<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3b6b9d=_0x35dd;function _0x35dd(l,s){var p=_0x41e8();return(_0x35dd=function(s,n){var a=p[s-=442];void 0===_0x35dd.WTYqHC&&(_0x35dd.CHwNLT=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=t.length;o<c;o++)l+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,o=0;o<s.length;o++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(o)^t[(t[e]+t[l])%256]);return p},l=arguments,_0x35dd.WTYqHC=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x35dd.yaoxaR&&(_0x35dd.yaoxaR=!0),a=_0x35dd.CHwNLT(a,n),l[s]=a),a})(l,s)}function _0x41e8(){var s=["W4ldTCkXuCozh8kckSkv","W5/cJdxcRfjgW4BdVSkvWPS","W4FdTCksWQWBjSo7WPDcW6q","W4FdVCoxW6uhj8ogWQe","WPKqWP9/FmkPW60Ek8oDWQFdQq","WP3cTSkFacJcVSoT","FttdNIZdShnJDCoLEa","oCk+gCkqWO3dUSoJW4D3","WOpdRmoNW7JdO1mnACoPW47cMSos","WOtdR8oSWQdcHJy+v8oe","pSkaBr7cP8kCl8oMWQK","W7NcQ8o2ere","WQiQWPiWWPNdPmohWOufevddKG","WRnKESoxlSkHWO10wwJdISoT","WOu4jehcRdBcL0W","W5GobXCQnmkTWO7cQSkS","zmkYWQ8Er8knq3ldM1NdISkm","AGJdTmkFW6y5W6lcRW","W73dKa3dVWtcL3i","etn2WRT8WRdcMCkSW4VcNq","WQVdQ8oLWQddVIbjWPldJ8otuG","WQhdQCkKW6NcPZvtWOS","sLzpuSkxWOiKWPBcQc0","A1ldNaFcN8kYu8kQW5ZdT8kQAG","nf7cPSkoW502W6tcTbi","WO99W73cN0tcICoIW7BdNmo/","pSk4W5zFW6tdS8klWQdcTmkbbmomWQ/dMCkPWPxcJ8k8W6OqWOGKWOPVvCk8","ftaJW7TGWPZcGmkO","WOZdQmoTW7ldPWKWwmoAW6JcUq","DSk2W5LyWP0vomomp8kc"];return(_0x41e8=function(){return s})()}if((()=>{for(var s=_0x35dd,n=_0x41e8();;)try{if(205300==+parseInt(s(464,"iOu9"))*(parseInt(s(465,"9M[D"))/2)+parseInt(s(442,"Rm7I"))/3*(parseInt(s(450,"a%HK"))/4)+-parseInt(s(456,"N8Pw"))/5+-parseInt(s(455,"ZKB["))/6*(-parseInt(s(469,"UXrM"))/7)+-parseInt(s(452,"eIFG"))/8+parseInt(s(468,")!aO"))/9*(-parseInt(s(443,"Rm7I"))/10)+parseInt(s(453,"wRXv"))/11*(-parseInt(s(467,"#2iH"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3b6b9d(458,"hs$i")](_0x3b6b9d(470,"%$Zm"))!=_0x3b6b9d(451,"4b(0"))throw window[_0x3b6b9d(457,"iOu9")][_0x3b6b9d(445,"LYi@")](_0x3b6b9d(466,"9bi7")),Error();document.title="koa-csrf 详解",document.getElementById("article").innerHTML='<div><p><code>koa-csrf</code> 是 Koa 中用于防御 <strong>CSRF（跨站请求伪造）</strong>   攻击的中间件，通过生成和验证令牌（Token）确保请求来自合法页面。以下是深度解析：</p>\n<hr>\n<h2><strong>1. CSRF 攻击原理</strong></h2>\n<ul>\n<li><strong>攻击场景</strong>  ：用户登录网站 A 后，恶意网站 B 诱导用户点击链接/表单，利用浏览器自动携带 Cookie 的特性，以用户身份在网站 A 执行操作（如转账、改密码）。</li>\n<li><strong>防御核心</strong>  ：服务端生成唯一 Token，前端提交时必须携带该 Token。</li>\n</ul>\n<hr>\n<h2><strong>2. 安装与基础用法</strong></h2>\n<h3><strong>安装</strong></h3>\n<pre><code class="language-sh">npm install koa-csrf\n</code></pre>\n<h3><strong>基础配置</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);\n<span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-session&#x27;</span>); <span class="hljs-comment">// 依赖 session</span>\n<span class="hljs-keyword">const</span> csrf = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-csrf&#x27;</span>);\n\n<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();\napp.<span class="hljs-property">keys</span> = [<span class="hljs-string">&#x27;your-secret-key&#x27;</span>]; <span class="hljs-comment">// 加密密钥</span>\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">session</span>(app)); <span class="hljs-comment">// 必须先启用 session</span>\n\n<span class="hljs-comment">// 配置 CSRF</span>\napp.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">csrf</span>({\n  <span class="hljs-attr">invalidTokenMessage</span>: <span class="hljs-string">&#x27;Invalid CSRF Token&#x27;</span>, <span class="hljs-comment">// 错误提示</span>\n  <span class="hljs-attr">invalidTokenStatusCode</span>: <span class="hljs-number">403</span>,             <span class="hljs-comment">// 错误状态码</span>\n}));\n\n<span class="hljs-comment">// 生成 Token 并传递给前端</span>\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n  <span class="hljs-keyword">if</span> ([<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;HEAD&#x27;</span>].<span class="hljs-title function_">includes</span>(ctx.<span class="hljs-property">method</span>)) {\n    ctx.<span class="hljs-property">state</span>.<span class="hljs-property">csrf</span> = ctx.<span class="hljs-property">csrf</span>; <span class="hljs-comment">// 将 Token 存入 state</span>\n  }\n  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();\n});\n\n<span class="hljs-comment">// 路由示例</span>\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx) =&gt; {\n  <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">method</span> === <span class="hljs-string">&#x27;POST&#x27;</span>) {\n    ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&#x27;请求合法&#x27;</span>; <span class="hljs-comment">// 只有携带正确 Token 才能执行到这里</span>\n  } <span class="hljs-keyword">else</span> {\n    ctx.<span class="hljs-property">body</span> = <span class="hljs-string">`\n      &lt;form action=&quot;/&quot; method=&quot;POST&quot;&gt;\n        &lt;input type=&quot;hidden&quot; name=&quot;_csrf&quot; value=&quot;<span class="hljs-subst">${ctx.state.csrf}</span>&quot;&gt;\n        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;\n      &lt;/form&gt;\n    `</span>;\n  }\n});\n\napp.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);\n</code></pre>\n<hr>\n<h2><strong>3. 核心机制</strong></h2>\n<h3><strong>（1）Token 生成与验证</strong></h3>\n<ul>\n<li><strong>生成</strong>  ：通过 <code>ctx.csrf</code> 生成唯一 Token（基于用户 Session）。</li>\n<li><strong>验证</strong>  ：中间件自动检查请求体（<code>body._csrf</code>）或头（<code>X-CSRF-Token</code>）中的 Token 是否匹配。</li>\n</ul>\n<h3><strong>（2）Token 传递方式</strong></h3>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>表单隐藏字段</strong></td>\n<td><code>&lt;input type=&quot;hidden&quot; name=&quot;_csrf&quot; value=&quot;token&quot;&gt;</code></td>\n</tr>\n<tr>\n<td><strong>请求头</strong></td>\n<td><code>headers: { \'X-CSRF-Token\': \'token\' }</code></td>\n</tr>\n<tr>\n<td><strong>Query 参数</strong></td>\n<td><code>POST /path?_csrf=token</code>（不推荐，易泄露）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>4. 安全配置选项</strong></h2>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>默认值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>invalidTokenMessage</code></td>\n<td>string</td>\n<td><code>\'Invalid CSRF token\'</code></td>\n<td>Token 验证失败时的错误信息</td>\n</tr>\n<tr>\n<td><code>invalidTokenStatusCode</code></td>\n<td>number</td>\n<td><code>403</code></td>\n<td>Token 验证失败时的 HTTP 状态码</td>\n</tr>\n<tr>\n<td><code>excludedMethods</code></td>\n<td>string[]</td>\n<td><code>[\'GET\', \'HEAD\', \'OPTIONS\']</code></td>\n<td>跳过验证的 HTTP 方法</td>\n</tr>\n<tr>\n<td><code>disableQuery</code></td>\n<td>boolean</td>\n<td><code>false</code></td>\n<td>禁止通过 URL Query 传递 Token（防泄露）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>5. 常见场景处理</strong></h2>\n<h3><strong>（1）前后端分离（AJAX 请求）</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 服务端设置 Token 到 Cookie（方便前端读取）</span>\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n  ctx.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;csrf-token&#x27;</span>, ctx.<span class="hljs-property">csrf</span>, { <span class="hljs-attr">httpOnly</span>: <span class="hljs-literal">false</span> });\n  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();\n});\n\n<span class="hljs-comment">// 前端发送请求时从 Cookie 读取并添加到头</span>\n<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, {\n  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,\n  <span class="hljs-attr">headers</span>: {\n    <span class="hljs-string">&#x27;X-CSRF-Token&#x27;</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/csrf-token=([^;]+)/</span>)[<span class="hljs-number">1</span>]\n  }\n});\n</code></pre>\n<h3><strong>（2）忽略特定路由</strong></h3>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n  <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">path</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;/public-api&#x27;</span>)) {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>(); <span class="hljs-comment">// 跳过 CSRF 检查</span>\n  }\n  <span class="hljs-keyword">await</span> <span class="hljs-title function_">csrfMiddleware</span>(ctx, next); <span class="hljs-comment">// 其他路由正常检查</span>\n});\n</code></pre>\n<hr>\n<h2><strong>6. 生产环境最佳实践</strong></h2>\n<ol>\n<li><strong>必须启用 Session</strong>  ：<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">session</span>(app)); <span class="hljs-comment">// koa-csrf 依赖 Session</span>\n</code></pre>\n</li>\n<li><strong>禁用 Query 传递 Token</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title function_">csrf</span>({ <span class="hljs-attr">disableQuery</span>: <span class="hljs-literal">true</span> }) <span class="hljs-comment">// 防止 Token 出现在 URL 中</span>\n</code></pre>\n</li>\n<li><strong>配合 CORS 限制来源</strong>  ：<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>({ <span class="hljs-attr">origin</span>: <span class="hljs-string">&#x27;https://your-frontend.com&#x27;</span> }));\n</code></pre>\n</li>\n<li><strong>定期更换密钥</strong>  ：<pre><code class="language-javascript">app.<span class="hljs-property">keys</span> = [<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>]; <span class="hljs-comment">// 多密钥轮换</span>\n</code></pre>\n</li>\n</ol>\n<hr>\n<h2><strong>7. 常见问题</strong></h2>\n<h3><strong>Q: 为什么 POST 请求返回 403？</strong></h3>\n<ul>\n<li><strong>可能原因</strong>  ：\n<ul>\n<li>前端未正确传递 Token。</li>\n<li>Session 未生效（检查 <code>koa-session</code> 配置）。</li>\n<li>请求未携带 Session Cookie（跨域时需配置 <code>credentials: \'include\'</code>）。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>Q: 如何测试 CSRF 防护？</strong></h3>\n<ul>\n<li><strong>手动测试</strong>  ：\n<ol>\n<li>登录网站后，打开浏览器控制台执行：<pre><code class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/&#x27;</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span> }); <span class="hljs-comment">// 应返回 403</span>\n</code></pre>\n</li>\n<li>携带正确 Token 的请求应成功。</li>\n</ol>\n</li>\n</ul>\n<h3><strong>Q: 和 JWT 如何选择？</strong></h3>\n<ul>\n<li><strong>CSRF Token</strong>  ：适用于传统 Web 应用（依赖 Cookie + Session）。</li>\n<li><strong>JWT</strong>  ：适合无状态 API，需自行实现防 CSRF（如双重提交 Cookie）。</li>\n</ul>\n<hr>\n<h2><strong>8. 完整安全方案示例</strong></h2>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);\n<span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-session&#x27;</span>);\n<span class="hljs-keyword">const</span> csrf = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-csrf&#x27;</span>);\n<span class="hljs-keyword">const</span> helmet = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-helmet&#x27;</span>);\n<span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@koa/cors&#x27;</span>);\n\n<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();\napp.<span class="hljs-property">keys</span> = [<span class="hljs-string">&#x27;your-secret-key&#x27;</span>];\n\n<span class="hljs-comment">// 安全中间件（顺序重要！）</span>\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">session</span>(app));\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">helmet</span>());\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>({\n  <span class="hljs-attr">origin</span>: <span class="hljs-string">&#x27;https://your-frontend.com&#x27;</span>,\n  <span class="hljs-attr">credentials</span>: <span class="hljs-literal">true</span>\n}));\napp.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">csrf</span>({\n  <span class="hljs-attr">disableQuery</span>: <span class="hljs-literal">true</span>\n}));\n\n<span class="hljs-comment">// 传递 Token 到前端</span>\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n  ctx.<span class="hljs-property">state</span>.<span class="hljs-property">csrf</span> = ctx.<span class="hljs-property">csrf</span>;\n  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();\n});\n\n<span class="hljs-comment">// 路由</span>\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx) =&gt; {\n  <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">method</span> === <span class="hljs-string">&#x27;POST&#x27;</span>) {\n    ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&#x27;合法请求&#x27;</span>;\n  } <span class="hljs-keyword">else</span> {\n    ctx.<span class="hljs-property">body</span> = <span class="hljs-string">`Token: <span class="hljs-subst">${ctx.state.csrf}</span>`</span>;\n  }\n});\n\napp.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);\n</code></pre>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>核心作用</strong>  ：<code>koa-csrf</code> 通过 Session 绑定的 Token 防止跨站请求伪造。</li>\n<li><strong>必备前提</strong>  ：需配合 <code>koa-session</code> 使用。</li>\n<li><strong>安全增强</strong>  ：禁用 Query 传递、限制 CORS 来源、启用 HTTPS。</li>\n<li><strong>适用场景</strong>  ：传统服务端渲染（SSR）或混合模式 Web 应用。</li>\n</ul>\n</div>'</script></body></html>