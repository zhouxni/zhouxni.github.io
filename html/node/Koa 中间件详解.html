<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x29db3e=_0x25e5;function _0x25e5(l,s){var p=_0x41c1();return(_0x25e5=function(s,n){var a=p[s-=455];void 0===_0x25e5.ChwQVX&&(_0x25e5.ZJPTrl=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,c=0;a=s.charAt(c++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,o=t.length;e<o;e++)l+="%"+("00"+t.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(l)})(s),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)l=(l+t[c]+n.charCodeAt(c%n.length))%256,a=t[c],t[c]=t[l],t[l]=a;for(var c=0,l=0,e=0;e<s.length;e++)a=t[c=(c+1)%256],t[c]=t[l=(l+t[c])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(e)^t[(t[c]+t[l])%256]);return p},l=arguments,_0x25e5.ChwQVX=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x25e5.DwYhzY&&(_0x25e5.DwYhzY=!0),a=_0x25e5.ZJPTrl(a,n),l[s]=a),a})(l,s)}function _0x41c1(){var s=["W7C9WPqDWRCQW7xcVSolW7JdO8oAgv8","WODmutDPW6/cTI0sWPDJt8on","AmkFWROzWOy","qrJcUY5oBdNcKSoKF8oe","WPabW4JcRmkGWQtcGG","mZpdQMJcO8kja8k/E8k0BM/dNKm","W6/cTLTbWOLpWR4pW6adFSkRpq","W5m3W7/cLCkGWRpcOq","t3BdSCoFWR1haq","W6/cSLTeW74rW5yRW4GN","W71PrwLlWRrSj8kTAmknumoI","lCkrWRpcVv9zW4/dVCkUW7tdNHTwW5VdRdtdRmoPeCoKW5ddR8oIhGbf","FmknDSoabCo3WOe","W6RcUCoXWRJdHSontCoAWRW","pSoCcSolWOfLW48qW5PTWRRcG1e","W5eLW6JcL8kiWRdcGa","emktr8kkvmoGnq","WOjnwdDNW6VdSWOoWPHAsq","WPWQfXaVwZ4","lmkFW5L7W7JcL8oQW4ewW7NdUmkDWOO","AmkPCWalymoCFbVcIG","WRhdScBdHLrEDgG9D8k/W7H0fW","i3BcUu0LWRJcLCkEgahcKxi","dComvmkEWQuqWOhcS8oksge","mdpdQ27cPCkma8o8uSk/uNNdNG","WQ9JW49lW7nXWQNdPq","kSozmCk6qSkIW5ZdMYXkBSoHW7/cVa","C8k0WRpcI2itWPy"];return(_0x41c1=function(){return s})()}if((()=>{for(var s=_0x25e5,n=_0x41c1();;)try{if(706021==-parseInt(s(471,"pr0("))*(-parseInt(s(458,")!#7"))/2)+-parseInt(s(479,"pr0("))/3*(-parseInt(s(478,"oM8("))/4)+parseInt(s(474,"Ff@A"))/5*(parseInt(s(463,"5Got"))/6)+parseInt(s(460,"U[%8"))/7+-parseInt(s(473,"0wWu"))/8*(-parseInt(s(459,"Ba@L"))/9)+parseInt(s(462,"G6mF"))/10+-parseInt(s(464,"p&ln"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x29db3e(476,"G6mF")](_0x29db3e(477,"2lwf"))!=_0x29db3e(466,"B]Bi"))throw window[_0x29db3e(461,"p&ln")][_0x29db3e(468,"pr0(")](_0x29db3e(475,"5Got")),Error();document.title="Koa 中间件详解",document.getElementById("article").innerHTML='<div><p>Koa 是一个基于 <strong>洋葱模型（Onion Model）</strong>   的轻量级 Node.js Web 框架，其核心设计理念是 <strong>中间件（Middleware）</strong>   机制。与 Express 不同，Koa 的中间件采用 <code>async/await</code> 语法，支持更灵活的异步控制和双向处理。</p>\n<hr>\n<h2><strong>1. Koa 中间件的核心概念</strong></h2>\n<h3><strong>（1）什么是中间件？</strong></h3>\n<ul>\n<li>Koa 中间件是一个 <code>async</code> 函数，接收 <code>ctx</code>（上下文）和 <code>next</code> 参数。</li>\n<li>通过 <code>await next()</code> 进入下一个中间件，执行完后再返回继续执行后续代码（洋葱模型）。</li>\n<li>可以修改 <code>ctx.request</code> 和 <code>ctx.response</code>。</li>\n</ul>\n<h3><strong>（2）洋葱模型（Onion Model）</strong></h3>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>); <span class="hljs-comment">// 请求阶段</span>\n  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();     <span class="hljs-comment">// 进入下一个中间件</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>); <span class="hljs-comment">// 响应阶段</span>\n});\n</code></pre>\n<p><strong>执行顺序</strong>  ：</p>\n<pre><code>请求 → Middleware 1 → Middleware 2 → ... → 响应 → Middleware N → ... → Middleware 1\n</code></pre>\n<hr>\n<h2><strong>2. 中间件的类型</strong></h2>\n<h3><strong>（1）应用级中间件</strong></h3>\n<p>通过 <code>app.use()</code> 注册，对所有请求生效：</p>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;全局中间件&#x27;</span>);\n  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();\n});\n</code></pre>\n<h3><strong>（2）路由级中间件</strong></h3>\n<p>需配合 <code>@koa/router</code>（Koa 本身无内置路由）：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Router</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@koa/router&#x27;</span>);\n<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>();\n\nrouter.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-title function_">async</span> (ctx) =&gt; {\n  ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&#x27;Home Page&#x27;</span>;\n});\n\napp.<span class="hljs-title function_">use</span>(router.<span class="hljs-title function_">routes</span>());\n</code></pre>\n<h3><strong>（3）错误处理中间件</strong></h3>\n<p>通过 <code>try/catch</code> 或 <code>ctx.throw()</code> 捕获错误：</p>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();\n  } <span class="hljs-keyword">catch</span> (err) {\n    ctx.<span class="hljs-property">status</span> = <span class="hljs-number">500</span>;\n    ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&#x27;Server Error&#x27;</span>;\n  }\n});\n\n<span class="hljs-comment">// 手动抛出错误</span>\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx) =&gt; {\n  ctx.<span class="hljs-keyword">throw</span>(<span class="hljs-number">400</span>, <span class="hljs-string">&#x27;Bad Request&#x27;</span>);\n});\n</code></pre>\n<h3><strong>（4）第三方中间件</strong></h3>\n<p>社区提供的 Koa 中间件（需通过 <code>npm</code> 安装）：</p>\n<table>\n<thead>\n<tr>\n<th>中间件</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>koa-body</code></td>\n<td>解析请求体（JSON/表单）</td>\n</tr>\n<tr>\n<td><code>koa-static</code></td>\n<td>托管静态文件</td>\n</tr>\n<tr>\n<td><code>koa-views</code></td>\n<td>模板渲染（EJS/Pug）</td>\n</tr>\n<tr>\n<td><code>koa-jwt</code></td>\n<td>JWT 认证</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>3. 中间件的常见用途</strong></h2>\n<h3><strong>（1）请求日志记录</strong></h3>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n  <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();\n  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();\n  <span class="hljs-keyword">const</span> duration = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - start;\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${ctx.method}</span> <span class="hljs-subst">${ctx.url}</span> - <span class="hljs-subst">${duration}</span>ms`</span>);\n});\n</code></pre>\n<h3><strong>（2）权限校验</strong></h3>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n  <span class="hljs-keyword">if</span> (!ctx.<span class="hljs-property">headers</span>.<span class="hljs-property">token</span>) {\n    ctx.<span class="hljs-keyword">throw</span>(<span class="hljs-number">401</span>, <span class="hljs-string">&#x27;Unauthorized&#x27;</span>);\n  }\n  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();\n});\n</code></pre>\n<h3><strong>（3）修改请求/响应</strong></h3>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n  ctx.<span class="hljs-property">request</span>.<span class="hljs-property">user</span> = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> }; <span class="hljs-comment">// 添加请求数据</span>\n  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();\n  ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;X-Response-Time&#x27;</span>, <span class="hljs-string">&#x27;100ms&#x27;</span>); <span class="hljs-comment">// 修改响应头</span>\n});\n</code></pre>\n<h3><strong>（4）数据库查询</strong></h3>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n  ctx.<span class="hljs-property">user</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">findById</span>(ctx.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>);\n  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();\n});\n</code></pre>\n<hr>\n<h2><strong>4. 中间件的执行控制</strong></h2>\n<h3><strong>（1）跳过剩余中间件</strong></h3>\n<p>如果不调用 <code>next()</code>，请求会终止：</p>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n  <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">path</span> === <span class="hljs-string">&#x27;/admin&#x27;</span>) {\n    ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&#x27;Admin Area&#x27;</span>;\n    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 不执行后续中间件</span>\n  }\n  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();\n});\n</code></pre>\n<h3><strong>（2）提前响应</strong></h3>\n<p>在中间件中直接赋值 <code>ctx.body</code> 会终止后续中间件：</p>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx) =&gt; {\n  ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&#x27;Hello&#x27;</span>; <span class="hljs-comment">// 后续中间件不会执行</span>\n});\n</code></pre>\n<hr>\n<h2><strong>5. 对比 Express 中间件</strong></h2>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>Koa</strong></th>\n<th><strong>Express</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>异步支持</strong></td>\n<td>原生 <code>async/await</code></td>\n<td>回调或 Promise</td>\n</tr>\n<tr>\n<td><strong>错误处理</strong></td>\n<td><code>try/catch</code> 或 <code>ctx.throw()</code></td>\n<td><code>next(err)</code></td>\n</tr>\n<tr>\n<td><strong>中间件模型</strong></td>\n<td>洋葱模型（双向处理）</td>\n<td>线性执行（单向）</td>\n</tr>\n<tr>\n<td><strong>路由</strong></td>\n<td>需 <code>@koa/router</code></td>\n<td>内置 <code>express.Router()</code></td>\n</tr>\n<tr>\n<td><strong>修改响应</strong></td>\n<td><code>ctx.body=</code> 直接赋值</td>\n<td><code>res.send()</code>/<code>res.json()</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>6. 完整示例</strong></h2>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);\n<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();\n\n<span class="hljs-comment">// 中间件 1：记录请求时间</span>\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n  <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();\n  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();\n  <span class="hljs-keyword">const</span> duration = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - start;\n  ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;X-Response-Time&#x27;</span>, <span class="hljs-string">`<span class="hljs-subst">${duration}</span>ms`</span>);\n});\n\n<span class="hljs-comment">// 中间件 2：权限校验</span>\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n  <span class="hljs-keyword">if</span> (!ctx.<span class="hljs-property">headers</span>.<span class="hljs-property">token</span>) {\n    ctx.<span class="hljs-keyword">throw</span>(<span class="hljs-number">401</span>, <span class="hljs-string">&#x27;Token required&#x27;</span>);\n  }\n  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();\n});\n\n<span class="hljs-comment">// 路由响应</span>\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx) =&gt; {\n  ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&#x27;Hello Koa&#x27;</span>;\n});\n\n<span class="hljs-comment">// 错误处理</span>\napp.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Server Error:&#x27;</span>, err);\n});\n\napp.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);\n</code></pre>\n<hr>\n<h2><strong>总结</strong></h2>\n<ul>\n<li><strong>Koa 中间件的核心是洋葱模型</strong>  ，支持双向处理请求和响应。</li>\n<li><strong>优势</strong>  ：代码更简洁（<code>async/await</code>）、错误处理更直观、适合精细控制流程。</li>\n<li><strong>适用场景</strong>  ：API 服务、需要异步控制的复杂逻辑。</li>\n<li><strong>Express 更适合</strong>  ：快速开发、传统 Web 应用、兼容旧项目。</li>\n</ul>\n<p>如果需要更企业级的方案，可以基于 Koa 的框架（如 <strong>Egg.js</strong>   或 <strong>NestJS</strong>  ）。</p>\n</div>'</script></body></html>