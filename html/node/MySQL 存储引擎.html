<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x449699=_0x14df;function _0x14df(r,n){var l=_0x13cb();return(_0x14df=function(n,s){var t=l[n-=242];void 0===_0x14df.aVmezz&&(_0x14df.WGeiaa=function(n,s){var t,o=[],r=0,l="";for(n=(n=>{for(var s,t,o="",r="",l=0,d=0;t=n.charAt(d++);~t&&(s=l%4?64*s+t:t,l++%4)&&(o+=String.fromCharCode(255&s>>(-2*l&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var a=0,e=o.length;a<e;a++)r+="%"+("00"+o.charCodeAt(a).toString(16)).slice(-2);return decodeURIComponent(r)})(n),d=0;d<256;d++)o[d]=d;for(d=0;d<256;d++)r=(r+o[d]+s.charCodeAt(d%s.length))%256,t=o[d],o[d]=o[r],o[r]=t;for(var d=0,r=0,a=0;a<n.length;a++)t=o[d=(d+1)%256],o[d]=o[r=(r+o[d])%256],o[r]=t,l+=String.fromCharCode(n.charCodeAt(a)^o[(o[d]+o[r])%256]);return l},r=arguments,_0x14df.aVmezz=!0);var n=n+l[0],o=r[n];return o?t=o:(void 0===_0x14df.fIcfbs&&(_0x14df.fIcfbs=!0),t=_0x14df.WGeiaa(t,s),r[n]=t),t})(r,n)}if((()=>{for(var n=_0x14df,s=_0x13cb();;)try{if(728030==-parseInt(n(255,"1t!3"))*(parseInt(n(264,"4$aS"))/2)+parseInt(n(263,"fp$^"))/3+-parseInt(n(265,"cI$h"))/4*(-parseInt(n(257,"e[Wq"))/5)+-parseInt(n(259,"nYsX"))/6*(parseInt(n(245,"FWhf"))/7)+-parseInt(n(268,"P4dM"))/8+-parseInt(n(256,"P4dM"))/9+parseInt(n(266,"(#cM"))/10*(parseInt(n(242,"AE%J"))/11))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x449699(254,"H]hR")](_0x449699(243,"ZCIC"))!=_0x449699(261,"cI$h"))throw window[_0x449699(258,"ZCIC")][_0x449699(249,"w&O(")](_0x449699(269,"k))(")),Error();function _0x13cb(){var n=["x8oHWQKgWRxcUSorW5b4dCoh","FZldNcJcPcJcUIi","WODEBCozaZ03WOdcHmo9W7acCG","rCkJW6FdRr16iMP8W6XphCoO","W5nhzCkSrq","W6JdH2rYWRhcQCojWONcKG","CcKZbZbVW4pcVNKXsaNcKq","W41+cJFdGhucq2JcISks","WPiejSoRudevW7tcQCkq","FHLupGybE2f/WPK","xCoUWQrMnSoimZG","ychcQmk9nCkFW6NcJSoFW6vQWOXF","iMJcOYvNW6lcJ8oSbmkRc29lnLK2rmkRW4egW7vPzSo+nvm","xmkEW4tdH8kuDYOTDLBcLa","uJ7dNcZcOZlcNIKq","WPVdVmoveZXfWOhdH0hdRSoc","xLvlehLXFYS","W47dGCoWvM0rW6ThnSo0","hmoKWQiqWPe+fCoEW48WWQe","W7SDomktaCkUu2G3lG","ggdcISk1W7tcVCof","CIK1ad5OW4xcGKqJvJJcHG","B0u7uCoeW4CWWQazWR1o","iMZcIhNdPxxdOhGXW4WoWOuvWPS","W74ApSkuxSoEmLmzmSoTWOldIq","WRBcUmoHCLldNLK","W5ickLZcPCkylmoFEa","zshcQCk+m8ksW67dI8ocW5rNWPvGba"];return(_0x13cb=function(){return n})()}document.title="MySQL 存储引擎",document.getElementById("article").innerHTML='<div><p>MySQL 的存储引擎是数据库底层用于<strong>管理数据存储、索引、事务等核心功能</strong>   的组件，不同存储引擎有不同的特性，适用于不同业务场景。选择合适的存储引擎对性能、可靠性和功能支持至关重要。以下是 MySQL 中主流存储引擎的详细解析：</p>\n<h3>一、存储引擎的基本概念</h3>\n<p>存储引擎（Storage Engine）是 MySQL 的核心组件之一，负责：</p>\n<ul>\n<li>数据的物理存储格式（如文件结构）；</li>\n<li>索引的实现方式（如 B+ 树、哈希）；</li>\n<li>事务支持、锁机制、并发控制；</li>\n<li>数据完整性约束（如外键）。</li>\n</ul>\n<p>MySQL 是“插件式存储引擎”架构，可根据表的需求单独指定引擎（一张表一个引擎），默认使用 <strong>InnoDB</strong>   （MySQL 5.5+ 起）。</p>\n<h3>二、主流存储引擎特性对比</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>InnoDB</th>\n<th>MyISAM</th>\n<th>Memory</th>\n<th>Archive</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>事务支持</td>\n<td>支持（ACID）</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>外键约束</td>\n<td>支持</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>索引类型</td>\n<td>B+ 树（聚簇索引）</td>\n<td>B+ 树（非聚簇索引）</td>\n<td>哈希/BTREE</td>\n<td>无（仅支持插入查询）</td>\n</tr>\n<tr>\n<td>锁机制</td>\n<td>行级锁 + 表级锁</td>\n<td>表级锁</td>\n<td>表级锁</td>\n<td>行级锁（仅插入）</td>\n</tr>\n<tr>\n<td>存储文件</td>\n<td>.ibd（数据+索引）</td>\n<td>.MYD（数据）+.MYI（索引）</td>\n<td>内存中（重启丢失）</td>\n<td>.ARZ（压缩存储）</td>\n</tr>\n<tr>\n<td>崩溃恢复</td>\n<td>支持（通过 redo log）</td>\n<td>不支持</td>\n<td>不支持（数据丢失）</td>\n<td>支持（有限）</td>\n</tr>\n<tr>\n<td>全文索引</td>\n<td>支持（5.6+）</td>\n<td>支持</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>空间数据支持</td>\n<td>支持（GIS）</td>\n<td>支持</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>事务、高并发、完整性</td>\n<td>读多写少、全文索引</td>\n<td>临时数据、缓存</td>\n<td>归档日志、历史数据</td>\n</tr>\n</tbody>\n</table>\n<h3>三、核心存储引擎详解</h3>\n<h4>1. InnoDB（默认引擎，最常用）</h4>\n<p>InnoDB 是 MySQL 推荐的存储引擎，专注于<strong>事务支持、数据完整性和高并发</strong>   ，是绝大多数业务的首选。</p>\n<p><strong>核心特性</strong>   ：</p>\n<ul>\n<li><strong>事务支持</strong>   ：完全遵循 ACID 特性，支持 <code>COMMIT</code>/<code>ROLLBACK</code>，通过 <strong>MVCC（多版本并发控制）</strong>   实现高并发读写。</li>\n<li><strong>行级锁</strong>   ：仅锁定修改的行，而非整个表，大幅提升多用户并发操作效率（如秒杀场景）。</li>\n<li><strong>聚簇索引</strong>   ：数据与主键索引存储在一起（索引即数据），查询主键时效率极高。</li>\n<li><strong>外键约束</strong>   ：支持 <code>FOREIGN KEY</code>，保证数据参照完整性。</li>\n<li><strong>崩溃恢复</strong>   ：通过 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）实现崩溃后的数据恢复。</li>\n<li><strong>自适应哈希索引</strong>   ：自动为热点数据创建哈希索引，加速等值查询。</li>\n</ul>\n<p><strong>适用场景</strong>   ：</p>\n<ul>\n<li>电商订单、支付系统（需事务和数据一致性）；</li>\n<li>高并发读写业务（如用户中心、商品详情）；</li>\n<li>需要外键约束的关联表（如用户-订单-订单明细）。</li>\n</ul>\n<p><strong>创建示例</strong>   ：</p>\n<pre><code class="language-sql"><span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-keyword">user</span> (\n  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,\n  name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)\n) ENGINE <span class="hljs-operator">=</span> InnoDB; <span class="hljs-comment">-- 可省略（默认）</span>\n</code></pre>\n<h4>2. MyISAM（传统引擎，逐步被淘汰）</h4>\n<p>MyISAM 是 MySQL 早期默认引擎，不支持事务，但在<strong>读密集场景</strong>   下性能较好。</p>\n<p><strong>核心特性</strong>   ：</p>\n<ul>\n<li><strong>不支持事务和外键</strong>   ：设计简单，性能开销低，但无法保证数据一致性。</li>\n<li><strong>表级锁</strong>   ：写入时锁定整个表，不适合高并发写操作（如频繁插入/更新）。</li>\n<li><strong>非聚簇索引</strong>   ：数据与索引分离存储，查询需先查索引再找数据。</li>\n<li><strong>全文索引</strong>   ：原生支持全文索引（比 InnoDB 更早支持，但功能较弱）。</li>\n<li><strong>压缩表</strong>   ：可通过 <code>myisampack</code> 工具压缩表，节省存储空间（仅支持读操作）。</li>\n</ul>\n<p><strong>局限性</strong>   ：</p>\n<ul>\n<li>崩溃后无法安全恢复（无事务日志）；</li>\n<li>写操作阻塞所有读写，并发性能差。</li>\n</ul>\n<p><strong>适用场景</strong>   ：</p>\n<ul>\n<li>只读或读多写少的静态数据（如博客文章、历史归档）；</li>\n<li>需要全文索引的场景（如简单搜索功能，可被 Elasticsearch 替代）。</li>\n</ul>\n<p><strong>创建示例</strong>   ：</p>\n<pre><code class="language-sql"><span class="hljs-keyword">CREATE TABLE</span> article (\n  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,\n  content TEXT\n) ENGINE <span class="hljs-operator">=</span> MyISAM;\n</code></pre>\n<h4>3. Memory（内存引擎，临时数据）</h4>\n<p>Memory 引擎将数据存储在<strong>内存中</strong>   ，访问速度极快，但数据随服务重启丢失。</p>\n<p><strong>核心特性</strong>   ：</p>\n<ul>\n<li><strong>内存存储</strong>   ：读写速度比磁盘引擎快 10-100 倍，适合临时计算。</li>\n<li><strong>支持哈希索引</strong>   ：等值查询（<code>WHERE id = 1</code>）效率极高，范围查询较差。</li>\n<li><strong>表级锁</strong>   ：并发写入性能有限。</li>\n<li><strong>数据易失</strong>   ：MySQL 重启或崩溃后，数据全部丢失（仅表结构保留）。</li>\n</ul>\n<p><strong>适用场景</strong>   ：</p>\n<ul>\n<li>临时数据缓存（如会话数据、计算中间结果）；</li>\n<li>高频访问的小表（如字典表、配置表）；</li>\n<li>测试环境的临时表。</li>\n</ul>\n<p><strong>创建示例</strong>   ：</p>\n<pre><code class="language-sql"><span class="hljs-keyword">CREATE TABLE</span> session (\n  session_id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">PRIMARY KEY</span>,\n  user_id <span class="hljs-type">INT</span>\n) ENGINE <span class="hljs-operator">=</span> Memory;\n</code></pre>\n<h4>4. Archive（归档引擎，日志存储）</h4>\n<p>Archive 引擎专为<strong>大量归档数据</strong>   设计，压缩率高，仅支持插入和查询。</p>\n<p><strong>核心特性</strong>   ：</p>\n<ul>\n<li><strong>高压缩率</strong>   ：数据存储时自动压缩，节省 70%-90% 空间。</li>\n<li><strong>只支持 INSERT 和 SELECT</strong>   ：不支持 UPDATE/DELETE，适合写后不修改的场景。</li>\n<li><strong>行级锁</strong>   ：插入时效率高，适合批量写入日志。</li>\n</ul>\n<p><strong>适用场景</strong>   ：</p>\n<ul>\n<li>日志存储（如访问日志、操作日志）；</li>\n<li>历史数据归档（如几年前的订单记录）。</li>\n</ul>\n<p><strong>创建示例</strong>   ：</p>\n<pre><code class="language-sql"><span class="hljs-keyword">CREATE TABLE</span> access_log (\n  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,\n  ip <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),\n  visit_time DATETIME\n) ENGINE <span class="hljs-operator">=</span> Archive;\n</code></pre>\n<h3>四、存储引擎的选择原则</h3>\n<ol>\n<li><strong>优先 InnoDB</strong>   ：绝大多数业务（尤其是需要事务、并发、完整性的场景）首选 InnoDB，它是 MySQL 官方推荐的“万能引擎”。</li>\n<li><strong>特殊场景特殊选择</strong>   ：\n<ul>\n<li>读多写少的静态数据 → MyISAM（逐渐被 InnoDB 替代）；</li>\n<li>临时缓存或高频访问小表 → Memory；</li>\n<li>日志归档 → Archive。</li>\n</ul>\n</li>\n<li><strong>避免混合引擎</strong>   ：关联查询的表建议使用同一引擎（如 InnoDB 外键不能关联 MyISAM 表）。</li>\n<li><strong>考虑迁移成本</strong>   ：MyISAM 可通过 <code>ALTER TABLE table_name ENGINE = InnoDB;</code> 迁移到 InnoDB，兼容性良好。</li>\n</ol>\n<h3>五、查看和修改存储引擎</h3>\n<ul>\n<li><strong>查看表的存储引擎</strong>   ：<pre><code class="language-sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">TABLE</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;表名&#x27;</span>; <span class="hljs-comment">-- 查看 Engine 字段</span>\n</code></pre>\n</li>\n<li><strong>修改表的存储引擎</strong>   ：<pre><code class="language-sql"><span class="hljs-keyword">ALTER TABLE</span> 表名 ENGINE <span class="hljs-operator">=</span> 新引擎; <span class="hljs-comment">-- 如 ALTER TABLE user ENGINE = InnoDB;</span>\n</code></pre>\n</li>\n</ul>\n<h3>总结</h3>\n<p>MySQL 存储引擎的选择直接影响性能和功能：</p>\n<ul>\n<li><strong>InnoDB</strong>   是“全能选手”，支持事务、行锁、外键，适合绝大多数业务；</li>\n<li>其他引擎（MyISAM、Memory、Archive）仅在特定场景（如只读、临时数据、归档）有优势。</li>\n</ul>\n<p>实际开发中，建议以 InnoDB 为主，仅在明确需要其他引擎特性时再考虑替代方案。</p>\n</div>'</script></body></html>