<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2341(){var s=["WQFdMCoWnc3dGrybW5xcSqhdOa","W7v0WORcICofd3z1","WPCZgmkLWPnHq8kQW7u0WQXrWR0","W65tWQpcNSkQsWldOga","s8oDhqmBAuldU8oycc7dRCks","WQD7w8oWW61EduddLCoCE8kp","W4PHtX4uqfqUFWFdIs/cLvRcV8kZWQ3dHSkiibDzC8kMWO3dMW","W77cHxGbW6tdNCkVk8kYWOPi","hSoCWQtcTfxcKmkMugDzk8ogyW","ph4Uj8k2ASorEa","j8oPWPrtW7VcVraRWODZWP04W5a","WPyiW7ldJmoVdHNdQN8XW4tdUq","ktRdNuNcTCkmgXdcP8k6","uCksWRlcPSoCpmkyuW","WPGBfZ9eW7ddUa","W4uvuwddJNxcTq","BmocW6RdKCkmvaTM","WPmScLzxq0iXBHVdLJVcIxS","W7BcSgRcOb8","WRBdMSkAtSo0W6xdHmo+W5f9","WO5dfJRcLYtdOCk0W5f4W5lcI8oD","iWlcT8kWhSkSW5uj","B8oeWOpcOmoQdJP3BCkwn8op","WRpdKmkrsmkWWQZcM8oGW6nUWOpcJSks","W5eovM1SDSkql3zCWPaAW4zH","WOzieZVcNv/cQCktW7v4W7y"];return(_0x2341=function(){return s})()}var _0x143d50=_0x4b3c;function _0x4b3c(r,s){var l=_0x2341();return(_0x4b3c=function(s,n){var a=l[s-=114];void 0===_0x4b3c.DkpDst&&(_0x4b3c.SGNHHe=function(s,n){var a,t=[],r=0,l="";for(s=(s=>{for(var n,a,t="",r="",l=0,p=0;a=s.charAt(p++);~a&&(n=l%4?64*n+a:a,l++%4)&&(t+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,e=t.length;o<e;o++)r+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(r)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)r=(r+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[r],t[r]=a;for(var p=0,r=0,o=0;o<s.length;o++)a=t[p=(p+1)%256],t[p]=t[r=(r+t[p])%256],t[r]=a,l+=String.fromCharCode(s.charCodeAt(o)^t[(t[p]+t[r])%256]);return l},r=arguments,_0x4b3c.DkpDst=!0);var s=s+l[0],t=r[s];return t?a=t:(void 0===_0x4b3c.ZYHEnD&&(_0x4b3c.ZYHEnD=!0),a=_0x4b3c.SGNHHe(a,n),r[s]=a),a})(r,s)}if((()=>{for(var s=_0x4b3c,n=_0x2341();;)try{if(812436==-parseInt(s(132,"vOKp"))+parseInt(s(134,"Id@("))/2*(-parseInt(s(121,"8IX^"))/3)+-parseInt(s(123,"5u[3"))/4+-parseInt(s(137,"lBN*"))/5*(parseInt(s(131,"o2PZ"))/6)+-parseInt(s(114,"&7dk"))/7*(-parseInt(s(120,"^nX!"))/8)+parseInt(s(115,"^nX!"))/9+parseInt(s(119,"xa1w"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x143d50(135,"OPtY")](_0x143d50(124,"vOKp"))!=_0x143d50(139,"*4fX"))throw window[_0x143d50(122,"h0!z")][_0x143d50(136,"^nX!")](_0x143d50(127,"Ll*q")),Error();document.title="Egg.js  全局中间件 和 配置方式区别",document.getElementById("article").innerHTML='<div><p>在 Egg.js 中，<strong>全局中间件</strong>  和<strong>配置方式</strong>  是两种不同的中间件管理机制，它们的区别主要体现在使用场景、控制粒度和执行顺序上。以下是详细对比：</p>\n<hr>\n<h3><strong>1. 核心区别对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>维度</strong></th>\n<th><strong>全局中间件</strong></th>\n<th><strong>配置方式中间件</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>定义位置</strong></td>\n<td>在 <code>app.js</code> 中通过 <code>app.use()</code> 直接注册</td>\n<td>在 <code>config/config.default.js</code> 中配置</td>\n</tr>\n<tr>\n<td><strong>执行顺序</strong></td>\n<td>最早执行（Egg 内核加载前）</td>\n<td>在全局中间件之后执行</td>\n</tr>\n<tr>\n<td><strong>启用方式</strong></td>\n<td>代码强制启用</td>\n<td>可动态配置 <code>enable: true/false</code></td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>必须优先执行的底层中间件</td>\n<td>业务相关、可插拔的中间件</td>\n</tr>\n<tr>\n<td><strong>典型示例</strong></td>\n<td>错误捕获、请求计时</td>\n<td>权限校验、参数解析</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>2. 技术实现差异</strong></h3>\n<h4><strong>(1) 全局中间件（Koa 风格）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// app.js</span>\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> {\n  <span class="hljs-comment">// 会最先执行的中间件（比 Egg 内置中间件更早）</span>\n  app.<span class="hljs-title function_">use</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-helmet&#x27;</span>)()); \n  app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n    <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();\n    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();\n    ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;X-Response-Time&#x27;</span>, <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now() - start}</span>ms`</span>);\n  });\n};\n</code></pre>\n<p><strong>特点</strong>  ：</p>\n<ul>\n<li>直接操作 Koa 实例</li>\n<li><strong>无法通过配置关闭</strong></li>\n<li>执行顺序最早（甚至早于 Egg 的内置中间件）</li>\n</ul>\n<h4><strong>(2) 配置方式中间件（Egg 风格）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// config/config.default.js</span>\n<span class="hljs-built_in">exports</span>.<span class="hljs-property">middleware</span> = [<span class="hljs-string">&#x27;compression&#x27;</span>, <span class="hljs-string">&#x27;errorHandler&#x27;</span>];\n\n<span class="hljs-comment">// 中间件配置</span>\n<span class="hljs-built_in">exports</span>.<span class="hljs-property">compression</span> = {\n  <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>,\n  <span class="hljs-attr">package</span>: <span class="hljs-string">&#x27;egg-compress&#x27;</span>\n};\n<span class="hljs-built_in">exports</span>.<span class="hljs-property">errorHandler</span> = {\n  <span class="hljs-attr">match</span>: <span class="hljs-string">&#x27;/api&#x27;</span> <span class="hljs-comment">// 仅对 /api 路由生效</span>\n};\n</code></pre>\n<p><strong>特点</strong>  ：</p>\n<ul>\n<li>通过配置文件管理</li>\n<li><strong>可动态启用/禁用</strong>  （<code>enable: false</code>）</li>\n<li>支持路由匹配（<code>match</code>/<code>ignore</code>）</li>\n<li>执行顺序可控（通过数组顺序调整）</li>\n</ul>\n<hr>\n<h3><strong>3. 执行顺序示意图</strong></h3>\n<pre><code>请求进入\n│\n├─ 全局中间件（app.use() 注册）\n│   ├─ koa-helmet\n│   └─ 自定义计时中间件\n│\n├─ Egg 内置核心中间件\n│   ├─ bodyParser\n│   └─ session\n│\n├─ 配置方式中间件（按 config.middleware 数组顺序）\n│   ├─ compression\n│   └─ errorHandler\n│\n└─ 路由处理\n</code></pre>\n<hr>\n<h3><strong>4. 如何选择？</strong></h3>\n<h4><strong>使用全局中间件当：</strong></h4>\n<ul>\n<li>需要处理 <strong>最底层的请求/响应</strong>  （如安全防护）</li>\n<li>中间件 <strong>必须无条件启用</strong>  （如全链路追踪）</li>\n<li>需要 <strong>比 Egg 内置中间件更早执行</strong></li>\n</ul>\n<h4><strong>使用配置方式当：</strong></h4>\n<ul>\n<li>中间件需要 <strong>按环境动态启用</strong>  （如开发环境禁用缓存）</li>\n<li>需要 <strong>精细的路由控制</strong>  （如只对 <code>/api</code> 生效）</li>\n<li>中间件 <strong>依赖 Egg 的扩展功能</strong>  （如 <code>ctx.service</code>）</li>\n</ul>\n<hr>\n<h3><strong>5. 混合使用示例</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// app.js → 全局中间件</span>\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> {\n  <span class="hljs-comment">// 安全相关（必须最早执行）</span>\n  app.<span class="hljs-title function_">use</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-helmet&#x27;</span>)());\n};\n\n<span class="hljs-comment">// config/config.default.js → 配置方式</span>\n<span class="hljs-built_in">exports</span>.<span class="hljs-property">middleware</span> = [\n  <span class="hljs-string">&#x27;ratelimit&#x27;</span>, <span class="hljs-comment">// 限流中间件</span>\n  <span class="hljs-string">&#x27;errorHandler&#x27;</span> \n];\n\n<span class="hljs-built_in">exports</span>.<span class="hljs-property">ratelimit</span> = {\n  <span class="hljs-attr">enable</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;production&#x27;</span>,\n  <span class="hljs-attr">redis</span>: { <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span> }\n};\n\n<span class="hljs-built_in">exports</span>.<span class="hljs-property">errorHandler</span> = {\n  <span class="hljs-attr">ignore</span>: [<span class="hljs-string">&#x27;/static&#x27;</span>] <span class="hljs-comment">// 静态资源不处理错误</span>\n};\n</code></pre>\n<hr>\n<h3><strong>6. 注意事项</strong></h3>\n<ol>\n<li><strong>避免功能冲突</strong>  ：全局中间件中的 <code>bodyParser</code> 会覆盖 Egg 内置的</li>\n<li><strong>顺序敏感性</strong>  ：全局中间件可能影响 Egg 内置功能（如 <code>ctx.body</code> 解析）</li>\n<li><strong>TypeScript 支持</strong>  ：配置方式中间件能自动生成类型提示（通过 <code>egg-ts-helper</code>）</li>\n</ol>\n<p>通过合理组合两种方式，可以既保持灵活性，又能确保关键中间件的可靠执行。</p>\n</div>'</script></body></html>