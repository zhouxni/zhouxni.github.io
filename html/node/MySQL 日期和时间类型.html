<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0xeb8f(d,s){var c=_0x2eb2();return(_0xeb8f=function(s,n){var e=c[s-=351];void 0===_0xeb8f.QNOthL&&(_0xeb8f.lUayVD=function(s,n){var e,o=[],d=0,c="";for(s=(s=>{for(var n,e,o="",d="",c=0,a=0;e=s.charAt(a++);~e&&(n=c%4?64*n+e:e,c++%4)&&(o+=String.fromCharCode(255&n>>(-2*c&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var l=0,t=o.length;l<t;l++)d+="%"+("00"+o.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(d)})(s),a=0;a<256;a++)o[a]=a;for(a=0;a<256;a++)d=(d+o[a]+n.charCodeAt(a%n.length))%256,e=o[a],o[a]=o[d],o[d]=e;for(var a=0,d=0,l=0;l<s.length;l++)e=o[a=(a+1)%256],o[a]=o[d=(d+o[a])%256],o[d]=e,c+=String.fromCharCode(s.charCodeAt(l)^o[(o[a]+o[d])%256]);return c},d=arguments,_0xeb8f.QNOthL=!0);var s=s+c[0],o=d[s];return o?e=o:(void 0===_0xeb8f.tALAoD&&(_0xeb8f.tALAoD=!0),e=_0xeb8f.lUayVD(e,n),d[s]=e),e})(d,s)}var _0x26922b=_0xeb8f;function _0x2eb2(){var s=["WQVcOSkgquXWnxzJoY46","hNbrtmoKWRaj","WPxdGJ3dR30sW6aufG","WPZcHmoDr8k4W4PIw8kBy8kTha","p3xcJfXLWQ3dIuHWzmkqWQG","l8k7WQJdPxLCxmkXWQqdWPy","nMjfWPldTmoZWOnTWPb/W6y","smokW5VcMwNcVmkQn8o4","k8kXWQ7dOhSDxmkpWRqHWQHl","vmkVWQ8IWPhdLmoMWQXVCL0","W7FcRH3dO0NcSMxdJe7dRmkU","AZTPW4DnWQSWW75rWQWxDa","WQ8xyKxcJXGnW6y","eSkwlM8CWRZcQCoNW64","s8k3WPhcQfxcLCkY","sSkhW5lcLCkGuKv6lG","WRmnCLFcGG","yMj6WQZdNmkAW7q","sCkiW5FdTmoYyeXjlmoKWQm","WRfJoJpcOCkBWRNdQmou","WQBdVv7cNGZcRu0","W6WcWOuBlZexW71xuKK","W4eXAwtdQSoyWORdHmoAv8o7WPC","W4eXydlcQmkXWPZdJSop","rCoQi8kIW7nGW5NdScBcSwRdMSoSdSkPW7FdSHfmWOSdkgFdISogW5u","h3n9FSooWOJcPmoYaa"];return(_0x2eb2=function(){return s})()}if((()=>{for(var s=_0xeb8f,n=_0x2eb2();;)try{if(104054==+parseInt(s(371,"%w*0"))*(parseInt(s(367,"ieEx"))/2)+-parseInt(s(375,"zt]E"))/3+-parseInt(s(368,"%w*0"))/4*(parseInt(s(352,"zd1h"))/5)+parseInt(s(362,"rbAd"))/6*(-parseInt(s(360,"ieEx"))/7)+parseInt(s(361,"^]Dj"))/8+parseInt(s(356,"fZy2"))/9+-parseInt(s(358,"^]Dj"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x26922b(373,"#M2H")](_0x26922b(372,"zt]E"))!=_0x26922b(369,"xyqu"))throw window[_0x26922b(365,"xyqu")][_0x26922b(354,"VHK4")](_0x26922b(351,"2hXF")),Error();document.title="MySQL 日期和时间类型",document.getElementById("article").innerHTML='<div><p>在 MySQL 中，日期和时间类型用于存储时间相关数据，不同类型在 <strong>存储空间</strong>   、<strong>取值范围</strong>   、<strong>精度</strong>   和 <strong>适用场景</strong>   上有明确差异。合理选择类型可减少存储空间、避免数据溢出，并确保时间计算的准确性。以下按「核心类型分类」「特性对比」「使用场景」「常见问题」展开详解。</p>\n<h2>一、MySQL 日期时间类型核心分类</h2>\n<p>MySQL 提供 5 种常用日期时间类型，覆盖从“日期”“时间”到“日期时间+时区”的全场景需求，核心区别在于是否包含时间、是否带时区、精度范围：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>格式</th>\n<th>字节数</th>\n<th>取值范围</th>\n<th>核心特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>DATE</code></td>\n<td><code>YYYY-MM-DD</code></td>\n<td>3</td>\n<td><code>1000-01-01</code> ~ <code>9999-12-31</code></td>\n<td>仅存储「日期」，无时间部分，适合生日、订单日期等。</td>\n</tr>\n<tr>\n<td><code>TIME</code></td>\n<td><code>HH:MM:SS</code></td>\n<td>3</td>\n<td><code>-838:59:59</code> ~ <code>838:59:59</code></td>\n<td>仅存储「时间」，支持负数（表示“过去的时间”）和超24小时（表示“持续时间”），适合时长、打卡时间点等。</td>\n</tr>\n<tr>\n<td><code>DATETIME</code></td>\n<td><code>YYYY-MM-DD HH:MM:SS</code></td>\n<td>5/8</td>\n<td><code>1000-01-01 00:00:00</code> ~ <code>9999-12-31 23:59:59</code></td>\n<td>存储「日期+时间」，无时区信息，依赖数据库服务器时间，适合订单创建时间、日志时间等。</td>\n</tr>\n<tr>\n<td><code>TIMESTAMP</code></td>\n<td><code>YYYY-MM-DD HH:MM:SS</code></td>\n<td>4</td>\n<td><code>1970-01-01 00:00:01</code> ~ <code>2038-01-19 03:14:07</code></td>\n<td>存储「日期+时间」，带时区自动转换（依赖服务器时区），支持自动填充（创建/更新时间），适合记录数据的“时间戳”场景。</td>\n</tr>\n<tr>\n<td><code>YEAR</code></td>\n<td><code>YYYY</code></td>\n<td>1</td>\n<td><code>1901</code> ~ <code>2155</code></td>\n<td>仅存储「年份」，占用空间最小，适合年份统计、历史数据等。</td>\n</tr>\n</tbody>\n</table>\n<h3>关键补充：精度与字节数细节</h3>\n<ul>\n<li><strong><code>DATETIME</code> 字节数</strong>   ：MySQL 5.6.4 及以上支持「微秒精度」（<code>DATETIME(f)</code>，<code>f</code> 为 0~6，代表微秒位数），此时字节数从 5 变为 8（如 <code>DATETIME(6)</code> 存储到微秒，占 8 字节）；</li>\n<li><strong><code>TIMESTAMP</code> 精度</strong>   ：同样支持微秒精度（<code>TIMESTAMP(f)</code>），字节数仍为 4（但取值范围不变，仍受 2038 年限制）；</li>\n<li><strong><code>TIME</code> 精度</strong>   ：支持毫秒/微秒精度（<code>TIME(f)</code>），如 <code>TIME(3)</code> 存储到毫秒（格式 <code>HH:MM:SS.sss</code>）。</li>\n</ul>\n<h2>二、各类型深度解析与使用场景</h2>\n<h3>1. <code>DATE</code>：仅日期，简洁高效</h3>\n<ul>\n<li><strong>格式</strong>   ：固定 <code>YYYY-MM-DD</code>（如 <code>2024-05-20</code>），插入时需符合格式（如 <code>\'20240520\'</code> 会自动转换为 <code>2024-05-20</code>）；</li>\n<li><strong>适用场景</strong>   ：仅需日期的场景，如用户生日（<code>birthday DATE</code>）、订单日期（<code>order_date DATE</code>）、节假日配置（<code>holiday_date DATE</code>）；</li>\n<li><strong>示例</strong>   ：<pre><code class="language-sql"><span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-keyword">user</span> (\n  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,\n  birthday <span class="hljs-type">DATE</span> <span class="hljs-comment">-- 存储生日，无时间</span>\n);\n<span class="hljs-keyword">INSERT INTO</span> <span class="hljs-keyword">user</span> (birthday) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;2000-01-01&#x27;</span>), (<span class="hljs-string">&#x27;20000101&#x27;</span>); <span class="hljs-comment">-- 两种格式均有效</span>\n</code></pre>\n</li>\n</ul>\n<h3>2. <code>TIME</code>：仅时间，支持特殊场景</h3>\n<ul>\n<li><strong>格式</strong>   ：<code>HH:MM:SS</code>（如 <code>14:30:00</code>），但支持两种特殊场景：\n<ul>\n<li><strong>超24小时</strong>   ：表示“持续时间”（如 <code>25:30:00</code> 代表 25小时30分钟）；</li>\n<li><strong>负数时间</strong>   ：表示“过去的时间”（如 <code>-02:00:00</code> 代表 2小时前）；</li>\n</ul>\n</li>\n<li><strong>适用场景</strong>   ：\n<ul>\n<li>时间点（如打卡时间 <code>checkin_time TIME</code>，存储 <code>09:00:00</code>）；</li>\n<li>时长（如视频时长 <code>video_duration TIME</code>，存储 <code>01:30:00</code> 代表 1小时30分钟）；</li>\n</ul>\n</li>\n<li><strong>示例</strong>   ：<pre><code class="language-sql"><span class="hljs-keyword">CREATE TABLE</span> clock_in (\n  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,\n  checkin_time <span class="hljs-type">TIME</span>, <span class="hljs-comment">-- 打卡时间点</span>\n  work_duration <span class="hljs-type">TIME</span> <span class="hljs-comment">-- 工作时长（如 &#x27;08:30:00&#x27; 代表 8.5小时）</span>\n);\n<span class="hljs-keyword">INSERT INTO</span> clock_in <span class="hljs-keyword">VALUES</span> (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;09:00:00&#x27;</span>, <span class="hljs-string">&#x27;08:30:00&#x27;</span>);\n<span class="hljs-keyword">INSERT INTO</span> clock_in <span class="hljs-keyword">VALUES</span> (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;18:00:00&#x27;</span>, <span class="hljs-string">&#x27;-01:00:00&#x27;</span>); <span class="hljs-comment">-- 1小时前</span>\n</code></pre>\n</li>\n</ul>\n<h3>3. <code>DATETIME</code>：日期+时间，无时区依赖</h3>\n<ul>\n<li><strong>核心特性</strong>   ：\n<ul>\n<li>不随数据库时区变化（如服务器时区从 UTC 改为 CST，存储的 <code>2024-05-20 14:30:00</code> 仍保持不变）；</li>\n<li>取值范围广（1000年~9999年），无 2038 年限制；</li>\n</ul>\n</li>\n<li><strong>适用场景</strong>   ：需精确记录“日期+时间”且不依赖时区的场景，如：\n<ul>\n<li>订单创建时间（<code>order_create_time DATETIME</code>）；</li>\n<li>文章发布时间（<code>article_publish_time DATETIME(3)</code>，带毫秒精度）；</li>\n</ul>\n</li>\n<li><strong>示例（带微秒精度）</strong>   ：<pre><code class="language-sql"><span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-keyword">order</span> (\n  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,\n  create_time DATETIME(<span class="hljs-number">6</span>) <span class="hljs-comment">-- 存储到微秒，如 &#x27;2024-05-20 14:30:00.123456&#x27;</span>\n);\n<span class="hljs-comment">-- 插入当前时间（带微秒）</span>\n<span class="hljs-keyword">INSERT INTO</span> <span class="hljs-keyword">order</span> (create_time) <span class="hljs-keyword">VALUES</span> (NOW(<span class="hljs-number">6</span>));\n</code></pre>\n</li>\n</ul>\n<h3>4. <code>TIMESTAMP</code>：日期+时间，带时区与自动填充</h3>\n<ul>\n<li><strong>核心特性（与 <code>DATETIME</code> 关键区别）</strong>   ：\n<ol>\n<li><strong>时区自动转换</strong>   ：存储时按 UTC 时间存储，查询时按服务器当前时区转换（如服务器时区为 CST，插入 <code>2024-05-20 14:30:00</code>，实际存储为 UTC 时间 <code>2024-05-20 06:30:00</code>，查询时仍显示 <code>14:30:00</code>）；</li>\n<li><strong>自动填充</strong>   ：支持 <code>DEFAULT CURRENT_TIMESTAMP</code>（创建时自动填当前时间）和 <code>ON UPDATE CURRENT_TIMESTAMP</code>（更新时自动更新时间），无需应用层维护；</li>\n<li><strong>2038年限制</strong>   ：取值范围仅到 <code>2038-01-19 03:14:07</code>（UTC），超过会报错；</li>\n</ol>\n</li>\n<li><strong>适用场景</strong>   ：\n<ul>\n<li>记录数据的“创建/更新时间戳”（如 <code>create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP</code>，<code>update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</code>）；</li>\n<li>跨时区服务的时间记录（如全球用户操作日志，依赖时区自动转换）；</li>\n</ul>\n</li>\n<li><strong>示例（自动填充）</strong>   ：<pre><code class="language-sql"><span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-keyword">user</span> (\n  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,\n  username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT NULL</span>,\n  create_time <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>, <span class="hljs-comment">-- 创建时自动填当前时间</span>\n  update_time <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-comment">-- 更新时自动更新</span>\n);\n<span class="hljs-comment">-- 插入时无需指定 create_time/update_time</span>\n<span class="hljs-keyword">INSERT INTO</span> <span class="hljs-keyword">user</span> (username) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;zhangsan&#x27;</span>);\n<span class="hljs-comment">-- 更新时 update_time 自动变为当前时间</span>\n<span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;lisi&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;\n</code></pre>\n</li>\n</ul>\n<h3>5. <code>YEAR</code>：仅年份，极致节省空间</h3>\n<ul>\n<li><strong>格式</strong>   ：<code>YYYY</code>（如 <code>2024</code>），插入时可简写（如 <code>24</code> 代表 <code>2024</code>，<code>99</code> 代表 <code>1999</code>，<code>00</code> 代表 <code>2000</code>）；</li>\n<li><strong>字节数</strong>   ：仅 1 字节（远小于 <code>DATE</code> 的 3 字节），适合大量年份数据存储；</li>\n<li><strong>适用场景</strong>   ：仅需年份的场景，如：\n<ul>\n<li>年度报表（<code>report_year YEAR</code>）；</li>\n<li>历史事件年份（<code>event_year YEAR</code>）；</li>\n</ul>\n</li>\n<li><strong>示例</strong>   ：<pre><code class="language-sql"><span class="hljs-keyword">CREATE TABLE</span> annual_report (\n  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,\n  report_year <span class="hljs-keyword">YEAR</span>, <span class="hljs-comment">-- 存储年份</span>\n  sales <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">-- 年度销售额</span>\n);\n<span class="hljs-keyword">INSERT INTO</span> annual_report (report_year, sales) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2024</span>, <span class="hljs-number">1000000.00</span>), (<span class="hljs-number">23</span>, <span class="hljs-number">950000.00</span>); <span class="hljs-comment">-- 23 自动转为 2023</span>\n</code></pre>\n</li>\n</ul>\n<h2>三、关键对比：<code>DATETIME</code> vs <code>TIMESTAMP</code></h2>\n<p>两者均存储“日期+时间”，但差异显著，选择错误可能导致数据问题（如 2038 年溢出、时区混乱），核心对比如下：</p>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th><code>DATETIME</code></th>\n<th><code>TIMESTAMP</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>取值范围</td>\n<td><code>1000-01-01</code> ~ <code>9999-12-31</code></td>\n<td><code>1970-01-01</code> ~ <code>2038-01-19</code>（UTC）</td>\n</tr>\n<tr>\n<td>时区依赖</td>\n<td>无（存储原始值）</td>\n<td>有（存储UTC，查询时转服务器时区）</td>\n</tr>\n<tr>\n<td>自动填充</td>\n<td>不支持（需手动或触发器）</td>\n<td>支持 <code>DEFAULT</code>/<code>ON UPDATE</code> 自动填充</td>\n</tr>\n<tr>\n<td>字节数</td>\n<td>5（无精度）/8（带微秒）</td>\n<td>4（无论是否带微秒）</td>\n</tr>\n<tr>\n<td>2038年问题</td>\n<td>无</td>\n<td>有（超过范围报错）</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>长期时间记录（如历史订单）</td>\n<td>短期时间戳（如创建/更新时间）</td>\n</tr>\n</tbody>\n</table>\n<h2>四、日期时间类型最佳实践</h2>\n<h3>1. 按场景选择类型，避免过度设计</h3>\n<ul>\n<li>仅日期 → <code>DATE</code>（如生日）；</li>\n<li>仅时间 → <code>TIME</code>（如时长）；</li>\n<li>日期+时间，长期存储 → <code>DATETIME</code>（如订单时间，避免 2038 问题）；</li>\n<li>日期+时间，需自动更新 → <code>TIMESTAMP</code>（如 create_time/update_time）；</li>\n<li>仅年份 → <code>YEAR</code>（如年度报表）。</li>\n</ul>\n<h3>2. 避免“字符串存储时间”</h3>\n<p>切勿用 <code>VARCHAR</code> 存储日期时间（如 <code>\'2024-05-20\'</code> 存为字符串），否则会导致：</p>\n<ul>\n<li>无法使用日期函数（如 <code>DATE_ADD</code>、<code>DATEDIFF</code>）；</li>\n<li>排序错误（如字符串排序 <code>\'2024-10-01\' &lt; \'2024-09-01\'</code>，实际日期相反）；</li>\n<li>占用空间更大（<code>VARCHAR(10)</code> 存日期占 10 字节，<code>DATE</code> 仅 3 字节）。</li>\n</ul>\n<h3>3. 处理 <code>TIMESTAMP</code> 的 2038 年问题</h3>\n<p>若业务需支持 2038 年后的时间，需替换 <code>TIMESTAMP</code> 为：</p>\n<ul>\n<li><code>DATETIME</code>（无 2038 限制，需手动处理时区和自动填充）；</li>\n<li><code>BIGINT</code>（存储毫秒级时间戳，如 <code>1716226200000</code> 代表 <code>2024-05-20 14:30:00</code>，需应用层转换格式）。</li>\n</ul>\n<h3>4. 明确时区配置</h3>\n<ul>\n<li>数据库服务器时区统一设为 <strong>UTC</strong>   （避免不同环境时区差异导致数据混乱）；</li>\n<li>若用 <code>TIMESTAMP</code>，需确保应用层与数据库时区一致（或依赖 <code>TIMESTAMP</code> 的自动转换）；</li>\n<li>查看/设置数据库时区：<pre><code class="language-sql"><span class="hljs-comment">-- 查看当前时区</span>\n<span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@time_zone</span>;\n<span class="hljs-comment">-- 设置为 UTC（临时生效，重启后失效）</span>\n<span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> time_zone <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;+00:00&#x27;</span>;\n</code></pre>\n</li>\n</ul>\n<h3>5. 合理使用精度</h3>\n<ul>\n<li>非必要不添加微秒精度（如普通订单时间无需到微秒，<code>DATETIME</code> 即可，节省 3 字节）；</li>\n<li>需精确计时的场景（如高频交易、日志埋点）再用 <code>DATETIME(6)</code> 或 <code>TIMESTAMP(6)</code>。</li>\n</ul>\n<h2>五、常见问题与避坑</h2>\n<h3>1. 插入日期时间报错“Invalid datetime value”</h3>\n<p>原因：插入值格式错误或超出类型范围，解决方案：</p>\n<ul>\n<li>格式统一为 <code>YYYY-MM-DD</code>（<code>DATE</code>）、<code>YYYY-MM-DD HH:MM:SS</code>（<code>DATETIME</code>/<code>TIMESTAMP</code>）；</li>\n<li>避免 <code>TIMESTAMP</code> 插入 2038 年后的时间（如 <code>2039-01-01</code> 会报错，需换 <code>DATETIME</code>）。</li>\n</ul>\n<h3>2. <code>TIMESTAMP</code> 时间查询显示错误</h3>\n<p>原因：数据库时区与应用层时区不一致，解决方案：</p>\n<ul>\n<li>统一数据库和应用层时区为 UTC；</li>\n<li>或查询时手动转换时区（如 <code>CONVERT_TZ(create_time, \'+00:00\', \'+08:00\')</code> 将 UTC 转为 CST）。</li>\n</ul>\n<h3>3. <code>YEAR</code> 插入 <code>00</code> 显示 <code>2000</code> 而非 <code>1900</code></h3>\n<p>原因：MySQL 对 <code>YEAR</code> 简写的规则是：<code>00</code>~<code>69</code> 代表 <code>2000</code>~<code>2069</code>，<code>70</code>~<code>99</code> 代表 <code>1970</code>~<code>1999</code>，解决方案：</p>\n<ul>\n<li>需插入 <code>1900</code> 时，显式写 <code>1900</code> 而非 <code>00</code>；</li>\n<li>避免简写，直接用 4 位年份插入（如 <code>2000</code> 而非 <code>00</code>）。</li>\n</ul>\n<h3>4. 日期计算用函数而非字符串拼接</h3>\n<p>正确做法：用 MySQL 内置日期函数（如 <code>DATE_ADD</code>、<code>DATEDIFF</code>），避免字符串操作：</p>\n<pre><code class="language-sql"><span class="hljs-comment">-- 错误：字符串拼接（易出错）</span>\n<span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;2024-05-20&#x27;</span> <span class="hljs-operator">+</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-number">1</span> <span class="hljs-keyword">DAY</span>; <span class="hljs-comment">-- 虽能运行，但不推荐</span>\n<span class="hljs-comment">-- 正确：用 DATE_ADD 函数</span>\n<span class="hljs-keyword">SELECT</span> DATE_ADD(<span class="hljs-string">&#x27;2024-05-20&#x27;</span>, <span class="hljs-type">INTERVAL</span> <span class="hljs-number">1</span> <span class="hljs-keyword">DAY</span>); <span class="hljs-comment">-- 结果 &#x27;2024-05-21&#x27;</span>\n\n<span class="hljs-comment">-- 计算两个日期差（天数）</span>\n<span class="hljs-keyword">SELECT</span> DATEDIFF(<span class="hljs-string">&#x27;2024-05-20&#x27;</span>, <span class="hljs-string">&#x27;2024-05-10&#x27;</span>); <span class="hljs-comment">-- 结果 10</span>\n</code></pre>\n<h2>总结</h2>\n<p>MySQL 日期时间类型的选择核心是「匹配业务场景」：</p>\n<ul>\n<li>追求兼容性和长期存储 → 选 <code>DATETIME</code>；</li>\n<li>需自动填充或跨时区 → 选 <code>TIMESTAMP</code>（注意 2038 限制）；</li>\n<li>仅日期/时间/年份 → 选 <code>DATE</code>/<code>TIME</code>/<code>YEAR</code>（节省空间）。</li>\n</ul>\n<p>同时需规避“字符串存时间”“忽视时区”“滥用精度”等常见问题，确保时间数据的准确性和性能。</p>\n</div>'</script></body></html>