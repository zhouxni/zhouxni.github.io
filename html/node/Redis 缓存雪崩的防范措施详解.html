<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x526d(e,s){var p=_0x1abd();return(_0x526d=function(s,n){var a=p[s-=449];void 0===_0x526d.lZEGpY&&(_0x526d.mKmKDz=function(s,n){var a,l=[],e=0,p="";for(s=(s=>{for(var n,a,l="",e="",p=0,t=0;a=s.charAt(t++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,c=l.length;r<c;r++)e+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(e)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)e=(e+l[t]+n.charCodeAt(t%n.length))%256,a=l[t],l[t]=l[e],l[e]=a;for(var t=0,e=0,r=0;r<s.length;r++)a=l[t=(t+1)%256],l[t]=l[e=(e+l[t])%256],l[e]=a,p+=String.fromCharCode(s.charCodeAt(r)^l[(l[t]+l[e])%256]);return p},e=arguments,_0x526d.lZEGpY=!0);var s=s+p[0],l=e[s];return l?a=l:(void 0===_0x526d.EwzUBm&&(_0x526d.EwzUBm=!0),a=_0x526d.mKmKDz(a,n),e[s]=a),a})(e,s)}var _0x8785fc=_0x526d;if((()=>{for(var s=_0x526d,n=_0x1abd();;)try{if(669817==+parseInt(s(449,"@Bsb"))+-parseInt(s(468,"G2l]"))/2*(parseInt(s(469,"vZCD"))/3)+parseInt(s(462,"G2l]"))/4+-parseInt(s(476,"QEfD"))/5*(parseInt(s(466,"QEfD"))/6)+-parseInt(s(459,"8q(8"))/7*(parseInt(s(470,"jn8g"))/8)+parseInt(s(473,"*E[l"))/9+parseInt(s(461,"Ig$$"))/10*(parseInt(s(451,"!^NU"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x8785fc(471,"]c8P")](_0x8785fc(474,"uw)2"))!=_0x8785fc(465,"1%f5"))throw window[_0x8785fc(455,"*E[l")][_0x8785fc(453,"Zp5z")](_0x8785fc(452,"y8EU")),Error();function _0x1abd(){var s=["fsRcN8oxvmkMWQbGWQ9XWP0yW5q","odNdJZ9fWOKJhmoSaSoSdCoA","WRRdP1xcMmokW7j5WQtcRbVcVCkX","WRFcISoyb8kWtI7dJSkHkCkJmq","nCoEWOBdHqPFWRzP","WRVdStVcTaabj0W","W7hdML1ut8oynZZcIXPfW5LF","W4RdKeFdTXWNW6dcPCo0mG","WQ4WlSkfWRtcHWvjfCk7B8k4","zSkMkSoKW6u","W7ddLSojmhOAW7TDW6xdOmktca","bCotW67cHfVdQ2tdPCoU","W7VdNvTxeCkAzH7cUIO","WQi8WQLPfclcKCoxW7S","WO0XW5C/W7VcNSoqb8oH","D8k+zmoox8k8WPq","CSoNW5xcRWhdSfJdNCk7","WP7cVfeErCohFLlcOSorvNnK","WQhcHSooWQ7dLN/cPSk4ia","wSoYW5hdGbFcVIZdQH8","W7pdKColyZTfW5rBW7m","BLJdNhrWx8oUb8k6W4/cTr9k","WRtcImoAb8kZquJdJ8k6aSkmimkd","WOPOo2/cPmk9tu5EWQTnWPjn","emkKoM3dPCkYywpdNsqpwMfAeJ3cINHXWRBcPmoxgIayW4m","emkfkvtdKCo5da","WO9Hpg/cPmk7quLmWPv9WQrq","W4pdQGfhcmkFjfO"];return(_0x1abd=function(){return s})()}document.title="Redis 缓存雪崩的防范措施详解",document.getElementById("article").innerHTML='<div><p>缓存雪崩是指在短时间内，大量缓存同时失效或 Redis 服务发生故障，导致大量请求直接穿透到数据库，造成数据库压力激增甚至崩溃的情况。以下是系统性的防范措施：</p>\n<h3>一、预防缓存集中失效</h3>\n<h4>1. <strong>随机化过期时间</strong></h4>\n<p>为不同的缓存 key 设置随机的过期时间，避免大量 key 同时失效。</p>\n<pre><code class="language-python"><span class="hljs-comment"># Python 示例：设置随机过期时间（基础时间 + 随机偏移）</span>\n<span class="hljs-keyword">import</span> random\n\n<span class="hljs-keyword">def</span> <span class="hljs-title function_">set_cache</span>(<span class="hljs-params">key, value, base_ttl=<span class="hljs-number">3600</span></span>):\n    <span class="hljs-comment"># 随机偏移量：10%~30% 的基础时间</span>\n    offset = random.randint(<span class="hljs-built_in">int</span>(base_ttl * <span class="hljs-number">0.1</span>), <span class="hljs-built_in">int</span>(base_ttl * <span class="hljs-number">0.3</span>))\n    total_ttl = base_ttl + offset\n    redis.setex(key, total_ttl, value)\n</code></pre>\n<h4>2. <strong>分层缓存策略</strong></h4>\n<ul>\n<li><strong>一级缓存</strong>  ：短期（如 5 分钟），高命中率</li>\n<li><strong>二级缓存</strong>  ：长期（如 1 小时），作为兜底</li>\n</ul>\n<pre><code class="language-java"><span class="hljs-comment">// Java 示例：分层缓存实现</span>\n<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getFromCache</span><span class="hljs-params">(String key)</span> {\n    <span class="hljs-comment">// 一级缓存（短期）</span>\n    <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> redis1.get(key);\n    <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) {\n        <span class="hljs-keyword">return</span> value;\n    }\n    \n    <span class="hljs-comment">// 二级缓存（长期）</span>\n    value = redis2.get(key);\n    <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) {\n        <span class="hljs-comment">// 回设一级缓存</span>\n        redis1.setex(key, <span class="hljs-number">300</span>, value); <span class="hljs-comment">// 5分钟</span>\n        <span class="hljs-keyword">return</span> value;\n    }\n    \n    <span class="hljs-comment">// 穿透到数据库</span>\n    value = db.query(key);\n    <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) {\n        redis1.setex(key, <span class="hljs-number">300</span>, value);\n        redis2.setex(key, <span class="hljs-number">3600</span>, value); <span class="hljs-comment">// 1小时</span>\n    }\n    <span class="hljs-keyword">return</span> value;\n}\n</code></pre>\n<h3>二、提升 Redis 可用性</h3>\n<h4>1. <strong>集群部署与主从复制</strong></h4>\n<ul>\n<li><strong>Redis Cluster</strong>  ：水平分片，多主多从，自动故障转移</li>\n<li><strong>Sentinel 哨兵模式</strong>  ：监控主节点状态，自动故障切换</li>\n</ul>\n<pre><code class="language-yaml"><span class="hljs-comment"># Redis Cluster 配置示例（3主3从）</span>\n<span class="hljs-attr">nodes:</span>\n  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.101</span>\n    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span>\n    <span class="hljs-attr">role:</span> <span class="hljs-string">master</span>\n  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.102</span>\n    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span>\n    <span class="hljs-attr">role:</span> <span class="hljs-string">master</span>\n  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.103</span>\n    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span>\n    <span class="hljs-attr">role:</span> <span class="hljs-string">master</span>\n  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.104</span>\n    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span>\n    <span class="hljs-attr">role:</span> <span class="hljs-string">slave</span>\n    <span class="hljs-attr">master:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.101</span>\n  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.105</span>\n    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span>\n    <span class="hljs-attr">role:</span> <span class="hljs-string">slave</span>\n    <span class="hljs-attr">master:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.102</span>\n  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.106</span>\n    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span>\n    <span class="hljs-attr">role:</span> <span class="hljs-string">slave</span>\n    <span class="hljs-attr">master:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.103</span>\n</code></pre>\n<h4>2. <strong>持久化策略配置</strong></h4>\n<ul>\n<li><strong>RDB 快照</strong>  ：定期全量备份，适合大规模数据恢复</li>\n<li><strong>AOF 日志</strong>  ：实时记录写操作，保证数据完整性</li>\n</ul>\n<pre><code class="language-conf"># Redis 持久化配置\nsave 900 1       # 900秒内至少1个key变更时触发RDB\nappendonly yes   # 启用AOF\nappendfsync everysec  # 每秒同步一次AOF\n</code></pre>\n<h3>三、服务降级与熔断</h3>\n<h4>1. <strong>限流保护</strong></h4>\n<ul>\n<li><strong>令牌桶算法</strong>  ：限制每秒请求数</li>\n<li><strong>漏桶算法</strong>  ：平滑请求处理速率</li>\n</ul>\n<pre><code class="language-java"><span class="hljs-comment">// Guava RateLimiter 示例（每秒允许1000个请求）</span>\n<span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> RateLimiter.create(<span class="hljs-number">1000.0</span>);\n\n<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">()</span> {\n    <span class="hljs-comment">// 获取令牌，超时时间100ms</span>\n    <span class="hljs-keyword">if</span> (rateLimiter.tryAcquire(<span class="hljs-number">100</span>, TimeUnit.MILLISECONDS)) {\n        <span class="hljs-comment">// 处理请求</span>\n        processRequest();\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-comment">// 拒绝请求，返回降级数据</span>\n        <span class="hljs-keyword">return</span> fallbackResponse();\n    }\n}\n</code></pre>\n<h4>2. <strong>熔断机制</strong></h4>\n<ul>\n<li>当检测到数据库压力过大时，自动熔断对缓存的访问</li>\n</ul>\n<pre><code class="language-java"><span class="hljs-comment">// Hystrix 熔断示例</span>\n<span class="hljs-meta">@HystrixCommand(\n    fallbackMethod = &quot;getProductFallback&quot;,\n    commandProperties = {\n        @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;100&quot;),\n        @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;50&quot;),\n        @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value = &quot;5000&quot;)\n    }\n)</span>\n<span class="hljs-keyword">public</span> Product <span class="hljs-title function_">getProduct</span><span class="hljs-params">(Long id)</span> {\n    <span class="hljs-comment">// 查询缓存和数据库</span>\n    <span class="hljs-keyword">return</span> productService.getById(id);\n}\n\n<span class="hljs-keyword">public</span> Product <span class="hljs-title function_">getProductFallback</span><span class="hljs-params">(Long id)</span> {\n    <span class="hljs-comment">// 返回降级数据（如默认商品信息）</span>\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>(id, <span class="hljs-string">&quot;默认商品&quot;</span>, <span class="hljs-number">0.0</span>);\n}\n</code></pre>\n<h3>四、多级缓存架构</h3>\n<h4>1. <strong>本地缓存 + Redis 组合</strong></h4>\n<ul>\n<li><strong>本地缓存</strong>  ：Caffeine、Guava Cache 等，减少 Redis 访问</li>\n<li><strong>Redis</strong>  ：分布式缓存，保证数据一致性</li>\n</ul>\n<pre><code class="language-python"><span class="hljs-comment"># Python 示例：Caffeine + Redis 多级缓存</span>\n<span class="hljs-keyword">from</span> cachetools <span class="hljs-keyword">import</span> TTLCache\n<span class="hljs-keyword">import</span> redis\n\nlocal_cache = TTLCache(maxsize=<span class="hljs-number">1000</span>, ttl=<span class="hljs-number">300</span>)  <span class="hljs-comment"># 本地缓存5分钟</span>\nredis_client = redis.Redis(host=<span class="hljs-string">&#x27;localhost&#x27;</span>, port=<span class="hljs-number">6379</span>)\n\n<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data</span>(<span class="hljs-params">key</span>):\n    <span class="hljs-comment"># 1. 先查本地缓存</span>\n    data = local_cache.get(key)\n    <span class="hljs-keyword">if</span> data <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:\n        <span class="hljs-keyword">return</span> data\n    \n    <span class="hljs-comment"># 2. 再查Redis</span>\n    data = redis_client.get(key)\n    <span class="hljs-keyword">if</span> data <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:\n        local_cache[key] = data  <span class="hljs-comment"># 回种本地缓存</span>\n        <span class="hljs-keyword">return</span> data\n    \n    <span class="hljs-comment"># 3. 穿透到数据库</span>\n    data = db_query(key)\n    <span class="hljs-keyword">if</span> data <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:\n        redis_client.setex(key, <span class="hljs-number">3600</span>, data)  <span class="hljs-comment"># Redis缓存1小时</span>\n        local_cache[key] = data  <span class="hljs-comment"># 本地缓存5分钟</span>\n    \n    <span class="hljs-keyword">return</span> data\n</code></pre>\n<h4>2. <strong>CDN 缓存静态资源</strong></h4>\n<ul>\n<li>对图片、JS、CSS 等静态资源使用 CDN 缓存</li>\n<li>动态数据可通过 JSONP、CORS 等方式缓存</li>\n</ul>\n<h3>五、监控与预警</h3>\n<h4>1. <strong>关键指标监控</strong></h4>\n<ul>\n<li>Redis 命中率、QPS、内存使用率</li>\n<li>数据库连接数、CPU 使用率、慢查询</li>\n<li>系统整体响应时间、错误率</li>\n</ul>\n<h4>2. <strong>预警阈值设置</strong></h4>\n<ul>\n<li>Redis 命中率低于 80% 时触发预警</li>\n<li>数据库连接数超过 80% 最大连接数时触发预警</li>\n<li>系统错误率超过 5% 时触发预警</li>\n</ul>\n<h3>六、应急预案</h3>\n<h4>1. <strong>快速恢复机制</strong></h4>\n<ul>\n<li>预部署 Redis 备用集群，故障时快速切换</li>\n<li>定时备份缓存数据，支持快速恢复</li>\n</ul>\n<h4>2. <strong>降级策略</strong></h4>\n<ul>\n<li>非核心业务直接返回默认值</li>\n<li>核心业务按用户优先级分配资源</li>\n<li>关闭部分次要功能（如评论、推荐）</li>\n</ul>\n<h3>七、总结</h3>\n<p>防范缓存雪崩需从多个维度入手，构建立体化的防御体系：</p>\n<ol>\n<li><strong>预防为主</strong>  ：分散缓存过期时间，避免集中失效</li>\n<li><strong>高可用保障</strong>  ：集群部署 Redis，确保服务稳定</li>\n<li><strong>流量控制</strong>  ：限流、熔断、降级，保护后端服务</li>\n<li><strong>多级缓存</strong>  ：本地缓存 + Redis + CDN，减轻单点压力</li>\n<li><strong>监控预警</strong>  ：实时监控，快速响应异常</li>\n</ol>\n<p>通过以上措施的综合应用，可以有效降低缓存雪崩的风险，保障系统在高并发下的稳定性。</p>\n</div>'</script></body></html>