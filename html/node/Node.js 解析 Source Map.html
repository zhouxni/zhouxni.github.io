<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x356a10=_0x4eb4;function _0x6abd(){var s=["u0lcNCkAWP4MnHJcPCoBE8oVWQe","WOjGW4tcMSk4oqdcMG","WQSnqH3dHLhdG2mmW4W9W7FcVW","k8otruPBW45xySoIWPpdKK4u","kmoztK9FWPSBxCo9WPNdLW","ECovW7urW5HUaCoiBSk/W5ZdHW","WP0dWO9Bbf9bWRBdN8oIW5fXW7y","rI5PfqrahdjeWQhdOeOU","oYKxsXKDW64BbG","laTLCmoSyJvaabZdRIv0","f1ZdHSkvWQtdTmoUWRK","W7LnsIvtW7xdJa","WO8vlg5vW4nirCovhSoHBW","WQTqWOywW7xcLmkvv8oclgZdTYC","WRZdTardpSktACkv","zf9LW77dRSosW57dHqBcTSok","WPBcRwpdGmkNWRmhvSoyW4xcJSo2kYmrW6/cMCowreRcRSk0WQ8gW6uz","WQbHmCkCWQNcQXi","WRDZc0ZcQmoagmodj8oUWOKKha","WRnYCJ3dT8kGrCoy","W7uBW6JcJ17dTaS","o8oXW7S0WPBcM8o5zwuJvNa","WOxcL8kEW4PfW5VcSqGP","WODMW7tcMSkNcX7cVG","arddMmoNW5H7yG","ArurWQaP","W5HCW7uLWOHyb8kiW7PlW7JcIG","WO8CkHKsWQ19s8oU"];return(_0x6abd=function(){return s})()}function _0x4eb4(p,s){var o=_0x6abd();return(_0x4eb4=function(s,n){var a=o[s-=467];void 0===_0x4eb4.VNFYsw&&(_0x4eb4.wKYCTG=function(s,n){var a,l=[],p=0,o="";for(s=(s=>{for(var n,a,l="",p="",o=0,t=0;a=s.charAt(t++);~a&&(n=o%4?64*n+a:a,o++%4)&&(l+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,e=l.length;c<e;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)p=(p+l[t]+n.charCodeAt(t%n.length))%256,a=l[t],l[t]=l[p],l[p]=a;for(var t=0,p=0,c=0;c<s.length;c++)a=l[t=(t+1)%256],l[t]=l[p=(p+l[t])%256],l[p]=a,o+=String.fromCharCode(s.charCodeAt(c)^l[(l[t]+l[p])%256]);return o},p=arguments,_0x4eb4.VNFYsw=!0);var s=s+o[0],l=p[s];return l?a=l:(void 0===_0x4eb4.cvPpED&&(_0x4eb4.cvPpED=!0),a=_0x4eb4.wKYCTG(a,n),p[s]=a),a})(p,s)}if((()=>{for(var s=_0x4eb4,n=_0x6abd();;)try{if(912298==-parseInt(s(488,"0l8b"))+parseInt(s(481,"Z5ji"))/2+parseInt(s(494,"H%6M"))/3*(parseInt(s(474,"Cp5n"))/4)+parseInt(s(472,"[3*u"))/5*(parseInt(s(490,"!)J*"))/6)+-parseInt(s(486,"s*2I"))/7+parseInt(s(470,"wsE1"))/8*(parseInt(s(469,"wsE1"))/9)+-parseInt(s(478,"!(Kk"))/10*(-parseInt(s(491,"!(Kk"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x356a10(475,"cNnM")](_0x356a10(487,"Y%H4"))!=_0x356a10(476,"&Gjh"))throw window[_0x356a10(489,"%sGm")][_0x356a10(468,"HZeq")](_0x356a10(467,"RZ[f")),Error();document.title="Node.js 解析 Source Map",document.getElementById("article").innerHTML='<div><p>在生产环境中，通过 Node.js 解析 <strong>Source Map</strong>   的核心目标是：<strong>将用户上报的压缩代码错误堆栈（如 <code>main.js:10:15</code>）反向映射到源码（如 TypeScript 或未压缩的 JavaScript）的具体位置</strong>   。以下是完整的实现方案和代码示例：</p>\n<hr>\n<h2><strong>一、核心流程</strong></h2>\n<ol>\n<li><strong>获取压缩代码的堆栈信息</strong>   （如文件名、行号、列号）。</li>\n<li><strong>读取对应的 <code>.map</code> 文件</strong>   （需提前上传到服务器或从存储服务下载）。</li>\n<li><strong>使用 <code>source-map</code> 库解析堆栈</strong>   ，映射到源码位置。</li>\n</ol>\n<hr>\n<h2><strong>二、环境准备</strong></h2>\n<h3><strong>1. 安装依赖库</strong></h3>\n<pre><code class="language-bash">npm install source-map\n</code></pre>\n<ul>\n<li><code>source-map</code> 是官方推荐的 Source Map 解析库，支持异步解析大文件。</li>\n</ul>\n<h3><strong>2. 确保 <code>.map</code> 文件可访问</strong></h3>\n<ul>\n<li><strong>存储位置</strong>   ：<code>.map</code> 文件需上传到服务器的特定目录（如 <code>/var/sourcemaps/</code>）或云存储（如 AWS S3）。</li>\n<li><strong>路径规则</strong>   ：<code>.map</code> 文件需与压缩代码文件同名（如 <code>dist/main.js</code> 对应 <code>dist/main.js.map</code>）。</li>\n</ul>\n<hr>\n<h2><strong>三、完整代码实现</strong></h2>\n<h3><strong>1. 从错误上报中提取堆栈信息</strong></h3>\n<p>假设前端上报的错误数据格式如下：</p>\n<pre><code class="language-json"><span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Cannot read property &#x27;name&#x27; of undefined&quot;</span><span class="hljs-punctuation">,</span>\n  <span class="hljs-attr">&quot;stack&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;main.js:10:15&quot;</span> <span class="hljs-comment">// 压缩代码的文件名、行号、列号</span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n<h3><strong>2. Node.js 解析脚本</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);\n<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);\n<span class="hljs-keyword">const</span> { <span class="hljs-title class_">SourceMapConsumer</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;source-map&quot;</span>);\n\n<span class="hljs-comment">/**\n * 解析 Source Map 并返回源码位置\n * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">stackInfo</span> - 压缩代码的堆栈信息（格式：filename:line:column）\n * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">sourcemapDir</span> - .map 文件存储目录\n */</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">parseSourceMap</span>(<span class="hljs-params">stackInfo, sourcemapDir</span>) {\n  <span class="hljs-comment">// 1. 解析堆栈信息</span>\n  <span class="hljs-keyword">const</span> [filename, lineStr, columnStr] = stackInfo.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;:&quot;</span>);\n  <span class="hljs-keyword">const</span> line = <span class="hljs-built_in">parseInt</span>(lineStr, <span class="hljs-number">10</span>);\n  <span class="hljs-keyword">const</span> column = <span class="hljs-built_in">parseInt</span>(columnStr, <span class="hljs-number">10</span>);\n\n  <span class="hljs-comment">// 2. 构造 .map 文件路径（假设 .map 文件与压缩代码同目录）</span>\n  <span class="hljs-keyword">const</span> mapFilePath = path.<span class="hljs-title function_">join</span>(sourcemapDir, <span class="hljs-string">`<span class="hljs-subst">${filename}</span>.map`</span>);\n\n  <span class="hljs-comment">// 3. 检查 .map 文件是否存在</span>\n  <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(mapFilePath)) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Source Map 文件不存在: <span class="hljs-subst">${mapFilePath}</span>`</span>);\n  }\n\n  <span class="hljs-comment">// 4. 读取 .map 文件内容</span>\n  <span class="hljs-keyword">const</span> rawSourceMap = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(fs.<span class="hljs-title function_">readFileSync</span>(mapFilePath, <span class="hljs-string">&quot;utf8&quot;</span>));\n\n  <span class="hljs-comment">// 5. 创建 SourceMapConsumer 实例（异步解析）</span>\n  <span class="hljs-keyword">const</span> consumer = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SourceMapConsumer</span>(rawSourceMap);\n\n  <span class="hljs-comment">// 6. 映射到源码位置</span>\n  <span class="hljs-keyword">const</span> originalPosition = consumer.<span class="hljs-title function_">originalPositionFor</span>({\n    <span class="hljs-attr">line</span>: line, <span class="hljs-comment">// 压缩代码的行号</span>\n    <span class="hljs-attr">column</span>: column, <span class="hljs-comment">// 压缩代码的列号</span>\n  });\n\n  <span class="hljs-comment">// 7. 返回结果</span>\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">source</span>: originalPosition.<span class="hljs-property">source</span>, <span class="hljs-comment">// 源码文件名（如 src/main.ts）</span>\n    <span class="hljs-attr">line</span>: originalPosition.<span class="hljs-property">line</span>, <span class="hljs-comment">// 源码行号</span>\n    <span class="hljs-attr">column</span>: originalPosition.<span class="hljs-property">column</span>, <span class="hljs-comment">// 源码列号</span>\n    <span class="hljs-attr">name</span>: originalPosition.<span class="hljs-property">name</span>, <span class="hljs-comment">// 变量名（如果有）</span>\n  };\n}\n\n<span class="hljs-comment">// 示例：模拟错误上报数据</span>\n<span class="hljs-keyword">const</span> errorStack = <span class="hljs-string">&quot;main.js:10:15&quot;</span>; <span class="hljs-comment">// 压缩代码的堆栈</span>\n<span class="hljs-keyword">const</span> sourcemapDirectory = <span class="hljs-string">&quot;/var/sourcemaps&quot;</span>; <span class="hljs-comment">// .map 文件存储目录</span>\n\n<span class="hljs-comment">// 执行解析</span>\n<span class="hljs-title function_">parseSourceMap</span>(errorStack, sourcemapDirectory)\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;源码位置:&quot;</span>, result);\n    <span class="hljs-comment">// 输出示例: { source: &#x27;src/main.ts&#x27;, line: 25, column: 8, name: &#x27;getUser&#x27; }</span>\n  })\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;解析失败:&quot;</span>, err.<span class="hljs-property">message</span>);\n  });\n</code></pre>\n<hr>\n<h2><strong>四、关键细节说明</strong></h2>\n<h3><strong>1. 堆栈信息的格式</strong></h3>\n<ul>\n<li>前端需上报 <strong>压缩代码的文件名、行号、列号</strong>   （如 <code>main.js:10:15</code>）。</li>\n<li>如果前端上报的是完整堆栈（如多行错误），需逐行解析每一条堆栈记录。</li>\n</ul>\n<h3><strong>2. <code>.map</code> 文件的路径规则</strong></h3>\n<ul>\n<li><strong>默认假设</strong>   ：<code>.map</code> 文件与压缩代码同目录（如 <code>dist/main.js</code> → <code>dist/main.js.map</code>）。</li>\n<li><strong>动态路径</strong>   ：如果构建时 <code>.map</code> 文件路径不同（如上传到云存储），需根据文件名动态构造下载链接（如从 AWS S3 获取）。</li>\n</ul>\n<h3><strong>3. Source Map 版本兼容性</strong></h3>\n<ul>\n<li>确保构建工具生成的 Source Map 版本与 <code>source-map</code> 库兼容（现代工具如 Webpack 5、Vite 默认兼容）。</li>\n<li>如果解析失败，检查 <code>.map</code> 文件内容是否符合 <a href="https://sourcemaps.info/spec.html" target="_blank">Source Map 规范</a>。</li>\n</ul>\n<hr>\n<h2><strong>五、生产环境优化实践</strong></h2>\n<h3><strong>1. 缓存 Source Map 文件</strong></h3>\n<ul>\n<li>避免重复读取磁盘或下载 <code>.map</code> 文件，使用内存缓存（如 Redis 或 Node.js 全局变量）：</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> sourcemapCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();\n\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">parseSourceMapWithCache</span>(<span class="hljs-params">stackInfo, sourcemapDir</span>) {\n  <span class="hljs-keyword">const</span> mapFilePath = path.<span class="hljs-title function_">join</span>(sourcemapDir, <span class="hljs-string">`<span class="hljs-subst">${filename}</span>.map`</span>);\n  <span class="hljs-keyword">if</span> (sourcemapCache.<span class="hljs-title function_">has</span>(mapFilePath)) {\n    <span class="hljs-keyword">const</span> cachedConsumer = sourcemapCache.<span class="hljs-title function_">get</span>(mapFilePath);\n    <span class="hljs-comment">// 直接使用缓存的 SourceMapConsumer</span>\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 读取并缓存 .map 文件</span>\n  }\n}\n</code></pre>\n<h3><strong>2. 异步批处理</strong></h3>\n<ul>\n<li>如果同时解析多个错误堆栈，使用 <code>Promise.all</code> 并行处理：</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> errorStacks = [<span class="hljs-string">&quot;main.js:10:15&quot;</span>, <span class="hljs-string">&quot;vendor.js:5:20&quot;</span>];\n<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(\n  errorStacks.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">stack</span>) =&gt;</span> <span class="hljs-title function_">parseSourceMap</span>(stack, sourcemapDir)),\n).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;批量解析结果:&quot;</span>, results);\n});\n</code></pre>\n<h3><strong>3. 安全防护</strong></h3>\n<ul>\n<li><strong>限制 <code>.map</code> 文件访问</strong>   ：通过 Nginx 或服务器配置禁止直接下载 <code>.map</code> 文件：<pre><code class="language-nginx"><span class="hljs-section">location</span> <span class="hljs-regexp">~ \\.map$</span> {\n  <span class="hljs-attribute">deny</span> all;\n  <span class="hljs-attribute">return</span> <span class="hljs-number">403</span>;\n}\n</code></pre>\n</li>\n<li><strong>验证文件来源</strong>   ：确保 <code>.map</code> 文件仅从内部存储或可信来源加载（避免恶意文件注入）。</li>\n</ul>\n<hr>\n<h2><strong>六、常见问题排查</strong></h2>\n<table>\n<thead>\n<tr>\n<th>问题现象</th>\n<th>可能原因</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>originalPositionFor</code> 返回 <code>null</code></td>\n<td>堆栈行号/列号超出范围</td>\n<td>检查前端上报的堆栈是否准确</td>\n</tr>\n<tr>\n<td>解析速度慢</td>\n<td><code>.map</code> 文件过大或未缓存</td>\n<td>使用缓存或升级服务器配置</td>\n</tr>\n<tr>\n<td>报错 <code>Unexpected token</code></td>\n<td><code>.map</code> 文件损坏或格式错误</td>\n<td>重新上传正确的 <code>.map</code> 文件</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>通过以上方案，Node.js 可以高效、安全地解析 Source Map，将生产环境的压缩代码错误精准映射到源码位置，辅助开发团队快速定位问题。</p>\n</div>'</script></body></html>