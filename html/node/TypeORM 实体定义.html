<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5831(){var s=["W6fiWPG9z1NcMG","W7NcGGbMzmk8W7y","tIy1W4ZdUhuOW5GrlmoxWPtcOq","BSoCsCosW6NcQSoyh1W","p8oUWPLThComW47cMSkNtH/cJa","hmkYWOXVWQjYqCkVra","s8oLWQBdRq8","W5KIqXWcjSkpW50","W6WgWRRcLgRdNfa8","W7ldRfKsomocW7FdJXbnWPdcLW","kmoaW6zCW7/cUCk2W7SZ","W4CVW441W77dQIK9W6/cU09BbmkeW68YW4dcRc0KDmkmEmorW4FdSa","W7e2BwdcPYmhbSkhmmkFF8oj","emovWPZcMCkdWQjVtgNdKZ7dNsG","gCoPzN3dVq/cK8kEqqVdKwK","f15LW4FdSCo6tLG9sfVcPstcVG","cbyVWPy7WPNcVHeXvxvEW74","WONdHbtdU1dcICkohSo9c8klW6RcTG","WRZcLSoTWO1UAJldSMn0c2NdU3S","d8ooWQfMW58bWRFcRHWWfSoPWR4","tmk6iGpcVfRcIq","zMadW53dSWbSWPtcMSkipCol","W5PVhSkrvCk9W7jW","fCotWPZcN8keWQbUt2/dJGJdJaC","gSoTy3JdUWNdKmkHrcddKh7dVa","zSomW6X2WQS2oq"];return(_0x5831=function(){return s})()}var _0x1a04d6=_0x181d;function _0x181d(p,s){var t=_0x5831();return(_0x181d=function(s,a){var n=t[s-=264];void 0===_0x181d.vOWklB&&(_0x181d.HkFrzH=function(s,a){var n,l=[],p=0,t="";for(s=(s=>{for(var a,n,l="",p="",t=0,e=0;n=s.charAt(e++);~n&&(a=t%4?64*a+n:n,t++%4)&&(l+=String.fromCharCode(255&a>>(-2*t&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,o=l.length;c<o;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+a.charCodeAt(e%a.length))%256,n=l[e],l[e]=l[p],l[p]=n;for(var e=0,p=0,c=0;c<s.length;c++)n=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=n,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[p])%256]);return t},p=arguments,_0x181d.vOWklB=!0);var s=s+t[0],l=p[s];return l?n=l:(void 0===_0x181d.ExfXfg&&(_0x181d.ExfXfg=!0),n=_0x181d.HkFrzH(n,a),p[s]=n),n})(p,s)}if((()=>{for(var s=_0x181d,a=_0x5831();;)try{if(722469==-parseInt(s(265,"I1&v"))+-parseInt(s(277,"m5fz"))/2+parseInt(s(288,"aZaO"))/3*(parseInt(s(287,"m5fz"))/4)+parseInt(s(286,"*urx"))/5+-parseInt(s(282,"@ZQF"))/6+-parseInt(s(268,"5*P9"))/7*(parseInt(s(267,"O@xk"))/8)+-parseInt(s(281,"Z%bt"))/9*(-parseInt(s(270,"eZIO"))/10))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x1a04d6(283,"m5fz")](_0x1a04d6(266,")I5$"))!=_0x1a04d6(269,"W#0&"))throw window[_0x1a04d6(271,"42p&")][_0x1a04d6(289,"I!m%")](_0x1a04d6(274,"lu3@")),Error();document.title="TypeORM 实体定义",document.getElementById("article").innerHTML='<div><p>TypeORM 实体（Entity）是映射数据库表的核心概念，一个实体类对应数据库中的一张表，类的属性对应表的字段。以下是 TypeORM 实体定义的详细解析，涵盖核心装饰器、字段配置、关系映射等关键内容：</p>\n<h3>一、基础实体结构</h3>\n<p>实体类通过装饰器定义，最基础的结构包含主键和普通字段：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Entity</span>, <span class="hljs-title class_">PrimaryGeneratedColumn</span>, <span class="hljs-title class_">Column</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;typeorm&quot;</span>;\n\n<span class="hljs-meta">@Entity</span>() <span class="hljs-comment">// 标记为实体类</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {\n  <span class="hljs-meta">@PrimaryGeneratedColumn</span>() <span class="hljs-comment">// 主键（自增）</span>\n  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;\n\n  <span class="hljs-meta">@Column</span>() <span class="hljs-comment">// 普通字段</span>\n  <span class="hljs-attr">username</span>: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-meta">@Column</span>()\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n}\n</code></pre>\n<h3>二、核心装饰器详解</h3>\n<h4>1. 实体类装饰器：<code>@Entity()</code></h4>\n<p>用于标记类为数据库实体，可配置表名、引擎等属性：</p>\n<pre><code class="language-typescript"><span class="hljs-meta">@Entity</span>({\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;user_profile&quot;</span>, <span class="hljs-comment">// 自定义表名（默认是类名的蛇形小写）</span>\n  <span class="hljs-attr">engine</span>: <span class="hljs-string">&quot;InnoDB&quot;</span>, <span class="hljs-comment">// 数据库引擎（仅关系型数据库，如 MySQL）</span>\n  <span class="hljs-attr">schema</span>: <span class="hljs-string">&quot;public&quot;</span>, <span class="hljs-comment">// 数据库模式（如 PostgreSQL 的 schema）</span>\n  <span class="hljs-attr">comment</span>: <span class="hljs-string">&quot;用户信息表&quot;</span>, <span class="hljs-comment">// 表注释</span>\n  <span class="hljs-attr">synchronize</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 是否自动同步表结构（默认继承全局配置）</span>\n})\n</code></pre>\n<h4>2. 主键装饰器</h4>\n<ul>\n<li>\n<p><strong><code>@PrimaryGeneratedColumn()</code></strong>   ：自动生成主键（最常用）</p>\n<pre><code class="language-typescript"><span class="hljs-meta">@PrimaryGeneratedColumn</span>() <span class="hljs-comment">// 默认：自增整数（INT）</span>\n<span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;\n\n<span class="hljs-meta">@PrimaryGeneratedColumn</span>(<span class="hljs-string">&quot;uuid&quot;</span>) <span class="hljs-comment">// 自动生成 UUID 字符串</span>\n<span class="hljs-attr">uuid</span>: <span class="hljs-built_in">string</span>;\n\n<span class="hljs-meta">@PrimaryGeneratedColumn</span>({\n  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;bigint&quot;</span>, <span class="hljs-comment">// 自定义类型（如 BIGINT）</span>\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;user_id&quot;</span> <span class="hljs-comment">// 自定义字段名</span>\n})\n<span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;\n</code></pre>\n</li>\n<li>\n<p><strong><code>@PrimaryColumn()</code></strong>   ：手动指定主键（非自增）</p>\n<pre><code class="language-typescript"><span class="hljs-meta">@PrimaryColumn</span>() <span class="hljs-comment">// 单个字段主键</span>\n<span class="hljs-attr">code</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 需要手动赋值</span>\n\n<span class="hljs-comment">// 联合主键（多个字段组合）</span>\n<span class="hljs-meta">@PrimaryColumn</span>()\n<span class="hljs-attr">userId</span>: <span class="hljs-built_in">number</span>;\n\n<span class="hljs-meta">@PrimaryColumn</span>()\n<span class="hljs-attr">roleId</span>: <span class="hljs-built_in">number</span>;\n</code></pre>\n</li>\n</ul>\n<h4>3. 字段装饰器：<code>@Column()</code></h4>\n<p>定义表字段的核心装饰器，支持丰富的配置项：</p>\n<pre><code class="language-typescript"><span class="hljs-meta">@Column</span>({\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;user_name&quot;</span>, <span class="hljs-comment">// 数据库字段名（默认与属性名一致）</span>\n  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;varchar&quot;</span>, <span class="hljs-comment">// 字段类型（如 varchar、int、boolean 等）</span>\n  <span class="hljs-attr">length</span>: <span class="hljs-number">50</span>, <span class="hljs-comment">// 长度（仅适用于字符串类型）</span>\n  <span class="hljs-attr">nullable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否允许为 null（默认 false）</span>\n  <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;guest&quot;</span>, <span class="hljs-comment">// 默认值（如字符串需加引号，数字/布尔直接写）</span>\n  <span class="hljs-attr">comment</span>: <span class="hljs-string">&quot;用户姓名&quot;</span>, <span class="hljs-comment">// 字段注释</span>\n  <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否唯一约束（会自动创建唯一索引）</span>\n  <span class="hljs-attr">enum</span>: [<span class="hljs-string">&quot;male&quot;</span>, <span class="hljs-string">&quot;female&quot;</span>, <span class="hljs-string">&quot;other&quot;</span>], <span class="hljs-comment">// 枚举类型（值只能是数组中的项）</span>\n  <span class="hljs-attr">enumName</span>: <span class="hljs-string">&quot;gender_enum&quot;</span>, <span class="hljs-comment">// 枚举类型名称（数据库层面）</span>\n  <span class="hljs-attr">unsigned</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否无符号（仅数字类型，如 MySQL 的 INT UNSIGNED）</span>\n  <span class="hljs-attr">zerofill</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否零填充（仅 MySQL）</span>\n  <span class="hljs-attr">select</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 查询时是否默认包含该字段（默认 true）</span>\n  <span class="hljs-attr">precision</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// 数值精度（小数总位数，如 DECIMAL(10,2)）</span>\n  <span class="hljs-attr">scale</span>: <span class="hljs-number">2</span>, <span class="hljs-comment">// 小数位数</span>\n  <span class="hljs-attr">array</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否为数组类型（仅 PostgreSQL 支持，如 int[]）</span>\n  <span class="hljs-attr">charset</span>: <span class="hljs-string">&quot;utf8mb4&quot;</span>, <span class="hljs-comment">// 字符集（如 MySQL 的 utf8mb4）</span>\n  <span class="hljs-attr">collation</span>: <span class="hljs-string">&quot;utf8mb4_general_ci&quot;</span> <span class="hljs-comment">// 排序规则</span>\n})\n<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n</code></pre>\n<p><strong>常用字段类型</strong>   ：</p>\n<ul>\n<li>字符串：<code>varchar</code>、<code>text</code>（长文本）、<code>char</code>（定长）</li>\n<li>数字：<code>int</code>、<code>bigint</code>、<code>float</code>、<code>double</code>、<code>decimal</code></li>\n<li>布尔：<code>boolean</code>（数据库中可能存为 tinyint 或 boolean）</li>\n<li>日期：<code>date</code>（年月日）、<code>datetime</code>（年月日时分秒）、<code>timestamp</code>（带时区）</li>\n<li>特殊：<code>json</code>/<code>jsonb</code>（存储 JSON 数据）、<code>uuid</code>、<code>geometry</code>（空间数据）</li>\n</ul>\n<h4>4. 特殊字段装饰器</h4>\n<ul>\n<li>\n<p><strong><code>@CreateDateColumn()</code></strong>   ：自动记录创建时间（插入时赋值）</p>\n<pre><code class="language-typescript"><span class="hljs-meta">@CreateDateColumn</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;create_time&quot;</span> })\n<span class="hljs-attr">createdAt</span>: <span class="hljs-title class_">Date</span>;\n</code></pre>\n</li>\n<li>\n<p><strong><code>@UpdateDateColumn()</code></strong>   ：自动记录更新时间（更新时刷新）</p>\n<pre><code class="language-typescript"><span class="hljs-meta">@UpdateDateColumn</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;update_time&quot;</span> })\n<span class="hljs-attr">updatedAt</span>: <span class="hljs-title class_">Date</span>;\n</code></pre>\n</li>\n<li>\n<p><strong><code>@DeleteDateColumn()</code></strong>   ：软删除标记（配合 <code>soft-delete</code> 功能）</p>\n<pre><code class="language-typescript"><span class="hljs-meta">@DeleteDateColumn</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;delete_time&quot;</span> })\n<span class="hljs-attr">deletedAt</span>: <span class="hljs-title class_">Date</span> | <span class="hljs-literal">null</span>; <span class="hljs-comment">// 未删除时为 null，删除时记录时间</span>\n</code></pre>\n</li>\n</ul>\n<h3>三、索引与约束</h3>\n<h4>1. 索引装饰器：<code>@Index()</code></h4>\n<p>用于创建索引（普通索引或唯一索引），可作用于单个字段或多个字段：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Index</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;typeorm&quot;</span>;\n\n<span class="hljs-comment">// 类级别：联合索引</span>\n<span class="hljs-meta">@Entity</span>()\n<span class="hljs-meta">@Index</span>([<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>]) <span class="hljs-comment">// 普通联合索引</span>\n<span class="hljs-meta">@Index</span>([<span class="hljs-string">&quot;email&quot;</span>], { <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;idx_unique_email&quot;</span> }) <span class="hljs-comment">// 唯一索引</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {\n  <span class="hljs-comment">// 字段级别：单个字段索引</span>\n  <span class="hljs-meta">@Index</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;idx_username&quot;</span> }) <span class="hljs-comment">// 自定义索引名</span>\n  <span class="hljs-meta">@Column</span>()\n  <span class="hljs-attr">username</span>: <span class="hljs-built_in">string</span>;\n}\n</code></pre>\n<h4>2. 唯一约束装饰器：<code>@Unique()</code></h4>\n<p>简化的唯一索引定义（等价于 <code>@Index({ unique: true })</code>）：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Unique</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;typeorm&quot;</span>;\n\n<span class="hljs-meta">@Entity</span>()\n<span class="hljs-meta">@Unique</span>([<span class="hljs-string">&quot;username&quot;</span>]) <span class="hljs-comment">// 单个字段唯一</span>\n<span class="hljs-meta">@Unique</span>([<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;phone&quot;</span>]) <span class="hljs-comment">// 联合唯一（组合值不重复）</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {\n  <span class="hljs-comment">// ...字段</span>\n}\n</code></pre>\n<h3>四、关系映射（表关联）</h3>\n<p>TypeORM 支持常见的数据库关系（一对一、一对多、多对多），通过装饰器定义：</p>\n<h4>1. 一对一（<code>@OneToOne</code>）</h4>\n<pre><code class="language-typescript"><span class="hljs-comment">// User 实体（主表）</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">OneToOne</span>, <span class="hljs-title class_">JoinColumn</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;typeorm&quot;</span>;\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Profile</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Profile&quot;</span>;\n\n<span class="hljs-meta">@Entity</span>()\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {\n  <span class="hljs-comment">// ...其他字段</span>\n\n  <span class="hljs-meta">@OneToOne</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Profile</span>, <span class="hljs-function">(<span class="hljs-params">profile</span>) =&gt;</span> profile.<span class="hljs-property">user</span>)\n  <span class="hljs-meta">@JoinColumn</span>() <span class="hljs-comment">// 表示外键在当前表（user 表会有 profileId 字段）</span>\n  <span class="hljs-attr">profile</span>: <span class="hljs-title class_">Profile</span>;\n}\n\n<span class="hljs-comment">// Profile 实体（从表）</span>\n<span class="hljs-meta">@Entity</span>()\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Profile</span> {\n  <span class="hljs-comment">// ...其他字段</span>\n\n  <span class="hljs-meta">@OneToOne</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">User</span>, <span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> user.<span class="hljs-property">profile</span>)\n  <span class="hljs-attr">user</span>: <span class="hljs-title class_">User</span>; <span class="hljs-comment">// 不存储外键，仅用于查询关联</span>\n}\n</code></pre>\n<h4>2. 一对多（<code>@OneToMany</code>）与多对一（<code>@ManyToOne</code>）</h4>\n<pre><code class="language-typescript"><span class="hljs-comment">// User 实体（一的一方）</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">OneToMany</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;typeorm&quot;</span>;\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Post</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Post&quot;</span>;\n\n<span class="hljs-meta">@Entity</span>()\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {\n  <span class="hljs-comment">// ...其他字段</span>\n\n  <span class="hljs-meta">@OneToMany</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Post</span>, <span class="hljs-function">(<span class="hljs-params">post</span>) =&gt;</span> post.<span class="hljs-property">author</span>) <span class="hljs-comment">// 关联 Post 的 author 字段</span>\n  <span class="hljs-attr">posts</span>: <span class="hljs-title class_">Post</span>[]; <span class="hljs-comment">// 一个用户有多个帖子</span>\n}\n\n<span class="hljs-comment">// Post 实体（多的一方）</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ManyToOne</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;typeorm&quot;</span>;\n\n<span class="hljs-meta">@Entity</span>()\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Post</span> {\n  <span class="hljs-comment">// ...其他字段</span>\n\n  <span class="hljs-meta">@ManyToOne</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">User</span>, <span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> user.<span class="hljs-property">posts</span>) <span class="hljs-comment">// 关联 User 的 posts 字段</span>\n  <span class="hljs-attr">author</span>: <span class="hljs-title class_">User</span>; <span class="hljs-comment">// 多个帖子属于一个用户（外键在 post 表：authorId）</span>\n}\n</code></pre>\n<h4>3. 多对多（<code>@ManyToMany</code>）</h4>\n<p>需要中间表关联，通过 <code>@JoinTable()</code> 定义中间表：</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// User 实体</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ManyToMany</span>, <span class="hljs-title class_">JoinTable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;typeorm&quot;</span>;\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Role</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Role&quot;</span>;\n\n<span class="hljs-meta">@Entity</span>()\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {\n  <span class="hljs-comment">// ...其他字段</span>\n\n  <span class="hljs-meta">@ManyToMany</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Role</span>, <span class="hljs-function">(<span class="hljs-params">role</span>) =&gt;</span> role.<span class="hljs-property">users</span>)\n  <span class="hljs-meta">@JoinTable</span>({\n    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;user_role&quot;</span>, <span class="hljs-comment">// 自定义中间表名</span>\n    <span class="hljs-attr">joinColumn</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;user_id&quot;</span> }, <span class="hljs-comment">// 中间表中关联当前表的字段</span>\n    <span class="hljs-attr">inverseJoinColumn</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;role_id&quot;</span> }, <span class="hljs-comment">// 中间表中关联对方表的字段</span>\n  })\n  <span class="hljs-attr">roles</span>: <span class="hljs-title class_">Role</span>[]; <span class="hljs-comment">// 一个用户可拥有多个角色</span>\n}\n\n<span class="hljs-comment">// Role 实体</span>\n<span class="hljs-meta">@Entity</span>()\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Role</span> {\n  <span class="hljs-comment">// ...其他字段</span>\n\n  <span class="hljs-meta">@ManyToMany</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">User</span>, <span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> user.<span class="hljs-property">roles</span>)\n  <span class="hljs-attr">users</span>: <span class="hljs-title class_">User</span>[]; <span class="hljs-comment">// 一个角色可分配给多个用户</span>\n}\n</code></pre>\n<h3>五、继承与抽象实体</h3>\n<p>通过抽象类定义公共字段，被其他实体继承（减少重复代码）：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Entity</span>, <span class="hljs-title class_">PrimaryGeneratedColumn</span>, <span class="hljs-title class_">CreateDateColumn</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;typeorm&quot;</span>;\n\n<span class="hljs-comment">// 抽象实体（不生成表）</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseEntity</span> {\n  <span class="hljs-meta">@PrimaryGeneratedColumn</span>()\n  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;\n\n  <span class="hljs-meta">@CreateDateColumn</span>()\n  <span class="hljs-attr">createdAt</span>: <span class="hljs-title class_">Date</span>;\n}\n\n<span class="hljs-comment">// 继承抽象实体</span>\n<span class="hljs-meta">@Entity</span>()\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">BaseEntity</span> {\n  <span class="hljs-meta">@Column</span>()\n  <span class="hljs-attr">username</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-comment">// 自动继承 id 和 createdAt 字段</span>\n}\n</code></pre>\n<h3>六、实体元数据操作</h3>\n<p>通过 <code>getMetadata</code> 可获取实体的元数据（字段、关系等信息）：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { getMetadata } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;typeorm&quot;</span>;\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">User</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./User&quot;</span>;\n\n<span class="hljs-keyword">const</span> metadata = <span class="hljs-title function_">getMetadata</span>(<span class="hljs-title class_">User</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(metadata.<span class="hljs-property">tableName</span>); <span class="hljs-comment">// 表名</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(metadata.<span class="hljs-property">columns</span>); <span class="hljs-comment">// 所有字段信息</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(metadata.<span class="hljs-property">relations</span>); <span class="hljs-comment">// 所有关系信息</span>\n</code></pre>\n<h3>总结</h3>\n<p>TypeORM 实体定义的核心是通过装饰器映射数据库结构，关键要点包括：</p>\n<ul>\n<li>用 <code>@Entity()</code> 标记实体类，配置表属性；</li>\n<li>用主键装饰器定义主键（自增或手动）；</li>\n<li>用 <code>@Column()</code> 及衍生装饰器定义字段，配置类型、约束等；</li>\n<li>用关系装饰器（<code>@OneToOne</code> 等）定义表关联；</li>\n<li>用 <code>@Index</code> 和 <code>@Unique</code> 优化查询和保证数据唯一性。</li>\n</ul>\n<p>合理设计实体可清晰映射业务模型，同时提升数据库操作效率。</p>\n</div>'</script></body></html>