<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2b02(){var s=["eGSDfaVcOYzfy0KOW5FcVq","nmkmbmoIamoique","W6u1xWpdTJyKW5j/fqpdRSk2","lfxdJZxcHSkxvq","wComWRdcOmkDkuqiWReVg8oWWQW","WP3cI8k9BrffWRW","DCk7W5yzvSknW6Dd","W7jsq2RcQMzIgCoiW5dcQmkMlcWdWRNdOsz9W6tcICoHDCk6W6FcKG","cSoeWPPzWOpcV37dS8oxx8oIzSkp","WQ0YW7ujBgFcMWGiWQi6fSoU","W6y1xqhdTZDFW6fCga/dGG","WRfArSk+WQDUW4VdJZFcI1NcQXS","WONcSCoiWRqRcCoinSoip2/cGrm","n8knc8oibmoHq3S","tJvIfmkfW5i8w8kvr8ksW64","vSokWOVcNhuFFCkSzG","c8oypCoEW4ZcTCoJW6fDmSoosW","WOVdNSkIqCo9W5RcVmkgWPKTgSoLqq","WOZcUSonWRyQa8kWk8o0phxcHW","WQ/cMGVcKSogmSoJv8o/W7BdK0xdMa","WOZdM8kLrmo8W5VcVCkfWQaqg8o1zG","emkjf8onW7SDEa","hajGsaJcKgmc","f8ovc8osW6yjuCoL","jCoiWRNcVwmava","hCkzW7ddUmoeEru","uSkgu8kOWO9whG","nuhcQCkKfa","WQTPWQ5zaqFdIq","WOddTXpcK8oEWOFdTa"];return(_0x2b02=function(){return s})()}var _0x21d964=_0x1b36;function _0x1b36(l,s){var e=_0x2b02();return(_0x1b36=function(s,n){var o=e[s-=400];void 0===_0x1b36.DGCtNf&&(_0x1b36.tqLCzW=function(s,n){var o,a=[],l=0,e="";for(s=(s=>{for(var n,o,a="",l="",e=0,c=0;o=s.charAt(c++);~o&&(n=e%4?64*n+o:o,e++%4)&&(a+=String.fromCharCode(255&n>>(-2*e&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var r=0,p=a.length;r<p;r++)l+="%"+("00"+a.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(s),c=0;c<256;c++)a[c]=c;for(c=0;c<256;c++)l=(l+a[c]+n.charCodeAt(c%n.length))%256,o=a[c],a[c]=a[l],a[l]=o;for(var c=0,l=0,r=0;r<s.length;r++)o=a[c=(c+1)%256],a[c]=a[l=(l+a[c])%256],a[l]=o,e+=String.fromCharCode(s.charCodeAt(r)^a[(a[c]+a[l])%256]);return e},l=arguments,_0x1b36.DGCtNf=!0);var s=s+e[0],a=l[s];return a?o=a:(void 0===_0x1b36.bjJEVH&&(_0x1b36.bjJEVH=!0),o=_0x1b36.tqLCzW(o,n),l[s]=o),o})(l,s)}if((()=>{for(var s=_0x1b36,n=_0x2b02();;)try{if(734615==-parseInt(s(428,"2n15"))*(parseInt(s(413,"#XFq"))/2)+parseInt(s(423,"vlac"))/3*(parseInt(s(417,"^%IC"))/4)+-parseInt(s(401,"#gxA"))/5*(-parseInt(s(419,"[P!4"))/6)+parseInt(s(427,"cS42"))/7*(parseInt(s(424,"Z3yZ"))/8)+parseInt(s(425,"KIeJ"))/9+-parseInt(s(407,"]10m"))/10*(parseInt(s(418,"P0l$"))/11)+parseInt(s(422,"o#my"))/12)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x21d964(410,"Ndpr")](_0x21d964(429,"v&%6"))!=_0x21d964(411,"5R#X"))throw window[_0x21d964(406,"XCFg")][_0x21d964(409,"P0l$")](_0x21d964(421,"t0fe")),Error();document.title="MySQL 索引",document.getElementById("article").innerHTML='<div><p>在 MySQL 中，<strong>索引（Index）</strong>   是一种特殊的数据结构，用于快速定位表中的数据，类似于书籍的目录。它通过预先构建数据的“关键字”与“存储位置”的映射关系，大幅减少查询时的磁盘 I/O 次数，从而提升查询效率。以下从索引的作用、类型、原理、创建与删除、最佳实践等方面进行全面详解。</p>\n<h2>一、索引的核心作用</h2>\n<ol>\n<li><strong>加速查询</strong>   ：通过索引直接定位数据位置，避免全表扫描（如 <code>WHERE id=100</code> 借助主键索引可瞬间找到记录）。</li>\n<li><strong>优化排序/分组</strong>   ：若查询包含 <code>ORDER BY</code> 或 <code>GROUP BY</code>，索引可避免额外的排序操作（索引本身是有序的）。</li>\n<li><strong>强制唯一性</strong>   ：唯一索引（<code>UNIQUE</code>）可确保字段值不重复，替代手动校验。</li>\n</ol>\n<h2>二、索引的底层数据结构</h2>\n<p>MySQL 索引默认使用 <strong>B+ 树</strong>   结构（InnoDB 引擎），其设计专为磁盘存储优化，核心特点：</p>\n<ul>\n<li><strong>层级低</strong>   ：B+ 树是平衡多叉树，通常 3~4 层即可存储千万级数据，查询时只需 3~4 次磁盘 I/O。</li>\n<li><strong>有序性</strong>   ：叶子节点按索引值排序，且通过指针连接，适合范围查询（如 <code>BETWEEN</code>、<code>&gt; &lt;</code>）。</li>\n<li><strong>聚簇特性</strong>   ：InnoDB 的主键索引叶子节点存储完整数据行（聚簇索引），辅助索引叶子节点存储主键值（需回表查询）。</li>\n</ul>\n<h2>三、索引的类型</h2>\n<p>按功能和结构可分为以下几类：</p>\n<h3>1. 主键索引（PRIMARY KEY）</h3>\n<ul>\n<li><strong>特性</strong>   ：唯一且非空，一张表只能有一个主键索引，自动创建，对应聚簇索引。</li>\n<li><strong>作用</strong>   ：唯一标识记录，是查询效率最高的索引。</li>\n<li><strong>示例</strong>   ：<pre><code class="language-sql"><span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-keyword">user</span> (\n  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT, <span class="hljs-comment">-- 主键索引</span>\n  username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)\n);\n</code></pre>\n</li>\n</ul>\n<h3>2. 唯一索引（UNIQUE）</h3>\n<ul>\n<li>\n<p><strong>特性</strong>   ：索引值唯一（允许 <code>NULL</code>，但 <code>NULL</code> 只能出现一次），可创建多个。</p>\n</li>\n<li>\n<p><strong>作用</strong>   ：确保字段唯一性（如用户名、邮箱），同时加速查询。</p>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-sql"><span class="hljs-comment">-- 建表时创建</span>\n<span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-keyword">user</span> (\n  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,\n  username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">UNIQUE</span> <span class="hljs-comment">-- 唯一索引</span>\n);\n\n<span class="hljs-comment">-- 建表后添加</span>\n<span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> INDEX idx_email (email);\n</code></pre>\n</li>\n</ul>\n<h3>3. 普通索引（INDEX）</h3>\n<ul>\n<li>\n<p><strong>特性</strong>   ：无唯一性约束，可重复，最常用的索引类型。</p>\n</li>\n<li>\n<p><strong>作用</strong>   ：单纯加速查询（如按手机号、订单号查询）。</p>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-sql"><span class="hljs-comment">-- 简写法</span>\n<span class="hljs-keyword">CREATE</span> INDEX idx_phone <span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span>(phone);\n\n<span class="hljs-comment">-- 完整写法</span>\n<span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">ADD</span> INDEX idx_address (address);\n</code></pre>\n</li>\n</ul>\n<h3>4. 复合索引（多列索引）</h3>\n<ul>\n<li><strong>特性</strong>   ：基于多个字段创建的索引（如 <code>(a, b, c)</code>），遵循“最左前缀原则”。</li>\n<li><strong>作用</strong>   ：优化多条件查询（如 <code>WHERE a=1 AND b=2</code>）。</li>\n<li><strong>最左前缀原则</strong>   ：查询条件需包含索引的最左列才能触发索引，例如：\n<ul>\n<li>索引 <code>(a, b, c)</code> 可匹配 <code>WHERE a=1</code>、<code>WHERE a=1 AND b=2</code>、<code>WHERE a=1 AND b=2 AND c=3</code>；</li>\n<li>无法匹配 <code>WHERE b=2</code>、<code>WHERE a=1 AND c=3</code>（缺失中间列 <code>b</code>）。</li>\n</ul>\n</li>\n<li><strong>示例</strong>   ：<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> INDEX idx_name_age <span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span>(username, age); <span class="hljs-comment">-- 复合索引</span>\n</code></pre>\n</li>\n</ul>\n<h3>5. 全文索引（FULLTEXT）</h3>\n<ul>\n<li>\n<p><strong>特性</strong>   ：用于长文本（<code>TEXT</code>、<code>LONGTEXT</code> 等）的关键词检索，不支持 <code>WHERE LIKE \'%关键词%\'</code> 的模糊查询优化。</p>\n</li>\n<li>\n<p><strong>作用</strong>   ：高效搜索文本中的关键词（如文章内容、评论）。</p>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-sql"><span class="hljs-keyword">CREATE TABLE</span> article (\n  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,\n  content TEXT,\n  FULLTEXT INDEX idx_content (content) <span class="hljs-comment">-- 全文索引</span>\n);\n\n<span class="hljs-comment">-- 查询包含“MySQL”或“索引”的文章</span>\n<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> article <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">MATCH</span>(content) AGAINST(<span class="hljs-string">&#x27;MySQL 索引&#x27;</span>);\n</code></pre>\n</li>\n</ul>\n<h3>6. 空间索引（SPATIAL）</h3>\n<ul>\n<li><strong>特性</strong>   ：用于地理空间数据（如 <code>POINT</code>、<code>POLYGON</code>），加速位置相关查询。</li>\n<li><strong>适用场景</strong>   ：地图应用、LBS 服务（如“附近的商店”）。</li>\n</ul>\n<h2>四、索引的创建与删除</h2>\n<h3>1. 创建索引</h3>\n<ul>\n<li>\n<p><strong>建表时创建</strong>   ：</p>\n<pre><code class="language-sql"><span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-keyword">user</span> (\n  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,\n  username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),\n  age <span class="hljs-type">INT</span>,\n  <span class="hljs-comment">-- 普通索引</span>\n  INDEX idx_age (age),\n  <span class="hljs-comment">-- 唯一索引</span>\n  <span class="hljs-keyword">UNIQUE</span> INDEX idx_username (username),\n  <span class="hljs-comment">-- 复合索引</span>\n  INDEX idx_username_age (username, age)\n);\n</code></pre>\n</li>\n<li>\n<p><strong>建表后创建</strong>   ：</p>\n<pre><code class="language-sql"><span class="hljs-comment">-- 普通索引</span>\n<span class="hljs-keyword">CREATE</span> INDEX idx_age <span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span>(age);\n\n<span class="hljs-comment">-- 唯一索引</span>\n<span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> INDEX idx_username (username);\n\n<span class="hljs-comment">-- 全文索引</span>\n<span class="hljs-keyword">CREATE</span> FULLTEXT INDEX idx_content <span class="hljs-keyword">ON</span> article(content);\n</code></pre>\n</li>\n</ul>\n<h3>2. 删除索引</h3>\n<pre><code class="language-sql"><span class="hljs-comment">-- 方式1：DROP INDEX</span>\n<span class="hljs-keyword">DROP</span> INDEX idx_age <span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span>;\n\n<span class="hljs-comment">-- 方式2：ALTER TABLE</span>\n<span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">DROP</span> INDEX idx_username;\n\n<span class="hljs-comment">-- 注意：主键索引只能通过修改表结构删除</span>\n<span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY KEY</span>; <span class="hljs-comment">-- 需先移除 AUTO_INCREMENT（如有）</span>\n</code></pre>\n<h2>五、索引的优缺点</h2>\n<h3>优点</h3>\n<ul>\n<li><strong>查询加速</strong>   ：大幅减少磁盘 I/O，尤其对大表效果显著。</li>\n<li><strong>优化排序</strong>   ：利用索引有序性避免临时表排序。</li>\n<li><strong>唯一性约束</strong>   ：唯一索引确保数据完整性。</li>\n</ul>\n<h3>缺点</h3>\n<ul>\n<li><strong>占用空间</strong>   ：索引需单独存储，一张表索引可能占比 30%~50% 存储空间。</li>\n<li><strong>写入变慢</strong>   ：新增/修改/删除数据时，需同步更新索引（B+ 树维护成本）。</li>\n<li><strong>维护成本</strong>   ：过多索引会降低写入性能，且需定期优化（如重建碎片化索引）。</li>\n</ul>\n<h2>六、索引使用的最佳实践</h2>\n<h3>1. 哪些字段适合建索引？</h3>\n<ul>\n<li><strong>查询频繁的字段</strong>   ：如 <code>WHERE</code>、<code>JOIN ON</code>、<code>ORDER BY</code>、<code>GROUP BY</code> 中的字段。</li>\n<li><strong>区分度高的字段</strong>   ：如手机号（几乎唯一）比性别（仅男/女）更适合建索引（区分度低的索引过滤效果差）。</li>\n<li><strong>长度短的字段</strong>   ：如 <code>CHAR(11)</code> 手机号比 <code>VARCHAR(200)</code> 地址更适合（索引存储更小，查询更快）。</li>\n</ul>\n<h3>2. 哪些情况不适合建索引？</h3>\n<ul>\n<li><strong>表数据量小</strong>   （如 &lt; 1万行）：全表扫描比索引查询更快（索引本身有开销）。</li>\n<li><strong>写入频繁的表</strong>   ：如日志表（索引会拖慢 <code>INSERT</code>/<code>UPDATE</code> 性能）。</li>\n<li><strong>区分度低的字段</strong>   ：如 <code>status</code>（仅 0/1）、<code>gender</code>（男/女）。</li>\n<li><strong>频繁更新的字段</strong>   ：索引会随字段值更新而频繁重建，影响性能。</li>\n</ul>\n<h3>3. 复合索引设计原则</h3>\n<ul>\n<li><strong>最左前缀优先</strong>   ：将查询频率最高的字段放在最左（如 <code>WHERE a=1 AND b=2</code> 应建 <code>(a, b)</code> 而非 <code>(b, a)</code>）。</li>\n<li><strong>避免冗余</strong>   ：若已有 <code>(a, b)</code> 索引，无需再建 <code>(a)</code> 索引（<code>(a, b)</code> 可覆盖 <code>(a)</code> 的查询需求）。</li>\n<li><strong>控制长度</strong>   ：复合索引字段不宜过多（建议 ≤3 个），否则索引体积过大。</li>\n</ul>\n<h3>4. 索引失效的常见场景</h3>\n<ul>\n<li><strong>违反最左前缀原则</strong>   ：复合索引 <code>(a, b)</code> 用 <code>WHERE b=1</code> 无法触发索引。</li>\n<li><strong>函数/表达式操作索引字段</strong>   ：<code>WHERE SUBSTR(phone, 1, 3)=\'138\'</code> 会使 <code>phone</code> 索引失效。</li>\n<li><strong>隐式类型转换</strong>   ：<code>WHERE phone=13800138000</code>（<code>phone</code> 是字符串类型）会触发转换，索引失效。</li>\n<li><strong><code>LIKE</code> 以 <code>%</code> 开头</strong>   ：<code>WHERE username LIKE \'%张三\'</code> 无法使用索引（<code>LIKE \'张三%\'</code> 可使用前缀索引）。</li>\n<li><strong><code>OR</code> 连接非索引字段</strong>   ：<code>WHERE a=1 OR b=2</code> 中若 <code>b</code> 无索引，整个查询可能全表扫描。</li>\n</ul>\n<h3>5. 索引维护技巧</h3>\n<ul>\n<li><strong>定期分析索引使用情况</strong>   ：通过 <code>sys.schema_unused_indexes</code> 找出未使用的冗余索引并删除。</li>\n<li><strong>重建碎片化索引</strong>   ：频繁更新的表会导致索引碎片化，可通过 <code>ALTER TABLE ... FORCE INDEX</code> 重建。</li>\n<li><strong>避免过度索引</strong>   ：一张表索引建议 ≤5 个，过多会降低写入性能。</li>\n</ul>\n<h2>七、总结</h2>\n<p>索引是 MySQL 性能优化的核心手段，但其设计需权衡查询加速与写入成本。关键原则：</p>\n<ul>\n<li><strong>按需创建</strong>   ：只为高频查询字段建索引，避免冗余。</li>\n<li><strong>合理设计</strong>   ：复合索引遵循最左前缀原则，优先短字段、高区分度字段。</li>\n<li><strong>定期维护</strong>   ：删除无用索引，重建碎片化索引。</li>\n</ul>\n<p>理解索引的工作原理（B+ 树）和失效场景，能帮助你避开常见陷阱，让索引真正发挥优化作用。</p>\n</div>'</script></body></html>