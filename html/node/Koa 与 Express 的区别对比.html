<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1728b8=_0x85dd;if((()=>{for(var s=_0x85dd,n=_0x198b();;)try{if(932277==-parseInt(s(454,"sDyc"))+-parseInt(s(481,"q6xl"))/2*(-parseInt(s(455,"1oY1"))/3)+parseInt(s(474,"NdYZ"))/4+-parseInt(s(467,"]6tL"))/5*(parseInt(s(477,"9]2&"))/6)+parseInt(s(462,"zE1)"))/7*(parseInt(s(475,"Ie&h"))/8)+-parseInt(s(461,"Jo[o"))/9+parseInt(s(457,"lfFx"))/10*(parseInt(s(465,"GsV&"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1728b8(471,"VsgL")](_0x1728b8(480,"zCkm"))!=_0x1728b8(460,"Jo[o"))throw window[_0x1728b8(464,"y$j(")][_0x1728b8(476,"71kd")](_0x1728b8(466,"8$jV")),Error();function _0x85dd(l,s){var r=_0x198b();return(_0x85dd=function(s,n){var a=r[s-=454];void 0===_0x85dd.ViWHfS&&(_0x85dd.JQlDIK=function(s,n){var a,t=[],l=0,r="";for(s=(s=>{for(var n,a,t="",l="",r=0,p=0;a=s.charAt(p++);~a&&(n=r%4?64*n+a:a,r++%4)&&(t+=String.fromCharCode(255&n>>(-2*r&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,c=t.length;e<c;e++)l+="%"+("00"+t.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)l=(l+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[l],t[l]=a;for(var p=0,l=0,e=0;e<s.length;e++)a=t[p=(p+1)%256],t[p]=t[l=(l+t[p])%256],t[l]=a,r+=String.fromCharCode(s.charCodeAt(e)^t[(t[p]+t[l])%256]);return r},l=arguments,_0x85dd.ViWHfS=!0);var s=s+r[0],t=l[s];return t?a=t:(void 0===_0x85dd.zKcMZm&&(_0x85dd.zKcMZm=!0),a=_0x85dd.JQlDIK(a,n),l[s]=a),a})(l,s)}function _0x198b(){var s=["Cmk+W5ZcR8kOW7NdR8oGBSol","FZpcJulcLZ7dUmkdWRaDWPxcNa","WPbUWRhdKmkwW5FdLKvtW7eC","qZTKWRFdQG","cN8MW7dcPWtdNmoZeCo4WQPLDa","sc/cISkPW4NcP8k9vwxcG1G","q03dPSoKW7moW77dRCoezSk4","zSomW5ukWRGxDqC","nCkabqSCW7CmWRJdUSkDW491","xdFcTGBdQ0HPe8o9ctnzASkPa3iIwuldV0xcHSkyW7G4WRO","W7OCW5n0hw/dRCoDW4Pk","W63cRSoBkcxcHNJcMqTr","W5FcSCkVWRFdSatcJCkNW6NdKe1C","W6rqWPKzW7NdQHi+","WOhdOCoQW47cVfNcTa","eJxdO8oOjvjHmmoM","sJtdOmoglhW3a33dPG","tZFdOCodrHCabxldJSkJia","WQKRW6pcMCkWWOqvWQHM","WQisWQ/cNNHmW60","WPDPWRFdLSkuW7FdON5YW4y7","W6KMEHFcV1VdGKPjW4ldVSkyW5y","W7CBW5j1EWVcV8o7W6buWOG6ga","gu3cNqWVW5DEEHq","jmkpzColW7jRmCk0wsWT","WOZdIXNdQmkcWPddOCk8g0K+W7Xv","W4SzzJ0oqtFcUG","WRxcNfm1WOxcIhRdJdCaWOm"];return(_0x198b=function(){return s})()}document.title="Koa 与 Express 的区别对比",document.getElementById("article").innerHTML='<div><p>Koa 和 Express 是 Node.js 最流行的两个 Web 框架，均由 <strong>TJ Holowaychuk</strong>   开发。它们的设计理念相似，但在架构、异步处理和中间件机制上有显著差异。以下是详细对比：</p>\n<hr>\n<h2><strong>1. 核心区别总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><strong>Express</strong></th>\n<th><strong>Koa</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>发布时间</strong></td>\n<td>2010 年（更早，更成熟）</td>\n<td>2013 年（更现代）</td>\n</tr>\n<tr>\n<td><strong>底层 HTTP 处理</strong></td>\n<td>封装 Node.js 原生 <code>http</code> 模块</td>\n<td>基于 Node.js 原生 <code>http</code>，但更轻量</td>\n</tr>\n<tr>\n<td><strong>中间件机制</strong></td>\n<td><strong>线性执行（Callback 风格）</strong></td>\n<td><strong>洋葱模型（Async/Await）</strong></td>\n</tr>\n<tr>\n<td><strong>异步处理</strong></td>\n<td>基于 <strong>Callback/Promise</strong></td>\n<td>原生支持 <strong>Async/Await</strong></td>\n</tr>\n<tr>\n<td><strong>错误处理</strong></td>\n<td>需手动 <code>next(err)</code> 传递</td>\n<td>支持 <code>try/catch</code> 捕获</td>\n</tr>\n<tr>\n<td><strong>路由</strong></td>\n<td>内置 <code>express.Router()</code></td>\n<td>需额外安装 <code>@koa/router</code></td>\n</tr>\n<tr>\n<td><strong>体积</strong></td>\n<td>较大（约 2k+ 行代码）</td>\n<td>极轻量（约 600 行代码）</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>传统 Web 应用、快速开发</td>\n<td>现代 API、中间件精细控制</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>2. 中间件机制对比</strong></h2>\n<h3><strong>（1）Express：线性执行（Callback 风格）</strong></h3>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 1&#x27;</span>);\n  <span class="hljs-title function_">next</span>(); <span class="hljs-comment">// 必须调用 next() 才能进入下一个中间件</span>\n});\n\napp.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Middleware 2&#x27;</span>);\n  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello Express&#x27;</span>);\n});\n</code></pre>\n<p><strong>特点</strong>  ：</p>\n<ul>\n<li>中间件按顺序执行，<code>next()</code> 控制流程。</li>\n<li><strong>无法在响应阶段再执行代码</strong>  （除非手动存储 <code>res.send</code> 的数据）。</li>\n</ul>\n<hr>\n<h3><strong>（2）Koa：洋葱模型（Async/Await）</strong></h3>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>); <span class="hljs-comment">// 请求阶段</span>\n  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();     <span class="hljs-comment">// 进入下一个中间件</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>); <span class="hljs-comment">// 响应阶段（回来时执行）</span>\n});\n\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx) =&gt; {\n  ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&#x27;Hello Koa&#x27;</span>;\n});\n</code></pre>\n<p><strong>特点</strong>  ：</p>\n<ul>\n<li>中间件可<strong>双向处理</strong>  请求和响应（类似洋葱层层穿透）。</li>\n<li>通过 <code>await next()</code> 暂停当前中间件，执行完后续逻辑后再回来。</li>\n<li><strong>更适合异步操作</strong>  （如数据库查询后修改响应）。</li>\n</ul>\n<hr>\n<h2><strong>3. 异步处理对比</strong></h2>\n<h3><strong>（1）Express：Callback/Promise</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// Callback 风格</span>\napp.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> {\n  <span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">err, user</span>) =&gt;</span> {\n    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>(err); <span class="hljs-comment">// 手动传递错误</span>\n    res.<span class="hljs-title function_">json</span>(user);\n  });\n});\n\n<span class="hljs-comment">// Promise 风格</span>\napp.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> {\n  <span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>()\n    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> res.<span class="hljs-title function_">json</span>(user))\n    .<span class="hljs-title function_">catch</span>(next); <span class="hljs-comment">// 仍需手动捕获</span>\n});\n</code></pre>\n<h3><strong>（2）Koa：Async/Await</strong></h3>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx) =&gt; {\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>();\n    ctx.<span class="hljs-property">body</span> = user; <span class="hljs-comment">// 直接赋值，无需 res.json()</span>\n  } <span class="hljs-keyword">catch</span> (err) {\n    ctx.<span class="hljs-keyword">throw</span>(<span class="hljs-number">500</span>, <span class="hljs-string">&#x27;DB Error&#x27;</span>); <span class="hljs-comment">// 内置错误处理</span>\n  }\n});\n</code></pre>\n<p><strong>优势</strong>  ：</p>\n<ul>\n<li>代码更简洁，错误处理更直观（<code>try/catch</code>）。</li>\n<li>无需手动调用 <code>next()</code> 或 <code>res.end()</code>。</li>\n</ul>\n<hr>\n<h2><strong>4. 路由对比</strong></h2>\n<h3><strong>（1）Express：内置路由</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();\nrouter.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;User Info&#x27;</span>);\n});\napp.<span class="hljs-title function_">use</span>(router);\n</code></pre>\n<h3><strong>（2）Koa：需安装 <code>@koa/router</code></strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Router</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@koa/router&#x27;</span>);\n<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>();\n\nrouter.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">ctx</span>) =&gt;</span> {\n  ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&#x27;User Info&#x27;</span>;\n});\napp.<span class="hljs-title function_">use</span>(router.<span class="hljs-title function_">routes</span>());\n</code></pre>\n<p><strong>区别</strong>  ：</p>\n<ul>\n<li>Express 路由是内置的，Koa 保持核心精简，路由交给插件实现。</li>\n</ul>\n<hr>\n<h2><strong>5. 错误处理对比</strong></h2>\n<h3><strong>（1）Express：需手动传递</strong></h3>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);\n  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Server Error&#x27;</span>);\n});\n</code></pre>\n<ul>\n<li>必须通过 <code>next(err)</code> 传递错误，否则会被忽略。</li>\n</ul>\n<h3><strong>（2）Koa：自动捕获</strong></h3>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();\n  } <span class="hljs-keyword">catch</span> (err) {\n    ctx.<span class="hljs-property">status</span> = <span class="hljs-number">500</span>;\n    ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&#x27;Server Error&#x27;</span>;\n  }\n});\n</code></pre>\n<ul>\n<li>支持 <code>ctx.throw(400, \'Bad Request\')</code> 快速抛出错误。</li>\n</ul>\n<hr>\n<h2><strong>6. 适用场景</strong></h2>\n<h3><strong>选择 Express 如果：</strong></h3>\n<ul>\n<li>需要快速开发传统 Web 应用（如服务端渲染）。</li>\n<li>依赖 Express 生态（如 <code>passport.js</code>、<code>express-session</code>）。</li>\n<li>项目已有 Express 代码，渐进式迁移。</li>\n</ul>\n<h3><strong>选择 Koa 如果：</strong></h3>\n<ul>\n<li>开发现代 API 服务（如 RESTful/GraphQL）。</li>\n<li>需要精细控制中间件流程（如权限校验、日志）。</li>\n<li>全面使用 <code>async/await</code>，避免回调地狱。</li>\n</ul>\n<hr>\n<h2><strong>7. 代码示例对比</strong></h2>\n<h3><strong>Express 示例</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);\n<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();\n\napp.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>()); <span class="hljs-comment">// 解析 JSON 请求体</span>\n\napp.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n  res.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Express&#x27;</span> });\n});\n\napp.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);\n</code></pre>\n<h3><strong>Koa 示例</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);\n<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();\n\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx) =&gt; {\n  ctx.<span class="hljs-property">body</span> = { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Koa&#x27;</span> };\n});\n\napp.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);\n</code></pre>\n<hr>\n<h2><strong>8. 总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th><strong>框架</strong></th>\n<th><strong>优势</strong></th>\n<th><strong>劣势</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Express</strong></td>\n<td>成熟、生态丰富、适合传统 Web 开发</td>\n<td>回调风格、错误处理繁琐</td>\n</tr>\n<tr>\n<td><strong>Koa</strong></td>\n<td>轻量、现代异步、洋葱模型</td>\n<td>路由等需额外插件、学习曲线稍高</td>\n</tr>\n</tbody>\n</table>\n<p><strong>推荐选择</strong>  ：</p>\n<ul>\n<li><strong>新手/快速开发</strong>   → Express</li>\n<li><strong>现代 API/精细控制</strong>   → Koa</li>\n<li><strong>企业级应用</strong>   → NestJS（基于 Express/Koa）</li>\n</ul>\n</div>'</script></body></html>