<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1a9aa3=_0x49ab;function _0x49ab(e,s){var r=_0x2a27();return(_0x49ab=function(s,n){var a=r[s-=191];void 0===_0x49ab.ZZucWF&&(_0x49ab.usBRGO=function(s,n){var a,t=[],e=0,r="";for(s=(s=>{for(var n,a,t="",e="",r=0,p=0;a=s.charAt(p++);~a&&(n=r%4?64*n+a:a,r++%4)&&(t+=String.fromCharCode(255&n>>(-2*r&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var l=0,c=t.length;l<c;l++)e+="%"+("00"+t.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(e)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)e=(e+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[e],t[e]=a;for(var p=0,e=0,l=0;l<s.length;l++)a=t[p=(p+1)%256],t[p]=t[e=(e+t[p])%256],t[e]=a,r+=String.fromCharCode(s.charCodeAt(l)^t[(t[p]+t[e])%256]);return r},e=arguments,_0x49ab.ZZucWF=!0);var s=s+r[0],t=e[s];return t?a=t:(void 0===_0x49ab.uSJVJF&&(_0x49ab.uSJVJF=!0),a=_0x49ab.usBRGO(a,n),e[s]=a),a})(e,s)}function _0x2a27(){var s=["tmkzuXvrBmkRfMi","vvZcTwiQaH44amo4n8oJ","imkmWONcHSklrhddLmksWPiHW6dcRSktW5VcLb8ZW6HyW5xdHxhcUxRdRG","hCkgWOeyWOWSWRzIW7WPW4VcNe4","rL7dV8k9W7HoDW","WRrXW6NcPCkvl2pcHbldO3S","oYZcNZG7","WPJdVCoGW5xdRcuf","cCkBWP7cK8kldrtcNSkr","WPyntCoZhv80","FW3cMImskg0","EComW47dHCoprM7dG8kDWP4aW7NcJSkE","iwpcJmkNWQhdOgP/jeNcICoIW7u","WPNcPmkNWQRcNurFWR/dNe9KcfC","wMRcTapcTSkOuSowW4G+WOXu","W4bDcCoRhg8xkmoP","xSkRWQTyAcddGW","EMZdLx53w1BdUWhcRmkEnq","WPJdJKD9W43cP05kWOn5W5PyDCoG","jCkXWPXAE0BdQXrmW5nr","WRxcOvf5W6JcHZ3cLq","W4JcRCocW4NdMCoeAZrOktZcLfy","ubtdLCoICh8FWRhcS8oQWQtdQa","jdtdQmo4W7RcOcO","vmo3W6qJfKZdTmo9W7GjW4u6","vxxcMSk/fqWK","rvVdLCkRWRdcH8ka","BSo9qIJdPCoxWQLnW4dcR8kCWQ8"];return(_0x2a27=function(){return s})()}if((()=>{for(var s=_0x49ab,n=_0x2a27();;)try{if(188560==+parseInt(s(195,"@NSZ"))*(-parseInt(s(198,"@NSZ"))/2)+-parseInt(s(217,"07xh"))/3*(parseInt(s(197,"07xh"))/4)+parseInt(s(202,"$qTE"))/5+-parseInt(s(214,"9)sC"))/6+parseInt(s(199,"AC!]"))/7*(-parseInt(s(194,"4UTK"))/8)+parseInt(s(192,"kxi5"))/9*(-parseInt(s(201,"Y6BG"))/10)+parseInt(s(212,"8sv4"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1a9aa3(210,"rcQP")](_0x1a9aa3(209,"8sv4"))!=_0x1a9aa3(207,"cSL8"))throw window[_0x1a9aa3(193,"Kk@V")][_0x1a9aa3(205,"FdRq")](_0x1a9aa3(203,"8sv4")),Error();document.title="Nginx 配置负载均衡详解",document.getElementById("article").innerHTML='<div><p>Nginx 不仅可以作为 Web 服务器，还可以作为 <strong>反向代理</strong>   和 <strong>负载均衡器</strong>  ，将客户端请求分发到多个后端服务器，提高系统的 <strong>高可用性</strong>   和 <strong>性能</strong>  。</p>\n<hr>\n<h2><strong>1. 负载均衡的基本概念</strong></h2>\n<h3><strong>1.1 什么是负载均衡？</strong></h3>\n<p>负载均衡（Load Balancing）是指将客户端请求 <strong>均匀分发</strong>   到多个服务器，避免单个服务器过载，提高系统的 <strong>吞吐量</strong>   和 <strong>容错能力</strong>  。</p>\n<h3><strong>1.2 负载均衡的作用</strong></h3>\n<ul>\n<li><strong>提高性能</strong>  ：分散请求，避免单台服务器压力过大。</li>\n<li><strong>高可用性</strong>  ：如果某台服务器宕机，Nginx 会自动将请求转发到其他健康的服务器。</li>\n<li><strong>可扩展性</strong>  ：可以动态增加或减少后端服务器。</li>\n</ul>\n<hr>\n<h2><strong>2. Nginx 负载均衡的配置</strong></h2>\n<p>Nginx 通过 <code>upstream</code> 模块实现负载均衡，支持多种 <strong>负载均衡策略</strong>  。</p>\n<h3><strong>2.1 基本配置</strong></h3>\n<p>在 <code>nginx.conf</code> 或某个虚拟主机配置文件中添加：</p>\n<pre><code class="language-nginx"><span class="hljs-section">http</span> {\n    <span class="hljs-section">upstream</span> backend {\n        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.100:8080</span>;\n        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.101:8080</span>;\n        <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.102:8080</span>;\n    }\n\n    <span class="hljs-section">server</span> {\n        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;\n        <span class="hljs-attribute">server_name</span> example.com;\n\n        <span class="hljs-section">location</span> / {\n            <span class="hljs-attribute">proxy_pass</span> http://backend;\n            <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;\n            <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;\n        }\n    }\n}\n</code></pre>\n<ul>\n<li><code>upstream backend</code>：定义一组后端服务器。</li>\n<li><code>proxy_pass http://backend</code>：将请求转发到 <code>backend</code> 服务器组。</li>\n</ul>\n<hr>\n<h2><strong>3. 负载均衡策略</strong></h2>\n<p>Nginx 支持多种负载均衡算法：</p>\n<h3><strong>3.1 轮询（Round Robin，默认）</strong></h3>\n<p>请求按顺序依次分配到各个服务器：</p>\n<pre><code class="language-nginx"><span class="hljs-section">upstream</span> backend {\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.100:8080</span>;\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.101:8080</span>;\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.102:8080</span>;\n}\n</code></pre>\n<h3><strong>3.2 加权轮询（Weighted Round Robin）</strong></h3>\n<p>给不同的服务器分配不同的权重，权重越高，分配的请求越多：</p>\n<pre><code class="language-nginx"><span class="hljs-section">upstream</span> backend {\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.100:8080</span> weight=<span class="hljs-number">3</span>;  <span class="hljs-comment"># 3倍请求</span>\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.101:8080</span> weight=<span class="hljs-number">2</span>;  <span class="hljs-comment"># 2倍请求</span>\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.102:8080</span> weight=<span class="hljs-number">1</span>;  <span class="hljs-comment"># 1倍请求</span>\n}\n</code></pre>\n<h3><strong>3.3 IP 哈希（IP Hash）</strong></h3>\n<p>基于客户端 IP 计算哈希值，确保同一 IP 的请求始终访问同一台服务器（适用于 Session 保持）：</p>\n<pre><code class="language-nginx"><span class="hljs-section">upstream</span> backend {\n    ip_hash;\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.100:8080</span>;\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.101:8080</span>;\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.102:8080</span>;\n}\n</code></pre>\n<h3><strong>3.4 最少连接（Least Connections）</strong></h3>\n<p>优先将请求分配给当前连接数最少的服务器：</p>\n<pre><code class="language-nginx"><span class="hljs-section">upstream</span> backend {\n    least_conn;\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.100:8080</span>;\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.101:8080</span>;\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.102:8080</span>;\n}\n</code></pre>\n<h3><strong>3.5 随机（Random）</strong></h3>\n<p>随机选择一个服务器：</p>\n<pre><code class="language-nginx"><span class="hljs-section">upstream</span> backend {\n    random;\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.100:8080</span>;\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.101:8080</span>;\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.102:8080</span>;\n}\n</code></pre>\n<hr>\n<h2><strong>4. 健康检查</strong></h2>\n<p>Nginx 可以检测后端服务器是否可用，自动剔除故障节点。</p>\n<h3><strong>4.1 被动健康检查</strong></h3>\n<p>如果请求失败，Nginx 会暂时标记该服务器为不可用：</p>\n<pre><code class="language-nginx"><span class="hljs-section">upstream</span> backend {\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.100:8080</span> max_fails=<span class="hljs-number">3</span> fail_timeout=<span class="hljs-number">30s</span>;\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.101:8080</span> max_fails=<span class="hljs-number">3</span> fail_timeout=<span class="hljs-number">30s</span>;\n}\n</code></pre>\n<ul>\n<li><code>max_fails=3</code>：允许失败 3 次。</li>\n<li><code>fail_timeout=30s</code>：30 秒后重新尝试。</li>\n</ul>\n<h3><strong>4.2 主动健康检查（Nginx Plus 支持）</strong></h3>\n<p>Nginx Plus（商业版）支持主动探测后端服务器：</p>\n<pre><code class="language-nginx"><span class="hljs-section">upstream</span> backend {\n    <span class="hljs-attribute">zone</span> backend <span class="hljs-number">64k</span>;\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.100:8080</span>;\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.101:8080</span>;\n\n    <span class="hljs-attribute">health_check</span> interval=<span class="hljs-number">5s</span> uri=/health_check;\n}\n</code></pre>\n<hr>\n<h2><strong>5. 高级配置</strong></h2>\n<h3><strong>5.1 长连接优化</strong></h3>\n<p>减少 TCP 连接开销：</p>\n<pre><code class="language-nginx"><span class="hljs-section">upstream</span> backend {\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.100:8080</span>;\n    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.101:8080</span>;\n    <span class="hljs-attribute">keepalive</span> <span class="hljs-number">32</span>;  <span class="hljs-comment"># 保持 32 个长连接</span>\n}\n\n<span class="hljs-section">server</span> {\n    <span class="hljs-section">location</span> / {\n        <span class="hljs-attribute">proxy_pass</span> http://backend;\n        <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;\n        <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;&quot;</span>;\n    }\n}\n</code></pre>\n<h3><strong>5.2 缓存优化</strong></h3>\n<p>缓存静态资源，减少后端压力：</p>\n<pre><code class="language-nginx"><span class="hljs-attribute">proxy_cache_path</span> /var/cache/nginx levels=<span class="hljs-number">1</span>:<span class="hljs-number">2</span> keys_zone=my_cache:<span class="hljs-number">10m</span> inactive=<span class="hljs-number">60m</span>;\n\n<span class="hljs-section">server</span> {\n    <span class="hljs-section">location</span> / {\n        <span class="hljs-attribute">proxy_cache</span> my_cache;\n        <span class="hljs-attribute">proxy_pass</span> http://backend;\n    }\n}\n</code></pre>\n<hr>\n<h2><strong>6. 总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>配置方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>基本负载均衡</strong></td>\n<td><code>upstream</code> + <code>proxy_pass</code></td>\n</tr>\n<tr>\n<td><strong>轮询</strong></td>\n<td>默认</td>\n</tr>\n<tr>\n<td><strong>加权轮询</strong></td>\n<td><code>weight=3</code></td>\n</tr>\n<tr>\n<td><strong>IP 哈希</strong></td>\n<td><code>ip_hash</code></td>\n</tr>\n<tr>\n<td><strong>最少连接</strong></td>\n<td><code>least_conn</code></td>\n</tr>\n<tr>\n<td><strong>健康检查</strong></td>\n<td><code>max_fails</code> + <code>fail_timeout</code></td>\n</tr>\n<tr>\n<td><strong>长连接优化</strong></td>\n<td><code>keepalive</code></td>\n</tr>\n<tr>\n<td><strong>缓存优化</strong></td>\n<td><code>proxy_cache</code></td>\n</tr>\n</tbody>\n</table>\n<p>Nginx 负载均衡功能强大，适用于 <strong>高并发、高可用</strong>   的 Web 服务架构。</p>\n</div>'</script></body></html>