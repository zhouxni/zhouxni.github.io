<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0xd9ee74=_0xaf03;function _0xaf03(t,s){var e=_0x45f7();return(_0xaf03=function(s,n){var a=e[s-=162];void 0===_0xaf03.xXQXTt&&(_0xaf03.yVhnNN=function(s,n){var a,l=[],t=0,e="";for(s=(s=>{for(var n,a,l="",t="",e=0,r=0;a=s.charAt(r++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,c=l.length;p<c;p++)t+="%"+("00"+l.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(t)})(s),r=0;r<256;r++)l[r]=r;for(r=0;r<256;r++)t=(t+l[r]+n.charCodeAt(r%n.length))%256,a=l[r],l[r]=l[t],l[t]=a;for(var r=0,t=0,p=0;p<s.length;p++)a=l[r=(r+1)%256],l[r]=l[t=(t+l[r])%256],l[t]=a,e+=String.fromCharCode(s.charCodeAt(p)^l[(l[r]+l[t])%256]);return e},t=arguments,_0xaf03.xXQXTt=!0);var s=s+e[0],l=t[s];return l?a=l:(void 0===_0xaf03.NbhEwn&&(_0xaf03.NbhEwn=!0),a=_0xaf03.yVhnNN(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0xaf03,n=_0x45f7();;)try{if(150616==+parseInt(s(186,"e[4F"))+parseInt(s(169,"^VJ#"))/2*(-parseInt(s(185,"FNvi"))/3)+parseInt(s(166,"8Gg$"))/4+-parseInt(s(184,"&ZPA"))/5*(-parseInt(s(187,"VlZG"))/6)+-parseInt(s(183,"rV&K"))/7+-parseInt(s(162,"yn7*"))/8+parseInt(s(180,"nPU2"))/9*(parseInt(s(178,"E%0h"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0xd9ee74(167,"]0I)")](_0xd9ee74(164,"(YyS"))!=_0xd9ee74(177,"b^w%"))throw window[_0xd9ee74(173,"&2yz")][_0xd9ee74(174,"HR]$")](_0xd9ee74(171,"e[4F")),Error();function _0x45f7(){var s=["DYfzWPjCvMyhhSo1WQq","W4BcNmocFWxcHCk0W6y","W6pcKxhcGCkqW7D3wwys","WOC5W51BfIurnG0inmoF","WOiYWRZdJ8kcs2GMmwu","WRrrWRNdT8ovWQuEDCobWQddGmk7W7y","wuK9kd/cVxZcKmk3gmoIqa","qtBdSx5CWP0nW64n","ngFcOIGEW5H2W7SIWO7dU8o+W5K","gSkKW7KStctdSmkVWO4XkG","d0SLWOlcQw4E","WRfjsY80umk+","emklv3XGrXVdK3a","DCoJm3e8bCoCWOu1W4ddP8oYW6O","W514WPSsusDjDJ8HnCoUxwhdMCoDoIdcU2jsWOBcH8oFW6vh","WQxdPZpcPmomW4SgqMpcNq","c2PCCGm8Dwm","W7POAaCcACkO","xCkDxx4zWOS+W5tcMa","kX/dGCoxWP8Re8k/cqDX","WRzysw8H","WRqSWP3dKWJcNZjNz8k1lSompW","WRKOWP7dKGNdHgboF8kwpa","WPHBWOJcQGBcGSk9","W6NcSmo5WQpcPv0MW4utvq","ECkjW4xdUXZdUu8M"];return(_0x45f7=function(){return s})()}document.title="Node.js Cluster 模块详解",document.getElementById("article").innerHTML='<div><p>Node.js 的 <code>cluster</code> 模块允许你轻松创建共享同一服务器端口的子进程（worker），充分利用多核 CPU 的性能。以下是关于该模块的详细解析：</p>\n<h2>基本概念</h2>\n<ol>\n<li><strong>主进程（Master）</strong>  ：负责管理工作进程，通常不处理实际业务逻辑</li>\n<li><strong>工作进程（Worker）</strong>  ：实际处理请求的子进程，由主进程 fork 出来</li>\n</ol>\n<h2>核心功能</h2>\n<h3>创建集群</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> cluster = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cluster&#x27;</span>);\n<span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);\n<span class="hljs-keyword">const</span> numCPUs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;os&#x27;</span>).<span class="hljs-title function_">cpus</span>().<span class="hljs-property">length</span>;\n\n<span class="hljs-keyword">if</span> (cluster.<span class="hljs-property">isMaster</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`主进程 <span class="hljs-subst">${process.pid}</span> 正在运行`</span>);\n\n  <span class="hljs-comment">// 衍生工作进程</span>\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numCPUs; i++) {\n    cluster.<span class="hljs-title function_">fork</span>();\n  }\n\n  cluster.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;exit&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">worker, code, signal</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`工作进程 <span class="hljs-subst">${worker.process.pid}</span> 已退出`</span>);\n  });\n} <span class="hljs-keyword">else</span> {\n  <span class="hljs-comment">// 工作进程可以共享任何 TCP 连接</span>\n  <span class="hljs-comment">// 在本例子中，共享的是 HTTP 服务器</span>\n  http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>);\n    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;你好世界\\n&#x27;</span>);\n  }).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>);\n\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`工作进程 <span class="hljs-subst">${process.pid}</span> 已启动`</span>);\n}\n</code></pre>\n<h3>主要方法和属性</h3>\n<ol>\n<li><strong>cluster.isMaster</strong>  ：如果进程是主进程，则为 true</li>\n<li><strong>cluster.isWorker</strong>  ：如果进程是工作进程，则为 true</li>\n<li><strong>cluster.fork([env])</strong>  ：衍生一个新的工作进程</li>\n<li><strong>cluster.setupMaster([settings])</strong>  ：修改默认的 fork 行为</li>\n<li><strong>cluster.worker</strong>  ：当前工作进程对象的引用</li>\n<li><strong>cluster.workers</strong>  ：存储活动工作进程对象的哈希表</li>\n</ol>\n<h3>事件</h3>\n<ol>\n<li><strong>fork</strong>  ：当新的工作进程被 fork 时触发</li>\n<li><strong>online</strong>  ：当工作进程发送在线消息时触发</li>\n<li><strong>listening</strong>  ：当工作进程调用 listen() 后触发</li>\n<li><strong>disconnect</strong>  ：当工作进程 IPC 通道断开连接时触发</li>\n<li><strong>exit</strong>  ：当工作进程退出时触发</li>\n<li><strong>message</strong>  ：当主进程收到工作进程发送的消息时触发</li>\n</ol>\n<h2>高级用法</h2>\n<h3>进程间通信</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 主进程</span>\ncluster.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">worker, message</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`收到来自工作进程 <span class="hljs-subst">${worker.id}</span> 的消息: <span class="hljs-subst">${message}</span>`</span>);\n});\n\n<span class="hljs-comment">// 工作进程</span>\nprocess.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;你好主进程&#x27;</span>);\n</code></pre>\n<h3>优雅重启</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 主进程</span>\ncluster.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;exit&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">worker, code, signal</span>) =&gt;</span> {\n  <span class="hljs-keyword">if</span> (code !== <span class="hljs-number">0</span> &amp;&amp; !worker.<span class="hljs-property">exitedAfterDisconnect</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;工作进程崩溃，启动一个新的工作进程&#x27;</span>);\n    cluster.<span class="hljs-title function_">fork</span>();\n  }\n});\n\n<span class="hljs-comment">// 接收SIGUSR2信号实现零停机重启</span>\nprocess.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;SIGUSR2&#x27;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> workers = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(cluster.<span class="hljs-property">workers</span>);\n  \n  <span class="hljs-keyword">function</span> <span class="hljs-title function_">restartWorker</span>(<span class="hljs-params">i</span>) {\n    <span class="hljs-keyword">if</span> (i &gt;= workers.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span>;\n    <span class="hljs-keyword">const</span> worker = workers[i];\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`停止工作进程 <span class="hljs-subst">${worker.process.pid}</span>`</span>);\n    worker.<span class="hljs-title function_">disconnect</span>();\n    \n    worker.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;exit&#x27;</span>, <span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-keyword">const</span> newWorker = cluster.<span class="hljs-title function_">fork</span>();\n      newWorker.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;listening&#x27;</span>, <span class="hljs-function">() =&gt;</span> {\n        <span class="hljs-title function_">restartWorker</span>(i + <span class="hljs-number">1</span>);\n      });\n    });\n  }\n  \n  <span class="hljs-title function_">restartWorker</span>(<span class="hljs-number">0</span>);\n});\n</code></pre>\n<h3>负载均衡策略</h3>\n<p>Node.js 提供了两种负载均衡策略（通过 <code>cluster.schedulingPolicy</code> 设置）：</p>\n<ol>\n<li><code>cluster.SCHED_RR</code> - 轮询（默认）</li>\n<li><code>cluster.SCHED_NONE</code> - 由操作系统调度</li>\n</ol>\n<h2>性能考虑</h2>\n<ol>\n<li><strong>共享连接</strong>  ：所有工作进程共享相同的服务器句柄</li>\n<li><strong>无状态应用</strong>  ：最适合无状态应用，因为工作进程不共享内存</li>\n<li><strong>会话处理</strong>  ：需要外部存储（如 Redis）来共享会话数据</li>\n</ol>\n<h2>实际应用场景</h2>\n<ol>\n<li>Web 服务器（HTTP/HTTPS）</li>\n<li>TCP 服务器</li>\n<li>任何需要利用多核 CPU 的长时间运行的服务</li>\n</ol>\n<h2>注意事项</h2>\n<ol>\n<li>工作进程是独立的进程，不共享内存</li>\n<li>每个工作进程有自己的事件循环、内存空间和 V8 实例</li>\n<li>工作进程崩溃不会影响主进程和其他工作进程</li>\n<li>主进程和工作进程之间通过 IPC 通信</li>\n</ol>\n<p>通过合理使用 cluster 模块，可以显著提高 Node.js 应用的性能和可靠性。</p>\n</div>'</script></body></html>