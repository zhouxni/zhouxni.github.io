<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x54b8a5=_0x55ec;function _0x5081(){var s=["W6GoW5NcSrRcGLFdM8o/WPpdMmoy","f8oAbKe6","W5NcOYeWyHRdQK7cV8kpBSow","WOZdNCowWOFdRJVcT8oqW4XkWPddOa","WQm4CZhdMx4fffqzwJFcHbxcHmkzW6CAWPVcRCo3W4zoW6bCbG","WRHchr9iWO7dMxqH","WOtdISkkgCoAgbdcQ8krWR7dQ8kc","wZrBEwJdKtimWRbRWO7cGMO","yI1timkAuCoRWP9HA03dN8o3","r2LLWR1xbSknCKdcMhBdVG","WO3cTCoTWP3dGsiU","W6BdHCk6fcVcJZNdO25XpmkG","WRGjhN7cRCoHE8oNEZbtcSkA","W5NcJmkAW7FcRw7cIG","WRNdTbb6o1L3WQC7WOhdVGa","g8odgIisW7hcHZDHAmoaDG","WRRdTX5XpvGsWOCdWQhdSqq+","W57cPc41zr/cRupcS8k8rSoqFa","W4dcQYXFyCkAlWK","WQRdPSkfWQ0+W6JcSCkSWRamWQ1iW7u"];return(_0x5081=function(){return s})()}function _0x55ec(e,s){var o=_0x5081();return(_0x55ec=function(s,n){var a=o[s-=457];void 0===_0x55ec.FEicrY&&(_0x55ec.YFDfLP=function(s,n){var a,r=[],e=0,o="";for(s=(s=>{for(var n,a,r="",e="",o=0,t=0;a=s.charAt(t++);~a&&(n=o%4?64*n+a:a,o++%4)&&(r+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,c=r.length;p<c;p++)e+="%"+("00"+r.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(s),t=0;t<256;t++)r[t]=t;for(t=0;t<256;t++)e=(e+r[t]+n.charCodeAt(t%n.length))%256,a=r[t],r[t]=r[e],r[e]=a;for(var t=0,e=0,p=0;p<s.length;p++)a=r[t=(t+1)%256],r[t]=r[e=(e+r[t])%256],r[e]=a,o+=String.fromCharCode(s.charCodeAt(p)^r[(r[t]+r[e])%256]);return o},e=arguments,_0x55ec.FEicrY=!0);var s=s+o[0],r=e[s];return r?a=r:(void 0===_0x55ec.wwHenx&&(_0x55ec.wwHenx=!0),a=_0x55ec.YFDfLP(a,n),e[s]=a),a})(e,s)}if((()=>{for(var s=_0x55ec,n=_0x5081();;)try{if(217128==+parseInt(s(464,"]Pc#"))+parseInt(s(473,"d5UQ"))/2+parseInt(s(460,"hl5a"))/3+-parseInt(s(468,"6pYu"))/4+parseInt(s(470,"8NgY"))/5+parseInt(s(476,"CBB!"))/6+-parseInt(s(465,"4!Is"))/7)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x54b8a5(466,"CBB!")](_0x54b8a5(458,"exol"))!=_0x54b8a5(474,"&5QP"))throw window[_0x54b8a5(471,"WGpE")][_0x54b8a5(463,"[s0Q")](_0x54b8a5(457,"Sqs5")),Error();document.title="Jenkins 中通过 Docker 部署应用",document.getElementById("article").innerHTML='<div><p>在 Jenkins 中通过 Docker 部署应用是一种高效、可移植的方式，尤其适合微服务架构或需要环境隔离的场景。以下是详细流程和最佳实践：</p>\n<hr>\n<h2><strong>1. 准备工作</strong></h2>\n<h3><strong>(1) 确保环境支持 Docker</strong></h3>\n<ul>\n<li>Jenkins 服务器需安装 Docker，并确保 Jenkins 用户有权限操作 Docker（通常需要将 Jenkins 用户加入 <code>docker</code> 组）：<pre><code class="language-bash"><span class="hljs-built_in">sudo</span> usermod -aG docker jenkins  <span class="hljs-comment"># 将 jenkins 用户加入 docker 组</span>\n<span class="hljs-built_in">sudo</span> systemctl restart jenkins   <span class="hljs-comment"># 重启 Jenkins 使配置生效</span>\n</code></pre>\n</li>\n<li>验证 Docker 是否可用：<pre><code class="language-bash">docker --version\ndocker run hello-world  <span class="hljs-comment"># 测试运行容器</span>\n</code></pre>\n</li>\n</ul>\n<h3><strong>(2) 安装 Jenkins 插件</strong></h3>\n<ul>\n<li>在 Jenkins 的 <strong>插件管理</strong>   中安装以下插件：\n<ul>\n<li><strong>Docker Pipeline</strong>   （支持在 Pipeline 中直接调用 Docker 命令）</li>\n<li><strong>Docker</strong>   （可选，提供 Docker 相关的构建步骤）</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2><strong>2. 通过 Docker 部署应用的两种方式</strong></h2>\n<h3><strong>方式 1：直接在 Jenkins Pipeline 中调用 Docker 命令</strong></h3>\n<p>适用于简单场景，直接在 Pipeline 脚本中编写 Docker 命令。</p>\n<h4><strong>示例：部署一个 Java Spring Boot 应用</strong></h4>\n<pre><code class="language-groovy">pipeline {\n    agent any\n\n    environment {\n        IMAGE_NAME = <span class="hljs-string">&quot;your-registry/your-app:latest&quot;</span>\n        DOCKER_HOST = <span class="hljs-string">&quot;tcp://your-docker-host:2375&quot;</span>  # 如果是远程 Docker\n    }\n\n    stages {\n        stage(<span class="hljs-string">&#x27;Checkout&#x27;</span>) {\n            steps {\n                git <span class="hljs-attr">branch:</span> <span class="hljs-string">&#x27;main&#x27;</span>, <span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;https://github.com/your-repo/your-app.git&#x27;</span>\n            }\n        }\n\n        stage(<span class="hljs-string">&#x27;Build Docker Image&#x27;</span>) {\n            steps {\n                script {\n                    sh <span class="hljs-string">&#x27;docker build -t ${IMAGE_NAME} .&#x27;</span>  # 构建镜像\n                }\n            }\n        }\n\n        stage(<span class="hljs-string">&#x27;Push Docker Image&#x27;</span>) {\n            steps {\n                script {\n                    withCredentials([usernamePassword(<span class="hljs-attr">credentialsId:</span> <span class="hljs-string">&#x27;docker-hub-creds&#x27;</span>, <span class="hljs-attr">usernameVariable:</span> <span class="hljs-string">&#x27;DOCKER_USER&#x27;</span>, <span class="hljs-attr">passwordVariable:</span> <span class="hljs-string">&#x27;DOCKER_PASS&#x27;</span>)]) {\n                        sh <span class="hljs-string">&#x27;echo ${DOCKER_PASS} | docker login -u ${DOCKER_USER} --password-stdin&#x27;</span>\n                        sh <span class="hljs-string">&#x27;docker push ${IMAGE_NAME}&#x27;</span>\n                    }\n                }\n            }\n        }\n\n        stage(<span class="hljs-string">&#x27;Deploy to Production&#x27;</span>) {\n            steps {\n                script {\n                    <span class="hljs-comment">// 停止并删除旧容器（如果存在）</span>\n                    sh <span class="hljs-string">&#x27;docker stop your-app || true&#x27;</span>\n                    sh <span class="hljs-string">&#x27;docker rm your-app || true&#x27;</span>\n                    <span class="hljs-comment">// 运行新容器</span>\n                    sh <span class="hljs-string">&#x27;docker run -d --name your-app -p 8080:8080 ${IMAGE_NAME}&#x27;</span>\n                }\n            }\n        }\n    }\n\n    post {\n        success {\n            echo <span class="hljs-string">&#x27;部署成功！&#x27;</span>\n        }\n        failure {\n            echo <span class="hljs-string">&#x27;部署失败，请检查日志！&#x27;</span>\n        }\n    }\n}\n</code></pre>\n<h4><strong>关键点说明</strong></h4>\n<ul>\n<li><code>docker build -t</code>：构建镜像，<code>-t</code> 指定镜像名称和标签。</li>\n<li><code>docker push</code>：推送镜像到仓库（如 Docker Hub、Harbor）。</li>\n<li><code>docker run -d --name</code>：后台运行容器，<code>-p</code> 映射端口。</li>\n</ul>\n<hr>\n<h3><strong>方式 2：使用 Dockerfile 和 Jenkinsfile 结合（推荐）</strong></h3>\n<p>适用于复杂场景，通过 <code>Dockerfile</code> 定义镜像构建过程，Jenkinsfile 调用 Docker 命令。</p>\n<h4><strong>步骤 1：编写 Dockerfile</strong></h4>\n<p>在项目根目录创建 <code>Dockerfile</code>（以 Java Spring Boot 为例）：</p>\n<pre><code class="language-dockerfile"><span class="hljs-comment"># 使用官方基础镜像</span>\n<span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">17</span>-jdk-slim\n\n<span class="hljs-comment"># 设置工作目录</span>\n<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span>\n\n<span class="hljs-comment"># 复制构建产物（假设是 Maven 项目，打包后的 JAR 文件）</span>\n<span class="hljs-keyword">COPY</span><span class="language-bash"> target/your-app.jar app.jar</span>\n\n<span class="hljs-comment"># 暴露端口</span>\n<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span>\n\n<span class="hljs-comment"># 启动命令</span>\n<span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;app.jar&quot;</span>]</span>\n</code></pre>\n<h4><strong>步骤 2：编写 Jenkinsfile</strong></h4>\n<pre><code class="language-groovy">pipeline {\n    agent any\n\n    environment {\n        IMAGE_NAME = <span class="hljs-string">&quot;your-registry/your-app:${env.BUILD_NUMBER}&quot;</span>  # 使用构建号作为标签\n    }\n\n    stages {\n        stage(<span class="hljs-string">&#x27;Checkout&#x27;</span>) {\n            steps {\n                git <span class="hljs-attr">branch:</span> <span class="hljs-string">&#x27;main&#x27;</span>, <span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;https://github.com/your-repo/your-app.git&#x27;</span>\n            }\n        }\n\n        stage(<span class="hljs-string">&#x27;Build Application&#x27;</span>) {\n            steps {\n                sh <span class="hljs-string">&#x27;mvn clean package&#x27;</span>  # 假设是 Maven 项目\n            }\n        }\n\n        stage(<span class="hljs-string">&#x27;Build Docker Image&#x27;</span>) {\n            steps {\n                script {\n                    sh <span class="hljs-string">&quot;docker build -t ${IMAGE_NAME} .&quot;</span>\n                }\n            }\n        }\n\n        stage(<span class="hljs-string">&#x27;Push Docker Image&#x27;</span>) {\n            steps {\n                script {\n                    withCredentials([usernamePassword(<span class="hljs-attr">credentialsId:</span> <span class="hljs-string">&#x27;docker-hub-creds&#x27;</span>, <span class="hljs-attr">usernameVariable:</span> <span class="hljs-string">&#x27;DOCKER_USER&#x27;</span>, <span class="hljs-attr">passwordVariable:</span> <span class="hljs-string">&#x27;DOCKER_PASS&#x27;</span>)]) {\n                        sh <span class="hljs-string">&#x27;echo ${DOCKER_PASS} | docker login -u ${DOCKER_USER} --password-stdin&#x27;</span>\n                        sh <span class="hljs-string">&quot;docker push ${IMAGE_NAME}&quot;</span>\n                    }\n                }\n            }\n        }\n\n        stage(<span class="hljs-string">&#x27;Deploy to Production&#x27;</span>) {\n            steps {\n                script {\n                    <span class="hljs-comment">// 拉取最新镜像并运行容器（假设生产环境有 Docker）</span>\n                    sh <span class="hljs-string">&quot;ssh user@production-server &#x27;docker pull ${IMAGE_NAME}&#x27;&quot;</span>\n                    sh <span class="hljs-string">&quot;ssh user@production-server &#x27;docker stop your-app || true&#x27;&quot;</span>\n                    sh <span class="hljs-string">&quot;ssh user@production-server &#x27;docker rm your-app || true&#x27;&quot;</span>\n                    sh <span class="hljs-string">&quot;ssh user@production-server &#x27;docker run -d --name your-app -p 8080:8080 ${IMAGE_NAME}&#x27;&quot;</span>\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<h4><strong>优势</strong></h4>\n<ul>\n<li><strong>镜像版本化</strong>   ：通过 <code>BUILD_NUMBER</code> 或 Git Commit ID 标记镜像，便于回滚。</li>\n<li><strong>环境一致性</strong>   ：生产环境和开发环境使用相同的 Dockerfile 构建镜像。</li>\n</ul>\n<hr>\n<h2><strong>3. 高级场景</strong></h2>\n<h3><strong>(1) 使用 Docker Compose 部署多容器应用</strong></h3>\n<p>如果应用依赖多个服务（如数据库、Redis），可以用 <code>docker-compose.yml</code> 定义服务。</p>\n<h4><strong>示例 Jenkinsfile 片段</strong></h4>\n<pre><code class="language-groovy">stage(<span class="hljs-string">&#x27;Deploy with Docker Compose&#x27;</span>) {\n    steps {\n        script {\n            sh <span class="hljs-string">&#x27;scp docker-compose.yml user@production-server:/app/&#x27;</span>\n            sh <span class="hljs-string">&quot;ssh user@production-server &#x27;cd /app &amp;&amp; docker-compose down&#x27;&quot;</span>\n            sh <span class="hljs-string">&quot;ssh user@production-server &#x27;cd /app &amp;&amp; docker-compose pull&#x27;&quot;</span>\n            sh <span class="hljs-string">&quot;ssh user@production-server &#x27;cd /app &amp;&amp; docker-compose up -d&#x27;&quot;</span>\n        }\n    }\n}\n</code></pre>\n<h3><strong>(2) 部署到 Kubernetes</strong></h3>\n<p>如果生产环境使用 Kubernetes，可以通过 <code>kubectl</code> 或 Helm 部署 Docker 镜像。</p>\n<h4><strong>示例 Jenkinsfile 片段</strong></h4>\n<pre><code class="language-groovy">stage(<span class="hljs-string">&#x27;Deploy to Kubernetes&#x27;</span>) {\n    steps {\n        script {\n            sh <span class="hljs-string">&quot;ssh user@k8s-master &#x27;kubectl set image deployment/your-app your-app=${IMAGE_NAME}&#x27;&quot;</span>\n        }\n    }\n}\n</code></pre>\n<hr>\n<h2><strong>4. 最佳实践</strong></h2>\n<ol>\n<li>\n<p><strong>镜像优化</strong>   ：</p>\n<ul>\n<li>使用多阶段构建减少镜像体积。</li>\n<li>避免在镜像中包含敏感信息（如密码），使用 <code>ENV</code> 或 <code>Secrets</code> 管理。</li>\n</ul>\n</li>\n<li>\n<p><strong>安全</strong>   ：</p>\n<ul>\n<li>限制 Jenkins 对 Docker 的权限（避免使用 <code>root</code> 用户运行 Docker）。</li>\n<li>使用 <code>docker scan</code> 扫描镜像漏洞。</li>\n</ul>\n</li>\n<li>\n<p><strong>回滚机制</strong>   ：</p>\n<ul>\n<li>保留历史版本的镜像标签，支持快速回滚：<pre><code class="language-bash">docker run -d --name your-app your-registry/your-app:previous-version\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>日志与监控</strong>   ：</p>\n<ul>\n<li>集成日志收集工具（如 ELK、Fluentd）。</li>\n<li>使用 Prometheus + Grafana 监控容器性能。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2><strong>5. 常见问题解决</strong></h2>\n<table>\n<thead>\n<tr>\n<th><strong>问题</strong></th>\n<th><strong>解决方案</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Jenkins 无权限操作 Docker</td>\n<td>将 Jenkins 用户加入 <code>docker</code> 组，并重启 Jenkins。</td>\n</tr>\n<tr>\n<td>Docker 构建缓存失效</td>\n<td>在 <code>Dockerfile</code> 中合理使用 <code>COPY</code> 和 <code>RUN</code> 指令，利用缓存加速构建。</td>\n</tr>\n<tr>\n<td>镜像推送失败</td>\n<td>检查 Docker Hub 或私有仓库的凭据是否正确，网络是否通畅。</td>\n</tr>\n<tr>\n<td>容器启动后立即退出</td>\n<td>检查容器日志：<code>docker logs your-app</code>，确认启动命令是否正确。</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>通过以上方法，可以高效、可靠地通过 Jenkins + Docker 实现应用的自动化部署。</p>\n</div>'</script></body></html>