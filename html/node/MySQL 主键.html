<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x737639=_0x585e;function _0x57bc(){var s=["lConhg5F","WQfwWPL8gSkstG","s8opWOeuW4hdKqyea8kHW4CX","dshcM8kiWPpdUCkBW54","qJ0DlmkoWR3cPsnpW6GqWOW","ft0jWP7cQCoyW6ClW5yHDCkO","W4egW4byWPegWPbJwCkOWPtcRmkq","zbj2W63dM8oIWO0","t8onWOnqWQBcIdeElW","WRrrCGlcOrtcPb/dT8omcaK","CSkDW5y7WRfIWQmTW4PTymoMeW","WORdTrPsW5vPqCo9f8kZW6NdV3xdJCoRWPP4tM5hW57dLe3dPNdcQW","W6hcH0ddQmk5WRrNWRhcGeD1ka","CKpcPmoqWPSLACkeBmkdW7WKW58","W6xcGuldQmk+WRyaWRZcG11bbKy","tHzwWQVcSgpcSuDvW5VcJCkaW7G","hrGwW5ldGSkQW7u","fmkLc0ldUKxcNmo0","WRjvivxdReRcHWu","qHrHW4hdNmo0WQVcIHi","WR3cJLRcGuOBW4i","WR3dKW/dIrnvWO3cSCkyWPRdV8o+WRq","W5FcSvCAWPnLvSk5bmkmW4VdMeO","q8kJW4eFeConysNcGq","De7cOSkeW4ldMmolWQuQdmo9vSoc"];return(_0x57bc=function(){return s})()}function _0x585e(l,s){var o=_0x57bc();return(_0x585e=function(s,n){var a=o[s-=223];void 0===_0x585e.OJAgKp&&(_0x585e.nfkAfc=function(s,n){var a,e=[],l=0,o="";for(s=(s=>{for(var n,a,e="",l="",o=0,c=0;a=s.charAt(c++);~a&&(n=o%4?64*n+a:a,o++%4)&&(e+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,r=e.length;p<r;p++)l+="%"+("00"+e.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(l)})(s),c=0;c<256;c++)e[c]=c;for(c=0;c<256;c++)l=(l+e[c]+n.charCodeAt(c%n.length))%256,a=e[c],e[c]=e[l],e[l]=a;for(var c=0,l=0,p=0;p<s.length;p++)a=e[c=(c+1)%256],e[c]=e[l=(l+e[c])%256],e[l]=a,o+=String.fromCharCode(s.charCodeAt(p)^e[(e[c]+e[l])%256]);return o},l=arguments,_0x585e.OJAgKp=!0);var s=s+o[0],e=l[s];return e?a=e:(void 0===_0x585e.pzciqq&&(_0x585e.pzciqq=!0),a=_0x585e.nfkAfc(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x585e,n=_0x57bc();;)try{if(817367==+parseInt(s(228,"RLr)"))+-parseInt(s(244,"*)qT"))/2*(-parseInt(s(238,"OY^C"))/3)+-parseInt(s(239,"(kXk"))/4*(-parseInt(s(246,"uWK]"))/5)+-parseInt(s(236,"8Q8e"))/6+parseInt(s(240,"OY^C"))/7+parseInt(s(223,"gTVP"))/8+parseInt(s(234,"RLr)"))/9*(-parseInt(s(230,"YDgQ"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x737639(233,"mcGN")](_0x737639(245,"mcGN"))!=_0x737639(226,"fhNG"))throw window[_0x737639(229,"V^4D")][_0x737639(242,"4Pg8")](_0x737639(237,"gTVP")),Error();document.title="MySQL 主键",document.getElementById("article").innerHTML='<div><p>在 MySQL 中，<strong>主键（Primary Key，简称 PK）</strong>   是用于唯一标识表中每条记录的约束，它确保了数据的唯一性和完整性，同时也是数据库优化查询性能的核心手段。以下从定义、特性、类型、创建方式、最佳实践等维度进行全面详解。</p>\n<h2>一、主键的核心特性</h2>\n<p>主键必须满足以下 4 个核心规则，缺一不可：</p>\n<ol>\n<li><strong>唯一性（Unique）</strong>   ：主键字段的取值在表中绝对不重复（即使删除某条记录，其主键值也不能被重新使用，除非手动重置自增）。</li>\n<li><strong>非空性（Not Null）</strong>   ：主键字段不能为 <code>NULL</code>（MySQL 会自动为主键添加 <code>NOT NULL</code> 约束，无需手动声明）。</li>\n<li><strong>最小性（Minimal）</strong>   ：主键应使用最少的字段组合（优先单字段主键，避免冗余的复合主键）。</li>\n<li><strong>稳定性（Stable）</strong>   ：主键字段的值不应频繁修改（如避免用“用户名”“手机号”等可能变更的字段作为主键）。</li>\n</ol>\n<h2>二、主键的类型</h2>\n<p>MySQL 支持两种主流主键类型：<strong>单字段主键</strong>   和<strong>复合主键</strong>   ，实际开发中以单字段主键为主。</p>\n<h3>1. 单字段主键（最常用）</h3>\n<p>用表中一个字段唯一标识记录，常见场景：用户ID、订单ID、商品ID等。<br>\n支持的字段类型通常为<strong>整数类型</strong>   （推荐）或<strong>字符串类型</strong>   （需谨慎）：</p>\n<ul>\n<li><strong>整数类型（推荐）</strong>   ：<code>INT UNSIGNED</code>（中小型表）、<code>BIGINT UNSIGNED</code>（超大型表/分布式场景），配合 <code>AUTO_INCREMENT</code> 实现自增，性能最优。</li>\n<li><strong>字符串类型（谨慎使用）</strong>   ：<code>VARCHAR(36)</code>（存储 UUID）、<code>CHAR(18)</code>（存储雪花ID字符串），优点是分布式环境下无需协调自增，缺点是占用空间大、查询性能比整数低（字符串比较比整数慢）。</li>\n</ul>\n<h3>2. 复合主键（特殊场景）</h3>\n<p>用多个字段的组合唯一标识记录，仅适用于“无单一唯一字段”的场景（如多对多关联表）。<br>\n<strong>示例</strong>   ：用户-角色关联表（一个用户可关联多个角色，一个角色可关联多个用户），需用 <code>user_id + role_id</code> 作为复合主键：</p>\n<pre><code class="language-sql"><span class="hljs-keyword">CREATE TABLE</span> user_role (\n  user_id <span class="hljs-type">INT</span> UNSIGNED <span class="hljs-keyword">NOT NULL</span>,\n  role_id <span class="hljs-type">INT</span> UNSIGNED <span class="hljs-keyword">NOT NULL</span>,\n  <span class="hljs-comment">-- 复合主键：user_id 和 role_id 组合唯一</span>\n  <span class="hljs-keyword">PRIMARY KEY</span> (user_id, role_id),\n  <span class="hljs-comment">-- 外键关联（可选）</span>\n  <span class="hljs-keyword">FOREIGN KEY</span> (user_id) <span class="hljs-keyword">REFERENCES</span> <span class="hljs-keyword">user</span>(id),\n  <span class="hljs-keyword">FOREIGN KEY</span> (role_id) <span class="hljs-keyword">REFERENCES</span> role(id)\n);\n</code></pre>\n<p><strong>注意</strong>   ：复合主键存在明显缺点，需谨慎使用：</p>\n<ul>\n<li>后续若需添加新的唯一约束（如“用户-角色-生效时间”唯一），需额外创建唯一索引，无法直接修改主键；</li>\n<li>查询时需携带所有主键字段，操作繁琐；</li>\n<li>不支持 <code>AUTO_INCREMENT</code>（自增只能作用于单个整数字段）。</li>\n</ul>\n<h2>三、主键的创建方式</h2>\n<p>主键可在<strong>建表时创建</strong>   或<strong>建表后添加</strong>   （需确保表中已有数据无重复且非空），不允许删除主键（需先删除依赖，如外键，再重新定义）。</p>\n<h3>1. 建表时创建单字段主键（3种语法）</h3>\n<h4>语法1：字段后直接声明 <code>PRIMARY KEY</code>（简洁）</h4>\n<pre><code class="language-sql"><span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-keyword">user</span> (\n  id <span class="hljs-type">INT</span> UNSIGNED AUTO_INCREMENT <span class="hljs-keyword">PRIMARY KEY</span>, <span class="hljs-comment">-- 主键+自增</span>\n  username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">UNIQUE</span>,\n  age TINYINT UNSIGNED\n);\n</code></pre>\n<h4>语法2：独立 <code>PRIMARY KEY</code> 子句（适合字段较多时，清晰）</h4>\n<pre><code class="language-sql"><span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-keyword">user</span> (\n  id <span class="hljs-type">INT</span> UNSIGNED AUTO_INCREMENT,\n  username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">UNIQUE</span>,\n  age TINYINT UNSIGNED,\n  <span class="hljs-keyword">PRIMARY KEY</span> (id) <span class="hljs-comment">-- 独立声明主键</span>\n);\n</code></pre>\n<h4>语法3：字符串主键（UUID 示例）</h4>\n<pre><code class="language-sql"><span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-keyword">user</span> (\n  uuid <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">36</span>) <span class="hljs-keyword">PRIMARY KEY</span>, <span class="hljs-comment">-- UUID 长度固定36位</span>\n  username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">UNIQUE</span>\n);\n<span class="hljs-comment">-- 插入时需手动生成 UUID</span>\n<span class="hljs-keyword">INSERT INTO</span> <span class="hljs-keyword">user</span> (uuid, username) <span class="hljs-keyword">VALUES</span> (UUID(), <span class="hljs-string">&#x27;zhangsan&#x27;</span>);\n</code></pre>\n<h3>2. 建表后添加主键（需确保数据合法）</h3>\n<p>若表已创建且无主键，可通过 <code>ALTER TABLE</code> 添加（需确保目标字段无重复值、无 <code>NULL</code> 值）：</p>\n<pre><code class="language-sql"><span class="hljs-comment">-- 1. 先确保字段无 NULL 和重复值（可选，若有数据需先清理）</span>\n<span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>; <span class="hljs-comment">-- 填充 NULL</span>\n<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> id <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>) t); <span class="hljs-comment">-- 删除重复</span>\n\n<span class="hljs-comment">-- 2. 添加主键</span>\n<span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-keyword">user</span>\n<span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY KEY</span> (id); <span class="hljs-comment">-- 单字段主键</span>\n\n<span class="hljs-comment">-- 若添加复合主键</span>\n<span class="hljs-keyword">ALTER TABLE</span> user_role\n<span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY KEY</span> (user_id, role_id);\n</code></pre>\n<h3>3. 主键与 <code>AUTO_INCREMENT</code>（自增）的配合</h3>\n<p><code>AUTO_INCREMENT</code> 是 MySQL 对整数主键的“自增扩展”，用于自动生成唯一的主键值，是单字段主键的最佳实践。</p>\n<h4>核心规则：</h4>\n<ul>\n<li>仅支持 <strong>整数类型</strong>   （<code>TINYINT</code>/<code>SMALLINT</code>/<code>INT</code>/<code>BIGINT</code>），且字段必须是主键或唯一键（否则报错）；</li>\n<li>自增值从 <code>1</code> 开始，每次插入自动+1（若手动插入比当前自增值大的值，后续自增值会从该值+1开始）；</li>\n<li>自增值不会回滚（删除最后一条记录，下一次插入仍会使用“已删除值+1”，避免主键重复）。</li>\n</ul>\n<h4>示例：重置自增值</h4>\n<p>若需将自增值重置为 <code>1</code>（如测试环境清空表后），可通过以下方式：</p>\n<pre><code class="language-sql"><span class="hljs-comment">-- 方式1：清空表并重置自增（谨慎！会删除所有数据）</span>\n<span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span>; <span class="hljs-comment">-- 自增值自动重置为1</span>\n\n<span class="hljs-comment">-- 方式2：手动修改自增值（需确保新值大于当前最大主键值）</span>\n<span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-keyword">user</span> AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">-- 下次插入从100开始</span>\n</code></pre>\n<h2>四、主键索引的本质</h2>\n<p>MySQL 中，<strong>主键会自动创建一个唯一索引（Primary Index）</strong>   ，且该索引是“聚簇索引”（Clustered Index）—— 数据在磁盘上的存储顺序与主键索引的顺序一致。</p>\n<p>这意味着：</p>\n<ol>\n<li><strong>查询性能极高</strong>   ：通过主键查询时，MySQL 可直接定位到数据所在的磁盘位置（无需二次查找）；</li>\n<li><strong>排序性能优化</strong>   ：按主键排序时，无需额外排序（数据本身已按主键有序存储）；</li>\n<li><strong>辅助索引依赖主键</strong>   ：其他索引（如 <code>UNIQUE</code>、<code>INDEX</code>）的叶子节点存储的是“主键值”，而非完整数据（查询时需通过主键值回表查找，即“书签查找”）。</li>\n</ol>\n<p><strong>示例</strong>   ：若 <code>user</code> 表有 <code>username</code> 索引，查询 <code>SELECT * FROM user WHERE username = \'zhangsan\'</code> 的流程：</p>\n<ol>\n<li>先通过 <code>username</code> 索引找到对应的 <code>id</code>（主键值）；</li>\n<li>再通过 <code>id</code> 主键索引找到完整的用户数据。</li>\n</ol>\n<h2>五、主键设计的最佳实践</h2>\n<h3>1. 优先选择“整数自增主键”</h3>\n<ul>\n<li>优点：占用空间小（<code>INT</code> 仅4字节，<code>BIGINT</code> 8字节）、查询/排序性能高、无需手动生成值；</li>\n<li>适用场景：绝大多数业务表（用户表、订单表、商品表等）。</li>\n</ul>\n<h3>2. 分布式场景用“雪花ID（Snowflake）”</h3>\n<ul>\n<li>若系统是分布式架构（多数据库实例），自增主键会出现重复问题，此时推荐用<strong>雪花ID</strong>   （64位整数，含时间戳、机器ID、序列号）：\n<ul>\n<li>格式：1位符号位 + 41位时间戳（毫秒级，可用69年） + 10位机器ID（支持1024台机器） + 12位序列号（每毫秒支持4096个ID）；</li>\n<li>存储：用 <code>BIGINT UNSIGNED</code> 字段存储（避免符号位问题），性能接近自增主键。</li>\n</ul>\n</li>\n</ul>\n<h3>3. 避免用“业务字段”作为主键</h3>\n<ul>\n<li>禁止用“用户名”“手机号”“邮箱”等可能变更的字段作为主键（修改主键值会导致关联表的外键同步修改，风险高、性能差）；</li>\n<li>反例：用 <code>username</code> 作为用户表主键，若用户修改用户名，需同步更新所有关联表（如订单表、日志表）的 <code>username</code> 字段，极易出错。</li>\n</ul>\n<h3>4. 复合主键仅用于“多对多关联表”</h3>\n<ul>\n<li>除了“用户-角色”“商品-分类”等多对多关联表，其他场景一律用单字段主键；</li>\n<li>若关联表需额外字段（如“关联生效时间”），建议添加单字段主键（如 <code>id INT AUTO_INCREMENT PRIMARY KEY</code>），再用 <code>UNIQUE (user_id, role_id)</code> 确保唯一性。</li>\n</ul>\n<h3>5. 主键字段类型“最小够用”</h3>\n<ul>\n<li>中小型表（数据量≤4亿）用 <code>INT UNSIGNED</code>（最大值4294967295）；</li>\n<li>超大型表（数据量&gt;4亿）或分布式表用 <code>BIGINT UNSIGNED</code>（最大值18446744073709551615）；</li>\n<li>避免直接用 <code>BIGINT</code> 存储小数据（浪费空间）。</li>\n</ul>\n<h2>六、常见问题与避坑</h2>\n<h3>1. 主键能否为 <code>NULL</code>？</h3>\n<p>不能。MySQL 会自动为主键添加 <code>NOT NULL</code> 约束，插入 <code>NULL</code> 会报错：<code>ERROR 1048 (23000): Column \'id\' cannot be null</code>。</p>\n<h3>2. 一张表能否有多个主键？</h3>\n<p>不能。一张表只能有一个主键（单字段或复合），若需多个唯一约束，可通过 <code>UNIQUE</code> 索引实现（如 <code>username</code> 唯一、<code>phone</code> 唯一）。</p>\n<h3>3. 自增主键会重复吗？</h3>\n<ul>\n<li>单数据库实例：不会（自增值唯一且不回滚）；</li>\n<li>分布式多实例：会（不同实例的自增起始值可能重复），需用雪花ID或UUID解决。</li>\n</ul>\n<h3>4. 能否修改主键字段的值？</h3>\n<p>可以，但<strong>强烈不推荐</strong>   。修改主键会导致：</p>\n<ul>\n<li>关联表的外键值需同步修改（若开启外键约束，需手动处理级联更新，否则报错）；</li>\n<li>主键索引和所有辅助索引需重新维护，性能损耗大。</li>\n</ul>\n<h2>总结</h2>\n<p>主键是 MySQL 表的“灵魂”，其设计直接影响数据完整性和查询性能。核心原则是：<strong>优先选择整数自增主键（单字段），分布式场景用雪花ID，避免业务字段和冗余复合主键</strong>   。合理的主键设计能让数据库更高效、更稳定，是后端开发的基础技能之一。</p>\n</div>'</script></body></html>