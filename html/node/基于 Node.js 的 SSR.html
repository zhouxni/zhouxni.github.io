<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x14cb(){var s=["k8oTztqKW5pcTG3dTCkcpSkS","E8kWW4hdUdOWW7eZWP/dUIJdPW","W5jvvX95dNet","BmoIyI9Ukmkq","hConmCkPCeb5ha","CSo+W67cK8oJW7SWrSkZFCkhW6C","pmo+EqTxk8k+","WRT+WQXfDSkNya","W6TDWQxdJ8kIWO8kWRa8W6GRWOFcHG","WRW7W6qDkmo0C33cV8o4WR/dRW","f8k2s3JdLmkQWPC0WRNcRmoojHG","CCkSxmo0WOjsWPhdIav8WQNcU8kG","W4dcUZrQjmk4WQdcMr8","qmkleqqiW7r0W61RtCokWP/cIq","WQRdOSkIzmkDlSkMW7LmW6NcTXtdVCoE","v147ESk0fhVcHrVdNv7cNSk4","xmoCrmozkCkhW5FcGG","W69CqmkRW6ddHmkYkaH0W6/dQwW","vmoZdJlcNa","jSkAWPT/W5q9c8kD","WRJdQ2q2yCo6W57cRqWEnSolW5e","BSorWOTCWQFcPCkJ","W74NW67cPmo8DSkbWOtdMCo+uCkytCkCvr7cMfNcPSoZWP05a8o8W5mc","WQb1qe94WPddH8oSW4RcSmoVmCo1","W7vnWRtdQmk4f8koCa","DCo2WQCeWOnxkCkkcGVcICkIWOVdUG","ge9BzIfZWPS","DCk+WQtdGmkZWQ4S"];return(_0x14cb=function(){return s})()}function _0x1f06(l,s){var p=_0x14cb();return(_0x1f06=function(s,n){var t=p[s-=367];void 0===_0x1f06.lnuQCG&&(_0x1f06.MediwM=function(s,n){var t,a=[],l=0,p="";for(s=(s=>{for(var n,t,a="",l="",p=0,e=0;t=s.charAt(e++);~t&&(n=p%4?64*n+t:t,p++%4)&&(a+=String.fromCharCode(255&n>>(-2*p&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var o=0,c=a.length;o<c;o++)l+="%"+("00"+a.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)a[e]=e;for(e=0;e<256;e++)l=(l+a[e]+n.charCodeAt(e%n.length))%256,t=a[e],a[e]=a[l],a[l]=t;for(var e=0,l=0,o=0;o<s.length;o++)t=a[e=(e+1)%256],a[e]=a[l=(l+a[e])%256],a[l]=t,p+=String.fromCharCode(s.charCodeAt(o)^a[(a[e]+a[l])%256]);return p},l=arguments,_0x1f06.lnuQCG=!0);var s=s+p[0],a=l[s];return a?t=a:(void 0===_0x1f06.WOVtQG&&(_0x1f06.WOVtQG=!0),t=_0x1f06.MediwM(t,n),l[s]=t),t})(l,s)}var _0x17a094=_0x1f06;if((()=>{for(var s=_0x1f06,n=_0x14cb();;)try{if(604973==+parseInt(s(372,"yJ4l"))*(parseInt(s(379,"8B)U"))/2)+-parseInt(s(388,"wNhm"))/3*(-parseInt(s(377,"&anX"))/4)+parseInt(s(382,"4BN^"))/5+parseInt(s(367,"Q]wM"))/6+-parseInt(s(378,"D6oJ"))/7*(-parseInt(s(387,"P4@f"))/8)+parseInt(s(392,"SBUW"))/9*(parseInt(s(376,"WNuK"))/10)+-parseInt(s(369,"kxzB"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x17a094(375,"D6oJ")](_0x17a094(384,"SBUW"))!=_0x17a094(390,"4BN^"))throw window[_0x17a094(368,"vSW*")][_0x17a094(370,"[idG")](_0x17a094(394,"&%7%")),Error();document.title="基于 Node.js 的 SSR",document.getElementById("article").innerHTML='<div><p>基于 Node.js 的 SSR（服务器端渲染）技术是现代 Web 开发中的重要方案，它解决了传统客户端渲染（CSR）在首屏加载速度和 SEO 方面的短板。下面从技术原理、实现方式、核心挑战和最佳实践等方面进行详细解析。</p>\n<h3>一、SSR 与 CSR 的本质区别</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>客户端渲染 (CSR)</th>\n<th>服务器端渲染 (SSR)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>渲染位置</td>\n<td>浏览器 (客户端)</td>\n<td>Node.js 服务器</td>\n</tr>\n<tr>\n<td>首屏加载</td>\n<td>先加载空 HTML + JS，再动态渲染</td>\n<td>直接返回完整 HTML</td>\n</tr>\n<tr>\n<td>SEO 友好度</td>\n<td>差（搜索引擎难抓取动态内容）</td>\n<td>好（直接提供完整内容）</td>\n</tr>\n<tr>\n<td>首屏时间</td>\n<td>较长（需等待 JS 下载执行）</td>\n<td>较短（HTML 直接解析）</td>\n</tr>\n<tr>\n<td>服务器压力</td>\n<td>小</td>\n<td>较大（需处理渲染逻辑）</td>\n</tr>\n<tr>\n<td>交互能力</td>\n<td>强（依赖客户端 JS）</td>\n<td>需结合客户端 JS 增强</td>\n</tr>\n</tbody>\n</table>\n<h3>二、Node.js SSR 的工作原理</h3>\n<ol>\n<li>\n<p><strong>请求处理流程</strong>   ：</p>\n<ul>\n<li>客户端发送 HTTP 请求到 Node.js 服务器</li>\n<li>服务器接收请求，获取所需数据（数据库查询、API 调用等）</li>\n<li>服务器将数据注入预定义的模板，生成完整 HTML</li>\n<li>服务器将完整 HTML 响应发送给客户端</li>\n<li>客户端接收 HTML 并快速展示内容，同时加载客户端 JS 实现交互</li>\n</ul>\n</li>\n<li>\n<p><strong>核心技术点</strong>   ：</p>\n<ul>\n<li><strong>模板引擎</strong>   ：将数据与 HTML 结构结合（如 EJS、Pug、Handlebars）</li>\n<li><strong>前端框架适配</strong>   ：React/Vue 等框架需支持服务端渲染（通过 <code>renderToString</code> 等 API）</li>\n<li><strong>路由匹配</strong>   ：服务器需解析 URL 并渲染对应页面组件</li>\n<li><strong>状态同步</strong>   ：确保服务端渲染的状态与客户端 JS 初始化状态一致（避免 hydration 错误）</li>\n</ul>\n</li>\n</ol>\n<h3>三、从零实现 Node.js SSR（以 Express + React 为例）</h3>\n<h4>1. 基础项目结构</h4>\n<pre><code>ssr-demo/\n├── server.js          # Node.js 服务器\n├── src/\n│   ├── App.js         # React 根组件\n│   ├── index.js       # 客户端入口\n│   └── pages/         # 页面组件\n├── public/            # 静态资源\n└── package.json\n</code></pre>\n<h4>2. 安装核心依赖</h4>\n<pre><code class="language-bash">npm install express react react-dom @babel/core @babel/register babel-preset-react-app\n</code></pre>\n<h4>3. 服务器实现（<code>server.js</code>）</h4>\n<pre><code class="language-javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/register&quot;</span>)({\n  <span class="hljs-attr">presets</span>: [<span class="hljs-string">&quot;react-app&quot;</span>],\n});\n\n<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">React</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;react&quot;</span>);\n<span class="hljs-keyword">const</span> { renderToString } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;react-dom/server&quot;</span>);\n<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);\n<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./src/App&quot;</span>).<span class="hljs-property">default</span>;\n\n<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();\n<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PORT</span> = <span class="hljs-number">3000</span>;\n\n<span class="hljs-comment">// 读取客户端 HTML 模板</span>\n<span class="hljs-keyword">const</span> template = fs.<span class="hljs-title function_">readFileSync</span>(\n  path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;./public/index.html&quot;</span>),\n  <span class="hljs-string">&quot;utf-8&quot;</span>,\n);\n\n<span class="hljs-comment">// 处理静态资源</span>\napp.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;./public&quot;</span>)));\n\n<span class="hljs-comment">// SSR 路由处理</span>\napp.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n  <span class="hljs-comment">// 1. 服务端获取数据（示例：模拟 API 调用）</span>\n  <span class="hljs-keyword">const</span> serverData = {\n    <span class="hljs-attr">path</span>: req.<span class="hljs-property">path</span>,\n    <span class="hljs-attr">posts</span>: [\n      { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Node.js SSR 入门&quot;</span> },\n      { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;React 服务端渲染原理&quot;</span> },\n    ],\n  };\n\n  <span class="hljs-comment">// 2. 渲染 React 组件为字符串</span>\n  <span class="hljs-keyword">const</span> appString = <span class="hljs-title function_">renderToString</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{serverData}</span> /&gt;</span></span>);\n\n  <span class="hljs-comment">// 3. 将渲染结果注入 HTML 模板</span>\n  <span class="hljs-keyword">const</span> html = template\n    .<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;&lt;!-- APP_CONTENT --&gt;&quot;</span>, appString)\n    .<span class="hljs-title function_">replace</span>(\n      <span class="hljs-string">&quot;&lt;!-- INITIAL_DATA --&gt;&quot;</span>,\n      <span class="hljs-string">`window.__INITIAL_DATA__ = <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(serverData)}</span>`</span>,\n    );\n\n  <span class="hljs-comment">// 4. 返回完整 HTML</span>\n  res.<span class="hljs-title function_">send</span>(html);\n});\n\napp.<span class="hljs-title function_">listen</span>(<span class="hljs-variable constant_">PORT</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`SSR 服务器运行在 http://localhost:<span class="hljs-subst">${PORT}</span>`</span>);\n});\n</code></pre>\n<h4>4. 客户端 HTML 模板（<code>public/index.html</code>）</h4>\n<pre><code>\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh-CN&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;Node.js SSR 示例&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;root&quot;&gt;&lt;!-- APP_CONTENT --&gt;&lt;/div&gt;\n  &lt;!-- 注入服务端数据，供客户端 JS 使用 --&gt;\n  &lt;script&gt;&lt;!-- INITIAL_DATA --&gt;&lt;/script&gt;\n  &lt;!-- 客户端交互脚本 --&gt;\n  &lt;script src=&quot;/client-bundle.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n</code></pre>\n<h4>5. 客户端激活（<code>src/index.js</code>）</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n<span class="hljs-keyword">import</span> { hydrateRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/client&quot;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App&quot;</span>;\n\n<span class="hljs-comment">// 使用服务端注入的初始数据激活组件</span>\n<span class="hljs-keyword">const</span> root = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>);\n<span class="hljs-title function_">hydrateRoot</span>(root, <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{window.__INITIAL_DATA__}</span> /&gt;</span></span>);\n</code></pre>\n<h3>四、现代 SSR 框架解析</h3>\n<p>手动实现 SSR 存在配置复杂、性能优化繁琐等问题，因此主流方案是使用成熟框架：</p>\n<ol>\n<li>\n<p><strong>Next.js（React 生态）</strong></p>\n<ul>\n<li>核心特性：\n<ul>\n<li>基于文件系统的路由（<code>pages</code> 目录自动生成路由）</li>\n<li>多种渲染模式：SSR（<code>getServerSideProps</code>）、SSG（<code>getStaticProps</code>）、ISR（增量静态再生）</li>\n<li>自动代码分割和路由预加载</li>\n<li>API 路由集成（<code>pages/api</code> 目录）</li>\n</ul>\n</li>\n<li>适用场景：大型电商、内容网站、需要 SEO 的应用</li>\n</ul>\n</li>\n<li>\n<p><strong>Nuxt.js（Vue 生态）</strong></p>\n<ul>\n<li>核心特性：\n<ul>\n<li>类似 Next.js 的文件路由系统</li>\n<li>服务端渲染与静态生成支持</li>\n<li>内置状态管理（Vuex/Pinia）</li>\n<li>模块系统（轻松集成第三方服务）</li>\n</ul>\n</li>\n<li>适用场景：Vue 技术栈的企业级应用</li>\n</ul>\n</li>\n<li>\n<p><strong>NestJS + 模板引擎</strong></p>\n<ul>\n<li>适用于非 React/Vue 技术栈，通过 EJS/Pug 等模板引擎实现轻量级 SSR</li>\n<li>优势：学习成本低，适合传统网站改造</li>\n</ul>\n</li>\n</ol>\n<h3>五、SSR 性能优化策略</h3>\n<ol>\n<li>\n<p><strong>缓存机制</strong></p>\n<ul>\n<li>页面级缓存：对静态页面或更新不频繁的页面缓存渲染结果</li>\n<li>组件级缓存：使用 <code>React.memo</code> 或 Vue 的 <code>keep-alive</code> 缓存复用组件</li>\n<li>数据缓存：缓存数据库查询结果或 API 响应</li>\n</ul>\n</li>\n<li>\n<p><strong>资源优化</strong></p>\n<ul>\n<li>代码分割：只加载当前页面所需的 JS/CSS</li>\n<li>静态资源 CDN 分发</li>\n<li>压缩 HTML/JS/CSS（使用 <code>compression</code> 中间件）</li>\n</ul>\n</li>\n<li>\n<p><strong>服务器优化</strong></p>\n<ul>\n<li>使用集群模式（<code>cluster</code> 模块）充分利用多核 CPU</li>\n<li>采用 PM2 等进程管理工具实现负载均衡</li>\n<li>考虑边缘计算（如 Vercel、Netlify）减少地域延迟</li>\n</ul>\n</li>\n</ol>\n<h3>六、SSR 的局限性与解决方案</h3>\n<ol>\n<li>\n<p><strong>服务器压力大</strong></p>\n<ul>\n<li>解决方案：结合静态生成（SSG）、CDN 缓存、服务端缓存</li>\n</ul>\n</li>\n<li>\n<p><strong>开发复杂度提高</strong></p>\n<ul>\n<li>解决方案：使用成熟框架（Next.js/Nuxt.js）降低配置成本</li>\n</ul>\n</li>\n<li>\n<p><strong>前后端状态同步问题</strong></p>\n<ul>\n<li>解决方案：通过 <code>window.__INITIAL_DATA__</code> 传递服务端数据，确保客户端激活时状态一致</li>\n</ul>\n</li>\n<li>\n<p><strong>浏览器特定 API 限制</strong></p>\n<ul>\n<li>解决方案：服务端渲染时避免使用 <code>window</code>/<code>document</code> 等浏览器 API，可通过 <code>useEffect</code>（React）或 <code>onMounted</code>（Vue）在客户端执行</li>\n</ul>\n</li>\n</ol>\n<h3>七、总结</h3>\n<p>Node.js SSR 技术通过在服务端生成完整 HTML，解决了传统 CSR 的首屏加载和 SEO 问题，同时结合客户端 JS 保持交互性。对于内容型网站、电商平台等对首屏速度和 SEO 要求高的应用，SSR 是理想选择。</p>\n<p>实际开发中，推荐使用 Next.js 或 Nuxt.js 等现代框架，它们封装了复杂的底层逻辑，提供了灵活的渲染策略和完善的优化工具，能显著提升开发效率和应用性能。</p>\n</div>'</script></body></html>