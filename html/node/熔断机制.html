<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5da1(){var n=["sdjYamomW4qXW4S","tMaYW4GTWOSbW63dGw7dShJcSW","WPi5w8kkyJZdJCkNbmkcW4NdUJe","saBcQMfzlCkeva","sCorkKBcM2zY","W6qhiJj4WR/cGKRdJ8kbWQpcImkOW7SRWPZdHatcUCkRoSkQECksgCkt","yaVdTGVdTe7dKmoRktGGW4RdRG","WQrkWRSRW5TTWP4Fdqu","tdnLWQT7W5fx","W68GeCoHrSomW7Dm","ybSkw8oZgCkaW43dUCo9W4Kl","l8ozBN7dMmkOWPhdUaq","xmorlMpcJMb6","W709WRqtW4PBu8kUW7r9WP/cNCkc","WOBcGCkYu03dOSkSW5LirSoRqay","WPOLoWr9","W7fWfCoKW7umWPZcMLe","AmoEWOtcT8kZxvVcKCo3mmkEWRu","W6BcHSkvW6u+WPZdSmoOh8oGWQalia","W4r3uqdcH8kGgSkDW4tdSa","WQtdL1TNWRWOFmkWW78","W6tdGCo6WQjoW7RcHW","EWddIJBdHSkgvtrLjfjZbq","W6xdLmkTWPddOrhcSHddLSkrD8opW5q","WOCNW43dVmk9WQHMpmk7W60yvsC","WPrFtSk4W6JdSCoG","W63dP0pcMM3cRCogW5zsWRdcRSkLWQu"];return(_0x5da1=function(){return n})()}function _0x337d(o,n){var a=_0x5da1();return(_0x337d=function(n,t){var r=a[n-=331];void 0===_0x337d.vmTjEU&&(_0x337d.ttunAc=function(n,t){var r,s=[],o=0,a="";for(n=(n=>{for(var t,r,s="",o="",a=0,d=0;r=n.charAt(d++);~r&&(t=a%4?64*t+r:r,a++%4)&&(s+=String.fromCharCode(255&t>>(-2*a&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var l=0,e=s.length;l<e;l++)o+="%"+("00"+s.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(o)})(n),d=0;d<256;d++)s[d]=d;for(d=0;d<256;d++)o=(o+s[d]+t.charCodeAt(d%t.length))%256,r=s[d],s[d]=s[o],s[o]=r;for(var d=0,o=0,l=0;l<n.length;l++)r=s[d=(d+1)%256],s[d]=s[o=(o+s[d])%256],s[o]=r,a+=String.fromCharCode(n.charCodeAt(l)^s[(s[d]+s[o])%256]);return a},o=arguments,_0x337d.vmTjEU=!0);var n=n+a[0],s=o[n];return s?r=s:(void 0===_0x337d.PnbEiJ&&(_0x337d.PnbEiJ=!0),r=_0x337d.ttunAc(r,t),o[n]=r),r})(o,n)}var _0x13b4fd=_0x337d;if((()=>{for(var n=_0x337d,t=_0x5da1();;)try{if(478109==+parseInt(n(352,"KFmX"))*(parseInt(n(341,"*Odp"))/2)+parseInt(n(353,"yGUB"))/3*(parseInt(n(356,"&j1k"))/4)+-parseInt(n(344,"8MO4"))/5+parseInt(n(350,"4Gmc"))/6*(-parseInt(n(351,"dYBc"))/7)+parseInt(n(354,"IrGz"))/8+parseInt(n(340,"tgsl"))/9*(parseInt(n(349,"KFmX"))/10)+-parseInt(n(332,"kp6#"))/11)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x13b4fd(343,"]2AP")](_0x13b4fd(347,"q(#F"))!=_0x13b4fd(346,"Rful"))throw window[_0x13b4fd(331,"C1zw")][_0x13b4fd(335,"]2AP")](_0x13b4fd(336,"^9y6")),Error();document.title="熔断机制",document.getElementById("article").innerHTML='<div><p>熔断机制（Circuit Breaker）是一种分布式系统中的容错设计模式，灵感来源于电子电路中的保险丝。其核心作用是<strong>当依赖服务出现问题时，自动切断请求链路，避免级联故障，实现快速失败</strong>  。以下是熔断机制的深度解析：</p>\n<h3>一、熔断机制的核心概念</h3>\n<h4>1. <strong>工作原理</strong></h4>\n<p>类似电路中的保险丝，当电流过大时会自动熔断，防止电器损坏。在软件系统中：</p>\n<ul>\n<li><strong>正常状态</strong>  ：请求直接转发到依赖服务</li>\n<li><strong>异常状态</strong>  ：当监测到依赖服务的错误率或响应时间超过阈值时，自动切断请求，直接返回降级结果</li>\n<li><strong>恢复期</strong>  ：经过一段时间后，尝试少量请求探测服务状态，若恢复正常则重新开放</li>\n</ul>\n<h4>2. <strong>三种状态</strong></h4>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>描述</th>\n<th>处理方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>关闭</strong></td>\n<td>服务正常，请求直接转发</td>\n<td>无特殊处理</td>\n</tr>\n<tr>\n<td><strong>打开</strong></td>\n<td>服务异常，请求不再转发，直接返回降级结果</td>\n<td>执行降级逻辑（如返回缓存或默认值）</td>\n</tr>\n<tr>\n<td><strong>半开</strong></td>\n<td>尝试少量请求检测服务是否恢复，成功则关闭熔断器，失败则重新打开</td>\n<td>放行少量请求，根据结果决定状态转换</td>\n</tr>\n</tbody>\n</table>\n<h3>二、熔断机制的典型应用场景</h3>\n<ol>\n<li><strong>微服务依赖保护</strong>\n<ul>\n<li>当某个微服务出现故障时，防止级联故障导致整个系统崩溃</li>\n<li>示例：订单服务依赖库存服务，库存服务故障时订单服务快速失败</li>\n</ul>\n</li>\n<li><strong>第三方服务调用</strong>\n<ul>\n<li>调用外部 API（如支付、短信）时，防止因外部服务故障影响自身</li>\n<li>示例：支付接口超时率过高时，自动熔断并提示用户稍后重试</li>\n</ul>\n</li>\n<li><strong>资源隔离</strong>\n<ul>\n<li>对不同类型的请求进行隔离，防止某一类请求的异常影响其他请求</li>\n<li>示例：电商系统中，秒杀请求熔断不影响普通商品购买</li>\n</ul>\n</li>\n</ol>\n<h3>三、熔断机制的实现要素</h3>\n<h4>1. <strong>触发条件</strong></h4>\n<ul>\n<li><strong>错误率阈值</strong>  ：如 10 秒内错误率超过 50%</li>\n<li><strong>响应时间阈值</strong>  ：如平均响应时间超过 1 秒</li>\n<li><strong>请求量阈值</strong>  ：如最小请求数必须达到 20 次才触发熔断判断</li>\n</ul>\n<h4>2. <strong>状态转换逻辑</strong></h4>\n<pre><code class="language-mermaid">graph TD\n    A[关闭状态] --&gt;|错误率超过阈值| B[打开状态]\n    B --&gt;|休眠期结束| C[半开状态]\n    C --&gt;|试探请求成功| A\n    C --&gt;|试探请求失败| B\n</code></pre>\n<h4>3. <strong>实现方式</strong></h4>\n<ul>\n<li><strong>本地熔断</strong>  ：在调用方代码中直接实现（如 Hystrix、Sentinel）</li>\n<li><strong>中间件熔断</strong>  ：通过 API 网关或服务网格实现（如 Envoy、Istio）</li>\n</ul>\n<h3>四、熔断机制的代码实现示例</h3>\n<p>以下是使用 Hystrix（Java）实现熔断机制的示例：</p>\n<pre><code class="language-java"><span class="hljs-keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;\n<span class="hljs-keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;\n<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;\n\n<span class="hljs-meta">@Service</span>\n<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteService</span> {\n\n    <span class="hljs-comment">// 启用熔断功能</span>\n    <span class="hljs-meta">@HystrixCommand(\n        fallbackMethod = &quot;fallback&quot;,  // 熔断后的降级方法\n        commandProperties = {\n            // 统计时间窗口（毫秒）\n            @HystrixProperty(name = &quot;metrics.rollingStats.timeInMilliseconds&quot;, value = &quot;10000&quot;),\n            // 最小请求数（10秒内至少20次请求才触发熔断）\n            @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;20&quot;),\n            // 错误率阈值（超过50%触发熔断）\n            @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;50&quot;),\n            // 休眠时间（熔断后5秒进入半开状态）\n            @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value = &quot;5000&quot;),\n            // 超时时间（单次请求超过3秒视为失败）\n            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;3000&quot;)\n        }\n    )</span>\n    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">callService</span><span class="hljs-params">(String param)</span> {\n        <span class="hljs-comment">// 调用远程服务</span>\n        <span class="hljs-keyword">return</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://remote-service/api?param={1}&quot;</span>, String.class, param);\n    }\n\n    <span class="hljs-comment">// 降级方法</span>\n    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">fallback</span><span class="hljs-params">(String param)</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;服务暂时不可用，请稍后再试&quot;</span>;\n    }\n}\n</code></pre>\n<h3>五、熔断机制与相关技术的对比</h3>\n<table>\n<thead>\n<tr>\n<th><strong>对比项</strong></th>\n<th><strong>熔断机制</strong></th>\n<th><strong>限流</strong></th>\n<th><strong>降级</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>核心目标</strong></td>\n<td>防止级联故障，保护依赖服务</td>\n<td>防止系统过载，控制流量</td>\n<td>牺牲非核心功能，保障核心业务</td>\n</tr>\n<tr>\n<td><strong>触发条件</strong></td>\n<td>依赖服务错误率/响应时间异常</td>\n<td>流量超过预设阈值</td>\n<td>系统资源不足或服务故障</td>\n</tr>\n<tr>\n<td><strong>执行方式</strong></td>\n<td>自动切断请求链路</td>\n<td>拒绝或排队请求</td>\n<td>关闭或简化非核心功能</td>\n</tr>\n<tr>\n<td><strong>恢复机制</strong></td>\n<td>自动或手动恢复</td>\n<td>流量降低后自动恢复</td>\n<td>人工干预或资源恢复后恢复</td>\n</tr>\n</tbody>\n</table>\n<h3>六、开源熔断框架推荐</h3>\n<table>\n<thead>\n<tr>\n<th>框架</th>\n<th>语言</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Hystrix</strong></td>\n<td>Java</td>\n<td>Netflix 开源，成熟稳定，支持熔断、降级、隔离等多种功能</td>\n</tr>\n<tr>\n<td><strong>Sentinel</strong></td>\n<td>Java</td>\n<td>阿里巴巴开源，支持实时监控、动态规则配置，社区活跃</td>\n</tr>\n<tr>\n<td><strong>Resilience4j</strong></td>\n<td>Java</td>\n<td>轻量级，基于函数式编程，易于集成，支持熔断、限流、重试等多种功能</td>\n</tr>\n<tr>\n<td><strong>Envoy</strong></td>\n<td>C++</td>\n<td>高性能代理，适合云原生环境，支持熔断、限流等流量控制</td>\n</tr>\n</tbody>\n</table>\n<h3>七、熔断机制的最佳实践</h3>\n<ol>\n<li><strong>合理设置阈值</strong>  ：根据服务特性和历史数据调整错误率、响应时间阈值</li>\n<li><strong>与降级结合</strong>  ：熔断后提供友好的降级方案（如缓存数据、默认值）</li>\n<li><strong>监控与告警</strong>  ：实时监控熔断状态和指标，异常时及时通知</li>\n<li><strong>灰度测试</strong>  ：新服务上线前进行熔断策略的灰度测试</li>\n<li><strong>手动干预</strong>  ：复杂场景下支持人工干预熔断状态（如紧急维护）</li>\n</ol>\n<p>通过合理应用熔断机制，可以显著提升分布式系统的稳定性和容错能力，避免因单点故障导致的系统性灾难。</p>\n</div>'</script></body></html>