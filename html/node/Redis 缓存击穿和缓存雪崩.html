<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2573c3=_0x101a;function _0x101a(r,n){var e=_0x5f31();return(_0x101a=function(n,s){var a=e[n-=382];void 0===_0x101a.SQpMEB&&(_0x101a.yRNLxN=function(n,s){var a,t=[],r=0,e="";for(n=(n=>{for(var s,a,t="",r="",e=0,l=0;a=n.charAt(l++);~a&&(s=e%4?64*s+a:a,e++%4)&&(t+=String.fromCharCode(255&s>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,p=t.length;o<p;o++)r+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(r)})(n),l=0;l<256;l++)t[l]=l;for(l=0;l<256;l++)r=(r+t[l]+s.charCodeAt(l%s.length))%256,a=t[l],t[l]=t[r],t[r]=a;for(var l=0,r=0,o=0;o<n.length;o++)a=t[l=(l+1)%256],t[l]=t[r=(r+t[l])%256],t[r]=a,e+=String.fromCharCode(n.charCodeAt(o)^t[(t[l]+t[r])%256]);return e},r=arguments,_0x101a.SQpMEB=!0);var n=n+e[0],t=r[n];return t?a=t:(void 0===_0x101a.RtnCOb&&(_0x101a.RtnCOb=!0),a=_0x101a.yRNLxN(a,s),r[n]=a),a})(r,n)}function _0x5f31(){var n=["W63cSmo1W7mrtCkRm1y","vmoDW4n2pGrE","kCkkW7DkWOBdJce","m8klWQ/dR8k7FmkvuItdL2XkWOq","WQzQtxhdKJCbW5OC","AernWRmH","BI1MWPf1WPSGumoXW5tcMmkFva","W6xdU8k9g2yXwmo4","W7r2rmkVWObVW4ldMw1zvmo6W6K","egHPlrJcP8kJWQu","WR/cU0NdKCovExtdImkdWQ1SuxC","WPtcOt9VvCoSm8oLWONcSmkjW6xdIG","WOVdQSoUW7/dJCk8mmohcmoCiuC","WPBdLSkofLtdKfq","WPZdTvO/fSkFsG","WR/cTWRcISkZjJhdNW","hSoHkSkNWR9KWQZdUvu","Fw7dGSoKW7CFAqS","vHldJKdcRxFcG2dcOHOG","W7b+q8oLW6KQWQ3dLx8","WPZcPtPOvmoTn8oXWOlcVCkoW77dJq","W4yFsGJcS8o7W7VdTfOrcbnu","jZpcLSk2WRzamWO2h8o/W6HX","W713q8kJWOTUWRhdSN5QvCo9","kGb1WPusW6xcONm","cSocW4PKWRv4nY/dJXpdSmkDx8o4WQ/cTwFdQNtdJSkDE8kAW7SqWQS","W4dcGCojzXFdSfJcKKmVha","yGJcGYNdPKnxFI3cLt8cya","WQn7W4VcLtddPSoplmof"];return(_0x5f31=function(){return n})()}if((()=>{for(var n=_0x101a,s=_0x5f31();;)try{if(765776==-parseInt(n(401,"lkXM"))*(parseInt(n(390,"Knud"))/2)+parseInt(n(405,"M]u8"))/3*(-parseInt(n(403,"]QA("))/4)+-parseInt(n(409,"r[UZ"))/5+parseInt(n(385,"OMd8"))/6*(-parseInt(n(394,"*!tb"))/7)+parseInt(n(407,"lkXM"))/8*(parseInt(n(402,"oBk5"))/9)+parseInt(n(398,"lkXM"))/10+parseInt(n(386,"Bth3"))/11*(parseInt(n(410,"py&]"))/12))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x2573c3(400,"6aIU")](_0x2573c3(391,"yYT6"))!=_0x2573c3(392,"j[2U"))throw window[_0x2573c3(404,"r[UZ")][_0x2573c3(389,"mglD")](_0x2573c3(383,"!xd^")),Error();document.title="Redis 缓存击穿和缓存雪崩",document.getElementById("article").innerHTML='<div><p>在高并发场景下，Redis 缓存的稳定性对系统性能至关重要。缓存击穿和缓存雪崩是两种常见的缓存失效问题，虽然名称相似，但产生原因和解决方案有所不同。</p>\n<h3>一、缓存击穿（Cache Breakdown）</h3>\n<p><strong>定义</strong>  ：<br>\n指某个<strong>热点 key</strong>   在缓存中过期或失效的瞬间，大量并发请求同时访问该 key，这些请求直接穿透缓存访问数据库，导致数据库压力骤增，甚至可能引发数据库崩溃。</p>\n<p><strong>特点</strong>  ：</p>\n<ul>\n<li><strong>针对单个热点 key</strong>  ：通常是某个非常热门的数据（如秒杀商品、热门文章）。</li>\n<li><strong>时效性</strong>  ：发生在 key 过期的瞬间。</li>\n<li><strong>并发量大</strong>  ：大量请求同时访问该 key。</li>\n</ul>\n<p><strong>解决方案</strong>  ：</p>\n<ol>\n<li><strong>永不过期</strong>  ：<br>\n对热点 key 设置为永不过期（或超长过期时间），通过后台任务异步更新缓存。<pre><code class="language-python"><span class="hljs-comment"># 示例：设置热点 key 永不过期，定期异步更新</span>\n<span class="hljs-keyword">def</span> <span class="hljs-title function_">update_hot_key</span>():\n    data = db.query(<span class="hljs-string">&quot;SELECT * FROM hot_data&quot;</span>)\n    redis.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;hot_key&quot;</span>, data)\n    <span class="hljs-comment"># 设置定时任务，每小时更新一次</span>\n    schedule.every(<span class="hljs-number">1</span>).hours.do(update_hot_key)\n</code></pre>\n</li>\n<li><strong>互斥锁（Mutex）</strong>  ：<br>\n当发现缓存失效时，先获取分布式锁，只有拿到锁的请求才能访问数据库并更新缓存，其他请求等待。<pre><code class="language-java"><span class="hljs-comment">// 示例：使用 Redis 分布式锁解决缓存击穿</span>\n<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHotData</span><span class="hljs-params">(String key)</span> {\n    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> redis.get(key);\n    <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) {\n        <span class="hljs-comment">// 获取分布式锁</span>\n        <span class="hljs-keyword">if</span> (redis.setnx(<span class="hljs-string">&quot;lock:&quot;</span> + key, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">30</span>)) { \n            <span class="hljs-keyword">try</span> {\n                value = db.query(key);\n                redis.set(key, value, <span class="hljs-number">3600</span>); <span class="hljs-comment">// 设置缓存</span>\n            } <span class="hljs-keyword">finally</span> {\n                redis.del(<span class="hljs-string">&quot;lock:&quot;</span> + key); <span class="hljs-comment">// 释放锁</span>\n            }\n        } <span class="hljs-keyword">else</span> {\n            Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 等待重试</span>\n            <span class="hljs-keyword">return</span> getHotData(key);\n        }\n    }\n    <span class="hljs-keyword">return</span> value;\n}\n</code></pre>\n</li>\n<li><strong>限流熔断</strong>  ：<br>\n对访问热点 key 的请求进行限流或熔断，避免过多请求压垮数据库。</li>\n</ol>\n<h3>二、缓存雪崩（Cache Avalanche）</h3>\n<p><strong>定义</strong>  ：<br>\n指<strong>大量缓存 key 在同一时间集中过期</strong>  ，或 Redis 服务发生故障，导致大量请求直接访问数据库，引发数据库压力激增甚至崩溃。</p>\n<p><strong>特点</strong>  ：</p>\n<ul>\n<li><strong>范围广</strong>  ：涉及大量缓存 key 同时失效。</li>\n<li><strong>突发性</strong>  ：可能在某个时间点集中发生。</li>\n<li><strong>连锁反应</strong>  ：数据库压力过大可能导致整个系统崩溃。</li>\n</ul>\n<p><strong>解决方案</strong>  ：</p>\n<ol>\n<li><strong>随机过期时间</strong>  ：<br>\n为不同 key 的过期时间添加随机偏移量，避免集中过期。<pre><code class="language-python"><span class="hljs-comment"># 示例：设置随机过期时间（60 分钟 ± 10 分钟）</span>\n<span class="hljs-keyword">import</span> random\n\n<span class="hljs-keyword">def</span> <span class="hljs-title function_">set_cache</span>(<span class="hljs-params">key, value</span>):\n    expire_time = <span class="hljs-number">3600</span> + random.randint(-<span class="hljs-number">600</span>, <span class="hljs-number">600</span>)  <span class="hljs-comment"># 30-50 分钟</span>\n    redis.<span class="hljs-built_in">set</span>(key, value, expire_time)\n</code></pre>\n</li>\n<li><strong>多级缓存</strong>  ：<br>\n使用多级缓存（如本地缓存 + Redis），当 Redis 失效时，先访问本地缓存。<pre><code class="language-java"><span class="hljs-comment">// 示例：Caffeine 本地缓存 + Redis</span>\n<span class="hljs-keyword">private</span> LoadingCache&lt;String, String&gt; localCache = Caffeine.newBuilder()\n    .maximumSize(<span class="hljs-number">1000</span>)\n    .expireAfterWrite(<span class="hljs-number">10</span>, TimeUnit.MINUTES)\n    .build(key -&gt; {\n        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> redis.get(key);\n        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) {\n            value = db.query(key);\n            redis.set(key, value, <span class="hljs-number">3600</span>);\n        }\n        <span class="hljs-keyword">return</span> value;\n    });\n\n<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getData</span><span class="hljs-params">(String key)</span> {\n    <span class="hljs-keyword">return</span> localCache.get(key);\n}\n</code></pre>\n</li>\n<li><strong>Redis 高可用</strong>  ：<br>\n部署 Redis 集群或哨兵模式，避免单点故障导致的缓存雪崩。</li>\n<li><strong>服务降级与熔断</strong>  ：<br>\n当检测到数据库压力过大时，部分请求进行降级处理（如返回默认值），或开启熔断机制暂时拒绝请求。</li>\n</ol>\n<h3>三、缓存击穿 vs 缓存雪崩</h3>\n<table>\n<thead>\n<tr>\n<th><strong>对比项</strong></th>\n<th><strong>缓存击穿</strong></th>\n<th><strong>缓存雪崩</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>失效对象</strong></td>\n<td>单个热点 key</td>\n<td>大量缓存 key 或整个 Redis</td>\n</tr>\n<tr>\n<td><strong>原因</strong></td>\n<td>热点 key 过期或失效</td>\n<td>集中过期或 Redis 故障</td>\n</tr>\n<tr>\n<td><strong>影响范围</strong></td>\n<td>局部（仅该热点 key）</td>\n<td>全局（整个系统）</td>\n</tr>\n<tr>\n<td><strong>解决方案</strong></td>\n<td>互斥锁、永不过期、限流</td>\n<td>随机过期、多级缓存、高可用</td>\n</tr>\n</tbody>\n</table>\n<h3>四、总结</h3>\n<ul>\n<li><strong>缓存击穿</strong>  ：聚焦于<strong>单个热点 key</strong>   的保护，通过锁机制或永不过期避免穿透。</li>\n<li><strong>缓存雪崩</strong>  ：关注<strong>整体缓存系统</strong>  的稳定性，通过分散过期时间、多级缓存和高可用架构来应对。</li>\n</ul>\n<p>实际应用中，需根据业务场景综合使用上述策略，确保 Redis 缓存系统在高并发下的可靠性。</p>\n</div>'</script></body></html>