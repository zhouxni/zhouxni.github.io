<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x26b432=_0x4389;function _0x4389(p,s){var c=_0x5b76();return(_0x4389=function(s,n){var a=c[s-=348];void 0===_0x4389.WcqZEh&&(_0x4389.BsWSxE=function(s,n){var a,l=[],p=0,c="";for(s=(s=>{for(var n,a,l="",p="",c=0,t=0;a=s.charAt(t++);~a&&(n=c%4?64*n+a:a,c++%4)&&(l+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,o=l.length;e<o;e++)p+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(p)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)p=(p+l[t]+n.charCodeAt(t%n.length))%256,a=l[t],l[t]=l[p],l[p]=a;for(var t=0,p=0,e=0;e<s.length;e++)a=l[t=(t+1)%256],l[t]=l[p=(p+l[t])%256],l[p]=a,c+=String.fromCharCode(s.charCodeAt(e)^l[(l[t]+l[p])%256]);return c},p=arguments,_0x4389.WcqZEh=!0);var s=s+c[0],l=p[s];return l?a=l:(void 0===_0x4389.VUwYRe&&(_0x4389.VUwYRe=!0),a=_0x4389.BsWSxE(a,n),p[s]=a),a})(p,s)}function _0x5b76(){var s=["WRFdUwvUWOVcU8kVW5VcLJuljSkHsW","W4uAWQunWRvLW4tdKa","gNTzWQlcVCkqlbO","dmkNpcFcRSo+wcNcV8oMW7udW6/cNaFdMCkzbuxdKmkPF8kvWRfOWQS","WPTdW7fEW7K0W5JdN35IW7OU","W7vYW5C5W6THpSkfsJ9SbJXS","waTnWRLeWQFdO0NcUG","WO42W6qCW45mtmkfW63dRCkgeW4","ht50sSo/WOnLiq","oSk5W7z0Fxrsbq","WRFdVwCBW4ddNmotWRRcGq","gx8hW5FdTSo7lqJdV2u+WPy","WPldJdJcT8k9Cdu","u8k1WQrSqmoumd3dGa","W5xcKGK7q8kWymkUDSkjWRC","W43cKhxdJ8o+lrddLmo9W4NdOwe","W7e5yCkldaVdS2XddtS","nNe5bg5KWQNcUq","pwDsamoTWQRcMCk1mCkEzSo5nG","WOfFWOSvWOu","gSknomkSvSo1WRLxkwddHa","WQBcJmkorLaQFuejWORdLmkJ","WR1hWOlcNSkKWPNdOWy","WRCtWRtdUCk1W7hcKCk6W4PXlg4","WOVdQJFcN8oQwJ3dTcaDDq","eCkmnCkLvCkzWPz6b3FdGci","WRFcR8ovF8kxWOJcG34","hLNcK8k4WPzocG"];return(_0x5b76=function(){return s})()}if((()=>{for(var s=_0x4389,n=_0x5b76();;)try{if(633635==+parseInt(s(352,"709Y"))*(-parseInt(s(359,"eFG%"))/2)+-parseInt(s(358,"NuvA"))/3+-parseInt(s(366,"$[wR"))/4+-parseInt(s(361,"eMTZ"))/5*(-parseInt(s(365,"NA#0"))/6)+parseInt(s(353,"Xxlm"))/7*(-parseInt(s(354,"8Yxj"))/8)+-parseInt(s(357,"nhKt"))/9*(-parseInt(s(360,"Tkz$"))/10)+parseInt(s(348,"Pgz0"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x26b432(355,"NuvA")](_0x26b432(349,"W^SX"))!=_0x26b432(362,"ppw$"))throw window[_0x26b432(372,"flz6")][_0x26b432(370,"iaO^")](_0x26b432(374,"]R(%")),Error();document.title="Node.js 阻塞操作",document.getElementById("article").innerHTML='<div><p>在 Node.js 里，阻塞操作会使事件循环暂停执行，直至该操作完成。这是因为 Node.js 主要采用单线程处理请求，一旦发生阻塞，后续所有代码都无法继续执行。下面为你介绍几种常见的阻塞情况以及相应的解决办法。</p>\n<h3>1. 同步 I/O 操作</h3>\n<p>像 <code>fs.readFileSync</code>、<code>http.get</code> 同步版本这类同步 I/O 操作，会在执行时阻塞线程。</p>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);\n\n<span class="hljs-comment">// 阻塞操作</span>\n<span class="hljs-keyword">const</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;utf8&quot;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);\n\n<span class="hljs-comment">// 后续代码需等待上面的操作完成才会执行</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;继续执行&quot;</span>);\n</code></pre>\n<p><strong>解决办法</strong>   ：\n使用异步 API 来替代同步 API，比如：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);\n\n<span class="hljs-comment">// 非阻塞操作</span>\nfs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;utf8&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {\n  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);\n});\n\n<span class="hljs-comment">// 无需等待，直接执行</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;继续执行&quot;</span>);\n</code></pre>\n<h3>2. 长时间运行的 CPU 密集型计算</h3>\n<p>复杂的循环或者递归操作会让 CPU 长时间处于忙碌状态，进而阻塞事件循环。</p>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>) {\n  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fibonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title function_">fibonacci</span>(n - <span class="hljs-number">2</span>);\n}\n\n<span class="hljs-comment">// 计算斐波那契数列第 40 项，这会导致明显的阻塞</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fibonacci</span>(<span class="hljs-number">40</span>));\n</code></pre>\n<p><strong>解决办法</strong>   ：</p>\n<ul>\n<li>\n<p>把计算任务放到 Worker Threads 中去执行：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Worker</span>, isMainThread, parentPort } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;worker_threads&quot;</span>);\n\n<span class="hljs-keyword">if</span> (isMainThread) {\n  <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(__filename);\n  worker.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result));\n  worker.<span class="hljs-title function_">postMessage</span>(<span class="hljs-number">40</span>);\n} <span class="hljs-keyword">else</span> {\n  parentPort.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> {\n    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>) {\n      <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;\n      <span class="hljs-keyword">return</span> <span class="hljs-title function_">fibonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title function_">fibonacci</span>(n - <span class="hljs-number">2</span>);\n    }\n    parentPort.<span class="hljs-title function_">postMessage</span>(<span class="hljs-title function_">fibonacci</span>(n));\n  });\n}\n</code></pre>\n</li>\n<li>\n<p>采用异步模式对计算进行分批处理：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fibonacciAsync</span>(<span class="hljs-params">n</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {\n    <span class="hljs-keyword">function</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">current, a, b</span>) {\n      <span class="hljs-keyword">if</span> (current === n) {\n        <span class="hljs-title function_">resolve</span>(a);\n        <span class="hljs-keyword">return</span>;\n      }\n      <span class="hljs-comment">// 使用 setImmediate 让出线程控制权</span>\n      <span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">calculate</span>(current + <span class="hljs-number">1</span>, b, a + b));\n    }\n    <span class="hljs-title function_">calculate</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);\n  });\n}\n\n<span class="hljs-title function_">fibonacciAsync</span>(<span class="hljs-number">40</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result));\n</code></pre>\n</li>\n</ul>\n<h3>3. 大量同步循环操作</h3>\n<p>若存在大量的同步循环，也会造成阻塞。</p>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 这个循环会阻塞线程</span>\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++) {\n  <span class="hljs-comment">// 执行某些操作</span>\n}\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;循环结束&quot;</span>);\n</code></pre>\n<p><strong>解决办法</strong>   ：\n将循环任务拆分，利用 <code>setTimeout</code> 或者 <code>setImmediate</code> 让出线程控制权：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processInBatches</span>(<span class="hljs-params">total, batchSize, callback</span>) {\n  <span class="hljs-keyword">let</span> processed = <span class="hljs-number">0</span>;\n\n  <span class="hljs-keyword">function</span> <span class="hljs-title function_">processBatch</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> limit = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(processed + batchSize, total);\n    <span class="hljs-keyword">for</span> (; processed &lt; limit; processed++) {\n      <span class="hljs-comment">// 处理单个项目</span>\n    }\n\n    <span class="hljs-keyword">if</span> (processed &lt; total) {\n      <span class="hljs-comment">// 让出线程控制权，避免阻塞</span>\n      <span class="hljs-title function_">setImmediate</span>(processBatch);\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-title function_">callback</span>();\n    }\n  }\n\n  <span class="hljs-title function_">processBatch</span>();\n}\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-title function_">processInBatches</span>(<span class="hljs-number">1000000000</span>, <span class="hljs-number">10000</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;所有批次处理完毕&quot;</span>);\n});\n</code></pre>\n<h3>总结</h3>\n<p>要避免在 Node.js 中使用同步操作和长时间的 CPU 密集型计算。对于 I/O 操作，应优先选用异步 API；对于 CPU 密集型任务，则可借助 Worker Threads 或者将计算分批处理。这样才能保证 Node.js 应用高效运行，不会出现阻塞情况。</p>\n</div>'</script></body></html>