<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x472753=_0x5a4d;function _0x4d3a(){var s=["xdBdN8k8qrBcVSoU","r8oCW6zsC8kABY0","W5GDwtRdP8kOhLG","WPjGWQKVBSkNW4FdLmkkW78LkG","sLH4W4ZdQetcLq","WPPExqBdTa","xSoMerrJaSk3WOD/W5RdPvG","WPpcNmksWOaPlmoyWQtcSJjWW45t","l8kDWPKRn8oCWOG","wtBcO8ohhfFcSSoNWQJdLcZcGa","WPbKWQWRl8o8W4ddK8k6W6K","WR9xW4GJW5HqW6VcKa/dUCkvnG","WQ9+fb4GWRvlwW","WR/cKhGCW4q+W6PxW7m","W6ddUSk4BGdcMxRdTgZcSW","WPitW6hcHSoYF8k9WQpcVSk1W6Ss","b1C3W71xW4D4WQy","W7dcN8kCWQaUueGIw8oVW7SC","E8oAW7aAh8o5WQqa","rgLOW65kWOVcPqBdMvW","B8k8W4W+W6XvWOTjW64","WPNcLbhcQmo0Fxf6W5NdNuG4aW","W6X0WOTCg8oBza","rKBdVKCxCImlWR7dNSkolx7dLtbxWOfXW5SNW5dcLmk1ASobma","twnOW60oW6/cMGldGxtdIGq","umoKeX9JdCosWPLrW7hdKNz0","r2CSWPbuWQhcMG8","vmoGfHfLbSoxWQrnW4VdPMT+","wG5SW5vQW6bCWQ5Y","fWRcUGzvEentWR7dSmkxlG","WQH5WPDKnmo+Aa"];return(_0x4d3a=function(){return s})()}function _0x5a4d(t,s){var e=_0x4d3a();return(_0x5a4d=function(s,a){var n=e[s-=210];void 0===_0x5a4d.ZJMthz&&(_0x5a4d.YHvryj=function(s,a){var n,l=[],t=0,e="";for(s=(s=>{for(var a,n,l="",t="",e=0,p=0;n=s.charAt(p++);~n&&(a=e%4?64*a+n:n,e++%4)&&(l+=String.fromCharCode(255&a>>(-2*e&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,o=l.length;c<o;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)t=(t+l[p]+a.charCodeAt(p%a.length))%256,n=l[p],l[p]=l[t],l[t]=n;for(var p=0,t=0,c=0;c<s.length;c++)n=l[p=(p+1)%256],l[p]=l[t=(t+l[p])%256],l[t]=n,e+=String.fromCharCode(s.charCodeAt(c)^l[(l[p]+l[t])%256]);return e},t=arguments,_0x5a4d.ZJMthz=!0);var s=s+e[0],l=t[s];return l?n=l:(void 0===_0x5a4d.DvvKkg&&(_0x5a4d.DvvKkg=!0),n=_0x5a4d.YHvryj(n,a),t[s]=n),n})(t,s)}if((()=>{for(var s=_0x5a4d,a=_0x4d3a();;)try{if(738937==+parseInt(s(222,"2dn)"))*(parseInt(s(217,"seqc"))/2)+-parseInt(s(227,"2dn)"))/3+parseInt(s(220,"3y$F"))/4*(parseInt(s(234,"tAzg"))/5)+-parseInt(s(233,"A[kZ"))/6*(parseInt(s(230,"kn0*"))/7)+parseInt(s(216,"42Y@"))/8*(parseInt(s(212,"tAzg"))/9)+-parseInt(s(218,"WmOf"))/10*(-parseInt(s(215,"E^Ja"))/11)+parseInt(s(228,"kn0*"))/12*(-parseInt(s(229,"2dn)"))/13))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x472753(238,"Q1Qp")](_0x472753(223,"^1OY"))!=_0x472753(239,"FOSo"))throw window[_0x472753(219,"H@XY")][_0x472753(225,"A[kZ")](_0x472753(226,"c%$4")),Error();document.title="TypeORM 增删改查",document.getElementById("article").innerHTML='<div><p>TypeORM 提供了多种方式进行增删改查（CRUD）操作，包括 Repository 模式、Query Builder 和原生 SQL。以下是各类操作的详细说明和示例（基于上文中的 <code>User</code> 实体类）：</p>\n<h3>一、新增数据（Create）</h3>\n<p>通过 <code>repository.save()</code> 或 <code>repository.insert()</code> 方法添加新记录。</p>\n<h4>1. 基本新增</h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { getRepository } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;typeorm&quot;</span>;\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">User</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./entity/User&quot;</span>;\n\n<span class="hljs-comment">// 获取 User 仓库</span>\n<span class="hljs-keyword">const</span> userRepository = <span class="hljs-title function_">getRepository</span>(<span class="hljs-title class_">User</span>);\n\n<span class="hljs-comment">// 创建新用户实例</span>\n<span class="hljs-keyword">const</span> newUser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();\nnewUser.<span class="hljs-property">username</span> = <span class="hljs-string">&quot;johndoe&quot;</span>;\nnewUser.<span class="hljs-property">email</span> = <span class="hljs-string">&quot;john@example.com&quot;</span>;\nnewUser.<span class="hljs-property">passwordHash</span> = <span class="hljs-string">&quot;hashed_password&quot;</span>;\nnewUser.<span class="hljs-property">role</span> = <span class="hljs-string">&quot;user&quot;</span>;\n\n<span class="hljs-comment">// 保存到数据库</span>\n<span class="hljs-keyword">const</span> savedUser = <span class="hljs-keyword">await</span> userRepositoryRepository;\n</code></pre>\n<h4>2. 批量新增</h4>\n<pre><code class="language-typescript"><span class="hljs-comment">// 批量创建用户</span>\n<span class="hljs-keyword">const</span> users = [\n  { <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;alice&quot;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&quot;alice@example.com&quot;</span>, <span class="hljs-attr">passwordHash</span>: <span class="hljs-string">&quot;hash1&quot;</span> },\n  { <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;bob&quot;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&quot;bob@example.com&quot;</span>, <span class="hljs-attr">passwordHash</span>: <span class="hljs-string">&quot;hash2&quot;</span> },\n];\n\n<span class="hljs-comment">// 批量保存</span>\n<span class="hljs-keyword">const</span> savedUsers = <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">save</span>(users);\n</code></pre>\n<h4>3. 区别：<code>save()</code> vs <code>insert()</code></h4>\n<ul>\n<li><code>save()</code>：会自动判断是新增（无 ID）还是更新（有 ID），返回完整实体。</li>\n<li><code>insert()</code>：仅用于新增，返回包含插入 ID 的对象（性能略高）。</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">insert</span>({\n  <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;charlie&quot;</span>,\n  <span class="hljs-attr">email</span>: <span class="hljs-string">&quot;charlie@example.com&quot;</span>,\n  <span class="hljs-attr">passwordHash</span>: <span class="hljs-string">&quot;hash3&quot;</span>,\n});\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;插入的 ID：&quot;</span>, result.<span class="hljs-property">identifiers</span>[<span class="hljs-number">0</span>].<span class="hljs-property">id</span>);\n</code></pre>\n<h3>二、查询数据（Read）</h3>\n<p>TypeORM 提供多种查询方式，满足不同场景需求。</p>\n<h4>1. 按 ID 查询（单条）</h4>\n<pre><code class="language-typescript"><span class="hljs-comment">// 通过主键查询</span>\n<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">findOne</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 查询 ID=1 的用户</span>\n</code></pre>\n<h4>2. 条件查询（单条）</h4>\n<pre><code class="language-typescript"><span class="hljs-comment">// 按条件查询第一条匹配记录</span>\n<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">findOne</span>({\n  <span class="hljs-attr">where</span>: { <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;johndoe&quot;</span> },\n});\n</code></pre>\n<h4>3. 条件查询（多条）</h4>\n<pre><code class="language-typescript"><span class="hljs-comment">// 查询所有活跃用户</span>\n<span class="hljs-keyword">const</span> activeUsers = <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">find</span>({\n  <span class="hljs-attr">where</span>: { <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;active&quot;</span> },\n  <span class="hljs-attr">order</span>: { <span class="hljs-attr">createdAt</span>: <span class="hljs-string">&quot;DESC&quot;</span> }, <span class="hljs-comment">// 按创建时间倒序</span>\n  <span class="hljs-attr">skip</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// 分页：跳过前 10 条</span>\n  <span class="hljs-attr">take</span>: <span class="hljs-number">20</span>, <span class="hljs-comment">// 分页：取 20 条</span>\n});\n</code></pre>\n<h4>4. 复杂条件查询（AND/OR）</h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">find</span>({\n  <span class="hljs-attr">where</span>: [\n    <span class="hljs-comment">// OR 条件：(role = &#x27;admin&#x27; AND status = &#x27;active&#x27;) OR (age &gt; 18)</span>\n    { <span class="hljs-attr">role</span>: <span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;active&quot;</span> },\n    { <span class="hljs-attr">age</span>: <span class="hljs-title class_">MoreThan</span>(<span class="hljs-number">18</span>) },\n  ],\n});\n</code></pre>\n<h4>5. 自定义字段（投影）</h4>\n<pre><code class="language-typescript"><span class="hljs-comment">// 只查询 username 和 email 字段</span>\n<span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">find</span>({\n  <span class="hljs-attr">select</span>: [<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;email&quot;</span>],\n  <span class="hljs-attr">where</span>: { <span class="hljs-attr">role</span>: <span class="hljs-string">&quot;user&quot;</span> },\n});\n</code></pre>\n<h4>6. 关联查询（若有外键）</h4>\n<pre><code class="language-typescript"><span class="hljs-comment">// 假设有一个 Profile 实体关联到 User</span>\n<span class="hljs-keyword">const</span> userWithProfile = <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">findOne</span>({\n  <span class="hljs-attr">where</span>: { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> },\n  <span class="hljs-attr">relations</span>: [<span class="hljs-string">&quot;profile&quot;</span>], <span class="hljs-comment">// 关联查询 profile</span>\n});\n</code></pre>\n<h4>7. Query Builder（复杂查询）</h4>\n<p>更灵活的链式查询方式：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> userRepository\n  .<span class="hljs-title function_">createQueryBuilder</span>(<span class="hljs-string">&quot;user&quot;</span>) <span class="hljs-comment">// 别名</span>\n  .<span class="hljs-title function_">select</span>([<span class="hljs-string">&quot;user.username&quot;</span>, <span class="hljs-string">&quot;user.email&quot;</span>])\n  .<span class="hljs-title function_">where</span>(<span class="hljs-string">&quot;user.age &gt; :age&quot;</span>, { <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> })\n  .<span class="hljs-title function_">andWhere</span>(<span class="hljs-string">&quot;user.status = :status&quot;</span>, { <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;active&quot;</span> })\n  .<span class="hljs-title function_">orderBy</span>(<span class="hljs-string">&quot;user.createdAt&quot;</span>, <span class="hljs-string">&quot;DESC&quot;</span>)\n  .<span class="hljs-title function_">skip</span>(<span class="hljs-number">10</span>)\n  .<span class="hljs-title function_">take</span>(<span class="hljs-number">20</span>)\n  .<span class="hljs-title function_">getMany</span>(); <span class="hljs-comment">// 获取多条</span>\n</code></pre>\n<h3>三、更新数据（Update）</h3>\n<h4>1. 基于实体更新</h4>\n<pre><code class="language-typescript"><span class="hljs-comment">// 先查询，再修改，最后保存</span>\n<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">findOne</span>(<span class="hljs-number">1</span>);\n<span class="hljs-keyword">if</span> (user) {\n  user.<span class="hljs-property">email</span> = <span class="hljs-string">&quot;new-john@example.com&quot;</span>;\n  user.<span class="hljs-property">updatedAt</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();\n  <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">save</span>(user);\n}\n</code></pre>\n<h4>2. 直接更新（无需先查询）</h4>\n<pre><code class="language-typescript"><span class="hljs-comment">// 按条件更新，返回受影响的行数</span>\n<span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">update</span>(\n  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> }, <span class="hljs-comment">// 条件</span>\n  { <span class="hljs-attr">email</span>: <span class="hljs-string">&quot;updated@example.com&quot;</span>, <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;active&quot;</span> }, <span class="hljs-comment">// 要更新的字段</span>\n);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;受影响的行数：&quot;</span>, result.<span class="hljs-property">affected</span>);\n</code></pre>\n<h4>3. Query Builder 更新</h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">await</span> userRepository\n  .<span class="hljs-title function_">createQueryBuilder</span>()\n  .<span class="hljs-title function_">update</span>(<span class="hljs-title class_">User</span>)\n  .<span class="hljs-title function_">set</span>({ <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;suspended&quot;</span> })\n  .<span class="hljs-title function_">where</span>(<span class="hljs-string">&quot;last_login_at &lt; :date&quot;</span>, { <span class="hljs-attr">date</span>: <span class="hljs-string">&quot;2023-01-01&quot;</span> })\n  .<span class="hljs-title function_">execute</span>();\n</code></pre>\n<h3>四、删除数据（Delete）</h3>\n<h4>1. 按 ID 删除</h4>\n<pre><code class="language-typescript"><span class="hljs-comment">// 删除 ID=1 的用户</span>\n<span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">delete</span>(<span class="hljs-number">1</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;删除的行数：&quot;</span>, result.<span class="hljs-property">affected</span>);\n</code></pre>\n<h4>2. 按条件删除</h4>\n<pre><code class="language-typescript"><span class="hljs-comment">// 删除状态为 deleted 的用户</span>\n<span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">delete</span>({ <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;deleted&quot;</span> });\n</code></pre>\n<h4>3. 软删除（推荐）</h4>\n<p>如果实体启用了软删除（<code>@DeleteDateColumn</code>），删除操作会保留记录，仅更新删除时间：</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// 实体中需添加：@DeleteDateColumn() deletedAt: Date;</span>\n<span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">softDelete</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 软删除</span>\n<span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">restore</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 恢复软删除的记录</span>\n</code></pre>\n<h4>4. Query Builder 删除</h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">await</span> userRepository\n  .<span class="hljs-title function_">createQueryBuilder</span>()\n  .<span class="hljs-title function_">delete</span>()\n  .<span class="hljs-title function_">from</span>(<span class="hljs-title class_">User</span>)\n  .<span class="hljs-title function_">where</span>(<span class="hljs-string">&quot;age &lt; :age&quot;</span>, { <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> })\n  .<span class="hljs-title function_">execute</span>();\n</code></pre>\n<h3>五、常用查询操作符</h3>\n<p>TypeORM 提供了多种操作符简化条件查询（需从 <code>typeorm</code> 导入）：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">MoreThan</span>, <span class="hljs-title class_">LessThan</span>, <span class="hljs-title class_">Like</span>, <span class="hljs-title class_">In</span>, <span class="hljs-title class_">Between</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;typeorm&quot;</span>;\n\n<span class="hljs-comment">// 示例</span>\n<span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">find</span>({\n  <span class="hljs-attr">where</span>: {\n    <span class="hljs-attr">age</span>: <span class="hljs-title class_">MoreThan</span>(<span class="hljs-number">18</span>), <span class="hljs-comment">// 年龄 &gt; 18</span>\n    <span class="hljs-attr">createdAt</span>: <span class="hljs-title class_">Between</span>(<span class="hljs-string">&quot;2023-01-01&quot;</span>, <span class="hljs-string">&quot;2023-12-31&quot;</span>), <span class="hljs-comment">// 创建时间在 2023 年内</span>\n    <span class="hljs-attr">username</span>: <span class="hljs-title class_">Like</span>(<span class="hljs-string">&quot;%john%&quot;</span>), <span class="hljs-comment">// 用户名包含 john</span>\n    <span class="hljs-attr">role</span>: <span class="hljs-title class_">In</span>([<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;moderator&quot;</span>]), <span class="hljs-comment">// 角色是 admin 或 moderator</span>\n  },\n});\n</code></pre>\n<h3>六、原生 SQL</h3>\n<p>对于极复杂的查询，可使用原生 SQL：</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// 原生查询（返回数组）</span>\n<span class="hljs-keyword">const</span> rawData = <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">query</span>(\n  <span class="hljs-string">&quot;SELECT username, email FROM users WHERE status = ?&quot;</span>,\n  [<span class="hljs-string">&quot;active&quot;</span>],\n);\n\n<span class="hljs-comment">// 原生查询（映射到实体）</span>\n<span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> userRepository\n  .<span class="hljs-title function_">createQueryBuilder</span>()\n  .<span class="hljs-title function_">select</span>(<span class="hljs-string">&quot;*&quot;</span>)\n  .<span class="hljs-title function_">from</span>(<span class="hljs-title class_">User</span>, <span class="hljs-string">&quot;user&quot;</span>)\n  .<span class="hljs-title function_">where</span>(<span class="hljs-string">&quot;user.role = &#x27;admin&#x27;&quot;</span>)\n  .<span class="hljs-title function_">getRawMany</span>();\n</code></pre>\n<h3>总结</h3>\n<ul>\n<li><strong>简单操作</strong>   ：优先使用 <code>Repository</code> 的 <code>find</code>/<code>save</code>/<code>update</code>/<code>delete</code> 方法。</li>\n<li><strong>复杂查询</strong>   ：使用 <code>QueryBuilder</code> 链式构建，可读性和灵活性更好。</li>\n<li><strong>性能敏感场景</strong>   ：适当使用 <code>insert</code>/<code>update</code>（直接操作，不返回完整实体）。</li>\n<li><strong>数据安全</strong>   ：删除操作优先考虑软删除，便于数据恢复和审计。</li>\n</ul>\n<p>根据业务复杂度选择合适的方式，既能保证代码简洁，又能满足性能需求。</p>\n</div>'</script></body></html>