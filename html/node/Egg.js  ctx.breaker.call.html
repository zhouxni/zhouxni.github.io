<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x95d2d2=_0x899b;function _0x5764(){var s=["WRG+BahdSSkUWQZcJq","tmkOzJXzWRW/","W7ddHCk4D8kgnSk6DSoJWPbPrW","p8kDWQBcQmkAsmogWRy4aSoikCkUimoeW67cQ8kJrM7cKSoJwCoWfmkT","W41oW5T5W7/dQra","W6zLpvNcTCoXWRhcHmk3wSoMWQq","W6maiSoAiduMWQNdMW","W7vKWOXlDXtdTXWj","yxJdKCo1iCovxW","W5DWWRK3FG4AW5aMWQxcP0e","WOTqWPpcS8kf","W4JdTConE8kXW5CPeCkE","WQVdLXekW54TeCkACX3dOmkh","WOldHmkkleldRCkMASo2dJ5jWPG","W4KqW5ddT8ooWQpcSSoJW45SlG","WRzNoKqEpCo8WPRdRgGC","mKNcRuxcGCkuW4tcVeiUWR/cKLS","W6GWcx13omoUWP4aWOldJmkEWR8","W6ecimkYEbOmWQJdPSovdW","W4FcTK3cJHHlDSozESkQiYu","W64zsCkepGhdKW","n0NcRu3cHSoqWPpcVNeuWO0","zSo3jmoLWQ7dKmkAWRpcMCkFEMRdIq","WQvid8oDBfddNHDGWPBcMKS","zmoyWRbpW7i/ta4"];return(_0x5764=function(){return s})()}function _0x899b(t,s){var r=_0x5764();return(_0x899b=function(s,n){var a=r[s-=295];void 0===_0x899b.FqbZgJ&&(_0x899b.mInIqm=function(s,n){var a,l=[],t=0,r="";for(s=(s=>{for(var n,a,l="",t="",r=0,p=0;a=s.charAt(p++);~a&&(n=r%4?64*n+a:a,r++%4)&&(l+=String.fromCharCode(255&n>>(-2*r&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,e=l.length;c<e;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)t=(t+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[t],l[t]=a;for(var p=0,t=0,c=0;c<s.length;c++)a=l[p=(p+1)%256],l[p]=l[t=(t+l[p])%256],l[t]=a,r+=String.fromCharCode(s.charCodeAt(c)^l[(l[p]+l[t])%256]);return r},t=arguments,_0x899b.FqbZgJ=!0);var s=s+r[0],l=t[s];return l?a=l:(void 0===_0x899b.seDAem&&(_0x899b.seDAem=!0),a=_0x899b.mInIqm(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x899b,n=_0x5764();;)try{if(355636==+parseInt(s(299,"ZQKX"))+-parseInt(s(318,"xizR"))/2+-parseInt(s(306,"Vk2K"))/3+-parseInt(s(296,"X2O%"))/4+parseInt(s(301,"dK)S"))/5*(parseInt(s(310,"XA2p"))/6)+-parseInt(s(302,"D2VR"))/7*(-parseInt(s(315,"D2VR"))/8)+parseInt(s(303,"^i#a"))/9*(parseInt(s(308,"$tmW"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x95d2d2(317,"UuI)")](_0x95d2d2(316,"#Gm&"))!=_0x95d2d2(319,"#9nT"))throw window[_0x95d2d2(309,"$]3k")][_0x95d2d2(304,"[SOI")](_0x95d2d2(312,"G4Vi")),Error();document.title="Egg.js  ctx.breaker.call",document.getElementById("article").innerHTML='<div><p>在 Egg.js 中，<code>ctx.breaker.call</code> 是 <code>egg-circuit-breaker</code> 插件提供的一个核心方法，用于<strong>调用受熔断器保护的异步操作</strong>  。它的作用是：当目标服务出现故障（如超时、连续失败）时，自动触发熔断机制，避免系统雪崩，并支持降级处理。</p>\n<hr>\n<h3><strong>1. 方法定义</strong></h3>\n<pre><code class="language-typescript">ctx.<span class="hljs-property">breaker</span>.<span class="hljs-title function_">call</span>(\n  <span class="hljs-attr">clientName</span>: <span class="hljs-built_in">string</span>,       <span class="hljs-comment">// 对应配置中的 clients 名称（如 &#x27;userService&#x27;）</span>\n  <span class="hljs-attr">fn</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;,   <span class="hljs-comment">// 要保护的异步函数</span>\n  <span class="hljs-attr">options</span>?: <span class="hljs-built_in">object</span>          <span class="hljs-comment">// 可选，覆盖本次调用的配置</span>\n): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;\n</code></pre>\n<hr>\n<h3><strong>2. 基础用法</strong></h3>\n<h4><strong>场景</strong>  ：调用一个可能失败的用户服务 API</h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/service/user.js</span>\n<span class="hljs-keyword">async</span> <span class="hljs-title function_">getUser</span>(<span class="hljs-params">id</span>) {\n  <span class="hljs-keyword">const</span> { ctx } = <span class="hljs-variable language_">this</span>;\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-comment">// 使用 userService 的熔断配置</span>\n    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">breaker</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;userService&#x27;</span>, <span class="hljs-title function_">async</span> () =&gt; {\n      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> ctx.<span class="hljs-title function_">curl</span>(<span class="hljs-string">`https://api.example.com/users/<span class="hljs-subst">${id}</span>`</span>, {\n        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,\n        <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,\n      });\n    });\n    <span class="hljs-keyword">return</span> user.<span class="hljs-property">data</span>;\n  } <span class="hljs-keyword">catch</span> (err) {\n    ctx.<span class="hljs-property">logger</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;[用户服务熔断]&#x27;</span>, err);\n    <span class="hljs-comment">// 如果配置了 fallback，err 可能是熔断触发的错误</span>\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;获取用户信息失败&#x27;</span>);\n  }\n}\n</code></pre>\n<hr>\n<h3><strong>3. 参数详解</strong></h3>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>必填</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>clientName</strong></td>\n<td><code>string</code></td>\n<td>是</td>\n<td>对应 <code>config.circuitBreaker.clients</code> 中的配置名称（如 <code>userService</code>）。</td>\n</tr>\n<tr>\n<td><strong>fn</strong></td>\n<td><code>() =&gt; Promise&lt;T&gt;</code></td>\n<td>是</td>\n<td>要保护的异步函数，通常包含网络请求或数据库操作。</td>\n</tr>\n<tr>\n<td><strong>options</strong></td>\n<td><code>object</code></td>\n<td>否</td>\n<td>本次调用覆盖的配置（如临时调整 <code>timeout</code>）。</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>4. 动态覆盖配置</strong></h3>\n<p>在调用时临时修改熔断参数：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">await</span> ctx.<span class="hljs-property">breaker</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;paymentService&#x27;</span>, <span class="hljs-title function_">async</span> () =&gt; {\n  <span class="hljs-comment">// 支付接口逻辑</span>\n}, {\n  <span class="hljs-attr">timeout</span>: <span class="hljs-number">15000</span>, <span class="hljs-comment">// 本次调用超时改为 15 秒</span>\n  <span class="hljs-attr">maxFailures</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 本次调用失败 1 次即熔断</span>\n});\n</code></pre>\n<hr>\n<h3><strong>5. 结合降级逻辑（Fallback）</strong></h3>\n<p>在配置中预设 <code>fallback</code>，当熔断触发时自动执行：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// config/config.default.js</span>\n<span class="hljs-built_in">exports</span>.<span class="hljs-property">circuitBreaker</span> = {\n  <span class="hljs-attr">clients</span>: {\n    <span class="hljs-attr">userService</span>: {\n      <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>,\n      <span class="hljs-attr">fallback</span>: <span class="hljs-function">(<span class="hljs-params">ctx</span>) =&gt;</span> ({ <span class="hljs-comment">// 返回兜底数据</span>\n        <span class="hljs-attr">id</span>: <span class="hljs-number">0</span>,\n        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;默认用户&#x27;</span>,\n        <span class="hljs-attr">fromCache</span>: <span class="hljs-literal">true</span>,\n      }),\n    },\n  },\n};\n\n<span class="hljs-comment">// 调用时若触发熔断，会自动返回 fallback 数据</span>\n<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">breaker</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;userService&#x27;</span>, fetchUser);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user); <span class="hljs-comment">// { id: 0, name: &#x27;默认用户&#x27;, fromCache: true }</span>\n</code></pre>\n<hr>\n<h3><strong>6. 错误处理</strong></h3>\n<p>熔断器可能抛出两种错误：</p>\n<ol>\n<li><strong>业务错误</strong>  ：<code>fn</code> 执行中抛出的原始错误（如 HTTP 500）。</li>\n<li><strong>熔断错误</strong>  ：当熔断触发时抛出 <code>CircuitBreakerOpenError</code>。</li>\n</ol>\n<p><strong>区分处理示例</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">try</span> {\n  <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">breaker</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;service&#x27;</span>, riskyOperation);\n} <span class="hljs-keyword">catch</span> (err) {\n  <span class="hljs-keyword">if</span> (err.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;CircuitBreakerOpenError&#x27;</span>) {\n    ctx.<span class="hljs-property">logger</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;服务已熔断，使用降级逻辑&#x27;</span>);\n    <span class="hljs-keyword">return</span> fallbackData;\n  } <span class="hljs-keyword">else</span> {\n    ctx.<span class="hljs-property">logger</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;服务业务错误&#x27;</span>, err);\n    <span class="hljs-keyword">throw</span> err;\n  }\n}\n</code></pre>\n<hr>\n<h3><strong>7. 性能监控建议</strong></h3>\n<p>通过监听事件统计熔断情况：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// app.js</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">AppBootHook</span> {\n  <span class="hljs-keyword">async</span> <span class="hljs-title function_">didLoad</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> { circuitBreaker } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">app</span>;\n    circuitBreaker.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">app</span>.<span class="hljs-property">metrics</span>.<span class="hljs-title function_">increment</span>(<span class="hljs-string">&#x27;circuit_breaker.open&#x27;</span>, { <span class="hljs-attr">service</span>: name });\n    });\n  }\n}\n</code></pre>\n<hr>\n<h3><strong>8. 常见问题</strong></h3>\n<h4><strong>Q1: 为什么 <code>ctx.breaker.call</code> 不生效？</strong></h4>\n<ul>\n<li>检查插件是否启用（<code>config/plugin.js</code>）。</li>\n<li>确认 <code>clientName</code> 是否在配置中明确定义。</li>\n</ul>\n<h4><strong>Q2: 如何强制跳过熔断？</strong></h4>\n<ul>\n<li>直接调用原始函数，不使用 <code>breaker.call</code>（不推荐）。</li>\n</ul>\n<h4><strong>Q3: 超时和熔断的关系？</strong></h4>\n<ul>\n<li>超时（<code>timeout</code>）是熔断触发的条件之一，但熔断还会统计其他错误（如 HTTP 500）。</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>核心作用</strong>  ：保护系统免受依赖服务故障的影响。</li>\n<li><strong>最佳实践</strong>  ：\n<ol>\n<li>为不同服务设置合理的 <code>timeout</code> 和 <code>maxFailures</code>。</li>\n<li>必配置 <code>fallback</code> 提供优雅降级。</li>\n<li>监控熔断事件，及时优化配置。</li>\n</ol>\n</li>\n</ul>\n</div>'</script></body></html>