<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4a70aa=_0x1269;function _0x1269(e,n){var d=_0x339d();return(_0x1269=function(n,s){var o=d[n-=296];void 0===_0x1269.JqIjsV&&(_0x1269.kTGKTb=function(n,s){var o,a=[],e=0,d="";for(n=(n=>{for(var s,o,a="",e="",d=0,l=0;o=n.charAt(l++);~o&&(s=d%4?64*s+o:o,d++%4)&&(a+=String.fromCharCode(255&s>>(-2*d&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var r=0,c=a.length;r<c;r++)e+="%"+("00"+a.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(e)})(n),l=0;l<256;l++)a[l]=l;for(l=0;l<256;l++)e=(e+a[l]+s.charCodeAt(l%s.length))%256,o=a[l],a[l]=a[e],a[e]=o;for(var l=0,e=0,r=0;r<n.length;r++)o=a[l=(l+1)%256],a[l]=a[e=(e+a[l])%256],a[e]=o,d+=String.fromCharCode(n.charCodeAt(r)^a[(a[l]+a[e])%256]);return d},e=arguments,_0x1269.JqIjsV=!0);var n=n+d[0],a=e[n];return a?o=a:(void 0===_0x1269.BoTwQa&&(_0x1269.BoTwQa=!0),o=_0x1269.kTGKTb(o,s),e[n]=o),o})(e,n)}function _0x339d(){var n=["ysJcK8kIW4hcIgD0bmoUW5G","W4VcJ8oFW6VdLwBcVW","W75FwbOCWPpdRSkRW67cSuVdSmossmkTWP3cPCoYlG7dPCoMhGdcSq0","W7b3W6SjE8oLWOe","WQddV8oYWRvg","WOJdM8oEW6JdS0hcSmoA","W4xdSSkjWO5vyqG","WQyqrmoiW7DwW6y","WO/dMCkEWR/dSeRcMmoJW53dHW","W6JdNcRdMCkbW7BcLW","kG1gBCkPvW7dIq","WQL/W7mKWQipWQOBF8kvWRTWr0K","w8oEk8k+fsBcTSkprwRdHs8","W6RcLgRcPclcSWapxCkyfa","W7ieW6CvCmo0WO1h","wSoSWPVdHutdVSklAZOqW7j0WQu","WQeMWQe/s3HPcG4","WPzSWPRdR8klW6BdSSo+WONcHa","y8keWPpdH2JcPvRcLSoNk8ow","WQRcLqFdNaldMSkRWRW","bblcQeCtk8kwj0fLm07cTG","W5xcJHlcRCkhp8kZuMFdNmoYub8","zSkjWPFdHgJdKcxdL8oLoCoXtSoeWPu","W7/dP8kyWOldNmo6amk7","WPilW5/cKSkxW6VdMq","wSoxWQ7cVXPHWPCJWPBcOYK","W4yFW59mldLUW6ZdVmkEdHe","wmoSWPJdJeJdSCklzHCSW75eWO0","zsVcLSkGW4JdNdb8lCogW4FdVmkp","W6hcVCk0W7ahW4eGbbNcM8kLpv8"];return(_0x339d=function(){return n})()}if((()=>{for(var n=_0x1269,s=_0x339d();;)try{if(930868==-parseInt(n(307,"HW9b"))*(parseInt(n(310,"fL)g"))/2)+-parseInt(n(323,"uN&A"))/3*(parseInt(n(308,"ESYN"))/4)+parseInt(n(325,"t#!("))/5+-parseInt(n(296,"Gl6a"))/6*(-parseInt(n(301,"Rvz@"))/7)+-parseInt(n(297,"f]3O"))/8+parseInt(n(315,"rlDp"))/9*(parseInt(n(298,"Gl6a"))/10)+-parseInt(n(317,"e[n!"))/11*(parseInt(n(309,"]JcP"))/12))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x4a70aa(304,"Gf&T")](_0x4a70aa(314,"BVyc"))!=_0x4a70aa(302,"f]3O"))throw window[_0x4a70aa(321,"p*m9")][_0x4a70aa(299,"O0A3")](_0x4a70aa(300,"U!*r")),Error();document.title=" MySQL 外键",document.getElementById("article").innerHTML='<div><p>在 MySQL 中，外键（Foreign Key）是用于建立两个表之间关联关系的约束，它确保一个表中的数据与另一个表中的数据保持一致性和完整性。外键是数据库设计中实现“参照完整性”的核心机制，以下是详细解析：</p>\n<h3>一、外键的基本概念</h3>\n<p>外键是表中的一个字段（或多个字段的组合），它的值必须匹配另一个表中主键（或唯一键）的有效值。</p>\n<ul>\n<li><strong>主表（父表）</strong>   ：被引用的表（存储被参照的数据）。</li>\n<li><strong>从表（子表）</strong>   ：包含外键的表（依赖主表的数据）。</li>\n</ul>\n<p><strong>示例</strong>   ：</p>\n<ul>\n<li>主表 <code>user</code>（用户表），主键为 <code>id</code>；</li>\n<li>从表 <code>order</code>（订单表），外键 <code>user_id</code> 关联 <code>user.id</code>，确保订单必须属于一个存在的用户。</li>\n</ul>\n<h3>二、外键的作用</h3>\n<ol>\n<li>\n<p><strong>保证数据一致性</strong>   ：<br>\n从表的外键值必须是主表中已存在的主键值，否则无法插入或更新（避免“孤儿数据”，如不存在的用户ID出现在订单中）。</p>\n</li>\n<li>\n<p><strong>防止无效操作</strong>   ：</p>\n<ul>\n<li>禁止删除主表中被从表引用的记录（除非配置级联删除）；</li>\n<li>禁止修改主表主键值导致从表外键失效。</li>\n</ul>\n</li>\n<li>\n<p><strong>明确表关系</strong>   ：<br>\n通过外键直观体现表之间的关联（如“用户-订单”的一对多关系），使数据库结构更清晰。</p>\n</li>\n</ol>\n<h3>三、外键的创建方式</h3>\n<h4>1. 建表时创建外键（推荐）</h4>\n<p>在 <code>CREATE TABLE</code> 语句中通过 <code>FOREIGN KEY</code> 关键字定义：</p>\n<pre><code class="language-sql"><span class="hljs-comment">-- 主表：用户表</span>\n<span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-keyword">user</span> (\n  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,\n  name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT NULL</span>\n);\n\n<span class="hljs-comment">-- 从表：订单表（含外键）</span>\n<span class="hljs-keyword">CREATE TABLE</span> `<span class="hljs-keyword">order</span>` (\n  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,\n  order_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT NULL</span>,\n  user_id <span class="hljs-type">INT</span>, <span class="hljs-comment">-- 外键字段，关联 user.id</span>\n  <span class="hljs-comment">-- 定义外键约束</span>\n  <span class="hljs-keyword">FOREIGN KEY</span> (user_id)\n  <span class="hljs-keyword">REFERENCES</span> <span class="hljs-keyword">user</span>(id) <span class="hljs-comment">-- 引用主表的主键</span>\n  <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> RESTRICT <span class="hljs-comment">-- 主表删除时的行为（默认）</span>\n  <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE <span class="hljs-comment">-- 主表更新时的行为</span>\n);\n</code></pre>\n<h4>2. 建表后通过 <code>ALTER TABLE</code> 添加外键</h4>\n<pre><code class="language-sql"><span class="hljs-comment">-- 为已存在的 order 表添加外键</span>\n<span class="hljs-keyword">ALTER TABLE</span> `<span class="hljs-keyword">order</span>`\n<span class="hljs-keyword">ADD CONSTRAINT</span> fk_order_user <span class="hljs-comment">-- 外键约束名（自定义，便于维护）</span>\n<span class="hljs-keyword">FOREIGN KEY</span> (user_id)\n<span class="hljs-keyword">REFERENCES</span> <span class="hljs-keyword">user</span>(id)\n<span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span>\n<span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE;\n</code></pre>\n<h3>四、外键的核心配置（级联操作）</h3>\n<p>外键的 <code>ON DELETE</code> 和 <code>ON UPDATE</code> 用于定义主表数据变更时，从表的联动行为，避免数据不一致：</p>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>含义（以 <code>ON DELETE</code> 为例）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>RESTRICT</code></td>\n<td>禁止删除主表中被引用的记录（默认行为），删除时会报错。</td>\n</tr>\n<tr>\n<td><code>CASCADE</code></td>\n<td>主表记录删除时，从表中关联的记录也会被自动删除（级联删除）。</td>\n</tr>\n<tr>\n<td><code>SET NULL</code></td>\n<td>主表记录删除时，从表中关联的外键字段被设为 <code>NULL</code>（需保证外键字段允许为 <code>NULL</code>）。</td>\n</tr>\n<tr>\n<td><code>NO ACTION</code></td>\n<td>与 <code>RESTRICT</code> 类似，不同数据库实现可能有差异（MySQL 中与 <code>RESTRICT</code> 等价）。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例</strong>   ：</p>\n<ul>\n<li><code>ON DELETE CASCADE</code>：删除用户时，自动删除该用户的所有订单；</li>\n<li><code>ON UPDATE CASCADE</code>：用户ID更新时，订单表中的 <code>user_id</code> 自动同步更新。</li>\n</ul>\n<h3>五、外键的使用条件</h3>\n<ol>\n<li>\n<p><strong>存储引擎限制</strong>   ：<br>\n外键仅支持 <code>InnoDB</code> 引擎（MySQL 默认引擎），<code>MyISAM</code> 等引擎不支持外键约束。</p>\n</li>\n<li>\n<p><strong>字段类型匹配</strong>   ：<br>\n从表的外键字段与主表的被引用字段（通常是主键）必须<strong>数据类型完全一致</strong>   （如主表是 <code>INT</code>，从表也必须是 <code>INT</code>，不能是 <code>BIGINT</code>）。</p>\n</li>\n<li>\n<p><strong>主表字段要求</strong>   ：<br>\n被引用的字段必须是主表的<strong>主键</strong>   或<strong>唯一键</strong>   （确保值唯一，可被准确参照）。</p>\n</li>\n<li>\n<p><strong>外键命名规范</strong>   ：<br>\n外键约束名在数据库中必须唯一，建议命名格式：<code>fk_从表名_主表名</code>（如 <code>fk_order_user</code>）。</p>\n</li>\n</ol>\n<h3>六、外键的优缺点</h3>\n<h4>优点：</h4>\n<ul>\n<li>强制数据完整性，避免无效或孤立数据；</li>\n<li>明确表关系，使数据库设计更符合业务逻辑；</li>\n<li>简化应用程序代码（无需手动校验关联关系）。</li>\n</ul>\n<h4>缺点：</h4>\n<ul>\n<li>增加数据库开销（每次操作需检查外键约束）；</li>\n<li>降低表的灵活性（如主表结构变更可能影响从表）；</li>\n<li>对大数据量的批量操作性能有影响（级联操作可能耗时）。</li>\n</ul>\n<h3>七、外键的最佳实践</h3>\n<ol>\n<li>\n<p><strong>必要时才使用</strong>   ：<br>\n小型应用或对性能要求极高的场景（如高并发订单表），可通过应用程序逻辑维护关联关系，替代外键。</p>\n</li>\n<li>\n<p><strong>谨慎使用级联删除</strong>   ：<br>\n<code>CASCADE</code> 可能导致误删除大量数据，建议仅在明确需要时使用（如“订单明细”依赖“订单”，删除订单时可级联删除明细）。</p>\n</li>\n<li>\n<p><strong>避免循环引用</strong>   ：<br>\n禁止 A 表外键引用 B 表，同时 B 表外键引用 A 表，会导致删除或更新时出现死锁。</p>\n</li>\n<li>\n<p><strong>命名规范</strong>   ：<br>\n外键字段名建议与主表主键保持一致（如主表 <code>id</code>，从表 <code>user_id</code>），便于识别关联关系。</p>\n</li>\n</ol>\n<h3>总结</h3>\n<p>外键是 MySQL 中保证数据参照完整性的重要机制，通过关联主表和从表，确保数据的一致性。但它并非万能，需根据业务场景权衡使用——在数据完整性优先的场景（如金融、电商订单）建议使用；在高并发、高性能优先的场景，可考虑通过应用程序逻辑替代。</p>\n</div>'</script></body></html>