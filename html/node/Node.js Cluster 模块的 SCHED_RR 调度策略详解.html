<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x18cc16=_0x4be0;function _0xbe3d(){var n=["W5bVW4ddLSoeW5hdT8oeW7f+W73dNCkX","WPWxwuddQMNdLCk4v8ouWR0l","DSkNu8kYW5jVW4ddUSk2W5lcNCo/WPi","AeqCzmoO","W5BdI09xW5pdUCkZWR7dGeahCmki","tmk9jcVcPe99ma","kSofW6jXW53cOmkpWPZcOmo+W4ZdUH4","aSoEvxHRwSocWRVcHNOysMq","v3jtkZCGW7BdNSoUWRjeWRq4W7ZcMhZcTCkmmmocWRaUW65tsCkg","cCoGhGRcNeTu","W6BcSmobyCo5W4PxW58h","bSoAu31UwmkrWP3cJg41AW","fI16uHHwW7H3W5JdISohCa","EmoiW6HXWOlcGt93DSkohmob","W74VFefPWQ3cGCkjuwxcMmkXW7y","WO3dIWbhWO3dSx3cTG","jdtcS0rykGq","W5NcVSkFA8kNnCoOWQKtWRitpG","WRBdUCkSlCkWWRpcQ0H2Er9v","WO8YWPFcJ8kgWO/cQSoE","WOLaW4RcUxCGF8koWPnfW47dTr4","W5mXEebsngr9","b8oAuhbPxmodWQlcKfGvv3W"];return(_0xbe3d=function(){return n})()}function _0x4be0(o,n){var l=_0xbe3d();return(_0x4be0=function(n,s){var t=l[n-=200];void 0===_0x4be0.fEKyQI&&(_0x4be0.eXMuWU=function(n,s){var t,r=[],o=0,l="";for(n=(n=>{for(var s,t,r="",o="",l=0,e=0;t=n.charAt(e++);~t&&(s=l%4?64*s+t:t,l++%4)&&(r+=String.fromCharCode(255&s>>(-2*l&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var a=0,c=r.length;a<c;a++)o+="%"+("00"+r.charCodeAt(a).toString(16)).slice(-2);return decodeURIComponent(o)})(n),e=0;e<256;e++)r[e]=e;for(e=0;e<256;e++)o=(o+r[e]+s.charCodeAt(e%s.length))%256,t=r[e],r[e]=r[o],r[o]=t;for(var e=0,o=0,a=0;a<n.length;a++)t=r[e=(e+1)%256],r[e]=r[o=(o+r[e])%256],r[o]=t,l+=String.fromCharCode(n.charCodeAt(a)^r[(r[e]+r[o])%256]);return l},o=arguments,_0x4be0.fEKyQI=!0);var n=n+l[0],r=o[n];return r?t=r:(void 0===_0x4be0.KskQsM&&(_0x4be0.KskQsM=!0),t=_0x4be0.eXMuWU(t,s),o[n]=t),t})(o,n)}if((()=>{for(var n=_0x4be0,s=_0xbe3d();;)try{if(912334==-parseInt(n(211,"ivzS"))+parseInt(n(205,"%5*8"))/2+-parseInt(n(217,"efq9"))/3+-parseInt(n(213,"mBqA"))/4+-parseInt(n(201,"AE3p"))/5+-parseInt(n(214,"c%Nl"))/6*(-parseInt(n(216,"#uX3"))/7)+-parseInt(n(220,"y2wx"))/8*(-parseInt(n(203,"PW*K"))/9))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x18cc16(215,"Lfzt")](_0x18cc16(209,"Z4f9"))!=_0x18cc16(202,"Z[^D"))throw window[_0x18cc16(218,"^kKM")][_0x18cc16(208,"8X2O")](_0x18cc16(207,"3m%j")),Error();document.title="Node.js Cluster 模块的 SCHED_RR 调度策略详解",document.getElementById("article").innerHTML='<div><p><code>cluster.SCHED_RR</code> 是 Node.js Cluster 模块中的一种负载均衡策略，代表 &quot;Round Robin&quot;（轮询调度）。这是 Node.js 默认采用的调度策略。</p>\n<h2>基本概念</h2>\n<h3>什么是 SCHED_RR？</h3>\n<ul>\n<li><strong>RR</strong>   是 &quot;Round Robin&quot; 的缩写</li>\n<li>这是一种循环分配请求的调度算法</li>\n<li>主进程按照固定顺序将新连接分配给各个工作进程</li>\n<li>确保每个工作进程获得大致相同数量的连接</li>\n</ul>\n<h2>工作原理</h2>\n<ol>\n<li>当新连接到达时，主进程接收连接</li>\n<li>主进程按照工作进程列表的顺序将连接分配给下一个工作进程</li>\n<li>分配完最后一个工作进程后，又从第一个工作进程开始循环</li>\n</ol>\n<pre><code>工作进程列表: [Worker1, Worker2, Worker3]\n连接分配顺序: Worker1 → Worker2 → Worker3 → Worker1 → Worker2 → Worker3 → ...\n</code></pre>\n<h2>如何设置</h2>\n<p>可以在启动集群前设置调度策略：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> cluster = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cluster&#x27;</span>);\n<span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;os&#x27;</span>);\n\n<span class="hljs-comment">// 设置调度策略为 Round Robin</span>\ncluster.<span class="hljs-property">schedulingPolicy</span> = cluster.<span class="hljs-property">SCHED_RR</span>;\n\n<span class="hljs-comment">// 或者使用数值 (SCHED_RR = 2, SCHED_NONE = 1)</span>\n<span class="hljs-comment">// cluster.schedulingPolicy = 2;</span>\n\n<span class="hljs-keyword">if</span> (cluster.<span class="hljs-property">isMaster</span>) {\n  <span class="hljs-comment">// 创建工作进程</span>\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; os.<span class="hljs-title function_">cpus</span>().<span class="hljs-property">length</span>; i++) {\n    cluster.<span class="hljs-title function_">fork</span>();\n  }\n} <span class="hljs-keyword">else</span> {\n  <span class="hljs-comment">// 工作进程代码</span>\n  <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./app&#x27;</span>);\n}\n</code></pre>\n<h2>特点</h2>\n<h3>优点</h3>\n<ol>\n<li><strong>公平性</strong>  ：每个工作进程获得大致相同数量的连接</li>\n<li><strong>可预测性</strong>  ：分配顺序固定，便于调试和性能分析</li>\n<li><strong>简单高效</strong>  ：算法实现简单，开销小</li>\n<li><strong>适合短连接</strong>  ：对于处理时间相近的短连接效果最佳</li>\n</ol>\n<h3>缺点</h3>\n<ol>\n<li><strong>不考虑负载</strong>  ：不关心工作进程当前的实际负载</li>\n<li><strong>不适合长连接</strong>  ：如果连接持续时间差异大，可能导致负载不均</li>\n<li><strong>无状态感知</strong>  ：不跟踪工作进程的状态或处理能力</li>\n</ol>\n<h2>与 SCHED_NONE 的比较</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>SCHED_RR (Round Robin)</th>\n<th>SCHED_NONE (操作系统调度)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>调度方式</td>\n<td>Node.js 主进程轮询分配</td>\n<td>由操作系统决定</td>\n</tr>\n<tr>\n<td>默认值</td>\n<td>是 (Linux/Unix)</td>\n<td>是 (Windows)</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>稍高（用户空间调度）</td>\n<td>可能稍低（内核空间调度）</td>\n</tr>\n<tr>\n<td>可预测性</td>\n<td>高</td>\n<td>低</td>\n</tr>\n<tr>\n<td>适合场景</td>\n<td>短连接、均匀负载</td>\n<td>长连接、特殊负载需求</td>\n</tr>\n</tbody>\n</table>\n<h2>实际应用建议</h2>\n<ol>\n<li><strong>大多数情况下使用默认值</strong>  ：Node.js 会根据平台自动选择最佳策略</li>\n<li><strong>短连接服务</strong>  ：如 HTTP API 服务，SCHED_RR 通常表现更好</li>\n<li><strong>需要更精细控制时</strong>  ：考虑使用反向代理（如 Nginx）进行负载均衡</li>\n<li><strong>混合使用</strong>  ：可以将 SCHED_RR 与其他技术结合使用</li>\n</ol>\n<h2>注意事项</h2>\n<ol>\n<li>在 Windows 上，默认使用 SCHED_NONE</li>\n<li>调度策略必须在调用 <code>cluster.fork()</code> 前设置</li>\n<li>修改调度策略不会影响已建立的工作进程</li>\n<li>对于特殊需求，可能需要实现自定义的负载均衡逻辑</li>\n</ol>\n<p>通过理解 SCHED_RR 的工作原理，可以更好地优化 Node.js 集群应用的性能表现。</p>\n</div>'</script></body></html>