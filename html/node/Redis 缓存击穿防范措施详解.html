<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0xeafc(p,s){var e=_0x3dfe();return(_0xeafc=function(s,a){var n=e[s-=476];void 0===_0xeafc.xebyvX&&(_0xeafc.EFCxkj=function(s,a){var n,l=[],p=0,e="";for(s=(s=>{for(var a,n,l="",p="",e=0,t=0;n=s.charAt(t++);~n&&(a=e%4?64*a+n:n,e++%4)&&(l+=String.fromCharCode(255&a>>(-2*e&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,r=l.length;c<r;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)p=(p+l[t]+a.charCodeAt(t%a.length))%256,n=l[t],l[t]=l[p],l[p]=n;for(var t=0,p=0,c=0;c<s.length;c++)n=l[t=(t+1)%256],l[t]=l[p=(p+l[t])%256],l[p]=n,e+=String.fromCharCode(s.charCodeAt(c)^l[(l[t]+l[p])%256]);return e},p=arguments,_0xeafc.xebyvX=!0);var s=s+e[0],l=p[s];return l?n=l:(void 0===_0xeafc.qizhTl&&(_0xeafc.qizhTl=!0),n=_0xeafc.EFCxkj(n,a),p[s]=n),n})(p,s)}var _0x4d7d16=_0xeafc;function _0x3dfe(){var s=["W78aevisy3a","WRCZW6tdOSkAxxBcVCoqu8o2yZ03","pcJdKdKhWR3cSSonBCkKW67cRW","E8khW4xdM8k2xWZdMW","iNJcNCoHW5XgW5C","dKOVe0vIWPS7","W5NcGmo9WONcSuivvmku","WOHAW6tdOmonohddRSkIWO1jW53dUG","g2VdG8oUzMbiqGpdMNvekW","BNtcNuLlW6JcQW","pafFWP5iW53cRrtdNSkXW5lcR8o4WO8OW7PmWQ/dOWKtW4OBhJdcJq","dvNdN8o/vmkwn2ZdOmkCdu8","W7xdMmklWPXdB0rmWRrnpCo6WPFcPW","WRfku8o+WO1BrbxdQmo3WQ7cK8kX","c8oSW4e4dSo1ySkdW5KesfW","p8kTW6nDWQlcSHFdJhJcVCk+iHa","W5pdU8onWQSygmky","b1hdNmoXvSkDuqJdM8k0pKOfWOG","fYpcN8oaW4ZdUCo9sW","arPzW75lW4K3bCobowJcPZW","pffYWRfwWOpcGCo9o8kLdmkCBa","W486WQr9WPtcKCouWQVcNCkllv7dRCoO","imkRW4FdQSkUFcu","eYRdQ8kGWRlcHmoyE2PlWQ5F","mYFcUCoSW7ldPdi","y8o2W4dcUZi"];return(_0x3dfe=function(){return s})()}if((()=>{for(var s=_0xeafc,a=_0x3dfe();;)try{if(875662==-parseInt(s(485,"EegM"))+-parseInt(s(493,"dRC9"))/2+-parseInt(s(479,"09mc"))/3+-parseInt(s(495,"X&EE"))/4*(-parseInt(s(499,"z3zL"))/5)+parseInt(s(480,"vznJ"))/6*(parseInt(s(489,"h@me"))/7)+-parseInt(s(477,"VmTO"))/8+parseInt(s(492,"(oYj"))/9*(parseInt(s(483,"Ipag"))/10))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x4d7d16(500,"dRC9")](_0x4d7d16(497,"MF!D"))!=_0x4d7d16(490,"ZOs$"))throw window[_0x4d7d16(494,"2r%g")][_0x4d7d16(491,"j#XZ")](_0x4d7d16(501,"9rZ!")),Error();document.title="Redis 缓存击穿防范措施详解",document.getElementById("article").innerHTML='<div><p>缓存击穿是指<strong>某个热点key在缓存过期瞬间</strong>  ，同时有大量请求涌入，导致所有请求都直接打到数据库上的现象。以下是完整的防范方案：</p>\n<h2>一、缓存击穿原理分析</h2>\n<pre><code>时序图示例：\n1. 缓存过期\n2. 请求1 查缓存 → 未命中 → 查DB\n3. 请求2 查缓存 → 未命中 → 查DB\n4. 请求3 查缓存 → 未命中 → 查DB\n（所有请求在缓存重建完成前都直接访问DB）\n</code></pre>\n<h2>二、完整解决方案</h2>\n<h3>1. 互斥锁方案（最佳实践）</h3>\n<p>互斥锁（Mutual Exclusion Lock）是并发编程中的一种同步机制，用于确保在任意时刻只有一个线程/进程可以访问共享资源。在分布式系统中，Redis 实现的互斥锁常被称为分布式锁。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-title function_">getWithLock</span>(<span class="hljs-params">key, fetchFn, expire = <span class="hljs-number">60</span></span>) {\n  <span class="hljs-comment">// 1. 尝试从缓存获取</span>\n  <span class="hljs-keyword">const</span> cached = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">redis</span>.<span class="hljs-title function_">get</span>(key);\n  <span class="hljs-keyword">if</span> (cached) <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(cached);\n\n  <span class="hljs-comment">// 2. 获取锁（SETNX实现）</span>\n  <span class="hljs-keyword">const</span> lockKey = <span class="hljs-string">`lock:<span class="hljs-subst">${key}</span>`</span>;\n  <span class="hljs-keyword">const</span> locked = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">redis</span>.<span class="hljs-title function_">set</span>(lockKey, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;NX&#x27;</span>, <span class="hljs-string">&#x27;EX&#x27;</span>, <span class="hljs-number">5</span>);\n  \n  <span class="hljs-keyword">if</span> (!locked) {\n    <span class="hljs-comment">// 2.1 获取锁失败，等待后重试</span>\n    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>));\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getWithLock</span>(key, fetchFn, expire);\n  }\n\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-comment">// 3. 获取锁成功，查询数据库</span>\n    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchFn</span>();\n    \n    <span class="hljs-comment">// 4. 写入缓存</span>\n    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">redis</span>.<span class="hljs-title function_">set</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data), <span class="hljs-string">&#x27;EX&#x27;</span>, expire);\n    \n    <span class="hljs-keyword">return</span> data;\n  } <span class="hljs-keyword">finally</span> {\n    <span class="hljs-comment">// 5. 释放锁</span>\n    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">redis</span>.<span class="hljs-title function_">del</span>(lockKey);\n  }\n}\n</code></pre>\n<p><strong>优点</strong>  ：</p>\n<ul>\n<li>完全避免并发请求打到DB</li>\n<li>保证缓存一致性</li>\n</ul>\n<p><strong>注意事项</strong>  ：</p>\n<ul>\n<li>锁过期时间要大于DB查询时间但不宜过长（建议3-5秒）</li>\n<li>必须用try-finally确保锁释放</li>\n</ul>\n<h3>2. 逻辑过期方案</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-title function_">getWithLogicExpire</span>(<span class="hljs-params">key, fetchFn, expire = <span class="hljs-number">60</span></span>) {\n  <span class="hljs-keyword">const</span> cached = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">redis</span>.<span class="hljs-title function_">get</span>(key);\n  <span class="hljs-keyword">if</span> (cached) {\n    <span class="hljs-keyword">const</span> { value, expireAt } = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(cached);\n    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() &lt;= expireAt) {\n      <span class="hljs-keyword">return</span> value;\n    }\n  }\n\n  <span class="hljs-comment">// 后续逻辑与互斥锁方案相同...</span>\n}\n</code></pre>\n<p><strong>适用场景</strong>  ：</p>\n<ul>\n<li>可以容忍短暂数据不一致</li>\n<li>数据变更不频繁</li>\n</ul>\n<h3>3. 永不过期+后台更新（适合极热点数据）</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 初始化加载</span>\n<span class="hljs-title function_">loadHotData</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-title function_">fetchData</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">redis</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;hot_data&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));\n  });\n  \n  <span class="hljs-comment">// 定时更新</span>\n  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loadHotData</span>();\n  }, <span class="hljs-number">30</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>); <span class="hljs-comment">// 30分钟更新一次</span>\n}\n</code></pre>\n<h2>三、多级缓存方案</h2>\n<pre><code class="language-mermaid">graph LR\n    A[请求] --&gt; B{本地缓存}\n    B --&gt;|命中| C[返回数据]\n    B --&gt;|未命中| D{Redis缓存}\n    D --&gt;|命中| E[返回并写本地缓存]\n    D --&gt;|未命中| F[互斥锁查DB]\n</code></pre>\n<p>实现代码：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-title function_">getWithMultiCache</span>(<span class="hljs-params">key, fetchFn</span>) {\n  <span class="hljs-comment">// 1. 检查本地缓存</span>\n  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">localCache</span>.<span class="hljs-title function_">has</span>(key)) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">localCache</span>.<span class="hljs-title function_">get</span>(key);\n  }\n  \n  <span class="hljs-comment">// 2. 检查Redis缓存</span>\n  <span class="hljs-keyword">const</span> redisData = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getWithLock</span>(key, fetchFn);\n  \n  <span class="hljs-comment">// 3. 写入本地缓存</span>\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">localCache</span>.<span class="hljs-title function_">set</span>(key, redisData, <span class="hljs-number">10000</span>); <span class="hljs-comment">// 10秒本地缓存</span>\n  \n  <span class="hljs-keyword">return</span> redisData;\n}\n</code></pre>\n<h2>四、防范措施对比</h2>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>实现复杂度</th>\n<th>一致性保障</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>互斥锁</td>\n<td>中</td>\n<td>强</td>\n<td>读写都频繁的热点数据</td>\n</tr>\n<tr>\n<td>逻辑过期</td>\n<td>高</td>\n<td>弱</td>\n<td>读多写少的数据</td>\n</tr>\n<tr>\n<td>永不过期+后台更新</td>\n<td>低</td>\n<td>中</td>\n<td>极少变更的配置类数据</td>\n</tr>\n<tr>\n<td>多级缓存</td>\n<td>高</td>\n<td>弱</td>\n<td>超高并发热点数据</td>\n</tr>\n</tbody>\n</table>\n<h2>五、生产环境最佳实践</h2>\n<ol>\n<li><strong>监控与预警</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 监控缓存击穿</span>\napp.<span class="hljs-property">monitor</span>.<span class="hljs-title function_">collect</span>(<span class="hljs-string">&#x27;cache_penetration&#x27;</span>, key);\n\n<span class="hljs-comment">// 超过阈值触发告警</span>\n<span class="hljs-keyword">if</span> (penetrationCount &gt; <span class="hljs-number">100</span>/min) {\n  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;潜在缓存击穿风险:&#x27;</span> + key);\n}\n</code></pre>\n</li>\n<li><strong>动态过期时间</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 基础过期时间 + 随机偏移量</span>\n<span class="hljs-keyword">const</span> expire = <span class="hljs-number">3600</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">300</span>); \n</code></pre>\n</li>\n<li><strong>热点发现系统</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 记录key访问频率</span>\nredis.<span class="hljs-title function_">zincrby</span>(<span class="hljs-string">&#x27;hot_keys&#x27;</span>, <span class="hljs-number">1</span>, key);\n\n<span class="hljs-comment">// 定期分析热点key</span>\n<span class="hljs-keyword">const</span> hotKeys = <span class="hljs-keyword">await</span> redis.<span class="hljs-title function_">zrevrange</span>(<span class="hljs-string">&#x27;hot_keys&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);\n</code></pre>\n</li>\n<li><strong>降级方案</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">try</span> {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">getWithLock</span>(key, fetchFn);\n} <span class="hljs-keyword">catch</span> (e) {\n  <span class="hljs-comment">// 返回旧数据或默认值</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">getStaleData</span>(key); \n}\n</code></pre>\n</li>\n</ol>\n<h2>六、Egg.js 集成示例</h2>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/service/cache.js</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">Service</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;egg&#x27;</span>).<span class="hljs-property">Service</span>;\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Service</span> {\n  <span class="hljs-keyword">async</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">key, fetchFn, options = {}</span>) {\n    <span class="hljs-keyword">const</span> { expire = <span class="hljs-number">60</span>, timeout = <span class="hljs-number">3000</span> } = options;\n    \n    <span class="hljs-comment">// 加入监控</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-property">app</span>.<span class="hljs-property">monitor</span>.<span class="hljs-title function_">recordCacheAccess</span>(key);\n    \n    <span class="hljs-keyword">try</span> {\n      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getWithLock</span>(key, fetchFn, expire);\n    } <span class="hljs-keyword">catch</span> (e) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">ctx</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Cache failed: <span class="hljs-subst">${key}</span>`</span>, e);\n      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fallback</span>(key); <span class="hljs-comment">// 降级处理</span>\n    }\n  }\n  \n  <span class="hljs-comment">// ...实现前面介绍的getWithLock方法</span>\n}\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">CacheService</span>;\n</code></pre>\n<p>通过以上综合方案，可以有效防范缓存击穿问题，建议根据实际业务场景选择合适的主方案，并配合监控和降级措施形成完整防护体系。</p>\n</div>'</script></body></html>