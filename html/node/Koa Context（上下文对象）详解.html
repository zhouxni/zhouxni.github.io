<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x7d2ab=_0xe247;function _0x5d60(){var s=["FCk8xmkgW6zkxZ7dKq","W5vriSk/umoOia","W7ldSSo3W4WItJbuWO5gW45RWQSkW5yFWQVdIZOMW5mhdSkXj0q","WOjGWRf2WQtcL8kLW48OWPtdLa","WP/cV3RdTCoX","xLq+C8k9y8orcCoaWPxdRG","FCk6x8owWPTyFtNdIuDy","WRzLFCoDlYNcQSoIWRdcVmot","W48qWO3cQ3VdOSkjW7e","rCkhW5X7EIi/W4i","WOdcK8kUWRrYkSoh","W7/cGtFcLYOBW6eW","WQxcQ1xdSdTLbW","WRhcQ8k5ycG/WOuYyITpW47dVG","W6JdO8oZW5aWf3O","W7VcUWLbW58mWP/cJYCgnaa","W7lcRCkQWRFcTSk3FwVcPWJcRa","kW5Qimo+vSo0i8oq","W5VdRCk1AmomyJKPWPZdKmkTi8ow","wSoPxhNdI8oSW6iQkH8vWQ8r","qWxdKSoev8kIWPtcTuRdJCo1tMq","uCo4mmoenab8CfBdOJJcSLy","nbGBWP7dNSo+W4HzWOO","xvK+lCojzmoEfCoE","w1u7a8oPzmojkSoA","nHmCW6RcISo1W7fzWO7dNGm","WPS2W5yyW67cGJ3cICkOW6xcM8ko","yr7dP3H0C8oPW6ddVmoBW6GaBG"];return(_0x5d60=function(){return s})()}function _0xe247(e,s){var c=_0x5d60();return(_0xe247=function(s,n){var t=c[s-=120];void 0===_0xe247.fITxYT&&(_0xe247.MOjSKZ=function(s,n){var t,a=[],e=0,c="";for(s=(s=>{for(var n,t,a="",e="",c=0,o=0;t=s.charAt(o++);~t&&(n=c%4?64*n+t:t,c++%4)&&(a+=String.fromCharCode(255&n>>(-2*c&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var d=0,r=a.length;d<r;d++)e+="%"+("00"+a.charCodeAt(d).toString(16)).slice(-2);return decodeURIComponent(e)})(s),o=0;o<256;o++)a[o]=o;for(o=0;o<256;o++)e=(e+a[o]+n.charCodeAt(o%n.length))%256,t=a[o],a[o]=a[e],a[e]=t;for(var o=0,e=0,d=0;d<s.length;d++)t=a[o=(o+1)%256],a[o]=a[e=(e+a[o])%256],a[e]=t,c+=String.fromCharCode(s.charCodeAt(d)^a[(a[o]+a[e])%256]);return c},e=arguments,_0xe247.fITxYT=!0);var s=s+c[0],a=e[s];return a?t=a:(void 0===_0xe247.aJgIRO&&(_0xe247.aJgIRO=!0),t=_0xe247.MOjSKZ(t,n),e[s]=t),t})(e,s)}if((()=>{for(var s=_0xe247,n=_0x5d60();;)try{if(254154==+parseInt(s(122,"SRi#"))*(-parseInt(s(138,"r4Vz"))/2)+-parseInt(s(146,"mCJw"))/3*(parseInt(s(120,"[fGJ"))/4)+-parseInt(s(132,"xy6W"))/5+parseInt(s(139,"s9Om"))/6+-parseInt(s(134,"I79W"))/7*(parseInt(s(145,"sYS#"))/8)+parseInt(s(135,"sYS#"))/9*(parseInt(s(137,"I79W"))/10)+parseInt(s(131,"Murr"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x7d2ab(124,"2#tB")](_0x7d2ab(129,"sYS#"))!=_0x7d2ab(144,"Mc(#"))throw window[_0x7d2ab(121,"1A%q")][_0x7d2ab(126,"AvzQ")](_0x7d2ab(142,"AvzQ")),Error();document.title="Koa Context（上下文对象）详解",document.getElementById("article").innerHTML='<div><p>Koa 的 <strong>Context（<code>ctx</code>）</strong>   是一个封装了请求（<code>Request</code>）和响应（<code>Response</code>）的全局对象，每个中间件都可以访问它。它是 Koa 的核心设计之一，简化了 HTTP 请求和响应的操作。</p>\n<hr>\n<h2><strong>1. Context 的作用</strong></h2>\n<ul>\n<li><strong>统一管理</strong>  ：合并了 Node.js 的 <code>req</code>（请求）和 <code>res</code>（响应）对象。</li>\n<li><strong>简化 API</strong>  ：提供更直观的属性和方法（如 <code>ctx.body</code> 代替 <code>res.end()</code>）。</li>\n<li><strong>共享数据</strong>  ：在中间件之间传递数据（如 <code>ctx.user = {id: 1}</code>）。</li>\n</ul>\n<hr>\n<h2><strong>2. Context 的核心属性</strong></h2>\n<h3><strong>（1）请求相关（<code>ctx.request</code>）</strong></h3>\n<table>\n<thead>\n<tr>\n<th>属性/方法</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ctx.method</code></td>\n<td>HTTP 方法（GET/POST 等）</td>\n<td><code>ctx.method === \'GET\'</code></td>\n</tr>\n<tr>\n<td><code>ctx.url</code> / <code>ctx.path</code></td>\n<td>请求 URL 和路径</td>\n<td><code>ctx.path === \'/users\'</code></td>\n</tr>\n<tr>\n<td><code>ctx.query</code></td>\n<td>解析后的查询参数（对象形式）</td>\n<td><code>ctx.query.name</code></td>\n</tr>\n<tr>\n<td><code>ctx.headers</code></td>\n<td>请求头对象</td>\n<td><code>ctx.headers[\'user-agent\']</code></td>\n</tr>\n<tr>\n<td><code>ctx.ip</code></td>\n<td>客户端 IP 地址</td>\n<td><code>console.log(ctx.ip)</code></td>\n</tr>\n<tr>\n<td><code>ctx.get(field)</code></td>\n<td>获取请求头字段</td>\n<td><code>ctx.get(\'Accept\')</code></td>\n</tr>\n</tbody>\n</table>\n<h3><strong>（2）响应相关（<code>ctx.response</code>）</strong></h3>\n<table>\n<thead>\n<tr>\n<th>属性/方法</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ctx.body</code></td>\n<td>设置响应体（自动设置 <code>Content-Type</code>）</td>\n<td><code>ctx.body = { code: 200 }</code></td>\n</tr>\n<tr>\n<td><code>ctx.status</code></td>\n<td>HTTP 状态码（默认 <code>404</code>）</td>\n<td><code>ctx.status = 201</code></td>\n</tr>\n<tr>\n<td><code>ctx.set(field, value)</code></td>\n<td>设置响应头</td>\n<td><code>ctx.set(\'Cache-Control\', \'no-cache\')</code></td>\n</tr>\n<tr>\n<td><code>ctx.redirect(url)</code></td>\n<td>重定向</td>\n<td><code>ctx.redirect(\'/login\')</code></td>\n</tr>\n<tr>\n<td><code>ctx.type</code></td>\n<td>设置 <code>Content-Type</code></td>\n<td><code>ctx.type = \'text/html\'</code></td>\n</tr>\n</tbody>\n</table>\n<h3><strong>（3）其他实用属性</strong></h3>\n<table>\n<thead>\n<tr>\n<th>属性/方法</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ctx.cookies</code></td>\n<td>读写 Cookie（需 <code>koa-cookies</code> 中间件）</td>\n<td><code>ctx.cookies.set(\'name\', \'value\')</code></td>\n</tr>\n<tr>\n<td><code>ctx.state</code></td>\n<td>推荐用于中间件共享数据</td>\n<td><code>ctx.state.user = {id: 1}</code></td>\n</tr>\n<tr>\n<td><code>ctx.app</code></td>\n<td>访问 Koa 应用实例</td>\n<td><code>ctx.app.env</code></td>\n</tr>\n<tr>\n<td><code>ctx.throw(status, msg)</code></td>\n<td>抛出 HTTP 错误</td>\n<td><code>ctx.throw(401, \'Unauthorized\')</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>3. Context 的底层结构</strong></h2>\n<pre><code class="language-javascript"><span class="hljs-comment">// Context 封装了 Request 和 Response</span>\n<span class="hljs-keyword">const</span> ctx = {\n  <span class="hljs-attr">request</span>: {}, <span class="hljs-comment">// Koa Request 对象（非 Node.js 原生 req）</span>\n  <span class="hljs-attr">response</span>: {}, <span class="hljs-comment">// Koa Response 对象（非 Node.js 原生 res）</span>\n  <span class="hljs-attr">req</span>: {},      <span class="hljs-comment">// Node.js 原生 HTTP Request</span>\n  <span class="hljs-attr">res</span>: {},      <span class="hljs-comment">// Node.js 原生 HTTP Response</span>\n  <span class="hljs-attr">app</span>: {},       <span class="hljs-comment">// Koa 应用实例</span>\n  <span class="hljs-attr">state</span>: {}      <span class="hljs-comment">// 中间件共享数据</span>\n};\n</code></pre>\n<ul>\n<li><strong><code>ctx.request</code> 和 <code>ctx.response</code></strong>   是 Koa 扩展的对象，提供更友好的 API。</li>\n<li><strong><code>ctx.req</code> 和 <code>ctx.res</code></strong>   是 Node.js 原生对象，一般不需要直接操作。</li>\n</ul>\n<hr>\n<h2><strong>4. Context 的常见使用场景</strong></h2>\n<h3><strong>（1）获取请求参数</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 查询参数（?name=Jack）</span>\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx) =&gt; {\n  ctx.<span class="hljs-property">body</span> = <span class="hljs-string">`Hello, <span class="hljs-subst">${ctx.query.name}</span>`</span>;\n});\n\n<span class="hljs-comment">// POST 请求体（需 koa-body 中间件）</span>\napp.<span class="hljs-title function_">use</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-body&#x27;</span>)());\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx) =&gt; {\n  ctx.<span class="hljs-property">body</span> = <span class="hljs-string">`Received: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(ctx.request.body)}</span>`</span>;\n});\n</code></pre>\n<h3><strong>（2）设置响应</strong></h3>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx) =&gt; {\n  ctx.<span class="hljs-property">status</span> = <span class="hljs-number">200</span>;\n  ctx.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;application/json&#x27;</span>;\n  ctx.<span class="hljs-property">body</span> = { <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;OK&#x27;</span> };\n  <span class="hljs-comment">// 等效于：</span>\n  <span class="hljs-comment">// ctx.response.status = 200;</span>\n  <span class="hljs-comment">// ctx.response.body = { data: &#x27;OK&#x27; };</span>\n});\n</code></pre>\n<h3><strong>（3）共享数据（中间件传值）</strong></h3>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n  ctx.<span class="hljs-property">state</span>.<span class="hljs-property">user</span> = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> }; <span class="hljs-comment">// 推荐使用 state</span>\n  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();\n});\n\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx) =&gt; {\n  ctx.<span class="hljs-property">body</span> = <span class="hljs-string">`User ID: <span class="hljs-subst">${ctx.state.user.id}</span>`</span>;\n});\n</code></pre>\n<h3><strong>（4）错误处理</strong></h3>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx) =&gt; {\n  <span class="hljs-keyword">if</span> (!ctx.<span class="hljs-property">headers</span>.<span class="hljs-property">token</span>) {\n    ctx.<span class="hljs-keyword">throw</span>(<span class="hljs-number">401</span>, <span class="hljs-string">&#x27;Token required&#x27;</span>); <span class="hljs-comment">// 自动设置 status 和 body</span>\n  }\n});\n</code></pre>\n<hr>\n<h2><strong>5. 对比 Express 的 Request/Response</strong></h2>\n<table>\n<thead>\n<tr>\n<th><strong>功能</strong></th>\n<th><strong>Koa (ctx)</strong></th>\n<th><strong>Express (req/res)</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>获取查询参数</strong></td>\n<td><code>ctx.query</code></td>\n<td><code>req.query</code></td>\n</tr>\n<tr>\n<td><strong>获取请求体</strong></td>\n<td><code>ctx.request.body</code></td>\n<td><code>req.body</code></td>\n</tr>\n<tr>\n<td><strong>设置响应状态</strong></td>\n<td><code>ctx.status = 200</code></td>\n<td><code>res.status(200)</code></td>\n</tr>\n<tr>\n<td><strong>设置响应体</strong></td>\n<td><code>ctx.body = \'OK\'</code></td>\n<td><code>res.send(\'OK\')</code></td>\n</tr>\n<tr>\n<td><strong>设置响应头</strong></td>\n<td><code>ctx.set(\'Cache-Control\', \'no-cache\')</code></td>\n<td><code>res.set(\'Cache-Control\', \'no-cache\')</code></td>\n</tr>\n<tr>\n<td><strong>重定向</strong></td>\n<td><code>ctx.redirect(\'/login\')</code></td>\n<td><code>res.redirect(\'/login\')</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>6. 完整示例</strong></h2>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);\n<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();\n\n<span class="hljs-comment">// 中间件 1：记录请求时间</span>\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {\n  <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();\n  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();\n  <span class="hljs-keyword">const</span> duration = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - start;\n  ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;X-Response-Time&#x27;</span>, <span class="hljs-string">`<span class="hljs-subst">${duration}</span>ms`</span>);\n});\n\n<span class="hljs-comment">// 中间件 2：路由处理</span>\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx) =&gt; {\n  <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">path</span> === <span class="hljs-string">&#x27;/&#x27;</span>) {\n    ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&#x27;Home Page&#x27;</span>;\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">path</span> === <span class="hljs-string">&#x27;/user&#x27;</span>) {\n    ctx.<span class="hljs-property">body</span> = { <span class="hljs-attr">name</span>: ctx.<span class="hljs-property">query</span>.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;Anonymous&#x27;</span> };\n  } <span class="hljs-keyword">else</span> {\n    ctx.<span class="hljs-keyword">throw</span>(<span class="hljs-number">404</span>, <span class="hljs-string">&#x27;Not Found&#x27;</span>);\n  }\n});\n\napp.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server running on http://localhost:3000&#x27;</span>);\n});\n</code></pre>\n<hr>\n<h2><strong>总结</strong></h2>\n<ul>\n<li><strong><code>ctx</code> 是 Koa 的核心对象</strong>  ，封装了请求和响应的操作。</li>\n<li><strong>优势</strong>  ：\n<ul>\n<li>更简洁的 API（如 <code>ctx.body</code> 代替 <code>res.end()</code>）。</li>\n<li>支持异步控制（<code>async/await</code>）。</li>\n<li>中间件间数据共享（<code>ctx.state</code>）。</li>\n</ul>\n</li>\n<li><strong>适用场景</strong>  ：构建 RESTful API、需要精细控制 HTTP 请求/响应的应用。</li>\n</ul>\n<p>如果需要更高级的功能（如路由、模板渲染），可以结合 <code>@koa/router</code>、<code>koa-views</code> 等中间件使用。</p>\n</div>'</script></body></html>