<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1397(e,s){var c=_0x478c();return(_0x1397=function(s,n){var a=c[s-=310];void 0===_0x1397.lnpvtV&&(_0x1397.fnrcYh=function(s,n){var a,t=[],e=0,c="";for(s=(s=>{for(var n,a,t="",e="",c=0,l=0;a=s.charAt(l++);~a&&(n=c%4?64*n+a:a,c++%4)&&(t+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,o=t.length;r<o;r++)e+="%"+("00"+t.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(e)})(s),l=0;l<256;l++)t[l]=l;for(l=0;l<256;l++)e=(e+t[l]+n.charCodeAt(l%n.length))%256,a=t[l],t[l]=t[e],t[e]=a;for(var l=0,e=0,r=0;r<s.length;r++)a=t[l=(l+1)%256],t[l]=t[e=(e+t[l])%256],t[e]=a,c+=String.fromCharCode(s.charCodeAt(r)^t[(t[l]+t[e])%256]);return c},e=arguments,_0x1397.lnpvtV=!0);var s=s+c[0],t=e[s];return t?a=t:(void 0===_0x1397.XeaiNL&&(_0x1397.XeaiNL=!0),a=_0x1397.fnrcYh(a,n),e[s]=a),a})(e,s)}var _0x28f404=_0x1397;function _0x478c(){var s=["W4ZdICoZWRJcVXGPW45beSkaW4K","ySonW6z4WRRdGw7dNWm","hY5fWPbpWPz4W7hcQu7dJ8kBxG","s8osfKKeASkMcCkPf3hcJa","W4tcM0qaWQ7dO8kTtqxdIxu1","yComoe/cQSkGhSk9WOxcNmkUWOa","luFdOJLJvMdcT8kOW7lcHJ8","seNcUJWtWOrbWR1qWRPeWRO","zHFcOCouWOSaW4tdULNdLSoXW78","kX1BlCouWRirW5FcSSobWP3dTW","W5NcG0W+WQVdUsP5WORcNGO+","gsxcOc7dOSk7emk0","l8o9W4m5kmklctPlc8o7WOi+","W5BdVZxdOSo0WPays8oTvw7dSa","WOtcJCkZW7JdSa","j8kHWOD7W4tdRmkswSo3WR/dIvdcOflcGmo2W54MF8oRe8kKWQe1Ehq","WRJdR1ldNLJcL8kw","W5dcGKG0WQVdUtTUWRVcVs4/","aweEWOCiWQ0BW4BdVCkSWPKg","ieFdQmkbW5XtW7q"];return(_0x478c=function(){return s})()}if((()=>{for(var s=_0x1397,n=_0x478c();;)try{if(123376==-parseInt(s(322,"e5PO"))+-parseInt(s(313,"4N4p"))/2+-parseInt(s(317,"c5!K"))/3+-parseInt(s(326,"lQOv"))/4+parseInt(s(327,"JnxX"))/5+parseInt(s(314,"DN09"))/6+parseInt(s(311,"y(4u"))/7)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x28f404(325,"*LQV")](_0x28f404(310,"3Eom"))!=_0x28f404(323,"9Q9]"))throw window[_0x28f404(320,"eXv@")][_0x28f404(328,"c5!K")](_0x28f404(324,"96p[")),Error();document.title="Eggjs 3.x 定时任务详解",document.getElementById("article").innerHTML='<div><p>在 Egg.js 3.x 中，定时任务（Schedule）功能基于 <code>egg-schedule</code> 插件实现，允许开发者以声明式或编程式的方式定义周期性任务（如定时清理日志、数据同步等）。以下是详细说明和最佳实践：</p>\n<hr>\n<h3><strong>一、快速开始</strong></h3>\n<h4>1. 安装依赖</h4>\n<p>Egg.js 3.x 已内置定时任务支持，无需额外安装插件。</p>\n<h4>2. 创建定时任务文件</h4>\n<p>在 <code>app/schedule</code> 目录下新建文件（如 <code>update_cache.js</code>），每个文件代表一个独立任务。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/schedule/update_cache.js</span>\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">schedule</span>: {\n    <span class="hljs-attr">interval</span>: <span class="hljs-string">&#x27;10s&#x27;</span>, <span class="hljs-comment">// 每 10 秒执行一次</span>\n    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;worker&#x27;</span>,  <span class="hljs-comment">// 随机选择一个 worker 执行</span>\n  },\n  <span class="hljs-keyword">async</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">ctx</span>) {\n    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">update</span>();\n    ctx.<span class="hljs-property">logger</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;缓存更新结果: %j&#x27;</span>, res);\n  },\n};\n</code></pre>\n<hr>\n<h3><strong>二、核心配置项</strong></h3>\n<h4>1. <strong>调度规则 (<code>schedule</code>)</strong></h4>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>interval</code></td>\n<td>string</td>\n<td>执行间隔（如 <code>\'1m\'</code>、<code>\'2h\'</code>），支持单位：<code>s</code>/<code>m</code>/<code>h</code>/<code>d</code>。</td>\n</tr>\n<tr>\n<td><code>cron</code></td>\n<td>string</td>\n<td>Cron 表达式（如 <code>\'0 0 3 * * *\'</code>），与 <code>interval</code> 二选一。</td>\n</tr>\n<tr>\n<td><code>type</code></td>\n<td>string</td>\n<td>执行方式：<code>worker</code>（随机 worker）或 <code>all</code>（所有 worker 同时执行）。</td>\n</tr>\n<tr>\n<td><code>immediate</code></td>\n<td>boolean</td>\n<td>应用启动后立即执行一次。</td>\n</tr>\n<tr>\n<td><code>disable</code></td>\n<td>boolean</td>\n<td>禁用任务。</td>\n</tr>\n<tr>\n<td><code>env</code></td>\n<td>string[]</td>\n<td>仅在指定环境（如 <code>[\'prod\']</code>）下启用。</td>\n</tr>\n</tbody>\n</table>\n<h4>2. <strong>任务函数 (<code>task</code>)</strong></h4>\n<ul>\n<li>参数 <code>ctx</code>：当前请求的上下文（部分 API 不可用，如 <code>ctx.curl</code>）。</li>\n<li>支持异步操作（<code>async/await</code>）。</li>\n</ul>\n<hr>\n<h3><strong>三、高级用法</strong></h3>\n<h4>1. <strong>Cron 表达式示例</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-attr">schedule</span>: {\n  <span class="hljs-attr">cron</span>: <span class="hljs-string">&#x27;0 30 11 * * *&#x27;</span>, <span class="hljs-comment">// 每天 11:30:00 执行</span>\n  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;worker&#x27;</span>,\n}\n</code></pre>\n<p>Cron 格式：<code>秒 分 时 日 月 周</code>（兼容 Linux Cron）。</p>\n<h4>2. <strong>动态关闭任务</strong></h4>\n<p>通过 <code>app.schedules</code> 获取任务实例：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 关闭指定任务</span>\napp.<span class="hljs-property">schedules</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;update_cache&#x27;</span>).<span class="hljs-title function_">disable</span>();\n</code></pre>\n<h4>3. <strong>日志记录</strong></h4>\n<p>使用 <code>ctx.logger</code> 记录执行情况：</p>\n<pre><code class="language-javascript">ctx.<span class="hljs-property">logger</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;任务执行异常，重试中...&#x27;</span>);\n</code></pre>\n<h4>4. <strong>错误处理</strong></h4>\n<p>任务抛出错误时会被捕获并记录到日志，不会导致进程退出。</p>\n<hr>\n<h3><strong>四、注意事项</strong></h3>\n<ol>\n<li><strong>多机部署</strong><br>\n默认情况下，所有机器的定时任务会同时执行。若需独占执行，需借助分布式锁（如 Redis）或使用 <code>type: \'worker\'</code> 随机分配。</li>\n<li><strong>长任务监控</strong><br>\n长时间运行的任务可能阻塞其他任务，建议：\n<ul>\n<li>拆分任务为小颗粒度。</li>\n<li>使用 <code>ctx.runInBackground</code> 异步执行。</li>\n</ul>\n</li>\n<li><strong>与 Egg.js 2.x 区别</strong>\n<ul>\n<li>Egg 3.x 延续了 2.x 的定时任务设计，API 完全兼容。</li>\n<li>推荐使用 <code>app.schedule</code> 替代低效的 <code>setInterval</code>。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>五、完整示例</strong></h3>\n<h4>场景：每天凌晨清理临时文件</h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/schedule/clean_tmp.js</span>\n<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs/promises&#x27;</span>);\n<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">schedule</span>: {\n    <span class="hljs-attr">cron</span>: <span class="hljs-string">&#x27;0 0 0 * * *&#x27;</span>, <span class="hljs-comment">// 每天 0 点执行</span>\n    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;all&#x27;</span>,         <span class="hljs-comment">// 所有 worker 同时清理</span>\n  },\n  <span class="hljs-keyword">async</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">ctx</span>) {\n    <span class="hljs-keyword">const</span> tmpDir = path.<span class="hljs-title function_">join</span>(app.<span class="hljs-property">baseDir</span>, <span class="hljs-string">&#x27;tmp&#x27;</span>);\n    <span class="hljs-keyword">try</span> {\n      <span class="hljs-keyword">await</span> fs.<span class="hljs-title function_">rm</span>(tmpDir, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> });\n      ctx.<span class="hljs-property">logger</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`已清理临时目录: <span class="hljs-subst">${tmpDir}</span>`</span>);\n    } <span class="hljs-keyword">catch</span> (err) {\n      ctx.<span class="hljs-property">logger</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;清理失败:&#x27;</span>, err);\n    }\n  },\n};\n</code></pre>\n<hr>\n<h3><strong>六、调试技巧</strong></h3>\n<ol>\n<li><strong>本地测试</strong><br>\n修改 <code>schedule.interval</code> 为短时间（如 <code>\'10s\'</code>），快速验证逻辑。</li>\n<li><strong>手动触发</strong><br>\n通过 <code>curl http://localhost:7001/__schedule?task=update_cache</code> 手动运行任务（需开启配置）。</li>\n<li><strong>日志查看</strong><br>\n执行日志默认输出到 <code>${appInfo.root}/logs/{appname}/egg-schedule.log</code>。</li>\n</ol>\n<hr>\n<p>通过合理使用定时任务，可以显著提升后台运维效率。建议结合业务需求选择 <code>interval</code> 或 <code>cron</code> 模式，并注意多机部署时的任务分配策略。</p>\n</div>'</script></body></html>