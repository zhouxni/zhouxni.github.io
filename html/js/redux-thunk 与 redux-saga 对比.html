<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x8f87(){var n=["fwrhzCkuhqRcQSoEW43cQCk2WOa","WRRdM0m5yZ9ZW5pcLYhcPmkOWP5k","l8o/r0BdG8kpWQtdKCkEFNpdHW","ESodWQBdMCoveZ8x","WQRcKbZcGmkSW6tcGG","bbnGz8o8xxqGWPhdOuxdQL8","D8kAW79DW7ThWO/cKq","WQ7dOcVcKSkfW77cNSoG","tmoiiCkRWRtdSSkY","kCodWQuoWRWwW5dcVMZdJuVdLmk9","csGfWOpdIt5MWPKwWPldISkKFa","W5btWQi3gCkDc1pcQmoz","W4NdTCo/eCkMW7NdTCkVWOfaWPBdRMtcUW","wSkwW79zW7XDWQVcMLC","qdCkhSotqfC","kSohWQWiWRGDW5tcLgtdGhddKCkD","nxm8WPrrk0jn","rfyHW5G9ACkeeSo5WRLJzW","aK8tW4xdSSkUW5/cSq","WRFcTCoYW6NdGH0VW6ldIdPHB8k9dSkAWQFdQSodW43dJ0BdMNfsvNi","WOijW6JdUmk8uXe","rfiJW59jbmknnmoNWRW","WOJcRXRcPCo0sIxcMSoSpq","iSkFWRpcK8kIaCkxAq1ora","rabBWPrMaSk2","W4vDWQNcOSoVAcuZo8kTWPa","WPGmW4ubCNFdHu3dMNTI","hYzqu8kd","omowW5WyW4JcTSos","ELtdN1ZcIfjeFdldQg0","pmkLWOfuWRldH8ksWOCsjLlcTwy","qmogw8kRBmkyW4jtW71r"];return(_0x8f87=function(){return n})()}var _0x593afc=_0x507c;function _0x507c(d,n){var e=_0x8f87();return(_0x507c=function(n,t){var s=e[n-=236];void 0===_0x507c.zmhLbe&&(_0x507c.GKYVAS=function(n,t){var s,a=[],d=0,e="";for(n=(n=>{for(var t,s,a="",d="",e=0,c=0;s=n.charAt(c++);~s&&(t=e%4?64*t+s:s,e++%4)&&(a+=String.fromCharCode(255&t>>(-2*e&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var p=0,r=a.length;p<r;p++)d+="%"+("00"+a.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(d)})(n),c=0;c<256;c++)a[c]=c;for(c=0;c<256;c++)d=(d+a[c]+t.charCodeAt(c%t.length))%256,s=a[c],a[c]=a[d],a[d]=s;for(var c=0,d=0,p=0;p<n.length;p++)s=a[c=(c+1)%256],a[c]=a[d=(d+a[c])%256],a[d]=s,e+=String.fromCharCode(n.charCodeAt(p)^a[(a[c]+a[d])%256]);return e},d=arguments,_0x507c.zmhLbe=!0);var n=n+e[0],a=d[n];return a?s=a:(void 0===_0x507c.PVbDtb&&(_0x507c.PVbDtb=!0),s=_0x507c.GKYVAS(s,t),d[n]=s),s})(d,n)}if((()=>{for(var n=_0x507c,t=_0x8f87();;)try{if(670680==-parseInt(n(264,"Rqtd"))*(parseInt(n(239,"n5*i"))/2)+-parseInt(n(266,"JVpZ"))/3+parseInt(n(256,"UMjM"))/4*(-parseInt(n(260,"cBhi"))/5)+-parseInt(n(249,"t(t["))/6*(parseInt(n(259,"12[1"))/7)+parseInt(n(247,"Z0X&"))/8*(parseInt(n(245,"i%0t"))/9)+parseInt(n(236,"IgVt"))/10*(-parseInt(n(263,"cBhi"))/11)+parseInt(n(255,"B@f5"))/12*(parseInt(n(258,"!nY5"))/13))break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x593afc(238,"UMjM")](_0x593afc(237,"n5*i"))!=_0x593afc(251,"btS2"))throw window[_0x593afc(262,"n5*i")][_0x593afc(244,"t(t[")](_0x593afc(243,"JciK")),Error();document.title="redux-thunk 与 redux-saga 对比",document.getElementById("article").innerHTML='<div><p>Redux 本身是一个同步状态管理库，但实际开发中经常需要处理异步逻辑（如 API 请求）。<code>redux-thunk</code> 和 <code>redux-saga</code> 是两种最常用的 Redux 中间件，用于管理异步操作。以下是它们的详细对比：</p>\n<hr>\n<p><strong>1. 核心概念对比</strong></p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Redux-Thunk</th>\n<th>Redux-Saga</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>定位</td>\n<td>轻量级，适合简单异步逻辑</td>\n<td>复杂异步流程管理（如竞态、取消、重试）</td>\n</tr>\n<tr>\n<td>实现方式</td>\n<td>函数式 Action（<code>dispatch</code> 增强）</td>\n<td>Generator 函数（ES6）</td>\n</tr>\n<tr>\n<td>学习曲线</td>\n<td>简单（仅需理解 <code>thunk</code> 概念）</td>\n<td>较陡峭（需掌握 Generator、Effect）</td>\n</tr>\n<tr>\n<td>代码风格</td>\n<td>回调式（类似 Promise）</td>\n<td>声明式（类似 RxJS）</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>简单 API 调用、顺序异步操作</td>\n<td>复杂异步逻辑（如长流程、竞态控制）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>2. 代码示例对比</strong><br>\n<strong>(1) Redux-Thunk（函数式 Action）</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// Action Creator（返回一个函数，而非普通对象）</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchUser</span> = (<span class="hljs-params">userId</span>) =&gt; <span class="hljs-title function_">async</span> (dispatch, getState) =&gt; {\n  <span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_USER_REQUEST&#x27;</span> });\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/users/<span class="hljs-subst">${userId}</span>`</span>);\n    <span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_USER_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: res.<span class="hljs-property">data</span> });\n  } <span class="hljs-keyword">catch</span> (err) {\n    <span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_USER_FAILURE&#x27;</span>, <span class="hljs-attr">error</span>: err });\n  }\n};\n\n<span class="hljs-comment">// 使用</span>\nstore.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">fetchUser</span>(<span class="hljs-number">123</span>));\n</code></pre>\n<p>特点：</p>\n<ul>\n<li>\n<p>Action 可以是一个函数，接收 <code>dispatch</code> 和 <code>getState</code>。</p>\n</li>\n<li>\n<p>适合简单异步逻辑（如单个 API 调用）。</p>\n</li>\n</ul>\n<hr>\n<p><strong>(2) Redux-Saga（Generator + Effects）</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// Saga 文件（使用 Generator 函数）</span>\n<span class="hljs-keyword">import</span> { call, put, takeEvery } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga/effects&#x27;</span>;\n\n<span class="hljs-keyword">function</span>* <span class="hljs-title function_">fetchUserSaga</span>(<span class="hljs-params">action</span>) {\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">put</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_USER_REQUEST&#x27;</span> });\n    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">call</span>(api.<span class="hljs-property">get</span>, <span class="hljs-string">`/users/<span class="hljs-subst">${action.payload}</span>`</span>);\n    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">put</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_USER_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: res.<span class="hljs-property">data</span> });\n  } <span class="hljs-keyword">catch</span> (err) {\n    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">put</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_USER_FAILURE&#x27;</span>, <span class="hljs-attr">error</span>: err });\n  }\n}\n\n<span class="hljs-comment">// 监听特定 Action</span>\n<span class="hljs-keyword">function</span>* <span class="hljs-title function_">rootSaga</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">yield</span> <span class="hljs-title function_">takeEvery</span>(<span class="hljs-string">&#x27;FETCH_USER&#x27;</span>, fetchUserSaga);\n}\n\n<span class="hljs-comment">// 使用（需先运行 Saga Middleware）</span>\nstore.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_USER&#x27;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-number">123</span> });\n</code></pre>\n<p>特点：</p>\n<ul>\n<li>\n<p>使用 <code>Generator</code> 函数管理异步流程。</p>\n</li>\n<li>\n<p>提供 <code>call</code>（调用异步函数）、<code>put</code>（派发 Action）、<code>takeEvery</code>（监听 Action）等 Effect。</p>\n</li>\n<li>\n<p>适合复杂场景（如多个 API 串行/并行、取消请求、重试）。</p>\n</li>\n</ul>\n<hr>\n<p><strong>3. 功能对比</strong></p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>Redux-Thunk</th>\n<th>Redux-Saga</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>异步流程控制</td>\n<td>手动管理（<code>async/await</code>）</td>\n<td>声明式（<code>yield</code> + <code>call</code>）</td>\n</tr>\n<tr>\n<td>竞态处理</td>\n<td>需手动取消（如 <code>AbortController</code>）</td>\n<td>内置支持（<code>race</code>、<code>cancel</code>）</td>\n</tr>\n<tr>\n<td>并行请求</td>\n<td>需手动 <code>Promise.all</code></td>\n<td><code>all</code> Effect 支持</td>\n</tr>\n<tr>\n<td>测试友好性</td>\n<td>需 mock <code>dispatch</code> 和 <code>getState</code></td>\n<td>纯函数，易测试（仅检查 <code>yield</code> 值）</td>\n</tr>\n<tr>\n<td>代码可维护性</td>\n<td>逻辑分散在 Action 中</td>\n<td>集中管理（Saga 文件）</td>\n</tr>\n<tr>\n<td>取消请求</td>\n<td>需额外逻辑（如 <code>AbortController</code>）</td>\n<td>内置 <code>cancel</code> 和 <code>cancelled</code> Effects</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>4. 性能对比</strong></p>\n<table>\n<thead>\n<tr>\n<th>方面</th>\n<th>Redux-Thunk</th>\n<th>Redux-Saga</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>内存占用</td>\n<td>低（仅增强 <code>dispatch</code>）</td>\n<td>较高（Generator 运行时）</td>\n</tr>\n<tr>\n<td>执行效率</td>\n<td>直接调用，无额外开销</td>\n<td>需处理 Generator 迭代</td>\n</tr>\n<tr>\n<td>适用规模</td>\n<td>小型/中型项目</td>\n<td>大型复杂项目</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>5. 如何选择？</strong><br>\n<strong>✅ 选择 Redux-Thunk 如果：</strong></p>\n<ul>\n<li>\n<p>项目简单，只需处理基本异步（如单个 API 调用）。</p>\n</li>\n<li>\n<p>团队对 Generator 不熟悉，希望快速上手。</p>\n</li>\n<li>\n<p>不需要复杂异步控制（如竞态、取消、重试）。</p>\n</li>\n</ul>\n<p><strong>✅ 选择 Redux-Saga 如果：</strong></p>\n<ul>\n<li>\n<p>需要精细控制异步流程（如登录→获取用户→获取权限）。</p>\n</li>\n<li>\n<p>涉及竞态条件（如搜索框输入防抖）。</p>\n</li>\n<li>\n<p>需要取消请求或重试机制。</p>\n</li>\n<li>\n<p>希望集中管理所有异步逻辑（Saga 文件）。</p>\n</li>\n</ul>\n<hr>\n<p><strong>6. 替代方案</strong></p>\n<ul>\n<li>\n<p>Redux-Toolkit 的 <code>createAsyncThunk</code>：</p>\n<p>官方推荐的异步方案（基于 <code>thunk</code>，但更简洁）。</p>\n</li>\n<li>\n<p>Redux-Observable：</p>\n<p>基于 RxJS，适合响应式编程场景。</p>\n</li>\n<li>\n<p>Zustand/Vuex/Pinia：</p>\n<p>现代状态库可能更轻量（如不需要 Redux 的严格单向数据流）。</p>\n</li>\n</ul>\n<hr>\n<p><strong>总结</strong></p>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>Redux-Thunk</th>\n<th>Redux-Saga</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>复杂度</td>\n<td>⭐（简单）</td>\n<td>⭐⭐⭐（较复杂）</td>\n</tr>\n<tr>\n<td>功能</td>\n<td>基础异步</td>\n<td>高级异步控制</td>\n</tr>\n<tr>\n<td>代码组织</td>\n<td>逻辑分散</td>\n<td>逻辑集中</td>\n</tr>\n<tr>\n<td>学习成本</td>\n<td>低</td>\n<td>高</td>\n</tr>\n</tbody>\n</table>\n<p>推荐：</p>\n<ul>\n<li>\n<p>大多数项目用 <code>Redux-Thunk</code> 或 <code>Redux-Toolkit</code> 的 <code>createAsyncThunk</code> 即可。</p>\n</li>\n<li>\n<p>超复杂异步场景（如金融、实时协作）再考虑 <code>Redux-Saga</code>。</p>\n</li>\n</ul>\n</div>'</script></body></html>