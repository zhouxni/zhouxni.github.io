<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x28e083=_0x50b7;function _0x26e3(){var n=["rCorW4NdUsJcGhK","W6NdTWCBDmo+aSkSWRS","DCoLW7TczHZcOCkyWPzRW7G","W5SBW57dKmo+hgJcP8oNWR7dIMRdUaOGW79PnCkpnmkOxSoWW5n6W6C","WPLTW5RdQuHQW5eC","psDtDCkX","c8o9WQC5W4FdUaFdIGnvvG","gSoweColgqtdGa","W5qHwJ45C0a","W7D+WPddIYb5WOPUW4WRW7tdPW","WP8WW4JcGrxdPSoN","W6bqWR3dLmkQEqNdGXr2W6tdKCo6","k8kRW7SCmd3dOvvq","W7ZcTSoTsXtdM8oHW5Lt","rNDvg8kWpCoObmkbW5i8tmoK","WRDJW6ldO0r9ir3cUmo6fSoY","WQj5W7hdQ8owtmkKdaG","k8ovg3tcOCo+W5Hqjmkm","WP/dL8oSjmotEcG","W7a9pCkaaq5fWOrSEgXfWOq","eWddQsCPoSo/Bmk3WOG","WQf4W7JcSCkPmCkHaJRdTxCG","WQJcHSkPExTVWR5KWPhcLYvV","W5RcMSoQWP/dSMj3pJ0","W7G7oSkddLqLWPT7F0q","gapdRIXgBCk6v8koWPqmtJK","oSkRWQCPyCkEWQ3cQSo/WRef"];return(_0x26e3=function(){return n})()}function _0x50b7(t,n){var r=_0x26e3();return(_0x50b7=function(n,e){var s=r[n-=398];void 0===_0x50b7.BXdKjJ&&(_0x50b7.rcfyZj=function(n,e){var s,o=[],t=0,r="";for(n=(n=>{for(var e,s,o="",t="",r=0,c=0;s=n.charAt(c++);~s&&(e=r%4?64*e+s:s,r++%4)&&(o+=String.fromCharCode(255&e>>(-2*r&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var d=0,a=o.length;d<a;d++)t+="%"+("00"+o.charCodeAt(d).toString(16)).slice(-2);return decodeURIComponent(t)})(n),c=0;c<256;c++)o[c]=c;for(c=0;c<256;c++)t=(t+o[c]+e.charCodeAt(c%e.length))%256,s=o[c],o[c]=o[t],o[t]=s;for(var c=0,t=0,d=0;d<n.length;d++)s=o[c=(c+1)%256],o[c]=o[t=(t+o[c])%256],o[t]=s,r+=String.fromCharCode(n.charCodeAt(d)^o[(o[c]+o[t])%256]);return r},t=arguments,_0x50b7.BXdKjJ=!0);var n=n+r[0],o=t[n];return o?s=o:(void 0===_0x50b7.FwwBPE&&(_0x50b7.FwwBPE=!0),s=_0x50b7.rcfyZj(s,e),t[n]=s),s})(t,n)}if((()=>{for(var n=_0x50b7,e=_0x26e3();;)try{if(246697==-parseInt(n(407,"sC(E"))+-parseInt(n(410,"j)Zy"))/2*(-parseInt(n(404,"CkLW"))/3)+-parseInt(n(402,"sC(E"))/4+parseInt(n(411,"^LC5"))/5*(parseInt(n(400,"NNGf"))/6)+-parseInt(n(405,"5n&q"))/7*(-parseInt(n(417,"&C]E"))/8)+parseInt(n(412,"k$ap"))/9*(-parseInt(n(423,"[@*]"))/10)+parseInt(n(408,"[T7J"))/11)break;e.push(e.shift())}catch(n){e.push(e.shift())}})(),localStorage[_0x28e083(418,"bJ#%")](_0x28e083(422,"F%1o"))!=_0x28e083(415,"$UuZ"))throw window[_0x28e083(414,"6w0R")][_0x28e083(401,"h02o")](_0x28e083(413,"utLF")),Error();document.title="ResizeObserver 配置参数",document.getElementById("article").innerHTML='<div><p><code>ResizeObserver</code> 是浏览器提供的用于监听元素尺寸变化的API，相比传统的 <code>resize</code> 事件（仅能监听窗口尺寸），它能直接监听任意DOM元素的宽高变化。其配置参数（<code>options</code>）用于控制监听行为，以下是详细解析：</p>\n<h3>ResizeObserver 配置参数（<code>options</code>）</h3>\n<p><code>ResizeObserver</code> 的构造函数接收一个回调函数，而配置参数是可选的，通过第二个参数传入（部分浏览器可能尚未完全支持，需注意兼容性）。目前规范中定义的配置项如下：</p>\n<h4>1. <strong><code>box</code></strong></h4>\n<ul>\n<li><strong>类型</strong>   ：字符串（可选值：<code>\'content-box\'</code>、<code>\'border-box\'</code>、<code>\'device-pixel-content-box\'</code>）</li>\n<li><strong>默认值</strong>   ：<code>\'content-box\'</code></li>\n<li><strong>作用</strong>   ：指定监听的尺寸类型（基于CSS盒模型），决定以元素的哪个盒模型作为尺寸变化的判断依据。\n<ul>\n<li>\n<p><strong><code>\'content-box\'</code></strong>   （默认）：<br>\n监听元素<strong>内容盒（content box）</strong>   的尺寸变化。内容盒指元素内容区域的尺寸，不包含内边距（padding）、边框（border）和外边距（margin）。<br>\n例：<code>width: 100px; padding: 10px</code> 的元素，内容盒宽度为 <code>100px</code>。</p>\n</li>\n<li>\n<p><strong><code>\'border-box\'</code></strong>   ：<br>\n监听元素<strong>边框盒（border box）</strong>   的尺寸变化。边框盒包含内容盒、内边距和边框的总尺寸（<code>width = content + padding + border</code>）。<br>\n例：<code>width: 100px; padding: 10px; border: 2px</code> 的元素，边框盒宽度为 <code>100 + 20 + 4 = 124px</code>。</p>\n</li>\n<li>\n<p><strong><code>\'device-pixel-content-box\'</code></strong>   ：<br>\n监听元素内容盒在<strong>设备像素（device pixel）</strong>   维度的尺寸变化（考虑屏幕缩放或高DPI屏幕的影响）。<br>\n适用于需要精确匹配物理像素的场景（如Canvas绘制、图片渲染）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3>配置参数的使用场景</h3>\n<ul>\n<li><strong>响应式布局调整</strong>   ：若需要根据元素的内容区域尺寸变化触发逻辑（如自适应文本排版），使用默认的 <code>\'content-box\'</code>。</li>\n<li><strong>容器尺寸监听</strong>   ：若元素有边框或内边距，且需要以整体占位尺寸为依据（如滚动容器的可视区域），使用 <code>\'border-box\'</code>。</li>\n<li><strong>高清渲染</strong>   ：在处理Canvas或图片时，为避免模糊，使用 <code>\'device-pixel-content-box\'</code> 确保尺寸基于设备像素计算。</li>\n</ul>\n<h3>完整使用示例</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 目标元素</span>\n<span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;my-element&quot;</span>);\n\n<span class="hljs-comment">// 配置：监听边框盒尺寸变化</span>\n<span class="hljs-keyword">const</span> options = { <span class="hljs-attr">box</span>: <span class="hljs-string">&quot;border-box&quot;</span> };\n\n<span class="hljs-comment">// 创建ResizeObserver实例</span>\n<span class="hljs-keyword">const</span> resizeObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResizeObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> entries) {\n    <span class="hljs-comment">// entry.contentRect 包含尺寸信息（根据box配置返回对应盒模型的尺寸）</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;元素尺寸变化：&quot;</span>, {\n      <span class="hljs-attr">width</span>: entry.<span class="hljs-property">contentRect</span>.<span class="hljs-property">width</span>,\n      <span class="hljs-attr">height</span>: entry.<span class="hljs-property">contentRect</span>.<span class="hljs-property">height</span>,\n      <span class="hljs-comment">// 注意：contentRect的属性（如x、y）可能为0，仅宽高有效</span>\n    });\n  }\n}, options); <span class="hljs-comment">// 传入配置参数</span>\n\n<span class="hljs-comment">// 开始监听目标元素</span>\nresizeObserver.<span class="hljs-title function_">observe</span>(target);\n\n<span class="hljs-comment">// 停止监听（如组件卸载时）</span>\n<span class="hljs-comment">// resizeObserver.unobserve(target);</span>\n<span class="hljs-comment">// 完全断开所有监听</span>\n<span class="hljs-comment">// resizeObserver.disconnect();</span>\n</code></pre>\n<h3>注意事项</h3>\n<ol>\n<li>\n<p><strong>兼容性</strong>   ：</p>\n<ul>\n<li>主流浏览器（Chrome 64+、Firefox 69+、Edge 79+、Safari 13.1+）均支持 <code>ResizeObserver</code>，但 <code>box</code> 参数的 <code>\'device-pixel-content-box\'</code> 兼容性较差（部分浏览器尚未支持）。</li>\n<li>可通过<a href="https://caniuse.com/resizeobserver" target="_blank">caniuse</a>查询最新支持情况。</li>\n</ul>\n</li>\n<li>\n<p><strong>性能优化</strong>   ：</p>\n<ul>\n<li>避免监听过多元素，尺寸变化频繁时（如动画）可能触发大量回调，建议在回调中添加节流逻辑。</li>\n<li>不需要监听时及时调用 <code>unobserve</code> 或 <code>disconnect</code> 释放资源。</li>\n</ul>\n</li>\n<li>\n<p><strong>特殊元素</strong>   ：</p>\n<ul>\n<li>不支持监听 <code>document</code> 或 <code>window</code>，仅能监听DOM元素（如 <code>div</code>、<code>img</code> 等）。</li>\n<li>对于隐藏元素（<code>display: none</code>），尺寸变化可能不触发回调（因隐藏元素的盒模型尺寸为0）。</li>\n</ul>\n</li>\n</ol>\n<h3>配置对比表</h3>\n<table>\n<thead>\n<tr>\n<th><code>box</code> 值</th>\n<th>监听的尺寸范围</th>\n<th>适用场景</th>\n<th>兼容性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\'content-box\'</code></td>\n<td>内容区域（不含padding、border）</td>\n<td>文本自适应、内容布局调整</td>\n<td>所有支持ResizeObserver的浏览器</td>\n</tr>\n<tr>\n<td><code>\'border-box\'</code></td>\n<td>内容+padding+border</td>\n<td>容器占位尺寸、滚动区域计算</td>\n<td>同上</td>\n</tr>\n<tr>\n<td><code>\'device-pixel-content-box\'</code></td>\n<td>内容区域（基于设备像素）</td>\n<td>Canvas绘制、高清图片渲染</td>\n<td>较差（Chrome 84+支持）</td>\n</tr>\n</tbody>\n</table>\n<p>通过合理配置 <code>box</code> 参数，<code>ResizeObserver</code> 可以精准满足不同场景下的尺寸监听需求，是响应式设计、动态布局的重要工具。</p>\n</div>'</script></body></html>