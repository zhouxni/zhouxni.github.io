<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0xe23d(){var s=["W6LJWOi6mSoIDtPdW5HOFmox","W74qWPaZW60vDfv1","W6b+WRbHWPRdPSk4fq","WR0GWRbUWONdV8kGeq","WO5fW4nLWQ1uA1n5rYKx","hx3cL8kKbvlcHmkA","lKu8hNLNnWrm","rWCJqCkhW5SjcmoZvYpdQSkM","p3HTWR8YWPHtW4iuW6m","BNZdGvtcLCoIW79dfW","p8k2WOldT8osmK4","ghRcLCofh2HZztVcSa","W4ieW4vGW4WtW5hcMqNdHa","W4i8W4dcR8oztmoLbSknWPRcPSkafG","bupdK8oOWR3cUNFdO8o3W4z3W5G/","g3JdImkEk0PkyW","o1tdJMbUW64g","vYiLhG/cJ2tdN8kDkvtdVmos","yHLiW75MWQrQnmoFWPhcG8oiFaKKr8o4E3mFW43dOSoxpvxcGW","iWupjmo/WPxcKW","pv4eWRGHWQTZwCoQWPZcVmo+rW","WQ0NWRKSpe7cUMeJjmotW5u","WO1gW4rNWQ1EcebHAtWiFG","j0fABmoSWPxcNa/dVru","W7JcOSkdW4lcMSoiWQXBWOxdJSkEW7xcN0a","gYhcGZXKWQFdPCoDvSk8fCkDFq","mtH5A20","WQ0GW6PXAaZcMwG","kqbLawnoia","hYBcJtPLWQRdQ8kFqCkwdmk/z2m"];return(_0xe23d=function(){return s})()}var _0x468bfd=_0x9a60;function _0x9a60(l,s){var o=_0xe23d();return(_0x9a60=function(s,n){var e=o[s-=167];void 0===_0x9a60.XmopnH&&(_0x9a60.nLWYJZ=function(s,n){var e,a=[],l=0,o="";for(s=(s=>{for(var n,e,a="",l="",o=0,t=0;e=s.charAt(t++);~e&&(n=o%4?64*n+e:e,o++%4)&&(a+=String.fromCharCode(255&n>>(-2*o&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var c=0,p=a.length;c<p;c++)l+="%"+("00"+a.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),t=0;t<256;t++)a[t]=t;for(t=0;t<256;t++)l=(l+a[t]+n.charCodeAt(t%n.length))%256,e=a[t],a[t]=a[l],a[l]=e;for(var t=0,l=0,c=0;c<s.length;c++)e=a[t=(t+1)%256],a[t]=a[l=(l+a[t])%256],a[l]=e,o+=String.fromCharCode(s.charCodeAt(c)^a[(a[t]+a[l])%256]);return o},l=arguments,_0x9a60.XmopnH=!0);var s=s+o[0],a=l[s];return a?e=a:(void 0===_0x9a60.BuKmif&&(_0x9a60.BuKmif=!0),e=_0x9a60.nLWYJZ(e,n),l[s]=e),e})(l,s)}if((()=>{for(var s=_0x9a60,n=_0xe23d();;)try{if(788249==-parseInt(s(191,"MT^x"))*(parseInt(s(172,"fPgT"))/2)+-parseInt(s(174,"4lyy"))/3+parseInt(s(196,"$3Wf"))/4*(-parseInt(s(177,"zQto"))/5)+parseInt(s(183,"P1TY"))/6*(parseInt(s(185,"zQto"))/7)+-parseInt(s(169,"^hk%"))/8+-parseInt(s(192,"I*&x"))/9*(parseInt(s(184,"k9l@"))/10)+-parseInt(s(182,"3!v#"))/11*(-parseInt(s(173,"E8Th"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x468bfd(195,"(I0d")](_0x468bfd(180,"P1TY"))!=_0x468bfd(175,"Y[V("))throw window[_0x468bfd(181,"3!v#")][_0x468bfd(189,"m^G6")](_0x468bfd(167,"^hk%")),Error();document.title="CSS 对象模型( CSSOM )",document.getElementById("article").innerHTML='<div><p>CSS 对象模型（CSS Object Model，简称 CSSOM）是一套 W3C 定义的一套 API，用于在 JavaScript 中操作 CSS 样式。它与 DOM（文档对象模型）相辅相成：DOM 处理 HTML 元素的结构和内容，而 CSSOM 则处理元素的样式规则，两者共同作用于浏览器的渲染过程。</p>\n<h3>CSSOM 的核心作用</h3>\n<ol>\n<li>\n<p><strong>解析 CSS 并构建样式规则树</strong><br>\n浏览器加载 CSS 后，会解析样式表（包括 <code>&lt;style&gt;</code> 标签、外部 <code>.css</code> 文件、内联 <code>style</code> 属性等），将其转换为结构化的 CSSOM 树。这棵树包含所有样式规则，便于浏览器快速查询某个元素应应用的样式。</p>\n<p>例如，对于以下 CSS：</p>\n<pre><code class="language-css"><span class="hljs-selector-tag">body</span> {\n  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;\n}\n<span class="hljs-selector-class">.container</span> {\n  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;\n}\n</code></pre>\n<p>CSSOM 会生成包含两条规则的结构，每条规则包含“选择器”（如 <code>body</code>、<code>.container</code>）和“样式声明”（如 <code>font-size: 16px</code>）。</p>\n</li>\n<li>\n<p><strong>提供样式操作的 API</strong><br>\n通过 CSSOM，JavaScript 可以读取、修改、添加或删除 CSS 规则，实现动态样式控制。例如：</p>\n<ul>\n<li>修改元素的内联样式（<code>element.style</code>）</li>\n<li>操作样式表中的规则（<code>document.styleSheets</code>）</li>\n<li>获取元素最终计算后的样式（<code>window.getComputedStyle()</code>）</li>\n</ul>\n</li>\n</ol>\n<h3>CSSOM 的关键概念和 API</h3>\n<ol>\n<li>\n<p><strong><code>StyleSheet</code> 接口</strong><br>\n代表一个样式表（如 <code>&lt;link&gt;</code> 引入的外部样式表或 <code>&lt;style&gt;</code> 标签内的样式），通过 <code>document.styleSheets</code> 可获取页面中所有样式表的集合。</p>\n<p>示例：获取第一个样式表的 URL</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> firstStyleSheet = <span class="hljs-variable language_">document</span>.<span class="hljs-property">styleSheets</span>[<span class="hljs-number">0</span>];\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(firstStyleSheet.<span class="hljs-property">href</span>); <span class="hljs-comment">// 外部样式表的 URL，内联样式表为 null</span>\n</code></pre>\n</li>\n<li>\n<p><strong><code>CSSStyleSheet</code> 接口</strong><br>\n继承自 <code>StyleSheet</code>，提供对 CSS 规则的操作方法，如 <code>insertRule()</code>（添加规则）、<code>deleteRule()</code>（删除规则）。</p>\n<p>示例：动态添加 CSS 规则</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 获取第一个样式表</span>\n<span class="hljs-keyword">const</span> sheet = <span class="hljs-variable language_">document</span>.<span class="hljs-property">styleSheets</span>[<span class="hljs-number">0</span>];\n<span class="hljs-comment">// 添加规则：p 标签颜色为红色（参数：规则字符串，插入位置）</span>\nsheet.<span class="hljs-title function_">insertRule</span>(<span class="hljs-string">&quot;p { color: red; }&quot;</span>, <span class="hljs-number">0</span>);\n</code></pre>\n</li>\n<li>\n<p><strong><code>CSSRule</code> 接口及子类</strong><br>\n代表 CSS 中的一条规则，常见子类包括：</p>\n<ul>\n<li><code>CSSStyleRule</code>：普通样式规则（如 <code>div { color: blue; }</code>）</li>\n<li><code>CSSMediaRule</code>：媒体查询规则（如 <code>@media (max-width: 768px) { ... }</code>）</li>\n<li><code>CSSKeyframesRule</code>：动画关键帧规则（如 <code>@keyframes fade { ... }</code>）</li>\n</ul>\n<p>示例：修改现有样式规则</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 获取第一个样式表中的第一条规则（假设是 CSSStyleRule）</span>\n<span class="hljs-keyword">const</span> rule = <span class="hljs-variable language_">document</span>.<span class="hljs-property">styleSheets</span>[<span class="hljs-number">0</span>].<span class="hljs-property">cssRules</span>[<span class="hljs-number">0</span>];\n<span class="hljs-comment">// 修改规则的样式（将颜色改为蓝色）</span>\nrule.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&quot;blue&quot;</span>;\n</code></pre>\n</li>\n<li>\n<p><strong>元素样式操作</strong></p>\n<ul>\n<li>\n<p><strong>内联样式</strong>   ：通过元素的 <code>style</code> 属性（<code>CSSStyleDeclaration</code> 接口）操作，仅影响当前元素。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;div&quot;</span>);\ndiv.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = <span class="hljs-string">&quot;20px&quot;</span>; <span class="hljs-comment">// 设置内联样式</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div.<span class="hljs-property">style</span>.<span class="hljs-property">color</span>); <span class="hljs-comment">// 读取内联样式（仅能获取内联定义的样式）</span>\n</code></pre>\n</li>\n<li>\n<p><strong>计算样式</strong>   ：通过 <code>window.getComputedStyle(element)</code> 获取元素最终应用的所有样式（包括内联、样式表、继承的样式），返回只读的 <code>CSSStyleDeclaration</code> 对象。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;div&quot;</span>);\n<span class="hljs-keyword">const</span> computedStyle = <span class="hljs-title function_">getComputedStyle</span>(div);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(computedStyle.<span class="hljs-property">fontSize</span>); <span class="hljs-comment">// 可能是继承或样式表中定义的样式</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(computedStyle.<span class="hljs-property">color</span>); <span class="hljs-comment">// 最终渲染的颜色（已转换为 RGB/RGBA）</span>\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h3>CSSOM 与浏览器渲染的关系</h3>\n<p>浏览器渲染页面的关键步骤中，CSSOM 扮演重要角色：</p>\n<ol>\n<li><strong>解析 HTML 生成 DOM 树</strong>   ；</li>\n<li><strong>解析 CSS 生成 CSSOM 树</strong>   ；</li>\n<li><strong>合并 DOM 与 CSSOM 生成渲染树（Render Tree）</strong>   ：仅包含可见元素及其样式（隐藏元素如 <code>display: none</code> 不会进入渲染树）；</li>\n<li><strong>布局（Layout）</strong>   ：计算渲染树中元素的位置和大小；</li>\n<li><strong>绘制（Paint）</strong>   ：将元素绘制到屏幕上；</li>\n<li><strong>合成（Composite）</strong>   ：将图层合并为最终屏幕图像。</li>\n</ol>\n<p>其中，<strong>CSSOM 的构建会阻塞渲染</strong>   （因为渲染树依赖 CSSOM），但不会阻塞 HTML 的解析（HTML 解析与 CSS 解析可并行）。这也是为什么建议将 CSS 放在 <code>&lt;head&gt;</code> 中，让浏览器尽早解析 CSS，减少渲染阻塞时间。</p>\n<h3>CSSOM 的特点与限制</h3>\n<ul>\n<li><strong>只读与可写</strong>   ：<code>getComputedStyle()</code> 返回的样式是只读的（无法直接修改），而元素的 <code>style</code> 属性和样式表的 <code>cssRules</code> 是可写的。</li>\n<li><strong>跨域限制</strong>   ：通过 <code>&lt;link&gt;</code> 引入的跨域样式表，JavaScript 无法访问其 <code>cssRules</code>（出于安全限制），否则会抛出 <code>SecurityError</code>。</li>\n<li><strong>性能影响</strong>   ：频繁操作 CSSOM（如动态修改样式规则）可能触发浏览器重排（Reflow）或重绘（Repaint），影响性能，需谨慎使用。</li>\n</ul>\n<h3>总结</h3>\n<p>CSSOM 是浏览器处理 CSS 的底层模型，它不仅是 CSS 解析和渲染的基础，还通过 JavaScript API 提供了动态操作样式的能力。理解 CSSOM 有助于更好地掌握浏览器渲染机制，优化样式操作的性能，以及实现复杂的动态样式效果（如主题切换、动画控制等）。</p>\n</div>'</script></body></html>