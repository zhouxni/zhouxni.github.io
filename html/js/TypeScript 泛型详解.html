<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x44928b=_0x4c10;function _0x4c10(t,s){var p=_0x4316();return(_0x4c10=function(s,a){var n=p[s-=137];void 0===_0x4c10.VRjntn&&(_0x4c10.uriwKc=function(s,a){var n,l=[],t=0,p="";for(s=(s=>{for(var a,n,l="",t="",p=0,e=0;n=s.charAt(e++);~n&&(a=p%4?64*a+n:n,p++%4)&&(l+=String.fromCharCode(255&a>>(-2*p&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,r=l.length;c<r;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+a.charCodeAt(e%a.length))%256,n=l[e],l[e]=l[t],l[t]=n;for(var e=0,t=0,c=0;c<s.length;c++)n=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=n,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[t])%256]);return p},t=arguments,_0x4c10.VRjntn=!0);var s=s+p[0],l=t[s];return l?n=l:(void 0===_0x4c10.KPQkFv&&(_0x4c10.KPQkFv=!0),n=_0x4c10.uriwKc(n,a),t[s]=n),n})(t,s)}function _0x4316(){var s=["wCoGd8ktWPmnu3/cO8ojWOK","p8kMWRxcGmkFW5HkqmoIW7y","W60vvexdVsid","W7flCHGvWRPKwCk5","m8kUWOf0iCoPW5vHW49rWRO","WR7dUmkUuCketbtcKfxcTa","W4FdGSoOW7pdMSkCW58fW7RcSCojaCot","W4iab8k+W5nvr1hcQ2S","sa4XDSo1WPSX","eCoYWRBdLCk/zCoH","gCkvW43cTCknDSoVrXvd","iSkNW7Pjkr7cQmotWPdcRSownYK","WOeykeruWQH2CSkxbeK","W5VcHSo9xmoZW5/cGZBdOmkjB8oqsq","smkmW645WOFcISkXWOFdQmkDEG","W7uFvmojWOP6W6flWOBcJmoKW7u","W6zZWRzzAwmZtWdcJW","d8oEWOxcICoxWOjOf8oVxfzsvSonW6ddRYuQtCk4WPldR8o/WQnQxa","WRTeeJVdNdCcWQhcM8kK","W6v2WRHsjXTzCIJcRCoNW7Ht","W6DdcMNdIqtcOG","W4hdJmkuWRRcJmoUWQWM","W6WGDGhcOgZcVY/dNw3dRmkB","W68KCqNdUXFcRatdKuW","bt1kdqFdK1u","W4ldOColzmo7vYj7","lfNdLbucDc3cS8kmW6CKWOLm","zKmtWOb4k8kuBCkZW4a","hSkea1ygBxVcN8kzua","WPZcUSkAmmodCIDDzK8","BGDcW4fBpSko","dxOFseNcGXfmxCoJW61/ia","AXtcNLrk","W6D3W4aBEw8Vta"];return(_0x4316=function(){return s})()}if((()=>{for(var s=_0x4c10,a=_0x4316();;)try{if(863670==-parseInt(s(150,"vO6e"))*(-parseInt(s(167,"052$"))/2)+-parseInt(s(141,"T3Ps"))/3*(-parseInt(s(163,"nf$("))/4)+-parseInt(s(160,"wY$("))/5*(parseInt(s(144,"22ct"))/6)+parseInt(s(146,"ENu&"))/7*(-parseInt(s(155,"O9jD"))/8)+parseInt(s(162,"tWAv"))/9*(parseInt(s(158,"GiK["))/10)+-parseInt(s(138,"XLEE"))/11*(-parseInt(s(153,"XLEE"))/12)+-parseInt(s(139,"CJBw"))/13*(parseInt(s(154,"O9jD"))/14))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x44928b(168,"vO6e")](_0x44928b(169,"22ct"))!=_0x44928b(164,"GiK["))throw window[_0x44928b(157,"jkSK")][_0x44928b(140,"8cQh")](_0x44928b(149,"lBe3")),Error();document.title="TypeScript 泛型详解",document.getElementById("article").innerHTML='<div><p>泛型是 TypeScript 中非常重要的特性，它允许我们创建可重用的组件，这些组件可以支持多种类型而不只是一个特定类型。</p>\n<h2>1. 泛型基础</h2>\n<h3>1.1 泛型函数</h3>\n<pre><code class="language-typescript"><span class="hljs-comment">// 普通函数只能返回特定类型</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">identity</span>(<span class="hljs-params"><span class="hljs-attr">arg</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {\n  <span class="hljs-keyword">return</span> arg;\n}\n\n<span class="hljs-comment">// 泛型函数可以适用于多种类型</span>\n<span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T {\n  <span class="hljs-keyword">return</span> arg;\n}\n\n<span class="hljs-comment">// 使用方式</span>\n<span class="hljs-keyword">let</span> output1 = identity&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;myString&quot;</span>); <span class="hljs-comment">// 显式指定类型</span>\n<span class="hljs-keyword">let</span> output2 = <span class="hljs-title function_">identity</span>(<span class="hljs-string">&quot;myString&quot;</span>); <span class="hljs-comment">// 类型推断</span>\n</code></pre>\n<h3>1.2 泛型接口</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">GenericIdentityFn</span>&lt;T&gt; {\n  (<span class="hljs-attr">arg</span>: T): T;\n}\n\n<span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T {\n  <span class="hljs-keyword">return</span> arg;\n}\n\n<span class="hljs-keyword">let</span> <span class="hljs-attr">myIdentity</span>: <span class="hljs-title class_">GenericIdentityFn</span>&lt;<span class="hljs-built_in">number</span>&gt; = identity;\n</code></pre>\n<h3>1.3 泛型类</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericNumber</span>&lt;T&gt; {\n  <span class="hljs-attr">zeroValue</span>: T;\n  <span class="hljs-attr">add</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">x</span>: T, <span class="hljs-attr">y</span>: T</span>) =&gt;</span> T;\n}\n\n<span class="hljs-keyword">let</span> myGenericNumber = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericNumber</span>&lt;<span class="hljs-built_in">number</span>&gt;();\nmyGenericNumber.<span class="hljs-property">zeroValue</span> = <span class="hljs-number">0</span>;\nmyGenericNumber.<span class="hljs-property">add</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) { <span class="hljs-keyword">return</span> x + y; };\n</code></pre>\n<h2>2. 泛型约束</h2>\n<h3>2.1 基本约束</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lengthwise</span> {\n  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-keyword">function</span> loggingIdentity&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Lengthwise</span>&gt;(<span class="hljs-attr">arg</span>: T): T {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>); <span class="hljs-comment">// 现在编译器知道arg有length属性</span>\n  <span class="hljs-keyword">return</span> arg;\n}\n</code></pre>\n<h3>2.2 在泛型约束中使用类型参数</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> getProperty&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt;(<span class="hljs-attr">obj</span>: T, <span class="hljs-attr">key</span>: K) {\n  <span class="hljs-keyword">return</span> obj[key];\n}\n\n<span class="hljs-keyword">let</span> x = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> };\n<span class="hljs-title function_">getProperty</span>(x, <span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// 正确</span>\n<span class="hljs-title function_">getProperty</span>(x, <span class="hljs-string">&quot;m&quot;</span>); <span class="hljs-comment">// 错误: m不是x的属性</span>\n</code></pre>\n<h3>2.3 使用类类型约束</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> create&lt;T&gt;(<span class="hljs-attr">c</span>: { <span class="hljs-title function_">new</span>(): T }): T {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">c</span>();\n}\n</code></pre>\n<h2>3. 高级泛型技术</h2>\n<h3>3.1 泛型默认类型</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Box</span>&lt;T = <span class="hljs-built_in">string</span>&gt; {\n  <span class="hljs-attr">value</span>: T;\n}\n\n<span class="hljs-keyword">let</span> <span class="hljs-attr">box1</span>: <span class="hljs-title class_">Box</span> = { <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;hello&quot;</span> }; <span class="hljs-comment">// T默认为string</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">box2</span>: <span class="hljs-title class_">Box</span>&lt;<span class="hljs-built_in">number</span>&gt; = { <span class="hljs-attr">value</span>: <span class="hljs-number">42</span> };\n</code></pre>\n<h3>3.2 条件类型</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">NonNullable</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span> ? <span class="hljs-built_in">never</span> : T;\n</code></pre>\n<h3>3.3 映射类型</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Readonly</span>&lt;T&gt; = {\n  <span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> keyof T]: T[P];\n};\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Partial</span>&lt;T&gt; = {\n  [P <span class="hljs-keyword">in</span> keyof T]?: T[P];\n};\n</code></pre>\n<h3>3.4 类型推断</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReturnType</span>&lt;T&gt; = T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; infer R ? R : <span class="hljs-built_in">any</span>;\n</code></pre>\n<h2>4. 实用泛型示例</h2>\n<h3>4.1 泛型函数示例</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> merge&lt;T, U&gt;(<span class="hljs-attr">obj1</span>: T, <span class="hljs-attr">obj2</span>: U): T &amp; U {\n  <span class="hljs-keyword">return</span> { ...obj1, ...obj2 };\n}\n\n<span class="hljs-keyword">const</span> merged = <span class="hljs-title function_">merge</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> }, { <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> });\n</code></pre>\n<h3>4.2 泛型接口示例</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Result</span>&lt;T&gt; {\n  <span class="hljs-attr">data</span>: T | <span class="hljs-literal">null</span>;\n  <span class="hljs-attr">error</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;\n}\n\n<span class="hljs-keyword">function</span> fetchData&lt;T&gt;(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Result</span>&lt;T&gt; {\n  <span class="hljs-comment">// 实现数据获取逻辑</span>\n}\n</code></pre>\n<h3>4.3 泛型类示例</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataStorage</span>&lt;T&gt; {\n  <span class="hljs-keyword">private</span> <span class="hljs-attr">data</span>: T[] = [];\n\n  <span class="hljs-title function_">addItem</span>(<span class="hljs-params"><span class="hljs-attr">item</span>: T</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">push</span>(item);\n  }\n\n  <span class="hljs-title function_">getItem</span>(<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>): T {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index];\n  }\n}\n\n<span class="hljs-keyword">const</span> textStorage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataStorage</span>&lt;<span class="hljs-built_in">string</span>&gt;();\ntextStorage.<span class="hljs-title function_">addItem</span>(<span class="hljs-string">&quot;Hello&quot;</span>);\n</code></pre>\n<h2>5. 常见问题与解决方案</h2>\n<h3>5.1 泛型与any的区别</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>泛型</th>\n<th>any</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>类型安全</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>类型推断</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>代码提示</td>\n<td>有</td>\n<td>无</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>需要类型安全的多类型支持</td>\n<td>不关心类型时</td>\n</tr>\n</tbody>\n</table>\n<h3>5.2 泛型约束的最佳实践</h3>\n<ol>\n<li><strong>尽量使用约束</strong>  ：避免使用过于宽泛的类型</li>\n<li><strong>合理命名类型参数</strong>  ：如 <code>T</code>, <code>K</code>, <code>V</code> 等约定俗成的名称</li>\n<li><strong>避免过度使用</strong>  ：不是所有情况都需要泛型</li>\n</ol>\n<h3>5.3 复杂泛型的调试技巧</h3>\n<pre><code class="language-typescript"><span class="hljs-comment">// 使用类型打印辅助工具</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Debug</span>&lt;T&gt; = { [K <span class="hljs-keyword">in</span> keyof T]: T[K] };\n\n<span class="hljs-comment">// 或者使用条件类型来查看中间类型</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Check</span>&lt;T&gt; = T <span class="hljs-title function_">extends</span> (infer U)[] ? U : T;\n</code></pre>\n<h2>6. 实际应用场景</h2>\n<h3>6.1 API响应处理</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApiResponse</span>&lt;T&gt; {\n  <span class="hljs-attr">success</span>: <span class="hljs-built_in">boolean</span>;\n  <span class="hljs-attr">data</span>?: T;\n  <span class="hljs-attr">error</span>?: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUser</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ApiResponse</span>&lt;<span class="hljs-title class_">User</span>&gt;&gt; {\n  <span class="hljs-comment">// 实现获取用户逻辑</span>\n}\n</code></pre>\n<h3>6.2 高阶组件</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> withLoading&lt;T&gt;(<span class="hljs-title class_">WrappedComponent</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">ComponentType</span>&lt;T&gt;) {\n  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">props</span>: T &amp; { isLoading: <span class="hljs-built_in">boolean</span> }</span>) =&gt;</span> (\n    props.<span class="hljs-property">isLoading</span> ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Spinner</span> /&gt;</span></span> : <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> {<span class="hljs-attr">...props</span>} /&gt;</span></span>\n  );\n}\n</code></pre>\n<h3>6.3 状态管理</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Store</span>&lt;T&gt; {\n  <span class="hljs-attr">state</span>: T;\n  <span class="hljs-attr">setState</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">newState</span>: <span class="hljs-title class_">Partial</span>&lt;T&gt;</span>) =&gt;</span> <span class="hljs-built_in">void</span>;\n}\n\n<span class="hljs-keyword">function</span> createStore&lt;T&gt;(<span class="hljs-attr">initialState</span>: T): <span class="hljs-title class_">Store</span>&lt;T&gt; {\n  <span class="hljs-comment">// 实现store创建逻辑</span>\n}\n</code></pre>\n<p>通过掌握泛型，你可以编写更灵活、更可重用的TypeScript代码，同时保持类型安全。泛型是TypeScript强大类型系统的核心特性之一，合理使用可以大大提高代码质量和开发效率。</p>\n</div>'</script></body></html>