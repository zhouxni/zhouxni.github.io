<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x34a6(){var s=["W5rOiYbnW6hcRfVdRNxcPCo6WRa","WOxcV8kCWOhdHmkGjtWDWPNcK8oVW7O","WP/dHmobWPW2pd40hCkVud1x","EmkoWReOtrGvWRtdHG","mr7cQmoYgsBcM8oeasf0WRqj","WQ9xW5FdQYO","E8kJWQVdK0JdQ8oQAf1hpr7cUmk+WOhdHdFdUSoHzexcHYy5cSo7","W6yuWP3cQgBcL8o1pmk7iatdIq","WOn8WOZdGSkiWO3dTSk1ySokWOZcIG","WPuJW5vlW6dcQqfjW6NcQcqZ","wmkwW4bWW6u5WOW","abi6WOVdLLKnqW","WP9JfH43W6u7umkgsbmrWO4","fmo4WP05qcNcQ8oEobXkW5a","n8ofWOhcNgZdHZlcICk3db8Q","pSkfW4ZdRvxdVCkC","mNdcK8k3yWbyb0/dGmkYCJi","BCouWONcLXJcQ8kAWQmXW6VdNCoO","AmovWONcNbdcRCkBWQapW4JdPSob"];return(_0x34a6=function(){return s})()}var _0x150473=_0x2b54;function _0x2b54(e,s){var p=_0x34a6();return(_0x2b54=function(s,n){var a=p[s-=257];void 0===_0x2b54.WDZMNJ&&(_0x2b54.reMqkE=function(s,n){var a,l=[],e=0,p="";for(s=(s=>{for(var n,a,l="",e="",p=0,t=0;a=s.charAt(t++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=l.length;c<o;c++)e+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)e=(e+l[t]+n.charCodeAt(t%n.length))%256,a=l[t],l[t]=l[e],l[e]=a;for(var t=0,e=0,c=0;c<s.length;c++)a=l[t=(t+1)%256],l[t]=l[e=(e+l[t])%256],l[e]=a,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[t]+l[e])%256]);return p},e=arguments,_0x2b54.WDZMNJ=!0);var s=s+p[0],l=e[s];return l?a=l:(void 0===_0x2b54.hzEwCM&&(_0x2b54.hzEwCM=!0),a=_0x2b54.reMqkE(a,n),e[s]=a),a})(e,s)}if((()=>{for(var s=_0x2b54,n=_0x34a6();;)try{if(198791==+parseInt(s(260,"cfna"))+parseInt(s(259,"aa&y"))/2+parseInt(s(268,"I206"))/3+-parseInt(s(258,"ERQ("))/4+parseInt(s(270,"co^x"))/5+parseInt(s(272,"LU2["))/6+-parseInt(s(267,"B7g]"))/7)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x150473(266,"I206")](_0x150473(273,"E#Qj"))!=_0x150473(275,"ERQ("))throw window[_0x150473(262,"(*G1")][_0x150473(261,"U]8v")](_0x150473(257,"])@A")),Error();document.title=" 如何使用 Fetch API 的 ReadableStream 处理流式文本消息",document.getElementById("article").innerHTML='<div><h4>核心概念</h4>\n<ol>\n<li><strong><code>ReadableStream</code></strong>   ：表示一个可读的二进制数据流，适用于处理大文件或持续产生的数据</li>\n<li><strong>流式文本</strong>   ：文本数据被分成多个小块（chunks）逐步传输和处理</li>\n<li><strong>Fetch API</strong>   ：现代浏览器提供的网络请求接口，其响应体（<code>response.body</code>）就是一个 <code>ReadableStream</code></li>\n</ol>\n<h4>完整实现方案</h4>\n<h5>1. 服务端设置（Node.js 示例）</h5>\n<pre><code class="language-javascript"><span class="hljs-comment">// Express 服务器示例</span>\n<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);\n<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();\n\napp.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/stream-text&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/plain; charset=utf-8&quot;</span>);\n\n  <span class="hljs-comment">// 模拟流式文本数据</span>\n  <span class="hljs-keyword">const</span> messages = [<span class="hljs-string">&quot;第一条消息\\n&quot;</span>, <span class="hljs-string">&quot;第二条消息\\n&quot;</span>, <span class="hljs-string">&quot;第三条消息\\n&quot;</span>];\n  <span class="hljs-comment">/*\n    const encoder = new TextEncoder(); // 浏览器或Node.js的util模块\n    const encodedMessages = messages.map(msg =&gt; encoder.encode(msg));\n    const stream = Readable.from(encodedMessages); // 传入Uint8Array\n   */</span>\n  <span class="hljs-comment">// 创建可读流</span>\n  <span class="hljs-keyword">const</span> { <span class="hljs-title class_">Readable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;stream&quot;</span>);\n  <span class="hljs-keyword">const</span> stream = <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>(messages);\n\n  <span class="hljs-comment">// 通过管道发送到响应</span>\n  stream.<span class="hljs-title function_">pipe</span>(res);\n  <span class="hljs-comment">/*\n  // 创建动态可读流\n  const stream = new Readable({\n    read() {} // 必须实现空read方法\n  });\n  \n  // 将流管道到响应\n  stream.pipe(res);\n  // 将消息推入流\n    stream.push(msg);\n  // 停止流\n    stream.destroy();\n  */</span>\n});\n\napp.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);\n</code></pre>\n<h5>2. 客户端处理（浏览器 JavaScript）</h5>\n<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchStreamingText</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;http://localhost:3000/stream-text&quot;</span>);\n\n  <span class="hljs-comment">// 验证响应是否有效</span>\n  <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span> || !response.<span class="hljs-property">body</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Network response was not ok&quot;</span>);\n  }\n\n  <span class="hljs-comment">// 获取流阅读器</span>\n  <span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();\n  <span class="hljs-keyword">const</span> decoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>(<span class="hljs-string">&quot;utf-8&quot;</span>);\n  <span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;&quot;</span>;\n\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n      <span class="hljs-keyword">const</span> { value, done } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();\n      <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">break</span>;\n\n      <span class="hljs-comment">// 流式解码文本（处理多字节字符）</span>\n      result += decoder.<span class="hljs-title function_">decode</span>(value, { <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span> });\n\n      <span class="hljs-comment">// 实时处理接收到的文本</span>\n      <span class="hljs-title function_">processChunk</span>(result);\n    }\n\n    <span class="hljs-comment">// 处理最后剩余的数据</span>\n    result += decoder.<span class="hljs-title function_">decode</span>();\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;完整内容:&quot;</span>, result);\n  } <span class="hljs-keyword">finally</span> {\n    reader.<span class="hljs-title function_">releaseLock</span>();\n  }\n}\n\n<span class="hljs-comment">// 处理文本块的函数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">processChunk</span>(<span class="hljs-params">chunk</span>) {\n  <span class="hljs-comment">// 示例：按行分割处理</span>\n  <span class="hljs-keyword">const</span> lines = chunk.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;\\n&quot;</span>);\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> line <span class="hljs-keyword">of</span> lines.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)) {\n    <span class="hljs-comment">// 最后一行可能不完整</span>\n    <span class="hljs-keyword">if</span> (line) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到新行:&quot;</span>, line);\n  }\n}\n\n<span class="hljs-comment">// 调用函数</span>\n<span class="hljs-title function_">fetchStreamingText</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);\n</code></pre>\n<h4>关键点解析</h4>\n<ol>\n<li>\n<p><strong>文本编码处理</strong>   ：</p>\n<ul>\n<li>使用 <code>TextDecoder</code> 将二进制数据转换为文本</li>\n<li><code>{ stream: true }</code> 参数确保多字节字符（如中文）正确处理</li>\n</ul>\n</li>\n<li>\n<p><strong>流式处理优势</strong>   ：</p>\n<ul>\n<li>内存效率：不需要等待完整内容下载</li>\n<li>实时性：收到数据立即处理</li>\n</ul>\n</li>\n<li>\n<p><strong>消息边界处理</strong>   ：</p>\n<ul>\n<li>使用特定分隔符（如换行符 <code>\\n</code>）区分消息</li>\n<li>示例中的 <code>processChunk</code> 函数演示了按行处理</li>\n</ul>\n</li>\n</ol>\n<h4>实际应用场景</h4>\n<ol>\n<li>\n<p><strong>实时日志监控</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在网页中实时显示服务器日志</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">processChunk</span>(<span class="hljs-params">chunk</span>) {\n  <span class="hljs-keyword">const</span> logElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;logs&quot;</span>);\n  logElement.<span class="hljs-property">textContent</span> += chunk;\n  logElement.<span class="hljs-property">scrollTop</span> = logElement.<span class="hljs-property">scrollHeight</span>;\n}\n</code></pre>\n</li>\n<li>\n<p><strong>大文件处理</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 流式处理大型文本文件</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">processLargeFile</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;large-file.txt&quot;</span>);\n  <span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();\n  <span class="hljs-keyword">let</span> lineBuffer = <span class="hljs-string">&quot;&quot;</span>;\n\n  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n    <span class="hljs-keyword">const</span> { value, done } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();\n    <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">break</span>;\n\n    lineBuffer += decoder.<span class="hljs-title function_">decode</span>(value, { <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span> });\n    <span class="hljs-keyword">const</span> lines = lineBuffer.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;\\n&quot;</span>);\n    lineBuffer = lines.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 保存不完整的最后一行</span>\n\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> line <span class="hljs-keyword">of</span> lines) {\n      <span class="hljs-comment">// 处理每一行数据</span>\n    }\n  }\n}\n</code></pre>\n</li>\n</ol>\n<h4>注意事项</h4>\n<ol>\n<li>\n<p><strong>错误处理</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">try</span> {\n  <span class="hljs-comment">// 流处理代码</span>\n} <span class="hljs-keyword">catch</span> (error) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;流处理出错:&quot;</span>, error);\n} <span class="hljs-keyword">finally</span> {\n  reader.<span class="hljs-title function_">releaseLock</span>();\n}\n</code></pre>\n</li>\n<li>\n<p><strong>性能优化</strong>   ：</p>\n<ul>\n<li>避免过于频繁的 DOM 操作（可积累一定量数据再更新）</li>\n<li>考虑使用 <code>setTimeout</code> 或 <code>requestAnimationFrame</code> 节流更新</li>\n</ul>\n</li>\n<li>\n<p><strong>浏览器兼容性</strong>   ：</p>\n<ul>\n<li>所有现代浏览器支持（Chrome、Firefox、Edge、Safari）</li>\n<li>不支持 IE（需要使用 polyfill）</li>\n</ul>\n</li>\n</ol>\n<h4>高级用法</h4>\n<ol>\n<li>\n<p><strong>取消请求</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();\n<span class="hljs-title function_">fetch</span>(url, { <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span> });\n\n<span class="hljs-comment">// 需要取消时</span>\ncontroller.<span class="hljs-title function_">abort</span>();\n</code></pre>\n</li>\n<li>\n<p><strong>进度监控</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> receivedLength = <span class="hljs-number">0</span>;\n<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n  <span class="hljs-keyword">const</span> { value, done } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();\n  <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">break</span>;\n  receivedLength += value.<span class="hljs-property">length</span>;\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`已接收: <span class="hljs-subst">${receivedLength}</span> bytes`</span>);\n}\n</code></pre>\n</li>\n</ol>\n<p>这种流式文本处理方式特别适合：</p>\n<ul>\n<li>实时聊天应用</li>\n<li>日志监控系统</li>\n<li>大文件预览/处理</li>\n<li>长时间运行的数据传输</li>\n</ul>\n<p>通过合理使用 <code>ReadableStream</code>，可以显著提升应用的性能和用户体验。</p>\n</div>'</script></body></html>