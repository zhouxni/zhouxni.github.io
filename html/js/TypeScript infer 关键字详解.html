<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x43b0(){var s=["WOtcM8oIcMDNW5BdLq","W7aXFmomW75mWQFcPhe2ma","WQRdSmkdWQRcLHfEFY7dKmkfW5W","qH9oWQ51WPVcQhP7WPq+","WQBdSCkaWQBcMuTQvI3dRmkE","WQfuDCkmnXxcPNJdI8oxda","WQDPWO7cMSkOW5rTu2FdQ8ksW5HtBIZcPI7dICobW7ucW4xdHSoDBSkJ","CSo9WQ3cJXldQCkOfqjWW6Xp","W6dcPmokWRLDqSkm","W64lDmobqSoMfSkuWR53aSkn","WRfGAcBcLmoMh2u","W7NdHH3cIbquCci","W5ZdNCo6WOj7WPicW6ZcJSoPWRpcLLu","W6SlD8ofrCoLcSktWRDkoSkc","vmkdWPBdGCodWQ9EW7VdKb5Y","WR7cLCojW6hcHCodCCkZkCo1W7NdGq","WPruw8odhspcIa","W6WmC8ocq8oLl8kYWPDwo8ks","W6mxmCoiFa","WQhcU0xcVSo8DmkAaa","qmouWRjhWRy2wK4u","WQlcThpcLCkIW7PiWO5rw8kDWOzW","qXSdW78kWRRcPLm","WOVcUmoIWRv4WQvGamkfm3y"];return(_0x43b0=function(){return s})()}var _0x5350a8=_0x5e40;function _0x5e40(p,s){var t=_0x43b0();return(_0x5e40=function(s,a){var n=t[s-=478];void 0===_0x5e40.cxNKBv&&(_0x5e40.UuQOzS=function(s,a){var n,l=[],p=0,t="";for(s=(s=>{for(var a,n,l="",p="",t=0,e=0;n=s.charAt(e++);~n&&(a=t%4?64*a+n:n,t++%4)&&(l+=String.fromCharCode(255&a>>(-2*t&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,r=l.length;c<r;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+a.charCodeAt(e%a.length))%256,n=l[e],l[e]=l[p],l[p]=n;for(var e=0,p=0,c=0;c<s.length;c++)n=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=n,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[p])%256]);return t},p=arguments,_0x5e40.cxNKBv=!0);var s=s+t[0],l=p[s];return l?n=l:(void 0===_0x5e40.VOTddH&&(_0x5e40.VOTddH=!0),n=_0x5e40.UuQOzS(n,a),p[s]=n),n})(p,s)}if((()=>{for(var s=_0x5e40,a=_0x43b0();;)try{if(201395==-parseInt(s(484,"@cQQ"))+-parseInt(s(485,"b0!I"))/2+parseInt(s(492,"j75U"))/3+-parseInt(s(496,"j75U"))/4+parseInt(s(495,"PlH0"))/5+parseInt(s(488,"yt@7"))/6*(parseInt(s(481,"gFIb"))/7)+-parseInt(s(493,"fJXa"))/8*(parseInt(s(482,"TXPp"))/9))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x5350a8(499,"w0n5")](_0x5350a8(479,"i()u"))!=_0x5350a8(501,"yt@7"))throw window[_0x5350a8(478,"wajN")][_0x5350a8(491,"Fgd5")](_0x5350a8(489,"ti1K")),Error();document.title="TypeScript infer 关键字详解",document.getElementById("article").innerHTML='<div><p><code>infer</code> 是 TypeScript 中一个强大的类型推断关键字，主要用于<strong>条件类型</strong>  中，可以从复杂类型中提取和推断出子类型。它是 TypeScript 类型系统的高级特性，能够实现更灵活的类型操作。</p>\n<h2>1. 基本概念</h2>\n<h3>1.1 <code>infer</code> 的作用</h3>\n<p><code>infer</code> 允许我们在条件类型中声明一个<strong>类型变量</strong>  ，TypeScript 会根据上下文自动推断这个变量的具体类型。</p>\n<h3>1.2 基本语法</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">InferExample</span>&lt;T&gt; = T <span class="hljs-title function_">extends</span> (infer U)[] ? U : T;\n<span class="hljs-comment">// 如果 T 是数组类型，则提取元素类型 U，否则返回 T 本身</span>\n</code></pre>\n<h2>2. 常见使用场景</h2>\n<h3>2.1 提取函数返回类型</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReturnType</span>&lt;T&gt; = T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; infer R ? R : <span class="hljs-built_in">never</span>;\n\n<span class="hljs-comment">// 示例</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>; }\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">FooReturn</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> foo&gt;; <span class="hljs-comment">// number</span>\n</code></pre>\n<h3>2.2 提取函数参数类型</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Parameters</span>&lt;T&gt; = T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: infer P) =&gt; <span class="hljs-built_in">any</span> ? P : <span class="hljs-built_in">never</span>;\n\n<span class="hljs-comment">// 示例</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span></span>) {}\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">BarParams</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-keyword">typeof</span> bar&gt;; <span class="hljs-comment">// [string, number]</span>\n</code></pre>\n<h3>2.3 提取数组元素类型</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ElementType</span>&lt;T&gt; = T <span class="hljs-title function_">extends</span> (infer U)[] ? U : T;\n\n<span class="hljs-comment">// 示例</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">NumArray</span> = <span class="hljs-built_in">number</span>[];\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Num</span> = <span class="hljs-title class_">ElementType</span>&lt;<span class="hljs-title class_">NumArray</span>&gt;; <span class="hljs-comment">// number</span>\n</code></pre>\n<h3>2.4 提取 Promise 的解析类型</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">UnpackPromise</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Promise</span>&lt;infer U&gt; ? U : T;\n\n<span class="hljs-comment">// 示例</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">PromiseString</span> = <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;;\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Resolved</span> = <span class="hljs-title class_">UnpackPromise</span>&lt;<span class="hljs-title class_">PromiseString</span>&gt;; <span class="hljs-comment">// string</span>\n</code></pre>\n<h2>3. 高级用法</h2>\n<h3>3.1 多个 <code>infer</code> 同时使用</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">FirstArg</span>&lt;T&gt; = T <span class="hljs-title function_">extends</span> (<span class="hljs-attr">arg1</span>: infer A, ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span> ? A : <span class="hljs-built_in">never</span>;\n\n<span class="hljs-comment">// 示例</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">boolean</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">string</span></span>) {}\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">BazFirstArg</span> = <span class="hljs-title class_">FirstArg</span>&lt;<span class="hljs-keyword">typeof</span> baz&gt;; <span class="hljs-comment">// boolean</span>\n</code></pre>\n<h3>3.2 递归类型推断</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">DeepUnpack</span>&lt;T&gt; = \n  T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Promise</span>&lt;infer U&gt; ? <span class="hljs-title class_">DeepUnpack</span>&lt;U&gt; :\n  T <span class="hljs-title function_">extends</span> (infer U)[] ? <span class="hljs-title class_">DeepUnpack</span>&lt;U&gt; :\n  T;\n\n<span class="hljs-comment">// 示例</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">DeepPromise</span> = <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;;\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">DeepString</span> = <span class="hljs-title class_">DeepUnpack</span>&lt;<span class="hljs-title class_">DeepPromise</span>&gt;; <span class="hljs-comment">// string</span>\n</code></pre>\n<h3>3.3 联合类型推断</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">UnionFromTuple</span>&lt;T&gt; = T <span class="hljs-title function_">extends</span> (infer U)[] ? U : <span class="hljs-built_in">never</span>;\n\n<span class="hljs-comment">// 示例</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Tuple</span> = [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>];\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Union</span> = <span class="hljs-title class_">UnionFromTuple</span>&lt;<span class="hljs-title class_">Tuple</span>&gt;; <span class="hljs-comment">// string | number | boolean</span>\n</code></pre>\n<h2>4. 实用工具类型实现</h2>\n<h3>4.1 提取构造函数参数</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ConstructorParameters</span>&lt;T&gt; = \n  T <span class="hljs-keyword">extends</span> <span class="hljs-title function_">new</span> (...<span class="hljs-attr">args</span>: infer P) =&gt; <span class="hljs-built_in">any</span> ? P : <span class="hljs-built_in">never</span>;\n\n<span class="hljs-comment">// 示例</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) {}\n}\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">PersonParams</span> = <span class="hljs-title class_">ConstructorParameters</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Person</span>&gt;; <span class="hljs-comment">// [string, number]</span>\n</code></pre>\n<h3>4.2 提取实例类型</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">InstanceType</span>&lt;T&gt; = \n  T <span class="hljs-keyword">extends</span> <span class="hljs-title function_">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; infer R ? R : <span class="hljs-built_in">any</span>;\n\n<span class="hljs-comment">// 示例</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">PersonInstance</span> = <span class="hljs-title class_">InstanceType</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Person</span>&gt;; <span class="hljs-comment">// Person</span>\n</code></pre>\n<h3>4.3 提取对象属性类型</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PropType</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = \n  T <span class="hljs-keyword">extends</span> { [P <span class="hljs-keyword">in</span> K]: infer U } ? U : <span class="hljs-built_in">never</span>;\n\n<span class="hljs-comment">// 示例</span>\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {\n  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n}\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">UserName</span> = <span class="hljs-title class_">PropType</span>&lt;<span class="hljs-title class_">User</span>, <span class="hljs-string">&#x27;name&#x27;</span>&gt;; <span class="hljs-comment">// string</span>\n</code></pre>\n<h2>5. 注意事项</h2>\n<ol>\n<li><strong><code>infer</code> 只能在条件类型的 <code>extends</code> 子句中使用</strong></li>\n<li><strong>同一个类型变量不能在多个位置使用</strong>  ：<pre><code class="language-typescript"><span class="hljs-comment">// 错误示例</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">ErrorExample</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> { <span class="hljs-attr">a</span>: infer U, <span class="hljs-attr">b</span>: infer U } ? U : <span class="hljs-built_in">never</span>;\n</code></pre>\n</li>\n<li><strong><code>infer</code> 声明的类型变量只在条件类型的 true 分支中可用</strong></li>\n<li><strong>优先使用内置工具类型</strong>  （如 <code>ReturnType</code>, <code>Parameters</code> 等），它们已经经过充分测试</li>\n</ol>\n<h2>6. 实际应用示例</h2>\n<h3>6.1 React 组件 Props 类型提取</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ComponentProps</span>&lt;T&gt; = \n  T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">ComponentType</span>&lt;infer P&gt; ? P : <span class="hljs-built_in">never</span>;\n\n<span class="hljs-comment">// 示例</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"><span class="hljs-attr">props</span>: { title: <span class="hljs-built_in">string</span> }</span>) { <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; }\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">MyProps</span> = <span class="hljs-title class_">ComponentProps</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">MyComponent</span>&gt;; <span class="hljs-comment">// { title: string }</span>\n</code></pre>\n<h3>6.2 Redux Action 类型推断</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ActionType</span>&lt;T&gt; = \n  T <span class="hljs-keyword">extends</span> { [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-function">(<span class="hljs-params">...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]</span>) =&gt;</span> infer A } ? A : <span class="hljs-built_in">never</span>;\n\n<span class="hljs-comment">// 示例</span>\n<span class="hljs-keyword">const</span> actions = {\n  <span class="hljs-attr">load</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> ({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LOAD&#x27;</span>, <span class="hljs-attr">payload</span>: id } <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>),\n  <span class="hljs-attr">save</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">data</span>: <span class="hljs-built_in">string</span></span>) =&gt;</span> ({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SAVE&#x27;</span>, <span class="hljs-attr">payload</span>: data } <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>)\n};\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Actions</span> = <span class="hljs-title class_">ActionType</span>&lt;<span class="hljs-keyword">typeof</span> actions&gt;; \n<span class="hljs-comment">// { type: &#x27;LOAD&#x27;, payload: number } | { type: &#x27;SAVE&#x27;, payload: string }</span>\n</code></pre>\n<h3>6.3 高阶函数类型推断</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">HigherOrderReturn</span>&lt;T&gt; = \n  T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-function">(<span class="hljs-params">...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]</span>) =&gt;</span> infer R ? R : <span class="hljs-built_in">never</span>;\n\n<span class="hljs-comment">// 示例</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">withLogging</span>(<span class="hljs-params"><span class="hljs-attr">fn</span>: (...args: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span></span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Calling with&#x27;</span>, args);\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(...args);\n  };\n}\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">OriginalReturn</span> = <span class="hljs-title class_">HigherOrderReturn</span>&lt;<span class="hljs-keyword">typeof</span> withLogging&gt;;\n<span class="hljs-comment">// 返回原始函数的返回类型</span>\n</code></pre>\n<p><code>infer</code> 关键字极大地增强了 TypeScript 的类型推断能力，使得我们可以创建更灵活、更精确的类型工具。通过合理使用 <code>infer</code>，可以显著减少手动类型定义的工作量，同时提高代码的类型安全性。</p>\n</div>'</script></body></html>