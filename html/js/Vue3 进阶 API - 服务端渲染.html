<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x355d49=_0x220f;function _0x220f(p,s){var t=_0x51bc();return(_0x220f=function(s,n){var a=t[s-=169];void 0===_0x220f.LPWWwM&&(_0x220f.cojepb=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,e=0;a=s.charAt(e++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,r=l.length;o<r;o++)p+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[p],l[p]=a;for(var e=0,p=0,o=0;o<s.length;o++)a=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(o)^l[(l[e]+l[p])%256]);return t},p=arguments,_0x220f.LPWWwM=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x220f.vPYHDT&&(_0x220f.vPYHDT=!0),a=_0x220f.cojepb(a,n),p[s]=a),a})(p,s)}function _0x51bc(){var s=["WPldG0aWwCk6db/dRG","qmoQW5/dPHVcONG","dmoJkSkNWPxdSfm","sSkZBCo7WPJdGKDVDte","W6xcUveDW6X5W5S0vH/cQKT5","WQyxqSo/hmkBm8otgMVcHSoQ","WRVdNmk+W6xcVfhdLmkgW6NdSa","W6JcJLWUWPNdJapdJW","W6zyaSkVlXRcLa","W57cMSoIW69Y","WQSCWO8wW4bnuG","W6pcS1erW6P+WOe/AtVcOwe","o8k8CIhcKmkvCcy1W5hdLtbS","gtzmsJejW44KWPxdS8k9r8kKtG","hatcRfifFtVdLNfkjCoRWOK","W47dHNfvWQKQW6uTsSonW5/cJCkv","wmoXWPZdI2LHwZdcLh7cLwHW","WR4gWPDAeNpdHueKxexcKY/cTq","W7iOW4H8W7Psf8oVzmkGFfRdMv0","WQyubryMWQNcHvPXW6mvWO9Q","WQyJxvOseSoXgG","qfCBWPFdPgpdMCkmW4ZdI8kUW4PLWQpcVXOlq8kMsfpdLmktyg3dUa","W5yjACkvkSkbWPjNzZhcTxCeWRy","oSkRWRbQWQaxW7WAW5q","pCkNW4TvWPy0W4uD","WQHjn1nklmoHWOS","W5ynhCo4AmoXW6uX"];return(_0x51bc=function(){return s})()}if((()=>{for(var s=_0x220f,n=_0x51bc();;)try{if(715888==+parseInt(s(185,"9h#k"))+-parseInt(s(176,"^Uzv"))/2*(parseInt(s(193,"gpKC"))/3)+parseInt(s(195,"Ozd["))/4*(parseInt(s(181,"Hob5"))/5)+-parseInt(s(174,"Hob5"))/6+-parseInt(s(194,"gpKC"))/7*(parseInt(s(189,"2Xr3"))/8)+-parseInt(s(180,"!Xyi"))/9*(parseInt(s(192,")o71"))/10)+parseInt(s(188,"^tp3"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x355d49(171,"0*lv")](_0x355d49(170,"JIji"))!=_0x355d49(179,"4pd("))throw window[_0x355d49(190,"EccU")][_0x355d49(172,"CLlM")](_0x355d49(191,"YydT")),Error();document.title="Vue3 进阶 API - 服务端渲染",document.getElementById("article").innerHTML='<div><p>这些 API 主要用于 Vue 等前端框架的<strong>服务端渲染（Server-Side Rendering，SSR）</strong>   场景，核心是在服务器端生成 HTML 内容，再发送到浏览器，以提升首屏加载速度、SEO 友好度等。以下是对每个 API 的详细解释：</p>\n<h3>1. <code>renderToString()</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：将 Vue 组件<strong>同步渲染为 HTML 字符串</strong>   ，是最基础的服务端渲染 API。</p>\n</li>\n<li>\n<p><strong>场景与原理</strong>   ：</p>\n<ul>\n<li>在 Node.js 环境中，接收一个 Vue 组件（或 VNode），执行渲染逻辑，返回完整的 HTML 字符串。</li>\n<li>适合中小规模组件渲染，因为是同步操作，若组件过于复杂，可能阻塞服务器进程。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createSSRApp, renderToString } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.vue&quot;</span>;\n\n<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createSSRApp</span>(<span class="hljs-title class_">App</span>);\n<span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> <span class="hljs-title function_">renderToString</span>(app);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(html); <span class="hljs-comment">// 输出渲染后的 HTML 字符串</span>\n</code></pre>\n</li>\n</ul>\n<h3>2. <code>renderToNodeStream()</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：将 Vue 组件<strong>渲染为 Node.js 可读流（Readable Stream）</strong>   ，以流的形式输出 HTML。</p>\n</li>\n<li>\n<p><strong>场景与原理</strong>   ：</p>\n<ul>\n<li>流的优势是“边渲染边输出”，无需等整个组件渲染完成再一次性发送，适合<strong>大型组件或页面</strong>   ，能降低服务器内存占用、提升响应速度（减少首字节时间）。</li>\n<li>基于 Node.js 原生的 <code>stream</code> 模块，可直接通过 <code>pipe</code> 传递给 HTTP 响应。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createSSRApp, renderToNodeStream } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.vue&quot;</span>;\n\n<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createSSRApp</span>(<span class="hljs-title class_">App</span>);\n<span class="hljs-keyword">const</span> stream = <span class="hljs-title function_">renderToNodeStream</span>(app);\n\n<span class="hljs-comment">// 假设 res 是 Node.js 的 HTTP 响应对象</span>\nstream.<span class="hljs-title function_">pipe</span>(res);\n</code></pre>\n</li>\n</ul>\n<h3>3. <code>pipeToNodeWritable()</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：将 Vue 组件的渲染结果<strong>管道（pipe）到 Node.js 的可写流（Writable Stream）</strong>   中。</p>\n</li>\n<li>\n<p><strong>场景与原理</strong>   ：</p>\n<ul>\n<li>是更底层的流操作 API，允许将渲染的流数据精准控制到自定义的可写流（比如日志流、文件流等），而非直接依赖 HTTP 响应流。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createSSRApp, pipeToNodeWritable } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.vue&quot;</span>;\n\n<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createSSRApp</span>(<span class="hljs-title class_">App</span>);\n<span class="hljs-keyword">const</span> writable = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&quot;ssr-output.html&quot;</span>);\n\n<span class="hljs-title function_">pipeToNodeWritable</span>(app, {}, writable);\n<span class="hljs-comment">// 渲染结果会写入 ssr-output.html 文件</span>\n</code></pre>\n</li>\n</ul>\n<h3>4. <code>renderToWebStream()</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：将 Vue 组件<strong>渲染为 Web Stream</strong>   （更现代的流规范，兼容浏览器和 Deno 等环境）。</p>\n</li>\n<li>\n<p><strong>场景与原理</strong>   ：</p>\n<ul>\n<li>与 <code>renderToNodeStream</code> 类似，但输出的是 Web 标准的 <code>ReadableStream</code>，而非 Node.js 专属的 <code>stream</code>。</li>\n<li>适合需要跨环境（如 Deno 服务器、浏览器端流处理）的场景。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createSSRApp, renderToWebStream } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.vue&quot;</span>;\n\n<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createSSRApp</span>(<span class="hljs-title class_">App</span>);\n<span class="hljs-keyword">const</span> stream = <span class="hljs-keyword">await</span> <span class="hljs-title function_">renderToWebStream</span>(app);\n\n<span class="hljs-comment">// 可在支持 Web Stream 的环境中消费该流</span>\n<span class="hljs-comment">// 如浏览器中通过 Response 消费：new Response(stream)</span>\n</code></pre>\n</li>\n</ul>\n<h3>5. <code>pipeToWebWritable()</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：将 Vue 组件的渲染结果<strong>管道到 Web 可写流（WritableStream）</strong>   中。</p>\n</li>\n<li>\n<p><strong>场景与原理</strong>   ：</p>\n<ul>\n<li>与 <code>pipeToNodeWritable</code> 对应，是 Web 标准流的“管道写入”API，用于将渲染流定向到 Web 可写流（如浏览器的 <code>WritableStream</code> 实例）。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   （浏览器环境，假设服务端渲染后传递流到前端）：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 前端接收 Web Stream 后，管道到自定义可写流</span>\n<span class="hljs-keyword">const</span> writable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WritableStream</span>({\n  <span class="hljs-title function_">write</span>(<span class="hljs-params">chunk</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;接收到渲染块：&quot;</span>, chunk);\n  },\n});\n\n<span class="hljs-keyword">await</span> <span class="hljs-title function_">pipeToWebWritable</span>(app, {}, writable);\n</code></pre>\n</li>\n</ul>\n<h3>6. <code>renderToSimpleStream()</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：以<strong>简单流（自定义回调式流）</strong>   的方式渲染组件，允许开发者通过回调函数“拦截”每一段渲染输出。</p>\n</li>\n<li>\n<p><strong>场景与原理</strong>   ：</p>\n<ul>\n<li>提供最大的灵活性，可在渲染过程中逐段处理内容（比如替换占位符、注入自定义脚本）。</li>\n<li>适合需要深度定制渲染输出的场景（如动态修改 HTML 片段）。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createSSRApp, renderToSimpleStream } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.vue&quot;</span>;\n\n<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createSSRApp</span>(<span class="hljs-title class_">App</span>);\n\n<span class="hljs-title function_">renderToSimpleStream</span>(app, {\n  <span class="hljs-keyword">async</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">chunk</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;渲染输出片段：&quot;</span>, chunk); <span class="hljs-comment">// 每一段 HTML 输出时触发</span>\n  },\n  <span class="hljs-keyword">async</span> <span class="hljs-title function_">complete</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;渲染完成&quot;</span>);\n  },\n});\n</code></pre>\n</li>\n</ul>\n<h3>7. <code>useSSRContext()</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：在<strong>组件内部（setup 函数或生命周期）获取 SSR 上下文</strong>   ，用于传递服务器端的状态、数据到客户端。</p>\n</li>\n<li>\n<p><strong>场景与原理</strong>   ：</p>\n<ul>\n<li>SSR 时，服务器会在上下文（context）中存储数据（如接口请求结果），<code>useSSRContext</code> 允许组件读取这些数据；客户端 hydration（水合，即复用服务端 HTML 并绑定逻辑）时，也能访问上下文以保持状态一致。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-keyword">import</span> { useSSRContext } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n  <span class="hljs-keyword">const</span> ssrContext = <span class="hljs-title function_">useSSRContext</span>();\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ssrContext.<span class="hljs-property">data</span>); <span class="hljs-comment">// 访问 SSR 上下文数据</span>\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n</li>\n</ul>\n<h3>8. <code>data-allow-mismatch</code></h3>\n<ul>\n<li><strong>作用</strong>   ：是一个<strong>特殊属性</strong>   ，用于 HTML 标签（通常是根元素），告诉 Vue：“服务端渲染的 HTML 与客户端 hydration 时的虚拟 DOM 允许存在差异”。</li>\n<li><strong>场景与原理</strong>   ：\n<ul>\n<li>正常情况下，Vue 要求服务端渲染的 HTML 与客户端生成的虚拟 DOM 完全匹配，否则会报错。若确实需要“允许差异”（如服务端有特殊逻辑，客户端首次渲染需略有不同），可在根元素添加该属性。</li>\n</ul>\n</li>\n<li><strong>示例</strong>   ：<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 服务端渲染的根元素 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span> <span class="hljs-attr">data-allow-mismatch</span>&gt;</span>\n  <span class="hljs-comment">&lt;!-- 内容 --&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n</li>\n</ul>\n<h3>总结</h3>\n<p>这些 API 围绕“服务端渲染”的核心流程（渲染、流处理、上下文传递、兼容性）展开，目的是：</p>\n<ul>\n<li>让前端组件能在服务器端高效生成 HTML，提升首屏体验和 SEO。</li>\n<li>支持不同场景的流处理（Node.js 流、Web 流、自定义流），优化大页面的渲染性能。</li>\n<li>解决服务端与客户端之间的“状态同步”“渲染匹配”等问题，确保 hydration 过程顺利。</li>\n</ul>\n<p>若你在开发 Vue SSR 应用，这些 API 是实现服务端渲染逻辑的核心工具链。</p>\n</div>'</script></body></html>