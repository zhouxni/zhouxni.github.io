<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1ab2(r,n){var o=_0x386a();return(_0x1ab2=function(n,s){var a=o[n-=402];void 0===_0x1ab2.GWQHgQ&&(_0x1ab2.PEhUQA=function(n,s){var a,t=[],r=0,o="";for(n=(n=>{for(var s,a,t="",r="",o=0,l=0;a=n.charAt(l++);~a&&(s=o%4?64*s+a:a,o++%4)&&(t+=String.fromCharCode(255&s>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,c=t.length;e<c;e++)r+="%"+("00"+t.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(r)})(n),l=0;l<256;l++)t[l]=l;for(l=0;l<256;l++)r=(r+t[l]+s.charCodeAt(l%s.length))%256,a=t[l],t[l]=t[r],t[r]=a;for(var l=0,r=0,e=0;e<n.length;e++)a=t[l=(l+1)%256],t[l]=t[r=(r+t[l])%256],t[r]=a,o+=String.fromCharCode(n.charCodeAt(e)^t[(t[l]+t[r])%256]);return o},r=arguments,_0x1ab2.GWQHgQ=!0);var n=n+o[0],t=r[n];return t?a=t:(void 0===_0x1ab2.oxhaKw&&(_0x1ab2.oxhaKw=!0),a=_0x1ab2.PEhUQA(a,s),r[n]=a),a})(r,n)}var _0x5431a9=_0x1ab2;function _0x386a(){var n=["W7fmWO19D2z4z8kuW57cHCoPra","WPddHSkLWPRcRZdcHCo6aCoTWRpcRgGB","zeyrW4VdIgin","nH7dJmkgW6eOW5C","rmoaW5q7gM13WRJdHWiypq","WQhcGCoPsvPQWPP4W7/cVXhdQq","WQPdWQRcHSobimkRdSoM","fIBcGgKJW5bashq","WPn9B8ojWPlcQSkCW74","wYXqytBdOSoY","W5KIWPpdTqFcJSon","AmoRyCktWOxcL3ZdMedcSxBcVCkT","q8kyWQ7cU1BdMsC","b8ocW7ZdLcHEt2NdSwZcPaVcVG","W6yJW7ZcLWCFW6FdKmkGW7OzW6Tu","WO13FmoeWOFcOmkw","jwuDWO8fW4uhW7NdLCk0EZO","WROazZC3hSk6W51B","W7DoWOf9DgL6qmkcW5lcMCoACa","W7pdSaSjqCoqoSoZDGhcPtVcPG","WPldHCkNWPFcQZJdNmkgbSoRWPtcGG","jmkEw8oaW5ddI8keW6VcGWFcQxtcMa","W6/dNCojf8o6","i8oDjsHoW7/dHmofW5CGWPFdK8kVbfNcMCkDWPRcJIutd0W3W5pcQq","W4ZcQ8oZvSkkdmktW4mJqSkKCSkW","iwiFWOmaW4HWWO7dK8kKDZJdIvu"];return(_0x386a=function(){return n})()}if((()=>{for(var n=_0x1ab2,s=_0x386a();;)try{if(575143==-parseInt(n(408,"0Qoa"))*(parseInt(n(403,"rSr*"))/2)+parseInt(n(423,"hW%u"))/3+-parseInt(n(418,"]]fN"))/4+-parseInt(n(412,"(PcF"))/5+-parseInt(n(402,"#Hy0"))/6*(parseInt(n(417,"&D(m"))/7)+-parseInt(n(406,"!(%1"))/8*(-parseInt(n(419,"u2xD"))/9)+parseInt(n(424,"skSp"))/10)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x5431a9(411,"hF([")](_0x5431a9(416,"*Az]"))!=_0x5431a9(421,"c@Zl"))throw window[_0x5431a9(407,"cOh4")][_0x5431a9(414,"cOh4")](_0x5431a9(422,"^Ez#")),Error();document.title="Babel 宽松模式 和 严格模式",document.getElementById("article").innerHTML='<div><p>在 Babel 中，<strong>宽松模式（Loose Mode）</strong>   和 <strong>严格模式（Normal/Strict Mode）</strong>   是两种不同的代码转换策略，主要影响 Babel 如何将 ES6+ 语法（如类、箭头函数等）编译为 ES5 代码。它们的核心区别在于 <strong>代码的精确性（符合规范）</strong>   与 <strong>编译后的性能/简洁性</strong>   之间的权衡。</p>\n<hr>\n<h3><strong>1. 宽松模式（Loose Mode）</strong></h3>\n<h4><strong>特点</strong></h4>\n<ul>\n<li><strong>更简单、更高效的输出代码</strong>   ：<br>\nBabel 会生成更简洁、性能更好的代码，但可能不完全符合 ECMAScript 规范。</li>\n<li><strong>牺牲一些边缘情况的准确性</strong>   ：<br>\n在极端场景下（如继承、静态方法等），编译后的行为可能与标准不一致。</li>\n</ul>\n<h4><strong>适用场景</strong></h4>\n<ul>\n<li>对性能要求高，且不需要 100% 符合规范的场景（如内部工具、非公开项目）。</li>\n<li>明确知道代码不会触及规范边缘情况时。</li>\n</ul>\n<h4><strong>示例：类的转换</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 源代码（ES6）</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;\n  }\n}\n</code></pre>\n<p><strong>宽松模式编译结果</strong>   （<code>@babel/preset-env</code> + <code>loose: true</code>）：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 转换为 ES5（简化版）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;\n}\n</code></pre>\n<ul>\n<li><strong>问题</strong>   ：未完全模拟类的内部特性（如 <code>[[HomeObject]]</code>），可能影响 <code>super</code> 的行为。</li>\n</ul>\n<hr>\n<h3><strong>2. 严格模式（Normal/Strict Mode，默认）</strong></h3>\n<h4><strong>特点</strong></h4>\n<ul>\n<li><strong>完全符合 ECMAScript 规范</strong>   ：<br>\n生成的代码严格遵循标准，保证所有边缘情况行为正确。</li>\n<li><strong>输出代码更复杂</strong>   ：<br>\n需要额外的辅助函数和检查，可能影响性能和体积。</li>\n</ul>\n<h4><strong>适用场景</strong></h4>\n<ul>\n<li>公共库、框架等需要严格兼容性的项目。</li>\n<li>无法预测代码是否会被用于边缘情况时。</li>\n</ul>\n<h4><strong>示例：类的转换</strong></h4>\n<p><strong>严格模式编译结果</strong>   （默认）：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 转换为 ES5（简化版）</span>\n<span class="hljs-keyword">var</span> <span class="hljs-title class_">Person</span> = <span class="hljs-comment">/*#__PURE__*/</span> (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {\n    <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// 检查是否通过 new 调用</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;\n  }\n  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Person</span>;\n})();\n</code></pre>\n<ul>\n<li><strong>额外开销</strong>   ：需要注入 <code>_classCallCheck</code> 等辅助函数。</li>\n</ul>\n<hr>\n<h3><strong>3. 关键差异对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>宽松模式</strong></th>\n<th><strong>严格模式</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>输出代码体积</strong></td>\n<td>更小</td>\n<td>更大（含辅助函数）</td>\n</tr>\n<tr>\n<td><strong>运行性能</strong></td>\n<td>更高（代码更直接）</td>\n<td>略低（有额外检查）</td>\n</tr>\n<tr>\n<td><strong>规范符合性</strong></td>\n<td>可能不符合边缘情况</td>\n<td>完全符合</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>内部项目、性能敏感场景</td>\n<td>公共库、严谨项目</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>4. 如何配置？</strong></h3>\n<h4><strong>通过 Babel 预设（如 <code>@babel/preset-env</code>）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// babel.config.js</span>\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">presets</span>: [\n    [\n      <span class="hljs-string">&quot;@babel/preset-env&quot;</span>,\n      {\n        <span class="hljs-attr">loose</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 启用宽松模式（默认 false）</span>\n      },\n    ],\n  ],\n};\n</code></pre>\n<h4><strong>针对特定插件单独设置</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// babel.config.js</span>\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">plugins</span>: [\n    [<span class="hljs-string">&quot;@babel/plugin-proposal-class-properties&quot;</span>, { <span class="hljs-attr">loose</span>: <span class="hljs-literal">true</span> }], <span class="hljs-comment">// 类的属性宽松模式</span>\n  ],\n};\n</code></pre>\n<hr>\n<h3><strong>5. 常见插件的宽松行为</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>插件</strong></th>\n<th><strong>宽松模式的影响</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>@babel/plugin-proposal-class-properties</code></td>\n<td>直接赋值属性（<code>this.x = y</code>），而非 <code>Object.defineProperty</code></td>\n</tr>\n<tr>\n<td><code>@babel/plugin-transform-classes</code></td>\n<td>简化类继承逻辑，可能破坏 <code>super</code> 的准确性</td>\n</tr>\n<tr>\n<td><code>@babel/plugin-transform-for-of</code></td>\n<td>将 <code>for...of</code> 转换为普通 <code>for</code> 循环，而非迭代器协议</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>6. 为什么需要宽松模式？</strong></h3>\n<ul>\n<li><strong>性能优化</strong>   ：减少辅助函数和属性检查，提升运行速度。</li>\n<li><strong>代码简化</strong>   ：输出更易读、更紧凑的代码（如直接赋值代替 <code>Object.defineProperty</code>）。</li>\n</ul>\n<hr>\n<h3><strong>7. 注意事项</strong></h3>\n<ol>\n<li><strong>公共库慎用宽松模式</strong>   ：<br>\n如果你的代码会被其他开发者使用，严格模式能避免潜在兼容性问题。</li>\n<li><strong>测试覆盖边缘情况</strong>   ：<br>\n如果启用宽松模式，需额外测试继承、静态方法等场景。</li>\n<li><strong>Babel 版本差异</strong>   ：<br>\n不同版本的 Babel 对宽松模式的支持可能不同，建议查阅对应插件文档。</li>\n</ol>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>宽松模式</strong>   ：用规范符合性换取性能和简洁性。</li>\n<li><strong>严格模式</strong>   ：优先保证行为正确性，适合公共代码。</li>\n</ul>\n<p>根据项目需求合理选择，通常推荐默认使用严格模式，仅在性能关键路径中局部启用宽松模式。</p>\n</div>'</script></body></html>