<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x209c79=_0x4a2b;function _0x1260(){var n=["uvtcHbOlEdJcMGq","W5pdVLpcS2HmmCouAJe","yeddMfZcLmoizCoxWODc","WPxdGSomW7dcISoTW4ZcI8keWQfpW712","WPhdR8k1tmkohmo8CZJcLmoJkmoHFq","WRRdHSozoSoVWQxdKG","s3fvW4xcTmoeoSoua8obbW","WPfvumo0W40","umoJtJ4yW5JdGHL6W74","W4HkhSk7nLSKW4dcUmkPqSktqq","WP4GWOmqsNfvWPFcG8kKxSk4W5G","W67dR8onaJNcSY1ve2TQW5dcJve","WPyCsSoQDqj5W6C","WP0MWOOEqNbxW6tcGmkBuCkaW67cKq","W7baDflcQ8o5WPpdVCkVW67dMhtdMvtcTSk+WOe0WOdcK8oAW4JdLcLZWRq","W5pdUv7cTbKSCCkhEHtcRIlcJ8k9","j1tdT2FcQ0rKWPPGWOVcKmkHWRi","W4dcPwujw8omiLaqWPVcOW","jCk1cWtdMrtcQJRdPG","AHVdIb0xBCkFbmoq","BZNdNCkrW6vUW6GWW7fC","W5a+d1SaWPn+W4NcHSkbmrFdTSkV","W5NdOrmbfCo5WQZcTCk0FCo+aXdcLq","WPOVWQZcGIZcQmow"];return(_0x1260=function(){return n})()}function _0x4a2b(t,n){var r=_0x1260();return(_0x4a2b=function(n,o){var e=r[n-=481];void 0===_0x4a2b.gMjJob&&(_0x4a2b.udXBtm=function(n,o){var e,c=[],t=0,r="";for(n=(n=>{for(var o,e,c="",t="",r=0,d=0;e=n.charAt(d++);~e&&(o=r%4?64*o+e:e,r++%4)&&(c+=String.fromCharCode(255&o>>(-2*r&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var l=0,i=c.length;l<i;l++)t+="%"+("00"+c.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(t)})(n),d=0;d<256;d++)c[d]=d;for(d=0;d<256;d++)t=(t+c[d]+o.charCodeAt(d%o.length))%256,e=c[d],c[d]=c[t],c[t]=e;for(var d=0,t=0,l=0;l<n.length;l++)e=c[d=(d+1)%256],c[d]=c[t=(t+c[d])%256],c[t]=e,r+=String.fromCharCode(n.charCodeAt(l)^c[(c[d]+c[t])%256]);return r},t=arguments,_0x4a2b.gMjJob=!0);var n=n+r[0],c=t[n];return c?e=c:(void 0===_0x4a2b.YleSkF&&(_0x4a2b.YleSkF=!0),e=_0x4a2b.udXBtm(e,o),t[n]=e),e})(t,n)}if((()=>{for(var n=_0x4a2b,o=_0x1260();;)try{if(942495==+parseInt(n(497,"^jer"))*(parseInt(n(485,"KZwX"))/2)+-parseInt(n(494,"EJQ["))/3+parseInt(n(493,"f&$N"))/4*(-parseInt(n(499,"Zh%q"))/5)+parseInt(n(483,"v$&h"))/6+-parseInt(n(504,"6LCI"))/7+parseInt(n(495,"^BRk"))/8+parseInt(n(482,"3G[u"))/9)break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x209c79(496,"CEco")](_0x209c79(491,"NQ#B"))!=_0x209c79(498,"Az9U"))throw window[_0x209c79(503,"D@iR")][_0x209c79(490,"NoJh")](_0x209c79(481,"yh@2")),Error();document.title="react 的事件注册和事件分发",document.getElementById("article").innerHTML="<div><p>React 的事件机制主要包括事件注册和事件分发两个核心部分，以下是详细的解析：</p>\n<h3>一、事件注册</h3>\n<ol>\n<li><strong>事件绑定位置</strong>  ：\n<ul>\n<li>在 React 中，事件并没有直接绑定到具体的 DOM 节点上，而是绑定在了 <code>document</code> 上（React 17 之后是绑定在 <code>#root</code> 节点上）。这种方式被称为<strong>事件委托</strong>  。</li>\n<li>通过事件委托，React 可以减少内存消耗，提升性能，因为一种事件类型只需要在 <code>document</code> 上注册一次。</li>\n</ul>\n</li>\n<li><strong>注册过程</strong>  ：\n<ul>\n<li>当组件挂载时，React 会根据组件内声明的事件类型（如 <code>onClick</code>、<code>onChange</code> 等），在 <code>document</code> 上添加相应的事件监听器，并指定统一的事件处理程序 <code>dispatchEvent</code>。</li>\n<li>React 会将所有的事件和事件类型以及 React 组件进行关联，并将这个关系保存在一个对象中（键值对），以便在事件触发时能够查找到对应的事件处理函数。</li>\n</ul>\n</li>\n<li><strong>事件存储</strong>  ：\n<ul>\n<li>React 会将事件处理函数存储在一个名为 <code>listenerBank</code> 的对象中，以便在事件触发时能够快速地查找到并执行。</li>\n</ul>\n</li>\n</ol>\n<h3>二、事件分发</h3>\n<ol>\n<li><strong>事件触发</strong>  ：\n<ul>\n<li>当用户在浏览器中与页面进行交互时，会触发原生的 DOM 事件。</li>\n<li>这些原生事件会被 React 捕获，并从原生事件中获取到原生节点。</li>\n</ul>\n</li>\n<li><strong>事件合成</strong>  ：\n<ul>\n<li>React 会根据原生事件生成一个<strong>合成事件</strong>  （<code>SyntheticEvent</code>）。合成事件是 React 对原生事件的封装，它提供了跨浏览器的兼容性，并增加了额外的功能和优化。</li>\n<li>合成事件对象会被重用，所有属性在事件处理函数执行后会被置为 <code>null</code>，以节省内存。如果需要保留事件对象的属性，可以调用 <code>event.persist()</code> 方法。</li>\n</ul>\n</li>\n<li><strong>事件分发</strong>  ：\n<ul>\n<li>React 会根据事件触发的原生节点，找到对应的 React 组件实例。</li>\n<li>然后，React 会从 <code>listenerBank</code> 中查找到该组件实例上注册的事件处理函数，并按照冒泡或捕获的顺序依次执行它们。</li>\n<li>事件处理函数会接收到一个合成事件对象作为参数，该对象包含了与原生事件相关的所有信息。</li>\n</ul>\n</li>\n<li><strong>事件冒泡与捕获</strong>  ：\n<ul>\n<li>React 的合成事件默认只支持事件冒泡。如果需要捕获阶段的事件处理，可以使用原生的 <code>addEventListener</code> 方法进行注册。</li>\n<li>原生事件阻止冒泡会阻止合成事件的触发，但合成事件的阻止冒泡不会影响原生事件。因此，建议尽量不要混合使用原生事件和合成事件。</li>\n</ul>\n</li>\n</ol>\n<h3>三、总结</h3>\n<p>React 的事件机制通过事件委托和事件合成等方式，实现了高效的事件处理和跨浏览器的兼容性。事件注册阶段将事件绑定到 <code>document</code> 上，并存储在 <code>listenerBank</code> 中；事件分发阶段则根据触发的事件类型和目标节点，查找到对应的事件处理函数并执行。这种机制减少了内存消耗，提升了性能，并对开发者更加友好。</p>\n</div>"</script></body></html>