<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2f162b=_0x2127;function _0x3afa(){var n=["W700W7uixq","W5rYW4H9W7VcQ8kuWOm","DmotW7RcLmo1C8kK","oCovWRRcUqDLgr7cHve","BSokBb12A8kkCtRcSJzb","WRfPW5hdNJLZWOuxc8oJWPvHWPS","W5mcm8kmoNiQ","WQSNlCk6smoKqCkJ","eeuIrSoIksj6WRG","oCkMW6WqWPTwWQG","WQKoWPjbustcIa","WP3dNSo8hJmjWOXAW5eNCHXw","W6pcOSoOW40QfwZdMxpcLXexdW","z8oejLy6omkltG","fCkixuVdMSkCESobW4JcKSoFWQLg","nKm1ASoLpWq","WOTEqmkmW4xcTCogW6iuW4C","WR3dNCkzW48eWRfZWRZcP8k7qmoEWR4","zJfcW4ddI2HUCHaGWOddLa","vmk7wCkfuqrNW4iChmoSWO/cRq","WPiMdfvnWPjcWQreeSoEWQG","WQnVcmkuFCosEa","W4ddN8kPWQddOeSzW5ldPCojl8km","WQv1W6S+ywFdR8o+W6xcNSoaWPVcUY/cK8k8cSoakdq9WOfDW6NcQbu","W4ldL8kOWQBdOeTQW5VdTCoubmkNWOe","WOxcRmkreKSbWQJcLCkQaCopymkm"];return(_0x3afa=function(){return n})()}function _0x2127(o,n){var a=_0x3afa();return(_0x2127=function(n,t){var s=a[n-=405];void 0===_0x2127.KQZurI&&(_0x2127.qeotEx=function(n,t){var s,e=[],o=0,a="";for(n=(n=>{for(var t,s,e="",o="",a=0,d=0;s=n.charAt(d++);~s&&(t=a%4?64*t+s:s,a++%4)&&(e+=String.fromCharCode(255&t>>(-2*a&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var r=0,c=e.length;r<c;r++)o+="%"+("00"+e.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(o)})(n),d=0;d<256;d++)e[d]=d;for(d=0;d<256;d++)o=(o+e[d]+t.charCodeAt(d%t.length))%256,s=e[d],e[d]=e[o],e[o]=s;for(var d=0,o=0,r=0;r<n.length;r++)s=e[d=(d+1)%256],e[d]=e[o=(o+e[d])%256],e[o]=s,a+=String.fromCharCode(n.charCodeAt(r)^e[(e[d]+e[o])%256]);return a},o=arguments,_0x2127.KQZurI=!0);var n=n+a[0],e=o[n];return e?s=e:(void 0===_0x2127.IgaVOm&&(_0x2127.IgaVOm=!0),s=_0x2127.qeotEx(s,t),o[n]=s),s})(o,n)}if((()=>{for(var n=_0x2127,t=_0x3afa();;)try{if(233553==-parseInt(n(408,"P3Zl"))*(-parseInt(n(417,"Gc9D"))/2)+parseInt(n(412,"cNpJ"))/3+-parseInt(n(410,"P^S$"))/4*(-parseInt(n(425,"^RPn"))/5)+-parseInt(n(423,"^RPn"))/6+parseInt(n(406,"#jnS"))/7+parseInt(n(405,"J(M7"))/8+parseInt(n(407,"OeHR"))/9*(-parseInt(n(413,"rqNq"))/10))break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x2f162b(416,"g!$1")](_0x2f162b(409,"g!$1"))!=_0x2f162b(427,"2[f7"))throw window[_0x2f162b(428,"]GdR")][_0x2f162b(411,"T93b")](_0x2f162b(424,"S^O2")),Error();document.title="Nuxt 3 生命周期",document.getElementById("article").innerHTML='<div><p>Nuxt 3 生命周期 = <strong>「Nitro 服务端」+「Vue 客户端」+「Nuxt 专属钩子」</strong>   三条线。<br>\n官方把后者封装成「<strong>可组合式函数</strong>   」与「<strong>插件/模块钩子</strong>   」，不再像 Nuxt 2 那样是「组件选项」。<br>\n下面一张图 + 一张表，带你一次看清所有“生命周期函数”到底在哪一步被执行。</p>\n<hr>\n<p>一、三张时序图（简版）</p>\n<ol>\n<li>\n<p>首屏 SSR<br>\n浏览器 → Nitro 收到请求 → 插件 nuxt:init → 插件 nuxt:ready →<br>\nmiddleware → plugins(一次) → setup() → onServerPrefetch() →<br>\nrenderToString() → 序列化 payload → HTML 返浏览器 →<br>\n浏览器 hydrate → 客户端插件 → Vue onMounted → 完成</p>\n</li>\n<li>\n<p>客户端导航（SPA）<br>\nmiddleware → plugins(不重复) → setup() → onBeforeMount() →<br>\nonMounted() → 完成（无服务端参与）</p>\n</li>\n<li>\n<p>仅 CSR（ssr: false）<br>\n浏览器拿到空白 HTML → 客户端插件 → setup() → onMounted() → 完成</p>\n</li>\n</ol>\n<hr>\n<p>二、完整清单 &amp; 使用方式\nA. Nuxt 3 专属「可组合式」生命周期（必须在 setup() 或 <code>&lt;script setup&gt;</code> 里调）</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>触发时刻</th>\n<th>可访问</th>\n<th>典型用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>useNuxtApp()</code></td>\n<td>创建 Nuxt 实例后</td>\n<td>ssr + client</td>\n<td>取 <code>$router, $payload, payload.state</code></td>\n</tr>\n<tr>\n<td><code>callOnce(fn)</code></td>\n<td>只在服务端或客户端<strong>首次</strong>   执行一次</td>\n<td>ssr + client</td>\n<td>全局单例初始化</td>\n</tr>\n<tr>\n<td><code>onNuxtReady(cb)</code></td>\n<td>客户端 hydration 完成后</td>\n<td>client only</td>\n<td>写日志、注册 PWA 更新</td>\n</tr>\n<tr>\n<td><code>refreshNuxtData(key)</code></td>\n<td>手动重新拉取 <code>useFetch</code> 数据</td>\n<td>ssr + client</td>\n<td>刷新列表</td>\n</tr>\n<tr>\n<td><code>clearNuxtData(key)</code></td>\n<td>清缓存并触发重新请求</td>\n<td>ssr + client</td>\n<td>登出清用户数据</td>\n</tr>\n<tr>\n<td><code>navigateTo(url)</code></td>\n<td>跳转前立即执行</td>\n<td>ssr + client</td>\n<td>中间件重定向</td>\n</tr>\n<tr>\n<td><code>abortNavigation()</code></td>\n<td>中间件里中断导航</td>\n<td>ssr + client</td>\n<td>权限拦截</td>\n</tr>\n<tr>\n<td><code>useRequestEvent()</code></td>\n<td>只在服务端</td>\n<td>ssr only</td>\n<td>读取 req, res, setHeader</td>\n</tr>\n<tr>\n<td><code>useRequestHeaders()</code></td>\n<td>服务端/客户端</td>\n<td>ssr + client</td>\n<td>取 cookie, UA</td>\n</tr>\n<tr>\n<td><code>useState()</code></td>\n<td>同构</td>\n<td>ssr + client</td>\n<td>全局状态，见上一篇</td>\n</tr>\n</tbody>\n</table>\n<p>B. Vue3 标准生命周期（setup 语法糖里直接写）</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>触发时刻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>onBeforeMount()</code></td>\n<td>客户端挂载前（<strong>服务端不调用</strong>   ）</td>\n</tr>\n<tr>\n<td><code>onMounted()</code></td>\n<td>客户端挂载后（<strong>服务端不调用</strong>   ）</td>\n</tr>\n<tr>\n<td><code>onBeforeUnmount()</code></td>\n<td>组件卸载前</td>\n</tr>\n<tr>\n<td><code>onUnmounted()</code></td>\n<td>组件卸载后</td>\n</tr>\n<tr>\n<td><code>onServerPrefetch()</code></td>\n<td><strong>仅服务端</strong>   ，渲染前异步预拉数据</td>\n</tr>\n<tr>\n<td><code>onErrorCaptured()</code></td>\n<td>子孙组件报错时</td>\n</tr>\n</tbody>\n</table>\n<p>C. 插件与模块级钩子（plugins 或自己写模块）</p>\n<pre><code class="language-ts"><span class="hljs-comment">// plugins/test.ts</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtPlugin</span>({\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;my-plugin&quot;</span>,\n  <span class="hljs-attr">enforce</span>: <span class="hljs-string">&quot;pre&quot;</span>, <span class="hljs-comment">// 执行顺序 pre/default/post</span>\n  <span class="hljs-keyword">async</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params">nuxtApp</span>) {\n    <span class="hljs-comment">// nuxt:init 阶段</span>\n  },\n  <span class="hljs-attr">hooks</span>: {\n    <span class="hljs-string">&quot;app:created&quot;</span>() {\n      <span class="hljs-comment">/* Vue 实例已建 */</span>\n    },\n    <span class="hljs-string">&quot;app:beforeMount&quot;</span>(app) {\n      <span class="hljs-comment">/* 客户端挂载前 */</span>\n    },\n    <span class="hljs-string">&quot;app:mounted&quot;</span>(app) {\n      <span class="hljs-comment">/* 客户端挂载后 */</span>\n    },\n    <span class="hljs-string">&quot;app:suspense:resolve&quot;</span>(app) {\n      <span class="hljs-comment">/* Suspense 完成 */</span>\n    },\n    <span class="hljs-string">&quot;page:start&quot;</span>() {\n      <span class="hljs-comment">/* 路由开始 */</span>\n    },\n    <span class="hljs-string">&quot;page:finish&quot;</span>() {\n      <span class="hljs-comment">/* 路由结束 */</span>\n    },\n    <span class="hljs-string">&quot;page:transition:start&quot;</span>() {\n      <span class="hljs-comment">/* 过渡动画开始 */</span>\n    },\n    <span class="hljs-string">&quot;page:transition:finish&quot;</span>() {\n      <span class="hljs-comment">/* 过渡动画结束 */</span>\n    },\n  },\n});\n</code></pre>\n<p>D. Nitro 服务端钩子（server/api 目录或 server/plugins）</p>\n<pre><code class="language-ts"><span class="hljs-comment">// server/plugins/logger.ts</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNitroPlugin</span>(<span class="hljs-function">(<span class="hljs-params">nitroApp</span>) =&gt;</span> {\n  nitroApp.<span class="hljs-property">hooks</span>.<span class="hljs-title function_">hook</span>(<span class="hljs-string">&quot;request&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[nitro] request&quot;</span>, event.<span class="hljs-property">path</span>);\n  });\n  nitroApp.<span class="hljs-property">hooks</span>.<span class="hljs-title function_">hook</span>(<span class="hljs-string">&quot;beforeResponse&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event, { body }</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[nitro] response&quot;</span>, event.<span class="hljs-property">path</span>, body);\n  });\n});\n</code></pre>\n<hr>\n<p>三、记忆口诀</p>\n<ol>\n<li><strong>「服务端只跑一次」</strong>   ：<code>onServerPrefetch</code> / <code>useRequestEvent</code> / <code>callOnce(...)</code></li>\n<li><strong>「客户端才挂载」</strong>   ：<code>onBeforeMount</code> / <code>onMounted</code> / <code>onNuxtReady</code></li>\n<li><strong>「每次导航都跑」</strong>   ：<code>middleware</code> → <code>setup()</code> → Vue 生命周期</li>\n<li><strong>「全局钩子写插件」</strong>   ：<code>app:created</code> / <code>page:start</code> / <code>page:finish</code></li>\n<li><strong>「底层日志改 Nitro」</strong>   ：<code>request</code> / <code>beforeResponse</code> / <code>afterResponse</code></li>\n</ol>\n<hr>\n<p>四、常见疑问</p>\n<ul>\n<li>\n<p>Q：Nuxt2 的 <code>asyncData/fetch</code> 去哪了？<br>\nA：被 <code>useFetch/useAsyncData</code> 组合式函数替代，在 <code>setup()</code> 里调即可，它们内部会在服务端预取并自动序列化。</p>\n</li>\n<li>\n<p>Q：为什么 <code>onMounted</code> 里拿不到 <code>useRequestEvent</code>？<br>\nA：<code>useRequestEvent</code> 仅服务端存在，客户端返回 <code>null</code>。需要服务端数据请提前在 <code>useFetch</code> 或 <code>onServerPrefetch</code> 里取好。</p>\n</li>\n<li>\n<p>Q：中间件里能终止导航吗？<br>\nA：可以 <code>return abortNavigation()</code> 或 <code>return navigateTo(\'/login\')</code>，等价于旧版 <code>redirect/abort</code>。</p>\n</li>\n</ul>\n<hr>\n<p>一张表 + 一张图，开发时对照看，就能知道代码到底该写在哪一个「生命周期函数」里。祝你在 Nuxt 3 的 SSR/SPA 双世界里游刃有余！</p>\n</div>'</script></body></html>