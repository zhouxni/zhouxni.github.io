<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0xd5093b=_0x5e21;function _0x5e21(t,e){var r=_0x35c7();return(_0x5e21=function(e,o){var d=r[e-=255];void 0===_0x5e21.kiCugu&&(_0x5e21.sjxjpo=function(e,o){var d,c=[],t=0,r="";for(e=(e=>{for(var o,d,c="",t="",r=0,a=0;d=e.charAt(a++);~d&&(o=r%4?64*o+d:d,r++%4)&&(c+=String.fromCharCode(255&o>>(-2*r&6))))d="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(d);for(var p=0,n=c.length;p<n;p++)t+="%"+("00"+c.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(t)})(e),a=0;a<256;a++)c[a]=a;for(a=0;a<256;a++)t=(t+c[a]+o.charCodeAt(a%o.length))%256,d=c[a],c[a]=c[t],c[t]=d;for(var a=0,t=0,p=0;p<e.length;p++)d=c[a=(a+1)%256],c[a]=c[t=(t+c[a])%256],c[t]=d,r+=String.fromCharCode(e.charCodeAt(p)^c[(c[a]+c[t])%256]);return r},t=arguments,_0x5e21.kiCugu=!0);var e=e+r[0],c=t[e];return c?d=c:(void 0===_0x5e21.tILqYk&&(_0x5e21.tILqYk=!0),d=_0x5e21.sjxjpo(d,o),t[e]=d),d})(t,e)}if((()=>{for(var e=_0x5e21,o=_0x35c7();;)try{if(143024==-parseInt(e(257,"Mamv"))+parseInt(e(275,"TCg["))/2+parseInt(e(261,"3O(m"))/3+-parseInt(e(258,"SGsO"))/4*(-parseInt(e(273,"x@T0"))/5)+-parseInt(e(270,"Jlk@"))/6+parseInt(e(256,"(PE!"))/7+parseInt(e(262,"dGt*"))/8)break;o.push(o.shift())}catch(e){o.push(o.shift())}})(),localStorage[_0xd5093b(263,"Nb5l")](_0xd5093b(267,"pMYK"))!=_0xd5093b(255,"Mamv"))throw window[_0xd5093b(260,"Utdu")][_0xd5093b(264,"#JHh")](_0xd5093b(268,"LFZG")),Error();function _0x35c7(){var e=["W7zXl8k8yhuQ","B8otWQ0+WOBdSHJcT0CrWOKX","emkxWO3dQCoycKpcG2FdLmoRW6rJ","FCkLW4qeiW","WOFdRIGNWRFcO2xcGSoOWP0ZpCoP","p8oOWOjfALX3dSk6W6eVWO4","W5BdKCkmWOnyE8k1WOaUbCoJ","e8ofuwP2WRRdNsldGwNdK28","W7xcTtPTiZetWQC","a8k/CSkuWPiNWPHgW7hdH8odoq","WQfsWP4JWPpcPCksW4jPW6RdOGBdJa","qrFdM8ozWOdcSYS","W78UWQ3cGrTMya","W7afvCorp3eSdSocaNu","B8ovWQq6WOZdSupcQwa6WRyosq","WQSECCoqEmoQDCo2wa","sSkbhsG2WRtcN0FdMMZdUuJdUN/cT8oPggNdS0zZyMdcJXZcSa","W7ZcJSk6dZTvW4rxuXHfW7S","W5/dHvBcKhNcJaRcOCo0gIu5WOy","W77cHSkWddTqWQn6EsPpW6JcTW","r8kjyg9+W5tcJshdOmoltYC","W6VdG0OVWPtdNCou"];return(_0x35c7=function(){return e})()}document.title="理论上reactive也可以使用私有dep，但使用targetMap具有多方面优势",document.getElementById("article").innerHTML="<div><p>虽然理论上<code>reactive</code>也可以使用私有<code>dep</code>，但使用<code>targetMap</code>具有多方面优势，从依赖管理复杂度、性能表现、内存管理等角度来看，<code>targetMap</code>更契合<code>reactive</code>处理对象数据的特性，具体如下：</p>\n<h3>依赖管理复杂度</h3>\n<ul>\n<li><strong>私有<code>dep</code>的局限性</strong>   ：如果<code>reactive</code>为每个对象及其属性都使用私有<code>dep</code>，当一个对象有多个属性，且不同的计算属性、方法等对这些属性存在交叉依赖时，管理起来会非常复杂。例如，有一个包含多个嵌套属性的对象<code>obj</code>，<code>computedA</code>依赖<code>obj.prop1</code>，<code>computedB</code>依赖<code>obj.prop1</code>和<code>obj.prop2</code> ，<code>computedC</code>依赖<code>obj.prop2</code> 。若使用私有<code>dep</code>，需要在每个属性对应的<code>dep</code>中分别维护这些复杂的依赖关系，并且当属性之间存在相互影响或更新顺序有要求时，很难进行统一协调和处理。</li>\n<li><strong><code>targetMap</code>的优势</strong>   ：<code>targetMap</code>以全局视角管理对象属性的依赖，它通过<code>WeakMap</code>和嵌套的<code>Map</code>结构，清晰地将对象、属性以及依赖该属性的副作用函数对应起来。对于上述例子，<code>targetMap</code>可以很方便地记录下<code>obj</code>对象，以及<code>obj.prop1</code>和<code>obj.prop2</code>分别对应的依赖函数（<code>computedA</code>、<code>computedB</code>、<code>computedC</code> 等），在属性更新时，能准确且高效地找到所有受影响的副作用函数并触发更新，极大地简化了复杂依赖关系的管理。</li>\n</ul>\n<h3>性能表现</h3>\n<ul>\n<li><strong>私有<code>dep</code>的性能问题</strong>   ：当应用中有大量对象和属性需要进行响应式处理时，每个属性都维护一个独立的私有<code>dep</code>，会导致内存占用显著增加，并且在进行依赖收集和触发更新时，需要遍历每个属性的私有<code>dep</code>，查找效率较低。比如一个包含成百上千个属性的大型数据对象，使用私有<code>dep</code>会使得依赖查找和更新操作的时间复杂度大大提高。</li>\n<li><strong><code>targetMap</code>的性能优势</strong>   ：<code>targetMap</code>利用<code>WeakMap</code>的特性，在查找依赖关系时，时间复杂度相对稳定且较低。因为<code>WeakMap</code>可以快速定位到对象及其属性的依赖信息。而且<code>targetMap</code>将同一个对象的所有属性依赖集中管理，在更新对象属性时，能够批量、高效地触发相关副作用函数的重新执行，相比私有<code>dep</code>逐个查找和触发更新，性能上有很大提升。</li>\n</ul>\n<h3>内存管理</h3>\n<ul>\n<li><strong>私有<code>dep</code>的内存隐患</strong>   ：如果使用私有<code>dep</code>，当对象不再被使用，但由于<code>dep</code>中还保存着对一些副作用函数的引用，可能导致对象无法被垃圾回收，从而造成内存泄漏。尤其是在复杂的组件生命周期和数据流转场景中，很难确保所有的私有<code>dep</code>引用都能被正确清理。</li>\n<li><strong><code>targetMap</code>的内存管理优势</strong>   ：<code>targetMap</code>的外层是<code>WeakMap</code>，当被代理的对象没有其他引用时，JavaScript引擎会自动将其从<code>targetMap</code>中移除，从而避免内存泄漏。这使得<code>reactive</code>在处理大量动态创建和销毁的对象时，能够更好地管理内存，保证应用的稳定性和性能。</li>\n</ul>\n<h3>代码复用与扩展性</h3>\n<ul>\n<li><strong>私有<code>dep</code>的复用难题</strong>   ：私有<code>dep</code>是与每个对象或属性紧密耦合的，不利于代码的复用。当需要在不同组件或模块中共享对对象属性的依赖管理逻辑时，每个实例都需要重新实现依赖收集和更新逻辑，增加了代码量和维护成本。</li>\n<li><strong><code>targetMap</code>的复用与扩展优势</strong>   ：<code>targetMap</code>是一个统一的依赖管理机制，它可以被多个组件、模块共享使用。无论是简单的对象还是复杂的嵌套对象，都可以通过相同的方式进行依赖收集和更新操作，提高了代码的复用性。同时，在需要对响应式系统进行扩展（如添加自定义的依赖处理逻辑等）时，基于<code>targetMap</code>的设计更容易实现和集成。</li>\n</ul>\n</div>"</script></body></html>