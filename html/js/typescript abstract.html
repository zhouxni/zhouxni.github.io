<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5243(){var s=["WPdcMXi5FG","WOddS2RcOCk6Bc3cLCov","ACo2drzUFSkhArK+W57cKSorWRVdJHZdUZ3cQMVdVM0WW67dUcO","WOFcSSofW6JdQ8oRmq","WPnpimkAWO/dTmkvWR4","hCkhCMtcJI/cM8ou","o8ohg8kYWRbrW7akWR4","nCk8f3ZdGMToWR7dICoBkdq","W4CEsfLLkCkm","jCo5sguBjhK","ECottXJdO8k+W60","kSovCwKif04","omodeCoxW5OBWOmAWRtdP8kfEte","nCk7sfyPFmo+mJytW5xcHq","W5C6WOGSW5ZcTeVcVe1XW7eD","aIeXWPeOlCoAWRDIWOBdMeK","r8kLE07cLZFcGW","BhtdGgBdRSklt8k3WQpcQNlcQG","W5hcNxSUWPL8WQFcHmobWPPRiG","W7uwutpcTmouW57dNCkOWQK+W5m","ASkPdfnzWO/cKaO","WOpcNMOjueVcUCk1W5b4W7KM","mSkYtLmQCmkBpaCfW53cLSo4","WOldJSkBWPpcOSk1ogrrrHxcNG","W5pdNLz/mgldG0PceCo/Ffu","j0ZcM8kBWOFcGCkQnW","bCk1WP/dOSouwmovFSoJW49Cdq","tSkIWRpcRSoTW7dcUa","wCklWQ9DW6hcULX0WPK","W7tdUg7dRfpdNYnHWPRdLWFcISkq","CSkVW6rspCkfhSkD","k8oxCgWDaea"];return(_0x5243=function(){return s})()}function _0x4e5a(e,s){var t=_0x5243();return(_0x4e5a=function(s,n){var a=t[s-=195];void 0===_0x4e5a.LhtQes&&(_0x4e5a.aonatg=function(s,n){var a,l=[],e=0,t="";for(s=(s=>{for(var n,a,l="",e="",t=0,p=0;a=s.charAt(p++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=l.length;c<r;c++)e+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)e=(e+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[e],l[e]=a;for(var p=0,e=0,c=0;c<s.length;c++)a=l[p=(p+1)%256],l[p]=l[e=(e+l[p])%256],l[e]=a,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[p]+l[e])%256]);return t},e=arguments,_0x4e5a.LhtQes=!0);var s=s+t[0],l=e[s];return l?a=l:(void 0===_0x4e5a.ioAzPY&&(_0x4e5a.ioAzPY=!0),a=_0x4e5a.aonatg(a,n),e[s]=a),a})(e,s)}var _0x151d41=_0x4e5a;if((()=>{for(var s=_0x4e5a,n=_0x5243();;)try{if(307650==-parseInt(s(221,"CnCy"))+-parseInt(s(226,"n6h%"))/2*(parseInt(s(202,"k^$w"))/3)+-parseInt(s(216,"A[[4"))/4*(parseInt(s(220,"zGxt"))/5)+parseInt(s(214,"0WOr"))/6*(-parseInt(s(206,"n6h%"))/7)+-parseInt(s(204,"n6h%"))/8*(parseInt(s(224,"V*%O"))/9)+-parseInt(s(215,"#iTm"))/10*(-parseInt(s(217,"[1Qf"))/11)+parseInt(s(209,"fR3#"))/12*(parseInt(s(223,"lRTJ"))/13))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x151d41(205,"F[uo")](_0x151d41(196,"5sTd"))!=_0x151d41(195,"B7fL"))throw window[_0x151d41(200,"8FJI")][_0x151d41(222,"oxtl")](_0x151d41(197,"[1Qf")),Error();document.title="typescript abstract",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，抽象定义通常涉及使用 <code>abstract</code> 关键字来创建抽象类和抽象方法。抽象类是不能被直接实例化的类，它们通常用于定义一组基类的通用接口或行为，而具体的实现则由子类提供。</p>\n<h3><strong>抽象类</strong></h3>\n<ul>\n<li><strong>定义</strong>  ：使用 <code>abstract</code> 关键字定义一个抽象类。</li>\n<li><strong>特性</strong>  ：\n<ul>\n<li>不能被实例化。</li>\n<li>可以包含抽象方法（没有方法体）和具体方法（有方法体）。</li>\n<li>可以包含属性、构造函数（但不能直接调用，除非通过子类）。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>抽象方法</strong></h3>\n<ul>\n<li><strong>定义</strong>  ：在抽象类中使用 <code>abstract</code> 关键字定义抽象方法。</li>\n<li><strong>特性</strong>  ：\n<ul>\n<li>没有方法体。</li>\n<li>必须在子类中实现。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>示例代码</strong></h3>\n<p>以下是一个简单的示例，展示了如何定义和使用抽象类和抽象方法：</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// 定义一个抽象类 Shape</span>\n<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> {\n  <span class="hljs-comment">// 抽象方法，没有方法体</span>\n  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">getArea</span>(): <span class="hljs-built_in">number</span>;\n\n  <span class="hljs-comment">// 具体方法，有方法体</span>\n  <span class="hljs-title function_">describe</span>(): <span class="hljs-built_in">string</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This is a shape.&quot;</span>;\n  }\n}\n\n<span class="hljs-comment">// 定义一个具体的子类 Circle，继承自 Shape</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Shape</span> {\n  <span class="hljs-keyword">private</span> <span class="hljs-attr">radius</span>: <span class="hljs-built_in">number</span>;\n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">radius</span>: <span class="hljs-built_in">number</span></span>) {\n    <span class="hljs-variable language_">super</span>(); <span class="hljs-comment">// 调用父类的构造函数（虽然这里父类没有显式构造函数，但调用 super() 是一个好习惯）</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> = radius;\n  }\n\n  <span class="hljs-comment">// 实现抽象方法 getArea</span>\n  <span class="hljs-title function_">getArea</span>(): <span class="hljs-built_in">number</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span>;\n  }\n}\n\n<span class="hljs-comment">// 定义另一个具体的子类 Rectangle，继承自 Shape</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Shape</span> {\n  <span class="hljs-keyword">private</span> <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-keyword">private</span> <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;\n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span></span>) {\n    <span class="hljs-variable language_">super</span>();\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = width;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height;\n  }\n\n  <span class="hljs-comment">// 实现抽象方法 getArea</span>\n  <span class="hljs-title function_">getArea</span>(): <span class="hljs-built_in">number</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span>;\n  }\n}\n\n<span class="hljs-comment">// 使用具体子类</span>\n<span class="hljs-keyword">const</span> circle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">5</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(circle.<span class="hljs-title function_">describe</span>()); <span class="hljs-comment">// 输出: This is a shape.</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(circle.<span class="hljs-title function_">getArea</span>());  <span class="hljs-comment">// 输出: 圆的面积</span>\n\n<span class="hljs-keyword">const</span> rectangle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rectangle.<span class="hljs-title function_">describe</span>()); <span class="hljs-comment">// 输出: This is a shape.</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rectangle.<span class="hljs-title function_">getArea</span>());  <span class="hljs-comment">// 输出: 矩形的面积</span>\n</code></pre>\n<h3><strong>解释</strong></h3>\n<ol>\n<li><strong>抽象类 <code>Shape</code></strong>  ：\n<ul>\n<li>定义了一个抽象方法 <code>getArea()</code>，没有方法体。</li>\n<li>定义了一个具体方法 <code>describe()</code>，有方法体。</li>\n</ul>\n</li>\n<li><strong>具体子类 <code>Circle</code> 和 <code>Rectangle</code></strong>  ：\n<ul>\n<li>继承自 <code>Shape</code>。</li>\n<li>实现了 <code>getArea()</code> 方法，提供了具体的计算逻辑。</li>\n</ul>\n</li>\n<li><strong>实例化</strong>  ：\n<ul>\n<li>不能直接实例化抽象类 <code>Shape</code>。</li>\n<li>可以实例化具体子类 <code>Circle</code> 和 <code>Rectangle</code>。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>使用场景</strong></h3>\n<ul>\n<li><strong>定义通用接口</strong>  ：抽象类可以用于定义一组相关类的通用接口，确保所有子类都实现某些方法。</li>\n<li><strong>代码复用</strong>  ：抽象类可以包含具体方法，提供通用的实现逻辑，减少子类中的重复代码。</li>\n<li><strong>设计模式</strong>  ：抽象类在设计模式中非常有用，如模板方法模式，其中抽象类定义了算法的骨架，而具体子类实现算法的某些步骤。</li>\n</ul>\n<h3><strong>注意事项</strong></h3>\n<ul>\n<li>抽象类不能包含未实现的抽象方法（除非子类实现了它们）。</li>\n<li>如果一个类包含抽象方法，那么这个类也必须被标记为 <code>abstract</code>。</li>\n<li>抽象类可以包含构造函数，但通常用于设置一些初始状态或调用子类的构造函数。</li>\n</ul>\n<p>通过抽象类和抽象方法，TypeScript 提供了一种强大的机制来定义和强制实现类的接口和行为。</p>\n</div>'</script></body></html>