<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2c59(){var n=["rSo/WPWhEmoPdrbnh8o5","hKjMWRjEWPZcNSkGWRWM","wCkIz0RdM8khrbhcJmk1sCkFWQbJ","rmobW5hdNmk3WOJdRue","xgVdUSoGWQOYWPBcQa","W7NcTIGUreP7WOPu","g2lcKmk1q8oama","WOaqoCoRgmkKWR0SW57cHa","eGRcM8oyWOnWWPi8vHZdJW","a1LzbdRcKhmq","nmo5WQ9cDqPB","b1qgBdZcR1aGlmks","gCouWPdcTmkOW4dcLW","W57dHaewW7zEWRCHxda","lGmHW7eIW7/cPmokWPLzW7W","nmklW4VcTN0rkSkWW7vnW7RcKN1k","oIm2amoPWPBdQIqJWPOwEmkWDmkoW6hcO8kxavddIgeGWPzyW6K","W50eW6pdShyQWOG","WOmFn8oHrSoTW4S8W63cNCo2W6FcMG","WOpdMCoIWR5ogs13","W4RcHa/cOXb6gd4gWPmhEW","mmklW4VcUxXkvmooW6PxW5W","x8kHydBcQCoAhNxcLW","W57dGqexW5bHWQ8mwYi","WRdcU1bJWRuEtSorta4k","WRJcKCo1tmojzmoOkq","eWpcN8oxWOn7WQumqZldOa","W47dNbNcTaddN8oFWPO1B3L9va","xWaIW7jg","WRpcSvbOW4ilE8oFraG","WQtdGqNcGCoVW5BcJCkNW7W","bf4hBwpdPKm7oCkjWRe0"];return(_0x2c59=function(){return n})()}var _0x1ae3a4=_0x44fe;function _0x44fe(e,n){var r=_0x2c59();return(_0x44fe=function(n,s){var t=r[n-=218];void 0===_0x44fe.rLYESJ&&(_0x44fe.KPJVAX=function(n,s){var t,a=[],e=0,r="";for(n=(n=>{for(var s,t,a="",e="",r=0,l=0;t=n.charAt(l++);~t&&(s=r%4?64*s+t:t,r++%4)&&(a+=String.fromCharCode(255&s>>(-2*r&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var o=0,i=a.length;o<i;o++)e+="%"+("00"+a.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(e)})(n),l=0;l<256;l++)a[l]=l;for(l=0;l<256;l++)e=(e+a[l]+s.charCodeAt(l%s.length))%256,t=a[l],a[l]=a[e],a[e]=t;for(var l=0,e=0,o=0;o<n.length;o++)t=a[l=(l+1)%256],a[l]=a[e=(e+a[l])%256],a[e]=t,r+=String.fromCharCode(n.charCodeAt(o)^a[(a[l]+a[e])%256]);return r},e=arguments,_0x44fe.rLYESJ=!0);var n=n+r[0],a=e[n];return a?t=a:(void 0===_0x44fe.PLckcR&&(_0x44fe.PLckcR=!0),t=_0x44fe.KPJVAX(t,s),e[n]=t),t})(e,n)}if((()=>{for(var n=_0x44fe,s=_0x2c59();;)try{if(686142==-parseInt(n(221,"](zb"))*(-parseInt(n(219,"C3Ew"))/2)+parseInt(n(222,"9k%6"))/3*(-parseInt(n(239,"GqQ]"))/4)+-parseInt(n(236,"oBVq"))/5*(parseInt(n(235,"DjNO"))/6)+parseInt(n(243,"](zb"))/7*(parseInt(n(248,"Q@MW"))/8)+-parseInt(n(225,"DjNO"))/9*(-parseInt(n(244,"dyVb"))/10)+parseInt(n(233,"0c7Q"))/11*(parseInt(n(234,"oY#0"))/12)+parseInt(n(246,"oY#0"))/13)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x1ae3a4(229,"xpQN")](_0x1ae3a4(249,"OBRe"))!=_0x1ae3a4(240,"85Uv"))throw window[_0x1ae3a4(231,"7G!Z")][_0x1ae3a4(218,"#Ejw")](_0x1ae3a4(228,"Mc0h")),Error();document.title="react diff 算法",document.getElementById("article").innerHTML='<div><p>React 的 diff 算法（也称为协调算法）是 React 高效更新虚拟 DOM 的核心机制。它负责比较新旧虚拟 DOM 树，找出差异，并以最小的代价更新实际 DOM。以下是 React diff 算法的详细解析：</p>\n<hr>\n<h3><strong>一、算法核心原则</strong></h3>\n<ol>\n<li><strong>同层级比较</strong><br>\nReact 只对同一层级的节点进行比较，不会跨层级比较。这减少了不必要的比较操作，提高了效率。</li>\n<li><strong>类型相同的节点复用</strong><br>\n如果两个节点的类型相同，React 会尝试复用该节点，并仅更新其属性或子节点。这避免了不必要的节点创建和销毁。</li>\n<li><strong>key 的使用</strong><br>\nkey 是 React diff 算法的重要优化手段。当节点具有唯一的 key 时，React 能够更高效地识别哪些节点需要移动、插入或删除。key 的使用显著提高了 diff 算法的性能，尤其是在处理动态列表时。</li>\n</ol>\n<hr>\n<h3><strong>二、算法流程</strong></h3>\n<ol>\n<li><strong>树结构对比</strong><br>\nReact 首先比较新旧虚拟 DOM 树的根节点。如果根节点类型不同，React 会直接销毁旧树并构建新树。</li>\n<li><strong>组件类型对比</strong>\n<ul>\n<li>如果节点是组件类型，React 会比较组件的类型。如果类型相同，则递归比较组件的子节点。</li>\n<li>如果类型不同，React 会销毁旧组件并创建新组件。</li>\n</ul>\n</li>\n<li><strong>元素类型对比</strong>\n<ul>\n<li>如果节点是原生 DOM 元素（如 div、span 等），React 会比较元素的类型。如果类型相同，则更新元素的属性和子节点。</li>\n<li>如果类型不同，React 会销毁旧元素并创建新元素。</li>\n</ul>\n</li>\n<li><strong>列表 diff</strong>\n<ul>\n<li>对于列表类型的节点，React 会采用特殊的 diff 策略。它会尝试复用旧列表中的节点，并根据 key 来确定节点的位置。</li>\n<li>如果没有 key 或 key 不唯一，React 可能会进行不必要的节点移动或销毁，导致性能下降。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>三、关键优化策略</strong></h3>\n<ol>\n<li><strong>单链表遍历</strong><br>\nReact 的 Fiber 架构采用单链表结构，从左到右依次对比新旧虚拟 DOM 树。虽然不支持双端比对，但通过其他优化策略（如 key 的使用）仍然实现了高效的 diff。</li>\n<li><strong>静态节点提升</strong><br>\n在编译时，React 会对静态节点进行提升，跳过 diff 过程。这减少了渲染成本和 diff 算法的运行时间。</li>\n<li><strong>批量更新</strong><br>\nReact 会将多个状态更新合并为一次 diff 和渲染过程，减少了不必要的 DOM 操作。</li>\n</ol>\n<hr>\n<h3><strong>四、复杂度分析</strong></h3>\n<ul>\n<li><strong>理想情况</strong>  ：在 key 使用合理、节点类型相同的情况下，React 的 diff 算法复杂度接近 O(n)，其中 n 是节点数量。</li>\n<li><strong>最坏情况</strong>  ：在 key 缺失或节点类型频繁变化的情况下，复杂度可能接近 O(n²)。然而，这种情况在实际应用中较为罕见。</li>\n</ul>\n<hr>\n<h3><strong>五、与 Vue diff 算法的比较</strong></h3>\n<ul>\n<li><strong>Vue2</strong>  ：采用双端比较策略，复杂度为 O(n²)。在处理静态内容和顺序变化时可能不如 React 高效。</li>\n<li><strong>Vue3</strong>  ：引入最长递增子序列（LIS）等优化策略，将复杂度降低至接近 O(n)，在某些方面甚至优于 React。</li>\n<li><strong>React</strong>  ：通过 key 的使用和单链表遍历策略，实现了高效的 diff 算法。在整体性能和灵活性方面表现出色。</li>\n</ul>\n<hr>\n<h3><strong>六、实际开发中的建议</strong></h3>\n<ol>\n<li><strong>合理使用 key</strong>\n<ul>\n<li>确保列表中的每个节点都有唯一且稳定的 key。</li>\n<li>避免使用数组索引作为 key，因为这可能导致不必要的节点移动。</li>\n</ul>\n</li>\n<li><strong>避免不必要的节点更新</strong>\n<ul>\n<li>尽量保持节点类型的稳定性，避免频繁切换节点类型。</li>\n<li>使用 <code>shouldComponentUpdate</code> 或 <code>React.memo</code> 来避免不必要的组件更新。</li>\n</ul>\n</li>\n<li><strong>优化组件结构</strong>\n<ul>\n<li>将静态内容提取到组件外部，减少 diff 的范围。</li>\n<li>使用 <code>useCallback</code> 和 <code>useMemo</code> 来优化函数和计算结果的复用。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>七、示例代码</strong></h3>\n<p>以下是一个简单的示例，展示了 key 的使用对 diff 算法的影响：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">List</span>(<span class="hljs-params">{ items }</span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n      {items.map(item =&gt; (\n        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>&gt;</span>{item.text}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> // 使用唯一 key\n      ))}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-comment">// 假设 items 数组发生变化，React 会根据 key 高效地更新列表</span>\n</code></pre>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>React 的 diff 算法通过一系列优化策略，实现了高效的虚拟 DOM 更新。在实际开发中，合理使用 key、避免不必要的节点更新、优化组件结构，可以进一步提高 React 应用的性能。</p>\n</div>'</script></body></html>