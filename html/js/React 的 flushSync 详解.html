<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x255d2f=_0x50c5;function _0x50c5(t,s){var c=_0x54fd();return(_0x50c5=function(s,n){var a=c[s-=388];void 0===_0x50c5.wVQAxv&&(_0x50c5.lXnNRT=function(s,n){var a,l=[],t=0,c="";for(s=(s=>{for(var n,a,l="",t="",c=0,p=0;a=s.charAt(p++);~a&&(n=c%4?64*n+a:a,c++%4)&&(l+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,o=l.length;e<o;e++)t+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)t=(t+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[t],l[t]=a;for(var p=0,t=0,e=0;e<s.length;e++)a=l[p=(p+1)%256],l[p]=l[t=(t+l[p])%256],l[t]=a,c+=String.fromCharCode(s.charCodeAt(e)^l[(l[p]+l[t])%256]);return c},t=arguments,_0x50c5.wVQAxv=!0);var s=s+c[0],l=t[s];return l?a=l:(void 0===_0x50c5.KMFUUx&&(_0x50c5.KMFUUx=!0),a=_0x50c5.lXnNRT(a,n),t[s]=a),a})(t,s)}function _0x54fd(){var s=["WQNcQSkHW5NcUtKX","Ecfsoa3cLwK","jSoyW7ldUczvaapdSSoqWOO/WPS","WRpdV8oYiSoknwyWWP/cKmoyzKS","EwVdShq+nSkXdmojdwhcHa","W4vZWR9fWQWPWRlcKCoBFSoQtCoQ","bmomW7mpmCkrxhJcKCo7W4i6","vYRdISoqWPhdTxFcQq","jSoLW5Lenmo2WOz2gIZcTmksW63dRW","W5a5W4xcQCogW6y3WP4","ECopW4BcGmkxrSoTWRbtW5tdPb0","jXBdOSkQo04qFCozWP54WRBcGG","khZcHSo7Et9h","W4uegSktttTBW5JdIu4Eyb7dJq","A8oelSoOCgv5kt8","W6WwW4niWQxcNSklxmosWO/cUSkmWOy","tCoIamoHW57cH8oAW791WOSZk1u","yvRcPSoQDW","W5vgmX7dJvBcOSo7WPJcOmoQdXC","W7H5wfudW4KuW6joWPbMvx5hW5VcNelcUmkDWQJdH8o8W6mCvay","WQD/WRVdRCoeld0K","t8kLEmoKW7JcQCkKWR3dQSk1z8ozWQ8","aSo7W6dcN8oHWOn3imkKWQfSWPa","W51AW6tcRmoFW6is"];return(_0x54fd=function(){return s})()}if((()=>{for(var s=_0x50c5,n=_0x54fd();;)try{if(773198==-parseInt(s(393,"oOlo"))+parseInt(s(399,"K9bG"))/2+parseInt(s(404,"BhPq"))/3+parseInt(s(410,"RUUn"))/4+parseInt(s(403,"5bIy"))/5*(parseInt(s(389,"xeKZ"))/6)+parseInt(s(388,"UGGi"))/7+-parseInt(s(396,"gDHi"))/8*(parseInt(s(406,"38Gb"))/9))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x255d2f(407,"*3^O")](_0x255d2f(397,"4sxT"))!=_0x255d2f(400,"wpys"))throw window[_0x255d2f(390,"thKs")][_0x255d2f(408,"tu1c")](_0x255d2f(402,"$KzY")),Error();document.title="React 的 flushSync 详解",document.getElementById("article").innerHTML='<div><p><code>flushSync</code> 是 React 提供的一个高级 API，用于在某些特殊情况下<strong>强制同步执行状态更新</strong>  ，绕过 React 的自动批处理机制。</p>\n<h2>基本概念</h2>\n<h3>什么是 <code>flushSync</code>？</h3>\n<ul>\n<li>一个可以强制 React <strong>同步刷新</strong>  （立即执行）状态更新的函数</li>\n<li>会<strong>立即执行</strong>  传入的回调函数中的所有状态更新</li>\n<li>会<strong>触发同步渲染</strong>  ，即 React 会立即处理这些更新并重新渲染组件</li>\n</ul>\n<h3>为什么需要 <code>flushSync</code>？</h3>\n<p>在绝大多数情况下，应该依赖 React 的自动批处理机制以获得最佳性能。但在极少数情况下：</p>\n<ul>\n<li>需要<strong>立即读取更新后的 DOM</strong>  （如计算元素尺寸）</li>\n<li>需要<strong>确保更新顺序</strong>  的特殊场景</li>\n<li>与某些第三方库集成时需要同步更新</li>\n</ul>\n<h2>基本用法</h2>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { flushSync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 常规更新（会被批处理）</span>\n  <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);\n  \n  <span class="hljs-comment">// 强制同步更新</span>\n  <span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-title function_">setFlag</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> !f); <span class="hljs-comment">// 这个更新会立即执行</span>\n  });\n  \n  <span class="hljs-comment">// 这里的DOM已经反映了flag的更新</span>\n}\n</code></pre>\n<h2>主要特点</h2>\n<ol>\n<li><strong>同步执行</strong>  ：<pre><code class="language-jsx"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Before&#x27;</span>);\n<span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">setState</span>(newValue);\n});\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;After&#x27;</span>); \n<span class="hljs-comment">// 保证在这时DOM已经更新</span>\n</code></pre>\n</li>\n<li><strong>中断批处理</strong>  ：<pre><code class="language-jsx"><span class="hljs-title function_">setState1</span>(a);       <span class="hljs-comment">// 批处理</span>\n<span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">setState2</span>(b);     <span class="hljs-comment">// 立即执行</span>\n});\n<span class="hljs-title function_">setState3</span>(c);       <span class="hljs-comment">// 新的批处理</span>\n</code></pre>\n</li>\n<li><strong>触发同步渲染</strong>  ：\n<ul>\n<li>会立即调用组件的render方法</li>\n<li>会立即执行副作用（如useLayoutEffect）</li>\n</ul>\n</li>\n</ol>\n<h2>使用场景示例</h2>\n<h3>场景1：测量DOM布局</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MeasureExample</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [width, setWidth] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);\n  <span class="hljs-keyword">const</span> divRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);\n\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">measure</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-comment">// 先强制渲染一些内容</span>\n      <span class="hljs-title function_">setShowContent</span>(<span class="hljs-literal">true</span>);\n    });\n    \n    <span class="hljs-comment">// 此时可以准确测量DOM</span>\n    <span class="hljs-keyword">const</span> rect = divRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">getBoundingClientRect</span>();\n    <span class="hljs-title function_">setWidth</span>(rect.<span class="hljs-property">width</span>);\n  };\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{divRef}</span>&gt;</span>\n      {showContent &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">ExpensiveComponent</span> /&gt;</span>}\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{measure}</span>&gt;</span>Measure<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h3>场景2：与第三方库集成</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">IntegrationExample</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);\n  <span class="hljs-keyword">const</span> editorRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);\n\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSave</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-comment">// 强制同步更新，确保第三方库获取最新值</span>\n    <span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-title function_">setValue</span>(editorRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">getValue</span>());\n    });\n    \n    <span class="hljs-comment">// 现在可以安全地使用更新后的value</span>\n    api.<span class="hljs-title function_">save</span>(value);\n  };\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThirdPartyEditor</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{editorRef}</span> /&gt;</span></span>;\n}\n</code></pre>\n<h2>注意事项</h2>\n<ol>\n<li><strong>性能影响</strong>  ：\n<ul>\n<li>频繁使用会显著降低应用性能</li>\n<li>破坏了React的批处理优化</li>\n<li>可能导致不必要的渲染</li>\n</ul>\n</li>\n<li><strong>使用限制</strong>  ：\n<ul>\n<li>不能在渲染过程中调用（即不能在组件函数体内直接调用）</li>\n<li>不能在类组件的生命周期方法中调用</li>\n<li>不能在<code>useMemo</code>、<code>useCallback</code>等hook中调用</li>\n</ul>\n</li>\n<li><strong>与并发特性的交互</strong>  ：\n<ul>\n<li>会暂时退出并发模式</li>\n<li>会阻止时间切片（time slicing）优化</li>\n</ul>\n</li>\n</ol>\n<h2>替代方案</h2>\n<p>在可能的情况下，优先考虑这些替代方案：</p>\n<ol>\n<li><strong>使用 <code>useLayoutEffect</code></strong>   读取DOM：<pre><code class="language-jsx"><span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> rect = ref.<span class="hljs-property">current</span>.<span class="hljs-title function_">getBoundingClientRect</span>();\n  <span class="hljs-comment">// 在这里处理测量结果</span>\n}, [deps]);\n</code></pre>\n</li>\n<li><strong>使用 <code>useSyncExternalStore</code></strong>   与外部存储集成</li>\n<li><strong>重新设计状态流</strong>  ，避免依赖同步更新</li>\n</ol>\n<h2>实现原理</h2>\n<p><code>flushSync</code> 的工作流程：</p>\n<ol>\n<li>暂停当前的批处理</li>\n<li>立即执行回调函数</li>\n<li>同步处理所有状态更新</li>\n<li>同步执行DOM更新</li>\n<li>恢复正常的批处理流程</li>\n</ol>\n<h2>错误用法示例</h2>\n<pre><code class="language-jsx"><span class="hljs-comment">// ❌ 错误：在渲染过程中调用</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">/* ... */</span> }); <span class="hljs-comment">// 会抛出错误</span>\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> /&gt;</span></span>;\n}\n\n<span class="hljs-comment">// ❌ 错误：在useMemo中调用</span>\n<span class="hljs-keyword">const</span> memoizedValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">/* ... */</span> }); <span class="hljs-comment">// 会抛出错误</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">computeExpensiveValue</span>(a, b);\n}, [a, b]);\n</code></pre>\n<h2>总结</h2>\n<p><code>flushSync</code> 是一个强大的逃生舱口（escape hatch），但应该极其谨慎地使用。在99%的情况下，你应该依赖React的自动批处理机制。只有在确实需要同步更新且没有其他解决方案时，才考虑使用<code>flushSync</code>。</p>\n</div>'</script></body></html>