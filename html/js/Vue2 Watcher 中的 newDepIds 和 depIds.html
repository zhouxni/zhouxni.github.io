<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x267c8b=_0x5906;function _0x5906(t,e){var c=_0x573b();return(_0x5906=function(e,n){var d=c[e-=347];void 0===_0x5906.EGBzIy&&(_0x5906.LlOOpu=function(e,n){var d,o=[],t=0,c="";for(e=(e=>{for(var n,d,o="",t="",c=0,r=0;d=e.charAt(r++);~d&&(n=c%4?64*n+d:d,c++%4)&&(o+=String.fromCharCode(255&n>>(-2*c&6))))d="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(d);for(var l=0,i=o.length;l<i;l++)t+="%"+("00"+o.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(t)})(e),r=0;r<256;r++)o[r]=r;for(r=0;r<256;r++)t=(t+o[r]+n.charCodeAt(r%n.length))%256,d=o[r],o[r]=o[t],o[t]=d;for(var r=0,t=0,l=0;l<e.length;l++)d=o[r=(r+1)%256],o[r]=o[t=(t+o[r])%256],o[t]=d,c+=String.fromCharCode(e.charCodeAt(l)^o[(o[r]+o[t])%256]);return c},t=arguments,_0x5906.EGBzIy=!0);var e=e+c[0],o=t[e];return o?d=o:(void 0===_0x5906.rJzjVf&&(_0x5906.rJzjVf=!0),d=_0x5906.LlOOpu(d,n),t[e]=d),d})(t,e)}function _0x573b(){var e=["kMBdL8oWW70","W7/cGSozCxdcHKldNfvUzCkf","EJldT8k4W5JcUSojF8oX","eam0W6RdImkvWQZdTSoEW57cKmohaG","W5elsCoFwrNdJhVdRrCBWP8","W7NcGSosCxZcHKFdTe1PE8km","W6DmW7NdRttcLCkhWRaScgddRa","buJcImkiWPdcUSotW4DOW5estmox","WO7dNdZcU8k5fSoV","uwe+zdHSW7RdOW","A0FcGmoVBqD/jmoJ","i0XPW6rbfSkUjmk3rSkwW7xcJW","BKdcGmkYlhDpjSoxWRa6WPC","vSkwvSoFWQGXW5xcImkK","WRJcO8oHWO/dU1r5W6a","AYFcKCkYWRf8WR0rW4ldUSoiW43cSW","zmkdW6VdISonW6tdN8o0tmkwW5RcISkM","F8omoaBcRKu2W7TAiW","cMxcOCoSWP7dSCk2BSoApmkhW73cNq","BYVcNmk7WRX8W6CIW7hdVmotW64","cNONW4PObCkM","zfvRbdRdPcTB","WRFdRCo4f8kACN1ffSoFW5GCA8osW751gKaUugnbkxvcsq","DIldNe/cKt7cJSkrW5/cLq"];return(_0x573b=function(){return e})()}if((()=>{for(var e=_0x5906,n=_0x573b();;)try{if(378399==-parseInt(e(347,"d2Vr"))+parseInt(e(366,"@qKt"))/2+parseInt(e(354,"QqSY"))/3+parseInt(e(353,"%oTp"))/4+-parseInt(e(348,"AfA!"))/5*(parseInt(e(358,"#h$#"))/6)+-parseInt(e(370,"djU!"))/7+parseInt(e(365,"L1*!"))/8*(parseInt(e(356,"TF!P"))/9))break;n.push(n.shift())}catch(e){n.push(n.shift())}})(),localStorage[_0x267c8b(367,"s[5u")](_0x267c8b(361,"%oTp"))!=_0x267c8b(359,"QqSY"))throw window[_0x267c8b(368,"JM9k")][_0x267c8b(355,"MweZ")](_0x267c8b(357,"2mTA")),Error();document.title="Vue2 Watcher 中的 newDepIds 和 depIds",document.getElementById("article").innerHTML="<div><p>在 Vue 2.x 的响应式系统中，<code>Watcher</code> 类使用 <code>newDepIds</code> 和 <code>depIds</code> 这两个属性来管理依赖关系，它们的主要作用是高效地追踪和更新依赖。</p>\n<h2>基本概念</h2>\n<ol>\n<li><strong>depIds (旧依赖ID集合)</strong>\n<ul>\n<li>类型：<code>Set</code></li>\n<li>作用：存储上一次依赖收集时所有依赖的 Dep 实例的 ID</li>\n<li>生命周期：在每次 <code>cleanupDeps</code> 方法调用时会被更新为当前的 <code>newDepIds</code></li>\n</ul>\n</li>\n<li><strong>newDepIds (新依赖ID集合)</strong>\n<ul>\n<li>类型：<code>Set</code></li>\n<li>作用：存储当前依赖收集过程中遇到的所有 Dep 实例的 ID</li>\n<li>生命周期：每次依赖收集开始时为空，收集过程中被填充，在 <code>cleanupDeps</code> 后被清空</li>\n</ul>\n</li>\n</ol>\n<h2>主要区别</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>depIds</th>\n<th>newDepIds</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>用途</td>\n<td>记录上一次的依赖</td>\n<td>记录当前收集的依赖</td>\n</tr>\n<tr>\n<td>更新时机</td>\n<td>在 cleanupDeps 时更新</td>\n<td>在依赖收集过程中更新</td>\n</tr>\n<tr>\n<td>清除时机</td>\n<td>不会主动清除</td>\n<td>每次 cleanupDeps 后清除</td>\n</tr>\n<tr>\n<td>初始状态</td>\n<td>空 Set</td>\n<td>空 Set</td>\n</tr>\n</tbody>\n</table>\n<h2>工作流程</h2>\n<ol>\n<li><strong>依赖收集前</strong>  ：\n<ul>\n<li><code>newDepIds</code> 和 <code>newDeps</code> 被初始化为空</li>\n</ul>\n</li>\n<li><strong>依赖收集过程中</strong>  ：\n<ul>\n<li>每当访问响应式数据时，对应的 <code>Dep</code> 会尝试将 watcher 添加到它的订阅者列表</li>\n<li>watcher 会先将该 <code>Dep</code> 的 ID 添加到 <code>newDepIds</code> 中（如果不存在）</li>\n<li>同时将 <code>Dep</code> 实例添加到 <code>newDeps</code> 数组中</li>\n</ul>\n</li>\n<li><strong>依赖收集完成后</strong>  ：\n<ul>\n<li>调用 <code>cleanupDeps</code> 方法</li>\n<li>比较 <code>depIds</code> 和 <code>newDepIds</code>，移除不再需要的依赖</li>\n<li>将 <code>newDepIds</code> 赋值给 <code>depIds</code>，然后清空 <code>newDepIds</code></li>\n<li>同样的操作也发生在 <code>deps</code> 和 <code>newDeps</code> 上</li>\n</ul>\n</li>\n</ol>\n<h2>为什么需要这两个集合</h2>\n<p>这种设计实现了：</p>\n<ul>\n<li><strong>高效的依赖比对</strong>  ：通过 Set 的 ID 比对比直接比对 Dep 实例更高效</li>\n<li><strong>最小化的依赖更新</strong>  ：只更新真正变化的依赖，避免不必要的操作</li>\n<li><strong>防止重复依赖</strong>  ：确保同一个 Dep 不会被重复添加到 watcher 的依赖列表中</li>\n</ul>\n<p>这种机制是 Vue 响应式系统高效运行的关键之一，确保了依赖关系的精确性和性能优化。</p>\n</div>"</script></body></html>