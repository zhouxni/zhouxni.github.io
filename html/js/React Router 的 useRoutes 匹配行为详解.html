<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x472f13=_0x1670;function _0x1670(t,s){var p=_0x365a();return(_0x1670=function(s,a){var n=p[s-=401];void 0===_0x1670.ytqmAC&&(_0x1670.ZrtFRD=function(s,a){var n,l=[],t=0,p="";for(s=(s=>{for(var a,n,l="",t="",p=0,e=0;n=s.charAt(e++);~n&&(a=p%4?64*a+n:n,p++%4)&&(l+=String.fromCharCode(255&a>>(-2*p&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,r=l.length;c<r;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+a.charCodeAt(e%a.length))%256,n=l[e],l[e]=l[t],l[t]=n;for(var e=0,t=0,c=0;c<s.length;c++)n=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=n,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[t])%256]);return p},t=arguments,_0x1670.ytqmAC=!0);var s=s+p[0],l=t[s];return l?n=l:(void 0===_0x1670.osmuiY&&(_0x1670.osmuiY=!0),n=_0x1670.ZrtFRD(n,a),t[s]=n),n})(t,s)}function _0x365a(){var s=["BmktW7G/W5mxj0BcShpdK8krkW","W4H9jmoeFSoCra","W498W51XW6G6WQZcVqZdOW","WRddO0WBwtG9W58pWPCweG","W6r2W7BcNmoFifRcIdZcTSoaW7TK","h8odWQ1TWPDDwwJcUa","WOCPgCoEWRhdIZDUWOzEW7qMW4dcKeVcOmoBicBcUmk5W53dTfbaW6i","s8kJWR8RtmkBWPVcTJTbWOdcKSkB","WPhdLCoHW6VcP3TtW6HDBMCWaq","zCk+t8oEWQ7cGuhcPSkRBmo7WPJdGG","kSo9WOSdWQRdQ1PIrwHI","W65ZWQ/dJ8kdwZVcOW","yCk4s8oAWQ7dKHdcQmk4Fmof","WORdMLj/wrhcJ8k2","W5DPa8ofWQJcVu8Y","WR5gW55ayG","rCkUW4OjW6ddJbuiW4pdL8oUW7JcUa","kmoQW4/cVmkAW4pdJ1uJW73dPMu","W5qeBJBcMSkPW5xcTSkisxuhWQ4","A8ohvKJdRSk8WO/dSItdJmkkmW","WP5yW5XIgKzvgmkXBa","WPhdLSoGW6lcPhWpW6r1s3Cl","WRWcWP3dSCoxW5FdKmoTW5T+WO8cxq","WRdcGKRcI0RcSdG"];return(_0x365a=function(){return s})()}if((()=>{for(var s=_0x1670,a=_0x365a();;)try{if(492523==+parseInt(s(409,"L#Qa"))+parseInt(s(412,"wH^("))/2+parseInt(s(414,"eL)D"))/3+-parseInt(s(418,")o!1"))/4+parseInt(s(411,"AjFk"))/5*(-parseInt(s(401,")o!1"))/6)+-parseInt(s(423,"5VEP"))/7+-parseInt(s(416,"JoD)"))/8*(-parseInt(s(424,"QYVx"))/9))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x472f13(415,"]DSN")](_0x472f13(419,"eL)D"))!=_0x472f13(405,"M!z!"))throw window[_0x472f13(403,"5NS!")][_0x472f13(413,"p13D")](_0x472f13(420,"(nr1")),Error();document.title="React Router 的 useRoutes 匹配行为详解",document.getElementById("article").innerHTML='<div><p><code>useRoutes</code> 是 React Router v6 中引入的核心路由匹配机制，它采用了一种不同于 v5 版本的匹配策略。下面我将全面解析它的匹配行为：</p>\n<h2>一、基本匹配规则</h2>\n<ol>\n<li><strong>顺序优先匹配</strong>  ：\n<ul>\n<li>路由按照配置数组的顺序依次匹配</li>\n<li>匹配到第一个符合条件的路由后立即停止</li>\n<li>这与 v5 的 <code>&lt;Switch&gt;</code> 行为类似</li>\n</ul>\n</li>\n<li><strong>路径匹配算法</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> routes = [\n  { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/products&#x27;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductList</span> /&gt;</span></span> },\n  { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/products/:id&#x27;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductDetail</span> /&gt;</span></span> },\n  { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/products/new&#x27;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NewProduct</span> /&gt;</span></span> }\n]\n</code></pre>\n<ul>\n<li><code>/products</code> → ProductList</li>\n<li><code>/products/123</code> → ProductDetail</li>\n<li><code>/products/new</code> → 如果放在最后会被当作 <code>:id</code> 匹配，因此应该放在 <code>:id</code> 前面</li>\n</ul>\n</li>\n</ol>\n<h2>二、匹配特性详解</h2>\n<h3>1. 动态参数匹配</h3>\n<pre><code class="language-javascript">{ <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;users/:userId&#x27;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserProfile</span> /&gt;</span></span> }\n</code></pre>\n<ul>\n<li>匹配 <code>/users/123</code>，可通过 <code>useParams()</code> 获取 <code>userId</code></li>\n</ul>\n<h3>2. 通配符匹配</h3>\n<pre><code class="language-javascript">{ <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;docs/*&#x27;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">DocsLayout</span> /&gt;</span></span> }\n</code></pre>\n<ul>\n<li>匹配 <code>/docs</code> 和所有 <code>/docs/...</code> 子路径</li>\n<li>剩余路径可通过 <code>useParams()[\'*\']</code> 获取</li>\n</ul>\n<h3>3. 精确匹配控制</h3>\n<ul>\n<li><strong>默认行为</strong>  ：自动识别是否需要&quot;精确&quot;匹配</li>\n<li><strong>强制匹配</strong>  ：添加结尾 <code>/*</code> 或使用 <code>index</code> 路由</li>\n</ul>\n<pre><code class="language-javascript">[\n  { <span class="hljs-attr">index</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Home</span> /&gt;</span></span> }, <span class="hljs-comment">// 精确匹配父路径</span>\n  { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;about&#x27;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">About</span> /&gt;</span></span> }\n]\n</code></pre>\n<h2>三、与 v5 的对比</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>v5 (Switch + Route)</th>\n<th>v6 (useRoutes)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>精确匹配</td>\n<td>需要 <code>exact</code> 属性</td>\n<td>自动智能判断</td>\n</tr>\n<tr>\n<td>匹配顺序</td>\n<td>按声明顺序</td>\n<td>按数组顺序</td>\n</tr>\n<tr>\n<td>404 处理</td>\n<td>最后一个无 path 的 Route</td>\n<td>通配符 <code>*</code> 路径</td>\n</tr>\n<tr>\n<td>嵌套路由</td>\n<td>嵌套 Route 组件</td>\n<td>使用 children 属性</td>\n</tr>\n</tbody>\n</table>\n<h2>四、高级匹配场景</h2>\n<h3>1. 布局路由</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> routes = [\n  {\n    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Layout</span> /&gt;</span></span>, <span class="hljs-comment">// 没有 path 属性</span>\n    <span class="hljs-attr">children</span>: [\n      { <span class="hljs-attr">index</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Home</span> /&gt;</span></span> },\n      { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;about&#x27;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">About</span> /&gt;</span></span> }\n    ]\n  }\n]\n</code></pre>\n<h3>2. 多重匹配</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 同时匹配多个路径</span>\n{ <span class="hljs-attr">path</span>: [<span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-string">&#x27;/welcome&#x27;</span>], <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Home</span> /&gt;</span></span> }\n</code></pre>\n<h3>3. 正则表达式匹配</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 使用 path-to-regexp 语法</span>\n{ <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/item/:id(\\\\d+)&#x27;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Item</span> /&gt;</span></span> } <span class="hljs-comment">// 只匹配数字ID</span>\n</code></pre>\n<h2>五、最佳实践建议</h2>\n<ol>\n<li><strong>路由排序原则</strong>  ：\n<ul>\n<li>具体路径在前，通用路径在后</li>\n<li>静态路径在前，动态路径在后</li>\n</ul>\n</li>\n<li><strong>性能优化</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 懒加载路由组件</span>\n{ <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;settings&#x27;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{...}</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Settings</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">React.Suspense</span>&gt;</span></span> }\n</code></pre>\n</li>\n<li><strong>类型安全</strong>  （TypeScript）：<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">RouteParams</span> {\n  <span class="hljs-attr">userId</span>: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">const</span> params = <span class="hljs-title function_">useParams</span>() <span class="hljs-keyword">as</span> <span class="hljs-title class_">RouteParams</span>;\n</code></pre>\n</li>\n</ol>\n<h2>六、常见问题解决方案</h2>\n<p><strong>问题1</strong>  ：如何确保 <code>/users</code> 不匹配 <code>/users/123</code>？</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 方案1：调整顺序 + 严格匹配</span>\n[\n  { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:id&#x27;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserDetail</span> /&gt;</span></span> },\n  { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserList</span> /&gt;</span></span>, <span class="hljs-attr">end</span>: <span class="hljs-literal">true</span> }\n]\n\n<span class="hljs-comment">// 方案2：使用布局路由</span>\n[\n  {\n    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users&#x27;</span>,\n    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserLayout</span> /&gt;</span></span>,\n    <span class="hljs-attr">children</span>: [\n      { <span class="hljs-attr">index</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserList</span> /&gt;</span></span> },\n      { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;:id&#x27;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserDetail</span> /&gt;</span></span> }\n    ]\n  }\n]\n</code></pre>\n<p><strong>问题2</strong>  ：如何实现权限路由？</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> routes = [\n  {\n    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/admin&#x27;</span>,\n    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RequireAuth</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;admin&quot;</span> /&gt;</span></span>,\n    <span class="hljs-attr">children</span>: [\n      { <span class="hljs-attr">index</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AdminDashboard</span> /&gt;</span></span> },\n      { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;users&#x27;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserManagement</span> /&gt;</span></span> }\n    ]\n  }\n]\n\n<span class="hljs-comment">// RequireAuth 组件实现认证逻辑</span>\n</code></pre>\n<p><code>useRoutes</code> 的这种设计使得路由配置更加声明式和可预测，同时也更易于维护和扩展。理解其匹配行为可以帮助开发者构建更健壮的路由系统。</p>\n</div>'</script></body></html>