<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x191a(){var t=["WRy9WQmMkSk5xr0","W7FcIWeIWPbqW6ldLw8oW7HRWO4","p8ovv8oBW70KWOK","WQ4+rv7dQ2ddMSoNW486wCojoW","WOddGComW5SWW4bSWOJcHa","WR/cImouWO1wWQOita","ubhcKh80W5DWz8opemkMs8o7","muGTWR/cT2LXW5K","W67dHmo0WQ52W5PRnmkrrSoJWO0lW4xcVHtcLSo0iLatWQm2W5KKwq","ASkjW7hdKXFdOdKUrCkdWRRdISoP","WQNcLd/dPCkwW59u","WRFcGSk5W6K9WOiuxCkbwCow","yXzcE8oEeeD/jCkpWRO","urdcK381W5eLFSoZkCk6Cq","WOm2eCkXcSoAt8ojWPTYW7hdIv0","WQdcPe3cU8oaASkYW5VcRvZdISkVnW","W6boEWvYW4agea","W7vzW69ju8obiq","W6r+qSkeW53cQbK","W7OpWRGBmmkZcKZcUSojeu8","jvDKWOVdIYVcPSks","t0BcQ8oUEu7dTW","rmoNWPOLbWulW77cQ8oqufZdUq","ifqeW6FcKNVdRSkBWOBdUCoBW4hdVa","W5qmWPv5qGP2cCktvCozzG","W5PZWOldLJRcTJ8","WOjKxmorvmkBmW","tCkYWPdcHtq","W6z4WQFcId/dIZe","W5yoWPP3ra5DemkpvmohqG"];return(_0x191a=function(){return t})()}var _0x3723f0=_0x2431;function _0x2431(o,t){var e=_0x191a();return(_0x2431=function(t,n){var d=e[t-=206];void 0===_0x2431.WubyAJ&&(_0x2431.kMPiSP=function(t,n){var d,r=[],o=0,e="";for(t=(t=>{for(var n,d,r="",o="",e=0,c=0;d=t.charAt(c++);~d&&(n=e%4?64*n+d:d,e++%4)&&(r+=String.fromCharCode(255&n>>(-2*e&6))))d="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(d);for(var s=0,a=r.length;s<a;s++)o+="%"+("00"+r.charCodeAt(s).toString(16)).slice(-2);return decodeURIComponent(o)})(t),c=0;c<256;c++)r[c]=c;for(c=0;c<256;c++)o=(o+r[c]+n.charCodeAt(c%n.length))%256,d=r[c],r[c]=r[o],r[o]=d;for(var c=0,o=0,s=0;s<t.length;s++)d=r[c=(c+1)%256],r[c]=r[o=(o+r[c])%256],r[o]=d,e+=String.fromCharCode(t.charCodeAt(s)^r[(r[c]+r[o])%256]);return e},o=arguments,_0x2431.WubyAJ=!0);var t=t+e[0],r=o[t];return r?d=r:(void 0===_0x2431.kqdauh&&(_0x2431.kqdauh=!0),d=_0x2431.kMPiSP(d,n),o[t]=d),d})(o,t)}if((()=>{for(var t=_0x2431,n=_0x191a();;)try{if(580885==+parseInt(t(206,"QO#J"))+parseInt(t(212,"(@dP"))/2*(parseInt(t(219,"PLPa"))/3)+parseInt(t(210,"49uY"))/4*(parseInt(t(225,"FoVH"))/5)+parseInt(t(209,"kViJ"))/6*(-parseInt(t(221,"3X5W"))/7)+parseInt(t(213,"G)vi"))/8*(-parseInt(t(224,"U]0M"))/9)+parseInt(t(223,"OmnQ"))/10*(parseInt(t(216,"Nx92"))/11)+-parseInt(t(220,"G)vi"))/12)break;n.push(n.shift())}catch(t){n.push(n.shift())}})(),localStorage[_0x3723f0(217,"xvsL")](_0x3723f0(211,"Uvu7"))!=_0x3723f0(234,"8Ec%"))throw window[_0x3723f0(207,"UWKF")][_0x3723f0(232,"E6VY")](_0x3723f0(215,"(@dP")),Error();document.title="React 与 Vue2 在虚拟 DOM 比较（diff）异同",document.getElementById("article").innerHTML="<div><p>下面把 React 与 Vue2 在<strong>虚拟 DOM 比较（diff）</strong>   这一层的异同<strong>逐条展开</strong>   ，从<strong>算法、数据结构、触发机制、性能策略、编译期优化</strong>   五个角度给出**“逐像素级”对比**   ，最后再用一张脑图式总结收尾，方便记忆。</p>\n<hr>\n<h2>1 算法核心思路</h2>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>React (Reconciler)</th>\n<th>Vue2 (Snabbdom 派生)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>遍历方向</strong></td>\n<td><strong>单端</strong>   ：从左到右的单指针遍历</td>\n<td><strong>双端</strong>   ：头→尾、尾→头双指针</td>\n</tr>\n<tr>\n<td><strong>时间复杂度</strong></td>\n<td>O(n)（理论最坏 O(n²) 但极少触发）</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td><strong>移动检测</strong></td>\n<td>用 <strong>lastPlacedIndex</strong>   记录“已遍历的最大位置”</td>\n<td>用 <strong>key → 旧节点索引映射表</strong>   直接定位</td>\n</tr>\n<tr>\n<td><strong>节点复用条件</strong></td>\n<td><code>type</code> + <code>key</code> <strong>两个条件</strong></td>\n<td><code>tag</code> + <code>key</code> + <code>isComment</code> + <code>data</code> + <code>asyncFactory</code> + <code>sameInputType</code> <strong>六个条件</strong></td>\n</tr>\n<tr>\n<td><strong>不可复用策略</strong></td>\n<td>直接卸载旧节点 → 创建新节点</td>\n<td>直接销毁 VNode → 创建新 VNode</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>2 数据结构差异</h2>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>React</th>\n<th>Vue2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>虚拟 DOM 单元</strong></td>\n<td><strong>ReactElement</strong>   → <strong>FiberNode</strong>   （双缓冲链表）</td>\n<td><strong>VNode</strong>   （纯对象，无链表）</td>\n</tr>\n<tr>\n<td><strong>key 位置</strong></td>\n<td><code>element.key</code></td>\n<td><code>vnode.key</code></td>\n</tr>\n<tr>\n<td><strong>type 含义</strong></td>\n<td><strong>组件构造函数</strong>   （函数/类）或字符串标签</td>\n<td><strong>字符串标签</strong>   或 <strong>组件构造函数</strong></td>\n</tr>\n<tr>\n<td><strong>children 形态</strong></td>\n<td><strong>扁平数组</strong>   （<code>props.children</code>）</td>\n<td><strong>数组</strong>   或 <strong>单个 VNode/string</strong></td>\n</tr>\n<tr>\n<td><strong>diff 入口</strong></td>\n<td><code>reconcileChildrenArray</code> / <code>reconcileChildrenIterator</code></td>\n<td><code>updateChildren</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>3 触发机制（什么时候 diff）</h2>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>React</th>\n<th>Vue2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>驱动方式</strong></td>\n<td><strong>setState → 调度器 → Fiber 工作循环</strong></td>\n<td><strong>响应式系统 → watcher → patch</strong></td>\n</tr>\n<tr>\n<td><strong>更新粒度</strong></td>\n<td><strong>组件级</strong>   （整棵子树重新 render）</td>\n<td><strong>属性级</strong>   （仅收集到依赖的 watcher 触发）</td>\n</tr>\n<tr>\n<td><strong>异步 / 批量</strong></td>\n<td><strong>Fiber 时间切片</strong>   （Concurrent）</td>\n<td><strong>微任务队列批量</strong>   （nextTick）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>4 性能策略</h2>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>React</th>\n<th>Vue2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>列表 key 警告</strong></td>\n<td>开发环境显式 warning</td>\n<td>开发环境 warning</td>\n</tr>\n<tr>\n<td><strong>编译期静态标记</strong></td>\n<td><strong>无</strong>   （React 16 以前）</td>\n<td><strong>有</strong>   ：<code>isStatic</code>、<code>isOnce</code>、<code>isCloned</code></td>\n</tr>\n<tr>\n<td><strong>跳过子树</strong></td>\n<td><strong>React.memo / PureComponent</strong>   （手动）</td>\n<td><strong>编译期自动</strong>   标记静态节点，diff 时直接跳过</td>\n</tr>\n<tr>\n<td><strong>事件代理</strong></td>\n<td><strong>顶层统一代理</strong>   （document 或 root）</td>\n<td><strong>VNode 级别绑定</strong>   （编译期生成）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>5 代码级流程对照</h2>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>React 代码位置</th>\n<th>Vue2 代码位置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>首次挂载</td>\n<td><code>createInstance</code> → <code>mountComponent</code> → <code>render</code> → <code>reconcile</code></td>\n<td><code>_init</code> → <code>$mount</code> → <code>render</code> → <code>patch</code></td>\n</tr>\n<tr>\n<td>diff 入口</td>\n<td><code>reconcileChildren</code> (<code>ReactChildFiber.js</code>)</td>\n<td><code>updateChildren</code> (<code>patch.js</code>)</td>\n</tr>\n<tr>\n<td>单节点 patch</td>\n<td><code>reconcileSingleElement</code></td>\n<td><code>patchVnode</code></td>\n</tr>\n<tr>\n<td>多节点 patch</td>\n<td><code>reconcileChildrenArray</code></td>\n<td><code>updateChildren</code></td>\n</tr>\n<tr>\n<td>节点复用判断</td>\n<td><code>type === existing.type &amp;&amp; key === existing.key</code></td>\n<td><code>sameVnode(a, b)</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>6 脑图式一句话总结</h2>\n<blockquote>\n<p>React 是 <strong>单端遍历 + 整组件重渲染 + 手动优化</strong>   ；<br>\nVue2 是 <strong>双端遍历 + 依赖追踪细粒度 + 编译期静态优化</strong>   。</p>\n</blockquote>\n<hr>\n<h2>7 速查表（面试 10 秒回答版）</h2>\n<table>\n<thead>\n<tr>\n<th>问题</th>\n<th>React</th>\n<th>Vue2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>遍历方式</td>\n<td>单指针从左到右</td>\n<td>双端指针</td>\n</tr>\n<tr>\n<td>复用条件</td>\n<td>type + key</td>\n<td>6 项</td>\n</tr>\n<tr>\n<td>更新粒度</td>\n<td>组件级</td>\n<td>属性级</td>\n</tr>\n<tr>\n<td>静态节点优化</td>\n<td>手动 memo</td>\n<td>编译期自动跳过</td>\n</tr>\n<tr>\n<td>触发机制</td>\n<td>setState → 调度器</td>\n<td>响应式 → watcher</td>\n</tr>\n</tbody>\n</table>\n<p>把这张表背下来，<strong>面试问到“虚拟 DOM diff 异同”</strong>   就能 30 秒答完。</p>\n</div>"</script></body></html>