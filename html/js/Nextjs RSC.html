<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5d7e51=_0x31a4;function _0x31a4(l,s){var p=_0x3a6b();return(_0x31a4=function(s,n){var a=p[s-=235];void 0===_0x31a4.aXtkeV&&(_0x31a4.agmIkl=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=t.length;c<r;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,c=0;c<s.length;c++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(c)^t[(t[e]+t[l])%256]);return p},l=arguments,_0x31a4.aXtkeV=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x31a4.RwvPxp&&(_0x31a4.RwvPxp=!0),a=_0x31a4.agmIkl(a,n),l[s]=a),a})(l,s)}function _0x3a6b(){var s=["W7z8Emozu8oDW6ziWO44","W7H4WRfMWRGqW4/cOXSnxa","oSkOW53cLbHBWRq","W45EyqLbW4biWP10WRyeW40","FdVcICk0WRjxW5JcVhGoqslcLq","WQ1hqgHPjv4","BZFcGmkfimkhWR01u8ok","jbemv8kVmCkU","W4RdOSkjaZJdG8o1oN5knSkiW7S","WPxdP8kFW7BcTsxcJs0","WQCceW02sJBdIXXAxCkXWR8","WO7cRCkZWO3cMdHOCSkaj8kHdCkL","W5fqW4hcTWLWWRK","WPu4e2pdVbldPq","d8kIm8kkW6tcJZeWn3dcJL/cMq","uqG+wCk+iCkNW7ep","eg9PWROfW5TucSozWQThWQG","v8ohW78rjJfjWPJcVCkJWPdcKG","WRhcQmk/WPZcKCk1Ea","WQaheamZqMpdIXT3CSk7","W4WQW6pdIua","wYvaW6jcFmoOhauTWRNcUCkd","W7r8FCoFmCkUWRfTWRORm8kUWQy","DgScWRBdPCoMW7jiWPudfG12","FtRcJCkXWRSHWOlcKeiMtW","WOVdMCozA2NcR3i","xuWKow1YWPi","W5/dSwNdOb1vxmkpW5bIWRZdQKNdP8khomkFWRBcHCkvW5WoWQxdR8oKbG"];return(_0x3a6b=function(){return s})()}if((()=>{for(var s=_0x31a4,n=_0x3a6b();;)try{if(417261==-parseInt(s(240,"3n98"))*(-parseInt(s(246,"7J!H"))/2)+parseInt(s(237,"QiBF"))/3+-parseInt(s(250,"L1h1"))/4*(-parseInt(s(236,"!ygI"))/5)+-parseInt(s(257,"GlL6"))/6+-parseInt(s(253,"dpu#"))/7*(-parseInt(s(255,"Igfh"))/8)+-parseInt(s(262,"dpu#"))/9+parseInt(s(249,"E9Uj"))/10*(-parseInt(s(244,"IuCZ"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5d7e51(261,"*Kqr")](_0x5d7e51(258,"L1h1"))!=_0x5d7e51(235,"9thy"))throw window[_0x5d7e51(252,"V^E8")][_0x5d7e51(241,"3ipd")](_0x5d7e51(242,"WMOd")),Error();document.title="Nextjs RSC",document.getElementById("article").innerHTML='<div><p><strong>RSC（React Server Components）</strong>   是 React 18 引入的一种<strong>服务端优先</strong>   的组件模型，专为现代全栈框架（如 Next.js App Router）设计。它颠覆了传统 React 的客户端渲染模式，通过服务端直接生成静态或动态的组件输出。以下是深度解析：</p>\n<hr>\n<h3>一、RSC 的核心特性</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>服务端执行</strong></td>\n<td>组件代码仅在服务端运行，不发送到客户端</td>\n</tr>\n<tr>\n<td><strong>零客户端体积</strong></td>\n<td>不增加 JS Bundle 大小，提升加载速度</td>\n</tr>\n<tr>\n<td><strong>直接访问后端资源</strong></td>\n<td>可直接操作数据库、调用 API 或读取文件系统</td>\n</tr>\n<tr>\n<td><strong>自动代码分割</strong></td>\n<td>仅动态导入客户端所需代码（如交互性组件）</td>\n</tr>\n<tr>\n<td><strong>流式渲染</strong></td>\n<td>支持渐进式传输 HTML，提升首屏性能</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>二、与传统 CSR（客户端组件）的区别</h3>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>RSC (服务端组件)</th>\n<th>CSR (客户端组件)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>执行环境</strong></td>\n<td>仅服务端</td>\n<td>浏览器</td>\n</tr>\n<tr>\n<td><strong>JS 体积</strong></td>\n<td>0 KB</td>\n<td>包含组件逻辑 + 依赖</td>\n</tr>\n<tr>\n<td><strong>数据获取</strong></td>\n<td>直接 <code>await</code> 数据库/API</td>\n<td>需通过 <code>fetch</code> 或 <code>useEffect</code></td>\n</tr>\n<tr>\n<td><strong>DOM 操作</strong></td>\n<td>无法使用 <code>useEffect</code>/<code>onClick</code></td>\n<td>支持完整 React 生命周期</td>\n</tr>\n<tr>\n<td><strong>使用场景</strong></td>\n<td>静态内容、SEO 关键部分</td>\n<td>交互元素（按钮、表单、动画）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>三、RSC 的工作原理</h3>\n<h4>1. <strong>编译阶段</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 服务端组件（RSC）</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ServerComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">query</span>(); <span class="hljs-comment">// 直接访问数据库</span>\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{data}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n\n<span class="hljs-comment">// 编译后输出：</span>\n<span class="hljs-comment">// - 服务端：生成静态 HTML + 动态数据插槽</span>\n<span class="hljs-comment">// - 客户端：仅接收渲染结果，无组件代码</span>\n</code></pre>\n<h4>2. <strong>运行时数据流</strong></h4>\n<pre><code class="language-mermaid">sequenceDiagram\n  浏览器-&gt;&gt;服务端: 请求页面\n  服务端-&gt;&gt;数据库: 查询数据\n  服务端-&gt;&gt;浏览器: 返回 HTML + 客户端组件占位符\n  浏览器-&gt;&gt;服务端: 请求客户端组件 JS\n  服务端-&gt;&gt;浏览器: 返回交互逻辑\n</code></pre>\n<hr>\n<h3>四、RSC 在 Next.js 中的使用</h3>\n<h4>1. <strong>默认行为</strong></h4>\n<p>Next.js App Router 中所有组件<strong>默认为 RSC</strong>   ，除非明确标记 <code>\'use client\'</code>：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/page.js (RSC)</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchPosts</span>(); <span class="hljs-comment">// 服务端直接获取数据</span>\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">PostList</span> <span class="hljs-attr">posts</span>=<span class="hljs-string">{posts}</span> /&gt;</span></span>;\n}\n\n<span class="hljs-comment">// app/PostList.js (客户端组件)</span>\n<span class="hljs-string">&#x27;use client&#x27;</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">PostList</span>(<span class="hljs-params">{ posts }</span>) {\n  <span class="hljs-keyword">const</span> [liked, setLiked] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 需要交互</span>\n  <span class="hljs-keyword">return</span> posts.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">post</span> =&gt;</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{post.id}</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{post.title}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setLiked(!liked)}&gt;\n        {liked ? &#x27;❤️&#x27; : &#x27;♡&#x27;}\n      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span></span>\n  ));\n}\n</code></pre>\n<h4>2. <strong>混合渲染模式</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/layout.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Layout</span>(<span class="hljs-params">{ children }</span>) {\n  <span class="hljs-comment">// RSC 部分：服务端获取用户信息</span>\n  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUser</span>();\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">Navbar</span> <span class="hljs-attr">user</span>=<span class="hljs-string">{user}</span> /&gt;</span> {/* RSC */}\n        <span class="hljs-tag">&lt;<span class="hljs-name">ClientProvider</span>&gt;</span> {/* 客户端边界 */}\n          {children} {/* 可能是 RSC 或 CSR */}\n        <span class="hljs-tag">&lt;/<span class="hljs-name">ClientProvider</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<hr>\n<h3>五、RSC 的三大优势</h3>\n<ol>\n<li>\n<p><strong>性能优化</strong></p>\n<ul>\n<li>减少 60-70% 的客户端 JS 体积（Vercel 实测数据）</li>\n<li>流式传输允许优先渲染关键路径</li>\n</ul>\n</li>\n<li>\n<p><strong>简化数据获取</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 直接服务端操作（无需 API 层）</span>\n<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> db.<span class="hljs-property">user</span>.<span class="hljs-title function_">findUnique</span>({ <span class="hljs-attr">where</span>: { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> } });\n</code></pre>\n</li>\n<li>\n<p><strong>安全增强</strong></p>\n<ul>\n<li>敏感逻辑（如数据库凭证）不会泄露到客户端</li>\n<li>自动防止 XSS（组件输出默认转义）</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>六、使用限制与解决方案</h3>\n<table>\n<thead>\n<tr>\n<th>限制</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>无浏览器 API</strong></td>\n<td>将相关逻辑移至客户端组件（<code>\'use client\'</code>）</td>\n</tr>\n<tr>\n<td><strong>无 React 状态</strong></td>\n<td>使用 URL 状态或通过 props 传递客户端组件</td>\n</tr>\n<tr>\n<td><strong>无 Context</strong></td>\n<td>在客户端边界外层提供 Context</td>\n</tr>\n<tr>\n<td><strong>无 useEffect</strong></td>\n<td>数据变更通过路由刷新或 Server Actions</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>七、实战示例：带评论的博客</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/blog/[slug]/page.js (RSC)</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{ params }</span>) {\n  <span class="hljs-keyword">const</span> post = <span class="hljs-keyword">await</span> db.<span class="hljs-property">post</span>.<span class="hljs-title function_">findUnique</span>({\n    <span class="hljs-attr">where</span>: { <span class="hljs-attr">slug</span>: params.<span class="hljs-property">slug</span> },\n    <span class="hljs-attr">include</span>: { <span class="hljs-attr">comments</span>: <span class="hljs-literal">true</span> }\n  });\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{post.title}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">MarkdownRenderer</span> <span class="hljs-attr">content</span>=<span class="hljs-string">{post.content}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">CommentSection</span> <span class="hljs-attr">comments</span>=<span class="hljs-string">{post.comments}</span> /&gt;</span> {/* 客户端组件 */}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-comment">// app/CommentSection.js (CSR)</span>\n<span class="hljs-string">&#x27;use client&#x27;</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">CommentSection</span>(<span class="hljs-params">{ comments }</span>) {\n  <span class="hljs-keyword">const</span> [newComment, setNewComment] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">submit</span> = (<span class="hljs-params"></span>) =&gt; { <span class="hljs-comment">/* 提交到 API 路由 */</span> };\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>\n      {comments.map(c =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">Comment</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{c.id}</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{c}</span> /&gt;</span>)}\n      <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{newComment}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{e</span> =&gt;</span> setNewComment(e.value)} /&gt;\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{submit}</span>&gt;</span>发送<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<hr>\n<h3>八、学习路径推荐</h3>\n<ol>\n<li>官方文档：https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components</li>\n<li>Next.js 实战：https://nextjs.org/docs/app/building-your-application/rendering/server-components</li>\n<li>深度解析：https://github.com/reactwg/server-components/discussions/5</li>\n</ol>\n<hr>\n<p>RSC 代表了 React 生态向服务端优先架构的转型，与 Next.js App Router 深度集成后，开发者能以更低的复杂度实现更高的性能。关键在于合理划分服务端与客户端边界，最大化利用两者的优势。</p>\n</div>'</script></body></html>