<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1c3fdc=_0xa02b;if((()=>{for(var s=_0xa02b,n=_0x58f8();;)try{if(226194==-parseInt(s(139,"SUz]"))+parseInt(s(134,"ZmrJ"))/2+parseInt(s(136,"nTcj"))/3+parseInt(s(141,"b]N]"))/4*(parseInt(s(129,"1osP"))/5)+parseInt(s(130,"XBV#"))/6*(-parseInt(s(144,"pbep"))/7)+parseInt(s(137,"%FPM"))/8*(parseInt(s(135,"NFHN"))/9)+-parseInt(s(150,"BJ6T"))/10*(parseInt(s(128,"%FPM"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1c3fdc(149,"x^4I")](_0x1c3fdc(138,"1osP"))!=_0x1c3fdc(133,"(nkX"))throw window[_0x1c3fdc(126,"##iM")][_0x1c3fdc(145,"P4@j")](_0x1c3fdc(140,"NFHN")),Error();function _0xa02b(l,s){var p=_0x58f8();return(_0xa02b=function(s,n){var a=p[s-=124];void 0===_0xa02b.JPstzC&&(_0xa02b.JwWBdk=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=t.length;c<o;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,c=0;c<s.length;c++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(c)^t[(t[e]+t[l])%256]);return p},l=arguments,_0xa02b.JPstzC=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0xa02b.VjKNEc&&(_0xa02b.VjKNEc=!0),a=_0xa02b.JwWBdk(a,n),l[s]=a),a})(l,s)}function _0x58f8(){var s=["p8knhLXnwmkjW6a","F03cPspdUsHT","dmo6ktSwW4FdIuS0WR0O","W5uJyt7dK8oLaJBdP34ypq","W5bKWPpdRqtdOmo6W7ldNSkW","tCkrjXRcGNn1WQ4hqSkZWRyj","W5WfW54Eq2C/Ca","W4JdUmkltK7dO0HGW4xcP8kk","W59sWPLcENFcNw3cUSoK","W6TiWOSaW57cUSkfWOP/WQG9","hHXdmHpdJXRdK0VdRa","EhBdLx7cQhWJrMJdS8kKvW","W61dWOObW57dTmkMWP9KWRW0WR4","WPmMW5pcRW0","ztldJSk5wSkcWQtcHmonWRPOW6O","eCosW4xdGI/dOfnJW4xdKw1w","umkNBSoaW43dLxPPWRpcRIrkWP4","W5LuW6yfygtcPLS","WPGtW55uWPJcV8kOWP9P","sxVdK8oYW7ddSmkbv8ouamkrW6i","qmkuWOdcIMZdRqq6W4JdVhzwnSouWOf5sXmFW6r4rG3cTmodW4q","uItdHc1bW5ddRCkxW4y","WQtdICosW7yzACoYfSoxW4W","W7qEjfSwwSkOWPHTct0","W7rXWPBcJCkUeW84fWK","WRKJW5tcRqKFoW","W43dJZiCW4VdTcFcSmo/WQK","WOfCWOKhrKacumke"];return(_0x58f8=function(){return s})()}document.title="EventSource 详解",document.getElementById("article").innerHTML='<div><p>好的，我们来对 <strong>EventSource</strong>   进行非常详细的解读。它是浏览器端用于接收 Server-Sent Events (SSE) 流的核心 API。</p>\n<hr>\n<h3>一、EventSource 是什么？</h3>\n<p><code>EventSource</code> 是一个内建的浏览器 JavaScript 接口（所有现代浏览器都支持），用于客户端与服务器的<strong>单向持久连接</strong>   。它允许客户端打开一个到服务器的 HTTP 连接，并接收服务器发送的<strong>事件流</strong>   （event stream），而无需轮询或手动刷新页面。</p>\n<p>它的设计目的非常纯粹：<strong>高效、简单地处理从服务器到客户端的文本数据流</strong>   。</p>\n<h3>二、核心特性与优势</h3>\n<ol>\n<li><strong>极简API</strong>   ：只需几行代码即可建立连接并开始接收数据。</li>\n<li><strong>自动重连</strong>   ：如果连接意外断开，<code>EventSource</code> 会自动尝试重新连接。你可以通过服务器发送 <code>retry</code> 字段来控制重连间隔。</li>\n<li><strong>消息ID追踪</strong>   ：通过 <code>id</code> 字段，客户端可以在重连后告诉服务器最后收到的消息ID，确保消息不会丢失或重复。</li>\n<li><strong>事件分类</strong>   ：可以监听不同“类型”的事件（如 <code>message</code>, <code>error</code>, 或自定义事件），从而对不同的数据流进行不同的处理。</li>\n<li><strong>基于HTTP</strong>   ：无需特殊协议，兼容性好，易于调试（可以在浏览器网络面板中看到事件流）。</li>\n</ol>\n<h3>三、如何使用 EventSource</h3>\n<h4>1. 创建连接</h4>\n<p>使用 <code>EventSource</code> 构造函数创建一个新的连接实例。第一个参数是服务器SSE端点的URL。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 连接到提供SSE的服务器端点</span>\n<span class="hljs-keyword">const</span> eventSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">&quot;https://api.yoursite.com/chat-stream&quot;</span>);\n\n<span class="hljs-comment">// 如果需要携带认证信息（如Cookie），需要设置 withCredentials</span>\n<span class="hljs-comment">// const eventSource = new EventSource(&#x27;https://api.yoursite.com/chat-stream&#x27;, { withCredentials: true });</span>\n</code></pre>\n<h4>2. 监听事件</h4>\n<p>建立连接后，最主要的工作就是监听来自服务器的不同事件。</p>\n<p><strong>a) 监听默认的 <code>message</code> 事件</strong><br>\n当服务器发送的数据没有指定 <code>event</code> 字段，或 <code>event</code> 字段为 <code>message</code> 时，会触发此事件。</p>\n<pre><code class="language-javascript">eventSource.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-comment">// 服务器发送的数据存储在 event.data 中</span>\n  <span class="hljs-keyword">const</span> data = event.<span class="hljs-property">data</span>;\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到消息:&quot;</span>, data);\n  <span class="hljs-comment">// 通常在这里更新UI，比如将数据追加到聊天窗口</span>\n  <span class="hljs-title function_">appendToChatWindow</span>(data);\n};\n</code></pre>\n<p><strong>b) 监听自定义事件</strong><br>\n服务器可以通过 <code>event: &lt;eventName&gt;</code> 指定事件类型。客户端使用 <code>addEventListener</code> 来监听这些特定事件。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 假设服务器发送了： event: close\\ndata: [DONE]\\n\\n</span>\neventSource.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;流结束:&quot;</span>, event.<span class="hljs-property">data</span>); <span class="hljs-comment">// 输出: 流结束: [DONE]</span>\n  eventSource.<span class="hljs-title function_">close</span>(); <span class="hljs-comment">// 手动关闭连接</span>\n});\n\n<span class="hljs-comment">// 监听一个自定义的 &#x27;update&#x27; 事件</span>\neventSource.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;update&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> status = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(event.<span class="hljs-property">data</span>); <span class="hljs-comment">// 数据可以是JSON字符串</span>\n  <span class="hljs-title function_">updateProgressBar</span>(status.<span class="hljs-property">progress</span>);\n});\n</code></pre>\n<h4>3. 处理错误和连接状态</h4>\n<p><code>EventSource</code> 有一个内置的 <code>onerror</code> 回调函数，用于处理连接错误。</p>\n<pre><code class="language-javascript">eventSource.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;EventSource 连接错误:&quot;</span>, error);\n  <span class="hljs-comment">// 注意：EventSource 在遇到错误（如网络中断）时会自动尝试重连。</span>\n  <span class="hljs-comment">// 这个回调可能会在每次重连尝试失败时被调用。</span>\n};\n</code></pre>\n<p>你可以通过检查 <code>readyState</code> 属性来获取连接的当前状态：</p>\n<pre><code class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventSource.<span class="hljs-property">readyState</span>); <span class="hljs-comment">// 0: CONNECTING, 1: OPEN, 2: CLOSED</span>\n</code></pre>\n<h4>4. 关闭连接</h4>\n<p>当不再需要接收消息时（例如组件卸载、用户离开页面），<strong>必须手动关闭连接</strong>   以释放资源。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 关闭连接，且不会自动重连</span>\neventSource.<span class="hljs-title function_">close</span>();\n</code></pre>\n<hr>\n<h3>四、一个完整的实战示例：AI聊天界面</h3>\n<p>假设我们有一个AI聊天后端，它通过SSE流式返回AI的响应。</p>\n<p><strong>HTML:</strong></p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;chatbox&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;messages&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;输入你的问题...&quot;</span> /&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;sendMessage()&quot;</span>&gt;</span>发送<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n<p><strong>JavaScript:</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> es = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 全局存储 EventSource 实例</span>\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> userInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;input&quot;</span>).<span class="hljs-property">value</span>;\n  <span class="hljs-keyword">if</span> (!userInput) <span class="hljs-keyword">return</span>;\n\n  <span class="hljs-comment">// 1. 先通过普通API发送用户消息到后端，后端会创建SSE连接</span>\n  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/chat&quot;</span>, {\n    <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,\n    <span class="hljs-attr">headers</span>: { <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span> },\n    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">message</span>: userInput, <span class="hljs-attr">sessionId</span>: <span class="hljs-title function_">getSessionId</span>() }),\n  }).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {\n    <span class="hljs-comment">// 2. 假设后端返回201 Created，并开始通过SSE流式返回AI答案</span>\n    <span class="hljs-comment">// 现在我们创建EventSource连接来接收这个流</span>\n    <span class="hljs-title function_">setupEventSource</span>();\n  });\n\n  <span class="hljs-comment">// 清空输入框</span>\n  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;input&quot;</span>).<span class="hljs-property">value</span> = <span class="hljs-string">&quot;&quot;</span>;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">setupEventSource</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 关闭已有的连接（如果存在）</span>\n  <span class="hljs-keyword">if</span> (es) {\n    es.<span class="hljs-title function_">close</span>();\n  }\n\n  <span class="hljs-comment">// 创建新的连接，URL中可能包含一个唯一的ID来标识这个特定的聊天流</span>\n  es = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">&quot;/api/chat-stream?sessionId=&quot;</span> + <span class="hljs-title function_">getSessionId</span>());\n\n  <span class="hljs-comment">// 监听默认的message事件，接收AI返回的文本流</span>\n  es.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n    <span class="hljs-comment">// event.data 是AI返回的一个词或一段话</span>\n    <span class="hljs-comment">// 这里实现“打字机效果”：逐字追加</span>\n    <span class="hljs-title function_">appendToChatWindow</span>(<span class="hljs-string">&quot;AI&quot;</span>, event.<span class="hljs-property">data</span>);\n  };\n\n  <span class="hljs-comment">// 监听自定义的 &#x27;end&#x27; 事件，表示流已结束</span>\n  es.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n    <span class="hljs-title function_">appendToChatWindow</span>(<span class="hljs-string">&quot;AI&quot;</span>, <span class="hljs-string">&quot;[对话结束]&quot;</span>);\n    es.<span class="hljs-title function_">close</span>(); <span class="hljs-comment">// 流结束，关闭连接</span>\n    es = <span class="hljs-literal">null</span>;\n  });\n\n  <span class="hljs-comment">// 错误处理</span>\n  es.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;SSE Error:&quot;</span>, error);\n    <span class="hljs-comment">// 可以根据错误类型进行UI提示</span>\n    <span class="hljs-title function_">appendToChatWindow</span>(<span class="hljs-string">&quot;System&quot;</span>, <span class="hljs-string">&quot;连接出现异常，正在重试...&quot;</span>);\n  };\n}\n\n<span class="hljs-comment">// 辅助函数：将消息追加到聊天窗口</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">appendToChatWindow</span>(<span class="hljs-params">sender, text</span>) {\n  <span class="hljs-keyword">const</span> messagesDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;messages&quot;</span>);\n  <span class="hljs-comment">// 简化实现：实际项目中应该更优雅地处理追加逻辑</span>\n  messagesDiv.<span class="hljs-property">innerHTML</span> += <span class="hljs-string">`&lt;p&gt;&lt;b&gt;<span class="hljs-subst">${sender}</span>:&lt;/b&gt; <span class="hljs-subst">${text}</span>&lt;/p&gt;`</span>;\n  messagesDiv.<span class="hljs-property">scrollTop</span> = messagesDiv.<span class="hljs-property">scrollHeight</span>; <span class="hljs-comment">// 滚动到底部</span>\n}\n\n<span class="hljs-comment">// 辅助函数：获取或生成会话ID</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">getSessionId</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// ... 从LocalStorage获取或生成新ID的逻辑</span>\n}\n</code></pre>\n<h3>五、注意事项与局限性</h3>\n<ol>\n<li><strong>单向通信</strong>   ：<code>EventSource</code> 只能接收数据，不能发送。发送数据需通过普通的 <code>fetch</code> 或 <code>XMLHttpRequest</code>。</li>\n<li><strong>仅文本协议</strong>   ：它设计用于传输文本数据（UTF-8）。二进制数据需要编码为Base64等文本格式，效率较低。</li>\n<li><strong>最大并发连接数</strong>   ：浏览器对到同一域名的HTTP连接数有限制（通常为6个）。过多的SSE连接可能会阻塞其他资源加载。</li>\n<li><strong>CORS限制</strong>   ：与所有跨域请求一样，SSE也受到同源策略的约束，需要服务器设置正确的CORS头（如 <code>Access-Control-Allow-Origin</code>）。</li>\n</ol>\n<p><strong>总结</strong>   ：<code>EventSource</code> 是一个强大而简单的工具，非常适合需要<strong>从服务器实时接收文本数据</strong>   的场景，如实时通知、日志流、股票行情和<strong>AI聊天对话</strong>   。它的自动重连机制和简洁API大大降低了开发实时应用的复杂度。</p>\n</div>'</script></body></html>