<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x42a185=_0x389b;if((()=>{for(var e=_0x389b,s=_0x5680();;)try{if(923767==+parseInt(e(279,"8c@6"))+parseInt(e(282,"uxwt"))/2+parseInt(e(270,"xXT["))/3*(-parseInt(e(272,"#3*5"))/4)+parseInt(e(271,"D#n6"))/5+parseInt(e(280,"^X0G"))/6+-parseInt(e(267,"4gHg"))/7+-parseInt(e(275,"uxwt"))/8)break;s.push(s.shift())}catch(e){s.push(s.shift())}})(),localStorage[_0x42a185(281,"j]6R")](_0x42a185(265,"uxwt"))!=_0x42a185(278,"#3*5"))throw window[_0x42a185(273,"]NTl")][_0x42a185(283,"6G[X")](_0x42a185(269,"!B!p")),Error();function _0x389b(t,e){var a=_0x5680();return(_0x389b=function(e,s){var n=a[e-=264];void 0===_0x389b.VGicaJ&&(_0x389b.BBUQzs=function(e,s){var n,o=[],t=0,a="";for(e=(e=>{for(var s,n,o="",t="",a=0,c=0;n=e.charAt(c++);~n&&(s=a%4?64*s+n:n,a++%4)&&(o+=String.fromCharCode(255&s>>(-2*a&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var r=0,l=o.length;r<l;r++)t+="%"+("00"+o.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(t)})(e),c=0;c<256;c++)o[c]=c;for(c=0;c<256;c++)t=(t+o[c]+s.charCodeAt(c%s.length))%256,n=o[c],o[c]=o[t],o[t]=n;for(var c=0,t=0,r=0;r<e.length;r++)n=o[c=(c+1)%256],o[c]=o[t=(t+o[c])%256],o[t]=n,a+=String.fromCharCode(e.charCodeAt(r)^o[(o[c]+o[t])%256]);return a},t=arguments,_0x389b.VGicaJ=!0);var e=e+a[0],o=t[e];return o?n=o:(void 0===_0x389b.rSUTPC&&(_0x389b.rSUTPC=!0),n=_0x389b.BBUQzs(n,s),t[e]=n),n})(t,e)}function _0x5680(){var e=["W7HgWPFcUmkEW65grCkJW6/dSvGA","thNcJLVcTCo8d8o1ca","tCo2sxBcHLi+","q8oVWO/cLbldUmozW6Tif8k3W6SR","W5uuW6FcKSoPW5tdS8osW57cPZhcHq","WP9apcFcTmkOWRiMn8opiCoIW7dcTmoSW7D+WRyvWPtdUdJcQb1wW5u","eCo0W57dT8ouD8oc","W5NdQmoKAKnkE3FdOamlWOhdUa","ACkXdZ7dLCo2CZmaaXlcH0q","WRboW6RdICo8oZG6","WRaZW5WfWPhcNSkYxNiWkSorW5i","pY7dMaNdTmk2CSo/n11Sqgi","ECoHFt8IeLRcHNvkpJyo","W5RdPCoMAKbcFvhdVb4XWQJdHG","kmo8tNVcLq","W7nyWRZdTmozAeXhWQ3cSmkKW5ldHG","amoXCSowcSkHWRSyW5lcHSkZdmkD","vwvHWQ97ueK","pIpdNW3dV8k/kCohk0LzvW","WRWdW4VcMCkkz8k8"];return(_0x5680=function(){return e})()}document.title="React 18 之所以优先用 queueMicrotask",document.getElementById("article").innerHTML='<div><p>React 18 之所以<strong>优先用 <code>queueMicrotask</code></strong>   ，而不是裸露的 <code>Promise.then</code>，主要有四个原因：语义、性能、兼容性和可控性。</p>\n<hr>\n<h3>1. 语义更纯粹</h3>\n<ul>\n<li><code>queueMicrotask</code> <strong>唯一目的</strong>   就是把回调排进微任务队列，不携带任何“异步成功/失败”的语义。</li>\n<li><code>Promise.then</code> 隐含“<strong>异步成功</strong>   ”含义，容易让读源码的人误以为这里有 Promise 链或错误处理逻辑，造成误解。</li>\n</ul>\n<hr>\n<h3>2. <strong>避免创建多余的 Promise 对象</strong></h3>\n<ul>\n<li>每次 <code>Promise.resolve().then(...)</code> 都会<strong>新建一个 Promise 实例</strong>   ；在高频调度（如输入框连续更新、动画）下会产生<strong>大量临时对象</strong>   ，增加 GC 压力。</li>\n<li><code>queueMicrotask</code> 只是往浏览器提供的微任务队列里塞一个函数指针，<strong>零额外内存分配</strong>   ，更轻量。</li>\n</ul>\n<hr>\n<h3>3. <strong>可移植性与未来兼容性</strong></h3>\n<ul>\n<li><code>queueMicrotask</code> 是 <strong>WHATWG HTML 标准</strong>   定义的浏览器专用 API，语义稳定；</li>\n<li>React 的调度包（<code>scheduler</code>）既要跑在浏览器，也要跑在 <strong>Node.js/React Native/测试环境</strong>   等。\n<ul>\n<li>Node.js 同样有 <code>queueMicrotask</code>，而 <code>MessageChannel</code>/<code>setImmediate</code> 在 Node 与浏览器表现不同。</li>\n<li>因此 React 在源码里做了分级降级：<pre><code>1. queueMicrotask（优先）\n2. MessageChannel（浏览器专用）\n3. setTimeout（兜底）\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>4. <strong>可控的“批处理边界”</strong></h3>\n<ul>\n<li>React 需要确保<strong>同一轮事件循环内所有 setState 全部收集完毕</strong>   后，再进行一次统一的调和与提交。</li>\n<li><code>queueMicrotask</code> 的回调永远在当前调用栈清空后、下一个宏任务之前执行，<strong>时序可预测</strong>   。</li>\n<li>如果使用 <code>Promise.then</code>，一旦外层代码里有 <code>await</code> 或自定义的 <code>Promise</code> 链，就可能把更新拆散到不同微任务，破坏批处理。</li>\n</ul>\n<hr>\n<h3>源码佐证（简化）</h3>\n<pre><code class="language-js"><span class="hljs-comment">// packages/scheduler/src/forks/Scheduler.js</span>\n<span class="hljs-keyword">const</span> scheduleMicrotask = <span class="hljs-keyword">typeof</span> queueMicrotask === <span class="hljs-string">&#x27;function&#x27;</span>\n  ? queueMicrotask\n  : <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>\n  ? <span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-literal">null</span>).<span class="hljs-title function_">then</span>(cb).<span class="hljs-title function_">catch</span>(handleError)\n  : <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">MessageChannel</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>\n  ? <span class="hljs-comment">/* …MessageChannel… */</span>\n  : <span class="hljs-built_in">setTimeout</span>;\n</code></pre>\n<p>可以看到优先级：<code>queueMicrotask</code> &gt; <code>Promise</code> &gt; <code>MessageChannel</code> &gt; <code>setTimeout</code>。</p>\n<hr>\n<h3>一句话总结</h3>\n<p><code>queueMicrotask</code> 比 <code>Promise.then</code> <strong>语义更纯粹、内存更省、时序更可控</strong>   ，因此 React 18 把它作为微任务调度的首选。</p>\n</div>'</script></body></html>