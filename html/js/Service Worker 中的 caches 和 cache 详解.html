<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4437(e,s){var l=_0x24b2();return(_0x4437=function(s,n){var a=l[s-=469];void 0===_0x4437.TEoIfw&&(_0x4437.xvnxOC=function(s,n){var a,c=[],e=0,l="";for(s=(s=>{for(var n,a,c="",e="",l=0,p=0;a=s.charAt(p++);~a&&(n=l%4?64*n+a:a,l++%4)&&(c+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,h=c.length;t<h;t++)e+="%"+("00"+c.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(e)})(s),p=0;p<256;p++)c[p]=p;for(p=0;p<256;p++)e=(e+c[p]+n.charCodeAt(p%n.length))%256,a=c[p],c[p]=c[e],c[e]=a;for(var p=0,e=0,t=0;t<s.length;t++)a=c[p=(p+1)%256],c[p]=c[e=(e+c[p])%256],c[e]=a,l+=String.fromCharCode(s.charCodeAt(t)^c[(c[p]+c[e])%256]);return l},e=arguments,_0x4437.TEoIfw=!0);var s=s+l[0],c=e[s];return c?a=c:(void 0===_0x4437.MpwLJY&&(_0x4437.MpwLJY=!0),a=_0x4437.xvnxOC(a,n),e[s]=a),a})(e,s)}var _0x48e0ed=_0x4437;function _0x24b2(){var s=["p0FdJSoNiSojh2nlCeW","WO5ZrcpcICkcBCkZW6ewlSoxASoTaeqpqsiYWRmFWOOgWOmv","CSkbW5pdGJNcI3q","W4JdNCkbWPvnWOeGWO7dPwz3aNC","m8otD8kAW6ddHCkGWQq4luNcRq","umkVWR7cULhdLu4xW4NdJ8kMmfu","DWdcJ8kIBa","W4LyW7D5W78NWOmAl8oWW7aGFW","WOhdJCk5WRnThIhcSCkOWPOABSka","W4pdHftcQsLbW4u6W5e","WR/dH8k5FCotWPf6mq","nSoCW4JdVc7cNvKl","W5e/agFdG8kaCSoxW5urfComAG","WOddHCkQEsJcLSk0nb3cKvb1wW","jSocW6NcIryoeCky","WRNdHSoqemkEW7mgnd7cSCk6sfO","WOBcShhdPmoJW73dUX3cN8oScG","WRJdRSonWPhcK8kNkCoGiSkIW5mi","W4/cQSkfWQeLWQRcIwS","W4JcOmkhWP0FWPNcQ2S","h1JdNJPlfHa","crKGW7CVW7zJW4XauMn+","t1tcNCoJW4WAcSoF","AbDdB8ofqLBdGmo9f8keWO4","WR3dR8kxW4FdQSoueSoz","WO3cTxldOCoIWPVcGHtcOComlCodW6S"];return(_0x24b2=function(){return s})()}if((()=>{for(var s=_0x4437,n=_0x24b2();;)try{if(941623==+parseInt(s(482,"dKe$"))*(parseInt(s(476,"7NgY"))/2)+parseInt(s(489,"IcOu"))/3+parseInt(s(477,"h3om"))/4*(parseInt(s(470,"kufT"))/5)+parseInt(s(490,"U@q0"))/6*(-parseInt(s(474,"[cHW"))/7)+-parseInt(s(479,"712W"))/8+-parseInt(s(471,"jT3Z"))/9+-parseInt(s(478,"%Ouv"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x48e0ed(486,"7lK)")](_0x48e0ed(475,"Ib]U"))!=_0x48e0ed(472,"UwX2"))throw window[_0x48e0ed(480,"Rmlg")][_0x48e0ed(494,"h3om")](_0x48e0ed(493,"%Ouv")),Error();document.title="Service Worker 中的 caches 和 cache 详解",document.getElementById("article").innerHTML='<div><h2>1. <code>caches</code> (CacheStorage)</h2>\n<p><code>caches</code> 是全局对象，代表浏览器中的缓存存储系统，属于 CacheStorage 接口。</p>\n<h3>主要特性：</h3>\n<ul>\n<li><strong>全局访问</strong>  ：通过 <code>window.caches</code> 或 <code>self.caches</code> 访问</li>\n<li><strong>命名空间</strong>  ：管理多个命名的 <code>Cache</code> 对象</li>\n<li><strong>持久性</strong>  ：缓存会持久保存，直到被显式删除</li>\n</ul>\n<h3>核心方法：</h3>\n<h4><code>caches.open(cacheName)</code></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 打开或创建一个缓存</span>\ncaches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;my-cache-v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n  <span class="hljs-comment">// 获得 cache 对象</span>\n});\n</code></pre>\n<h4><code>caches.keys()</code></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 获取所有缓存名称</span>\ncaches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cacheNames</span> =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cacheNames); <span class="hljs-comment">// [&#x27;my-cache-v1&#x27;, &#x27;other-cache&#x27;]</span>\n});\n</code></pre>\n<h4><code>caches.delete(cacheName)</code></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 删除指定缓存</span>\ncaches.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;old-cache&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">success</span> =&gt;</span> {\n  <span class="hljs-keyword">if</span> (success) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;缓存已删除&#x27;</span>);\n});\n</code></pre>\n<h4><code>caches.match(request)</code></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在所有缓存中搜索匹配的请求</span>\ncaches.<span class="hljs-title function_">match</span>(request).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {\n  <span class="hljs-keyword">if</span> (response) {\n    <span class="hljs-comment">// 使用缓存的响应</span>\n  }\n});\n</code></pre>\n<h2>2. <code>cache</code> (Cache)</h2>\n<p><code>cache</code> 是通过 <code>caches.open()</code> 获得的单个缓存对象，代表一个命名缓存存储。</p>\n<h3>主要特性：</h3>\n<ul>\n<li><strong>请求-响应存储</strong>  ：存储 Request-Response 对</li>\n<li><strong>同源限制</strong>  ：受同源策略限制（除非有正确的 CORS 头）</li>\n<li><strong>自动清理</strong>  ：浏览器可能会在存储空间不足时清理缓存</li>\n</ul>\n<h3>核心方法：</h3>\n<h4><code>cache.put(request, response)</code></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 缓存新的请求-响应对</span>\n<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">networkResponse</span> =&gt;</span> {\n  <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>, networkResponse);\n});\n</code></pre>\n<h4><code>cache.add(request)</code></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 获取资源并自动缓存（等同于 fetch + put）</span>\ncache.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;/styles.css&#x27;</span>);\n</code></pre>\n<h4><code>cache.addAll(requests)</code></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 批量缓存资源</span>\ncache.<span class="hljs-title function_">addAll</span>([\n  <span class="hljs-string">&#x27;/&#x27;</span>,\n  <span class="hljs-string">&#x27;/index.html&#x27;</span>,\n  <span class="hljs-string">&#x27;/styles.css&#x27;</span>,\n  <span class="hljs-string">&#x27;/app.js&#x27;</span>\n]);\n</code></pre>\n<h4><code>cache.match(request)</code></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在当前缓存中查找匹配的请求</span>\ncache.<span class="hljs-title function_">match</span>(<span class="hljs-string">&#x27;/images/logo.png&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {\n  <span class="hljs-keyword">if</span> (response) {\n    <span class="hljs-comment">// 使用缓存的图片</span>\n  }\n});\n</code></pre>\n<h4><code>cache.delete(request)</code></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 从缓存中删除特定请求</span>\ncache.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;/old-data.json&#x27;</span>);\n</code></pre>\n<h2>3. 实际应用示例</h2>\n<h3>缓存优先策略实现</h3>\n<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">respondWith</span>(\n    caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>)\n      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cachedResponse</span> =&gt;</span> {\n        <span class="hljs-comment">// 返回缓存或回退到网络</span>\n        <span class="hljs-keyword">return</span> cachedResponse || <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>);\n      })\n      .<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> {\n        <span class="hljs-comment">// 网络和缓存都失败时的回退</span>\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">&#x27;离线内容&#x27;</span>);\n      })\n  );\n});\n</code></pre>\n<h3>缓存更新策略</h3>\n<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">respondWith</span>(\n    caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;dynamic-v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cachedResponse</span> =&gt;</span> {\n        <span class="hljs-comment">// 立即返回缓存，同时后台更新</span>\n        <span class="hljs-keyword">const</span> fetchPromise = <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">networkResponse</span> =&gt;</span> {\n          cache.<span class="hljs-title function_">put</span>(event.<span class="hljs-property">request</span>, networkResponse.<span class="hljs-title function_">clone</span>());\n          <span class="hljs-keyword">return</span> networkResponse;\n        });\n        <span class="hljs-keyword">return</span> cachedResponse || fetchPromise;\n      });\n    })\n  );\n});\n</code></pre>\n<h2>4. 高级用法</h2>\n<h3>缓存版本控制</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CURRENT_CACHE</span> = <span class="hljs-string">&#x27;my-cache-v2&#x27;</span>;\n\nself.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">waitUntil</span>(\n    caches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cacheNames</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(\n        cacheNames.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">cacheName</span> =&gt;</span> {\n          <span class="hljs-keyword">if</span> (cacheName !== <span class="hljs-variable constant_">CURRENT_CACHE</span>) {\n            <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">delete</span>(cacheName);\n          }\n        })\n      );\n    })\n  );\n});\n</code></pre>\n<h3>缓存过期策略</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trimCache</span>(<span class="hljs-params">cacheName, maxItems</span>) {\n  caches.<span class="hljs-title function_">open</span>(cacheName).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n    cache.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">keys</span> =&gt;</span> {\n      <span class="hljs-keyword">if</span> (keys.<span class="hljs-property">length</span> &gt; maxItems) {\n        cache.<span class="hljs-title function_">delete</span>(keys[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 删除最旧的缓存项</span>\n      }\n    });\n  });\n}\n</code></pre>\n<h2>5. 注意事项</h2>\n<ol>\n<li><strong>缓存限制</strong>  ：浏览器对缓存总量有限制</li>\n<li><strong>缓存清理</strong>  ：浏览器可能在存储空间不足时清理缓存</li>\n<li><strong>安全限制</strong>  ：\n<ul>\n<li>只能缓存 GET 请求</li>\n<li>跨域资源需要正确的 CORS 头</li>\n</ul>\n</li>\n<li><strong>性能考虑</strong>  ：\n<ul>\n<li>避免缓存过大文件</li>\n<li>定期清理旧缓存</li>\n</ul>\n</li>\n<li><strong>开发调试</strong>  ：\n<ul>\n<li>使用 Chrome DevTools 的 Application &gt; Cache Storage 查看和管理缓存</li>\n<li>在开发时禁用缓存或使用不同缓存名称</li>\n</ul>\n</li>\n</ol>\n<p>正确使用 <code>caches</code> 和 <code>cache</code> 可以显著提升 Web 应用的性能和离线能力，但需要合理设计缓存策略以避免存储过时内容。</p>\n</div>'</script></body></html>