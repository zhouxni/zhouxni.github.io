<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2142ae=_0xadcb;if((()=>{for(var n=_0xadcb,e=_0x3ab5();;)try{if(486353==+parseInt(n(470,"U2Zo"))*(parseInt(n(492,"$0lM"))/2)+parseInt(n(489,"%9[d"))/3*(-parseInt(n(488,"q]uF"))/4)+parseInt(n(482,"!xSB"))/5+-parseInt(n(472,"XPTE"))/6+parseInt(n(485,"dd0K"))/7+-parseInt(n(474,"mWJD"))/8+-parseInt(n(484,"aMer"))/9*(-parseInt(n(477,"tiws"))/10))break;e.push(e.shift())}catch(n){e.push(e.shift())}})(),localStorage[_0x2142ae(494,"P*xY")](_0x2142ae(475,"xj]["))!=_0x2142ae(476,"P*xY"))throw window[_0x2142ae(479,"q]uF")][_0x2142ae(481,"P*xY")](_0x2142ae(473,"q]uF")),Error();function _0xadcb(a,n){var o=_0x3ab5();return(_0xadcb=function(n,e){var r=o[n-=469];void 0===_0xadcb.sapYPE&&(_0xadcb.WrKDXi=function(n,e){var r,t=[],a=0,o="";for(n=(n=>{for(var e,r,t="",a="",o=0,c=0;r=n.charAt(c++);~r&&(e=o%4?64*e+r:r,o++%4)&&(t+=String.fromCharCode(255&e>>(-2*o&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var d=0,p=t.length;d<p;d++)a+="%"+("00"+t.charCodeAt(d).toString(16)).slice(-2);return decodeURIComponent(a)})(n),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)a=(a+t[c]+e.charCodeAt(c%e.length))%256,r=t[c],t[c]=t[a],t[a]=r;for(var c=0,a=0,d=0;d<n.length;d++)r=t[c=(c+1)%256],t[c]=t[a=(a+t[c])%256],t[a]=r,o+=String.fromCharCode(n.charCodeAt(d)^t[(t[c]+t[a])%256]);return o},a=arguments,_0xadcb.sapYPE=!0);var n=n+o[0],t=a[n];return t?r=t:(void 0===_0xadcb.INwcFM&&(_0xadcb.INwcFM=!0),r=_0xadcb.WrKDXi(r,e),a[n]=r),r})(a,n)}function _0x3ab5(){var n=["W4n/WRauyaW+mmojtdhdS8kH","WPG5W6OsAtv4","xd4gW4BcJXTVBCkWqmkJW43dPa","rmoNaW4FBM/dTXqTW57cMG","W5ZcR8oCW4RcUmkTWOy","WRVdNCo7W5/dQwWKAI3cGmkxqKe","W4BdRe5XW7PMWRvlb8kKpH3dI8kyW6hdMXNcVCktWRxdQmohBIJdSsi","W5VcGSkrWPjTW6xcJ8kpwHlcM8oBya","DIbkWRuWW6hcUCkaW4C","WO8PW60Oza","n0H7W5tcMbbhsq","WPddLmolCSkVWPRcMcJdRaPzW7dcNq","W4ldT1LGW701W7uk","gmkeFxLOWOPcW4NcVSkAFtO","WO05W643FdnW","rCoXWRyngCkRWPqFW5VdUmkwoa","W7DpWQ59qd5/W5ddI3q","FmkuzNrwW6JcM8kLW57dKsSyWOS","WPmDWR7cS2ZdI0D1aHddHSozdq","W5qWFSohgracnNHmWOlcUa","W4PHFw0oW5xdGCoYv1hdUmkXDG","WP/cRaiXW6STW60Hkmk6","bmo8W7KzAgdcRSo3WOTt","WPBcOmk6hSk8W75aW4K","bNqFW6C2W53cSCkJW7P3","EZiWWPX4u8oX"];return(_0x3ab5=function(){return n})()}document.title="targetMap 的核心目的用 WeakMap 把依赖桶的生命周期绑定到对象本身，避免手动的、递归的 cleanup",document.getElementById("article").innerHTML='<div><p>把问题拆开，其实有两层：</p>\n<ol>\n<li>Dep 到底放在哪——「实例字段」还是「全局表」</li>\n<li>为什么要这样放——<strong>真的是为了“方便遍历 / 查询”吗？</strong></li>\n</ol>\n<hr>\n<p>一、3.5 的现状</p>\n<ul>\n<li><code>reactive</code> → 依赖桶挂在 <strong>全局 targetMap</strong></li>\n<li><code>ref</code> → 依赖桶挂在 <strong>RefImpl.dep</strong>   （实例字段）</li>\n</ul>\n<p>也就是说，<strong>Vue 3 并没有统一</strong>   ，而是把两种策略并存。</p>\n<hr>\n<p>二、「targetMap 只是方便遍历」这个说法站不住脚<br>\n<code>Proxy</code> 的 get / set 拦截已经把入口限制在 <strong>当前被 touch 的那个 key</strong>   ；<br>\n无论是</p>\n<pre><code class="language-js">targetMap.<span class="hljs-title function_">get</span>(obj).<span class="hljs-title function_">get</span>(key);\n</code></pre>\n<p>还是</p>\n<pre><code class="language-js">obj.<span class="hljs-property">dep</span>;\n</code></pre>\n<p>都是 O(1) 的哈希查找，性能差异可以忽略。</p>\n<hr>\n<p>三、真实动机：生命周期与内存管理的权衡</p>\n<ol>\n<li>\n<p>引用链</p>\n<ul>\n<li>\n<p>把桶放在 <code>RefImpl.dep</code>：<br>\n<code>ref → dep → effects</code><br>\n只要 ref 还被谁拿着，整个依赖链就<strong>一并存活</strong>   ；<br>\nref 被垃圾回收时，dep → effects 也<strong>自动消失</strong>   ，<strong>不需要额外清理</strong>   。</p>\n</li>\n<li>\n<p>把桶放在 <code>targetMap</code>：<br>\n<code>targetMap (全局) → WeakMap(obj) → Map(key) → dep → effects</code><br>\n只要 obj 活着，WeakMap 的 key 就活着；<br>\n但 effects 里<strong>可能反向持有</strong>   对 obj 的强引用（典型的是渲染 effect 持有 DOM 节点，又间接持有组件实例，组件实例又持有 ref）。<br>\n于是<strong>循环引用</strong>   会让 obj 和 effects 都<strong>无法被 GC</strong>   ，必须显式做“cleanup”——Vue 3 专门在 <code>stop</code> / <code>unmount</code> 里用 <code>cleanupDeps</code> 把 effects 从 dep 里摘掉，才能断链。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>成本对比</p>\n<ul>\n<li>ref 是<strong>原子值</strong>   ，生命周期通常跟着组件实例走，数量可控，用实例字段最省事，GC 路径简单。</li>\n<li>reactive 对象是<strong>可能非常大</strong>   的树，且跨组件共享的情况极多；如果每个对象都挂私有 dep，组件卸载时就要递归扫整棵树去做 cleanup，成本无法接受。<br>\n用全局 WeakMap 可以让“对象没人引用时自动消失”，把 cleanup 成本转移到 GC，运行时更轻。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<p>结论</p>\n<ul>\n<li>ref → 私有 dep：换取<strong>零额外清理成本</strong>   ，生命周期简单，数量可控。</li>\n<li>reactive → 全局 targetMap：换取<strong>跨组件共享 &amp; 大对象树</strong>   的自动内存管理，但必须在卸载时显式 cleanup 以切断循环引用。</li>\n</ul>\n<p>所以 <strong>targetMap 的核心目的并不是“方便查询”，而是“用 WeakMap 把依赖桶的生命周期绑定到对象本身，避免手动的、递归的 cleanup”</strong>   。</p>\n</div>'</script></body></html>