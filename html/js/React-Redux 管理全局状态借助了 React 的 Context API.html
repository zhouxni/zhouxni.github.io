<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1c1b65=_0xdbd3;function _0xdbd3(r,t){var c=_0x303f();return(_0xdbd3=function(t,e){var n=c[t-=193];void 0===_0xdbd3.yjMsmi&&(_0xdbd3.miRqRy=function(t,e){var n,o=[],r=0,c="";for(t=(t=>{for(var e,n,o="",r="",c=0,d=0;n=t.charAt(d++);~n&&(e=c%4?64*e+n:n,c++%4)&&(o+=String.fromCharCode(255&e>>(-2*c&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var s=0,a=o.length;s<a;s++)r+="%"+("00"+o.charCodeAt(s).toString(16)).slice(-2);return decodeURIComponent(r)})(t),d=0;d<256;d++)o[d]=d;for(d=0;d<256;d++)r=(r+o[d]+e.charCodeAt(d%e.length))%256,n=o[d],o[d]=o[r],o[r]=n;for(var d=0,r=0,s=0;s<t.length;s++)n=o[d=(d+1)%256],o[d]=o[r=(r+o[d])%256],o[r]=n,c+=String.fromCharCode(t.charCodeAt(s)^o[(o[d]+o[r])%256]);return c},r=arguments,_0xdbd3.yjMsmi=!0);var t=t+c[0],o=r[t];return o?n=o:(void 0===_0xdbd3.AAhNfr&&(_0xdbd3.AAhNfr=!0),n=_0xdbd3.miRqRy(n,e),r[t]=n),n})(r,t)}if((()=>{for(var t=_0xdbd3,e=_0x303f();;)try{if(486132==+parseInt(t(219,"7k)t"))*(-parseInt(t(217,"513F"))/2)+-parseInt(t(210,"hbTO"))/3+parseInt(t(200,"7k)t"))/4*(-parseInt(t(206,"(DdV"))/5)+-parseInt(t(193,"Ygn]"))/6*(-parseInt(t(214,"Nh!("))/7)+-parseInt(t(199,"z@G6"))/8+-parseInt(t(204,"QcsK"))/9+parseInt(t(211,"!dyr"))/10*(parseInt(t(198,"[Q(c"))/11))break;e.push(e.shift())}catch(t){e.push(e.shift())}})(),localStorage[_0x1c1b65(213,"rS8n")](_0x1c1b65(201,"]x&j"))!=_0x1c1b65(216,"oFI9"))throw window[_0x1c1b65(205,"TcN(")][_0x1c1b65(208,"H9Y5")](_0x1c1b65(207,"]e4^")),Error();function _0x303f(){var t=["WOSseZVdKmkHumk/j8oZga","WPhdR8kiwNyWWQpcSCkHrmo+W6O","i3ddJSknxc0Vmmo3BfOXW4ZdSG","uXRdGSk7W6HihYu","WOudgX01lGu","W7lcNNxcLw/cJvhdGCoVW5ZcLsu","W75qW6hcNX52bW","ymk5uvZdMq","WRhcQCkEA8kflgNdQW","W68hqMNcNgX3tCo1A8kRWOq","nutdS8krWRFdKdldGtnaoa","W7noW6W4zSoKW7X4tZ7dLXPU","W79aWQjIgCk2WRbo","W7CLn0KqW5qGwaZcKt42","y1BdS8ktjCo3kxBdM8kUWR3cMCk8","W7rTW7ddKSkeW5FcL0S/a8o+W73dH8ky","W4tcSSo/mCoeWR8bWRRdNCowDsa","WOWBqulcVCkICmkK","WPHmWRChW5/cVgpdK0WedmomCG","oXhcK8otW6NdOsq","pcZcKWFcJw7cQvv5","W57cU3yozCklkNi","thVcTWhcH3VcQfS","W5GuWPWyxdafWQRcVv5LmX8","lW0KWRJcJr0wbW","W7yTnu0FW5ueFX3cVXGJ","W7DzkmoowqiafHlcGCksWOFcGmk2W4ZdQ8osf1rQWPKbWPddKCk5WPq","W6hdNxqnW5JdRKC"];return(_0x303f=function(){return t})()}document.title="React-Redux 管理全局状态借助了 React 的 Context API",document.getElementById("article").innerHTML='<div><p>是的，React-Redux 管理全局状态<strong>确实借助了 React 的 Context API</strong>   ，但不仅仅是简单地“用了一下”，而是做了<strong>更复杂、更高效的封装和优化</strong>   。</p>\n<hr>\n<h3>✅ 简要回答：</h3>\n<blockquote>\n<p><strong>React-Redux 使用 Context API 来“传递” Redux store，但不直接用 Context 来传递状态值。</strong></p>\n</blockquote>\n<hr>\n<h3>🔍 深入解释：</h3>\n<h4>1. <strong>Context API 的作用：传递 store，而不是状态</strong></h4>\n<p>React-Redux 内部使用 <code>React.createContext()</code> 创建一个 <strong>store context</strong>   ，用来把 Redux store 本身（不是状态）传递给组件树：</p>\n<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">StoreContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>);\n</code></pre>\n<p>这个 context 的值是 Redux 的 <code>store</code>，而不是 <code>store.getState()</code> 的结果。</p>\n<hr>\n<h4>2. <strong>状态订阅机制：用自定义订阅系统，而不是直接依赖 Context 更新</strong></h4>\n<p>React-Redux（v7+）并没有用 Context 的 <code>.Provider</code> 来触发组件更新，而是：</p>\n<ul>\n<li>每个 <code>connect()</code> 或 <code>useSelector()</code> 的组件，都会<strong>直接订阅 Redux store 的变化</strong>   ；</li>\n<li>当 store 状态变化时，React-Redux 会<strong>手动触发组件的重新渲染</strong>   ；</li>\n<li>这样可以避免 Context 带来的<strong>性能问题（如不必要的子树重渲染）</strong>   。</li>\n</ul>\n<blockquote>\n<p>换句话说：Context 只是“传 store”，状态更新不走 Context。</p>\n</blockquote>\n<hr>\n<h4>3. <strong>React-Redux v8 的变化：用了 useSyncExternalStore</strong></h4>\n<p>在新版 React-Redux（v8）中，使用了 React 18 的 <code>useSyncExternalStore</code> hook 来订阅 store，这仍然是<strong>自定义订阅机制</strong>   ，不是直接用 Context 来传递状态。</p>\n<hr>\n<h3>✅ 总结一句话：</h3>\n<blockquote>\n<p><strong>React-Redux 借助 Context 把 Redux store 传下去，但状态更新是通过自定义订阅机制完成的，不是依赖 Context 的 value 变化。</strong></p>\n</blockquote>\n<hr>\n<p>如果你感兴趣，我可以给你看一段 React-Redux 的源码片段来说明这个机制。</p>\n</div>'</script></body></html>