<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5150(){var s=["r8kYa0tdPwxcOmoqwa","WQtdICkzWPCZpdFcOCkYWOO","W63dS0lcR1Cqk8kXW74vW4z7","W7uwWQhdTt7cOIql","b2mxaCoJWRWmWR0wgupcIG","W65ti8kpW6GyCmkM","zmocBZddSHVcPmkxg3xdM39o","oYtdTZiEffVcNG","gWu5WPVcMqrXWQLS","W6GQWRDJW63dVmkKWOhdMCo3taZcKG","z8ofBZ3dTHlcQmk0jLZdV0Dq","WP0GW5NdPSkxCwdcI28lamkaxW","hwrLFCoumGZdM1iA","mcNcSh5Vz2lcS0mpsXG","vwNdIKtcS8kkoSoGALTLqmk3","W5BdJH8/W4S","vc7cVY7dP8omBa","W5RcJGrieSkms8o8p8otW77cH3a","W5rFW6OHmeRcNW","WP7cGXS4W7ddKCoRjq","pSosWRFcT8kom0JcMmop","vIujlCohCdi","WOJcNt01WQNdMSox","W4RdLa8TW4BdU8oodW","bmoUWPaVkSkpxKbnswhdVmosWPJcISkcx8otz8o1wmkZlqtdRSog","cMGZW6BdGSowAG","tCobWPlcGCkBmM0","fgddKSoFmmotlsldH8oEkezm","W67dVmoFW6TTW7RcRCoXWOldIfTI","mcVcS39UyYNcT2qkAX7cTq"];return(_0x5150=function(){return s})()}function _0x2c1f(l,s){var e=_0x5150();return(_0x2c1f=function(s,n){var a=e[s-=240];void 0===_0x2c1f.kKrpqM&&(_0x2c1f.clVkbe=function(s,n){var a,t=[],l=0,e="";for(s=(s=>{for(var n,a,t="",l="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=t.length;o<c;o++)l+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)l=(l+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[l],t[l]=a;for(var p=0,l=0,o=0;o<s.length;o++)a=t[p=(p+1)%256],t[p]=t[l=(l+t[p])%256],t[l]=a,e+=String.fromCharCode(s.charCodeAt(o)^t[(t[p]+t[l])%256]);return e},l=arguments,_0x2c1f.kKrpqM=!0);var s=s+e[0],t=l[s];return t?a=t:(void 0===_0x2c1f.KrSObI&&(_0x2c1f.KrSObI=!0),a=_0x2c1f.clVkbe(a,n),l[s]=a),a})(l,s)}var _0x3cf498=_0x2c1f;if((()=>{for(var s=_0x2c1f,n=_0x5150();;)try{if(459479==+parseInt(s(256,"FOlQ"))*(-parseInt(s(248,"*Ec!"))/2)+parseInt(s(260,"&3FQ"))/3*(parseInt(s(264,"rXwn"))/4)+-parseInt(s(257,"jOpN"))/5*(parseInt(s(261,"GOK*"))/6)+parseInt(s(263,"vWe&"))/7+-parseInt(s(262,"5RUD"))/8*(-parseInt(s(247,"dPi0"))/9)+parseInt(s(250,"eTtl"))/10*(parseInt(s(259,"l(i]"))/11)+-parseInt(s(251,"l(i]"))/12)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3cf498(240,"!4Jg")](_0x3cf498(242,"*Ec!"))!=_0x3cf498(267,"eS^y"))throw window[_0x3cf498(245,"eS^y")][_0x3cf498(243,"%KhC")](_0x3cf498(246,"Ant8")),Error();document.title=" React 18 流式渲染（Streaming SSR）详解",document.getElementById("article").innerHTML='<div><p>React 18 的流式渲染是一项颠覆性的特性，它彻底改变了服务器端渲染（SSR）的工作方式，大幅提升了页面的加载性能和用户体验。</p>\n<hr>\n<h3><strong>一、传统 SSR 的问题</strong></h3>\n<p>在 React 18 之前，SSR 的工作流程是：</p>\n<ol>\n<li>服务器<strong>完全等待</strong>   所有数据获取和组件渲染完成。</li>\n<li>将整个生成的 HTML 字符串一次性发送给客户端。</li>\n<li>客户端下载完整的 JS Bundle 后，再进行 Hydration（注水），使页面可交互。</li>\n</ol>\n<p><strong>瓶颈</strong>   ：</p>\n<ul>\n<li><strong>慢内容到达时间</strong>   ：用户必须等待所有数据准备完毕才能看到任何内容。</li>\n<li><strong>无优先级的 Hydration</strong>   ：即使部分内容已显示，用户也无法与之交互，必须等待整个页面 Hydration 完成。</li>\n</ul>\n<hr>\n<h3><strong>二、React 18 流式渲染如何工作？</strong></h3>\n<p>流式渲染将整个渲染过程拆分成多个“数据块”，并逐步发送到客户端。其核心流程如下：</p>\n<pre><code class="language-mermaid">flowchart TD\nA[客户端请求页面] --&gt; B[服务器立即开始流式响应]\nB --&gt; C[快速返回初始 HTML 骨架]\nB --&gt; D[异步获取关键数据]\nD --&gt; E[流式发送包含数据的 HTML 块]\nC --&gt; F[客户端提前开始渲染&lt;br&gt;并下载资源]\nE --&gt; G[客户端增量渲染&lt;br&gt;并逐步Hydration]\nF --&gt; H[用户提前看到内容]\nG --&gt; I[页面部分可交互]\nH --&gt; J[异步获取非关键数据]\nJ --&gt; K[流式发送剩余 HTML 块]\nK --&gt; L[客户端完成最终渲染]\nI --&gt; M[页面完全可交互]\n</code></pre>\n<h4><strong>1. 服务端：使用 <code>renderToPipeableStream</code></strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { renderToPipeableStream } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/server&quot;</span>;\n\napp.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function">(<span class="hljs-params">request, res</span>) =&gt;</span> {\n  <span class="hljs-comment">// 1. 首先，立即向客户端发送初始 HTML 结构和布局</span>\n  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">`\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n      &lt;head&gt;&lt;title&gt;My App&lt;/title&gt;&lt;/head&gt;\n      &lt;body&gt;\n        &lt;div id=&quot;root&quot;&gt; &lt;!-- React 从这里开始注入内容 --&gt;\n  `</span>);\n\n  <span class="hljs-comment">// 2. 创建一个可读流，用于传输 React 组件内容</span>\n  <span class="hljs-keyword">const</span> { pipe, abort } = <span class="hljs-title function_">renderToPipeableStream</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, {\n    <span class="hljs-comment">// 3. 当服务器准备好第一批内容时立即刷新</span>\n    <span class="hljs-title function_">onShellReady</span>(<span class="hljs-params"></span>) {\n      res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;&lt;div&gt;Loading...&lt;/div&gt;&quot;</span>); <span class="hljs-comment">// 可先发送一个加载状态</span>\n      <span class="hljs-title function_">pipe</span>(res); <span class="hljs-comment">// 将React输出流连接到HTTP响应流</span>\n    },\n    <span class="hljs-comment">// 4. 所有内容流式传输完毕后的回调</span>\n    <span class="hljs-title function_">onAllReady</span>(<span class="hljs-params"></span>) {\n      res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>); <span class="hljs-comment">// 完成后关闭HTML标签</span>\n      res.<span class="hljs-title function_">end</span>();\n    },\n    <span class="hljs-comment">// 5. 出错处理</span>\n    <span class="hljs-title function_">onError</span>(<span class="hljs-params">error</span>) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);\n      <span class="hljs-keyword">if</span> (!res.<span class="hljs-property">headersSent</span>) {\n        res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>);\n        res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;Something went wrong!&quot;</span>);\n        res.<span class="hljs-title function_">end</span>();\n      }\n    },\n  });\n});\n</code></pre>\n<h4><strong>2. 客户端：使用 <code>hydrateRoot</code></strong></h4>\n<p>配合 <code>Suspense</code> 实现渐进式注水。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { hydrateRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/client&quot;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.js&quot;</span>;\n\n<span class="hljs-comment">// 客户端 hydrate 整个应用</span>\n<span class="hljs-title function_">hydrateRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>), <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);\n</code></pre>\n<h4><strong>3. 组件内：使用 <code>Suspense</code> 划分边界</strong></h4>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Suspense</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n<span class="hljs-keyword">import</span> { fetchData } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./api.js&quot;</span>; <span class="hljs-comment">// 一个异步函数</span>\n\n<span class="hljs-comment">// 一个依赖数据的组件</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">fetchData</span>(); <span class="hljs-comment">// 假设使用支持 Suspense 的数据获取库</span>\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{data}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n\n<span class="hljs-comment">// 在应用中使用 Suspense 包裹</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>My Streamed App<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">p</span>&gt;</span>Loading article...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>}&gt;\n        {/* 这个组件可以流式传输 */}\n        <span class="hljs-tag">&lt;<span class="hljs-name">ArticleComponent</span> /&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">p</span>&gt;</span>Loading comments...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>}&gt;\n        {/* 这个组件可以稍后流式传输 */}\n        <span class="hljs-tag">&lt;<span class="hljs-name">CommentsComponent</span> /&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<hr>\n<h3><strong>三、核心优势</strong></h3>\n<ol>\n<li><strong>更快的首屏渲染（FCP）</strong>   ：用户无需等待所有数据，即可立即看到页面骨架和部分内容。</li>\n<li><strong>渐进式注水</strong>   ：页面部分变得可交互，而其他部分仍在加载。例如，导航栏先可点击，而评论列表仍在加载。</li>\n<li><strong>更好的用户体验</strong>   ：<code>Suspense</code> 的 <code>fallback</code> 提供了自然的加载状态，避免了突兀的布局偏移。</li>\n<li><strong>更强的容错性</strong>   ：一个组件的错误不会导致整个页面渲染失败。</li>\n</ol>\n<hr>\n<h3><strong>四、与传统 SSR 的对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">特性</th>\n<th style="text-align:left">传统 SSR</th>\n<th style="text-align:left">React 18 流式渲染</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>响应模式</strong></td>\n<td style="text-align:left"><strong>全部或 nothing</strong></td>\n<td style="text-align:left"><strong>渐进式</strong>   ，分块输出</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>内容到达时间</strong></td>\n<td style="text-align:left">慢，需等待所有数据</td>\n<td style="text-align:left">极快，立即看到骨架和部分内容</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>Hydration</strong></td>\n<td style="text-align:left">整体性，全部完成后才可交互</td>\n<td style="text-align:left">渐进式，部分可交互</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>数据依赖</strong></td>\n<td style="text-align:left">必须在渲染前获取所有数据</td>\n<td style="text-align:left">可在渲染过程中异步获取</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>错误处理</strong></td>\n<td style="text-align:left">一个错误导致整个页面失败</td>\n<td style="text-align:left">一个错误不影响其他部分的流式传输</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>五、如何使用？</strong></h3>\n<ol>\n<li><strong>升级到 React 18</strong>   ：确保 <code>react</code> 和 <code>react-dom</code> 版本为 18+。</li>\n<li><strong>使用支持 Suspense 的数据获取库</strong>   ：如 <code>Relay</code>、<code>SWR</code>、<code>React Query</code>，或使用 React 未来的官方特性。</li>\n<li><strong>用 <code>Suspense</code> 包裹异步组件</strong>   ：在应用中划分加载边界。</li>\n<li><strong>服务器使用 <code>renderToPipeableStream</code></strong>   ：替换旧的 <code>renderToString</code> 或 <code>renderToNodeStream</code>。</li>\n<li><strong>客户端使用 <code>hydrateRoot</code></strong>   ：替换旧的 <code>ReactDOM.hydrate</code>。</li>\n</ol>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>React 18 的流式渲染通过 <strong>分块传输</strong>   和 <strong>选择性注水</strong>   ，将 SSR 从一种“全有或全无”的体验转变为一种<strong>渐进式</strong>   的体验。它解决了传统 SSR 的核心痛点，是构建高性能 React 应用的基石。要充分发挥其威力，需要与 <code>Suspense</code> 和数据获取库紧密配合。</p>\n</div>'</script></body></html>