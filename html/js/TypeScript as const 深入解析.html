<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4c5e(p,s){var t=_0x388e();return(_0x4c5e=function(s,n){var a=t[s-=371];void 0===_0x4c5e.CuDRyE&&(_0x4c5e.ajLjcq=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,e=0;a=s.charAt(e++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=l.length;c<o;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[p],l[p]=a;for(var e=0,p=0,c=0;c<s.length;c++)a=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[p])%256]);return t},p=arguments,_0x4c5e.CuDRyE=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x4c5e.cxoFjw&&(_0x4c5e.cxoFjw=!0),a=_0x4c5e.ajLjcq(a,n),p[s]=a),a})(p,s)}var _0x127b71=_0x4c5e;function _0x388e(){var s=["WPWEW73dUfhcHHGt","W6utmSkNWP4/uCkgW5RdVq","WRNcObFcKCkmwSoBWOm0W5/dN8ohAa","oCklWPBdGICCW5yR","W6pcImkRWR7dLaupyYTaEsrAgq","emkCmIuadWC","WRhdOxdcV1qavMS","lCkNWPxdP8obWRqa","vNG1WR1JW4PDW6dcPmo8WR9iW6O","WOSmoMHTuN3dNmoZWOJcPaK","W5b+pCkUvSkcdKJdTtRcUXaA","W5bjDIOMxdxcM8odWRpcUcZdG3fTz8k1nmkxr8oDW4/dT1BdVtK","ymkbW5VdLmoIW4rGWPr/W64PWOO","W6dcISkLWRtdKWecmI5TxW5I","o8knlCo3dG","WOtcL8k0W7ddVhXdWRC","WQaxxComeSkYW5ddRmkejfFcJZa","WRHeeSkuW7ujmCknzmoRW6Xsxq","WRNdMCkLrSkuW4ZcOG","W4jqW491m8o1vmk0","w3X4jfnEWONdMqKvjmklbW","WO/cNmowWPxdJNDZWRnsEq","gYRcSX0CWQ1JWPP6WOFcOK0t","W6XjW5BdQu3cUseyWQa","W4tdH01UfCkSomoEw8kiu3zdW5m","l8oaaqJdKqis","W4ddJICKwSo9ACk+","c8o1z8oBiw7cKmkV"];return(_0x388e=function(){return s})()}if((()=>{for(var s=_0x4c5e,n=_0x388e();;)try{if(748683==-parseInt(s(393,"9M5C"))+-parseInt(s(394,"33aN"))/2*(parseInt(s(371,"[81A"))/3)+parseInt(s(382,"[cBE"))/4+-parseInt(s(395,"EEzJ"))/5+parseInt(s(383,"OeX#"))/6*(-parseInt(s(373,"P3v6"))/7)+parseInt(s(381,"Lp9m"))/8*(parseInt(s(391,"$8eI"))/9)+parseInt(s(377,"[viV"))/10*(parseInt(s(388,"33aN"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x127b71(398,"KD3k")](_0x127b71(396,"P3v6"))!=_0x127b71(387,"iX@0"))throw window[_0x127b71(379,"S5a0")][_0x127b71(378,"QNlu")](_0x127b71(384,"[cBE")),Error();document.title="TypeScript as const 深入解析",document.getElementById("article").innerHTML='<div><p><code>as const</code> 是 TypeScript 中的一个类型断言，用于创建<strong>不可变的字面量类型</strong>  。它会将表达式中的所有内容转换为最精确的只读类型。</p>\n<h2>基本用法</h2>\n<pre><code class="language-typescript"><span class="hljs-comment">// 普通数组</span>\n<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// 类型为 number[]</span>\n<span class="hljs-keyword">const</span> arrConst = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// 类型为 readonly [1, 2, 3]</span>\n\n<span class="hljs-comment">// 对象</span>\n<span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> }; <span class="hljs-comment">// 类型为 { name: string; age: number; }</span>\n<span class="hljs-keyword">const</span> objConst = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> } <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// 类型为 { readonly name: &quot;Alice&quot;; readonly age: 30; }</span>\n</code></pre>\n<h2>主要特性</h2>\n<ol>\n<li><strong>字面量类型锁定</strong>\n<ul>\n<li>将值锁定为具体的字面量类型，而不是宽泛的类型</li>\n<li>数字变为数字字面量类型</li>\n<li>字符串变为字符串字面量类型</li>\n<li>布尔值变为 true/false 字面量类型</li>\n</ul>\n</li>\n<li><strong>深度只读</strong>\n<ul>\n<li>对象所有属性变为 <code>readonly</code></li>\n<li>数组变为 <code>readonly</code> 元组</li>\n</ul>\n</li>\n<li><strong>类型收窄</strong>\n<ul>\n<li>自动推断最精确的类型</li>\n</ul>\n</li>\n</ol>\n<h2>常见使用场景</h2>\n<h3>1. 定义不可变配置</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> config = {\n  <span class="hljs-attr">apiUrl</span>: <span class="hljs-string">&quot;https://api.example.com&quot;</span>,\n  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>,\n  <span class="hljs-attr">retry</span>: <span class="hljs-number">3</span>,\n} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;\n\n<span class="hljs-comment">// 尝试修改会报错</span>\nconfig.<span class="hljs-property">timeout</span> = <span class="hljs-number">3000</span>; <span class="hljs-comment">// Error: Cannot assign to &#x27;timeout&#x27; because it is a read-only property</span>\n</code></pre>\n<h3>2. 创建枚举替代方案</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Status</span> = {\n  <span class="hljs-title class_">Active</span>: <span class="hljs-string">&quot;ACTIVE&quot;</span>,\n  <span class="hljs-title class_">Inactive</span>: <span class="hljs-string">&quot;INACTIVE&quot;</span>,\n  <span class="hljs-title class_">Pending</span>: <span class="hljs-string">&quot;PENDING&quot;</span>,\n} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">StatusType</span> = <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Status</span>[keyof <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Status</span>]; <span class="hljs-comment">// &quot;ACTIVE&quot; | &quot;INACTIVE&quot; | &quot;PENDING&quot;</span>\n</code></pre>\n<h3>3. 精确的元组类型</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useTuple</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-number">200</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;\n}\n\n<span class="hljs-keyword">const</span> result = <span class="hljs-title function_">useTuple</span>(); <span class="hljs-comment">// 类型为 readonly [&quot;success&quot;, 200]</span>\n<span class="hljs-keyword">const</span> [status, code] = result; <span class="hljs-comment">// status类型为&quot;success&quot;，code类型为200</span>\n</code></pre>\n<h3>4. 配合 typeof 获取类型</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> colors = {\n  <span class="hljs-attr">red</span>: <span class="hljs-string">&quot;#FF0000&quot;</span>,\n  <span class="hljs-attr">green</span>: <span class="hljs-string">&quot;#00FF00&quot;</span>,\n  <span class="hljs-attr">blue</span>: <span class="hljs-string">&quot;#0000FF&quot;</span>,\n} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">ColorKeys</span> = keyof <span class="hljs-keyword">typeof</span> colors; <span class="hljs-comment">// &quot;red&quot; | &quot;green&quot; | &quot;blue&quot;</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">ColorValues</span> = <span class="hljs-keyword">typeof</span> colors[keyof <span class="hljs-keyword">typeof</span> colors]; <span class="hljs-comment">// &quot;#FF0000&quot; | &quot;#00FF00&quot; | &quot;#0000FF&quot;</span>\n</code></pre>\n<h2>注意事项</h2>\n<ol>\n<li><strong>与泛型的交互</strong><pre><code class="language-typescript"><span class="hljs-keyword">function</span> foo&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt;(<span class="hljs-attr">arg</span>: T) {\n  <span class="hljs-keyword">return</span> { <span class="hljs-attr">value</span>: arg } <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;\n}\n<span class="hljs-comment">// 返回类型为 { readonly value: T }</span>\n</code></pre>\n</li>\n<li><strong>性能影响</strong>\n<ul>\n<li>对于大型对象，<code>as const</code> 可能会增加类型检查时间</li>\n</ul>\n</li>\n<li><strong>不可过度使用</strong>\n<ul>\n<li>只有在需要精确类型时才使用</li>\n<li>普通场景下可能不需要</li>\n</ul>\n</li>\n<li><strong>与 const 声明的区别</strong>\n<ul>\n<li><code>const</code> 声明保证变量不可重新赋值</li>\n<li><code>as const</code> 保证值的类型不可变</li>\n</ul>\n</li>\n</ol>\n<h2>高级用法</h2>\n<h3>递归只读类型</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> deepObj = {\n  <span class="hljs-attr">level1</span>: {\n    <span class="hljs-attr">level2</span>: {\n      <span class="hljs-attr">level3</span>: {\n        <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;deep&quot;</span>\n      }\n    }\n  }\n} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;\n\n<span class="hljs-comment">// 所有嵌套属性都是readonly</span>\n</code></pre>\n<h3>联合类型收窄</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getResponse</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span> \n    ? { <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-attr">data</span>: [] } <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>\n    : { <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;&quot;</span> } <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;\n}\n\n<span class="hljs-keyword">const</span> response = <span class="hljs-title function_">getResponse</span>();\n<span class="hljs-keyword">if</span> (response.<span class="hljs-property">status</span> === <span class="hljs-string">&quot;success&quot;</span>) {\n  <span class="hljs-comment">// 这里response.data是可用的</span>\n} <span class="hljs-keyword">else</span> {\n  <span class="hljs-comment">// 这里response.message是可用的</span>\n}\n</code></pre>\n<p><code>as const</code> 是 TypeScript 中强大的工具，可以帮助开发者创建更精确、更安全的类型系统。合理使用可以显著提高代码的类型安全性。</p>\n</div>'</script></body></html>