<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x37ef(){var t=["W5VdS8kZWO8dWOWv","vauskwGaWQVcLmoXW60UwSk1W5hcUfBcJNxdH8k/x8k8mcLoWPq","mmotWO/cVSkkWQNcGSkEWPdcHCoJ","eSkcamoaWOPKpxNdV01bWPZcVW","p8kRW5ObrSotW7xdO8kT","vNVcImkhqmoCW67dGa","bSoHq3pdVSkzWO7dN8oaFu0p","sSkwxmoxWPuRWQDsW7qQdqVdVq","WQfUsGNdGYn+","W4LYWPWtmCoYa8k6ie3cI8oUW5a","W4G5wJtdOmk0WQ02W7xdOG","rfddLmkexCoNBCoe","WROHW4TeCSkYFmkmcG","W6tdSSo0Bmkkk8kB","W4tcIYPYzgDjf8ktxmo7fSoZ","WOikEc3dTcZcQSoAD8kZ","W7VdOJ7dMmkAwbdcG0biWRHryq","gq/cJSosemk+ASoiWOCcW6SD","z8kEqmktv8ktWRC","rbLplmoivJWFlmoxaG5d","taqvkMi","j3/dShBdPCkdW7NcIq","ix7cKrFcTmkiW4RcHfldRSo9","r2W7W499W4pcMCo4emooWR7cPCoU","kSoLiSkXiKGnW4BdOSkNWOXJvG","WRJdPCoGld7dT1LeW4VcKa","W6hcGCkotCkVo8kFkmo1","WQvfWPFdSIhdV10OW6JcMq"];return(_0x37ef=function(){return t})()}function _0x5a5e(d,t){var a=_0x37ef();return(_0x5a5e=function(t,n){var e=a[t-=365];void 0===_0x5a5e.QyaedR&&(_0x5a5e.UAnxTa=function(t,n){var e,s=[],d=0,a="";for(t=(t=>{for(var n,e,s="",d="",a=0,o=0;e=t.charAt(o++);~e&&(n=a%4?64*n+e:e,a++%4)&&(s+=String.fromCharCode(255&n>>(-2*a&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var c=0,r=s.length;c<r;c++)d+="%"+("00"+s.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(d)})(t),o=0;o<256;o++)s[o]=o;for(o=0;o<256;o++)d=(d+s[o]+n.charCodeAt(o%n.length))%256,e=s[o],s[o]=s[d],s[d]=e;for(var o=0,d=0,c=0;c<t.length;c++)e=s[o=(o+1)%256],s[o]=s[d=(d+s[o])%256],s[d]=e,a+=String.fromCharCode(t.charCodeAt(c)^s[(s[o]+s[d])%256]);return a},d=arguments,_0x5a5e.QyaedR=!0);var t=t+a[0],s=d[t];return s?e=s:(void 0===_0x5a5e.vpyhaO&&(_0x5a5e.vpyhaO=!0),e=_0x5a5e.UAnxTa(e,n),d[t]=e),e})(d,t)}var _0x113d14=_0x5a5e;if((()=>{for(var t=_0x5a5e,n=_0x37ef();;)try{if(590827==+parseInt(t(380,"W3pC"))*(-parseInt(t(374,"CI7E"))/2)+parseInt(t(388,"$QpK"))/3*(-parseInt(t(371,"%Td!"))/4)+parseInt(t(369,"!Nxp"))/5+-parseInt(t(377,"Iad]"))/6+-parseInt(t(376,"5h@G"))/7+parseInt(t(375,"CI7E"))/8*(-parseInt(t(385,"Yz@e"))/9)+-parseInt(t(387,"L%Nn"))/10*(-parseInt(t(378,"!1$H"))/11))break;n.push(n.shift())}catch(t){n.push(n.shift())}})(),localStorage[_0x113d14(389,"@I3p")](_0x113d14(365,"Nugo"))!=_0x113d14(373,"B%!A"))throw window[_0x113d14(392,"]p@Z")][_0x113d14(381,"TKp5")](_0x113d14(382,"B%!A")),Error();document.title=" Nuxt3 中，useAsyncData 和 useFetch 的区别",document.getElementById("article").innerHTML='<div><p>在 <strong>Nuxt3</strong>   中，<code>useAsyncData</code> 和 <code>useFetch</code> 都是用于在服务端渲染（SSR）阶段获取数据的组合式函数（composables），但它们的使用场景和底层机制有所不同。</p>\n<hr>\n<h3>✅ 一句话区别</h3>\n<ul>\n<li><code>useFetch</code> 是基于 <code>useAsyncData</code> 的<strong>封装</strong>   ，<strong>专门用于 HTTP 请求</strong>   （类似 <code>fetch</code>），更简洁。</li>\n<li><code>useAsyncData</code> 更<strong>底层、通用</strong>   ，可以用于任何异步逻辑（不限于 HTTP）。</li>\n</ul>\n<hr>\n<h3>🔍 详细对比</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>useFetch</code></th>\n<th><code>useAsyncData</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>用途</strong></td>\n<td>专门用于 HTTP 请求（封装了 <code>$fetch</code>）</td>\n<td>通用异步数据获取</td>\n</tr>\n<tr>\n<td><strong>底层实现</strong></td>\n<td>内部调用 <code>useAsyncData</code> + <code>$fetch</code></td>\n<td>纯异步逻辑处理</td>\n</tr>\n<tr>\n<td><strong>参数</strong></td>\n<td><code>(url, options)</code></td>\n<td><code>(key, handler)</code></td>\n</tr>\n<tr>\n<td><strong>自动 URL 编码</strong></td>\n<td>✅ 自动处理</td>\n<td>❌ 需要手动处理</td>\n</tr>\n<tr>\n<td><strong>缓存键</strong></td>\n<td>自动基于 URL 和参数</td>\n<td>需要手动指定 <code>key</code></td>\n</tr>\n<tr>\n<td><strong>类型推断</strong></td>\n<td>✅ 自动推断响应类型</td>\n<td>❌ 需要手动指定泛型</td>\n</tr>\n<tr>\n<td><strong>适合场景</strong></td>\n<td>RESTful API 调用</td>\n<td>自定义异步逻辑（如数据库、GraphQL、组合请求等）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>📌 示例对比</h3>\n<h4>1. 使用 <code>useFetch</code>（简洁）</h4>\n<pre><code class="language-ts"><span class="hljs-keyword">const</span> { data, pending, error } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">useFetch</span>(<span class="hljs-string">&quot;/api/user&quot;</span>, {\n  <span class="hljs-attr">query</span>: { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> },\n});\n</code></pre>\n<h4>2. 使用 <code>useAsyncData</code>（更灵活）</h4>\n<pre><code class="language-ts"><span class="hljs-keyword">const</span> { data, pending, error } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">useAsyncData</span>(\n  <span class="hljs-string">&quot;user-1&quot;</span>, <span class="hljs-comment">// 缓存 key</span>\n  <span class="hljs-function">() =&gt;</span> $fetch(<span class="hljs-string">&quot;/api/user&quot;</span>, { <span class="hljs-attr">query</span>: { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> } }), <span class="hljs-comment">// 任意异步逻辑</span>\n);\n</code></pre>\n<hr>\n<h3>🎯 何时用哪个？</h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>简单 REST API 调用</td>\n<td>✅ <code>useFetch</code></td>\n</tr>\n<tr>\n<td>需要自定义缓存 key</td>\n<td>✅ <code>useAsyncData</code></td>\n</tr>\n<tr>\n<td>非 HTTP 异步逻辑（如数据库）</td>\n<td>✅ <code>useAsyncData</code></td>\n</tr>\n<tr>\n<td>GraphQL 或组合多个请求</td>\n<td>✅ <code>useAsyncData</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>🚨 注意</h3>\n<ul>\n<li>两者默认都会在 SSR 阶段执行，避免客户端重复请求（利用缓存）。</li>\n<li>如果不需要 SSR，可以设置 <code>server: false</code> 选项。</li>\n</ul>\n<hr>\n<h3>📚 官方文档</h3>\n<ul>\n<li><a href="https://nuxt.com/docs/api/composables/use-fetch" target="_blank"><code>useFetch</code></a></li>\n<li><a href="https://nuxt.com/docs/api/composables/use-async-data" target="_blank"><code>useAsyncData</code></a></li>\n</ul>\n<p>总结：<strong>能用 <code>useFetch</code> 就别用 <code>useAsyncData</code>，除非需要更复杂的控制。</strong></p>\n</div>'</script></body></html>