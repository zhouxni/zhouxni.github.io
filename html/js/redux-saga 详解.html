<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4826(e,s){var r=_0x50c6();return(_0x4826=function(s,n){var a=r[s-=258];void 0===_0x4826.Wewcfd&&(_0x4826.UVSEfm=function(s,n){var a,l=[],e=0,r="";for(s=(s=>{for(var n,a,l="",e="",r=0,o=0;a=s.charAt(o++);~a&&(n=r%4?64*n+a:a,r++%4)&&(l+=String.fromCharCode(255&n>>(-2*r&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,c=l.length;t<c;t++)e+="%"+("00"+l.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(e)})(s),o=0;o<256;o++)l[o]=o;for(o=0;o<256;o++)e=(e+l[o]+n.charCodeAt(o%n.length))%256,a=l[o],l[o]=l[e],l[e]=a;for(var o=0,e=0,t=0;t<s.length;t++)a=l[o=(o+1)%256],l[o]=l[e=(e+l[o])%256],l[e]=a,r+=String.fromCharCode(s.charCodeAt(t)^l[(l[o]+l[e])%256]);return r},e=arguments,_0x4826.Wewcfd=!0);var s=s+r[0],l=e[s];return l?a=l:(void 0===_0x4826.bfEKMB&&(_0x4826.bfEKMB=!0),a=_0x4826.UVSEfm(a,n),e[s]=a),a})(e,s)}var _0x3fb3f1=_0x4826;function _0x50c6(){var s=["WRy7hSkRCCk4ocq1W5NcGbOrumkSxCoYgSoBW4ddSgaHW4T3dq","W4akW4ZdTgTWaIjbd8oBFmoc","W586pmo1WOZcOmkhWQi","W4xdKchdLhddT8oRWRSLW51dW6NdPa","dgxdT8ovWOddNJVcPq","pHBcL8keWRhcMSk+utVcPSoLW4mG","Fmk8WRFcTrH0W7u","DK01W7BdHCo9WR7dPJhdIwncBG","imk4W5xcUaLLW7K/WOpcO8oKbJq","WPRcMCoPW4xdL0RcQ1eKF8oOpSkY","dSowac/dJfXh","CCotlfZcGmo9W7C","yuZdG8oqW73dI8oIvW","obtcL8kgWRRcM8k5CXJcKCo+W4C8","W6BcPCo9WO5jc8ov","W7dcG8kvwcpdGZ0dW6JcKSoyW5tcTa","WPWCW5uYfmkrASoOWQi","WQ0kW4uKhG","WQv2wW7dHCk5W6hcK2XAW55VW7qN","W69iWObNumouySobWPpdRSkpkq","hb/cTCknW5hdJaW","WRTjWRvhWRCHWRG+W61YW5H5W5C","nCoNwJ8wWOj1C37dV3ddVSk2W5O","CuWXW7ZdHCo6WRpdQaddTfzPFG","W6GDjSkszCoAyW","w8keqLBcJW9PBupdJNRcMa"];return(_0x50c6=function(){return s})()}if((()=>{for(var s=_0x4826,n=_0x50c6();;)try{if(741564==+parseInt(s(258,"QsEG"))*(parseInt(s(271,"y(Xk"))/2)+-parseInt(s(267,"7)jP"))/3+-parseInt(s(273,"H)MO"))/4+-parseInt(s(281,"wSoe"))/5*(parseInt(s(276,"BXmt"))/6)+parseInt(s(265,"$BP3"))/7+parseInt(s(275,"0iY3"))/8*(-parseInt(s(282,"zZhu"))/9)+parseInt(s(274,"oTzd"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3fb3f1(262,"Aoyn")](_0x3fb3f1(268,"y(Xk"))!=_0x3fb3f1(269,"y(Xk"))throw window[_0x3fb3f1(264,"$BP3")][_0x3fb3f1(263,"i7aZ")](_0x3fb3f1(278,"BXmt")),Error();document.title="redux-saga 详解",document.getElementById("article").innerHTML='<div><p><strong>redux-saga 详解</strong></p>\n<p>redux-saga 是一个用于管理 Redux 应用中副作用（如异步获取数据、访问浏览器缓存等）的中间件。它旨在让副作用管理更容易、执行更高效、测试更简单，并在处理故障时提供更大的灵活性。以下是关于 redux-saga 的详细解析：</p>\n<h3>一、核心特性</h3>\n<ol>\n<li><strong>Generator 函数</strong>  ：\n<ul>\n<li>redux-saga 使用 ES6 的 Generator 函数来实现异步流程控制。这使得异步代码看起来像同步代码，易于阅读和测试。</li>\n</ul>\n</li>\n<li><strong>声明式 Effect</strong>  ：\n<ul>\n<li>redux-saga 提供了一系列声明式的 Effect（如 <code>call</code>、<code>put</code>、<code>take</code> 等），用于描述副作用操作。这些 Effect 在被 yield 时，会返回一个描述对象，redux-saga 中间件会根据这个描述对象来执行相应的操作。</li>\n</ul>\n</li>\n<li><strong>中间件集成</strong>  ：\n<ul>\n<li>redux-saga 是一个 Redux 中间件，可以与其他 Redux 中间件无缝集成。它允许你在 Redux 的数据流中插入自定义逻辑，以处理副作用。</li>\n</ul>\n</li>\n</ol>\n<h3>二、使用场景</h3>\n<p>redux-saga 特别适合处理复杂的异步流程，如：</p>\n<ul>\n<li>异步数据获取（如 API 调用）。</li>\n<li>长时间运行的任务（如轮询、WebSocket 连接）。</li>\n<li>并发任务管理。</li>\n<li>错误处理和重试机制。</li>\n</ul>\n<h3>三、基本用法</h3>\n<ol>\n<li><strong>安装</strong>  ：\n<ul>\n<li>使用 npm 或 yarn 安装 redux-saga：<pre><code class="language-sh">npm install redux-saga\n<span class="hljs-comment"># 或</span>\nyarn add redux-saga\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>配置 Redux Store</strong>  ：\n<ul>\n<li>在创建 Redux store 时，应用 redux-saga 中间件：<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createStore, applyMiddleware } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;\n<span class="hljs-keyword">import</span> createSagaMiddleware <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga&#x27;</span>;\n<span class="hljs-keyword">import</span> rootReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducers&#x27;</span>;\n<span class="hljs-keyword">import</span> rootSaga <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./sagas&#x27;</span>;\n\n<span class="hljs-keyword">const</span> sagaMiddleware = <span class="hljs-title function_">createSagaMiddleware</span>();\n<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(rootReducer, <span class="hljs-title function_">applyMiddleware</span>(sagaMiddleware));\n\nsagaMiddleware.<span class="hljs-title function_">run</span>(rootSaga);\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>定义 Saga</strong>  ：\n<ul>\n<li>使用 Generator 函数定义 Saga，并使用 Effect 来描述副作用操作：<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { call, put, takeEvery } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga/effects&#x27;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">Api</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../api&#x27;</span>;\n\n<span class="hljs-keyword">function</span>* <span class="hljs-title function_">fetchUser</span>(<span class="hljs-params">action</span>) {\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">call</span>(<span class="hljs-title class_">Api</span>.<span class="hljs-property">fetchUser</span>, action.<span class="hljs-property">payload</span>.<span class="hljs-property">userId</span>);\n    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">put</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;USER_FETCH_SUCCEEDED&#x27;</span>, <span class="hljs-attr">user</span>: user });\n  } <span class="hljs-keyword">catch</span> (e) {\n    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">put</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;USER_FETCH_FAILED&#x27;</span>, <span class="hljs-attr">message</span>: e.<span class="hljs-property">message</span> });\n  }\n}\n\n<span class="hljs-keyword">function</span>* <span class="hljs-title function_">mySaga</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">yield</span> <span class="hljs-title function_">takeEvery</span>(<span class="hljs-string">&#x27;USER_FETCH_REQUESTED&#x27;</span>, fetchUser);\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> mySaga;\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h3>四、关键概念</h3>\n<ol>\n<li><strong>Saga</strong>  ：\n<ul>\n<li>Saga 是一个 Generator 函数，用于描述异步操作。它可以被启动、暂停、恢复和取消。</li>\n</ul>\n</li>\n<li><strong>Effect</strong>  ：\n<ul>\n<li>Effect 是一个简单的 JavaScript 对象，包含了一些将被 saga 中间件执行的指令。redux-saga 提供了多种 Effect 创建器（如 <code>call</code>、<code>put</code>、<code>take</code> 等）来创建 Effect。</li>\n</ul>\n</li>\n<li><strong>Channel</strong>  ：\n<ul>\n<li>Channel 是 redux-saga 中用于实现发布/订阅模式的核心机制。它允许 Saga 之间进行通信，而无需直接调用彼此的函数。</li>\n</ul>\n</li>\n<li><strong>Task</strong>  ：\n<ul>\n<li>Task 是 redux-saga 中用于管理 Saga 执行的一个抽象。它可以被启动、取消或加入到一个并行任务中。</li>\n</ul>\n</li>\n</ol>\n<h3>五、优势</h3>\n<ol>\n<li><strong>易于测试</strong>  ：\n<ul>\n<li>由于 redux-saga 使用声明式的 Effect 来描述副作用操作，因此可以很容易地对 Saga 进行单元测试。你只需要比较执行 Effect 方法后返回的描述对象，与你所期望的描述对象是否相同即可。</li>\n</ul>\n</li>\n<li><strong>灵活的控制流</strong>  ：\n<ul>\n<li>redux-saga 提供了丰富的 Effect 和控制流操作符（如 <code>race</code>、<code>all</code>、<code>fork</code> 等），允许你实现复杂的异步流程。</li>\n</ul>\n</li>\n<li><strong>更好的错误处理</strong>  ：\n<ul>\n<li>redux-saga 提供了内置的错误处理机制，允许你在 Saga 中捕获异常，并采取相应的措施（如重试、记录日志等）。</li>\n</ul>\n</li>\n</ol>\n<h3>六、与其他中间件的比较</h3>\n<ul>\n<li><strong>redux-thunk</strong>  ：\n<ul>\n<li>redux-thunk 是另一个常用的 Redux 中间件，用于处理异步操作。与 redux-saga 相比，redux-thunk 更简单，但灵活性较低。它适合处理简单的异步操作，但对于复杂的异步流程则显得力不从心。</li>\n</ul>\n</li>\n<li><strong>redux-promise</strong>  ：\n<ul>\n<li>redux-promise 是一个专门用于处理 Promise 类型异步操作的中间件。与 redux-saga 相比，它的功能较为单一，且无法处理复杂的异步流程。</li>\n</ul>\n</li>\n</ul>\n<h3>七、总结</h3>\n<p>redux-saga 是一个功能强大、灵活且易于测试的 Redux 中间件，特别适合处理复杂的异步流程。通过使用 Generator 函数和声明式的 Effect，redux-saga 使得异步代码看起来像同步代码，易于阅读和测试。同时，它还提供了丰富的控制流操作符和错误处理机制，使得开发者能够更轻松地管理 Redux 应用中的副作用。</p>\n</div>'</script></body></html>