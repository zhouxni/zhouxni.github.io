<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5c12(t,s){var e=_0x2386();return(_0x5c12=function(s,n){var a=e[s-=444];void 0===_0x5c12.hiPPEM&&(_0x5c12.TObVob=function(s,n){var a,l=[],t=0,e="";for(s=(s=>{for(var n,a,l="",t="",e=0,o=0;a=s.charAt(o++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,c=l.length;p<c;p++)t+="%"+("00"+l.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(t)})(s),o=0;o<256;o++)l[o]=o;for(o=0;o<256;o++)t=(t+l[o]+n.charCodeAt(o%n.length))%256,a=l[o],l[o]=l[t],l[t]=a;for(var o=0,t=0,p=0;p<s.length;p++)a=l[o=(o+1)%256],l[o]=l[t=(t+l[o])%256],l[t]=a,e+=String.fromCharCode(s.charCodeAt(p)^l[(l[o]+l[t])%256]);return e},t=arguments,_0x5c12.hiPPEM=!0);var s=s+e[0],l=t[s];return l?a=l:(void 0===_0x5c12.rkIcKN&&(_0x5c12.rkIcKN=!0),a=_0x5c12.TObVob(a,n),t[s]=a),a})(t,s)}var _0x1de705=_0x5c12;if((()=>{for(var s=_0x5c12,n=_0x2386();;)try{if(898496==+parseInt(s(469,"KuYm"))+parseInt(s(449,"FL]p"))/2*(parseInt(s(454,"R!8$"))/3)+parseInt(s(450,"K*Rf"))/4*(-parseInt(s(461,"Q)Kd"))/5)+parseInt(s(444,"j2l^"))/6+-parseInt(s(463,"F!wC"))/7*(-parseInt(s(446,"tp#g"))/8)+-parseInt(s(470,"!zBv"))/9+-parseInt(s(462,"4]88"))/10*(parseInt(s(464,"SIaQ"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1de705(451,"g7S&")](_0x1de705(457,"aH2Y"))!=_0x1de705(460,"$YdN"))throw window[_0x1de705(452,")d94")][_0x1de705(445,"fGaM")](_0x1de705(458,"aH2Y")),Error();function _0x2386(){var s=["BxFcI3joWPVdHSomWQFcShi","utiKW6WWCWT1WPldLCoNW7C8","omooeSoxpmoBW6NcV8k8W4ldPG","WQ7dV8kSWRFdMKb/W7hcMCkohWRcQG","W7VcU8kuW6tcGmoixa","ifGUWPXRWQxcN3xcOG","W51QjSkXgSonW5hcNSoQpf5VWO1+","BmoQaCk6amoVW7xdPmkrFc3cLam","W5mqyCojWPniW7RdPbu","WRdcNmogW7xdGCoZWRG","ASkcl8k0W4ldMtO","W7yjDftdPsdcTSoh","aYHFWOjuW43cTtnpqSoSsaW","ECoIyCoaqmk7WO/cLCoJmxO","bMNcKJZdNmkZWOuIAa","WODyuxRcHCkBWPBcQuiWwHRdGa","mJjtW5LqWR7dTqxcRW","gYveW4XqW7FcKu/cRmoLnmkfW4RdS8k3BgTfW6XkW43cNbXXWOOB","WRhdQgZdJe/cV1qR","r2GvW4KD","W5FcMSoPW63cMvldKmoJWP0an8kWka","WOzDkaldGSoIW7RcLW","W7XlvY1+h8o+hSozW7jlWP8","fCoyWRBdSCoDzCoNywxcQ1aEdmkQ","BmoOcmodF8kCWO/dNCkb","W5GkzmoUCSkuWP4","s8oXuJS4WO07pZfTWPWX","WRSoFSoWFSomlqJcGKiT"];return(_0x2386=function(){return s})()}document.title="Recoil hooks 详解",document.getElementById("article").innerHTML='<div><p>Recoil 提供了一系列实用的 Hook，用于在组件中与 Recoil 状态（Atom 和 Selector）进行交互。这些 Hook 针对不同场景设计，帮助你高效地读取、修改和管理状态。以下是 Recoil 核心 Hook 的详细解析：</p>\n<h3>1. <code>useRecoilState(atom | writableSelector)</code></h3>\n<ul>\n<li>\n<p><strong>功能</strong>   ：类似 React 的 <code>useState</code>，同时获取状态值和更新函数</p>\n</li>\n<li>\n<p><strong>特点</strong>   ：</p>\n<ul>\n<li>组件会订阅状态变化，状态更新时会重新渲染</li>\n<li>适用于既需要读取状态又需要修改状态的场景</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { useRecoilState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;recoil&quot;</span>;\n<span class="hljs-keyword">import</span> { countState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./atoms&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useRecoilState</span>(countState);\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount((prev) =&gt; prev + 1)}&gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n</li>\n</ul>\n<h3>2. <code>useRecoilValue(atom | selector)</code></h3>\n<ul>\n<li>\n<p><strong>功能</strong>   ：仅获取状态值（只读）</p>\n</li>\n<li>\n<p><strong>特点</strong>   ：</p>\n<ul>\n<li>组件会订阅状态变化，状态更新时会重新渲染</li>\n<li>适用于只需要读取状态，不需要修改状态的场景</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { useRecoilValue } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;recoil&quot;</span>;\n<span class="hljs-keyword">import</span> { userState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./atoms&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">UserName</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useRecoilValue</span>(userState);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Welcome, {user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ul>\n<h3>3. <code>useSetRecoilState(atom | writableSelector)</code></h3>\n<ul>\n<li>\n<p><strong>功能</strong>   ：仅获取状态更新函数</p>\n</li>\n<li>\n<p><strong>特点</strong>   ：</p>\n<ul>\n<li>组件<strong>不会</strong>   订阅状态变化，状态更新时不会重新渲染</li>\n<li>适用于只需要修改状态，不需要读取状态的场景（性能优化）</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { useSetRecoilState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;recoil&quot;</span>;\n<span class="hljs-keyword">import</span> { themeState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./atoms&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeToggle</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> setTheme = <span class="hljs-title function_">useSetRecoilState</span>(themeState);\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>\n      <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span>\n        setTheme((prev) =&gt; (prev === &quot;light&quot; ? &quot;dark&quot; : &quot;light&quot;))\n      }\n    &gt;\n      Toggle Theme\n    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>\n  );\n}\n</code></pre>\n</li>\n</ul>\n<h3>4. <code>useResetRecoilState(atom | writableSelector)</code></h3>\n<ul>\n<li>\n<p><strong>功能</strong>   ：获取将状态重置为默认值的函数</p>\n</li>\n<li>\n<p><strong>特点</strong>   ：</p>\n<ul>\n<li>重置操作会触发所有订阅该状态的组件重新渲染</li>\n<li>适用于需要重置状态的场景（如表单重置、页面刷新）</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { useResetRecoilState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;recoil&quot;</span>;\n<span class="hljs-keyword">import</span> { formState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./atoms&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">ResetFormButton</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> resetForm = <span class="hljs-title function_">useResetRecoilState</span>(formState);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{resetForm}</span>&gt;</span>Reset Form<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ul>\n<h3>5. <code>useRecoilValueLoadable(selector)</code></h3>\n<ul>\n<li>\n<p><strong>功能</strong>   ：处理异步 Selector 的加载状态（加载中、成功、错误）</p>\n</li>\n<li>\n<p><strong>特点</strong>   ：</p>\n<ul>\n<li>适用于异步 Selector（包含网络请求或异步计算的 Selector）</li>\n<li>返回一个 <code>Loadable</code> 对象，包含状态（<code>loading</code>/<code>hasValue</code>/<code>hasError</code>）和数据</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { useRecoilValueLoadable } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;recoil&quot;</span>;\n<span class="hljs-keyword">import</span> { userDataSelector } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./selectors&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> userData = <span class="hljs-title function_">useRecoilValueLoadable</span>(userDataSelector);\n\n  <span class="hljs-keyword">switch</span> (userData.<span class="hljs-property">state</span>) {\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;loading&quot;</span>:\n      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading user data...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hasError&quot;</span>:\n      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Error: {userData.contents.message}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hasValue&quot;</span>:\n      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Name: {userData.contents.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n</li>\n</ul>\n<h3>6. <code>useRecoilCallback</code></h3>\n<ul>\n<li>\n<p><strong>功能</strong>   ：创建一个回调函数，在函数内部可以安全地读取/修改 Recoil 状态</p>\n</li>\n<li>\n<p><strong>特点</strong>   ：</p>\n<ul>\n<li>适用于需要在非 React 回调（如事件处理、定时器）中操作状态的场景</li>\n<li>避免闭包陷阱，确保获取最新的状态值</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { useRecoilCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;recoil&quot;</span>;\n<span class="hljs-keyword">import</span> { countState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./atoms&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">DelayedIncrement</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> incrementAfterDelay = <span class="hljs-title function_">useRecoilCallback</span>(\n    <span class="hljs-function">(<span class="hljs-params">{ set }</span>) =&gt;</span>\n      <span class="hljs-title function_">async</span> (delay) =&gt; {\n        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, delay));\n        <span class="hljs-title function_">set</span>(countState, <span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> prev + <span class="hljs-number">1</span>); <span class="hljs-comment">// 确保获取最新状态</span>\n      },\n  );\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> incrementAfterDelay(1000)}&gt;\n      Increment after 1s\n    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>\n  );\n}\n</code></pre>\n</li>\n</ul>\n<h3>7. <code>useRecoilSnapshot</code></h3>\n<ul>\n<li>\n<p><strong>功能</strong>   ：获取当前 Recoil 状态的快照（<code>Snapshot</code> 对象）</p>\n</li>\n<li>\n<p><strong>特点</strong>   ：</p>\n<ul>\n<li>快照是状态的只读副本，可用于调试、持久化或状态比较</li>\n<li>组件会在任何状态变化时重新渲染（性能开销较大，谨慎使用）</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { useRecoilSnapshot } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;recoil&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">DebugState</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> snapshot = <span class="hljs-title function_">useRecoilSnapshot</span>();\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>{JSON.stringify(snapshot.getNodes_UNSTABLE(), null, 2)}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ul>\n<h3>8. <code>useGotoRecoilState</code></h3>\n<ul>\n<li>\n<p><strong>功能</strong>   ：获取一个函数，用于直接跳转到指定状态值（替代增量更新）</p>\n</li>\n<li>\n<p><strong>特点</strong>   ：</p>\n<ul>\n<li>类似 <code>useSetRecoilState</code>，但更强调“跳转”到某个具体值</li>\n<li>适用于需要直接设置状态为特定值的场景（如导航、状态重置）</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { useGotoRecoilState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;recoil&quot;</span>;\n<span class="hljs-keyword">import</span> { stepState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./atoms&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">JumpToStep</span>(<span class="hljs-params">{ targetStep }</span>) {\n  <span class="hljs-keyword">const</span> gotoStep = <span class="hljs-title function_">useGotoRecoilState</span>(stepState);\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> gotoStep(targetStep)}&gt;\n      Go to Step {targetStep}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>\n  );\n}\n</code></pre>\n</li>\n</ul>\n<h3>总结：Hook 选择指南</h3>\n<table>\n<thead>\n<tr>\n<th>场景需求</th>\n<th>推荐 Hook</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读写状态</td>\n<td><code>useRecoilState</code></td>\n</tr>\n<tr>\n<td>只读状态</td>\n<td><code>useRecoilValue</code></td>\n</tr>\n<tr>\n<td>只写状态</td>\n<td><code>useSetRecoilState</code></td>\n</tr>\n<tr>\n<td>重置状态</td>\n<td><code>useResetRecoilState</code></td>\n</tr>\n<tr>\n<td>处理异步状态</td>\n<td><code>useRecoilValueLoadable</code></td>\n</tr>\n<tr>\n<td>非 React 环境操作状态</td>\n<td><code>useRecoilCallback</code></td>\n</tr>\n<tr>\n<td>调试/快照状态</td>\n<td><code>useRecoilSnapshot</code></td>\n</tr>\n<tr>\n<td>直接跳转状态值</td>\n<td><code>useGotoRecoilState</code></td>\n</tr>\n</tbody>\n</table>\n<p>合理使用这些 Hook 可以使状态管理更高效，同时避免不必要的组件重渲染，提升应用性能。</p>\n<h3>writableSelector 详解</h3>\n<p>在 Recoil 中，<code>writableSelector</code>（可写选择器）是一种特殊的 <code>Selector</code>，它不仅可以像普通 Selector 一样基于其他状态（Atom 或 Selector）计算派生状态，还支持通过 <code>set</code> 方法修改其关联的底层状态（通常是 Atom）。</p>\n<p>普通 Selector 只有 <code>get</code> 方法（只读），而 <code>writableSelector</code> 额外提供了 <code>set</code> 方法，使其具备“读写两用”的能力。</p>\n<h3>核心特点</h3>\n<ol>\n<li><strong>兼具计算与修改能力</strong>   ：既可以通过 <code>get</code> 方法从其他状态派生值，也可以通过 <code>set</code> 方法反向修改依赖的底层状态。</li>\n<li><strong>保持状态单一来源</strong>   ：修改操作最终会作用于底层的 Atom，避免状态分散。</li>\n<li><strong>支持与 Recoil Hook 配合</strong>   ：可以像 Atom 一样使用 <code>useRecoilState</code>、<code>useSetRecoilState</code> 等 Hook 进行操作。</li>\n</ol>\n<h3>定义方式</h3>\n<p>通过 <code>selector</code> 函数创建，同时指定 <code>get</code>（计算逻辑）和 <code>set</code>（修改逻辑）：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { atom, selector } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;recoil&quot;</span>;\n\n<span class="hljs-comment">// 1. 定义底层 Atom（状态的实际存储位置）</span>\n<span class="hljs-keyword">const</span> firstNameState = <span class="hljs-title function_">atom</span>({\n  <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;firstNameState&quot;</span>,\n  <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;John&quot;</span>,\n});\n\n<span class="hljs-keyword">const</span> lastNameState = <span class="hljs-title function_">atom</span>({\n  <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;lastNameState&quot;</span>,\n  <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;Doe&quot;</span>,\n});\n\n<span class="hljs-comment">// 2. 定义 writableSelector（可读写的派生状态）</span>\n<span class="hljs-keyword">const</span> fullNameState = <span class="hljs-title function_">selector</span>({\n  <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;fullNameState&quot;</span>, <span class="hljs-comment">// 唯一标识</span>\n  <span class="hljs-comment">// 计算逻辑：从 first/lastName 派生 fullName</span>\n  <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">{ get }</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> firstName = <span class="hljs-title function_">get</span>(firstNameState);\n    <span class="hljs-keyword">const</span> lastName = <span class="hljs-title function_">get</span>(lastNameState);\n    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${firstName}</span> <span class="hljs-subst">${lastName}</span>`</span>;\n  },\n  <span class="hljs-comment">// 修改逻辑：将 fullName 拆分为 first/lastName 并更新底层 Atom</span>\n  <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">{ set }, newValue</span>) =&gt;</span> {\n    <span class="hljs-comment">// 假设 newValue 是 &quot;FirstName LastName&quot; 格式的字符串</span>\n    <span class="hljs-keyword">const</span> [firstName, lastName] = newValue.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>);\n    <span class="hljs-title function_">set</span>(firstNameState, firstName); <span class="hljs-comment">// 更新底层 Atom</span>\n    <span class="hljs-title function_">set</span>(lastNameState, lastName); <span class="hljs-comment">// 更新底层 Atom</span>\n  },\n});\n</code></pre>\n<h3>使用场景</h3>\n<p>当需要从多个状态派生出一个“聚合状态”，且希望能通过修改这个聚合状态间接更新底层状态时，<code>writableSelector</code> 非常有用。</p>\n<p>例如上述示例中，<code>fullNameState</code> 是 <code>firstNameState</code> 和 <code>lastNameState</code> 的聚合，通过 <code>set</code> 方法可以一次性修改全名，底层会自动拆分并更新对应的 Atom。</p>\n<h3>如何使用</h3>\n<p><code>writableSelector</code> 可以像 Atom 一样与 Recoil Hook 配合使用：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { useRecoilState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;recoil&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">NameEditor</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 同时读写 writableSelector</span>\n  <span class="hljs-keyword">const</span> [fullName, setFullName] = <span class="hljs-title function_">useRecoilState</span>(fullNameState);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">input</span>\n        <span class="hljs-attr">value</span>=<span class="hljs-string">{fullName}</span>\n        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setFullName(e.target.value)} // 修改会触发底层 Atom 更新\n      /&gt;\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Full Name: {fullName}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h3>注意事项</h3>\n<ol>\n<li>\n<p><code>set</code> 方法的参数：</p>\n<ul>\n<li>第一个参数是工具集（包含 <code>set</code>、<code>get</code>、<code>reset</code> 等方法，用于操作其他状态）。</li>\n<li>第二个参数是新值（即通过 Hook 传递的更新值）。</li>\n</ul>\n</li>\n<li>\n<p>状态修改的最终载体：<code>writableSelector</code> 本身不存储状态，修改操作最终会作用于其依赖的 Atom（或其他可写状态）。</p>\n</li>\n<li>\n<p>与只读 Selector 的区别：只读 Selector 只有 <code>get</code> 方法，不能用于 <code>useRecoilState</code> 或 <code>useSetRecoilState</code>，而 <code>writableSelector</code> 可以。</p>\n</li>\n</ol>\n<p>通过 <code>writableSelector</code>，可以在保持状态单一来源的同时，提供更灵活的状态操作方式，特别适合处理具有复杂依赖关系的派生状态。</p>\n</div>'</script></body></html>