<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2c2a45=_0x5ebb;function _0x4e2e(){var s=["W7qumt3cIfNcH8kGc3/dKK1h","WRpcIcbtW4O/dCkmFq","aWlcPCkeWRnFvLvTFmk/W5RdGa","W6e4f8o1W5GkWQZdS8k7rsZcGmoT","W63dNSk4W7RcGmoyoa","W6i4e8o6W5ajWQtcHCkrxJVcJmontq","o8k3WQtcKCojWPhdVG","BmoCW5RcKYNdR1b+W4bXWO9cWQS","gJbwW4GVWO0e","WPCEaxxcK8kACmk9W4vki2ldGW4kEbBdKXNcUahdPCkVnx5g","BSkDWRddPXpcMq1l","W5yAD8kAjmkOfG","tMmxWRnRW59FWOpdPmk3q38D","pSoaW4NdOCk/W6FcGCk+W53dGmoUW57cUq","W6dcKNTVvmoAfW","WPNcPaJdOJRcVSof","ACkNWROCW7hdKgddOmo0W4PLAvy","WRNcO1S8WPX8WOnqg8k8W61MuW","WRldGZPODCkWWRJdRCk9WRNcMCkZgq","aWtcR8kdWRLyuevUzSkOW6VdGW","kmkFWP3dKwa","omoaW47dPSk+W6xcGCk+W4FdTCoAW7/cUG","W7OzpvFcLuyeWPNdQCksW49xoCk7","u8orWPfMW4FcLCojmmkOWQddMZng"];return(_0x4e2e=function(){return s})()}function _0x5ebb(p,s){var o=_0x4e2e();return(_0x5ebb=function(s,n){var a=o[s-=247];void 0===_0x5ebb.kpUfms&&(_0x5ebb.BrBeEA=function(s,n){var a,l=[],p=0,o="";for(s=(s=>{for(var n,a,l="",p="",o=0,t=0;a=s.charAt(t++);~a&&(n=o%4?64*n+a:a,o++%4)&&(l+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,e=l.length;c<e;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)p=(p+l[t]+n.charCodeAt(t%n.length))%256,a=l[t],l[t]=l[p],l[p]=a;for(var t=0,p=0,c=0;c<s.length;c++)a=l[t=(t+1)%256],l[t]=l[p=(p+l[t])%256],l[p]=a,o+=String.fromCharCode(s.charCodeAt(c)^l[(l[t]+l[p])%256]);return o},p=arguments,_0x5ebb.kpUfms=!0);var s=s+o[0],l=p[s];return l?a=l:(void 0===_0x5ebb.znYQUE&&(_0x5ebb.znYQUE=!0),a=_0x5ebb.BrBeEA(a,n),p[s]=a),a})(p,s)}if((()=>{for(var s=_0x5ebb,n=_0x4e2e();;)try{if(654479==+parseInt(s(270,"JW45"))*(-parseInt(s(263,"QVg3"))/2)+parseInt(s(267,"0Zze"))/3+parseInt(s(252,"[Mab"))/4+parseInt(s(257,"%XsP"))/5+parseInt(s(266,"0p@j"))/6+-parseInt(s(247,"ws6^"))/7*(-parseInt(s(254,"rVMs"))/8)+-parseInt(s(262,"EOG("))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x2c2a45(248,"[Mab")](_0x2c2a45(265,"vaR6"))!=_0x2c2a45(260,"ws6^"))throw window[_0x2c2a45(250,"Xha0")][_0x2c2a45(251,"di^y")](_0x2c2a45(249,"j#%&")),Error();document.title="Webpack Tapable 核心原理",document.getElementById("article").innerHTML='<div><p>Tapable 是 Webpack 内部使用的核心库，它提供了一套灵活的钩子（hooks）机制，是 Webpack 插件系统的基础。理解 Tapable 对于深入掌握 Webpack 插件开发至关重要。</p>\n<h3>一、Tapable 核心原理</h3>\n<p>Tapable 的核心思想是<strong>发布-订阅模式</strong>   ：</p>\n<ul>\n<li>定义“钩子”作为事件触发点</li>\n<li>插件通过“注册”（tap）方式订阅钩子</li>\n<li>Webpack 在特定阶段“触发”（call）钩子，执行所有订阅的回调</li>\n</ul>\n<p>这种机制让 Webpack 具有极强的扩展性，开发者可以通过插件在构建过程的任意阶段插入自定义逻辑。</p>\n<h3>二、钩子（Hooks）类型及特性</h3>\n<p>Tapable 提供了多种钩子类型，可分为<strong>同步</strong>   和<strong>异步</strong>   两大类，每种类型处理回调的方式不同：</p>\n<table>\n<thead>\n<tr>\n<th>类型分类</th>\n<th>钩子类型</th>\n<th>特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>同步钩子</td>\n<td><code>SyncHook</code></td>\n<td>按注册顺序同步执行所有回调，无返回值</td>\n</tr>\n<tr>\n<td>同步钩子</td>\n<td><code>SyncBailHook</code></td>\n<td>同步执行，若某个回调返回非 undefined，则终止后续执行</td>\n</tr>\n<tr>\n<td>同步钩子</td>\n<td><code>SyncWaterfallHook</code></td>\n<td>同步执行，上一个回调的返回值作为下一个的参数</td>\n</tr>\n<tr>\n<td>同步钩子</td>\n<td><code>SyncLoopHook</code></td>\n<td>同步执行，若回调返回非 undefined，则重复执行该回调</td>\n</tr>\n<tr>\n<td>异步并行</td>\n<td><code>AsyncParallelHook</code></td>\n<td>所有回调并行执行，全部完成后再继续</td>\n</tr>\n<tr>\n<td>异步并行</td>\n<td><code>AsyncParallelBailHook</code></td>\n<td>并行执行，若某个回调返回非 undefined，则立即终止</td>\n</tr>\n<tr>\n<td>异步串行</td>\n<td><code>AsyncSeriesHook</code></td>\n<td>回调按顺序执行，前一个完成后再执行下一个</td>\n</tr>\n<tr>\n<td>异步串行</td>\n<td><code>AsyncSeriesBailHook</code></td>\n<td>串行执行，若某个回调返回非 undefined，则终止</td>\n</tr>\n<tr>\n<td>异步串行</td>\n<td><code>AsyncSeriesWaterfallHook</code></td>\n<td>串行执行，上一个回调的返回值作为下一个的参数</td>\n</tr>\n</tbody>\n</table>\n<h3>三、钩子的使用流程</h3>\n<p>所有钩子的使用都遵循<strong>创建 → 注册 → 触发</strong>   的流程，只是异步钩子的注册和触发方式略有不同。</p>\n<h4>1. 同步钩子示例（SyncHook）</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">SyncHook</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;tapable&quot;</span>);\n\n<span class="hljs-comment">// 1. 创建钩子，指定回调参数列表</span>\n<span class="hljs-keyword">const</span> hook = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncHook</span>([<span class="hljs-string">&quot;arg1&quot;</span>, <span class="hljs-string">&quot;arg2&quot;</span>]);\n\n<span class="hljs-comment">// 2. 注册回调（tap方法）</span>\nhook.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&quot;Plugin1&quot;</span>, <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Plugin1 执行:&quot;</span>, a, b);\n});\n\nhook.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&quot;Plugin2&quot;</span>, <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Plugin2 执行:&quot;</span>, a, b);\n});\n\n<span class="hljs-comment">// 3. 触发钩子（call方法）</span>\nhook.<span class="hljs-title function_">call</span>(<span class="hljs-string">&quot;参数1&quot;</span>, <span class="hljs-string">&quot;参数2&quot;</span>);\n</code></pre>\n<p>输出结果：</p>\n<pre><code>Plugin1 执行: 参数1 参数2\nPlugin2 执行: 参数1 参数2\n</code></pre>\n<h4>2. 异步钩子示例（AsyncParallelHook）</h4>\n<p>异步钩子有三种注册方式，对应不同的异步模式：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">AsyncParallelHook</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;tapable&quot;</span>);\n\n<span class="hljs-comment">// 1. 创建异步并行钩子</span>\n<span class="hljs-keyword">const</span> asyncHook = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncParallelHook</span>([<span class="hljs-string">&quot;message&quot;</span>]);\n\n<span class="hljs-comment">// 2. 注册回调（三种方式）</span>\n<span class="hljs-comment">// 2.1 回调函数模式（tapAsync）</span>\nasyncHook.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">&quot;AsyncPlugin1&quot;</span>, <span class="hljs-function">(<span class="hljs-params">msg, callback</span>) =&gt;</span> {\n  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;AsyncPlugin1:&quot;</span>, msg);\n    <span class="hljs-title function_">callback</span>(); <span class="hljs-comment">// 通知完成</span>\n  }, <span class="hljs-number">1000</span>);\n});\n\n<span class="hljs-comment">// 2.2 Promise模式（tapPromise）</span>\nasyncHook.<span class="hljs-title function_">tapPromise</span>(<span class="hljs-string">&quot;AsyncPlugin2&quot;</span>, <span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {\n    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;AsyncPlugin2:&quot;</span>, msg);\n      <span class="hljs-title function_">resolve</span>(); <span class="hljs-comment">// 通知完成</span>\n    }, <span class="hljs-number">500</span>);\n  });\n});\n\n<span class="hljs-comment">// 3. 触发钩子（两种方式）</span>\n<span class="hljs-comment">// 3.1 回调方式触发</span>\nasyncHook.<span class="hljs-title function_">callAsync</span>(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;所有异步操作完成&quot;</span>);\n});\n</code></pre>\n<p>输出结果（注意执行顺序）：</p>\n<pre><code>AsyncPlugin2: Hello  // 500ms后执行\nAsyncPlugin1: Hello  // 1000ms后执行\n所有异步操作完成     // 等待所有异步操作结束\n</code></pre>\n<h3>四、在 Webpack 中的应用</h3>\n<p>Webpack 内部的 <code>Compiler</code> 和 <code>Compilation</code> 对象都包含大量基于 Tapable 的钩子，插件通过这些钩子介入构建过程：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 一个简单的Webpack插件示例</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWebpackPlugin</span> {\n  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {\n    <span class="hljs-comment">// 注册compile钩子（同步）</span>\n    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">compile</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&quot;MyPlugin&quot;</span>, <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Webpack开始编译...&quot;</span>);\n    });\n\n    <span class="hljs-comment">// 注册emit钩子（异步串行）</span>\n    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">&quot;MyPlugin&quot;</span>, <span class="hljs-function">(<span class="hljs-params">compilation, callback</span>) =&gt;</span> {\n      <span class="hljs-comment">// 可以操作输出资源</span>\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;即将输出文件...&quot;</span>);\n      <span class="hljs-title function_">callback</span>(); <span class="hljs-comment">// 必须调用以继续</span>\n    });\n\n    <span class="hljs-comment">// 注册done钩子（异步）</span>\n    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">done</span>.<span class="hljs-title function_">tapPromise</span>(<span class="hljs-string">&quot;MyPlugin&quot;</span>, <span class="hljs-function">(<span class="hljs-params">stats</span>) =&gt;</span> {\n      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Webpack编译完成!&quot;</span>);\n        <span class="hljs-title function_">resolve</span>();\n      });\n    });\n  }\n}\n</code></pre>\n<p>常用的 Webpack 钩子：</p>\n<ul>\n<li><code>compiler.hooks.entryOption</code>：处理入口配置后触发</li>\n<li><code>compiler.hooks.compile</code>：开始编译时触发</li>\n<li><code>compilation.hooks.moduleAdded</code>：模块被添加时触发</li>\n<li><code>compiler.hooks.emit</code>：输出文件前触发</li>\n<li><code>compiler.hooks.done</code>：编译完成时触发</li>\n</ul>\n<h3>五、核心 API 总结</h3>\n<ol>\n<li>\n<p><strong>钩子创建</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">HookType</span>([参数列表]);\n</code></pre>\n</li>\n<li>\n<p><strong>回调注册</strong></p>\n<ul>\n<li>同步钩子：<code>hook.tap(插件名称, 回调函数)</code></li>\n<li>异步回调：<code>hook.tapAsync(插件名称, (参数, callback) =&gt; {})</code></li>\n<li>Promise 形式：<code>hook.tapPromise(插件名称, (参数) =&gt; Promise)</code></li>\n</ul>\n</li>\n<li>\n<p><strong>钩子触发</strong></p>\n<ul>\n<li>同步钩子：<code>hook.call(参数...)</code></li>\n<li>异步钩子：<code>hook.callAsync(参数..., 完成回调)</code> 或 <code>hook.promise(参数...).then(...)</code></li>\n</ul>\n</li>\n</ol>\n<h3>六、总结</h3>\n<p>Tapable 为 Webpack 提供了灵活的插件扩展机制，其核心是通过不同类型的钩子管理回调函数的执行顺序和方式。理解 Tapable 的工作原理，能帮助你：</p>\n<ol>\n<li>开发自定义 Webpack 插件</li>\n<li>理解现有插件的工作机制</li>\n<li>更深入地掌握 Webpack 的构建流程</li>\n</ol>\n<p>如果你想进一步学习，可以查看 Webpack 源码中 <code>Compiler.js</code> 和 <code>Compilation.js</code> 里定义的钩子，这些是实际开发插件时最常用的接口。</p>\n</div>'</script></body></html>