<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x20a4(){var s=["n0VcImkOh8k/mCo6haFdHG","zSkwgxBdJmkpWRuHWPuBWORcNSkx","nCk8WRqFrSk1WQdcUCk+aCkck18","W58vWOlcISkAC0tcKGCnWQrD","qmkfmmo/fmoPW77dTJmBhK8","WOL2f8obWRldLSo+W4SBWR7cVCod","WQBdPhWwW50anqldQJS","jCobxs/cLmoCW6y","W7nvhqfhemo8","nmoaW50fWRLmpx9wWRFcTCoN","CSklWOCnh8kpW40WuSkXWO4","jmoyW4bZwSkcW6G","nuRcJSkTgSoPi8ofabldVCot","o8oltIlcGCowW6Wo","wwVcGXRcHLms","W5VcSSoDamkStZldK8obW7ftW4y","WRRcOdunrW5xnedcKq","kSkOD2u4tIpcL1K","WPXuW4ddI8or","AWRdImoTxmoMtSkhfZZdK8owmCkWkCk0WR3cU8omW7LwxCklaImX","W53dU8koW4mNnCotgCkjb8kIwSkV","W7y2s3qBdCogW7ldL1mW","mCoPCdPTW63dNa","W4e/W5WFW547W4uRzd7dMa","W6LnW4TSDGVdG3pdO8kQW57dTIK","EuxdPSkaW5eCnq"];return(_0x20a4=function(){return s})()}function _0xe254(p,s){var c=_0x20a4();return(_0xe254=function(s,n){var a=c[s-=357];void 0===_0xe254.pPHdqO&&(_0xe254.JWfPhr=function(s,n){var a,l=[],p=0,c="";for(s=(s=>{for(var n,a,l="",p="",c=0,t=0;a=s.charAt(t++);~a&&(n=c%4?64*n+a:a,c++%4)&&(l+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,r=l.length;e<r;e++)p+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(p)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)p=(p+l[t]+n.charCodeAt(t%n.length))%256,a=l[t],l[t]=l[p],l[p]=a;for(var t=0,p=0,e=0;e<s.length;e++)a=l[t=(t+1)%256],l[t]=l[p=(p+l[t])%256],l[p]=a,c+=String.fromCharCode(s.charCodeAt(e)^l[(l[t]+l[p])%256]);return c},p=arguments,_0xe254.pPHdqO=!0);var s=s+c[0],l=p[s];return l?a=l:(void 0===_0xe254.oBxrxU&&(_0xe254.oBxrxU=!0),a=_0xe254.JWfPhr(a,n),p[s]=a),a})(p,s)}var _0x9bff15=_0xe254;if((()=>{for(var s=_0xe254,n=_0x20a4();;)try{if(270530==+parseInt(s(369,"6XEi"))+parseInt(s(358,"5iHo"))/2*(parseInt(s(376,"2MHN"))/3)+-parseInt(s(368,"9P6e"))/4*(-parseInt(s(366,"RPaU"))/5)+-parseInt(s(378,"IwM7"))/6+-parseInt(s(374,"uMf@"))/7+-parseInt(s(370,"scYj"))/8*(-parseInt(s(364,"PMZN"))/9)+-parseInt(s(380,"RPaU"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x9bff15(365,"PMZN")](_0x9bff15(371,"h7f$"))!=_0x9bff15(372,"^7!o"))throw window[_0x9bff15(367,"#yM*")][_0x9bff15(361,"#yM*")](_0x9bff15(373,"RPaU")),Error();document.title="JavaScript 函数式编程详解",document.getElementById("article").innerHTML='<div><h1>JavaScript 函数式编程详解</h1>\n<p>函数式编程(FP - Functional Programming)是一种编程范式，它强调通过纯函数、不可变数据和函数组合来构建软件。JavaScript 作为一种多范式语言，非常适合函数式编程。</p>\n<h2>一、函数式编程核心概念</h2>\n<h3>1. 纯函数 (Pure Functions)</h3>\n<p>纯函数是函数式编程的基石，具有以下特性：</p>\n<ul>\n<li>相同的输入总是产生相同的输出</li>\n<li>没有副作用(不修改外部状态)</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// 纯函数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) {\n  <span class="hljs-keyword">return</span> a + b;\n}\n\n<span class="hljs-comment">// 非纯函数 - 依赖外部状态</span>\n<span class="hljs-keyword">let</span> taxRate = <span class="hljs-number">0.1</span>;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateTax</span>(<span class="hljs-params">amount</span>) {\n  <span class="hljs-keyword">return</span> amount * taxRate; <span class="hljs-comment">// 依赖外部变量</span>\n}\n\n<span class="hljs-comment">// 非纯函数 - 有副作用</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">saveUser</span>(<span class="hljs-params">user</span>) {\n  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(user)); <span class="hljs-comment">// 修改外部状态</span>\n}\n</code></pre>\n<h3>2. 不可变性 (Immutability)</h3>\n<p>数据一旦创建就不能被修改，任何&quot;修改&quot;操作都会返回一个新值。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 可变操作 (不推荐)</span>\n<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];\narr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 直接修改原数组</span>\n\n<span class="hljs-comment">// 不可变操作 (推荐)</span>\n<span class="hljs-keyword">const</span> newArr = [...arr, <span class="hljs-number">4</span>]; <span class="hljs-comment">// 创建新数组</span>\n</code></pre>\n<h3>3. 函数是一等公民 (First-class Functions)</h3>\n<p>在JavaScript中，函数可以：</p>\n<ul>\n<li>被赋值给变量</li>\n<li>作为参数传递</li>\n<li>作为返回值</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// 赋值给变量</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">greet</span> = name =&gt; <span class="hljs-string">`Hello, <span class="hljs-subst">${name}</span>!`</span>;\n\n<span class="hljs-comment">// 作为参数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">func, value</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">func</span>(value);\n}\n\n<span class="hljs-comment">// 作为返回值</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">multiplier</span>(<span class="hljs-params">factor</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> number * factor;\n}\n</code></pre>\n<h3>4. 高阶函数 (Higher-order Functions)</h3>\n<p>接收函数作为参数或返回函数的函数。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 接收函数作为参数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">map</span>(<span class="hljs-params">array, transform</span>) {\n  <span class="hljs-keyword">const</span> result = [];\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> array) {\n    result.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">transform</span>(item));\n  }\n  <span class="hljs-keyword">return</span> result;\n}\n\n<span class="hljs-comment">// 返回函数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">createLogger</span>(<span class="hljs-params">prefix</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">message</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[<span class="hljs-subst">${prefix}</span>] <span class="hljs-subst">${message}</span>`</span>);\n  };\n}\n</code></pre>\n<h2>二、常用函数式编程技术</h2>\n<h3>1. 函数组合 (Function Composition)</h3>\n<p>将多个函数组合成一个新函数。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">compose</span> = (<span class="hljs-params">...fns</span>) =&gt; <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> fns.<span class="hljs-title function_">reduceRight</span>(<span class="hljs-function">(<span class="hljs-params">acc, fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>(acc), x);\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">toUpperCase</span> = str =&gt; str.<span class="hljs-title function_">toUpperCase</span>();\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">exclaim</span> = str =&gt; <span class="hljs-string">`<span class="hljs-subst">${str}</span>!`</span>;\n<span class="hljs-keyword">const</span> emphasize = <span class="hljs-title function_">compose</span>(exclaim, toUpperCase);\n\n<span class="hljs-title function_">emphasize</span>(<span class="hljs-string">&#x27;hello&#x27;</span>); <span class="hljs-comment">// &quot;HELLO!&quot;</span>\n</code></pre>\n<h3>2. 柯里化 (Currying)</h3>\n<p>将多参数函数转换为一系列单参数函数。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 普通函数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c</span>) {\n  <span class="hljs-keyword">return</span> a + b + c;\n}\n\n<span class="hljs-comment">// 柯里化版本</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">curryAdd</span>(<span class="hljs-params">a</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>) {\n      <span class="hljs-keyword">return</span> a + b + c;\n    };\n  };\n}\n\n<span class="hljs-comment">// 使用箭头函数简化</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">curryAdd</span> = a =&gt; <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> a + b + c;\n\n<span class="hljs-comment">// 使用</span>\n<span class="hljs-keyword">const</span> add5 = <span class="hljs-title function_">curryAdd</span>(<span class="hljs-number">5</span>);\n<span class="hljs-keyword">const</span> add5And10 = <span class="hljs-title function_">add5</span>(<span class="hljs-number">10</span>);\n<span class="hljs-title function_">add5And10</span>(<span class="hljs-number">15</span>); <span class="hljs-comment">// 30</span>\n</code></pre>\n<h3>3. 部分应用 (Partial Application)</h3>\n<p>固定函数的部分参数，创建一个新函数。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">partial</span>(<span class="hljs-params">fn, ...fixedArgs</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...remainingArgs</span>) =&gt;</span> <span class="hljs-title function_">fn</span>(...fixedArgs, ...remainingArgs);\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">multiply</span> = (<span class="hljs-params">a, b</span>) =&gt; a * b;\n<span class="hljs-keyword">const</span> double = <span class="hljs-title function_">partial</span>(multiply, <span class="hljs-number">2</span>);\n<span class="hljs-title function_">double</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 10</span>\n</code></pre>\n<h3>4. 递归 (Recursion)</h3>\n<p>函数式编程中常用递归代替循环。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 递归实现数组求和</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">arr, total = <span class="hljs-number">0</span></span>) {\n  <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> total;\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">sum</span>(arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>), total + arr[<span class="hljs-number">0</span>]);\n}\n\n<span class="hljs-comment">// 尾递归优化版本</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">arr, total = <span class="hljs-number">0</span></span>) {\n  <span class="hljs-keyword">return</span> arr.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> \n    ? total \n    : <span class="hljs-title function_">sum</span>(arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>), total + arr[<span class="hljs-number">0</span>]);\n}\n</code></pre>\n<h2>三、JavaScript 内置函数式方法</h2>\n<h3>1. 数组方法</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];\n\n<span class="hljs-comment">// map - 转换</span>\n<span class="hljs-keyword">const</span> doubled = numbers.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n * <span class="hljs-number">2</span>);\n\n<span class="hljs-comment">// filter - 过滤</span>\n<span class="hljs-keyword">const</span> evens = numbers.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);\n\n<span class="hljs-comment">// reduce - 累积</span>\n<span class="hljs-keyword">const</span> sum = numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, n</span>) =&gt;</span> acc + n, <span class="hljs-number">0</span>);\n\n<span class="hljs-comment">// find - 查找</span>\n<span class="hljs-keyword">const</span> firstEven = numbers.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);\n\n<span class="hljs-comment">// some/every - 测试</span>\n<span class="hljs-keyword">const</span> hasNegative = numbers.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n &lt; <span class="hljs-number">0</span>);\n<span class="hljs-keyword">const</span> allPositive = numbers.<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n &gt; <span class="hljs-number">0</span>);\n</code></pre>\n<h3>2. 其他实用方法</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 函数绑定</span>\n<span class="hljs-keyword">const</span> person = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,\n  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>); }\n};\n<span class="hljs-keyword">const</span> greet = person.<span class="hljs-property">greet</span>.<span class="hljs-title function_">bind</span>(person);\n\n<span class="hljs-comment">// 函数记忆化</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">memoize</span>(<span class="hljs-params">fn</span>) {\n  <span class="hljs-keyword">const</span> cache = {};\n  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> key = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(args);\n    <span class="hljs-keyword">return</span> cache[key] || (cache[key] = <span class="hljs-title function_">fn</span>(...args));\n  };\n}\n\n<span class="hljs-keyword">const</span> factorial = <span class="hljs-title function_">memoize</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> \n  n &lt;= <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : n * <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>));\n</code></pre>\n<h2>四、函数式编程库</h2>\n<h3>1. Lodash/fp</h3>\n<p>Lodash的函数式版本，所有方法都是自动柯里化且数据最后传入。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { map, filter, flow } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash/fp&#x27;</span>;\n\n<span class="hljs-keyword">const</span> processNumbers = <span class="hljs-title function_">flow</span>(\n  <span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>),\n  <span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n * n)\n);\n\n<span class="hljs-title function_">processNumbers</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]); <span class="hljs-comment">// [4, 16]</span>\n</code></pre>\n<h3>2. Ramda</h3>\n<p>专为函数式编程设计的实用库。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> R <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ramda&#x27;</span>;\n\n<span class="hljs-keyword">const</span> add3Numbers = R.<span class="hljs-title function_">curry</span>(<span class="hljs-function">(<span class="hljs-params">a, b, c</span>) =&gt;</span> a + b + c);\n<span class="hljs-keyword">const</span> add5 = <span class="hljs-title function_">add3Numbers</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);\n<span class="hljs-title function_">add5</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 15</span>\n\n<span class="hljs-keyword">const</span> users = [{<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>}, {<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>}];\n<span class="hljs-keyword">const</span> getNames = R.<span class="hljs-title function_">map</span>(R.<span class="hljs-title function_">prop</span>(<span class="hljs-string">&#x27;name&#x27;</span>));\n<span class="hljs-title function_">getNames</span>(users); <span class="hljs-comment">// [&#x27;Alice&#x27;, &#x27;Bob&#x27;]</span>\n</code></pre>\n<h2>五、函数式编程的优势</h2>\n<ol>\n<li><strong>可预测性</strong>  ：纯函数和不可变数据使代码行为更可预测</li>\n<li><strong>可测试性</strong>  ：纯函数更容易测试，不需要模拟环境</li>\n<li><strong>可维护性</strong>  ：代码更简洁，模块化程度高</li>\n<li><strong>并发安全</strong>  ：无副作用和不可变数据天然适合并发环境</li>\n<li><strong>可组合性</strong>  ：小函数可以灵活组合成复杂功能</li>\n</ol>\n<h2>六、函数式编程的挑战</h2>\n<ol>\n<li><strong>学习曲线</strong>  ：需要转变思维方式</li>\n<li><strong>性能考虑</strong>  ：不可变数据可能带来内存和性能开销</li>\n<li><strong>JavaScript限制</strong>  ：缺乏原生不可变数据结构</li>\n<li><strong>调试难度</strong>  ：长调用链可能难以调试</li>\n</ol>\n<h2>七、实际应用示例</h2>\n<h3>1. 数据处理管道</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 传统方式</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">processOrders</span>(<span class="hljs-params">orders</span>) {\n  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> order <span class="hljs-keyword">of</span> orders) {\n    <span class="hljs-keyword">if</span> (order.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;completed&#x27;</span>) {\n      total += order.<span class="hljs-property">amount</span> * <span class="hljs-number">1.1</span>; <span class="hljs-comment">// 加10%税</span>\n    }\n  }\n  <span class="hljs-keyword">return</span> total;\n}\n\n<span class="hljs-comment">// 函数式方式</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">processOrders</span> = orders =&gt; orders\n  .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">order</span> =&gt;</span> order.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;completed&#x27;</span>)\n  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">order</span> =&gt;</span> order.<span class="hljs-property">amount</span> * <span class="hljs-number">1.1</span>)\n  .<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, amount</span>) =&gt;</span> sum + amount, <span class="hljs-number">0</span>);\n</code></pre>\n<h3>2. React 组件</h3>\n<pre><code class="language-jsx"><span class="hljs-comment">// 函数式React组件</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">UserList</span> = (<span class="hljs-params">{ users, onSelect }</span>) =&gt; (\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n    {users\n      .filter(user =&gt; user.isActive)\n      .map(user =&gt; (\n        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{user.id}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> onSelect(user.id)}&gt;\n          {user.name}\n        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n      ))}\n  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>\n);\n</code></pre>\n<h2>总结</h2>\n<p>函数式编程在JavaScript中提供了强大的抽象能力，能够使代码更加简洁、可维护和可测试。虽然完全采用函数式编程可能不总是最佳选择，但合理运用其原则和技术可以显著提高代码质量。现代JavaScript生态系统(如React、Redux等)已经广泛采用了函数式编程的概念，掌握这些技术对于现代前端开发至关重要。</p>\n</div>'</script></body></html>