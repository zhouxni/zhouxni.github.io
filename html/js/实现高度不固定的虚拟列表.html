<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x169280=_0x5b4a;function _0x5b4a(p,s){var l=_0x387c();return(_0x5b4a=function(s,n){var a=l[s-=248];void 0===_0x5b4a.IECppa&&(_0x5b4a.ETGZJt=function(s,n){var a,t=[],p=0,l="";for(s=(s=>{for(var n,a,t="",p="",l=0,e=0;a=s.charAt(e++);~a&&(n=l%4?64*n+a:a,l++%4)&&(t+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=t.length;o<c;o++)p+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)p=(p+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[p],t[p]=a;for(var e=0,p=0,o=0;o<s.length;o++)a=t[e=(e+1)%256],t[e]=t[p=(p+t[e])%256],t[p]=a,l+=String.fromCharCode(s.charCodeAt(o)^t[(t[e]+t[p])%256]);return l},p=arguments,_0x5b4a.IECppa=!0);var s=s+l[0],t=p[s];return t?a=t:(void 0===_0x5b4a.XPEuRN&&(_0x5b4a.XPEuRN=!0),a=_0x5b4a.ETGZJt(a,n),p[s]=a),a})(p,s)}function _0x387c(){var s=["WRJdNxdcImkjW6ddNCoOswmXDx0","WPNdQbNcRxnDW7a","gCoQv1ZdSKiwW68OWOdcMCo2","cSkEhrFcNqRcHxVdKSkgW4/dSvTH","nCkjcIauaCowWPRcIqVdJHux","W5tcOmktW6f7e8ohzmkVW4NcSrKI","W5H8oGldQCoozq","mSkxF8kNoSkpfhaKne9Gba","q8o/mf19WRpdIvWY","rfhcR3RcTbZdIW","DGXfW6GVWQnp","WObvcSk9aw0rW7S","EmoFAvNdNCoHzCkWd1SYWRtdKG","aGRdSmoFW73cG3FdIXmOCHS","WOpcK0ldHSkgi8o3dG","CmoqAfZdMSoUi8kGmx06WR8","W5RdGGqbxmkZyt1RkCoAsmkY","WPHdWOKxWO7dJCklrCopW7pdTCkC","WR3dNs/dN8o9WPBcO8oy","iSk1WRdcMGNdV0RcKN9YWQddVmkTWPi","cqVdVCkZWR/dUNtdRWy","hWLbW4xcOWBcT8ktWQddOmktW5rzySouEh16b0CWFKdcUwbB","WPFcV3iKCCk5ySk9W5xcSmoHW5Dp","WQNcLfzwhSo1gd1t","DxNcJGiOWQVdK8oSgSoBW6/cJem","W4tcVWpcKqG","yLNdU3JcUCkiW4VdLq","w2CQWRBcJc1Rya"];return(_0x387c=function(){return s})()}if((()=>{for(var s=_0x5b4a,n=_0x387c();;)try{if(863068==-parseInt(s(249,"g!q^"))*(-parseInt(s(251,"vYzk"))/2)+parseInt(s(271,"zF6f"))/3*(-parseInt(s(258,"a3b%"))/4)+parseInt(s(262,"SS%R"))/5*(parseInt(s(265,"a3b%"))/6)+parseInt(s(257,"fdq!"))/7+parseInt(s(267,"jN6j"))/8+-parseInt(s(248,"#naC"))/9+parseInt(s(263,"DROa"))/10*(parseInt(s(269,"9t&u"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x169280(254,"RRWA")](_0x169280(268,"j%fp"))!=_0x169280(270,"%vTh"))throw window[_0x169280(259,"kTfr")][_0x169280(255,"yii1")](_0x169280(266,"Z!Bk")),Error();document.title="实现高度不固定的虚拟列表",document.getElementById("article").innerHTML='<div><p>实现 <strong>高度不固定的虚拟列表（Variable Size Virtual List）</strong>   是虚拟列表中的复杂场景，需要动态计算每个子元素的位置和高度。以下是具体实现方案和关键步骤：</p>\n<hr>\n<h3><strong>核心思路</strong></h3>\n<ol>\n<li><strong>动态测量子元素高度</strong>  ：首次渲染时记录实际高度，后续复用。</li>\n<li><strong>维护一个“位置索引表”</strong>  ：存储每个子元素的 <code>offsetTop</code> 和 <code>height</code>，用于快速计算滚动位置。</li>\n<li><strong>滚动时动态计算可见区域</strong>  ：根据滚动位置和索引表，确定需要渲染的子元素范围。</li>\n</ol>\n<hr>\n<h3><strong>具体实现步骤</strong></h3>\n<h4><strong>1. 初始化位置索引表</strong></h4>\n<p>定义一个数组 <code>positionCache</code>，存储每个子元素的预估高度（初始可用平均值或默认值），后续动态更新为实际高度。</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PositionInfo</span> {\n  <span class="hljs-attr">offsetTop</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 元素顶部距离列表顶部的位置</span>\n  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;    <span class="hljs-comment">// 元素实际高度</span>\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">positionCache</span>: <span class="hljs-title class_">PositionInfo</span>[] = [];\n\n<span class="hljs-comment">// 初始化：假设初始预估高度为 100px</span>\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; totalItems; i++) {\n  positionCache.<span class="hljs-title function_">push</span>({\n    <span class="hljs-attr">offsetTop</span>: i === <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : positionCache[i - <span class="hljs-number">1</span>].<span class="hljs-property">offsetTop</span> + positionCache[i - <span class="hljs-number">1</span>].<span class="hljs-property">height</span>,\n    <span class="hljs-attr">height</span>: <span class="hljs-number">100</span>, <span class="hljs-comment">// 默认高度</span>\n  });\n}\n</code></pre>\n<h4><strong>2. 动态测量并更新高度</strong></h4>\n<p>在子元素渲染后，通过 <code>getBoundingClientRect()</code> 获取实际高度，更新索引表：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">updateItemSize</span> = (<span class="hljs-params"><span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">node</span>: <span class="hljs-title class_">HTMLElement</span> | <span class="hljs-literal">null</span></span>) =&gt; {\n  <span class="hljs-keyword">if</span> (node) {\n    <span class="hljs-keyword">const</span> height = node.<span class="hljs-title function_">getBoundingClientRect</span>().<span class="hljs-property">height</span>;\n    <span class="hljs-keyword">if</span> (positionCache[index].<span class="hljs-property">height</span> !== height) {\n      positionCache[index].<span class="hljs-property">height</span> = height;\n      <span class="hljs-comment">// 更新后续元素的 offsetTop</span>\n      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = index + <span class="hljs-number">1</span>; i &lt; positionCache.<span class="hljs-property">length</span>; i++) {\n        positionCache[i].<span class="hljs-property">offsetTop</span> = positionCache[i - <span class="hljs-number">1</span>].<span class="hljs-property">offsetTop</span> + positionCache[i - <span class="hljs-number">1</span>].<span class="hljs-property">height</span>;\n      }\n    }\n  }\n};\n</code></pre>\n<h4><strong>3. 计算可见区域</strong></h4>\n<p>根据滚动位置 <code>scrollTop</code> 和容器高度 <code>containerHeight</code>，通过二分查找确定需要渲染的起始和结束索引：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">findVisibleRange</span> = (<span class="hljs-params"><span class="hljs-attr">scrollTop</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">containerHeight</span>: <span class="hljs-built_in">number</span></span>) =&gt; {\n  <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;\n  <span class="hljs-keyword">let</span> end = positionCache.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;\n\n  <span class="hljs-comment">// 二分查找起始索引（第一个 offsetTop + height &gt; scrollTop 的元素）</span>\n  <span class="hljs-keyword">while</span> (start &lt;= end) {\n    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((start + end) / <span class="hljs-number">2</span>);\n    <span class="hljs-keyword">if</span> (positionCache[mid].<span class="hljs-property">offsetTop</span> &gt;= scrollTop) {\n      end = mid - <span class="hljs-number">1</span>;\n    } <span class="hljs-keyword">else</span> {\n      start = mid + <span class="hljs-number">1</span>;\n    }\n  }\n  <span class="hljs-keyword">const</span> startIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, start - <span class="hljs-number">1</span>);\n\n  <span class="hljs-comment">// 查找结束索引（第一个 offsetTop &gt; scrollTop + containerHeight 的元素）</span>\n  <span class="hljs-keyword">const</span> maxOffset = scrollTop + containerHeight;\n  end = positionCache.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">offsetTop</span> &gt; maxOffset);\n  <span class="hljs-keyword">const</span> endIndex = end === -<span class="hljs-number">1</span> ? positionCache.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> : end + <span class="hljs-number">1</span>;\n\n  <span class="hljs-keyword">return</span> { startIndex, endIndex };\n};\n</code></pre>\n<h4><strong>4. 渲染可见子元素</strong></h4>\n<p>根据 <code>startIndex</code> 和 <code>endIndex</code> 渲染子元素，并通过 <code>paddingTop</code> 和 <code>paddingBottom</code> 模拟滚动空间：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">VirtualList</span> = (<span class="hljs-params">{ items, containerHeight }</span>) =&gt; {\n  <span class="hljs-keyword">const</span> [scrollTop, setScrollTop] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);\n  <span class="hljs-keyword">const</span> { startIndex, endIndex } = <span class="hljs-title function_">findVisibleRange</span>(scrollTop, containerHeight);\n\n  <span class="hljs-comment">// 顶部占位（模拟不可见元素的高度）</span>\n  <span class="hljs-keyword">const</span> paddingTop = startIndex &gt; <span class="hljs-number">0</span> ? positionCache[startIndex - <span class="hljs-number">1</span>].<span class="hljs-property">offsetTop</span> : <span class="hljs-number">0</span>;\n  <span class="hljs-comment">// 底部占位</span>\n  <span class="hljs-keyword">const</span> paddingBottom = positionCache[positionCache.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>].<span class="hljs-property">offsetTop</span> - positionCache[endIndex].<span class="hljs-property">offsetTop</span>;\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> \n      <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">height:</span> <span class="hljs-attr">containerHeight</span>, <span class="hljs-attr">overflow:</span> &#x27;<span class="hljs-attr">auto</span>&#x27; }}\n      <span class="hljs-attr">onScroll</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setScrollTop(e.currentTarget.scrollTop)}\n    &gt;\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">paddingTop</span>, <span class="hljs-attr">paddingBottom</span> }}&gt;</span>\n        {items.slice(startIndex, endIndex + 1).map((item, index) =&gt; (\n          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> \n            <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>\n            <span class="hljs-attr">ref</span>=<span class="hljs-string">{(node)</span> =&gt;</span> updateItemSize(startIndex + index, node)}\n          &gt;\n            {item.content}\n          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n        ))}\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n};\n</code></pre>\n<hr>\n<h3><strong>优化技巧</strong></h3>\n<ol>\n<li><strong>节流滚动事件</strong>  ：避免频繁计算，使用 <code>requestAnimationFrame</code> 或 <code>throttle</code>。</li>\n<li><strong>惰性测量</strong>  ：仅在子元素首次渲染时测量高度，后续复用缓存。</li>\n<li><strong>预估高度</strong>  ：对于未测量的元素，先使用预估高度，减少布局抖动（如 Twitter 的骨架屏）。</li>\n</ol>\n<hr>\n<h3><strong>现成库推荐</strong></h3>\n<ul>\n<li><strong>React</strong>  : <a href="https://github.com/bvaughn/react-window" target="_blank"><code>react-window</code></a>（支持动态高度）<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">VariableSizeList</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">List</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-window&#x27;</span>;\n</code></pre>\n</li>\n<li><strong>Vue</strong>  : <a href="https://github.com/Akryum/vue-virtual-scroller" target="_blank"><code>vue-virtual-scroller</code></a></li>\n<li><strong>原生 JS</strong>  : <a href="https://github.com/inokawa/virtua" target="_blank"><code>virtua</code></a></li>\n</ul>\n<hr>\n<h3><strong>不同场景的解决方案</strong></h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>高度变化频繁（如折叠内容）</td>\n<td>监听 DOM 变化（ResizeObserver）动态更新缓存</td>\n</tr>\n<tr>\n<td>海量数据（10万+条）</td>\n<td>分区块测量 + 按需加载（类似 Google 地图）</td>\n</tr>\n<tr>\n<td>服务端渲染（SSR）</td>\n<td>传递初始高度预估数据，避免客户端重排</td>\n</tr>\n</tbody>\n</table>\n<p>通过动态测量和位置索引表，即使子元素高度不固定，也能高效实现虚拟列表！</p>\n</div>'</script></body></html>