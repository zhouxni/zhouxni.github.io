<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x58e4(){var n=["kSoyWR41W5/dL8k3WQW","sSo9W5FcTqDJBmowqWS0WQC","y0VcRJjvrmocdsy","yComjSkwrhLMW5FcLr3dNJFdUa","WOr9W7NcGJBdOua","WRfHySowxee7","rSocWPi1jCoieSoKWOK","W7lcLSk8W6C7pSkGW6a4nc7cOSkc","W5DKgCkFWRRcTSoUa2ldKhO","WRddJGxdM8okiCk5y2yBuSkD","W4arW5aMvW1ul8ok","EtxcS8oAWOntWOvwW75pu8opWPO","t8k5WPZcQMZcL8k8esLTW6i","eCo1W5ddOY3dQ8oJrGrXW4/cPIVdISkdj1ldJxdcP8oZySkaW5xcUSkC","WQ1dWQRcGLRdKdDRW4FdVhBcNW","W4CPWRNdNMtcSXv5eNhdOWSP","AcGtnGuXWRSKe0C+i30","W4CSWRJdNwxcSwfhfLtdMHa","yCokl8ktqN0BW6NcPrZdRGO","dmoSWPCvWOVcKbFcGCkosZBdJq","C1ZcTNy5vrhcO8krB8kxW7JdKG","xhu7W6BdJq"];return(_0x58e4=function(){return n})()}var _0x52f0ec=_0x4fa4;function _0x4fa4(o,n){var c=_0x58e4();return(_0x4fa4=function(n,s){var e=c[n-=241];void 0===_0x4fa4.jHBHYL&&(_0x4fa4.yWcagS=function(n,s){var e,a=[],o=0,c="";for(n=(n=>{for(var s,e,a="",o="",c=0,t=0;e=n.charAt(t++);~e&&(s=c%4?64*s+e:e,c++%4)&&(a+=String.fromCharCode(255&s>>(-2*c&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var l=0,p=a.length;l<p;l++)o+="%"+("00"+a.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(o)})(n),t=0;t<256;t++)a[t]=t;for(t=0;t<256;t++)o=(o+a[t]+s.charCodeAt(t%s.length))%256,e=a[t],a[t]=a[o],a[o]=e;for(var t=0,o=0,l=0;l<n.length;l++)e=a[t=(t+1)%256],a[t]=a[o=(o+a[t])%256],a[o]=e,c+=String.fromCharCode(n.charCodeAt(l)^a[(a[t]+a[o])%256]);return c},o=arguments,_0x4fa4.jHBHYL=!0);var n=n+c[0],a=o[n];return a?e=a:(void 0===_0x4fa4.zOemiW&&(_0x4fa4.zOemiW=!0),e=_0x4fa4.yWcagS(e,s),o[n]=e),e})(o,n)}if((()=>{for(var n=_0x4fa4,s=_0x58e4();;)try{if(649044==+parseInt(n(255,"#QjA"))+-parseInt(n(242,"wzgy"))/2+-parseInt(n(245,"%@HT"))/3+parseInt(n(249,"rTIx"))/4+-parseInt(n(259,"lcrK"))/5+-parseInt(n(261,"z$H&"))/6+parseInt(n(247,"%@HT"))/7*(parseInt(n(254,"9lY!"))/8))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x52f0ec(257,")3*q")](_0x52f0ec(262,"4Opz"))!=_0x52f0ec(251,"@MxN"))throw window[_0x52f0ec(252,"Ueut")][_0x52f0ec(256,"%@HT")](_0x52f0ec(243,"wzgy")),Error();document.title="Vue3 getCurrentInstance",document.getElementById("article").innerHTML='<div><p><code>getCurrentInstance()</code> 是 Vue 3 提供的一个高级 API，用于在组合式 API 中获取当前组件的内部实例。它主要用于开发库或实现一些特殊功能，在日常业务开发中应谨慎使用。</p>\n<h3>一、核心作用与返回值</h3>\n<p><code>getCurrentInstance()</code> 返回当前组件的内部实例对象（<code>ComponentInternalInstance</code>），包含了组件的所有内部状态和方法。这个对象是 Vue 内部维护的组件实例，不同于用户层面的组件实例。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { getCurrentInstance, onMounted } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> instance = <span class="hljs-title function_">getCurrentInstance</span>();\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance); <span class="hljs-comment">// 输出组件内部实例对象</span>\n\n    <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-comment">// 在生命周期钩子中也能获取</span>\n      <span class="hljs-keyword">const</span> instanceInHook = <span class="hljs-title function_">getCurrentInstance</span>();\n    });\n  },\n};\n</code></pre>\n<h3>二、主要属性详解</h3>\n<p>返回的实例对象包含多个重要属性：</p>\n<ol>\n<li>\n<p><strong><code>proxy</code></strong><br>\n组件的代理对象，等同于用户层面的 <code>this</code>，可以访问组件的：</p>\n<ul>\n<li>props（<code>proxy.xxx</code>）</li>\n<li>响应式数据（<code>proxy.count</code>）</li>\n<li>方法（<code>proxy.handleClick()</code>）</li>\n<li>计算属性等</li>\n</ul>\n</li>\n<li>\n<p><strong><code>props</code></strong><br>\n组件接收的 props 数据（原始值，非响应式），需要通过 <code>toRefs</code> 转为响应式：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { toRefs } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n<span class="hljs-keyword">const</span> { props } = <span class="hljs-title function_">getCurrentInstance</span>();\n<span class="hljs-keyword">const</span> { title } = <span class="hljs-title function_">toRefs</span>(props); <span class="hljs-comment">// 转为响应式</span>\n</code></pre>\n</li>\n<li>\n<p><strong><code>emit</code></strong><br>\n用于触发自定义事件的函数，等同于 <code>setup</code> 的第二个参数：</p>\n<pre><code class="language-javascript">instance.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;change&quot;</span>, value); <span class="hljs-comment">// 触发父组件事件</span>\n</code></pre>\n</li>\n<li>\n<p><strong><code>attrs</code></strong><br>\n父组件传递的非 props 属性（如 <code>class</code>、<code>style</code> 或自定义属性）：</p>\n<pre><code class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">attrs</span>); <span class="hljs-comment">// { id: &#x27;my-component&#x27;, class: &#x27;container&#x27; }</span>\n</code></pre>\n</li>\n<li>\n<p><strong><code>slots</code></strong><br>\n组件的插槽内容，可通过 <code>slots.default()</code> 访问默认插槽：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> defaultSlot = instance.<span class="hljs-property">slots</span>.<span class="hljs-title function_">default</span>(); <span class="hljs-comment">// 获取默认插槽内容</span>\n</code></pre>\n</li>\n<li>\n<p><strong><code>parent</code> 与 <code>vnode</code></strong></p>\n<ul>\n<li><code>parent</code>：父组件的内部实例</li>\n<li><code>vnode</code>：当前组件的虚拟节点对象</li>\n</ul>\n</li>\n<li>\n<p><strong><code>appContext</code></strong><br>\n应用上下文，可访问全局配置：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 获取全局注册的属性</span>\n<span class="hljs-keyword">const</span> <span class="hljs-variable language_">global</span> = instance.<span class="hljs-property">appContext</span>.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">global</span>.<span class="hljs-property">$router</span>); <span class="hljs-comment">// 访问全局路由</span>\n</code></pre>\n</li>\n</ol>\n<h3>三、使用场景</h3>\n<ol>\n<li>\n<p><strong>访问全局属性</strong><br>\n当需要在 <code>setup</code> 中访问全局注册的属性（如 <code>$router</code>、<code>$store</code>）时：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { appContext } = <span class="hljs-title function_">getCurrentInstance</span>();\n<span class="hljs-keyword">const</span> $router = appContext.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$router</span>;\n</code></pre>\n</li>\n<li>\n<p><strong>开发组件库</strong><br>\n在组件库开发中，可用于实现一些高级功能（如依赖注入、组件通信）。</p>\n</li>\n<li>\n<p><strong>调试与日志</strong><br>\n开发环境中可用于打印组件信息进行调试：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&quot;development&quot;</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;当前组件实例:&quot;</span>, <span class="hljs-title function_">getCurrentInstance</span>());\n}\n</code></pre>\n</li>\n</ol>\n<h3>四、注意事项</h3>\n<ol>\n<li>\n<p><strong>调用时机</strong><br>\n只能在 <code>setup()</code> 或组件的生命周期钩子（如 <code>onMounted</code>）中调用，在普通函数或异步回调中调用会返回 <code>null</code>。</p>\n</li>\n<li>\n<p><strong>生产环境限制</strong><br>\n生产环境下，<code>proxy</code> 属性可能会被禁用，且实例对象的部分属性会被压缩，建议通过 <code>instance.ctx</code> 访问（但不推荐在业务代码中使用）。</p>\n</li>\n<li>\n<p><strong>避免过度依赖</strong><br>\n优先使用 <code>setup</code> 的参数（<code>props</code>、<code>emit</code>）和 <code>provide/inject</code> 等标准 API，<code>getCurrentInstance()</code> 主要用于特殊场景。</p>\n</li>\n<li>\n<p><strong>TypeScript 支持</strong><br>\n可通过泛型指定类型，获得更好的类型提示：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">import</span> { getCurrentInstance, <span class="hljs-title class_">ComponentInternalInstance</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n<span class="hljs-keyword">const</span> instance = getCurrentInstance&lt;<span class="hljs-title class_">ComponentInternalInstance</span>&gt;();\n</code></pre>\n</li>\n</ol>\n<h3>五、替代方案</h3>\n<ul>\n<li>访问 props：直接使用 <code>setup</code> 的第一个参数</li>\n<li>触发事件：使用 <code>setup</code> 的第二个参数 <code>emit</code></li>\n<li>全局属性：通过 <code>provide/inject</code> 在入口文件提供后使用</li>\n<li>父子通信：优先使用 props/emit 或 <code>provide/inject</code></li>\n</ul>\n<p><code>getCurrentInstance()</code> 是 Vue 3 内部机制的“窗口”，合理使用可以解决一些特殊问题，但过度使用会增加代码耦合度和维护成本。</p>\n</div>'</script></body></html>