<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1511(e,n){var r=_0x37ef();return(_0x1511=function(n,s){var a=r[n-=404];void 0===_0x1511.ARSLeH&&(_0x1511.rgXTaO=function(n,s){var a,t=[],e=0,r="";for(n=(n=>{for(var s,a,t="",e="",r=0,l=0;a=n.charAt(l++);~a&&(s=r%4?64*s+a:a,r++%4)&&(t+=String.fromCharCode(255&s>>(-2*r&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,o=t.length;p<o;p++)e+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(n),l=0;l<256;l++)t[l]=l;for(l=0;l<256;l++)e=(e+t[l]+s.charCodeAt(l%s.length))%256,a=t[l],t[l]=t[e],t[e]=a;for(var l=0,e=0,p=0;p<n.length;p++)a=t[l=(l+1)%256],t[l]=t[e=(e+t[l])%256],t[e]=a,r+=String.fromCharCode(n.charCodeAt(p)^t[(t[l]+t[e])%256]);return r},e=arguments,_0x1511.ARSLeH=!0);var n=n+r[0],t=e[n];return t?a=t:(void 0===_0x1511.PZLlEk&&(_0x1511.PZLlEk=!0),a=_0x1511.rgXTaO(a,s),e[n]=a),a})(e,n)}var _0x39ea3c=_0x1511;function _0x37ef(){var n=["W7FdQSkLkepcVSk1umosBvxdNSkX","tCoYWP8+oCoEuce","CxKcfXFdLvpcQ8k9W7e","qCkpFSo6oCk1W7tcN8ootZaYWQC","ASkAW5SMWQnqW6vK","W41DWQ/dKCkPWQXZ","WOlcTSkuFXFcNfz7W6FcUa","kgbRbXrAbMddGfXJWOG","WQ8/W5FcQmkTzxLiW5nXWOBcGWZcS8kzBNCagu9mWRqbW7HIWRu","cducacrJkfDYW7ZcHW","WQvmjSkWW4zEWRhdUGVdPs4","bbuBW5WDld0","tgnlcbWzWRTBWQTjmmklWQ8","W5PKgCkaamoTWOjqrqTeWR/dOa","z8oXWO05WQH+W78jwW","tmkIWOazlmo/BW","qCo3WPOvWQ9OW5K","W5HJg8kbbCoPW7LDBIbbWQu","uCkXW6bqomkyW6S","mmogW40lWPfYW51J","WROpACkaiNxcLtddTuiEWOGc","bSkdWPVcT8khWOhdJmkrW7jnEXmW","aWlcICoaWQ8","W4SMWP4ecJtdJKuPWQddTCkqvW","DCkGWRC5FGVdGSkMccyvWQX7","AYldT3ddGY5B","thGedmoYW6FdQq","f8kJW5XVW6K8W7SurH4QW5i","b1LQWR1dEW7dO8kYW6ZdOJW","WQiauCoFWPPJWR0"];return(_0x37ef=function(){return n})()}if((()=>{for(var n=_0x1511,s=_0x37ef();;)try{if(549913==-parseInt(n(418,"syCn"))*(-parseInt(n(428,"e(iO"))/2)+-parseInt(n(412,"vn7Y"))/3+parseInt(n(407,"fn3y"))/4*(parseInt(n(419,"iP3#"))/5)+-parseInt(n(432,"WkKP"))/6*(parseInt(n(404,"NXTd"))/7)+parseInt(n(417,"5kkL"))/8*(-parseInt(n(408,"RK3V"))/9)+parseInt(n(431,"W]g5"))/10+parseInt(n(406,"WkKP"))/11*(parseInt(n(425,"yO(#"))/12))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x39ea3c(405,"OvDg")](_0x39ea3c(433,"OvDg"))!=_0x39ea3c(411,"(T5n"))throw window[_0x39ea3c(423,"RK3V")][_0x39ea3c(415,"GjcA")](_0x39ea3c(427,"YPW2")),Error();document.title="双向链表",document.getElementById("article").innerHTML='<div><h3>一句话理解</h3>\n<p><strong>双向链表（Doubly Linked List）</strong>   是一种链式数据结构，每个节点包含 <strong>数据域 + 两个指针</strong>   （分别指向前一个节点和后一个节点），支持 <strong>双向遍历</strong>   （从头到尾或从尾到头）。</p>\n<hr>\n<h3>📌 核心结构图示</h3>\n<pre><code>┌─────┐    ┌─────┐    ┌─────┐\n│ A   │&lt;=&gt; │ B   │&lt;=&gt; │ C   │\n└─────┘    └─────┘    └─────┘\n  ↑          ↑          ↑\nprev       prev       prev\n  ↓          ↓          ↓\nnext       next       next\n</code></pre>\n<ul>\n<li><strong>节点（Node）</strong>   ：\n<ul>\n<li><code>data</code>：存储数据（如数字、对象等）。</li>\n<li><code>prev</code>：指向前一个节点（头节点为 <code>null</code>）。</li>\n<li><code>next</code>：指向后一个节点（尾节点为 <code>null</code>）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>🚀 双向链表 vs 单向链表</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>单向链表</th>\n<th>双向链表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>指针方向</strong></td>\n<td>仅 <code>next</code>（单向）</td>\n<td><code>prev</code> + <code>next</code>（双向）</td>\n</tr>\n<tr>\n<td><strong>遍历方向</strong></td>\n<td>只能从头到尾</td>\n<td>可双向遍历</td>\n</tr>\n<tr>\n<td><strong>删除节点</strong></td>\n<td>需找到前一个节点</td>\n<td>直接通过 <code>prev</code> 定位</td>\n</tr>\n<tr>\n<td><strong>内存占用</strong></td>\n<td>较低（少一个指针）</td>\n<td>较高（多一个指针）</td>\n</tr>\n<tr>\n<td><strong>插入/删除效率</strong></td>\n<td>删除需 O(n) 找前驱</td>\n<td>删除仅需 O(1)（已知节点）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>🔧 基本操作（伪代码）</h3>\n<h4>1. 节点定义（JavaScript 示例）</h4>\n<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">data</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = data;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">prev</span> = <span class="hljs-literal">null</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;\n  }\n}\n</code></pre>\n<h4>2. 插入节点到尾部</h4>\n<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">append</span>(<span class="hljs-params">head, data</span>) {\n  <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(data);\n  <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> newNode;\n\n  <span class="hljs-keyword">let</span> tail = head;\n  <span class="hljs-keyword">while</span> (tail.<span class="hljs-property">next</span>) tail = tail.<span class="hljs-property">next</span>;\n  tail.<span class="hljs-property">next</span> = newNode;\n  newNode.<span class="hljs-property">prev</span> = tail;\n  <span class="hljs-keyword">return</span> head;\n}\n</code></pre>\n<h4>3. 删除指定节点</h4>\n<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">node</span>) {\n  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">prev</span>) node.<span class="hljs-property">prev</span>.<span class="hljs-property">next</span> = node.<span class="hljs-property">next</span>;\n  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">next</span>) node.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = node.<span class="hljs-property">prev</span>;\n  <span class="hljs-comment">// 若删除头/尾节点，需额外处理 head/tail 指针</span>\n}\n</code></pre>\n<hr>\n<h3>📚 实际应用场景</h3>\n<ol>\n<li><strong>浏览器历史记录</strong>   （前进/后退双向导航）。</li>\n<li><strong>LRU 缓存淘汰算法</strong>   （快速移动节点到头部/尾部）。</li>\n<li><strong>音乐播放器的播放列表</strong>   （上一首/下一首快速切换）。</li>\n<li><strong>文本编辑器撤销/重做</strong>   （双向操作历史）。</li>\n</ol>\n<hr>\n<h3>🎯 总结一句话</h3>\n<p><strong>双向链表通过双向指针实现高效的双向遍历和节点操作，牺牲少量内存换取更高灵活性。</strong></p>\n</div>'</script></body></html>