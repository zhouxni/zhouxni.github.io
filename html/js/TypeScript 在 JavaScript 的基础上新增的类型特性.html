<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3992(p,s){var e=_0x4c5b();return(_0x3992=function(s,n){var a=e[s-=309];void 0===_0x3992.Vqlvuo&&(_0x3992.eVekfB=function(s,n){var a,l=[],p=0,e="";for(s=(s=>{for(var n,a,l="",p="",e=0,t=0;a=s.charAt(t++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=l.length;c<r;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)p=(p+l[t]+n.charCodeAt(t%n.length))%256,a=l[t],l[t]=l[p],l[p]=a;for(var t=0,p=0,c=0;c<s.length;c++)a=l[t=(t+1)%256],l[t]=l[p=(p+l[t])%256],l[p]=a,e+=String.fromCharCode(s.charCodeAt(c)^l[(l[t]+l[p])%256]);return e},p=arguments,_0x3992.Vqlvuo=!0);var s=s+e[0],l=p[s];return l?a=l:(void 0===_0x3992.MyrxBx&&(_0x3992.MyrxBx=!0),a=_0x3992.eVekfB(a,n),p[s]=a),a})(p,s)}var _0x5d6620=_0x3992;function _0x4c5b(){var s=["W51Ya8o3nSo4oSogWPOE","CgCCW5NdGSo6W7j9AG","sSk3wmoMsmo4WQ7dU8oX","DwqMa8kmoW7cVrxdVfuf","WOZcRW43WQRdQYTwmG8","BCkbDHS+vmoZWQVcUc3dHKFcVG","W6xdHNHJW4O","amkfWPJcImkWz2xdVX5SBCotWRe","WPxcUSoCgbf4jW","C2mOaCoSrXFcNsVdRW","W70RfspdRcuzWO91gWC","W7RdTgddHWJcLSo5WRuHtqaKW60","aSojW7ZdLSknWRFdR8ooWRBdJXSqkG","WQtdUHVcHfRcTSoCCSkgW6Og","W7RdI8ong2O/WO0","qHC1BSoebCk8","uKFcS8oHqSkktX9cW4RdVLpdKcVcSgf5W71UWO1rWO9Ji8k6gG","q1zGo8kcm8kVaa1Sba","WOPDo2SUj8o7W78mWOSfDq","x0FcG8oicmojwgaxWOG","W7aXW6/cNCkPeSoaWQpcTmobkmo1WOK","wCoCW4ldN8oWpZVdMa","CSkXn2zIraSRqwNcNG","bgjDW4NdImoxW4WMW7a","kmo/huBcQG1G","WONcRJhcLuNdKCkcWR0x","qghdLhimWOJcNwz7C8o+l8ou"];return(_0x4c5b=function(){return s})()}if((()=>{for(var s=_0x3992,n=_0x4c5b();;)try{if(412444==+parseInt(s(312,"T[zJ"))+parseInt(s(328,"reKf"))/2*(parseInt(s(311,"U1eT"))/3)+-parseInt(s(335,"TUL*"))/4+parseInt(s(331,"Eluw"))/5*(parseInt(s(310,"BT2q"))/6)+-parseInt(s(321,"taz*"))/7+-parseInt(s(314,"[gk2"))/8*(parseInt(s(323,"2VMO"))/9)+-parseInt(s(319,"dB(!"))/10*(-parseInt(s(318,"T[zJ"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5d6620(333,"]yo2")](_0x5d6620(334,"zLI5"))!=_0x5d6620(315,"bsuA"))throw window[_0x5d6620(330,"j9LX")][_0x5d6620(317,"KL*t")](_0x5d6620(325,"Bpqr")),Error();document.title="TypeScript 在 JavaScript 的基础上新增的类型特性",document.getElementById("article").innerHTML='<div><p>TypeScript 在 JavaScript 的基础上扩展了更丰富的类型系统，新增的类型特性主要体现在以下几个方面：</p>\n<h3>一、基础类型增强</h3>\n<ol>\n<li>\n<p><strong><code>void</code></strong><br>\n表示函数没有返回值（或返回 <code>undefined</code>）：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello&quot;</span>);\n}\n</code></pre>\n</li>\n<li>\n<p><strong><code>never</code></strong><br>\n表示“永不存在的值”，如抛出错误的函数或死循环函数的返回值：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throwError</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> {\n  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Error&quot;</span>);\n}\n</code></pre>\n</li>\n<li>\n<p><strong><code>unknown</code></strong><br>\n安全的“任意类型”，比 <code>any</code> 更严格，使用前必须先断言或类型检查：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-string">&quot;hello&quot;</span>;\n<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;string&quot;</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toUpperCase</span>()); <span class="hljs-comment">// 合法</span>\n}\n</code></pre>\n</li>\n</ol>\n<h3>二、复合类型与类型操作</h3>\n<ol>\n<li>\n<p><strong>联合类型（Union Types）</strong><br>\n表示值可以是多种类型中的一种：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">NumberOrString</span> = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;\n<span class="hljs-keyword">let</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">NumberOrString</span> = <span class="hljs-number">123</span>; <span class="hljs-comment">// 或 &quot;123&quot;</span>\n</code></pre>\n</li>\n<li>\n<p><strong>交叉类型（Intersection Types）</strong><br>\n合并多个类型为一个，需同时满足所有类型：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> A = { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span> };\n<span class="hljs-keyword">type</span> B = { <span class="hljs-attr">y</span>: <span class="hljs-built_in">string</span> };\n<span class="hljs-keyword">type</span> C = A &amp; B; <span class="hljs-comment">// { x: number; y: string }</span>\n</code></pre>\n</li>\n<li>\n<p><strong>元组（Tuple）</strong><br>\n固定长度和类型的数组，各元素类型可不同：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];\n<span class="hljs-keyword">const</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Point</span> = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>]; <span class="hljs-comment">// 长度固定为 2，类型依次为 number、number</span>\n</code></pre>\n</li>\n<li>\n<p><strong>枚举（Enum）</strong><br>\n定义命名常量集合，提升代码可读性：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> {\n  <span class="hljs-title class_">Up</span> = <span class="hljs-string">&quot;UP&quot;</span>,\n  <span class="hljs-title class_">Down</span> = <span class="hljs-string">&quot;DOWN&quot;</span>,\n}\n<span class="hljs-keyword">const</span> move = <span class="hljs-title class_">Direction</span>.<span class="hljs-property">Up</span>;\n</code></pre>\n</li>\n</ol>\n<h3>三、类型工具与高级特性</h3>\n<ol>\n<li>\n<p><strong>泛型（Generics）</strong><br>\n定义“类型参数”，实现类型复用和动态类型约束：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T {\n  <span class="hljs-keyword">return</span> arg; <span class="hljs-comment">// 输入和输出类型保持一致</span>\n}\n</code></pre>\n</li>\n<li>\n<p><strong>类型别名（Type Aliases）</strong><br>\n为类型创建别名，简化复杂类型：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n};\n</code></pre>\n</li>\n<li>\n<p><strong>接口（Interfaces）</strong><br>\n声明对象的结构契约，支持继承和合并：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n}\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-title function_">bark</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 继承 Animal 并扩展方法</span>\n}\n</code></pre>\n</li>\n<li>\n<p><strong>映射类型（Mapped Types）</strong><br>\n基于已有类型创建新类型（如只读、可选）：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Readonly</span>&lt;T&gt; = {\n  <span class="hljs-keyword">readonly</span> [K <span class="hljs-keyword">in</span> keyof T]: T[K]; <span class="hljs-comment">// 将 T 的所有属性转为只读</span>\n};\n</code></pre>\n</li>\n<li>\n<p><strong>条件类型（Conditional Types）</strong><br>\n基于条件判断动态生成类型：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IsString</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;\n<span class="hljs-keyword">type</span> A = <span class="hljs-title class_">IsString</span>&lt;<span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">// true</span>\n<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">IsString</span>&lt;<span class="hljs-built_in">number</span>&gt;; <span class="hljs-comment">// false</span>\n</code></pre>\n</li>\n</ol>\n<h3>四、其他实用类型</h3>\n<ul>\n<li>\n<p><strong><code>keyof</code></strong>   ：获取对象类型的所有键名组成的联合类型：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">UserKeys</span> = keyof { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> }; <span class="hljs-comment">// &quot;name&quot; | &quot;age&quot;</span>\n</code></pre>\n</li>\n<li>\n<p><strong><code>typeof</code></strong>   ：根据变量值推导类型：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> };\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">UserType</span> = <span class="hljs-keyword">typeof</span> user; <span class="hljs-comment">// { name: string }</span>\n</code></pre>\n</li>\n<li>\n<p><strong>类型断言</strong>   ：手动指定变量类型（告诉 TS 编译器“我知道类型是什么”）：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-string">&quot;hello&quot;</span>;\n<span class="hljs-keyword">const</span> str = value <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 断言为 string</span>\n</code></pre>\n</li>\n</ul>\n<p>这些新增类型特性让 TypeScript 具备了静态类型检查能力，能在编译阶段发现类型错误，同时通过类型系统提升代码的可维护性和可读性。</p>\n</div>'</script></body></html>