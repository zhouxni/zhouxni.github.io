<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2be0(){var s=["WO/dO8kgW5PaWOFcOCoQu8kIW74btq","WR/cKH9PW7aIfIm","WOxdQWBcMsDnWQ56W7yiW7JcVSoQ","W4pcRSk+xCoU","vG8iisZcI8oMrCo6WOvlW5pdTCoppNVcNSoxWOaKW4H4yvjXuW","W54kWO/cSfjUWPPP","WQudWQxcIqFcRaBdLbVdQ8k5svG","WRThW7zEW68Qba","oxryeeu0dbSAW74","W5GkW7tcMNjqWRPGxW","WQ5hW7j7W7OSda","W5CsWPv7xZXYvvS/","emoHdCkIWQ8tW4H5WQD9W7O","bwhdR8okihRcJIO9WQddVW","d0KYmWJdNSkFbG","WRFcTbGCxSoTo2HQyCo3qG","W6ddHe84WR16sYa2WPu9W4JdMa","WQquyKZcVmkcW5FdH2OCW4TDtG","WPxdJZhcO0rHWRpdMmoPeCo4W4lcIW","hW51imk7pCo5B8kgvSkJWPe","uCouWPNcLx7cVmoHwru","W598zSkho8k5ohVcSfTHW7r3","WP4yqutcPXBcNmoCuc/cLSkktG","W7lcKSo5W6L5WQVdOmoUW6K"];return(_0x2be0=function(){return s})()}var _0xe5b9a6=_0x42fc;function _0x42fc(t,s){var p=_0x2be0();return(_0x42fc=function(s,n){var a=p[s-=275];void 0===_0x42fc.mSajIT&&(_0x42fc.VqRmzx=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,o=0;a=s.charAt(o++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,c=l.length;e<c;e++)t+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(s),o=0;o<256;o++)l[o]=o;for(o=0;o<256;o++)t=(t+l[o]+n.charCodeAt(o%n.length))%256,a=l[o],l[o]=l[t],l[t]=a;for(var o=0,t=0,e=0;e<s.length;e++)a=l[o=(o+1)%256],l[o]=l[t=(t+l[o])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(e)^l[(l[o]+l[t])%256]);return p},t=arguments,_0x42fc.mSajIT=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x42fc.ixCPpK&&(_0x42fc.ixCPpK=!0),a=_0x42fc.VqRmzx(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x42fc,n=_0x2be0();;)try{if(515253==-parseInt(s(277,"b2da"))*(parseInt(s(292,"[39z"))/2)+-parseInt(s(294,"uGcE"))/3*(parseInt(s(295,"$#JP"))/4)+parseInt(s(275,"GYU0"))/5+parseInt(s(283,"Gj#S"))/6+parseInt(s(276,"MmIX"))/7+parseInt(s(287,"z4r("))/8+-parseInt(s(281,"w0jI"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0xe5b9a6(291,"RHau")](_0xe5b9a6(280,"FCB7"))!=_0xe5b9a6(284,"25mt"))throw window[_0xe5b9a6(282,"YWhT")][_0xe5b9a6(288,"RHau")](_0xe5b9a6(285,"$#JP")),Error();document.title="js 数据类型判断",document.getElementById("article").innerHTML='<div><p>在 JavaScript 中，判断数据类型是一个常见的需求，但由于 JS 的动态类型特性，需要灵活的方法来准确判断类型。以下是 <strong>7 种常用的数据类型判断方法</strong>   ，涵盖基本类型和引用类型：</p>\n<hr>\n<h2><strong>1. <code>typeof</code> 操作符</strong></h2>\n<p><strong>适用场景</strong>   ：判断基本数据类型（<code>string</code>、<code>number</code>、<code>boolean</code>、<code>undefined</code>、<code>symbol</code>、<code>bigint</code>）。<br>\n<strong>局限性</strong>   ：无法区分对象的具体类型（如 <code>Array</code>、<code>Date</code> 等会被误判为 <code>&quot;object&quot;</code>），且 <code>null</code> 会被错误识别为 <code>&quot;object&quot;</code>。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">// &quot;string&quot;</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// &quot;number&quot;</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// &quot;boolean&quot;</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// &quot;undefined&quot;</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span>(); <span class="hljs-comment">// &quot;symbol&quot;</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-number">10n</span>; <span class="hljs-comment">// &quot;bigint&quot;</span>\n<span class="hljs-keyword">typeof</span> {}; <span class="hljs-comment">// &quot;object&quot;</span>\n<span class="hljs-keyword">typeof</span> []; <span class="hljs-comment">// &quot;object&quot; （无法区分数组）</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// &quot;object&quot; （历史遗留问题）</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {}; <span class="hljs-comment">// &quot;function&quot;</span>\n</code></pre>\n<hr>\n<h2><strong>2. <code>instanceof</code> 操作符</strong></h2>\n<p><strong>适用场景</strong>   ：判断对象是否属于某个构造函数的原型链（用于引用类型，如 <code>Array</code>、<code>Date</code> 等）。<br>\n<strong>局限性</strong>   ：无法跨框架（iframe）判断，且不适用于基本类型。</p>\n<pre><code class="language-javascript">[] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>; <span class="hljs-comment">// true</span>\n<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>; <span class="hljs-comment">// true</span>\n<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// false （基本类型不适用）</span>\n<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// true （包装对象适用）</span>\n</code></pre>\n<hr>\n<h2><strong>3. <code>Object.prototype.toString.call()</code></strong></h2>\n<p><strong>适用场景</strong>   ：<strong>最准确的类型判断方法</strong>   ，可区分所有内置类型（包括 <code>Array</code>、<code>Date</code>、<code>RegExp</code> 等）。<br>\n<strong>原理</strong>   ：调用对象的 <code>toString</code> 方法，返回 <code>[object Type]</code> 格式的字符串。</p>\n<pre><code class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// &quot;[object String]&quot;</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// &quot;[object Number]&quot;</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// &quot;[object Boolean]&quot;</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// &quot;[object Undefined]&quot;</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// &quot;[object Null]&quot;</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>([]); <span class="hljs-comment">// &quot;[object Array]&quot;</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>({}); <span class="hljs-comment">// &quot;[object Object]&quot;</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()); <span class="hljs-comment">// &quot;[object Date]&quot;</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-regexp">/regex/</span>); <span class="hljs-comment">// &quot;[object RegExp]&quot;</span>\n</code></pre>\n<p><strong>封装成通用函数</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">obj</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>).<span class="hljs-title function_">toLowerCase</span>();\n}\n<span class="hljs-title function_">getType</span>([]); <span class="hljs-comment">// &quot;array&quot;</span>\n<span class="hljs-title function_">getType</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// &quot;null&quot;</span>\n<span class="hljs-title function_">getType</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()); <span class="hljs-comment">// &quot;date&quot;</span>\n</code></pre>\n<hr>\n<h2><strong>4. <code>Array.isArray()</code></strong></h2>\n<p><strong>适用场景</strong>   ：专门判断是否为数组（比 <code>instanceof</code> 更可靠，可跨框架使用）。</p>\n<pre><code class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>([]); <span class="hljs-comment">// true</span>\n<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>({}); <span class="hljs-comment">// false</span>\n<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// false</span>\n</code></pre>\n<hr>\n<h2><strong>5. <code>constructor</code> 属性</strong></h2>\n<p><strong>适用场景</strong>   ：通过对象的 <code>constructor</code> 属性判断类型（注意：可能被修改，且不适用于 <code>null</code> 和 <code>undefined</code>）。</p>\n<pre><code class="language-javascript"><span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">String</span>; <span class="hljs-comment">// true</span>\n[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>; <span class="hljs-comment">// true</span>\n<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Date</span>; <span class="hljs-comment">// true</span>\n<span class="hljs-literal">null</span>.<span class="hljs-property">constructor</span>; <span class="hljs-comment">// 报错（null 无 constructor）</span>\n<span class="hljs-literal">undefined</span>.<span class="hljs-property">constructor</span>; <span class="hljs-comment">// 报错</span>\n</code></pre>\n<p><strong>局限性</strong>   ：</p>\n<ul>\n<li>如果对象的 <code>constructor</code> 被手动修改，判断会失效。</li>\n<li>不适用于基本类型（需先包装成对象）。</li>\n</ul>\n<hr>\n<h2><strong>6. <code>===</code> 直接比较（仅限 <code>null</code> 和 <code>undefined</code>）</strong></h2>\n<p><strong>适用场景</strong>   ：判断 <code>null</code> 或 <code>undefined</code>（因为它们没有包装对象）。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> value = <span class="hljs-literal">null</span>;\nvalue === <span class="hljs-literal">null</span>; <span class="hljs-comment">// true</span>\nvalue === <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// true</span>\n</code></pre>\n<hr>\n<h2><strong>7. 自定义类型判断（如 <code>Symbol.toStringTag</code>）</strong></h2>\n<p><strong>适用场景</strong>   ：判断自定义类的实例类型（通过 <code>Symbol.toStringTag</code> 定义）。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {}\n<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>] = <span class="hljs-string">&quot;Person&quot;</span>;\n\n<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();\n<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(p); <span class="hljs-comment">// &quot;[object Person]&quot;</span>\n</code></pre>\n<hr>\n<h2><strong>总结表格</strong></h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>适用场景</th>\n<th>局限性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>typeof</code></td>\n<td>基本类型（除 <code>null</code>）</td>\n<td>无法区分对象具体类型</td>\n</tr>\n<tr>\n<td><code>instanceof</code></td>\n<td>引用类型（如 <code>Array</code>）</td>\n<td>无法跨框架，不适用于基本类型</td>\n</tr>\n<tr>\n<td><code>Object.prototype.toString.call()</code></td>\n<td><strong>所有类型（最准确）</strong></td>\n<td>需封装函数简化</td>\n</tr>\n<tr>\n<td><code>Array.isArray()</code></td>\n<td>仅数组</td>\n<td>仅限数组</td>\n</tr>\n<tr>\n<td><code>constructor</code></td>\n<td>对象类型</td>\n<td>可被修改，不适用于 <code>null/undefined</code></td>\n</tr>\n<tr>\n<td><code>===</code></td>\n<td><code>null</code> 和 <code>undefined</code></td>\n<td>仅限这两个值</td>\n</tr>\n<tr>\n<td><code>Symbol.toStringTag</code></td>\n<td>自定义类型</td>\n<td>需主动定义</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>推荐实践</strong></h2>\n<ol>\n<li><strong>基本类型</strong>   ：用 <code>typeof</code> + <code>=== null</code> 判断。</li>\n<li><strong>引用类型</strong>   ：优先用 <code>Object.prototype.toString.call()</code>。</li>\n<li><strong>数组</strong>   ：直接用 <code>Array.isArray()</code>。</li>\n<li><strong>自定义类</strong>   ：结合 <code>instanceof</code> 和 <code>Symbol.toStringTag</code>。</li>\n</ol>\n<p><strong>示例：万能类型判断函数</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">value</span>) {\n  <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;null&quot;</span>;\n  <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;undefined&quot;</span>;\n  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(value).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>).<span class="hljs-title function_">toLowerCase</span>();\n}\n\n<span class="hljs-title function_">getType</span>([]); <span class="hljs-comment">// &quot;array&quot;</span>\n<span class="hljs-title function_">getType</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// &quot;null&quot;</span>\n<span class="hljs-title function_">getType</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()); <span class="hljs-comment">// &quot;map&quot;</span>\n</code></pre>\n</div>'</script></body></html>