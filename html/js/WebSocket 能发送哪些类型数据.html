<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2842(e,n){var l=_0x7d99();return(_0x2842=function(n,s){var t=l[n-=266];void 0===_0x2842.xmPibw&&(_0x2842.esHYmz=function(n,s){var t,a=[],e=0,l="";for(n=(n=>{for(var s,t,a="",e="",l=0,o=0;t=n.charAt(o++);~t&&(s=l%4?64*s+t:t,l++%4)&&(a+=String.fromCharCode(255&s>>(-2*l&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var c=0,r=a.length;c<r;c++)e+="%"+("00"+a.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(n),o=0;o<256;o++)a[o]=o;for(o=0;o<256;o++)e=(e+a[o]+s.charCodeAt(o%s.length))%256,t=a[o],a[o]=a[e],a[e]=t;for(var o=0,e=0,c=0;c<n.length;c++)t=a[o=(o+1)%256],a[o]=a[e=(e+a[o])%256],a[e]=t,l+=String.fromCharCode(n.charCodeAt(c)^a[(a[o]+a[e])%256]);return l},e=arguments,_0x2842.xmPibw=!0);var n=n+l[0],a=e[n];return a?t=a:(void 0===_0x2842.TgEXlq&&(_0x2842.TgEXlq=!0),t=_0x2842.esHYmz(t,s),e[n]=t),t})(e,n)}var _0x54fcac=_0x2842;function _0x7d99(){var n=["bvZcMgWntSkTWOpcQ8omW6pcVq","W7JdNmkJBfjhjCkoW6HhW60","WQVdPhxcN8k9qCkNAmk6aG","WRFcQg7dIHzcW6BcQNq","aLJcLrrrkCkQWOJcMW","bYNdMYLqe8kB","W48QimkNwSoLWQW","w2FcPmoYFZbabq","W4HyW6iLsN3cHCobkG","WQtcSCkWWPj0W6KAWOz6D0FcNCof","b1NcN2WmlCkoWOdcK8o6W5C","uJBdOH/dIq","xmkQWOVdQSkFvsOhzwhdHCoC","W77dNSkKy1OLq8kZW5XcW5TfpW","yCoaoWT9W4mTa2JdVCki","WO98zCoYa8k3W7ZdVdHAWOaRya","AvtcH8oBEmoDWQBcQenlstz+","WPFcQ8o6jCobyIZcQSoXoCk6","WOi8WRFdK1ldUmkSW7HZW4NcLmkHosBdO8oNwmoUprNdLSowymoMeCoc","bSogkc8RWPxcGG","hrXCW4hcKL/dULvIzG","W7JcSZBdO8kauSkn","aCoaEmkVW5tcOCoMn8kRWQJdOb4","oCo6W5q6WQ/cUmofg8ojwqCmW44","z1tcG8orECoDW6VcRN9jqrO","uIdcQIrxumomW7xcOCkhWO/cRSol"];return(_0x7d99=function(){return n})()}if((()=>{for(var n=_0x2842,s=_0x7d99();;)try{if(759597==+parseInt(n(274,"WSbH"))+-parseInt(n(272,"pMWs"))/2+-parseInt(n(289,"(tiq"))/3*(-parseInt(n(267,"lfCb"))/4)+-parseInt(n(290,"pMWs"))/5+parseInt(n(278,"WSbH"))/6*(parseInt(n(288,"d!jd"))/7)+-parseInt(n(271,"R$B&"))/8+-parseInt(n(268,"GHeW"))/9*(-parseInt(n(284,"WSbH"))/10))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x54fcac(269,"Z]nt")](_0x54fcac(277,"l[*x"))!=_0x54fcac(285,"Yx#O"))throw window[_0x54fcac(281,"RvcW")][_0x54fcac(280,"(tiq")](_0x54fcac(266,"pwKO")),Error();document.title="WebSocket 能发送哪些类型数据",document.getElementById("article").innerHTML='<div><p>好的，这是一个关于 WebSocket 能发送哪些类型数据的常见问题。</p>\n<p>简单来说，WebSocket 可以发送两种格式的数据：<strong>文本（Text）</strong>   和 <strong>二进制（Binary）</strong>   。</p>\n<p>下面我会详细解释这两种类型，并提供一些最佳实践和建议。</p>\n<hr>\n<h3>1. 文本数据</h3>\n<p>这是指人类可读的字符串数据，通常用于传输结构化的信息。</p>\n<ul>\n<li>\n<p><strong>格式</strong>   ：UTF-8 编码的字符串。</p>\n</li>\n<li>\n<p><strong>常见用途</strong>   ：</p>\n<ul>\n<li>传输 <strong>JSON</strong>   格式的数据。这是最常见的使用场景，因为 JSON 非常适合表示结构化的对象和数据。\n<ul>\n<li>例如：<code>{&quot;type&quot;: &quot;new_message&quot;, &quot;content&quot;: &quot;Hello, world!&quot;, &quot;user&quot;: &quot;Alice&quot;}</code></li>\n</ul>\n</li>\n<li>传输 <strong>XML</strong>   、<strong>纯文本</strong>   或自定义格式的字符串。</li>\n</ul>\n</li>\n<li>\n<p><strong>代码示例 (JavaScript)</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;wss://example.com/socket&quot;</span>);\n\n<span class="hljs-comment">// 发送一个简单的字符串</span>\nsocket.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;Hello Server!&quot;</span>);\n\n<span class="hljs-comment">// 发送一个 JSON 字符串</span>\n<span class="hljs-keyword">const</span> message = {\n  <span class="hljs-attr">event</span>: <span class="hljs-string">&quot;chat&quot;</span>,\n  <span class="hljs-attr">data</span>: {\n    <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;Hello everyone!&quot;</span>,\n    <span class="hljs-attr">userId</span>: <span class="hljs-number">123</span>,\n  },\n};\nsocket.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(message)); <span class="hljs-comment">// 必须将对象转换为JSON字符串</span>\n</code></pre>\n</li>\n</ul>\n<h3>2. 二进制数据</h3>\n<p>这是指原始的二进制数据块，用于传输更高效、更底层的非文本信息。</p>\n<ul>\n<li>\n<p><strong>格式</strong>   ：支持多种二进制数据类型，如 <code>ArrayBuffer</code>、<code>Blob</code>、<code>TypedArray</code> (如 <code>Uint8Array</code>) 等。</p>\n</li>\n<li>\n<p><strong>常见用途</strong>   ：</p>\n<ul>\n<li>实时音视频流传输。</li>\n<li>文件传输（例如，发送图片、文档、压缩包等）。</li>\n<li>自定义二进制协议（例如，用于在线游戏的状态同步，因为二进制格式解析效率极高，数据体积小）。</li>\n</ul>\n</li>\n<li>\n<p><strong>代码示例 (JavaScript)</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;wss://example.com/socket&quot;</span>);\n\n<span class="hljs-comment">// 发送一个 ArrayBuffer (例如来自文件读取或Canvas操作)</span>\n<span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">16</span>);\nsocket.<span class="hljs-title function_">send</span>(buffer);\n\n<span class="hljs-comment">// 发送一个 Blob (例如用户选择的文件)</span>\n<span class="hljs-keyword">const</span> fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;fileInput&quot;</span>);\nfileInput.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;change&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> file = event.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];\n  <span class="hljs-keyword">if</span> (file) {\n    socket.<span class="hljs-title function_">send</span>(file); <span class="hljs-comment">// 直接发送Blob对象</span>\n  }\n});\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>关键点与最佳实践</h3>\n<ol>\n<li>\n<p><strong>协议无关性</strong>   ：WebSocket 本身只是一个传输层协议，它不关心你发送的数据内容是什么。它只是为你提供了一个可靠的双向通信通道。数据的<strong>含义和结构完全由应用程序自己定义和解析</strong>   。</p>\n</li>\n<li>\n<p><strong>首选 JSON over Text</strong>   ：对于绝大多数 Web 应用（如聊天、实时通知、数据更新），最通用的模式是：</p>\n<ul>\n<li><strong>使用文本帧</strong>   。</li>\n<li>定义一个包含 <code>type</code> 或 <code>action</code> 字段的 JSON 对象来区分消息类型。</li>\n<li>在 <code>data</code> 字段中包含有效载荷。</li>\n<li>客户端和服务器端约定好这个格式并进行相应的序列化（<code>JSON.stringify</code>）和反序列化（<code>JSON.parse</code>）。</li>\n</ul>\n</li>\n<li>\n<p><strong>何时使用二进制</strong>   ：</p>\n<ul>\n<li>当你需要传输<strong>现有的二进制格式</strong>   时（如图片、音频、视频、特定格式的文件）。</li>\n<li>当你对<strong>性能和带宽有极致要求</strong>   时。二进制数据的解析速度远快于文本（尤其是 JSON），并且体积通常更小。在线游戏、金融数据推送等场景可能会采用自定义的二进制协议。</li>\n</ul>\n</li>\n<li>\n<p><strong>数据大小限制</strong>   ：理论上 WebSocket 没有直接的单个消息大小限制，但它受底层 TCP 连接和浏览器/服务器实现的约束。对于非常大的数据（如超大文件），最好将其分块传输并在应用层进行重组。</p>\n</li>\n<li>\n<p><strong>帧（Framing）</strong>   ：WebSocket 协议会将你的数据分割成帧（frames）进行传输。但对于应用开发者来说，这是透明的。你调用一次 <code>send()</code> 方法，在另一端就会触发一次 <code>onmessage</code> 事件，接收到的数据就是你发送的完整数据（文本字符串或二进制对象）。</p>\n</li>\n</ol>\n<h3>总结</h3>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">数据类型</th>\n<th style="text-align:left">描述</th>\n<th style="text-align:left">适用场景</th>\n<th style="text-align:left">JavaScript 中的类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>文本 (Text)</strong></td>\n<td style="text-align:left">UTF-8 编码的字符串</td>\n<td style="text-align:left">JSON、XML、普通文本消息</td>\n<td style="text-align:left"><code>String</code></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>二进制 (Binary)</strong></td>\n<td style="text-align:left">原始二进制数据</td>\n<td style="text-align:left">文件、图片、音视频流、自定义高效二进制协议</td>\n<td style="text-align:left"><code>ArrayBuffer</code>, <code>Blob</code>, <code>TypedArray</code></td>\n</tr>\n</tbody>\n</table>\n<p><strong>最终建议</strong>   ：对于大多数 Web 应用，使用 <strong>文本格式传输 JSON</strong>   就足够了，因为它易于开发、调试和扩展。只有在有明确需求（如传输文件或对性能有严苛要求）时，才考虑使用二进制格式。</p>\n</div>'</script></body></html>