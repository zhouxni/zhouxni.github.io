<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x25f1ea=_0xcd15;function _0xcd15(e,s){var l=_0x56e1();return(_0xcd15=function(s,n){var a=l[s-=253];void 0===_0xcd15.oDaYFB&&(_0xcd15.ugUstl=function(s,n){var a,t=[],e=0,l="";for(s=(s=>{for(var n,a,t="",e="",l=0,c=0;a=s.charAt(c++);~a&&(n=l%4?64*n+a:a,l++%4)&&(t+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,p=t.length;o<p;o++)e+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(e)})(s),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)e=(e+t[c]+n.charCodeAt(c%n.length))%256,a=t[c],t[c]=t[e],t[e]=a;for(var c=0,e=0,o=0;o<s.length;o++)a=t[c=(c+1)%256],t[c]=t[e=(e+t[c])%256],t[e]=a,l+=String.fromCharCode(s.charCodeAt(o)^t[(t[c]+t[e])%256]);return l},e=arguments,_0xcd15.oDaYFB=!0);var s=s+l[0],t=e[s];return t?a=t:(void 0===_0xcd15.dfznSC&&(_0xcd15.dfznSC=!0),a=_0xcd15.ugUstl(a,n),e[s]=a),a})(e,s)}function _0x56e1(){var s=["oajlW63dQcmKEwZcH8oLWO8","o3akb3uYWQFdLSkGn8owWOjZCW","dmkdfCoRWQZcQwVcSvuh","q8keWPVdVbBdPCke","W51qdNHoW4jpW7m6WQW","W5LqbbbQW7PRW4C4","W5ddJ8kcW6VdN3tdGSoDhW","WQpcLCotWR7cMtdcVmkiamkCuComg0u","fCozWPZdKsVdRmkaW4q","j19jW6xcVmk0aCkmWOXBWPhdMbZdNexdSeZcJYyllLBcR8kdW4xcLa","WOdcPdzlW7pdHMTKWQyBW5n5","lbiAW6nBW5/cPei","maxdMg8CW7TVWPKssNHWW7u","c01+oCoLyNRdRutcOmkrWPa","WQODxgONW4urW6e2W4G","sq89E8kV","iXSGW7CrWQddP8ofW73cHSok","WOFcI8obfmo4jYJcQa7cPCoXW5hcVq","W6NcSa4tecVdHCk9WOK","ktBcRmk6CK4Szt7dTIpdTG","WOfaWQFcHCoGW4xdStzYea","cConW57dQ8kWj8oabSocpmoTWO5+","vSkmwCoTlaKExG","WQTiW4yRiCkTca","WQVcUMVdTmksW7JdPmkJW4bmx0ed","FSoXW6rvWOpdQg3cK8kDW7vE"];return(_0x56e1=function(){return s})()}if((()=>{for(var s=_0xcd15,n=_0x56e1();;)try{if(695094==-parseInt(s(276,"^s8&"))*(-parseInt(s(277,"^s8&"))/2)+parseInt(s(272,"Thwq"))/3+-parseInt(s(258,"Uq3y"))/4+-parseInt(s(270,"mosK"))/5*(parseInt(s(257,"2kA)"))/6)+-parseInt(s(260,"B1!s"))/7*(parseInt(s(271,"syI#"))/8)+parseInt(s(265,"KLqt"))/9+parseInt(s(253,"lxpX"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x25f1ea(275,"gbRV")](_0x25f1ea(278,"lxpX"))!=_0x25f1ea(261,"bEwm"))throw window[_0x25f1ea(268,"qCKk")][_0x25f1ea(269,"ErTw")](_0x25f1ea(255,"H9Bq")),Error();document.title="addEventListener 参数详解",document.getElementById("article").innerHTML='<div><p><code>addEventListener</code> 是 JavaScript 中用于为 DOM 元素<strong>绑定事件监听器</strong>   的核心方法，它允许开发者在元素上注册一个函数（监听器），当指定事件被触发时（如点击、滚动、键盘输入等），该函数会自动执行。其灵活性主要体现在丰富的参数配置上，合理使用这些参数能精准控制事件的触发行为、优先级及兼容性。</p>\n<h3>一、<code>addEventListener</code> 基础语法</h3>\n<p><code>addEventListener</code> 是 DOM 元素的实例方法，调用格式如下：</p>\n<pre><code class="language-javascript">element.<span class="hljs-title function_">addEventListener</span>(eventType, listener, options);\n<span class="hljs-comment">// 或（兼容性写法，已逐步被 options 替代）</span>\nelement.<span class="hljs-title function_">addEventListener</span>(eventType, listener, useCapture);\n</code></pre>\n<h3>二、三大核心参数详解</h3>\n<h4>1. 第一个参数：<code>eventType</code>（事件类型，必传）</h4>\n<ul>\n<li><strong>作用</strong>   ：指定要监听的<strong>事件名称</strong>   （字符串类型），需严格遵循 DOM 事件规范，<strong>不含前缀 <code>on</code></strong>   （如点击事件是 <code>click</code>，而非 <code>onclick</code>）。</li>\n<li><strong>常见事件类型分类</strong>   ：\n<table>\n<thead>\n<tr>\n<th>事件类别</th>\n<th>示例事件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>鼠标事件</td>\n<td><code>click</code>（点击）、<code>mouseover</code>（悬浮）、<code>mousedown</code>（按下）</td>\n<td>与鼠标操作相关</td>\n</tr>\n<tr>\n<td>键盘事件</td>\n<td><code>keydown</code>（按键按下）、<code>keyup</code>（按键松开）、<code>keypress</code>（字符输入，已废弃）</td>\n<td>与键盘操作相关</td>\n</tr>\n<tr>\n<td>DOM 结构事件</td>\n<td><code>DOMContentLoaded</code>（DOM 加载完成）、<code>DOMNodeInserted</code>（节点插入）</td>\n<td>监听 DOM 结构变化</td>\n</tr>\n<tr>\n<td>表单事件</td>\n<td><code>submit</code>（表单提交）、<code>input</code>（输入框变化）、<code>change</code>（值改变）</td>\n<td>与表单元素交互相关</td>\n</tr>\n<tr>\n<td>窗口/文档事件</td>\n<td><code>load</code>（页面资源全加载）、<code>resize</code>（窗口 resize）、<code>scroll</code>（滚动）</td>\n<td>监听窗口或文档级别的状态变化</td>\n</tr>\n<tr>\n<td>触摸事件</td>\n<td><code>touchstart</code>（触摸开始）、<code>touchend</code>（触摸结束）、<code>touchmove</code>（触摸滑动）</td>\n<td>移动端专属，监听触摸操作</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li><strong>注意事项</strong>   ：\n<ul>\n<li>事件名称<strong>区分大小写</strong>   （如 <code>Click</code> 是无效的，必须为 <code>click</code>）。</li>\n<li>支持<strong>自定义事件</strong>   （需通过 <code>dispatchEvent</code> 手动触发），例如：<pre><code class="language-javascript"><span class="hljs-comment">// 注册自定义事件监听器</span>\n<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;customEvent&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;自定义事件触发，携带数据：&quot;</span>, e.<span class="hljs-property">detail</span>);\n});\n<span class="hljs-comment">// 手动触发自定义事件（携带数据）</span>\n<span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomEvent</span>(<span class="hljs-string">&quot;customEvent&quot;</span>, { <span class="hljs-attr">detail</span>: { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> } });\n<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">dispatchEvent</span>(event);\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h4>2. 第二个参数：<code>listener</code>（事件监听器，必传）</h4>\n<ul>\n<li>\n<p><strong>作用</strong>   ：指定事件触发时要执行的<strong>处理函数</strong>   （也称“回调函数”），可以是函数引用、匿名函数，或实现了 <code>EventListener</code> 接口的对象。</p>\n</li>\n<li>\n<p><strong>三种常见形式</strong>   ：</p>\n<h5>（1）普通函数（推荐）</h5>\n<p>最常用的形式，事件触发时函数会被调用，且默认接收一个 <strong><code>event</code> 对象</strong>   作为参数（包含事件相关信息，如触发元素、位置、按键等）。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);\n<span class="hljs-comment">// 函数声明（可复用）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">event</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;点击的元素：&quot;</span>, event.<span class="hljs-property">target</span>); <span class="hljs-comment">// event.target 是触发事件的元素</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;点击位置 X 坐标：&quot;</span>, event.<span class="hljs-property">clientX</span>);\n}\nbtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, handleClick); <span class="hljs-comment">// 传入函数引用</span>\n</code></pre>\n<h5>（2）匿名函数（一次性场景）</h5>\n<p>适合仅执行一次、无需复用的逻辑，但缺点是无法通过 <code>removeEventListener</code> 移除（因无函数引用）。</p>\n<pre><code class="language-javascript">btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;匿名函数处理点击&quot;</span>, event);\n});\n</code></pre>\n<h5>（3）箭头函数</h5>\n<p>语法简洁，但需注意：<strong>箭头函数没有自己的 <code>this</code></strong>   ，其 <code>this</code> 绑定到外层作用域（而非触发事件的元素），因此无法通过 <code>this</code> 获取当前元素，需通过 <code>event.target</code> 替代。</p>\n<pre><code class="language-javascript">btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;箭头函数 this：&quot;</span>, <span class="hljs-variable language_">this</span>); <span class="hljs-comment">// this 指向外层作用域（如 window）</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;触发元素：&quot;</span>, event.<span class="hljs-property">target</span>); <span class="hljs-comment">// 需用 event.target 获取按钮</span>\n});\n</code></pre>\n<h5>（4）实现 <code>EventListener</code> 接口的对象</h5>\n<p>较少用，适用于需要封装多个事件处理逻辑的场景，对象需包含 <code>handleEvent</code> 方法（事件触发时会自动调用该方法）。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> eventHandler = {\n  <span class="hljs-title function_">handleEvent</span>(<span class="hljs-params">event</span>) {\n    <span class="hljs-keyword">switch</span> (event.<span class="hljs-property">type</span>) {\n      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;click&quot;</span>:\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;处理点击事件&quot;</span>);\n        <span class="hljs-keyword">break</span>;\n      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;mouseover&quot;</span>:\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;处理悬浮事件&quot;</span>);\n        <span class="hljs-keyword">break</span>;\n    }\n  },\n};\nbtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, eventHandler);\nbtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;mouseover&quot;</span>, eventHandler);\n</code></pre>\n</li>\n</ul>\n<h4>3. 第三个参数：<code>options</code> / <code>useCapture</code>（可选，控制事件行为）</h4>\n<p>这是最灵活的参数，用于配置事件的<strong>传播阶段、触发时机、优先级</strong>   等。有两种写法：早期的布尔值 <code>useCapture</code>，以及现代的对象 <code>options</code>（功能更全面，推荐使用）。</p>\n<h5>（1）兼容性写法：布尔值 <code>useCapture</code></h5>\n<ul>\n<li>\n<p><strong>作用</strong>   ：控制事件监听器在<strong>事件传播的哪个阶段</strong>   触发（仅涉及“捕获阶段”和“冒泡阶段”，下文详解）。</p>\n</li>\n<li>\n<p><strong>取值</strong>   ：</p>\n<ul>\n<li><code>false</code>（默认值）：监听器在<strong>冒泡阶段</strong>   触发（事件从目标元素向上传播时执行）。</li>\n<li><code>true</code>：监听器在<strong>捕获阶段</strong>   触发（事件从顶层元素向下传播到目标元素时执行）。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：事件传播阶段的差异</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> parent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.parent&quot;</span>);\n<span class="hljs-keyword">const</span> child = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.child&quot;</span>);\n\n<span class="hljs-comment">// 父元素监听器（捕获阶段触发，useCapture: true）</span>\nparent.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;父元素（捕获）&quot;</span>), <span class="hljs-literal">true</span>);\n<span class="hljs-comment">// 子元素监听器（冒泡阶段触发，默认 false）</span>\nchild.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;子元素（冒泡）&quot;</span>), <span class="hljs-literal">false</span>);\n<span class="hljs-comment">// 父元素监听器（冒泡阶段触发，useCapture: false）</span>\nparent.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;父元素（冒泡）&quot;</span>), <span class="hljs-literal">false</span>);\n</code></pre>\n<p>点击按钮后，执行顺序为：<br>\n<code>父元素（捕获）</code> → <code>子元素（冒泡）</code> → <code>父元素（冒泡）</code><br>\n（原因：事件传播先经历“捕获阶段”（从 document 到目标元素），再经历“冒泡阶段”（从目标元素回到 document））。</p>\n</li>\n</ul>\n<h5>（2）现代写法：对象 <code>options</code>（推荐）</h5>\n<p><code>useCapture</code> 仅能控制传播阶段，而 <code>options</code> 对象支持更多配置项，完全覆盖 <code>useCapture</code> 的功能，同时新增了 <code>once</code>、<code>passive</code> 等实用属性。</p>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>类型</th>\n<th>作用与说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>capture</code></td>\n<td>boolean</td>\n<td>与 <code>useCapture</code> 完全一致：<code>true</code> 捕获阶段触发，<code>false</code> 冒泡阶段触发（默认 <code>false</code>）</td>\n</tr>\n<tr>\n<td><code>once</code></td>\n<td>boolean</td>\n<td><code>true</code> 表示监听器<strong>仅触发一次</strong>   ，触发后自动从元素上移除（无需手动调用 <code>removeEventListener</code>）</td>\n</tr>\n<tr>\n<td><code>passive</code></td>\n<td>boolean</td>\n<td><code>true</code> 表示监听器<strong>不会调用 <code>event.preventDefault()</code></strong>   （用于优化滚动性能，尤其移动端）</td>\n</tr>\n<tr>\n<td><code>signal</code></td>\n<td>AbortSignal</td>\n<td>通过 <code>AbortController</code> 控制监听器的销毁（可批量移除多个监听器）</td>\n</tr>\n<tr>\n<td><code>priority</code></td>\n<td>number</td>\n<td>非标准属性（部分浏览器支持），用于设置监听器优先级（数值越大，触发越早）</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>关键配置项详解</strong>   ：\n<ol>\n<li>\n<p><strong><code>once: true</code>（一次性监听器）</strong><br>\n适合“仅需响应一次”的场景（如弹窗确认按钮、表单提交按钮），避免重复触发。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 按钮点击一次后，监听器自动移除</span>\nbtn.<span class="hljs-title function_">addEventListener</span>(\n  <span class="hljs-string">&quot;click&quot;</span>,\n  <span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;仅触发一次&quot;</span>);\n  },\n  { <span class="hljs-attr">once</span>: <span class="hljs-literal">true</span> },\n);\n</code></pre>\n</li>\n<li>\n<p><strong><code>passive: true</code>（优化滚动性能）</strong><br>\n浏览器在触发滚动事件（如 <code>scroll</code>、<code>touchmove</code>）时，会先检查监听器是否调用 <code>event.preventDefault()</code>（可能阻止滚动），这会导致滚动卡顿（尤其移动端）。<br>\n若监听器<strong>确实不需要阻止默认行为</strong>   （如仅统计滚动位置），设置 <code>passive: true</code> 可让浏览器跳过检查，提升滚动流畅度。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 移动端滚动监听优化</span>\n<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(\n  <span class="hljs-string">&quot;touchmove&quot;</span>,\n  <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;滚动中...&quot;</span>);\n    <span class="hljs-comment">// 此处不能调用 e.preventDefault()，否则会报错（因 passive: true）</span>\n  },\n  { <span class="hljs-attr">passive</span>: <span class="hljs-literal">true</span> },\n);\n</code></pre>\n<blockquote>\n<p>注意：若 <code>passive: true</code> 时仍调用 <code>event.preventDefault()</code>，浏览器会忽略该调用并在控制台抛出警告。</p>\n</blockquote>\n</li>\n<li>\n<p><strong><code>signal</code>（通过 <code>AbortController</code> 销毁监听器）</strong><br>\n传统 <code>removeEventListener</code> 需手动传入相同的 <code>eventType</code> 和 <code>listener</code> 才能移除，而 <code>signal</code> 支持通过 <code>AbortController</code> 批量、灵活地销毁监听器。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 创建 AbortController 实例</span>\n<span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();\n<span class="hljs-keyword">const</span> { signal } = controller;\n\n<span class="hljs-comment">// 注册多个监听器，共用同一个 signal</span>\nbtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;点击1&quot;</span>), { signal });\nbtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;点击2&quot;</span>), { signal });\n<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;scroll&quot;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;滚动&quot;</span>), { signal });\n\n<span class="hljs-comment">// 手动销毁所有绑定了该 signal 的监听器（如组件卸载时）</span>\ncontroller.<span class="hljs-title function_">abort</span>();\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n<h3>三、事件传播阶段与 <code>capture</code> 参数的关系</h3>\n<p>理解 <code>capture</code> 参数的核心是掌握 <strong>DOM 事件的传播机制</strong>   ，事件触发后会经历三个阶段（IE 8 及以下仅支持冒泡阶段）：</p>\n<ol>\n<li><strong>捕获阶段（Capture Phase）</strong>   ：事件从最顶层元素（如 <code>document</code>）向下传播到<strong>目标元素</strong>   （触发事件的元素）。</li>\n<li><strong>目标阶段（Target Phase）</strong>   ：事件到达目标元素，触发目标元素上的监听器（无论 <code>capture</code> 为 <code>true</code> 或 <code>false</code>）。</li>\n<li><strong>冒泡阶段（Bubbling Phase）</strong>   ：事件从目标元素向上传播回最顶层元素（如 <code>document</code>）。</li>\n</ol>\n<p><code>capture</code> 参数决定监听器在<strong>捕获阶段</strong>   还是<strong>冒泡阶段</strong>   执行，而目标阶段的监听器不受 <code>capture</code> 影响，只要事件类型匹配就会执行。</p>\n<h3>四、常见注意事项</h3>\n<h4>1. 监听器的移除（<code>removeEventListener</code>）</h4>\n<p>要成功移除通过 <code>addEventListener</code> 注册的监听器，必须满足以下三个条件（否则移除无效）：</p>\n<ul>\n<li>相同的 <code>eventType</code>（事件类型）。</li>\n<li>相同的 <code>listener</code> 函数引用（<strong>匿名函数无法移除</strong>   ，因每次创建的匿名函数是不同对象）。</li>\n<li>相同的 <code>options</code> 或 <code>useCapture</code>（若注册时用 <code>{ capture: true }</code>，移除时也需传入相同配置）。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// 错误：匿名函数无法移除</span>\nbtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;无法移除&quot;</span>), { <span class="hljs-attr">once</span>: <span class="hljs-literal">false</span> });\nbtn.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;无法移除&quot;</span>), {\n  <span class="hljs-attr">once</span>: <span class="hljs-literal">false</span>,\n}); <span class="hljs-comment">// 无效</span>\n\n<span class="hljs-comment">// 正确：使用具名函数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;可移除&quot;</span>);\n}\nbtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, handleClick, { <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span> });\nbtn.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, handleClick, { <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span> }); <span class="hljs-comment">// 有效</span>\n</code></pre>\n<h4>2. 事件委托与 <code>event.target</code></h4>\n<p>当多个子元素需要绑定相同事件（如列表项点击），无需逐个绑定监听器，可利用<strong>事件冒泡</strong>   特性，在父元素上绑定一个监听器，通过 <code>event.target</code> 定位触发事件的子元素（即“事件委托”）。</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>项目1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>项目2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>项目3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-comment">// 父元素绑定一次监听器，处理所有子元素点击</span>\n<span class="hljs-keyword">const</span> list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;list&quot;</span>);\nlist.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {\n  <span class="hljs-comment">// e.target 是实际点击的 li 元素</span>\n  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span> === <span class="hljs-string">&quot;LI&quot;</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;点击了项目：&quot;</span>, e.<span class="hljs-property">target</span>.<span class="hljs-property">dataset</span>.<span class="hljs-property">id</span>);\n  }\n});\n</code></pre>\n<h4>3. 兼容性处理</h4>\n<ul>\n<li><code>addEventListener</code> 兼容 IE 9 及以上浏览器，IE 8 及以下需使用 <code>attachEvent</code>（语法：<code>element.attachEvent(\'onclick\', listener)</code>）。</li>\n<li>若需兼容旧浏览器，可封装跨浏览器事件绑定函数：<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addEvent</span>(<span class="hljs-params">element, eventType, listener</span>) {\n  <span class="hljs-keyword">if</span> (element.<span class="hljs-property">addEventListener</span>) {\n    element.<span class="hljs-title function_">addEventListener</span>(eventType, listener);\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.<span class="hljs-property">attachEvent</span>) {\n    <span class="hljs-comment">// IE 8 及以下，事件类型需加 on 前缀</span>\n    element.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">`on<span class="hljs-subst">${eventType}</span>`</span>, listener);\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 极低版本浏览器，直接赋值（会覆盖已有事件）</span>\n    element[<span class="hljs-string">`on<span class="hljs-subst">${eventType}</span>`</span>] = listener;\n  }\n}\n</code></pre>\n</li>\n</ul>\n<h3>五、总结</h3>\n<p><code>addEventListener</code> 的参数设计围绕“<strong>灵活控制事件触发行为</strong>   ”展开，核心要点：</p>\n<ol>\n<li><code>eventType</code> 需用标准事件名（无 <code>on</code> 前缀），支持自定义事件。</li>\n<li><code>listener</code> 推荐用具名函数（便于移除），箭头函数需注意 <code>this</code> 绑定问题。</li>\n<li><code>options</code> 是现代开发的首选，<code>capture</code> 控制传播阶段，<code>once</code> 实现一次性触发，<code>passive</code> 优化滚动性能，<code>signal</code> 支持批量销毁。</li>\n<li>结合事件传播机制（捕获+冒泡），可实现事件委托等高效开发模式，减少监听器数量。</li>\n</ol>\n<p>掌握这些参数的用法，能让事件处理逻辑更高效、更符合性能优化要求，尤其在复杂交互场景（如移动端应用、单页应用）中至关重要。</p>\n</div>'</script></body></html>