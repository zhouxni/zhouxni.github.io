<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x234103=_0x3947;function _0x273b(){var s=["WO7cNCkPW67dJG","WOeFWP7cP8kzW4dcV1pdOa","W65ujspcPXnoECoHyJpdR8oJ","ruXqW5NcRYTQCGy","W5ldObJdU8oKlt3dG8kUzG","pZBdVCksW5rwaXlcUSk3WP96bG","eGxdSfNdLSo4EZWUWPm2BCojeG","iCkFsSo1amkvhSkQ","WQpdMh5uWOldRSkmW4FdKW","WPHhCgNdSCkMCmofW5RcKWtdTSkLWR7cHJNdIYKIW65gWR7cLCoPeX8","WRrDWQxcImkoy8oPW43cICow","W5/dR8oDWR/cVCkHeSoAWQxdRG","WR/dVx1TW75ldNXamCkrWPa","ztBcTColze7dQmoTrCkh","WR/dUxXRW7vkvvf/emkrWOf8","zdVcTCk0vv7dNmo5ua","beCorhJdJfxdVYS0W4bkoa","ksdcHaZdSCkia3m6WRSroHm","W5hcHW3cUCk6WQKn","AtVcV8krB2xdRmo+qa","cHTkjmkKWPhdUsldTSoIBSoE","WP5gW6tdTSkcWOpdMSo4keqspLSU","W4GBWQFcImocW5xcHG"];return(_0x273b=function(){return s})()}function _0x3947(e,s){var t=_0x273b();return(_0x3947=function(s,n){var a=t[s-=220];void 0===_0x3947.Ikenio&&(_0x3947.rkjwbW=function(s,n){var a,l=[],e=0,t="";for(s=(s=>{for(var n,a,l="",e="",t=0,p=0;a=s.charAt(p++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=l.length;c<o;c++)e+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)e=(e+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[e],l[e]=a;for(var p=0,e=0,c=0;c<s.length;c++)a=l[p=(p+1)%256],l[p]=l[e=(e+l[p])%256],l[e]=a,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[p]+l[e])%256]);return t},e=arguments,_0x3947.Ikenio=!0);var s=s+t[0],l=e[s];return l?a=l:(void 0===_0x3947.fdHPIn&&(_0x3947.fdHPIn=!0),a=_0x3947.rkjwbW(a,n),e[s]=a),a})(e,s)}if((()=>{for(var s=_0x3947,n=_0x273b();;)try{if(778849==-parseInt(s(241,"2Fo#"))*(parseInt(s(233,"Pzr6"))/2)+-parseInt(s(234,"3M(g"))/3*(-parseInt(s(226,"9rVn"))/4)+parseInt(s(221,"rq0$"))/5+-parseInt(s(224,"L$Xe"))/6+-parseInt(s(235,"w38Y"))/7+-parseInt(s(242,"rq0$"))/8+parseInt(s(236,"Y4)O"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x234103(229,"KQ95")](_0x234103(231,"jHX%"))!=_0x234103(230,"04eq"))throw window[_0x234103(237,"Tsp2")][_0x234103(225,"V20)")](_0x234103(239,"jrk&")),Error();document.title="typescript 类型递归",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，递归类型是一种强大的工具，可以用于处理嵌套结构的数据类型，比如深层对象、树形结构等。递归类型允许你定义一个类型，该类型可以在其定义中引用自身，从而实现对任意深度的嵌套结构的类型描述。</p>\n<h3>示例：深层只读类型</h3>\n<p>以下是一个递归类型的示例，用于实现深层只读（<code>DeepReadonly</code>），即使对象的所有层级属性都变为只读：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">DeepReadonly</span>&lt;T&gt; = {\n  <span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> keyof T]: T[P] <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span> ? <span class="hljs-title class_">DeepReadonly</span>&lt;T[P]&gt; : T[P];\n};\n\n<span class="hljs-comment">// 示例类型</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">NestedObject</span> = {\n  <span class="hljs-attr">a</span>: {\n    <span class="hljs-attr">b</span>: {\n      <span class="hljs-attr">c</span>: <span class="hljs-built_in">number</span>;\n    };\n    <span class="hljs-attr">d</span>: <span class="hljs-built_in">string</span>;\n  };\n  <span class="hljs-attr">e</span>: <span class="hljs-built_in">boolean</span>;\n};\n\n<span class="hljs-comment">// 使用 DeepReadonly</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">DeepReadonlyNestedObject</span> = <span class="hljs-title class_">DeepReadonly</span>&lt;<span class="hljs-title class_">NestedObject</span>&gt;;\n\n<span class="hljs-comment">// 结果类型相当于：</span>\n<span class="hljs-comment">/*\ntype DeepReadonlyNestedObject = {\n  readonly a: {\n    readonly b: {\n      readonly c: number;\n    };\n    readonly d: string;\n  };\n  readonly e: boolean;\n};\n*/</span>\n\n<span class="hljs-comment">// 验证</span>\n<span class="hljs-keyword">const</span> <span class="hljs-attr">example</span>: <span class="hljs-title class_">DeepReadonlyNestedObject</span> = {\n  <span class="hljs-attr">a</span>: {\n    <span class="hljs-attr">b</span>: {\n      <span class="hljs-attr">c</span>: <span class="hljs-number">42</span>\n    },\n    <span class="hljs-attr">d</span>: <span class="hljs-string">&quot;hello&quot;</span>\n  },\n  <span class="hljs-attr">e</span>: <span class="hljs-literal">true</span>\n};\n\n<span class="hljs-comment">// 以下操作会导致编译错误，因为所有属性都是只读的</span>\n<span class="hljs-comment">// example.a.b.c = 100; // Error</span>\n<span class="hljs-comment">// example.e = false; // Error</span>\n</code></pre>\n<h3>解析</h3>\n<ol>\n<li><strong>映射类型</strong>  ：\n<ul>\n<li><code>readonly [P in keyof T]: ...</code> 将类型 <code>T</code> 的所有键变为只读。</li>\n</ul>\n</li>\n<li><strong>条件类型</strong>  ：\n<ul>\n<li><code>T[P] extends object ? DeepReadonly&lt;T[P]&gt; : T[P]</code> 检查属性 <code>T[P]</code> 是否是一个对象。</li>\n<li>如果是对象，则递归地应用 <code>DeepReadonly</code>，使其所有子属性也变为只读。</li>\n<li>如果不是对象（即基本类型，如 <code>number</code>、<code>string</code> 等），则直接使用该属性的类型。</li>\n</ul>\n</li>\n<li><strong>递归</strong>  ：\n<ul>\n<li>通过递归调用 <code>DeepReadonly</code>，确保所有层级的对象属性都被转换为只读。</li>\n</ul>\n</li>\n</ol>\n<h3>其他递归类型示例</h3>\n<h4>1. 深层可选（<code>DeepPartial</code>）</h4>\n<p>如果你想让对象的所有层级属性都变为可选，可以使用类似的递归类型：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">DeepPartial</span>&lt;T&gt; = {\n  [P <span class="hljs-keyword">in</span> keyof T]?: T[P] <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span> ? <span class="hljs-title class_">DeepPartial</span>&lt;T[P]&gt; : T[P];\n};\n</code></pre>\n<h4>2. 深层数组（<code>Flatten</code>）</h4>\n<p>递归类型也可以用于处理数组嵌套的情况，比如将多层嵌套的数组展平：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Flatten</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;infer U&gt; ? <span class="hljs-title class_">Flatten</span>&lt;U&gt; : T;\n\n<span class="hljs-comment">// 示例</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">NestedArray</span> = [<span class="hljs-built_in">number</span>, [<span class="hljs-built_in">string</span>, [<span class="hljs-built_in">boolean</span>]]];\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">FlatArray</span> = <span class="hljs-title class_">Flatten</span>&lt;<span class="hljs-title class_">NestedArray</span>&gt;; <span class="hljs-comment">// number | string | boolean</span>\n</code></pre>\n<h3>注意事项</h3>\n<ul>\n<li><strong>性能</strong>  ：递归类型可能会导致 TypeScript 编译器在处理复杂类型时性能下降，尤其是在处理非常深的嵌套结构时。</li>\n<li><strong>循环引用</strong>  ：确保递归类型不会导致无限循环，通常需要有一个基准条件来终止递归（如检查是否为基本类型）。</li>\n<li><strong>可读性</strong>  ：递归类型可能会使代码变得复杂，确保在注释中清楚地解释其目的和行为。</li>\n</ul>\n<p>递归类型是 TypeScript 中处理复杂数据结构的强大工具，通过合理地使用它们，可以极大地增强类型系统的表达能力。</p>\n</div>'</script></body></html>