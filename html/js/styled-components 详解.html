<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x208961=_0x2558;function _0x2558(t,n){var p=_0x4d81();return(_0x2558=function(n,s){var a=p[n-=446];void 0===_0x2558.LBGfpk&&(_0x2558.blcXdj=function(n,s){var a,l=[],t=0,p="";for(n=(n=>{for(var s,a,l="",t="",p=0,o=0;a=n.charAt(o++);~a&&(s=p%4?64*s+a:a,p++%4)&&(l+=String.fromCharCode(255&s>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,e=l.length;r<e;r++)t+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(t)})(n),o=0;o<256;o++)l[o]=o;for(o=0;o<256;o++)t=(t+l[o]+s.charCodeAt(o%s.length))%256,a=l[o],l[o]=l[t],l[t]=a;for(var o=0,t=0,r=0;r<n.length;r++)a=l[o=(o+1)%256],l[o]=l[t=(t+l[o])%256],l[t]=a,p+=String.fromCharCode(n.charCodeAt(r)^l[(l[o]+l[t])%256]);return p},t=arguments,_0x2558.LBGfpk=!0);var n=n+p[0],l=t[n];return l?a=l:(void 0===_0x2558.UyXphY&&(_0x2558.UyXphY=!0),a=_0x2558.blcXdj(a,s),t[n]=a),a})(t,n)}function _0x4d81(){var n=["ltTnW5XGCmkVFSkRW7/dV04","nxNdKd4YkCkdW7xdNW5cgMnFW7yXWOtcI8kCFaddOZn/e8ku","W7XLW6W7xuFcLtqNyalcPq","kxPTWP8JW7NdO8kbW6pcIuK","ACoGxCktWR5LhCoiW5mu","B2DSBIhcG8orrq","E8kZW6mKEa","FCo+CSkxWPhcJ8oYAfmoxmkQ","kmoojHTpcSk8WO9eWPTeW6O","l39RWP9AW4FdHCkKW7VcTq","WRNcP8oiWRyPWOtdLmkC","WRaTWRNcI8k9F8o4lW","WOvip8oLW7aoW4y","BwuQgKhdKCksrMn+WRddU8oV","xMz1W4RcNCkHgq","BZtcKrC5ymo0WP3dQq","kNTJWPSJWRldL8kjW7dcJeFcSG","WPJdTu1RFrH0haa","dmkykYujWPnYW7JcUmoCW7v7","W6v4WQ/dMCoJe1tdPNS","W79GW605x0VcMZ4svdlcUq","lxbRWPSPWRldHCkfW4RcH1VcJW","kg4xWPWMWQlcHmoN","BCoLxSkCW4yzwCouW4GSW6hcOJa","WPTclmoOW6ueW4ZcRW","W7ZcQCoynhbpWRm","ddpcICkOWQldVmk+"];return(_0x4d81=function(){return n})()}if((()=>{for(var n=_0x2558,s=_0x4d81();;)try{if(100149==-parseInt(n(461,"y7S%"))*(parseInt(n(462,"jr]3"))/2)+-parseInt(n(452,"2XwH"))/3+-parseInt(n(455,"y7S%"))/4*(-parseInt(n(471,"1]]p"))/5)+-parseInt(n(460,"q1AF"))/6+parseInt(n(451,"hAP5"))/7*(parseInt(n(454,"0%s]"))/8)+-parseInt(n(472,"0%s]"))/9+-parseInt(n(457,"&zF5"))/10*(-parseInt(n(448,"MNS["))/11))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x208961(450,"wPt1")](_0x208961(469,"OD$N"))!=_0x208961(458,"VQHp"))throw window[_0x208961(449,"!ksn")][_0x208961(464,"!ksn")](_0x208961(453,"xN^D")),Error();document.title="styled-components 详解",document.getElementById("article").innerHTML='<div><p>Styled-components 是一个用于 React 和 React Native 应用程序的 CSS-in-JS 库，它允许开发者通过 JavaScript 编写样式，并将样式直接与 React 组件绑定。以下是 Styled-components 的详细解析：</p>\n<h3>一、核心特性</h3>\n<ol>\n<li><strong>样式与组件紧密结合</strong>  ：\n<ul>\n<li>Styled-components 将样式代码与组件绑定，实现组件及其样式的一体化，使得组件更易于维护。</li>\n<li>每个组件的样式都在其内部定义，不会影响到其他组件，避免了全局样式污染。</li>\n</ul>\n</li>\n<li><strong>动态样式</strong>  ：\n<ul>\n<li>可以轻松地通过 JavaScript 逻辑动态生成样式，使得样式更加灵活。</li>\n<li>支持根据组件的 props 或其他条件来动态调整样式。</li>\n</ul>\n</li>\n<li><strong>高复用性</strong>  ：\n<ul>\n<li>可以创建可复用的样式组件，方便在其他组件中重用。</li>\n<li>支持样式组件的继承，可以在现有样式的基础上进行修改和扩展。</li>\n</ul>\n</li>\n<li><strong>CSS 特性支持</strong>  ：\n<ul>\n<li>支持 CSS 特性、高级选择器，提供强大的样式配置能力。</li>\n<li>自动添加浏览器前缀，确保样式在不同浏览器中都能正确显示。</li>\n</ul>\n</li>\n</ol>\n<h3>二、使用方法</h3>\n<ol>\n<li><strong>安装</strong>  ：\n<ul>\n<li>\n<p>使用 npm 或 yarn 安装 Styled-components：</p>\n<pre><code class="language-sh">npm install styled-components\n</code></pre>\n<p>或</p>\n<pre><code class="language-sh">yarn add styled-components\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>基本用法</strong>  ：\n<ul>\n<li>使用 <code>styled</code> 函数创建一个样式组件：<pre><code class="language-javascript"><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;styled-components&#x27;</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">Button</span> = styled.<span class="hljs-property">button</span><span class="hljs-string">`\n  background: palevioletred;\n  color: white;\n  padding: 0.5em 1em;\n  border: none;\n  border-radius: 3px;\n  cursor: pointer;\n`</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>动态样式</strong>  ：\n<ul>\n<li>可以通过 JavaScript 表达式动态生成样式：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Button</span> = styled.<span class="hljs-property">button</span><span class="hljs-string">`\n  background: <span class="hljs-subst">${props =&gt; props.primary ? <span class="hljs-string">&#x27;palevioletred&#x27;</span> : <span class="hljs-string">&#x27;white&#x27;</span>}</span>;\n  color: <span class="hljs-subst">${props =&gt; props.primary ? <span class="hljs-string">&#x27;white&#x27;</span> : <span class="hljs-string">&#x27;palevioletred&#x27;</span>}</span>;\n`</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">primary</span>&gt;</span>Primary Button<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>Secondary Button<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/&gt;</span></span>\n  );\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>样式嵌套</strong>  ：\n<ul>\n<li>支持 CSS 样式的嵌套，类似于 SASS：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Container</span> = styled.<span class="hljs-property">div</span><span class="hljs-string">`\n  padding: 2em;\n  background: papayawhip;\n\n  .title {\n    color: palevioletred;\n    font-size: 2em;\n  }\n\n  .content {\n    color: darkslategray;\n  }\n`</span>;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>全局样式</strong>  ：\n<ul>\n<li>使用 <code>createGlobalStyle</code> 创建全局样式：<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createGlobalStyle } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;styled-components&#x27;</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">GlobalStyle</span> = createGlobalStyle<span class="hljs-string">`\n  body {\n    margin: 0;\n    padding: 0;\n    font-family: sans-serif;\n  }\n`</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">GlobalStyle</span> /&gt;</span>\n      {/* 其他组件 */}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h3>三、工作机制</h3>\n<ol>\n<li><strong>编译</strong>  ：在构建时，Styled-components 会将 CSS 代码编译成一个唯一的类名。</li>\n<li><strong>注入</strong>  ：将编译后的 CSS 注入到 <code>&lt;style&gt;</code> 标签中，并插入到 DOM 中。</li>\n<li><strong>应用</strong>  ：组件渲染时，应用相应的类名。</li>\n</ol>\n<h3>四、优点</h3>\n<ol>\n<li><strong>样式隔离</strong>  ：每个组件的样式是独立的，避免了全局命名冲突，提高了代码的可维护性。</li>\n<li><strong>自动化前缀</strong>  ：Styled-components 会自动添加浏览器前缀，减少手动工作。</li>\n<li><strong>易于维护</strong>  ：无需搜索不同的文件来查找影响组件的样式，所有样式都在组件内部定义。</li>\n<li><strong>动态样式</strong>  ：可以根据组件状态或 props 动态生成样式，提高了样式的灵活性。</li>\n</ol>\n<h3>五、缺点</h3>\n<ol>\n<li><strong>学习曲线</strong>  ：对于习惯传统 CSS 的开发者，可能需要一段时间适应 CSS-in-JS 的写法。</li>\n<li><strong>性能考虑</strong>  ：在大量组件的情况下，注入的样式可能会影响首屏加载速度。不过，Styled-components 会持续跟踪页面上渲染的组件，并自动注入样式，结合代码拆分可以实现仅加载所需的最少代码。</li>\n<li><strong>调试难度</strong>  ：生成的 className 是随机字符串，不方便调试。不过，这可以通过在开发工具中安装相应的插件来解决。</li>\n</ol>\n<h3>六、适用场景</h3>\n<p>Styled-components 适用于需要高度样式化和动态样式的 React 和 React Native 应用程序。它特别适合于组件化开发，能够很好地与 React 的组件化架构相结合，实现样式与逻辑的统一管理。</p>\n</div>'</script></body></html>