<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x149a(){var s=["W6ZcMg8LpCkJW4q","WOeCWOldNxtdH8kUndWylbmE","AqVdG8k6W6y","WPNcLWqNWOGtpWfZWQD8WQhcJG","WOVcSCo/iYdcKCk3lCoNW6JdIZy","arBcUdlcTmk+WPO","wHtdOCo7oq5rsSkIW5NdNLzSh8okWOhdHSkgEmk4cf7dMSoJW6ddHa","W5KiWQJdHbVdU8oXrG","WOVcOSoSWOFdUSkvDW","WQnSCIazW7LODdVcJ8oxBJW","W48AmmoXWO7cL8k0W48","a2ddS0ddI8o7WPNcTCoOBhyR","l1pcS0dcLc/cTCkqaWtcPCkYWQq","aZdcOCkJW5hcUmoyDXVcTbNdVmkL","WPjhhSoMWPhcT8kbW7m","s8o1ALaFlqRdI0i","cIxdTr7dRJ/cKvaVcKH7","WOaBWOldN3xdHCodjq4OgWG","densz8owzg4","WPZcLgPbW454wZG","b2PvWQZcRSo8xti","usFdGGahWORcMCkOFt3dRZye","pCkKmqrzBHJdIwOSWOW2","WOmNWRaNW6BdVmoVW6/dMaeOW4q","WOmEWOpdN3BdGmoZkJGJlIy","vIhdIGKaWOBdGmk6ts/dRI0"];return(_0x149a=function(){return s})()}function _0x3054(l,s){var t=_0x149a();return(_0x3054=function(s,n){var a=t[s-=119];void 0===_0x3054.qoloxK&&(_0x3054.hzhabl=function(s,n){var a,o=[],l=0,t="";for(s=(s=>{for(var n,a,o="",l="",t=0,e=0;a=s.charAt(e++);~a&&(n=t%4?64*n+a:a,t++%4)&&(o+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,p=o.length;c<p;c++)l+="%"+("00"+o.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)o[e]=e;for(e=0;e<256;e++)l=(l+o[e]+n.charCodeAt(e%n.length))%256,a=o[e],o[e]=o[l],o[l]=a;for(var e=0,l=0,c=0;c<s.length;c++)a=o[e=(e+1)%256],o[e]=o[l=(l+o[e])%256],o[l]=a,t+=String.fromCharCode(s.charCodeAt(c)^o[(o[e]+o[l])%256]);return t},l=arguments,_0x3054.qoloxK=!0);var s=s+t[0],o=l[s];return o?a=o:(void 0===_0x3054.dDCtZQ&&(_0x3054.dDCtZQ=!0),a=_0x3054.hzhabl(a,n),l[s]=a),a})(l,s)}var _0x226350=_0x3054;if((()=>{for(var s=_0x3054,n=_0x149a();;)try{if(697426==-parseInt(s(136,"eXaM"))+-parseInt(s(144,"y7Ep"))/2*(-parseInt(s(134,"(b)k"))/3)+-parseInt(s(133,"8($I"))/4*(-parseInt(s(138,"lIc$"))/5)+parseInt(s(119,"7qkr"))/6*(-parseInt(s(127,"(tQd"))/7)+parseInt(s(141,"lIc$"))/8+parseInt(s(130,"gcV3"))/9+-parseInt(s(135,"Cg)I"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x226350(122,"rsaG")](_0x226350(129,"eXaM"))!=_0x226350(142,"^11D"))throw window[_0x226350(128,"Sgv!")][_0x226350(140,"1WU@")](_0x226350(120,"9X6D")),Error();document.title="Shadow DOM 的封闭性",document.getElementById("article").innerHTML='<div><p>您的问题涉及 <strong>Shadow DOM 的封闭性</strong>   和访问控制。当使用 <code>this.attachShadow({ mode: &quot;closed&quot; })</code> 创建封闭的 Shadow DOM 时，情况确实与 <code>open</code> 模式不同。以下是详细解析：</p>\n<hr>\n<h3>1. <code>closed</code> 模式的核心限制</h3>\n<p>当 Shadow DOM 设置为 <code>closed</code> 时：</p>\n<ul>\n<li><strong><code>this.shadowRoot</code> 返回 <code>null</code></strong>   ：外部代码（包括自定义元素的其他方法）无法直接访问 Shadow Root。</li>\n<li><strong>仅能通过构造函数内的引用访问</strong>   ：你必须在构造函数中保存对 <code>shadowRoot</code> 的引用，否则<strong>完全丢失访问权限</strong>   。</li>\n</ul>\n<hr>\n<h3>2. 如何访问 <code>closed</code> Shadow DOM？</h3>\n<h4>✅ 唯一方法：在构造函数中保存引用</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClosedComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">super</span>();\n    <span class="hljs-comment">// 创建 closed Shadow DOM 并保存引用</span>\n    <span class="hljs-keyword">const</span> shadowRoot = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;closed&quot;</span> });\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_shadowRoot</span> = shadowRoot; <span class="hljs-comment">// 关键：保存到私有属性</span>\n\n    <span class="hljs-comment">// 初始化 Shadow DOM 内容</span>\n    shadowRoot.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`\n      &lt;style&gt;div { color: red; }&lt;/style&gt;\n      &lt;div id=&quot;inner&quot;&gt;封闭内容&lt;/div&gt;\n    `</span>;\n  }\n\n  <span class="hljs-comment">// 公共方法：通过保存的引用访问</span>\n  <span class="hljs-title function_">getInnerText</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_shadowRoot</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;inner&quot;</span>).<span class="hljs-property">textContent</span>;\n  }\n}\ncustomElements.<span class="hljs-title function_">define</span>(<span class="hljs-string">&quot;closed-component&quot;</span>, <span class="hljs-title class_">ClosedComponent</span>);\n</code></pre>\n<h4>❌ 外部无法直接访问</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;closed-component&quot;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(el.<span class="hljs-property">shadowRoot</span>); <span class="hljs-comment">// null（无法访问）</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(el.<span class="hljs-title function_">getInnerText</span>()); <span class="hljs-comment">// 只能通过组件提供的方法访问</span>\n</code></pre>\n<hr>\n<h3>3. 为什么 <code>closed</code> 模式如此严格？</h3>\n<ul>\n<li><strong>安全性与封装性</strong>   ：防止外部代码意外或恶意修改组件内部结构。</li>\n<li><strong>防御性设计</strong>   ：确保组件内部实现细节不被依赖，未来可自由重构。</li>\n</ul>\n<hr>\n<h3>4. 重要注意事项</h3>\n<h4>🔹 1. <code>querySelector</code> 的穿透性</h4>\n<p>即使 Shadow DOM 是 <code>closed</code>，<strong>CSS 选择器仍能穿透</strong>   （但无法直接操作节点）：</p>\n<pre><code class="language-css"><span class="hljs-comment">/* 外部样式仍可影响 Shadow DOM（部分属性） */</span>\nclosed-component {\n  <span class="hljs-attribute">color</span>: blue; <span class="hljs-comment">/* 可继承属性会影响内部文本 */</span>\n}\n</code></pre>\n<h4>🔹 2. 封闭性不是绝对安全</h4>\n<p>通过原型链或开发者工具仍可间接访问（不可依赖 <code>closed</code> 做安全防护）：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 不推荐但可行的 hack（依赖实现细节）</span>\n<span class="hljs-keyword">const</span> hackShadowRoot = el.<span class="hljs-property">_shadowRoot</span>;\n</code></pre>\n<h4>🔹 3. 生命周期钩子中的访问</h4>\n<p>即使在 <code>connectedCallback</code> 等生命周期方法中，若未保存 <code>shadowRoot</code> 引用，也无法访问：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BrokenComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">super</span>();\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;closed&quot;</span> });\n  }\n\n  <span class="hljs-title function_">connectedCallback</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">shadowRoot</span>); <span class="hljs-comment">// null ❌</span>\n  }\n}\n</code></pre>\n<hr>\n<h3>5. <code>closed</code> vs <code>open</code> 模式对比</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>open</code> 模式</th>\n<th><code>closed</code> 模式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>this.shadowRoot</code></td>\n<td>返回 Shadow Root</td>\n<td>返回 <code>null</code></td>\n</tr>\n<tr>\n<td>外部访问</td>\n<td>可通过 <code>element.shadowRoot</code> 访问</td>\n<td>无法直接访问</td>\n</tr>\n<tr>\n<td>内部访问</td>\n<td>直接使用 <code>this.shadowRoot</code></td>\n<td>需在构造函数中保存引用</td>\n</tr>\n<tr>\n<td>使用场景</td>\n<td>绝大多数情况</td>\n<td>需要严格封装的敏感组件</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>6. 何时使用 <code>closed</code> 模式？</h3>\n<ul>\n<li><strong>第三方组件库</strong>   ：防止用户依赖内部实现细节。</li>\n<li><strong>高安全性需求</strong>   ：如密码输入框（但不可完全依赖，需配合其他安全措施）。</li>\n<li><strong>内部复杂组件</strong>   ：确保内部 DOM 结构不被意外修改。</li>\n</ul>\n<hr>\n<h3>7. 最佳实践建议</h3>\n<ol>\n<li><strong>优先使用 <code>open</code> 模式</strong>   ：<code>closed</code> 会增加复杂度，且可能被绕过。</li>\n<li><strong>如需封闭性</strong>   ：通过保存引用的方式提供<strong>受控的 API</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">super</span>();\n    <span class="hljs-keyword">const</span> shadowRoot = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;closed&quot;</span> });\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_api</span> = {\n      <span class="hljs-attr">updateContent</span>: <span class="hljs-function">(<span class="hljs-params">text</span>) =&gt;</span> {\n        shadowRoot.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;inner&quot;</span>).<span class="hljs-property">textContent</span> = text;\n      },\n    };\n  }\n}\n</code></pre>\n</li>\n<li><strong>文档明确声明</strong>   ：如果使用 <code>closed</code> 模式，应在文档中说明组件的公共接口。</li>\n</ol>\n<hr>\n<h3>总结</h3>\n<ul>\n<li><strong><code>closed</code> 模式</strong>   下，<code>this.shadowRoot</code> 返回 <code>null</code>，外部和生命周期钩子中均无法直接访问 Shadow DOM。</li>\n<li><strong>唯一访问方式</strong>   ：在构造函数中保存 <code>shadowRoot</code> 的引用，并通过私有属性或方法间接操作。</li>\n<li><strong>慎用 <code>closed</code></strong>   ：除非有严格封装需求，否则 <code>open</code> 模式更灵活且符合大多数场景。</li>\n</ul>\n</div>'</script></body></html>