<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5e18(){var s=["wCkpWP0KpqvfbtRcGmkOj043","afOUbwzLsgm","WP1KsSo/WOBdG8k4BvC","lCoviqKBW7JcRvdcNIewsmoY","WPJcQ8kGWQDYWQZcKmknWRj2WQ/cPa","tmozW7NcNmkWW7dcIW","W4hdRSoJW6eXWQddRCoVWO91WQRcOYSgWOT7W5JcTe5OsmktqCknnmoy","W5pdOSo4bSo0W5Ly","WQRcLJZdJW/dOb5ead7dRbq","WOJdPmkLW6pcS8kjW4y","W6GjluKNW7zqmCo1pmoihCoH","omksW5upWRDgW7pcMq","WPVcRmoBW5WTW7dcTCkn","WPxcQmojW6iyzSknW5G","nrrXzSoChfZdJmkxWQxcHSoXfCkC","Db4MWQSIW5dcGhTtW5r4W7i","CSkkDfPyWQddT3i","iapdNqy1W5xdPCkKW4OXW4hcSthcUG","mbmZW6OczSoHpLP7W6XX","W4dcIgyVW7NdJw3dQYxcVrBdHJa","gfCrW5BdJW","W4xdJCkVhGWLya","WQdcOHFdTefCna","oCksWQH3W5K8WOhcUXFdUSoMW4VcPa","fsFcS2/cJJZcL8klW4q","mbb3WR9Xm8oheq","i8k4W7dcL8kGW6lcLa","WPpcT27dGh5+W74iW5K","mbS1W60kzmkeqw9MW6bIWPJdHa","WPdcSCk9uSkKW61Zd8ktWRpcNa","nrCXnSkSsbRcMq","W7XrW7aQlxJcJComWPO2WR8"];return(_0x5e18=function(){return s})()}var _0x17df79=_0x3ee2;function _0x3ee2(p,s){var e=_0x5e18();return(_0x3ee2=function(s,n){var a=e[s-=193];void 0===_0x3ee2.rTfwcB&&(_0x3ee2.ogrpAm=function(s,n){var a,l=[],p=0,e="";for(s=(s=>{for(var n,a,l="",p="",e=0,c=0;a=s.charAt(c++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,i=l.length;t<i;t++)p+="%"+("00"+l.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(p)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)p=(p+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[p],l[p]=a;for(var c=0,p=0,t=0;t<s.length;t++)a=l[c=(c+1)%256],l[c]=l[p=(p+l[c])%256],l[p]=a,e+=String.fromCharCode(s.charCodeAt(t)^l[(l[c]+l[p])%256]);return e},p=arguments,_0x3ee2.rTfwcB=!0);var s=s+e[0],l=p[s];return l?a=l:(void 0===_0x3ee2.HOoKsq&&(_0x3ee2.HOoKsq=!0),a=_0x3ee2.ogrpAm(a,n),p[s]=a),a})(p,s)}if((()=>{for(var s=_0x3ee2,n=_0x5e18();;)try{if(721732==+parseInt(s(223,"VMIH"))*(-parseInt(s(199,"B8qZ"))/2)+parseInt(s(219,"@A^0"))/3*(parseInt(s(202,"]WO3"))/4)+-parseInt(s(217,"alzX"))/5+parseInt(s(212,"@A^0"))/6*(-parseInt(s(218,"P]#x"))/7)+-parseInt(s(220,"s&ZJ"))/8*(parseInt(s(211,"By1U"))/9)+parseInt(s(195,"3*%b"))/10*(-parseInt(s(213,"mpQH"))/11)+-parseInt(s(222,"@A^0"))/12*(-parseInt(s(206,"z*6("))/13))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x17df79(203,"F&kH")](_0x17df79(196,"o2*#"))!=_0x17df79(214,"TogN"))throw window[_0x17df79(210,"8sZq")][_0x17df79(201,"VMIH")](_0x17df79(200,"z*6(")),Error();document.title="typescript 类型守卫和类型断言",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，类型守卫和类型断言是两种用于处理类型不确定性的重要工具。它们帮助开发者在编译时和运行时确保变量类型的正确性。以下是它们的详细解释和使用方法：</p>\n<h3>类型守卫（Type Guards）</h3>\n<p>类型守卫是一种在运行时检查变量类型的技术。它允许你在条件语句中缩小变量的类型范围，以便 TypeScript 能够推断出更具体的类型。</p>\n<h4>常见类型守卫方法</h4>\n<ol>\n<li><strong><code>typeof</code> 类型守卫</strong>  ：\n<ul>\n<li>用于检查基本类型，如 <code>string</code>、<code>number</code>、<code>boolean</code>、<code>symbol</code>、<code>undefined</code>、<code>object</code> 和 <code>function</code>。</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) {\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>) {\n    <span class="hljs-comment">// 在这里，TypeScript 知道 x 是 string 类型</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x.<span class="hljs-title function_">toUpperCase</span>());\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 在这里，TypeScript 知道 x 是 number 类型</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>));\n  }\n}\n</code></pre>\n</li>\n<li><strong><code>instanceof</code> 类型守卫</strong>  ：\n<ul>\n<li>用于检查对象是否是某个类的实例。</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> {\n  <span class="hljs-title function_">bark</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Woof!&#x27;</span>);\n  }\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"><span class="hljs-attr">animal</span>: <span class="hljs-title class_">Dog</span> | <span class="hljs-built_in">string</span></span>) {\n  <span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Dog</span>) {\n    animal.<span class="hljs-title function_">bark</span>(); <span class="hljs-comment">// 在这里，TypeScript 知道 animal 是 Dog 类型</span>\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(animal.<span class="hljs-title function_">toUpperCase</span>()); <span class="hljs-comment">// 在这里，TypeScript 知道 animal 是 string 类型</span>\n  }\n}\n</code></pre>\n</li>\n<li><strong>自定义类型守卫</strong>  ：\n<ul>\n<li>通过定义返回类型谓词的函数来实现。</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fish</span> {\n  <span class="hljs-attr">swim</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;\n}\n\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Bird</span> {\n  <span class="hljs-attr">fly</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">isFish</span>(<span class="hljs-params"><span class="hljs-attr">pet</span>: <span class="hljs-title class_">Fish</span> | <span class="hljs-title class_">Bird</span></span>): pet is <span class="hljs-title class_">Fish</span> {\n  <span class="hljs-keyword">return</span> (pet <span class="hljs-keyword">as</span> <span class="hljs-title class_">Fish</span>).<span class="hljs-property">swim</span> !== <span class="hljs-literal">undefined</span>;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"><span class="hljs-attr">pet</span>: <span class="hljs-title class_">Fish</span> | <span class="hljs-title class_">Bird</span></span>) {\n  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isFish</span>(pet)) {\n    pet.<span class="hljs-title function_">swim</span>(); <span class="hljs-comment">// 在这里，TypeScript 知道 pet 是 Fish 类型</span>\n  } <span class="hljs-keyword">else</span> {\n    pet.<span class="hljs-title function_">fly</span>(); <span class="hljs-comment">// 在这里，TypeScript 知道 pet 是 Bird 类型</span>\n  }\n}\n</code></pre>\n</li>\n</ol>\n<h3>类型断言（Type Assertions）</h3>\n<p>类型断言是一种告诉 TypeScript 编译器“我知道这个变量是什么类型”的方式。它类似于其他语言中的类型转换，但不会在运行时进行任何检查。</p>\n<h4>语法</h4>\n<ul>\n<li><strong>“尖括号”语法</strong>  ：<code>&lt;Type&gt;value</code>（在 JSX 中不推荐使用）</li>\n<li><strong><code>as</code> 语法</strong>  ：<code>value as Type</code>（推荐使用）</li>\n</ul>\n<h4>示例</h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getLength</span>(<span class="hljs-params"><span class="hljs-attr">input</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) {\n  <span class="hljs-keyword">const</span> str = input <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 告诉 TypeScript 我确信 input 是 string 类型</span>\n  <span class="hljs-keyword">return</span> str.<span class="hljs-property">length</span>; <span class="hljs-comment">// 如果 input 实际上是 number 类型，这里会在运行时出错</span>\n}\n</code></pre>\n<h3>区别与选择</h3>\n<ul>\n<li><strong>类型守卫</strong>  ：\n<ul>\n<li>运行时检查，确保类型安全。</li>\n<li>适用于需要根据不同类型执行不同逻辑的场景。</li>\n<li>编译器能够智能地缩小类型范围。</li>\n</ul>\n</li>\n<li><strong>类型断言</strong>  ：\n<ul>\n<li>编译时告知，无运行时检查。</li>\n<li>适用于开发者确信变量类型的情况，但需要谨慎使用以避免运行时错误。</li>\n<li>不会改变运行时的行为，只是告诉编译器如何看待变量。</li>\n</ul>\n</li>\n</ul>\n<h3>总结</h3>\n<ul>\n<li>使用类型守卫来在运行时安全地检查变量类型，并根据类型执行不同逻辑。</li>\n<li>使用类型断言来告诉编译器你确信变量的类型，但要确保在运行时变量确实是你断言的类型，以避免潜在的运行时错误。</li>\n<li>在可能的情况下，优先使用类型守卫，因为它提供了更好的类型安全和运行时检查。</li>\n</ul>\n</div>'</script></body></html>