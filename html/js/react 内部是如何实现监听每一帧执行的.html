<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x23e8(t,n){var l=_0xed6b();return(_0x23e8=function(n,s){var e=l[n-=457];void 0===_0x23e8.UqiYsp&&(_0x23e8.sOROts=function(n,s){var e,a=[],t=0,l="";for(n=(n=>{for(var s,e,a="",t="",l=0,o=0;e=n.charAt(o++);~e&&(s=l%4?64*s+e:e,l++%4)&&(a+=String.fromCharCode(255&s>>(-2*l&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var r=0,c=a.length;r<c;r++)t+="%"+("00"+a.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(t)})(n),o=0;o<256;o++)a[o]=o;for(o=0;o<256;o++)t=(t+a[o]+s.charCodeAt(o%s.length))%256,e=a[o],a[o]=a[t],a[t]=e;for(var o=0,t=0,r=0;r<n.length;r++)e=a[o=(o+1)%256],a[o]=a[t=(t+a[o])%256],a[t]=e,l+=String.fromCharCode(n.charCodeAt(r)^a[(a[o]+a[t])%256]);return l},t=arguments,_0x23e8.UqiYsp=!0);var n=n+l[0],a=t[n];return a?e=a:(void 0===_0x23e8.BCpndx&&(_0x23e8.BCpndx=!0),e=_0x23e8.sOROts(e,s),t[n]=e),e})(t,n)}var _0xb11e9=_0x23e8;function _0xed6b(){var n=["WO7dQw0HW4OTWOm","amkyi8ktc0zbFSk/hG","W6CpWOZdMColWRZcVmkUESoOW6tdKSoN","E8ofESoIlfJcG8kcWP8cWRHHWRO","c8kuWQ9eWRpcHuaqselcVZSe","hCoRwbRdR2ubW6BcP0JcIJS5","W5OtW5tdTCocWPrxW5fuW6ihyCkI","iv/dQCkeW70IAa","CCoeFmkqvGZdMSkoWOa","uadcVmo7W6xdQSodW48eWPXQBJu","AmoBFCoKW57cGGRcISogcCoaDCo4","W7pdIHzlvY7cUG","r8kpW7SjfCknWRnGsW","WQNdR3mTj1hcU1JcId8","WQ9/r0zWumo8W5VdTa","h8ooW7ldSmk9zLVcUa","u1DYW4u/WPvKWPOQWOXHjtO","W748aCkjgM7cHSkPWPdcQCkAWQCQ","D8odcsZcRszuWQ/cGG","vSorWQjEW688WOW","B0euAmklWPKfW5VcJq","WRpcMLmEbh/dQWpdOdvvDcy","cCoeA8odW64NsLbyzWNdOmkeW43dU8oxW7dcISo7WPhcUCoDmCkVWPpdKG","AWhdKaX7mSokCHb1","kCoFl8o9WPRdRNvmWOS1","W4NcUgLvaW"];return(_0xed6b=function(){return n})()}if((()=>{for(var n=_0x23e8,s=_0xed6b();;)try{if(698213==-parseInt(n(462,"%8$3"))*(parseInt(n(466,"U&^#"))/2)+parseInt(n(465,"OM*N"))/3+-parseInt(n(457,"7zdL"))/4*(-parseInt(n(467,"8]2a"))/5)+parseInt(n(464,"7&n3"))/6+-parseInt(n(477,"6d]e"))/7+-parseInt(n(478,"S97L"))/8+-parseInt(n(475,"[fcM"))/9*(parseInt(n(471,"tSSJ"))/10))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0xb11e9(474,"WN0B")](_0xb11e9(460,"HcJ["))!=_0xb11e9(473,"WXqf"))throw window[_0xb11e9(463,"D$2F")][_0xb11e9(459,"lq85")](_0xb11e9(470,"ybpj")),Error();document.title="react 内部是如何实现监听每一帧执行的",document.getElementById("article").innerHTML='<div><p>React 内部通过 <strong>浏览器事件循环</strong>   和 <strong>调度策略</strong>   实现“监听每一帧执行”，核心目标是 <strong>在每一帧的空闲时间执行任务</strong>  ，避免阻塞渲染（60fps 的关键）。以下是具体实现原理：</p>\n<hr>\n<h3>一、核心机制：基于 <code>requestIdleCallback</code> 的模拟</h3>\n<p>浏览器原生的 <code>requestIdleCallback</code> 可以在空闲时间执行任务，但 React 没有直接使用它，而是 <strong>用 <code>MessageChannel</code> + 时间切片模拟更可控的调度</strong>  。原因：</p>\n<ol>\n<li><strong>兼容性问题</strong>  ：<code>requestIdleCallback</code> 支持度不足（如 Safari 早期版本不支持）。</li>\n<li><strong>优先级控制</strong>  ：React 需要更细粒度的任务优先级（如 Lane 模型）。</li>\n<li><strong>时间切片</strong>  ：默认按 <strong>5ms</strong>   分块执行任务，避免长时间占用主线程。</li>\n</ol>\n<hr>\n<h3>二、具体实现步骤</h3>\n<h4>1. <strong>调度入口：<code>scheduleCallback</code></strong></h4>\n<p>当 React 触发更新（如 <code>setState</code>）时，会通过调度器（Scheduler）安排任务：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 将任务加入调度队列，指定优先级</span>\n<span class="hljs-title function_">scheduleCallback</span>(priorityLevel, taskCallback);\n</code></pre>\n<h4>2. <strong>任务执行控制：<code>performWorkUntilDeadline</code></strong></h4>\n<p>React 通过以下函数控制每帧的任务执行：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">performWorkUntilDeadline</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">if</span> (scheduledHostCallback !== <span class="hljs-literal">null</span>) {\n    <span class="hljs-keyword">const</span> currentTime = <span class="hljs-title function_">getCurrentTime</span>();\n    <span class="hljs-comment">// 模拟 deadline 对象，检查剩余时间</span>\n    <span class="hljs-keyword">const</span> deadline = {\n      <span class="hljs-attr">timeRemaining</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, <span class="hljs-number">50</span> - (<span class="hljs-title function_">getCurrentTime</span>() - currentTime)), <span class="hljs-comment">// 默认 5ms 切片</span>\n      <span class="hljs-attr">didTimeout</span>: <span class="hljs-literal">false</span>,\n    };\n\n    <span class="hljs-comment">// 执行任务，直到时间用尽</span>\n    <span class="hljs-keyword">const</span> hasMoreWork = <span class="hljs-title function_">scheduledHostCallback</span>(<span class="hljs-literal">true</span>, deadline);\n    <span class="hljs-keyword">if</span> (hasMoreWork) {\n      <span class="hljs-comment">// 如果任务未完成，安排到下一帧继续</span>\n      <span class="hljs-title function_">schedulePerformWorkUntilDeadline</span>();\n    }\n  }\n};\n</code></pre>\n<h4>3. <strong>帧监听：<code>MessageChannel</code> 宏任务调度</strong></h4>\n<p>React 使用 <code>MessageChannel</code>（或 <code>setTimeout</code>）在每一帧结束后触发任务检查：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>();\nchannel.<span class="hljs-property">port1</span>.<span class="hljs-property">onmessage</span> = performWorkUntilDeadline;\n\n<span class="hljs-comment">// 安排任务到下一帧</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">schedulePerformWorkUntilDeadline</span>(<span class="hljs-params"></span>) {\n  channel.<span class="hljs-property">port2</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 触发宏任务</span>\n}\n</code></pre>\n<ul>\n<li><strong>为什么用 <code>MessageChannel</code>？</strong><br>\n比 <code>setTimeout</code> 更高效（无 4ms 延迟限制），且能精准嵌入浏览器事件循环。</li>\n</ul>\n<h4>4. <strong>时间切片（Time Slicing）</strong></h4>\n<p>在任务执行过程中，React 会检查每帧剩余时间：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoop</span>(<span class="hljs-params">hasTimeRemaining, deadline</span>) {\n  <span class="hljs-keyword">while</span> (currentTask !== <span class="hljs-literal">null</span> &amp;&amp; deadline.<span class="hljs-title function_">timeRemaining</span>() &gt; <span class="hljs-number">0</span>) {\n    <span class="hljs-title function_">performUnitOfWork</span>(currentTask); <span class="hljs-comment">// 执行一个任务单元</span>\n  }\n  <span class="hljs-keyword">return</span> currentTask !== <span class="hljs-literal">null</span>; <span class="hljs-comment">// 返回是否还有剩余任务</span>\n}\n</code></pre>\n<ul>\n<li>如果 <code>deadline.timeRemaining() &lt;= 0</code>，暂停任务并等待下一帧。</li>\n</ul>\n<hr>\n<h3>三、与浏览器渲染帧的协作流程</h3>\n<pre><code class="language-mermaid">sequenceDiagram\n  participant Browser\n  participant React\n\n  Browser-&gt;&gt;Browser: 开始一帧（16.6ms）\n  Browser-&gt;&gt;Browser: 执行 JS/渲染/布局/绘制\n  React-&gt;&gt;React: 执行 React 任务（5ms 切片）\n  alt 时间用尽\n    React-&gt;&gt;Browser: 暂停任务，归还主线程\n  else 任务完成\n    React-&gt;&gt;React: 提交更新到 DOM\n  end\n  Browser-&gt;&gt;Browser: 帧结束\n  React-&gt;&gt;React: schedulePerformWorkUntilDeadline() 安排下一帧任务\n</code></pre>\n<hr>\n<h3>四、关键设计点</h3>\n<ol>\n<li><strong>避免直接监听 <code>requestAnimationFrame</code></strong><br>\nReact 不直接依赖 <code>rAF</code>，因为：</li>\n</ol>\n<ul>\n<li><code>rAF</code> 在渲染前触发，可能阻塞渲染。</li>\n<li>需要更灵活的任务调度（如后台任务不需要紧跟渲染）。</li>\n</ul>\n<ol start="2">\n<li><strong>优先级插队机制</strong><br>\n高优先级任务（如用户输入）会中断当前低优先级任务，通过 <code>unstable_continueExecution</code> 恢复。</li>\n<li><strong>自动批处理（Batching）</strong><br>\n同一帧内的多个更新会被合并，减少不必要的渲染。</li>\n</ol>\n<hr>\n<h3>五、代码验证方法</h3>\n<p>在 React 源码中搜索以下关键函数：</p>\n<ol>\n<li><strong>调度入口</strong>  ：<code>scheduleCallback</code>（<code>Scheduler.js</code>）</li>\n<li><strong>任务循环</strong>  ：<code>performWorkUntilDeadline</code>、<code>workLoop</code></li>\n<li><strong>帧调度</strong>  ：<code>schedulePerformWorkUntilDeadline</code>、<code>requestHostCallback</code></li>\n</ol>\n<hr>\n<h3>六、总结</h3>\n<table>\n<thead>\n<tr>\n<th><strong>机制</strong></th>\n<th><strong>实现方式</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>帧监听</strong></td>\n<td>通过 <code>MessageChannel</code> 宏任务模拟，在每帧结束后调度任务。</td>\n</tr>\n<tr>\n<td><strong>时间切片</strong></td>\n<td>默认 5ms 任务分块，<code>deadline.timeRemaining()</code> 检查剩余时间。</td>\n</tr>\n<tr>\n<td><strong>优先级控制</strong></td>\n<td>Lane 模型区分任务优先级，高优先级可中断低优先级。</td>\n</tr>\n<tr>\n<td><strong>与渲染协作</strong></td>\n<td>任务执行后归还主线程，确保浏览器流畅渲染（60fps）。</td>\n</tr>\n</tbody>\n</table>\n<p>React 通过这套设计，实现了 <strong>高性能的任务调度</strong>  ，既保证 UI 响应速度，又避免阻塞渲染。</p>\n</div>'</script></body></html>