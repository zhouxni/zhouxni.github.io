<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2216(t,r){var i=_0x1519();return(_0x2216=function(r,e){var o=i[r-=438];void 0===_0x2216.cVqCDI&&(_0x2216.oEuDrT=function(r,e){var o,n=[],t=0,i="";for(r=(r=>{for(var e,o,n="",t="",i=0,c=0;o=r.charAt(c++);~o&&(e=i%4?64*e+o:o,i++%4)&&(n+=String.fromCharCode(255&e>>(-2*i&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var d=0,a=n.length;d<a;d++)t+="%"+("00"+n.charCodeAt(d).toString(16)).slice(-2);return decodeURIComponent(t)})(r),c=0;c<256;c++)n[c]=c;for(c=0;c<256;c++)t=(t+n[c]+e.charCodeAt(c%e.length))%256,o=n[c],n[c]=n[t],n[t]=o;for(var c=0,t=0,d=0;d<r.length;d++)o=n[c=(c+1)%256],n[c]=n[t=(t+n[c])%256],n[t]=o,i+=String.fromCharCode(r.charCodeAt(d)^n[(n[c]+n[t])%256]);return i},t=arguments,_0x2216.cVqCDI=!0);var r=r+i[0],n=t[r];return n?o=n:(void 0===_0x2216.VHkAcv&&(_0x2216.VHkAcv=!0),o=_0x2216.oEuDrT(o,e),t[r]=o),o})(t,r)}var _0x211cbd=_0x2216;function _0x1519(){var r=["W4ldI8kUW6JdOmkCWPm5WRTTWQauW6i","vCo8B8kQb8kcomo0","WQuUW6xcGmk3EcW","W7xcOei4xvC2","ECoQW7KUDSokWRTvW7eYWQPVWRi","fYxcGCkqWOb9WOpcKX0rxLNdHG","bqqzx8oZWO4dBrJdKtFdOq","WPy6WOZdLXHaW7SZrSkAD0S","W78czCkIWQZdVdldGduxWR8FBWfJW5dcHSkfWRqwCG4hdCkwhG","yCoul8oNWOnmifFcTc8TWO8","BaGWbetcSH9FWRddP8o+WQG","WRurdCk6axRdJs49wW1+WOG","W6SmWR/cNmk2seFcNmoIaJrHWQq","W6aSW6dcPmk3As0","bhLldG7dJaencY5KaW","gCkdDmkXW4mphedcIa","brNdGvRdK8oaW7xdRtXbz8og","a3XodqRdJN0koHn9aSo4","DmokWRe3oa","WOqzxmoyWOuUDCo0lCoLW4hcM10","p8kFgSoYD8okzH3cKxi0pmoA","WR0tW4PSWRXAgW"];return(_0x1519=function(){return r})()}if((()=>{for(var r=_0x2216,e=_0x1519();;)try{if(306647==-parseInt(r(448,"s138"))+parseInt(r(441,"HTw^"))/2+parseInt(r(443,"][Wh"))/3+parseInt(r(454,"!1]E"))/4+-parseInt(r(445,"^AqY"))/5+-parseInt(r(451,"s138"))/6*(-parseInt(r(455,"zmzb"))/7)+-parseInt(r(438,"2e@y"))/8)break;e.push(e.shift())}catch(r){e.push(e.shift())}})(),localStorage[_0x211cbd(459,"r(jv")](_0x211cbd(449,"][Wh"))!=_0x211cbd(452,"8C17"))throw window[_0x211cbd(457,"8N3x")][_0x211cbd(458,"QEKR")](_0x211cbd(442,"dJ6m")),Error();document.title="react Fiber 优先级调度",document.getElementById("article").innerHTML="<div><p>Fiber 节点通过引入任务优先级的概念，结合协调算法和增量渲染机制，实现了高效的优先级调度。以下是 Fiber 节点实现优先级调度的关键步骤和原理：</p>\n<h3>1. <strong>Fiber 数据结构</strong></h3>\n<p>每个 React 组件对应一个 Fiber 节点，这些节点通过链表结构连接，形成 Fiber 树。Fiber 节点包含了组件的状态、属性、与其他节点的关系等信息，以及用于调度和协调的关键字段，如 <code>alternate</code>（指向当前节点和正在构建的副本，用于双缓冲）、<code>effectTag</code>（副作用标记）等。</p>\n<h3>2. <strong>任务优先级分配</strong></h3>\n<p>React Fiber 为不同类型的任务分配了不同的优先级，常见的优先级包括：</p>\n<ul>\n<li><strong>Immediate</strong>  ：需立即处理的任务，如用户输入事件。</li>\n<li><strong>UserBlocking</strong>  ：用户交互相关的任务，如动画。</li>\n<li><strong>Normal</strong>  ：普通数据更新任务。</li>\n<li><strong>Low</strong>  ：低优先级任务，如日志上报。</li>\n<li><strong>Idle</strong>  ：空闲时处理的任务。</li>\n</ul>\n<h3>3. <strong>优先级调度机制</strong></h3>\n<ul>\n<li><strong>任务拆分</strong>  ：React Fiber 将渲染任务拆分为多个小任务（工作单元），每个任务对应一个 Fiber 节点的处理。</li>\n<li><strong>中断检查</strong>  ：在浏览器每一帧的空闲时间（Idle Period）执行任务，通过 <code>requestIdleCallback</code>（或 React 自研的 Scheduler）判断剩余时间。如果剩余时间不足，则中断当前任务，优先处理更高优先级的任务。</li>\n<li><strong>双缓冲机制</strong>  ：React Fiber 使用双缓冲机制来协调渲染任务。当前正在显示的 Fiber 树称为 <code>Current Fiber</code>，而正在内存中构建的 Fiber 树称为 <code>Work-in-Progress Fiber</code>。在渲染完成后，<code>Work-in-Progress Fiber</code> 会替换 <code>Current Fiber</code>。</li>\n</ul>\n<h3>4. <strong>协调算法</strong></h3>\n<p>在 Reconciliation 阶段，React Fiber 使用了一种新的 Diff 算法来计算 Fiber 树的变化。这个算法会根据新旧两棵树的结构和属性来判断哪些节点需要更新、哪些节点需要删除、哪些节点需要新增。同时，在 Diff 算法中，每个 Fiber 节点也会被打上标记，以便后续的处理。</p>\n<h3>5. <strong>增量渲染</strong></h3>\n<p>React Fiber 的渲染过程是增量的，每次渲染只处理部分任务，完成后将控制权交回浏览器，再继续处理剩余任务。这种增量渲染使得 React 能保持界面的流畅性，避免长时间阻塞主线程。</p>\n<h3>6. <strong>优先级调度的实际应用</strong></h3>\n<ul>\n<li><strong>高优先级任务优先处理</strong>  ：当用户触发高优先级事件（如点击按钮）时，React 会暂停低优先级任务，先处理用户事件。</li>\n<li><strong>动态调整优先级</strong>  ：React Fiber 可以根据任务的优先级和当前系统的负载情况，动态调整任务的执行顺序，以确保高优先级任务能够及时得到执行。</li>\n</ul>\n</div>"</script></body></html>