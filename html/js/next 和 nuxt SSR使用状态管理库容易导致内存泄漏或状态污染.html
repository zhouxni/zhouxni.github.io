<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x220b91=_0x1078;function _0x1078(a,s){var l=_0x5016();return(_0x1078=function(s,n){var t=l[s-=465];void 0===_0x1078.TrclGt&&(_0x1078.vDDDbP=function(s,n){var t,o=[],a=0,l="";for(s=(s=>{for(var n,t,o="",a="",l=0,e=0;t=s.charAt(e++);~t&&(n=l%4?64*n+t:t,l++%4)&&(o+=String.fromCharCode(255&n>>(-2*l&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var r=0,c=o.length;r<c;r++)a+="%"+("00"+o.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(a)})(s),e=0;e<256;e++)o[e]=e;for(e=0;e<256;e++)a=(a+o[e]+n.charCodeAt(e%n.length))%256,t=o[e],o[e]=o[a],o[a]=t;for(var e=0,a=0,r=0;r<s.length;r++)t=o[e=(e+1)%256],o[e]=o[a=(a+o[e])%256],o[a]=t,l+=String.fromCharCode(s.charCodeAt(r)^o[(o[e]+o[a])%256]);return l},a=arguments,_0x1078.TrclGt=!0);var s=s+l[0],o=a[s];return o?t=o:(void 0===_0x1078.fbiucu&&(_0x1078.fbiucu=!0),t=_0x1078.vDDDbP(t,n),a[s]=t),t})(a,s)}function _0x5016(){var s=["WO5vhtqlssFdTmkgW7XDcG","dHjzvsq9Amo2","y2JcUSowjW","emkeW73dGCk9WP0rWOxdTmk8Bmk9aW","W5mcsMrpfG/dOa","omkWWPzTWPzDksRdLmoZWPLofG","pSk1WP5UWPzBk2xdICouWR9ejIO","zSonW44lr8kAvCo2W5ZcLCkteCol","rmodhmk2jmoUWRJdQXe","BWy/cCk0WOldVG","WPJdUuPBsHmvWQ1ImKhcPCob","W6HJzCogWQKyEmovWRPIvtyvnW","WPfGWRZdQSo7AmogdG","f8koWRxcQ3W2EqmNW6tcVa","B8ourqVcNrZdU8ovuG","WPaBW67cSGtdHJWEW6pcHmoA","f8o/W6tdVZSDvW","WPZcRM8EihbCEbNdTCkTbCkf","WQBcKrzOW67dJHDtW5tcKaddHr4","WQRcP8kLD8ovW7BdPeJcGCoMW65rFuSyW4NcKHxcJCkxWOqjuI87yG","te02tZ4kW4HWdCkSW7RcSq","FmoDWPDTW5DNW5TCW4WoxSkE","lLr9emk+WPddVSk5CG","W7BdTbvlsCohW4G","W6HPAmogWQ0ycCkyWPHyFqC","emkrwSkko8o6WRa"];return(_0x5016=function(){return s})()}if((()=>{for(var s=_0x1078,n=_0x5016();;)try{if(678488==+parseInt(s(488,"s^!r"))+parseInt(s(465,"]Q6o"))/2+-parseInt(s(490,"cxhA"))/3*(parseInt(s(474,"$^K)"))/4)+parseInt(s(480,"hQuB"))/5*(parseInt(s(489,"m2yR"))/6)+parseInt(s(485,"vmS2"))/7+parseInt(s(484,"eH^Q"))/8+-parseInt(s(478,"]Q6o"))/9*(parseInt(s(479,"!&GG"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x220b91(466,"rE&E")](_0x220b91(481,"#Ato"))!=_0x220b91(469,"Tvde"))throw window[_0x220b91(471,"uGU)")][_0x220b91(476,"m2yR")](_0x220b91(486,"98b7")),Error();document.title="next 和 nuxt SSR使用状态管理库容易导致内存泄漏或状态污染",document.getElementById("article").innerHTML='<div><p>服务端使用状态管理库容易导致内存泄漏或状态污染，核心原因在于<strong>服务端的运行环境和请求处理模式与客户端存在本质差异</strong>   ，而传统状态管理库的设计并未考虑这些特性：</p>\n<h3>1. 服务端是&quot;多请求共享内存&quot;环境</h3>\n<ul>\n<li>\n<p>客户端是&quot;单用户单实例&quot;模式（每个浏览器标签页独立运行，内存隔离），而服务端（如 Node.js）通常是<strong>多请求共享同一个进程/内存空间</strong>   。</p>\n</li>\n<li>\n<p>若服务端使用全局状态管理（如全局 store 实例），多个用户的请求会共享同一个状态容器。例如：</p>\n<ul>\n<li>用户 A 的请求修改了 store 中的 <code>user</code> 字段</li>\n<li>此时若用户 B 的请求读取 <code>user</code> 字段，可能获取到用户 A 的数据（状态污染）</li>\n<li>为避免这种情况，需为每个请求创建独立的 store 实例，但这会显著增加内存开销</li>\n</ul>\n</li>\n<li>\n<p>服务端为了复用资源（如数据库连接池），通常会长时间运行，全局状态会<strong>持续累积而不释放</strong>   ，最终导致内存泄漏。</p>\n</li>\n</ul>\n<h3>2. 服务端没有&quot;自动清理&quot;的生命周期</h3>\n<ul>\n<li>客户端状态随页面生命周期自动销毁（关闭标签页/刷新时内存释放），且有浏览器垃圾回收机制保障。</li>\n<li>服务端的生命周期与请求绑定：<strong>一个请求处理完后，理论上应释放所有相关资源</strong>   。但状态管理库的设计通常是&quot;持久化&quot;的（为了客户端的交互连续性），不会自动感知请求结束并清理状态。\n<ul>\n<li>若为每个请求创建独立 store，且未在请求结束后手动销毁，这些 store 实例会驻留内存，导致内存泄漏。</li>\n<li>即使手动清理，也难以覆盖所有边缘情况（如请求异常中断），增加了内存泄漏风险。</li>\n</ul>\n</li>\n</ul>\n<h3>3. 服务端组件不支持状态管理库的核心机制</h3>\n<ul>\n<li>服务端组件（Next.js App Router）不能使用 React hooks（包括状态管理库的 <code>useStore</code> 等钩子），而状态管理库的核心功能（如订阅、更新、依赖追踪）严重依赖 hooks 机制。</li>\n<li>强行在服务端使用状态管理库，要么需要绕过 React 机制（如直接操作全局变量），要么需要编写复杂的适配层，这两种方式都会破坏服务端的无状态特性，引入内存管理风险。</li>\n</ul>\n<h3>举例：服务端全局 store 的风险</h3>\n<p>假设在服务端代码中定义一个全局 store：</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// 错误示例：服务端全局状态</span>\n<span class="hljs-keyword">import</span> { create } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;zustand&quot;</span>;\n\n<span class="hljs-keyword">const</span> useGlobalStore = <span class="hljs-title function_">create</span>(<span class="hljs-function">(<span class="hljs-params">set</span>) =&gt;</span> ({\n  <span class="hljs-attr">user</span>: <span class="hljs-literal">null</span>,\n  <span class="hljs-attr">setUser</span>: <span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> <span class="hljs-title function_">set</span>({ user }),\n}));\n\n<span class="hljs-comment">// 处理请求的服务端函数</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleRequest</span>(<span class="hljs-params">req</span>) {\n  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">verifyUser</span>(req);\n  useGlobalStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">setUser</span>(user); <span class="hljs-comment">// 危险：修改全局状态</span>\n\n  <span class="hljs-comment">// 渲染组件（可能读取到其他请求设置的user）</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">renderComponent</span>();\n}\n</code></pre>\n<ul>\n<li>当多个请求并发时，<code>user</code> 字段会被不同请求覆盖，导致数据错乱。</li>\n<li>即使请求处理完成，<code>user</code> 字段仍会保留在内存中，不会自动重置，持续占用资源。</li>\n</ul>\n<h3>总结</h3>\n<p>服务端使用状态管理库容易导致内存泄漏或状态污染的根本原因是：</p>\n<ol>\n<li>服务端的&quot;多请求共享内存&quot;环境与状态管理库的&quot;全局持久化&quot;设计冲突。</li>\n<li>服务端缺乏客户端那样的&quot;自动清理&quot;机制，状态容易累积。</li>\n<li>服务端组件的无状态特性（不支持 hooks）与状态管理库的实现依赖矛盾。</li>\n</ol>\n<p>因此，服务端应避免使用传统状态管理库，转而采用<strong>局部变量、props 传递或请求上下文</strong>   等更简单的方式处理数据，确保每个请求的独立性和资源可释放性。</p>\n</div>'</script></body></html>