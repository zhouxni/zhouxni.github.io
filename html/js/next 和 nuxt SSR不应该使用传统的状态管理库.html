<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4f5d(){var n=["vSktbmoOW6uUW43cV8k6WRvFACkS","DcivWQ3dQSooFCkXfYldGmkSWQy","gaRdGmk7WP06hCoVWQuLWRRcPq","WQ3cV8okWRSQx2q/uajNrgX+","W7VcRw1vW5pcPwldQ8kwlmkIWPWK","WRpcMW1zf1ldR37dKSkghhHj","W4RcPSkBWRpdK8ohWOu","W7xcRCkcWRZdGHlcNa","WPyTWOxdIvpcMSovWPddHmoetM9Z","yeXcxdxcTMK","WRzsW6/dM8oYW6GFf2VdRdtdQmo4WQldH8keeYelW7NdTmkjEWa9xG","qmoZiSoDWQzXCmo5gSkrzCocoW","mebtkaJcPmoYkCkrWQ0qBY3dNG","kCoVW714mLTDfa","u8oMD8kGWOv9WQW","WQ0lWQiSW5JcSKK","fuNcPMBdMtDrAKy","WQi8WOffobK0W4nShZfxWO4","WQxcV8olWRWSxgffrG9vCf4","qNXMWPqrWQ3cVa","WOZdTCoEW6BcHCkCWOldSSkqFmk7W7K","W7xdMCoWW7xcPK/dUuDope40W6u","FqJdLSkPwmoBWR7dUs18WR3dQKO","WRBcLmk6WRFdQa"];return(_0x4f5d=function(){return n})()}var _0x343718=_0x44c5;function _0x44c5(e,n){var W=_0x4f5d();return(_0x44c5=function(n,o){var r=W[n-=495];void 0===_0x44c5.LfJsjl&&(_0x44c5.ZqvZnE=function(n,o){var r,t=[],e=0,W="";for(n=(n=>{for(var o,r,t="",e="",W=0,c=0;r=n.charAt(c++);~r&&(o=W%4?64*o+r:r,W++%4)&&(t+=String.fromCharCode(255&o>>(-2*W&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var d=0,a=t.length;d<a;d++)e+="%"+("00"+t.charCodeAt(d).toString(16)).slice(-2);return decodeURIComponent(e)})(n),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)e=(e+t[c]+o.charCodeAt(c%o.length))%256,r=t[c],t[c]=t[e],t[e]=r;for(var c=0,e=0,d=0;d<n.length;d++)r=t[c=(c+1)%256],t[c]=t[e=(e+t[c])%256],t[e]=r,W+=String.fromCharCode(n.charCodeAt(d)^t[(t[c]+t[e])%256]);return W},e=arguments,_0x44c5.LfJsjl=!0);var n=n+W[0],t=e[n];return t?r=t:(void 0===_0x44c5.BjSNUA&&(_0x44c5.BjSNUA=!0),r=_0x44c5.ZqvZnE(r,o),e[n]=r),r})(e,n)}if((()=>{for(var n=_0x44c5,o=_0x4f5d();;)try{if(935058==-parseInt(n(506,"f0d$"))*(-parseInt(n(499,"H5Cx"))/2)+parseInt(n(511,"Onc6"))/3*(-parseInt(n(497,"Onc6"))/4)+-parseInt(n(502,"Jm@p"))/5+-parseInt(n(498,"G*ai"))/6+parseInt(n(501,"29Cr"))/7+parseInt(n(508,"gmC["))/8+parseInt(n(509,"b7*]"))/9)break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x343718(516,"sjgd")](_0x343718(513,"Y%$r"))!=_0x343718(496,"bZvR"))throw window[_0x343718(510,"wF2b")][_0x343718(503,"vYUk")](_0x343718(507,"nPqz")),Error();document.title="next 和 nuxt SSR不应该使用传统的状态管理库",document.getElementById("article").innerHTML="<div><p>你说得很对，在服务端渲染（SSR）或服务端组件（Server Components）中，确实不应该使用传统的状态管理库（如Zustand、Redux等），这是由服务端渲染的本质和限制决定的。</p>\n<p>核心原因可以总结为三点：</p>\n<ol>\n<li>\n<p><strong>服务端渲染的无状态特性</strong><br>\n服务端的核心工作是&quot;一次性生成HTML&quot;，每个请求都是独立的、瞬时的，处理完即销毁。而状态管理库的设计初衷是&quot;持续维护动态变化的状态&quot;（如用户交互产生的状态），两者的核心目标不匹配。</p>\n</li>\n<li>\n<p><strong>多请求共享环境的风险</strong><br>\n服务端通常是多请求共享进程/内存的（如Node.js），如果使用全局状态管理，会导致不同用户的请求共享同一状态，引发数据污染（比如用户A的数据被用户B获取）。即使为每个请求创建独立状态实例，也会因无法自动销毁而导致内存泄漏。</p>\n</li>\n<li>\n<p><strong>技术实现的限制</strong><br>\n服务端组件无法使用React hooks（包括状态管理库提供的<code>useStore</code>等钩子），而这些钩子是状态管理库实现响应式更新的核心机制。强行使用会导致报错或不可预期的行为。</p>\n</li>\n</ol>\n<p>正确的做法是：</p>\n<ul>\n<li><strong>服务端</strong>   ：用局部变量、函数参数和props传递数据，专注于数据获取和初始渲染，不涉及&quot;状态管理&quot;概念。</li>\n<li><strong>客户端</strong>   ：在客户端组件（带<code>'use client'</code>）中使用状态管理库，处理交互产生的动态状态。</li>\n<li><strong>衔接方式</strong>   ：服务端将初始数据通过props传递给客户端组件，客户端用这些数据初始化本地状态管理。</li>\n</ul>\n<p>这种分工既发挥了服务端渲染的性能和SEO优势，又保留了客户端状态管理的灵活性，是Next.js等现代框架的最佳实践。</p>\n</div>"</script></body></html>