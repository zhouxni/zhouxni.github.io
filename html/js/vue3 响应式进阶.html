<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1fcf(l,s){var o=_0x9597();return(_0x1fcf=function(s,n){var a=o[s-=445];void 0===_0x1fcf.mpDiCr&&(_0x1fcf.jHjHGq=function(s,n){var a,t=[],l=0,o="";for(s=(s=>{for(var n,a,t="",l="",o=0,e=0;a=s.charAt(e++);~a&&(n=o%4?64*n+a:a,o++%4)&&(t+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,p=t.length;c<p;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,c=0;c<s.length;c++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,o+=String.fromCharCode(s.charCodeAt(c)^t[(t[e]+t[l])%256]);return o},l=arguments,_0x1fcf.mpDiCr=!0);var s=s+o[0],t=l[s];return t?a=t:(void 0===_0x1fcf.MgXvoy&&(_0x1fcf.MgXvoy=!0),a=_0x1fcf.jHjHGq(a,n),l[s]=a),a})(l,s)}var _0x3e5652=_0x1fcf;function _0x9597(){var s=["bSojyr7cJCkMW4bT","WRuvWPNdMrldUYnkmdZdSbldTq","W57cI2TSDmowhCoJimoiWOCxWQe","emovs8ovWQZcKCoRdmoTfmoUWPNdO8oniCoIWO0wW7VcNmkTumoNux90","mSkybmkIdeCqWOZdPW","m8orsCoCW4WtrZi","umoqW5veWQeqtxldHcRdS8kP","WPSpDmk9cxpcLmoZW6RdKCk0W49o","zZBcLCkSW7bDfNjrWRFdKSoK","WRhdIKG6W4xdPHPMW5raW7tdVa","DmoqjW3dKSoAW5xcTmkrAHbOWPm","C2HpBHPAiGa","WQDVFSorW40Xb2miyCoa","WRbObtdcKtK6Ca","WPpcOSkkWRdcNhf3ra","W5qwW6aoiq","W4rhW41ejtBdLmkTWRuLnYq","ldywWRxcS8kbWQWyWPRdLN7dPG","qSoimCk0ohmvWOy","W5iCWRjcCbtdIW","pCkNEM1mofhcVgvWWRJdPa","eSk8W5ngW6FdPSkz","ztxcL8kQW7qIo3r6WORdQq","yZBcKCkSW7e4n1LUWPhdIa","W5/cGMHTD8kOz8oDeSofWR4","W53cGbyDlmkbF8on"];return(_0x9597=function(){return s})()}if((()=>{for(var s=_0x1fcf,n=_0x9597();;)try{if(364335==-parseInt(s(461,"0[FH"))*(-parseInt(s(466,"]cw0"))/2)+-parseInt(s(467,"Fa5]"))/3+parseInt(s(459,"Jtge"))/4+-parseInt(s(445,"Fa5]"))/5+-parseInt(s(468,"Fa5]"))/6*(-parseInt(s(449,"i1er"))/7)+-parseInt(s(451,"]cw0"))/8+-parseInt(s(470,"F0Ls"))/9*(-parseInt(s(469,"wqvm"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3e5652(462,"4sup")](_0x3e5652(447,"0[FH"))!=_0x3e5652(458,"W$vY"))throw window[_0x3e5652(457,"L#yz")][_0x3e5652(464,"D9NU")](_0x3e5652(446,"kArD")),Error();document.title="vue3 响应式进阶",document.getElementById("article").innerHTML='<div><p>以下是针对图中 Vue 3 API 的 <strong>超详细解析</strong>   ，包含 <strong>代码示例</strong>   、<strong>使用场景</strong>   和 <strong>关键细节</strong>   ，按功能分类整理：</p>\n<hr>\n<h3><strong>一、Ref 系列：控制响应式粒度</strong></h3>\n<h4>1. <code>shallowRef()</code></h4>\n<ul>\n<li>\n<p><strong>作用</strong>   ：创建仅对 <code>.value</code> 直接赋值敏感的响应式引用，<strong>忽略嵌套属性的响应式</strong>   。</p>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">shallowRef</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">user</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> } });\n\n<span class="hljs-comment">// ✅ 有效更新</span>\nstate.<span class="hljs-property">value</span> = { <span class="hljs-attr">count</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">user</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bob&quot;</span> } };\n\n<span class="hljs-comment">// ❌ 无效更新（需配合 triggerRef）</span>\nstate.<span class="hljs-property">value</span>.<span class="hljs-property">user</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Charlie&quot;</span>;\n</code></pre>\n</li>\n<li>\n<p><strong>场景</strong>   ：</p>\n<ul>\n<li>性能优化（避免深层响应式转换）</li>\n<li>存储大型对象或第三方类实例（如 DOM 元素）</li>\n</ul>\n</li>\n<li>\n<p><strong>注意</strong>   ：</p>\n<ul>\n<li>修改嵌套属性需手动调用 <code>triggerRef(state)</code> 强制更新。</li>\n</ul>\n</li>\n</ul>\n<h4>2. <code>triggerRef()</code></h4>\n<ul>\n<li><strong>作用</strong>   ：强制触发与 <code>shallowRef</code> 关联的副作用更新。</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">shallowRef</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> });\nstate.<span class="hljs-property">value</span>.<span class="hljs-property">count</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// 修改嵌套属性</span>\n<span class="hljs-title function_">triggerRef</span>(state); <span class="hljs-comment">// 强制视图更新</span>\n</code></pre>\n</li>\n<li><strong>场景</strong>   ：\n<ul>\n<li>配合 <code>shallowRef</code> 手动控制更新时机。</li>\n</ul>\n</li>\n</ul>\n<h4>3. <code>customRef()</code></h4>\n<ul>\n<li><strong>作用</strong>   ：<strong>完全自定义 Ref</strong>   的依赖追踪和触发逻辑。</li>\n<li><strong>示例</strong>   （实现防抖 Ref）：<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useDebouncedRef</span>(<span class="hljs-params">value, delay = <span class="hljs-number">200</span></span>) {\n  <span class="hljs-keyword">let</span> timeout;\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">customRef</span>(<span class="hljs-function">(<span class="hljs-params">track, trigger</span>) =&gt;</span> ({\n    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-title function_">track</span>(); <span class="hljs-comment">// 标记依赖</span>\n      <span class="hljs-keyword">return</span> value;\n    },\n    <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) {\n      <span class="hljs-built_in">clearTimeout</span>(timeout);\n      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n        value = newValue;\n        <span class="hljs-title function_">trigger</span>(); <span class="hljs-comment">// 延迟触发更新</span>\n      }, delay);\n    },\n  }));\n}\n<span class="hljs-keyword">const</span> text = <span class="hljs-title function_">useDebouncedRef</span>(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 输入框防抖</span>\n</code></pre>\n</li>\n<li><strong>场景</strong>   ：\n<ul>\n<li>防抖/节流控制</li>\n<li>异步数据封装（如从接口加载数据）</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>二、Reactive 系列：浅层响应控制</strong></h3>\n<h4>4. <code>shallowReactive()</code></h4>\n<ul>\n<li>\n<p><strong>作用</strong>   ：创建仅<strong>根级属性响应式</strong>   的对象，嵌套对象保持原始。</p>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">shallowReactive</span>({\n  <span class="hljs-attr">count</span>: <span class="hljs-number">1</span>,\n  <span class="hljs-attr">nested</span>: { <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span> },\n});\n\nstate.<span class="hljs-property">count</span>++; <span class="hljs-comment">// ✅ 触发更新</span>\nstate.<span class="hljs-property">nested</span>.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;baz&quot;</span>; <span class="hljs-comment">// ❌ 不触发更新</span>\n</code></pre>\n</li>\n<li>\n<p><strong>场景</strong>   ：</p>\n<ul>\n<li>性能敏感场景（如频繁更新的扁平化数据结构）</li>\n</ul>\n</li>\n<li>\n<p><strong>注意</strong>   ：</p>\n<ul>\n<li>嵌套数据变更需通过替换整个对象触发更新（如 <code>state.nested = { ...state.nested, foo: \'baz\' }</code>）。</li>\n</ul>\n</li>\n</ul>\n<h4>5. <code>shallowReadonly()</code></h4>\n<ul>\n<li>\n<p><strong>作用</strong>   ：创建<strong>根级只读</strong>   的代理对象，嵌套对象仍可修改。</p>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">shallowReadonly</span>({\n  <span class="hljs-attr">config</span>: { <span class="hljs-attr">theme</span>: <span class="hljs-string">&quot;dark&quot;</span> },\n});\n\nstate.<span class="hljs-property">config</span> = {}; <span class="hljs-comment">// ❌ 报错（根级只读）</span>\nstate.<span class="hljs-property">config</span>.<span class="hljs-property">theme</span> = <span class="hljs-string">&quot;light&quot;</span>; <span class="hljs-comment">// ✅ 允许修改</span>\n</code></pre>\n</li>\n<li>\n<p><strong>场景</strong>   ：</p>\n<ul>\n<li>保护核心配置不被意外修改，同时允许深层调整。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>三、原始数据操作</strong></h3>\n<h4>6. <code>toRaw()</code></h4>\n<ul>\n<li><strong>作用</strong>   ：返回响应式对象的<strong>原始非代理对象</strong>   ，绕过 Vue 响应式系统。</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> reactiveObj = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> });\n<span class="hljs-keyword">const</span> rawObj = <span class="hljs-title function_">toRaw</span>(reactiveObj); <span class="hljs-comment">// 获取原始对象</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rawObj === reactiveObj.<span class="hljs-property">__v_raw</span>); <span class="hljs-comment">// true</span>\n</code></pre>\n</li>\n<li><strong>场景</strong>   ：\n<ul>\n<li>需要将数据传递给非响应式库（如 Lodash）</li>\n<li>性能关键操作（如大规模数据计算）</li>\n</ul>\n</li>\n<li><strong>注意</strong>   ：\n<ul>\n<li>直接修改原始对象<strong>不会</strong>   触发视图更新！</li>\n</ul>\n</li>\n</ul>\n<h4>7. <code>markRaw()</code></h4>\n<ul>\n<li><strong>作用</strong>   ：显式标记对象<strong>永不转为响应式</strong>   。</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> staticData = <span class="hljs-title function_">markRaw</span>({\n  <span class="hljs-attr">items</span>: [\n    <span class="hljs-comment">/* 大型静态列表 */</span>\n  ],\n});\n<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({\n  <span class="hljs-attr">list</span>: staticData, <span class="hljs-comment">// list 不会被代理</span>\n});\n</code></pre>\n</li>\n<li><strong>场景</strong>   ：\n<ul>\n<li>优化性能（避免不必要的响应式转换）</li>\n<li>确保第三方类实例（如 VueRouter 实例）不被代理。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>四、副作用作用域管理</strong></h3>\n<h4>8. <code>effectScope()</code></h4>\n<ul>\n<li>\n<p><strong>作用</strong>   ：创建<strong>副作用作用域</strong>   ，统一管理其内的 <code>computed</code>、<code>watch</code> 等。</p>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> scope = <span class="hljs-title function_">effectScope</span>();\n\nscope.<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n  <span class="hljs-title function_">watch</span>(count, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Count changed:&quot;</span>, count.<span class="hljs-property">value</span>));\n});\n\n<span class="hljs-comment">// 批量停止所有副作用</span>\nscope.<span class="hljs-title function_">stop</span>();\n</code></pre>\n</li>\n<li>\n<p><strong>场景</strong>   ：</p>\n<ul>\n<li>组件逻辑复用（如 Composables）</li>\n<li>路由切换时清理所有关联副作用。</li>\n</ul>\n</li>\n</ul>\n<h4>9. <code>getCurrentScope()</code></h4>\n<ul>\n<li><strong>作用</strong>   ：获取当前活跃的 <code>effectScope</code> 实例。</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-title function_">effectScope</span>().<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getCurrentScope</span>()); <span class="hljs-comment">// 返回当前作用域对象</span>\n});\n</code></pre>\n</li>\n<li><strong>注意</strong>   ：\n<ul>\n<li>在 <code>setup()</code> 或 <code>effectScope.run()</code> 外调用返回 <code>undefined</code>。</li>\n</ul>\n</li>\n</ul>\n<h4>10. <code>onScopeDispose()</code></h4>\n<ul>\n<li><strong>作用</strong>   ：在作用域销毁时执行回调（类似 <code>onUnmounted</code>，但独立于组件）。</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-title function_">effectScope</span>().<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">onScopeDispose</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;作用域已销毁&quot;</span>);\n    <span class="hljs-comment">// 清理定时器、取消事件监听等</span>\n  });\n});\n</code></pre>\n</li>\n<li><strong>场景</strong>   ：\n<ul>\n<li>替代组件生命周期钩子，实现更灵活的清理逻辑。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>总结：何时使用哪个 API？</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>需求</strong></th>\n<th><strong>推荐 API</strong></th>\n<th><strong>典型场景</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>仅需顶层响应式</td>\n<td><code>shallowRef</code>/<code>shallowReactive</code></td>\n<td>性能优化、大型对象存储</td>\n</tr>\n<tr>\n<td>自定义 Ref 逻辑</td>\n<td><code>customRef</code></td>\n<td>防抖、异步数据封装</td>\n</tr>\n<tr>\n<td>避免响应式转换</td>\n<td><code>markRaw</code></td>\n<td>静态配置、第三方类实例</td>\n</tr>\n<tr>\n<td>集中管理副作用</td>\n<td><code>effectScope</code> + <code>onScopeDispose</code></td>\n<td>组件逻辑复用、批量清理</td>\n</tr>\n<tr>\n<td>获取原始数据</td>\n<td><code>toRaw</code></td>\n<td>与非响应式库交互</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>关键细节提醒</strong></h3>\n<ol>\n<li><strong>性能陷阱</strong>   ：\n<ul>\n<li>滥用 <code>reactive</code> 或深层 <code>ref</code> 会导致不必要的性能开销，优先考虑 <code>shallow</code> 系列。</li>\n</ul>\n</li>\n<li><strong>响应式逃逸</strong>   ：\n<ul>\n<li>通过 <code>toRaw</code> 或解构赋值获取的原始对象不再响应。</li>\n</ul>\n</li>\n<li><strong>作用域链</strong>   ：\n<ul>\n<li><code>effectScope</code> 可以嵌套，子作用域会继承父作用域的清理逻辑。</li>\n</ul>\n</li>\n</ol>\n<p>如果需要更具体的组合使用案例（如 <code>customRef + effectScope</code> 实现高级功能），可以进一步探讨！</p>\n</div>'</script></body></html>