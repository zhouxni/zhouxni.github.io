<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x56a785=_0x40dd;function _0x40dd(t,s){var e=_0x7dc6();return(_0x40dd=function(s,n){var a=e[s-=266];void 0===_0x40dd.ePsDWX&&(_0x40dd.SbMXBn=function(s,n){var a,l=[],t=0,e="";for(s=(s=>{for(var n,a,l="",t="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=l.length;o<c;o++)t+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(t)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)t=(t+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[t],l[t]=a;for(var p=0,t=0,o=0;o<s.length;o++)a=l[p=(p+1)%256],l[p]=l[t=(t+l[p])%256],l[t]=a,e+=String.fromCharCode(s.charCodeAt(o)^l[(l[p]+l[t])%256]);return e},t=arguments,_0x40dd.ePsDWX=!0);var s=s+e[0],l=t[s];return l?a=l:(void 0===_0x40dd.DbFvek&&(_0x40dd.DbFvek=!0),a=_0x40dd.SbMXBn(a,n),t[s]=a),a})(t,s)}function _0x7dc6(){var s=["W41sd8kuoHZcRmkiDmodth1u","kSopWQXIWPRdJSkV","yqqYWRyIrXzZlCoRW6O1wq","WQ/dPSk+fYZdOxNcNSk1DNHbWPW","FmoTWPBcV11sWPG","CbBdMvhcMLxcSCouWOhcPJBdOW","zgu0kw/dNCk0vCk8gCkaW4e","vM/cKx4fW4iGoW0","zCkUBetdHCkJWOFdMSkDWOJdIrzgWORdMMvgWQldSx8sW5KKpmknWQq","WPDuat3cGuxdRKO","BwLkWQPbW7PrWRddOYmaWO4P","c3RdImkXWOpdQmkx","WPddKmkHtqBdHCoNWPtcOmoNACosW6m","W7P7W7L6p8kXW7ZcKLDmWO7dSYy","W4lcI1S7WQ42W7dcRmooaSk1WRlcQe4","CSkJWRSsFmkhW5e","aCkvW7H3BCoxWPlcO8oRAh/cIWC","mWeGW6eFhCoMW5NdNSo+t8k4WQZdHa","W5JdKJBcO8o8","wcOvE8kJW7xcGevBWRNcVSk9mq","aIJcPM7dI8o6g8k8WQPauJjA","W6fluCk5W4meEuJcMmoRq8opWPu"];return(_0x7dc6=function(){return s})()}if((()=>{for(var s=_0x40dd,n=_0x7dc6();;)try{if(768627==+parseInt(s(273,"LKwj"))+-parseInt(s(278,"^jUx"))/2+-parseInt(s(280,"YvNy"))/3+-parseInt(s(270,"JrVd"))/4+parseInt(s(266,"nu)@"))/5+-parseInt(s(281,"Ycxk"))/6*(parseInt(s(279,"6^@f"))/7)+parseInt(s(282,"0*xo"))/8)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x56a785(269,"XAzM")](_0x56a785(275,"bsLy"))!=_0x56a785(286,"0RTp"))throw window[_0x56a785(277,"gpjP")][_0x56a785(272,"JN*x")](_0x56a785(276,"rNx4")),Error();document.title="Next.js 生命周期",document.getElementById("article").innerHTML='<div><p>Next.js 作为 React 的服务端渲染框架，结合了 React 的客户端生命周期和自身特有的服务端渲染流程。下面为你详细介绍 Next.js 的生命周期，涵盖服务端和客户端两个方面。</p>\n<h3>服务端渲染生命周期</h3>\n<h4>1. 页面请求阶段</h4>\n<p>当浏览器首次请求页面时，Next.js 会按以下步骤处理：</p>\n<ul>\n<li><strong>自定义文档（_document.js）</strong>   ：负责渲染页面的 HTML 结构，像 <code>&lt;html&gt;</code>、<code>&lt;body&gt;</code> 标签就由它来渲染。此文件只会在服务端渲染时被调用。</li>\n<li><strong>自定义应用（_app.js）</strong>   ：用于初始化页面，比如设置全局状态、添加全局样式等操作都可以在这里完成。它在服务端和客户端都会被调用。</li>\n<li><strong>数据获取方法</strong>   ：\n<ul>\n<li><strong>getServerSideProps</strong>   ：在每次请求时，都会在服务端执行，其返回值会作为 props 传递给页面组件。</li>\n<li><strong>getStaticProps</strong>   ：在构建时执行，执行后会生成静态 HTML 文件。</li>\n<li><strong>getInitialProps</strong>   ：既可以在服务端执行，也能在客户端执行，不过官方更推荐使用 <code>getServerSideProps</code> 或 <code>getStaticProps</code>。</li>\n</ul>\n</li>\n</ul>\n<h4>2. 组件渲染阶段</h4>\n<p>服务端会把 React 组件渲染成 HTML 字符串，然后将其发送给浏览器。在此过程中，React 的 <code>useEffect</code> 钩子不会被触发。</p>\n<h3>客户端渲染生命周期</h3>\n<h4>1. 水合（Hydration）阶段</h4>\n<p>浏览器接收到服务端发送的 HTML 后，Next.js 会进行以下操作：</p>\n<ul>\n<li>将静态 HTML 与 React 组件进行关联，这个过程被称为“水合”。</li>\n<li>初始化事件监听器，让页面具备交互能力。</li>\n<li>执行 <code>useEffect</code> 钩子（仅执行一次）。</li>\n</ul>\n<h4>2. 客户端路由切换</h4>\n<p>当使用 Next.js 的 <code>next/link</code> 或者 <code>next/router</code> 进行路由切换时：</p>\n<ul>\n<li><strong>beforeHistoryChange</strong>   ：在浏览器历史记录变更之前触发。</li>\n<li><strong>routeChangeStart</strong>   ：路由开始切换时触发。</li>\n<li><strong>app.render</strong>   ：重新渲染 <code>_app.js</code>。</li>\n<li><strong>页面组件卸载</strong>   ：当前页面组件会被卸载，相应地会触发 <code>componentWillUnmount</code> 或者 <code>useEffect</code> 的清理函数。</li>\n<li><strong>数据获取</strong>   ：\n<ul>\n<li>如果使用的是 <code>getInitialProps</code>，它会在客户端执行。</li>\n<li>如果使用的是 <code>getServerSideProps</code>，则不会执行，因为它仅在服务端执行。</li>\n</ul>\n</li>\n<li><strong>页面组件挂载</strong>   ：新页面组件会被挂载，会触发 <code>componentDidMount</code> 或者 <code>useEffect</code>。</li>\n<li><strong>routeChangeComplete</strong>   ：路由切换完成后触发。</li>\n</ul>\n<h3>生命周期钩子总结</h3>\n<h4>服务端特有</h4>\n<ul>\n<li><strong>getServerSideProps</strong>   ：每次请求时在服务端执行。</li>\n<li><strong>getStaticProps</strong>   ：在构建时执行。</li>\n<li><strong>getStaticPaths</strong>   ：用于动态路由的静态生成。</li>\n</ul>\n<h4>客户端特有</h4>\n<ul>\n<li><strong>useEffect</strong>   ：在组件挂载和更新时执行。</li>\n<li><strong>useLayoutEffect</strong>   ：与 <code>useEffect</code> 类似，但会在 DOM 更新后同步执行。</li>\n<li><strong>componentDidMount/Update/Unmount</strong>   ：类组件的生命周期方法。</li>\n</ul>\n<h4>通用</h4>\n<ul>\n<li><strong>getInitialProps</strong>   ：既可以在服务端执行，也能在客户端执行。</li>\n<li><strong>_app.js</strong>   ：在服务端和客户端都会被调用。</li>\n<li><strong>_document.js</strong>   ：仅在服务端渲染时被调用。</li>\n</ul>\n<h3>代码示例</h3>\n<p>下面是一个展示 Next.js 生命周期的代码示例：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// _document.js</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">Document</span>, { <span class="hljs-title class_">Html</span>, <span class="hljs-title class_">Head</span>, <span class="hljs-title class_">Main</span>, <span class="hljs-title class_">NextScript</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/document&#x27;</span>;\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDocument</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Document</span> {\n  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> (\n      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Html</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">Head</span> /&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n          <span class="hljs-tag">&lt;<span class="hljs-name">Main</span> /&gt;</span>\n          <span class="hljs-tag">&lt;<span class="hljs-name">NextScript</span> /&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">Html</span>&gt;</span></span>\n    );\n  }\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">MyDocument</span>;\n\n<span class="hljs-comment">// _app.js</span>\n<span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/router&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyApp</span>(<span class="hljs-params">{ Component, pageProps }</span>) {\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;App mounted on client&#x27;</span>);\n    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRouteChange</span> = (<span class="hljs-params">url</span>) =&gt; {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Route changed to: &#x27;</span>, url);\n    };\n    <span class="hljs-title class_">Router</span>.<span class="hljs-property">events</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;routeChangeStart&#x27;</span>, handleRouteChange);\n    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-title class_">Router</span>.<span class="hljs-property">events</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;routeChangeStart&#x27;</span>, handleRouteChange);\n    };\n  }, []);\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> {<span class="hljs-attr">...pageProps</span>} /&gt;</span></span>;\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">MyApp</span>;\n\n<span class="hljs-comment">// page.js</span>\n<span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getServerSideProps</span>(<span class="hljs-params">context</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Running on server&#x27;</span>);\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">props</span>: {\n      <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;Server-side data&#x27;</span>,\n    },\n  };\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{ data }</span>) {\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Component mounted on client&#x27;</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Component will unmount&#x27;</span>);\n    };\n  }, []);\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{data}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Page</span>;\n</code></pre>\n<h3>注意事项</h3>\n<ul>\n<li>服务端渲染不会触发 <code>useEffect</code>，它只会在客户端执行。</li>\n<li>要避免在服务端渲染的代码中使用浏览器特有的 API，如 <code>window</code>、<code>document</code> 等。</li>\n<li>使用 <code>getServerSideProps</code> 会使页面每次请求都在服务器端渲染，这可能会影响性能，你可以考虑使用 <code>getStaticProps</code> 结合 <code>revalidate</code> 来优化性能。</li>\n</ul>\n<p>通过了解 Next.js 的生命周期，你可以更好地控制数据获取的时机和方式，优化应用性能，同时避免一些常见的错误。</p>\n</div>'</script></body></html>