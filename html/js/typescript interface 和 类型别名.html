<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1af498=_0x1d33;function _0x2a3f(){var s=["gHdcR8oJW63cJde1aaxcMttdTa","WPhcSKZdM8kKymocW4GSFXKsfG","vmkJAblcKNldObrT","WPtdUqhdOmo8aSo9","letcMSkCfmotrdtdK8kSW7u","WQNcHmkGW5JcUmotDmkUn8kKysxdJa","W7BcLwSbAmohnCkKDSoJWPzYWPC","mSo+WPqgWRTIxCocWOtcOSkyW7GV","g8o1WR0oW7vwg3fnw8oW","WOldJGpcUSkvFCkUWPJcTa","vL3dT8ktW5eatSovWOiGWODFj8oB","W77cPSkXW59yWP7cNCohoZ5ZCuBcL1xcGCkxW6ZdTSofsmkaW6y8iSoV","n8o/WPfwW64wkCoJWRe","catcPCogWP1Bemkl","ygGGAg8NBYbmWRi","BxK6kCoxiMmtumoRwLS+","amksW7mIqgRcKG","x8oZztTa","mSo/WPilWRHSwmozWR/cLmkyW6Ch","W4iDW70wWRnPWQ/dTSolWPy","WQKSW68xWOn5W7vHW7BcVIaOW6u","W5FcSCkMW4PyW5FdUCknoa","kgrpWOKeW4fBB0G","CxaJuaRcVJS","lq09WOOJW7r/","BmkqWQRdSCkdWO0NWP4UWQrcBSoHW6O"];return(_0x2a3f=function(){return s})()}function _0x1d33(t,s){var e=_0x2a3f();return(_0x1d33=function(s,n){var a=e[s-=439];void 0===_0x1d33.zSydbr&&(_0x1d33.FRaCVz=function(s,n){var a,l=[],t=0,e="";for(s=(s=>{for(var n,a,l="",t="",e=0,r=0;a=s.charAt(r++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,p=l.length;c<p;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),r=0;r<256;r++)l[r]=r;for(r=0;r<256;r++)t=(t+l[r]+n.charCodeAt(r%n.length))%256,a=l[r],l[r]=l[t],l[t]=a;for(var r=0,t=0,c=0;c<s.length;c++)a=l[r=(r+1)%256],l[r]=l[t=(t+l[r])%256],l[t]=a,e+=String.fromCharCode(s.charCodeAt(c)^l[(l[r]+l[t])%256]);return e},t=arguments,_0x1d33.zSydbr=!0);var s=s+e[0],l=t[s];return l?a=l:(void 0===_0x1d33.gIHgdl&&(_0x1d33.gIHgdl=!0),a=_0x1d33.FRaCVz(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x1d33,n=_0x2a3f();;)try{if(641865==+parseInt(s(444,"ritD"))*(-parseInt(s(445,"J0Td"))/2)+-parseInt(s(439,"LYM7"))/3*(parseInt(s(456,"NI)k"))/4)+-parseInt(s(442,"j&d4"))/5+parseInt(s(458,"0rr)"))/6*(-parseInt(s(455,"wlTI"))/7)+parseInt(s(441,"WUQ1"))/8+parseInt(s(463,"4XCn"))/9+parseInt(s(461,"qGFv"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1af498(459,"9Ixx")](_0x1af498(457,"ZLFM"))!=_0x1af498(453,"IBY#"))throw window[_0x1af498(449,"SkOv")][_0x1af498(452,"v]dM")](_0x1af498(447,"ZLFM")),Error();document.title="typescript interface 和 类型别名",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>interface</code> 和 <strong>类型别名</strong>  （<code>type alias</code>）都是用于定义自定义类型的工具，但它们在语法、功能和使用场景上有一些关键的不同点。以下是两者的详细比较：</p>\n<hr>\n<h3><strong>1. 定义与语法</strong></h3>\n<ul>\n<li><strong><code>interface</code></strong>  ：\n<ul>\n<li>用于定义对象的结构，特别是对象的属性和方法。</li>\n<li>语法上更接近于面向对象编程中的接口概念。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong><code>type</code>（类型别名）</strong>  ：\n<ul>\n<li>用于为任何类型定义别名，包括基本类型、联合类型、元组、函数类型等。</li>\n<li>语法更灵活，可以定义 <code>interface</code> 无法表达的类型。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">StringOrNumber</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>2. 扩展方式</strong></h3>\n<ul>\n<li><strong><code>interface</code></strong>  ：\n<ul>\n<li>使用 <code>extends</code> 关键字进行扩展，可以继承其他 <code>interface</code> 或类类型。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Named</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Named</span> {\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong><code>type</code></strong>  ：\n<ul>\n<li>使用交叉类型（<code>&amp;</code>）进行扩展，可以组合多个类型。</li>\n<li>也可以通过 <code>type</code> 自身引用进行递归定义。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Named</span> = { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> };\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> = <span class="hljs-title class_">Named</span> &amp; { <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> };\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>3. 声明合并</strong></h3>\n<ul>\n<li><strong><code>interface</code></strong>  ：\n<ul>\n<li>支持声明合并，多个同名的 <code>interface</code> 会被自动合并。</li>\n<li>适用于需要逐步扩展接口的场景。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">person</span>: <span class="hljs-title class_">Person</span> = { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> }; <span class="hljs-comment">// 合法，属性合并</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong><code>type</code></strong>  ：\n<ul>\n<li>不支持声明合并，同名 <code>type</code> 会导致编译错误。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> = { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> };\n<span class="hljs-comment">// type Person = { age: number }; // 错误：重复定义</span>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>4. 复杂类型定义</strong></h3>\n<ul>\n<li><strong><code>interface</code></strong>  ：\n<ul>\n<li>主要用于定义对象的结构，不支持直接定义联合类型、元组等复杂类型。</li>\n<li><strong>示例</strong>  （不支持）：<pre><code class="language-typescript"><span class="hljs-comment">// interface StringOrNumber = string | number; // 错误</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong><code>type</code></strong>  ：\n<ul>\n<li>支持定义联合类型、元组、函数类型等复杂类型。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">StringOrNumber</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Func</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>5. 映射类型和条件类型</strong></h3>\n<ul>\n<li><strong><code>interface</code></strong>  ：\n<ul>\n<li>不支持直接用于映射类型和条件类型。</li>\n<li><strong>示例</strong>  （不支持）：<pre><code class="language-typescript"><span class="hljs-comment">// interface NonNullable&lt;T&gt; = T extends null | undefined ? never : T; // 错误</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong><code>type</code></strong>  ：\n<ul>\n<li>可以与映射类型、条件类型等高级类型特性结合使用，实现更复杂的类型逻辑。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">NonNullable</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span> ? <span class="hljs-built_in">never</span> : T;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>6. 使用场景</strong></h3>\n<ul>\n<li><strong><code>interface</code></strong>  ：\n<ul>\n<li>更适合用于定义对象的结构，特别是需要声明合并或继承时。</li>\n<li>在定义类类型或需要逐步扩展接口时更常用。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-title function_">move</span>(): <span class="hljs-built_in">void</span>;\n}\n\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-title function_">bark</span>(): <span class="hljs-built_in">void</span>;\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong><code>type</code></strong>  ：\n<ul>\n<li>更适合用于定义复杂的类型别名，如联合类型、元组、函数类型等。</li>\n<li>在需要更灵活的类型定义时更常用。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">APIResponse</span> = { <span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span>; <span class="hljs-attr">status</span>: <span class="hljs-built_in">number</span> };\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Callback</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">error</span>: <span class="hljs-title class_">Error</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">result</span>: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>7. 可变性</strong></h3>\n<ul>\n<li><strong><code>interface</code></strong>  ：\n<ul>\n<li>通常用于定义稳定的对象结构，但在某些情况下（如声明合并）可以扩展。</li>\n<li>一旦定义，结构相对稳定，但可以通过声明合并增加属性。</li>\n</ul>\n</li>\n<li><strong><code>type</code></strong>  ：\n<ul>\n<li>一旦定义，类型别名是固定的，不能通过类似声明合并的方式扩展。</li>\n<li>更适合用于定义不可变的类型别名。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>interface</code></th>\n<th><code>type</code>（类型别名）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>定义对象结构</strong></td>\n<td>是</td>\n<td>是（但更灵活）</td>\n</tr>\n<tr>\n<td><strong>声明合并</strong></td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td><strong>扩展方式</strong></td>\n<td>使用 <code>extends</code></td>\n<td>使用交叉类型（<code>&amp;</code>）</td>\n</tr>\n<tr>\n<td><strong>复杂类型定义</strong></td>\n<td>不支持（如联合类型、元组）</td>\n<td>支持（如联合类型、元组、函数类型）</td>\n</tr>\n<tr>\n<td><strong>映射类型和条件类型</strong></td>\n<td>不直接支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td><strong>使用场景</strong></td>\n<td>定义对象结构、类类型、需要继承时</td>\n<td>定义复杂类型、需要灵活性时</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>结论</strong>  ：</p>\n<ul>\n<li><strong>选择 <code>interface</code></strong>  ：\n<ul>\n<li>当你需要定义对象的结构，特别是需要声明合并或继承时。</li>\n<li>当你希望代码更接近于面向对象编程风格时。</li>\n</ul>\n</li>\n<li><strong>选择 <code>type</code></strong>  ：\n<ul>\n<li>当你需要定义联合类型、元组、函数类型等复杂类型时。</li>\n<li>当你需要更灵活的类型定义，或结合映射类型、条件类型等高级特性时。</li>\n</ul>\n</li>\n</ul>\n<p>在实际开发中，可以根据项目的类型定义需求，灵活选择或结合使用两者。</p>\n</div>'</script></body></html>