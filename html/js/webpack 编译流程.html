<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1546(){var n=["BvTbW4FcO8kRd8kZkCo2W49kW7C","r8o8rSodWQXNWQBdPSkKyHZcU3u","WOSKFLFcLdLmWRXBsCogW5O","wSkVF8k7WRnNW7a","vCoFgSoCW45hW6n6gSoQW5a","W6BcTty0wa","uY/dTmowWONcHHLO","W5tcOqFcK0OjmCocW4C7WRyiWR0","W6GSWQ1ma2fFW715","uh/cUgGwW7OngKLgWPGG","rSkTeSkAi8kRWOpcVCkLfcyrm8kEWOZdNaVcVhjfWQRdUCo4suRdIq","WRZcNSkIWRpcJmkTWP0","W5tcQWBcLumiumoEW58BWPGh","qSo4tSobWQS8W6ddMCkduXi","qs3dO8oQzsulcfO","W6tcIM9iW5pdM8kYrYq","WQddSamEueddSCkv","ld7cLtRdMLldMqKhzSoevIO","W6RdRZZdK8oLk2OAimo+W60","jeVdSLVcOs7cIG","wCo0WPBcIMBcLmkEWQLdWQldQSoG","WQ/dHCkzWQS2W6qkWRK","EmoFbc93kmobWOfvW57dUCo3","mmk3c1ddISk2bwOCi8kj","WPNdHCkvWOCqW5JcVW","rSo5sCobWQ9MW5FdUSkJzJRcKq","WO9YCSofW7VdLG0","vGRdLtfvWQeL"];return(_0x1546=function(){return n})()}function _0x3405(r,n){var a=_0x1546();return(_0x3405=function(n,s){var o=a[n-=120];void 0===_0x3405.jDGzpz&&(_0x3405.gbHTol=function(n,s){var o,l=[],r=0,a="";for(n=(n=>{for(var s,o,l="",r="",a=0,t=0;o=n.charAt(t++);~o&&(s=a%4?64*s+o:o,a++%4)&&(l+=String.fromCharCode(255&s>>(-2*a&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var e=0,c=l.length;e<c;e++)r+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(r)})(n),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)r=(r+l[t]+s.charCodeAt(t%s.length))%256,o=l[t],l[t]=l[r],l[r]=o;for(var t=0,r=0,e=0;e<n.length;e++)o=l[t=(t+1)%256],l[t]=l[r=(r+l[t])%256],l[r]=o,a+=String.fromCharCode(n.charCodeAt(e)^l[(l[t]+l[r])%256]);return a},r=arguments,_0x3405.jDGzpz=!0);var n=n+a[0],l=r[n];return l?o=l:(void 0===_0x3405.NyxxMi&&(_0x3405.NyxxMi=!0),o=_0x3405.gbHTol(o,s),r[n]=o),o})(r,n)}var _0x4453d7=_0x3405;if((()=>{for(var n=_0x3405,s=_0x1546();;)try{if(228969==+parseInt(n(147,"B9v*"))+-parseInt(n(122,"8PT7"))/2+-parseInt(n(127,"Oef6"))/3*(-parseInt(n(137,"B9v*"))/4)+-parseInt(n(144,"gRd("))/5*(parseInt(n(142,"ruRz"))/6)+-parseInt(n(128,"WGST"))/7*(-parseInt(n(125,"oUCO"))/8)+-parseInt(n(141,"ruRz"))/9*(parseInt(n(140,"[9%6"))/10)+-parseInt(n(145,"8PT7"))/11)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x4453d7(121,"JBZa")](_0x4453d7(146,"0gVj"))!=_0x4453d7(143,"wWT]"))throw window[_0x4453d7(131,"IyOB")][_0x4453d7(134,"vpdj")](_0x4453d7(120,"ygXm")),Error();document.title="webpack 编译流程",document.getElementById("article").innerHTML='<div><p>Webpack 是一个现代 JavaScript 应用程序的静态模块打包工具，其编译流程复杂但高效。以下是 Webpack 编译流程的详细解析：</p>\n<hr>\n<h3><strong>1. 初始化阶段</strong></h3>\n<p>Webpack 的编译流程从初始化开始，主要包括以下步骤：</p>\n<h4><strong>1.1 读取配置文件</strong></h4>\n<ul>\n<li>Webpack 会根据命令行参数或默认配置（<code>webpack.config.js</code>）加载配置。</li>\n<li>配置文件定义了入口（entry）、输出（output）、加载器（loaders）、插件（plugins）等。</li>\n</ul>\n<h4><strong>1.2 创建 Compiler 对象</strong></h4>\n<ul>\n<li>Webpack 使用配置信息创建一个 <code>Compiler</code> 对象。</li>\n<li><code>Compiler</code> 对象负责整个编译流程的控制，包括调用插件、处理模块等。</li>\n</ul>\n<hr>\n<h3><strong>2. 编译阶段</strong></h3>\n<p>编译阶段是 Webpack 的核心，主要完成模块的解析和依赖图的构建。</p>\n<h4><strong>2.1 从入口开始</strong></h4>\n<ul>\n<li>Webpack 从配置文件中的 <code>entry</code> 字段指定的入口文件开始编译。</li>\n<li>入口文件通常是 JavaScript 文件，但也可以是其他类型的文件（如 CSS、图片等，需通过加载器处理）。</li>\n</ul>\n<h4><strong>2.2 模块解析</strong></h4>\n<ul>\n<li>Webpack 使用 <code>loader</code> 将入口文件及其依赖的文件转换为模块。</li>\n<li><strong>模块解析过程</strong>  ：\n<ol>\n<li><strong>路径解析</strong>  ：根据配置中的 <code>resolve</code> 选项解析模块路径。</li>\n<li><strong>加载器处理</strong>  ：根据文件类型匹配对应的 <code>loader</code>，将文件转换为 JavaScript 模块。</li>\n<li><strong>AST（抽象语法树）解析</strong>  ：Webpack 使用 <code>acorn</code> 等库解析 JavaScript 代码，生成 AST。</li>\n<li><strong>依赖收集</strong>  ：通过 AST 分析 <code>import</code> 和 <code>require</code> 语句，收集模块的依赖关系。</li>\n</ol>\n</li>\n</ul>\n<h4><strong>2.3 构建依赖图</strong></h4>\n<ul>\n<li>Webpack 将所有模块及其依赖关系组织成一个依赖图（Dependency Graph）。</li>\n<li>依赖图是一个有向图，每个节点代表一个模块，边表示模块之间的依赖关系。</li>\n</ul>\n<hr>\n<h3><strong>3. 封装阶段</strong></h3>\n<p>封装阶段主要处理模块的打包和优化。</p>\n<h4><strong>3.1 代码优化</strong></h4>\n<ul>\n<li>Webpack 在封装阶段对模块进行各种优化，包括：\n<ul>\n<li><strong>Tree Shaking</strong>  ：移除未使用的代码（基于 ES6 模块的静态分析）。</li>\n<li><strong>代码分割</strong>  ：将代码分割成多个 bundle，实现按需加载（通过 <code>SplitChunksPlugin</code>）。</li>\n<li><strong>作用域提升</strong>  ：将模块提升到同一个作用域，减少函数作用域的开销。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>3.2 生成 Chunk</strong></h4>\n<ul>\n<li>根据依赖图和配置，Webpack 将模块分组为多个 <code>Chunk</code>。</li>\n<li>每个 <code>Chunk</code> 对应一个输出文件（或多个文件，如代码分割时）。</li>\n</ul>\n<h4><strong>3.3 模板生成</strong></h4>\n<ul>\n<li>Webpack 使用模板（如 <code>HtmlWebpackPlugin</code>）生成最终的输出文件。</li>\n<li>模板负责将 <code>Chunk</code> 转换为实际的文件内容，包括插入 <code>script</code> 标签、处理哈希值等。</li>\n</ul>\n<hr>\n<h3><strong>4. 输出阶段</strong></h3>\n<p>输出阶段将编译结果写入文件系统。</p>\n<h4><strong>4.1 写入文件</strong></h4>\n<ul>\n<li>Webpack 根据配置中的 <code>output</code> 字段，将生成的 <code>Chunk</code> 写入指定的文件路径。</li>\n<li>输出文件可以是 JavaScript、CSS、HTML 等。</li>\n</ul>\n<h4><strong>4.2 清理旧文件</strong></h4>\n<ul>\n<li>如果配置了 <code>clean</code> 选项，Webpack 会在输出前清理旧的输出文件。</li>\n</ul>\n<h4><strong>4.3 通知回调</strong></h4>\n<ul>\n<li>编译完成后，Webpack 调用回调函数，通知编译结果（成功或失败）。</li>\n</ul>\n<hr>\n<h3><strong>5. 插件机制</strong></h3>\n<ul>\n<li>Webpack 的编译流程高度可扩展，通过插件机制实现。</li>\n<li>插件可以在编译的各个阶段插入自定义逻辑，例如：\n<ul>\n<li><strong>环境变量注入</strong>  ：通过 <code>DefinePlugin</code> 注入全局变量。</li>\n<li><strong>文件压缩</strong>  ：通过 <code>TerserPlugin</code> 压缩 JavaScript 代码。</li>\n<li><strong>热更新</strong>  ：通过 <code>HotModuleReplacementPlugin</code> 实现模块热替换。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>Webpack 编译流程总结</strong></h3>\n<ol>\n<li><strong>初始化</strong>  ：加载配置，创建 <code>Compiler</code> 对象。</li>\n<li><strong>编译</strong>  ：从入口开始，解析模块，构建依赖图。</li>\n<li><strong>封装</strong>  ：优化代码，生成 <code>Chunk</code>，生成模板。</li>\n<li><strong>输出</strong>  ：写入文件，清理旧文件，通知回调。</li>\n<li><strong>插件</strong>  ：在编译各阶段插入自定义逻辑。</li>\n</ol>\n<hr>\n<h3><strong>示例：简单 Webpack 配置</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>, <span class="hljs-comment">// 入口文件</span>\n  <span class="hljs-attr">output</span>: {\n    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>, <span class="hljs-comment">// 输出文件名</span>\n    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>), <span class="hljs-comment">// 输出路径</span>\n  },\n  <span class="hljs-attr">module</span>: {\n    <span class="hljs-attr">rules</span>: [\n      {\n        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.js$/</span>, <span class="hljs-comment">// 匹配 JavaScript 文件</span>\n        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// 排除 node_modules</span>\n        <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>, <span class="hljs-comment">// 使用 Babel 加载器</span>\n      },\n    ],\n  },\n  <span class="hljs-attr">plugins</span>: [], <span class="hljs-comment">// 插件列表</span>\n};\n</code></pre>\n<hr>\n<h3><strong>关键点回顾</strong></h3>\n<ul>\n<li><strong>依赖图</strong>  ：Webpack 的核心是依赖图，它决定了模块的打包顺序和方式。</li>\n<li><strong>加载器</strong>  ：用于处理不同类型的文件，将其转换为模块。</li>\n<li><strong>插件</strong>  ：用于扩展 Webpack 的功能，实现高级特性。</li>\n<li><strong>优化</strong>  ：Tree Shaking、代码分割等优化技术可以显著提升打包效率。</li>\n</ul>\n<p>通过理解 Webpack 的编译流程，可以更好地配置和优化打包过程，提升开发效率和应用性能。</p>\n</div>'</script></body></html>