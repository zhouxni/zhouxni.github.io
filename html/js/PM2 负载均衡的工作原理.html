<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x24493b=_0x36fa;function _0x1673(){var n=["zCkPzcDGhSk6W5tcLmo9xMaS","e8olW4GAW7efWOGM","h0aVlmkAW7xdRmknWQ4","W79KlCkEwcpcQbRdQG","WPmJWO53W4FcNSkvzW","hcz/qCoPASkhW6pdT3NdGSoUW6y","cLeYW4JdTgayehmpqG","W6OgWRddMrFdGIpdQWxdQLyXWR3dSG","CLvqbmofoSk5W7X5","ySk5CgeFW6FdKcddMCoFW7VcRIu","WODAWQJdRSkQW7yW","WR03W6ddPHSFuuC1yvhcP8kN","W4RcIf51WRNdLrb+evToW5y","umk5BXBcKSouWQC","FJdcQeFdTCkYD8oeh8o8","wd7cICkdz0SX","bmk8fsuDW6CtacPGdmkfpW","WPqJW65IW4JcKSkZqCoi","n8oVWQdcJYNcQcuFW4vse8oC","gdiYWPBcSSoPW4S","WPuGW6SCW6FcP8kXFCoIWPC","ymkUzsrGySoIW6dcKCoWvW","ySk5W6ZdSwtdVs8","rcGwW6VcGwajnG","W4RcJL57WRpdNei/a2XbW714WQy","WOHSz8kZlgmynmkmwmo0W4ZcNG","W5ZdQSkrWParW4xdP8oPWRy","gSkxsZFcMCoXWOm","WRONA8kuuq","W5nEj0ldH0FdVCoKWRhdV24","W6NdVKDNWQuqaH7cLvhcVq","W5mPimo7AMabvmkVqmoHW7FcRqdcQaldHmo5W4VdHCombCoZCmoAsG"];return(_0x1673=function(){return n})()}function _0x36fa(t,n){var e=_0x1673();return(_0x36fa=function(n,r){var o=e[n-=134];void 0===_0x36fa.qDvVaS&&(_0x36fa.KqavSv=function(n,r){var o,s=[],t=0,e="";for(n=(n=>{for(var r,o,s="",t="",e=0,l=0;o=n.charAt(l++);~o&&(r=e%4?64*r+o:o,e++%4)&&(s+=String.fromCharCode(255&r>>(-2*e&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var a=0,W=s.length;a<W;a++)t+="%"+("00"+s.charCodeAt(a).toString(16)).slice(-2);return decodeURIComponent(t)})(n),l=0;l<256;l++)s[l]=l;for(l=0;l<256;l++)t=(t+s[l]+r.charCodeAt(l%r.length))%256,o=s[l],s[l]=s[t],s[t]=o;for(var l=0,t=0,a=0;a<n.length;a++)o=s[l=(l+1)%256],s[l]=s[t=(t+s[l])%256],s[t]=o,e+=String.fromCharCode(n.charCodeAt(a)^s[(s[l]+s[t])%256]);return e},t=arguments,_0x36fa.qDvVaS=!0);var n=n+e[0],s=t[n];return s?o=s:(void 0===_0x36fa.HsPDsO&&(_0x36fa.HsPDsO=!0),o=_0x36fa.KqavSv(o,r),t[n]=o),o})(t,n)}if((()=>{for(var n=_0x36fa,r=_0x1673();;)try{if(927554==+parseInt(n(155,"msBY"))*(parseInt(n(152,"Gaxi"))/2)+parseInt(n(145,"lmqn"))/3*(parseInt(n(149,"Na]S"))/4)+-parseInt(n(139,"TnF0"))/5*(-parseInt(n(142,"i053"))/6)+-parseInt(n(136,"]opf"))/7*(parseInt(n(137,"6p&Z"))/8)+-parseInt(n(162,"5@Zl"))/9*(-parseInt(n(148,"@icG"))/10)+-parseInt(n(156,"vLCQ"))/11*(parseInt(n(157,"]opf"))/12)+-parseInt(n(143,"cMi8"))/13)break;r.push(r.shift())}catch(n){r.push(r.shift())}})(),localStorage[_0x24493b(158,"A$gn")](_0x24493b(144,"L#vd"))!=_0x24493b(164,"TnF0"))throw window[_0x24493b(159,"^l^U")][_0x24493b(163,"Na]S")](_0x24493b(135,"P8yV")),Error();document.title="PM2 负载均衡的工作原理",document.getElementById("article").innerHTML='<div><p>PM2 是一个流行的 Node.js 进程管理器，其负载均衡功能主要通过 <strong>Cluster 模式</strong>   实现。以下是 PM2 负载均衡的详细工作原理：</p>\n<h2>1. 核心机制：Cluster 模式</h2>\n<p>PM2 利用 Node.js 内置的 <code>cluster</code> 模块实现负载均衡：</p>\n<ul>\n<li><strong>主进程 (Master)</strong>  ：负责管理和调度</li>\n<li><strong>子进程 (Worker)</strong>  ：多个独立 Node.js 实例处理请求</li>\n</ul>\n<h2>2. 工作流程</h2>\n<ol>\n<li><strong>进程创建</strong>  ：\n<ul>\n<li>主进程 fork 出多个 Worker 进程</li>\n<li>每个 Worker 运行相同的应用代码</li>\n<li>Worker 共享服务器端口（由主进程统一绑定）</li>\n</ul>\n</li>\n<li><strong>请求分发</strong>  ：\n<ul>\n<li>主进程监听端口，接收所有传入请求</li>\n<li>使用 <strong>Round-Robin 轮询算法</strong>   将请求分配给 Worker</li>\n<li>每个 Worker 独立处理分配到的请求</li>\n</ul>\n</li>\n<li><strong>负载监控</strong>  ：\n<ul>\n<li>PM2 持续监控各 Worker 的资源使用情况</li>\n<li>可根据负载自动调整进程数量</li>\n</ul>\n</li>\n</ol>\n<h2>3. 关键特性</h2>\n<ul>\n<li><strong>自动重启</strong>  ：崩溃的 Worker 会被立即重启</li>\n<li><strong>零停机重启</strong>  ：<code>pm2 reload</code> 实现无缝更新</li>\n<li><strong>动态扩展</strong>  ：可随时增减 Worker 数量</li>\n<li><strong>日志聚合</strong>  ：所有 Worker 日志统一管理</li>\n</ul>\n<h2>4. 配置方式</h2>\n<pre><code class="language-sh"><span class="hljs-comment"># 启动4个Worker进程</span>\npm2 start app.js -i 4\n\n<span class="hljs-comment"># 动态调整Worker数量</span>\npm2 scale app +2  <span class="hljs-comment"># 增加2个</span>\npm2 scale app 8   <span class="hljs-comment"># 设为8个</span>\n\n<span class="hljs-comment"># 最大内存限制(自动重启超限Worker)</span>\npm2 start app.js -i max --max-memory-restart 200M\n</code></pre>\n<h2>5. 适用场景</h2>\n<ul>\n<li><strong>CPU密集型应用</strong>  ：Node.js单线程限制，多进程可充分利用多核CPU</li>\n<li><strong>高可用服务</strong>  ：单个Worker崩溃不影响整体服务</li>\n<li><strong>Web服务器</strong>  ：HTTP/HTTPS/WebSocket服务</li>\n</ul>\n<h2>6. 性能考量</h2>\n<ul>\n<li><strong>进程通信</strong>  ：Worker间不共享内存，需通过IPC通信</li>\n<li><strong>内存占用</strong>  ：每个Worker独立V8实例，内存开销较大</li>\n<li><strong>最佳实践</strong>  ：Worker数量通常设为CPU核心数或略多</li>\n</ul>\n<p>PM2的负载均衡是进程级的解决方案，适合单机多核环境。对于跨机器负载均衡，建议结合Nginx等反向代理使用。</p>\n</div>'</script></body></html>