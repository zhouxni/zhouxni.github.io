<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2f24(){var s=["WQdcImkslCoLWOtcU8kk","W7HHW5NcISoOn0RcHmkCWORdOey","fX7cSumDWQRcQNxcN1yFrCoV","btvbW4VdMg4pDZlcSuXtfq","yCobab4YW6FcVq","W5m6W5FdPmoMEmkbgxbBf8o/","ASkxCCorW4n5wWRcIG","W5rnW4qAW6lcQaG","i8oWWOflW5ddMWymhSkaW5ldTSol","WODrjeKArL1g","fXVcTKqEWQZdRMpcNNCkFq","WR5xWPZdQxtcN8kAWOnitmougG","jCoZW7ddNmoFF8kv","WRBcO8oFWRCo","W4JdNNtdTSkCW5hcGYG","W7NdJSkKb8oqW6tdL8odW53dUwq0WOddJgVdP2pcRCoDW7NcKhfPgSkuDq","WQdcJSoIt8kvW6VcTmkCW7/dGwmR","W5OZW5tdPSoJECk/juX+gSoA","W48QmmoWW58VWPLDumohpt1HWOC","WQhdSCkqjCo5l0VdTCkHe1DJW4a","iGPXW7pdPCoSjmki","zJyuxmkXdSkpsajjW5fCW5D4","W7vGW69gCWFdQq","WQVdS315WRtdVLVcG8oIW43cJX7dOa","xwSuWPNcMtjtuq","o8o9W6bpDSklWQC","WP0dW4WqoCoKW5y","hSkDBSoUWOZcGYTRCMtdQalcHG"];return(_0x2f24=function(){return s})()}var _0x42e5bf=_0x4e0d;function _0x4e0d(t,s){var p=_0x2f24();return(_0x4e0d=function(s,n){var a=p[s-=332];void 0===_0x4e0d.xiRbpX&&(_0x4e0d.HnitAw=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,c=0;a=s.charAt(c++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,o=l.length;e<o;e++)t+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)t=(t+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[t],l[t]=a;for(var c=0,t=0,e=0;e<s.length;e++)a=l[c=(c+1)%256],l[c]=l[t=(t+l[c])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(e)^l[(l[c]+l[t])%256]);return p},t=arguments,_0x4e0d.xiRbpX=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x4e0d.zPXsdj&&(_0x4e0d.zPXsdj=!0),a=_0x4e0d.HnitAw(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x4e0d,n=_0x2f24();;)try{if(986012==-parseInt(s(350,"GJ6i"))*(parseInt(s(343,"I9]K"))/2)+parseInt(s(340,"&zd5"))/3*(-parseInt(s(336,"Occl"))/4)+parseInt(s(341,"mXAZ"))/5*(parseInt(s(339,"SsYP"))/6)+-parseInt(s(349,"mXAZ"))/7+-parseInt(s(353,"no@D"))/8*(-parseInt(s(334,"]*[a"))/9)+parseInt(s(358,"rAPr"))/10+-parseInt(s(357,"fuu5"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x42e5bf(337,"QLE!")](_0x42e5bf(345,"GMc6"))!=_0x42e5bf(352,"*b2l"))throw window[_0x42e5bf(335,"HH)$")][_0x42e5bf(351,"s3Xa")](_0x42e5bf(354,"SsYP")),Error();document.title="typescript 枚举",document.getElementById("article").innerHTML='<div><h3>TypeScript 枚举类型详解</h3>\n<p>TypeScript 的枚举（Enum）是一种特殊的类型，用于定义一组命名的常量。枚举提供了一种将一组相关的常量组织在一起的方式，使代码更加清晰和易于维护。以下是 TypeScript 枚举类型的详细解析：</p>\n<hr>\n<h4>1. <strong>枚举的定义</strong></h4>\n<p>枚举使用 <code>enum</code> 关键字定义，可以包含一组数值或字符串常量。</p>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> {\n  <span class="hljs-title class_">Up</span>,    <span class="hljs-comment">// 默认值为 0</span>\n  <span class="hljs-title class_">Down</span>,  <span class="hljs-comment">// 默认值为 1</span>\n  <span class="hljs-title class_">Left</span>,  <span class="hljs-comment">// 默认值为 2</span>\n  <span class="hljs-title class_">Right</span>  <span class="hljs-comment">// 默认值为 3</span>\n}\n</code></pre>\n<hr>\n<h4>2. <strong>数值枚举</strong></h4>\n<ul>\n<li><strong>默认行为</strong>  ：数值枚举的成员默认从 0 开始递增。</li>\n<li><strong>自定义值</strong>  ：可以为枚举成员指定初始值，后续成员会依次递增。</li>\n</ul>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Response</span> {\n  <span class="hljs-title class_">No</span> = <span class="hljs-number">0</span>,\n  <span class="hljs-title class_">Yes</span> = <span class="hljs-number">1</span>\n}\n\n<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span> {\n  <span class="hljs-title class_">Active</span> = <span class="hljs-number">1</span>,\n  <span class="hljs-title class_">Inactive</span>,  <span class="hljs-comment">// 值为 2</span>\n  <span class="hljs-title class_">Pending</span>    <span class="hljs-comment">// 值为 3</span>\n}\n</code></pre>\n<ul>\n<li><strong>反向映射</strong>  ：数值枚举在编译后会同时生成从值到名称的反向映射。</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> {\n  <span class="hljs-title class_">Red</span> = <span class="hljs-number">1</span>,\n  <span class="hljs-title class_">Green</span>,\n  <span class="hljs-title class_">Blue</span>\n}\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>);    <span class="hljs-comment">// 输出: 1</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Color</span>[<span class="hljs-number">1</span>]);     <span class="hljs-comment">// 输出: &quot;Red&quot;</span>\n</code></pre>\n<hr>\n<h4>3. <strong>字符串枚举</strong></h4>\n<ul>\n<li><strong>特点</strong>  ：字符串枚举没有反向映射，成员必须显式初始化。</li>\n<li><strong>用途</strong>  ：适用于需要更具可读性和安全性的场景。</li>\n</ul>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> {\n  <span class="hljs-title class_">Up</span> = <span class="hljs-string">&quot;UP&quot;</span>,\n  <span class="hljs-title class_">Down</span> = <span class="hljs-string">&quot;DOWN&quot;</span>,\n  <span class="hljs-title class_">Left</span> = <span class="hljs-string">&quot;LEFT&quot;</span>,\n  <span class="hljs-title class_">Right</span> = <span class="hljs-string">&quot;RIGHT&quot;</span>\n}\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Direction</span>.<span class="hljs-property">Up</span>);    <span class="hljs-comment">// 输出: &quot;UP&quot;</span>\n</code></pre>\n<hr>\n<h4>4. <strong>异构枚举</strong></h4>\n<ul>\n<li><strong>特点</strong>  ：枚举成员可以同时包含数值和字符串，但不建议使用，因为会失去反向映射和部分类型安全。</li>\n</ul>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">MixedEnum</span> {\n  <span class="hljs-title class_">No</span> = <span class="hljs-number">0</span>,\n  <span class="hljs-title class_">Yes</span> = <span class="hljs-string">&quot;YES&quot;</span>\n}\n</code></pre>\n<hr>\n<h4>5. <strong>常量枚举</strong></h4>\n<ul>\n<li><strong>定义</strong>  ：使用 <code>const enum</code> 关键字，编译时会内联枚举的定义。</li>\n<li><strong>优点</strong>  ：减少运行时开销，因为枚举在编译后会被直接替换为对应的值。</li>\n<li><strong>限制</strong>  ：只能在属性、索引访问表达式、导入/导出的命名空间或类型查询中使用。</li>\n</ul>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> {\n  <span class="hljs-title class_">Up</span>,\n  <span class="hljs-title class_">Down</span>,\n  <span class="hljs-title class_">Left</span>,\n  <span class="hljs-title class_">Right</span>\n}\n\n<span class="hljs-keyword">let</span> <span class="hljs-attr">dir</span>: <span class="hljs-title class_">Direction</span> = <span class="hljs-title class_">Direction</span>.<span class="hljs-property">Up</span>;\n</code></pre>\n<p>编译后：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> dir = <span class="hljs-number">0</span> <span class="hljs-comment">/* Up */</span>;\n</code></pre>\n<hr>\n<h4>6. <strong>枚举成员的类型</strong></h4>\n<ul>\n<li>枚举成员的类型是枚举类型本身。</li>\n<li>枚举类型可以与其他类型联合使用。</li>\n</ul>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> {\n  <span class="hljs-title class_">Red</span>,\n  <span class="hljs-title class_">Green</span>,\n  <span class="hljs-title class_">Blue</span>\n}\n\n<span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Green</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">printColor</span>(<span class="hljs-params"><span class="hljs-attr">color</span>: <span class="hljs-title class_">Color</span></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(color);\n}\n\n<span class="hljs-title function_">printColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>);    <span class="hljs-comment">// 输出: 0</span>\n</code></pre>\n<hr>\n<h4>7. <strong>使用枚举的最佳实践</strong></h4>\n<ul>\n<li><strong>可读性</strong>  ：使用枚举可以提高代码的可读性和可维护性，避免使用魔术数字或字符串。</li>\n<li><strong>类型安全</strong>  ：枚举提供了类型安全，防止无效值被赋值。</li>\n<li><strong>性能考虑</strong>  ：在性能敏感的场景中，考虑使用 <code>const enum</code> 或对象字面量来替代传统枚举。</li>\n<li><strong>避免过度使用</strong>  ：不要为简单的布尔值或少量状态使用枚举，可以考虑使用联合类型或字面量类型。</li>\n</ul>\n<hr>\n<h4>8. <strong>枚举与联合类型的比较</strong></h4>\n<ul>\n<li><strong>枚举</strong>  ：适用于一组固定的、相关的常量，提供了更好的可读性和类型安全。</li>\n<li><strong>联合类型</strong>  ：适用于简单的、不相关的常量集合，更加灵活。</li>\n</ul>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// 使用枚举</span>\n<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span> {\n  <span class="hljs-title class_">Active</span>,\n  <span class="hljs-title class_">Inactive</span>\n}\n\n<span class="hljs-comment">// 使用联合类型</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">StatusUnion</span> = <span class="hljs-string">&quot;active&quot;</span> | <span class="hljs-string">&quot;inactive&quot;</span>;\n</code></pre>\n<hr>\n<h4>9. <strong>枚举的编译结果</strong></h4>\n<ul>\n<li><strong>数值枚举</strong>  ：编译后会生成一个双向映射的对象。</li>\n<li><strong>字符串枚举</strong>  ：编译后会生成一个单向映射的对象。</li>\n<li><strong>常量枚举</strong>  ：编译后会内联替换为对应的值。</li>\n</ul>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> {\n  <span class="hljs-title class_">Up</span>,\n  <span class="hljs-title class_">Down</span>\n}\n</code></pre>\n<p>编译后：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Direction</span>;\n(<span class="hljs-keyword">function</span> (<span class="hljs-params">Direction</span>) {\n  <span class="hljs-title class_">Direction</span>[<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;Up&quot;</span>] = <span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Up&quot;</span>;\n  <span class="hljs-title class_">Direction</span>[<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&quot;Down&quot;</span>] = <span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Down&quot;</span>;\n})(<span class="hljs-title class_">Direction</span> || (<span class="hljs-title class_">Direction</span> = {}));\n</code></pre>\n<hr>\n<h4>10. <strong>总结</strong></h4>\n<ul>\n<li><strong>枚举</strong>  是 TypeScript 中定义一组命名常量的强大工具。</li>\n<li><strong>数值枚举</strong>  和<strong>字符串枚举</strong>  各有优缺点，应根据具体需求选择。</li>\n<li><strong>常量枚举</strong>  提供了更好的性能，但使用场景有限。</li>\n<li>在设计 API 或库时，考虑枚举对编译结果和运行时性能的影响。</li>\n</ul>\n<p>通过合理使用枚举，可以使代码更加清晰、易于维护，并提高类型安全性。</p>\n</div>'</script></body></html>