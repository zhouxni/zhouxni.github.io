<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3f50(){var s=["dSolACkSxSo+iG","W79GWRVdI1H+pG","W6G7iKGF","pSofu8k1WOtcGSoA","zCoRrCk9WPldVCkVtx7dO8owf35zj8kQoHBdVquSWPmJygfD","WRKiW5jdaSoopMq","W70mW6dcHa59bJBcVMm5","WO7cJg46W6XkW7vKsIG","uZBcGmkJWO16CSkmj8ogW4pdTmo2","AX7cU34IW63dNWaZE8kGWP/dKa","WR0om8olW4CWmrXX","WQWMsthcM8kJgveinCkrDq","W47cH8oKvGlcRmo9","jLHMWQXJW41PWPhcVsG","d2KJWOuWyHjlaCkZW43dTSoP","W4v4lCkuWO3cVgiixSowW4a","Amk5W6dcQConcSomWP0GACkqW5BdGq","W6/cICoFW4nqWPtcICkE","qSoyWRZdU8osWPO4jeS","W6StD8kBW49VW4iMWR8","pmkxWOjFcgNdU17cU8k0wCoDW5u","xI3dJg5muCoQbmoI","W7NdJmknWPhdR0ZcQmoY","WO1zWRRdLK5ilWlcJG","WOG9WQ7cOCk7WO1MlWDMW4ybWQW","W64AD8ogWRSFW6S3WPpcPGFcIG","WRhdN8kjWPOvW4ZdL8k2vdCEWPJdMq"];return(_0x3f50=function(){return s})()}function _0x7dfa(l,s){var o=_0x3f50();return(_0x7dfa=function(s,n){var a=o[s-=377];void 0===_0x7dfa.zpEsfa&&(_0x7dfa.aNseZG=function(s,n){var a,t=[],l=0,o="";for(s=(s=>{for(var n,a,t="",l="",o=0,p=0;a=s.charAt(p++);~a&&(n=o%4?64*n+a:a,o++%4)&&(t+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,r=t.length;e<r;e++)l+="%"+("00"+t.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)l=(l+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[l],t[l]=a;for(var p=0,l=0,e=0;e<s.length;e++)a=t[p=(p+1)%256],t[p]=t[l=(l+t[p])%256],t[l]=a,o+=String.fromCharCode(s.charCodeAt(e)^t[(t[p]+t[l])%256]);return o},l=arguments,_0x7dfa.zpEsfa=!0);var s=s+o[0],t=l[s];return t?a=t:(void 0===_0x7dfa.HpEwyx&&(_0x7dfa.HpEwyx=!0),a=_0x7dfa.aNseZG(a,n),l[s]=a),a})(l,s)}var _0x1a9209=_0x7dfa;if((()=>{for(var s=_0x7dfa,n=_0x3f50();;)try{if(831262==-parseInt(s(392,"(z^E"))*(-parseInt(s(391,"*)xI"))/2)+-parseInt(s(403,"^0&5"))/3*(-parseInt(s(382,"5fLE"))/4)+parseInt(s(387,"[P7R"))/5+parseInt(s(395,"*Qdp"))/6*(parseInt(s(384,"b25R"))/7)+-parseInt(s(397,"%GYX"))/8+parseInt(s(399,"WJn5"))/9+parseInt(s(380,"ZtiD"))/10*(-parseInt(s(379,"7%oE"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1a9209(400,"&#fj")](_0x1a9209(396,"7%oE"))!=_0x1a9209(402,"zYX$"))throw window[_0x1a9209(390,"WJn5")][_0x1a9209(385,"FuX2")](_0x1a9209(377,"^0&5")),Error();document.title="IntersectionObserver 配置参数",document.getElementById("article").innerHTML='<div><p><code>IntersectionObserver</code> 是浏览器提供的用于监听元素与其祖先元素或视口（viewport）交叉状态的API，常用于懒加载、无限滚动、曝光统计等场景。其配置参数（<code>options</code>）决定了监听的具体行为，以下是详细解析：</p>\n<h3>核心配置参数</h3>\n<h4>1. <strong><code>root</code></strong></h4>\n<ul>\n<li><strong>类型</strong>   ：<code>Element</code> 或 <code>Document</code>（可选）</li>\n<li><strong>作用</strong>   ：指定监听的根元素（祖先元素）。若未指定，则默认使用浏览器视口。</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> root = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;scroll-container&quot;</span>);\n<span class="hljs-keyword">const</span> options = { root }; <span class="hljs-comment">// 监听目标元素与scroll-container的交叉状态</span>\n</code></pre>\n</li>\n</ul>\n<h4>2. <strong><code>rootMargin</code></strong></h4>\n<ul>\n<li><strong>类型</strong>   ：字符串（类似CSS的margin值）</li>\n<li><strong>默认值</strong>   ：<code>\'0px 0px 0px 0px\'</code></li>\n<li><strong>作用</strong>   ：扩展或缩小根元素的边界框（bounding box），影响交叉检测的范围。</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> options = {\n  <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">&quot;100px 0px&quot;</span>, <span class="hljs-comment">// 上下各扩展100px的检测范围</span>\n};\n</code></pre>\n</li>\n</ul>\n<h4>3. <strong><code>threshold</code></strong></h4>\n<ul>\n<li>\n<p><strong>类型</strong>   ：<code>number</code> 或 <code>number[]</code></p>\n</li>\n<li>\n<p><strong>默认值</strong>   ：<code>0</code></p>\n</li>\n<li>\n<p><strong>作用</strong>   ：指定目标元素与根元素交叉比例达到多少时触发回调。</p>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> options = {\n  <span class="hljs-attr">threshold</span>: <span class="hljs-number">0.5</span>, <span class="hljs-comment">// 目标元素50%可见时触发回调</span>\n};\n\n<span class="hljs-comment">// 或监听多个阈值</span>\n<span class="hljs-keyword">const</span> options = {\n  <span class="hljs-attr">threshold</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.75</span>, <span class="hljs-number">1</span>], <span class="hljs-comment">// 每次可见度变化25%时触发回调</span>\n};\n</code></pre>\n</li>\n</ul>\n<h3>配置组合示例</h3>\n<h4>监听元素进入视口（懒加载场景）</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> options = {\n  <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">&quot;200px 0px&quot;</span>, <span class="hljs-comment">// 提前200px触发，优化用户体验</span>\n  <span class="hljs-attr">threshold</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 元素一进入视口就触发</span>\n};\n</code></pre>\n<h4>监听元素完全可见（曝光统计）</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> options = {\n  <span class="hljs-attr">threshold</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 元素100%可见时触发</span>\n};\n</code></pre>\n<h4>监听元素可见度变化（进度条更新）</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> options = {\n  <span class="hljs-attr">threshold</span>: <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">101</span> }, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> i / <span class="hljs-number">100</span>), <span class="hljs-comment">// 0%~100%每1%触发一次</span>\n};\n</code></pre>\n<h3>使用注意事项</h3>\n<ol>\n<li>\n<p><strong>性能考量</strong>   ：</p>\n<ul>\n<li>频繁触发的阈值（如<code>threshold: [0.1, 0.2, ...]</code>）会增加回调执行次数，可能影响性能。</li>\n<li>建议根据实际需求设置合理的阈值，避免过细的粒度。</li>\n</ul>\n</li>\n<li>\n<p><strong>交叉状态判断</strong>   ：</p>\n<ul>\n<li>回调中的<code>isIntersecting</code>属性表示当前是否交叉，但最终状态需结合<code>threshold</code>判断。</li>\n<li>当元素完全离开根元素时，<code>isIntersecting</code>为<code>false</code>，但回调仍会触发。</li>\n</ul>\n</li>\n<li>\n<p><strong>兼容性</strong>   ：</p>\n<ul>\n<li>主流浏览器均支持，但IE不支持。</li>\n<li>可使用<a href="https://github.com/w3c/IntersectionObserver/tree/main/polyfill" target="_blank">polyfill</a>提供兼容性。</li>\n</ul>\n</li>\n<li>\n<p><strong>典型场景</strong>   ：</p>\n<ul>\n<li>图片懒加载：元素进入视口时加载图片。</li>\n<li>无限滚动：监听底部元素，接近视口时加载更多内容。</li>\n<li>滚动动画：根据元素可见度触发CSS动画。</li>\n</ul>\n</li>\n</ol>\n<h3>完整使用示例</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 目标元素</span>\n<span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;my-element&quot;</span>);\n\n<span class="hljs-comment">// 配置：视口为根元素，提前100px触发</span>\n<span class="hljs-keyword">const</span> options = {\n  <span class="hljs-attr">root</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 默认使用视口</span>\n  <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">&quot;100px 0px&quot;</span>,\n  <span class="hljs-attr">threshold</span>: <span class="hljs-number">0</span>,\n};\n\n<span class="hljs-comment">// 创建观察者实例</span>\n<span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries, observer</span>) =&gt;</span> {\n  entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> {\n    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {\n      <span class="hljs-comment">// 元素进入视口时执行</span>\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;元素进入视口&quot;</span>);\n\n      <span class="hljs-comment">// 执行懒加载逻辑</span>\n      <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span> === <span class="hljs-string">&quot;IMG&quot;</span>) {\n        entry.<span class="hljs-property">target</span>.<span class="hljs-property">src</span> = entry.<span class="hljs-property">target</span>.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>;\n      }\n\n      <span class="hljs-comment">// 停止监听（只触发一次）</span>\n      observer.<span class="hljs-title function_">unobserve</span>(entry.<span class="hljs-property">target</span>);\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-comment">// 元素离开视口时执行</span>\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;元素离开视口&quot;</span>);\n    }\n  });\n}, options);\n\n<span class="hljs-comment">// 启动监听</span>\nobserver.<span class="hljs-title function_">observe</span>(target);\n\n<span class="hljs-comment">// 停止监听所有元素</span>\n<span class="hljs-comment">// observer.disconnect();</span>\n</code></pre>\n<h3>配置参数对照表</h3>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>默认值</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>root</code></td>\n<td>Element 或 Document</td>\n<td>null（视口）</td>\n<td>指定监听的根元素（祖先元素）</td>\n</tr>\n<tr>\n<td><code>rootMargin</code></td>\n<td>字符串</td>\n<td>\'0px 0px 0px 0px\'</td>\n<td>扩展或缩小根元素的检测边界</td>\n</tr>\n<tr>\n<td><code>threshold</code></td>\n<td>number 或 number[]</td>\n<td>0</td>\n<td>指定触发回调的交叉比例阈值（0表示刚进入，1表示完全可见）</td>\n</tr>\n</tbody>\n</table>\n<p>合理配置<code>IntersectionObserver</code>可以精准捕获元素的可见性变化，同时避免频繁的DOM操作，是现代前端性能优化的重要工具。</p>\n</div>'</script></body></html>