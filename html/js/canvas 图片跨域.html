<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2fb8fe=_0x4392;function _0x4392(p,s){var c=_0x4b79();return(_0x4392=function(s,n){var a=c[s-=196];void 0===_0x4392.CvzUiz&&(_0x4392.tcxttY=function(s,n){var a,l=[],p=0,c="";for(s=(s=>{for(var n,a,l="",p="",c=0,t=0;a=s.charAt(t++);~a&&(n=c%4?64*n+a:a,c++%4)&&(l+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,e=l.length;o<e;o++)p+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(p)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)p=(p+l[t]+n.charCodeAt(t%n.length))%256,a=l[t],l[t]=l[p],l[p]=a;for(var t=0,p=0,o=0;o<s.length;o++)a=l[t=(t+1)%256],l[t]=l[p=(p+l[t])%256],l[p]=a,c+=String.fromCharCode(s.charCodeAt(o)^l[(l[t]+l[p])%256]);return c},p=arguments,_0x4392.CvzUiz=!0);var s=s+c[0],l=p[s];return l?a=l:(void 0===_0x4392.yEwabR&&(_0x4392.yEwabR=!0),a=_0x4392.tcxttY(a,n),p[s]=a),a})(p,s)}if((()=>{for(var s=_0x4392,n=_0x4b79();;)try{if(370050==-parseInt(s(203,"QguE"))*(-parseInt(s(221,"6k#p"))/2)+-parseInt(s(223,"627T"))/3*(parseInt(s(201,"@oSO"))/4)+parseInt(s(206,"9rX0"))/5*(-parseInt(s(210,"#CaG"))/6)+parseInt(s(222,"fnbv"))/7+parseInt(s(197,"#ssp"))/8+parseInt(s(209,"#CaG"))/9*(-parseInt(s(218,"p1RC"))/10)+parseInt(s(196,"LU#k"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x2fb8fe(215,"Hj6(")](_0x2fb8fe(220,"*l1#"))!=_0x2fb8fe(214,"#CaG"))throw window[_0x2fb8fe(213,"ZSf*")][_0x2fb8fe(199,"C[mJ")](_0x2fb8fe(216,"w(9f")),Error();function _0x4b79(){var s=["W5GGCJb7W6pcPCkaWQBdQmk3oSk3DCo5zCoqW7NcJCoUqCoyqmkpxmk7","BgRcT8ooEYFcHge","zeD9ACk2FsZdQq","W5OJjCo8W5ZcPXfdeG","W58+WPjJegKJsCkF","BM7dISkbqqFcGh3cLXu","W6KnWOWQWQZcOb/cQ8oIfmkBEbW","zMSEWRmZWOdcTW","WRlcVmkSW7/cHmoLW4qTW5myWPiKW4e","WQVdGmoEr8k4W6qmtSoPW6W5WRpcUq","W6OaW65QW7VdHwJcSG","A8k7WORcTqddSSkW","iWPEzCoLWRtcICkec8k3w1T2","vMOFW7RcRSo5xmk5WPGpnCoFWOa","BdhcLSorvslcGq","lWNdUmk6W4ldTxbkWOi","pmofqmopW6FcRMDPWQ/cGG","dSoHp8k2mmojhmoqfbX4w8oG","WOBcGCokEGFcQ8o6ya","W58SjSkLWPxdHwf4aNfosf4","BMpdJCkmgvNdUKtcJHxcRKZcGa","WQ4xsCoNs8kLmfJcOSkFk3dcRG","WQ4Br8oKtCkPBvZcVmkeefW","yCoqWQtdRCk8W5e1WRyZWQpdR8o0","WP9ZteWll8kWW58kW6VcGJe9","W6ldT8ohxcpcISkdWRK","W69BdCkHbG","nmoUW6FcUmo4fdu"];return(_0x4b79=function(){return s})()}document.title="canvas 图片跨域",document.getElementById("article").innerHTML='<div><p>在 Web 开发中，使用 HTML5 的 canvas 元素生成图片时，如果 canvas 中加载了来自不同源的图像或其他资源，就可能会遇到跨域问题。当 canvas 中包含了跨域内容后，尝试调用 <code>toDataURL()</code> 方法导出图像时，会抛出安全错误，导致无法生成图片。</p>\n<h3>跨域问题的原因</h3>\n<p>浏览器出于安全考虑，实施了同源策略（Same-Origin Policy）。这意味着如果你的页面来自一个域（例如 <code>https://yourwebsite.com</code>），它不能直接访问不同域（例如 <code>https://anotherwebsite.com</code>）的资源，包括图片。当 canvas 尝试绘制跨域图片时，会被标记为“已污染”，从而禁止任何导出操作。</p>\n<h3>解决方案</h3>\n<ol>\n<li><strong>使用 CORS（跨域资源共享）</strong>\n<ul>\n<li><strong>服务器端设置</strong>  ：确保跨域图片的服务器设置了适当的 CORS 头，以允许你的域名访问图片资源。服务器需要返回 <code>Access-Control-Allow-Origin</code> 头，其值可以是你的网站域名，或者 <code>*</code>（允许所有域名访问，但不太安全）。</li>\n<li><strong>客户端设置</strong>  ：在 JavaScript 中，以 CORS 模式加载图像。例如：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();\nimg.<span class="hljs-property">crossOrigin</span> = <span class="hljs-string">&quot;anonymous&quot;</span>; <span class="hljs-comment">// 设置 CORS 模式</span>\nimg.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;https://example.com/image.png&quot;</span>; <span class="hljs-comment">// 跨域图像来源</span>\nimg.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;canvas&#x27;</span>);\n  <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&#x27;2d&#x27;</span>);\n  ctx.<span class="hljs-title function_">drawImage</span>(img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\n  <span class="hljs-keyword">const</span> dataURL = canvas.<span class="hljs-title function_">toDataURL</span>(); <span class="hljs-comment">// 不会抛出错误</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dataURL);\n};\nimg.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;图像加载失败&#x27;</span>);\n};\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>使用代理服务器</strong>\n<ul>\n<li>\n<p>如果无法控制图像服务器的 CORS 设置，可以通过设置一个代理服务器来转发请求。代理服务器可以在同一域下提供图像，从而避免跨域问题。</p>\n</li>\n<li>\n<p>示例（使用 Node.js 和 Express）：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);\n<span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;request&#x27;</span>);\n<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();\n\napp.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/proxy&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> imageUrl = req.<span class="hljs-property">query</span>.<span class="hljs-property">url</span>;\n  <span class="hljs-title function_">request</span>(imageUrl).<span class="hljs-title function_">pipe</span>(res);\n});\n\napp.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Proxy server is running on http://localhost:3000&#x27;</span>);\n});\n</code></pre>\n<p>在前端代码中使用代理：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();\nimg.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;http://localhost:3000/proxy?url=https://example.com/image.png&quot;</span>;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>将图像嵌入到 HTML 中</strong>\n<ul>\n<li>另一种方法是在 HTML 中直接嵌入图像数据（Base64 编码），这可以完全避免跨域问题。但这种方法不适合大图片，因为会显著增加 HTML/JS 文件的大小。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();\nimg.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...&quot;</span>;\nimg.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;canvas&#x27;</span>);\n  <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&#x27;2d&#x27;</span>);\n  ctx.<span class="hljs-title function_">drawImage</span>(img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\n  <span class="hljs-keyword">const</span> dataURL = canvas.<span class="hljs-title function_">toDataURL</span>(); <span class="hljs-comment">// 不会抛出错误</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dataURL);\n};\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>使用同源资源</strong>\n<ul>\n<li>确保所有加载到 canvas 中的资源都来自同一域。这是最简单的解决方案，但在实际应用中可能受到限制。</li>\n</ul>\n</li>\n</ol>\n<h3>关键点总结</h3>\n<ul>\n<li><strong>CORS 是首选方案</strong>  ：因为它最简单，性能也最好。如果无法使用 CORS，则需要考虑其他方案。</li>\n<li><strong>设置 <code>crossOrigin</code> 属性</strong>  ：在加载跨域图像时，必须设置 <code>&lt;img&gt;</code> 元素的 <code>crossOrigin</code> 属性为 <code>&quot;anonymous&quot;</code> 或 <code>&quot;use-credentials&quot;</code>（如果需要发送 cookie）。</li>\n<li><strong>代理服务器</strong>  ：适用于无法控制图像服务器 CORS 设置的情况。</li>\n<li><strong>Base64 编码</strong>  ：适用于小图片，但会增加文件大小。</li>\n<li><strong>同源资源</strong>  ：最简单的解决方案，但可能受到实际应用的限制。</li>\n</ul>\n</div>'</script></body></html>