<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x19b5(t,s){var p=_0x9dd3();return(_0x19b5=function(s,n){var a=p[s-=321];void 0===_0x19b5.THiSPc&&(_0x19b5.QKiguE=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=l.length;c<o;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[t],l[t]=a;for(var e=0,t=0,c=0;c<s.length;c++)a=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[t])%256]);return p},t=arguments,_0x19b5.THiSPc=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x19b5.wJykQL&&(_0x19b5.wJykQL=!0),a=_0x19b5.QKiguE(a,n),t[s]=a),a})(t,s)}var _0x343910=_0x19b5;if((()=>{for(var s=_0x19b5,n=_0x9dd3();;)try{if(674081==-parseInt(s(348,"vl3O"))*(parseInt(s(337,"^3TG"))/2)+parseInt(s(341,"k%%G"))/3*(-parseInt(s(346,"t^MI"))/4)+-parseInt(s(344,"!8OP"))/5+parseInt(s(347,"H3WY"))/6*(parseInt(s(342,"2(dM"))/7)+parseInt(s(343,"VhEX"))/8+parseInt(s(339,"VhEX"))/9+-parseInt(s(333,"sV&b"))/10*(-parseInt(s(338,"ec0b"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x343910(336,"yOfc")](_0x343910(326,"@D26"))!=_0x343910(321,"sV&b"))throw window[_0x343910(322,"*fuD")][_0x343910(324,"t^MI")](_0x343910(328,"VhEX")),Error();function _0x9dd3(){var s=["W4uhWR1YiCoudfhcSsyBeZhcOW","WOy7W57dVSkLtei","yw/dO0NcOLJcQCoxW6fxF28","WRzFvurLpmowFW","W5regGpcOKFdTSkNlczmW79a","mYaOxSo4WPVcLHhcIJBdQru","br8TAtVdVLpcSmkp","yIzbdwy5W5uyWR/dSmkHjYC","W5zpha/cPuZcMCklcqftW7C","WP1kW77dLuhcGwRdOCkyjemYfW","x8opifVdKbBdPKlcJG","qSo4W4JdJKrGlJdcT8k+WRm","Cmo6W68WtSkBW58","FCoNxmk/b8k2cbS","BSkFmSkaqG","WQdcGCoxW5qvhSkVkG","AWddT3vxW7ZdGc3cSmobj8ofW7G","aSkQWO/cKrnUeq","nJtcUdHUWPqk","WRuBCIqlW6RcHmkhW7a","WQddI8ofWPVdJmkbcNfuptiF","WOGix0VdOutdR8oPpIPoW7TPWRhdQGi+WRGVcSkvAmo1BxDf","bSoHqmkxqf3cUCocW4i5r8oGyq","xxWDWOBcSmoYWRqB","wG3cJLyoiHJdOCkzWQHo","C1NcO8kYW7igB8kk","l8oADSohdM/dOmknpSoFWP7cKSkaoG","ngBdSg8XW6DtWPNcN8kLW63dGIO"];return(_0x9dd3=function(){return s})()}document.title="typescript 条件类型",document.getElementById("article").innerHTML='<div><p><strong>TypeScript 条件类型</strong>  是 TypeScript 类型系统中的一个强大特性，它允许开发者根据条件表达式的结果来选择类型。这种机制类似于编程语言中的三元运算符，但作用于类型层面。以下是关于 TypeScript 条件类型的详细解析：</p>\n<hr>\n<h3><strong>基本概念</strong></h3>\n<ul>\n<li><strong>定义</strong>  ：条件类型使用 <code>extends</code> 关键字来判断一个类型是否满足某个条件，并根据判断结果选择相应的类型。</li>\n<li><strong>语法</strong>  ：<pre><code class="language-typescript">T <span class="hljs-keyword">extends</span> U ? X : Y\n</code></pre>\n<ul>\n<li><code>T</code> 是要检查的类型。</li>\n<li><code>U</code> 是用于比较的类型。</li>\n<li>如果 <code>T</code> 可以赋值给 <code>U</code>，则结果类型为 <code>X</code>。</li>\n<li>否则，结果类型为 <code>Y</code>。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>特性与用法</strong></h3>\n<h4><strong>1. 基本用法</strong></h4>\n<p>条件类型可以用于根据类型关系选择类型。</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Check</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> ? <span class="hljs-string">&quot;String Type&quot;</span> : <span class="hljs-string">&quot;Non-String Type&quot;</span>;\n\n<span class="hljs-keyword">type</span> A = <span class="hljs-title class_">Check</span>&lt;<span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">// &quot;String Type&quot;</span>\n<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">Check</span>&lt;<span class="hljs-built_in">number</span>&gt;; <span class="hljs-comment">// &quot;Non-String Type&quot;</span>\n</code></pre>\n<h4><strong>2. 分布式条件类型</strong></h4>\n<p>当条件类型作用于联合类型时，TypeScript 会将条件类型分发到联合类型的每个成员上。</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Distribute</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> ? <span class="hljs-string">&quot;String&quot;</span> : <span class="hljs-string">&quot;Non-String&quot;</span>;\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span> = <span class="hljs-title class_">Distribute</span>&lt;<span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-built_in">number</span>&gt;; <span class="hljs-comment">// &quot;String&quot; | &quot;String&quot; | &quot;Non-String&quot;</span>\n<span class="hljs-comment">// 简化为 &quot;String&quot; | &quot;Non-String&quot;（因为 &quot;String&quot; 重复了）</span>\n</code></pre>\n<h4><strong>3. 提取和排除类型</strong></h4>\n<p>条件类型可以用于从联合类型中提取或排除某些类型。</p>\n<ul>\n<li><strong>提取类型</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Extract</span>&lt;T, U&gt; = T <span class="hljs-keyword">extends</span> U ? T : <span class="hljs-built_in">never</span>;\n\n<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">// &quot;a&quot; | &quot;b&quot;</span>\n</code></pre>\n</li>\n<li><strong>排除类型</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Exclude</span>&lt;T, U&gt; = T <span class="hljs-keyword">extends</span> U ? <span class="hljs-built_in">never</span> : T;\n\n<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">// number</span>\n</code></pre>\n</li>\n</ul>\n<h4><strong>4. 映射类型中的条件类型</strong></h4>\n<p>条件类型可以与映射类型结合使用，以根据属性类型进行转换。</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Optional</span>&lt;T&gt; = {\n  [K <span class="hljs-keyword">in</span> keyof T]: T[K] <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span> ? T[K] : T[K] | <span class="hljs-literal">undefined</span>;\n};\n\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Example</span> {\n  <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">c</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;\n}\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">OptionalExample</span> = <span class="hljs-title class_">Optional</span>&lt;<span class="hljs-title class_">Example</span>&gt;;\n<span class="hljs-comment">// 等同于 { a?: string | undefined; b?: number | undefined; c: () =&gt; void; }</span>\n</code></pre>\n<h4><strong>5. 条件类型与推断</strong></h4>\n<p>条件类型可以用于推断函数的返回类型。</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReturnType</span>&lt;T&gt; = T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; infer R ? R : <span class="hljs-built_in">never</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;\n}\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">FnReturnType</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> fn&gt;; <span class="hljs-comment">// &quot;Hello&quot; 的类型，即 string</span>\n</code></pre>\n<hr>\n<h3><strong>应用场景</strong></h3>\n<ol>\n<li><strong>类型保护</strong>  ：\n<ul>\n<li>条件类型可以用于在编译时实现类型保护，确保代码的类型安全。</li>\n</ul>\n</li>\n<li><strong>工具类型</strong>  ：\n<ul>\n<li>TypeScript 提供了一些内置的工具类型，如 <code>Partial</code>、<code>Readonly</code>、<code>Pick</code> 等，它们都是基于条件类型实现的。</li>\n</ul>\n</li>\n<li><strong>复杂类型映射</strong>  ：\n<ul>\n<li>在处理复杂的数据结构时，条件类型可以帮助开发者根据属性类型进行转换或过滤。</li>\n</ul>\n</li>\n<li><strong>泛型编程</strong>  ：\n<ul>\n<li>条件类型增强了 TypeScript 的泛型编程能力，使得泛型函数和类型更加灵活和强大。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>注意事项</strong></h3>\n<ol>\n<li><strong>分布式条件类型的限制</strong>  ：\n<ul>\n<li>分布式条件类型仅适用于裸类型参数（即没有包裹在其他类型中的类型参数）。</li>\n</ul>\n</li>\n<li><strong>类型推断的复杂性</strong>  ：\n<ul>\n<li>在使用条件类型进行类型推断时，可能会遇到复杂的类型表达式，需要仔细分析。</li>\n</ul>\n</li>\n<li><strong>性能考虑</strong>  ：\n<ul>\n<li>过度使用条件类型可能会导致编译时间增加，特别是在处理大型代码库时。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>TypeScript 条件类型是一个强大的工具，它允许开发者在类型层面进行条件判断，并根据判断结果选择类型。通过掌握条件类型，开发者可以编写更类型安全、更灵活的 TypeScript 代码。条件类型不仅增强了 TypeScript 的类型表达能力，还使得泛型编程和工具类型的实现变得更加简单和直观。</p>\n</div>'</script></body></html>