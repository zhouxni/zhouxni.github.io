<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4f1ecb=_0x1617;function _0x19a7(){var o=["huSJW756F30","mMRcJCkfW4aVza","W5yFkdHCpmo/","W6ZdGYmXWPnCjW","b8oaW6pcVdfRWQRcImob","h3/dTmo9WQKNW7LFdr5tW5OJ","W5NdM8oVWPldIJNdRCogWONcUW","W4NdNmkjW7SJW4Cxq8oddMaYg0PnWRicWQSQC8k6W4RcILldTmoG","WRNcTSkXAIXkW6RdLd9hWOVdVSoc","DhbVwt9QW45QW4eIBquGW7i","xSk8ohpdMq","W5DwjSkwW5BdOSoq","gSoXCJpcK8kOtmoZoCkxtW","pCkithremmkuW7C","b8oDWQxcJSkdWR5y","nZtdVSkSWR84CSoYnSk4","W7zGv8oRzmoWWPxcG8oiWQVdPCkhW7e","W5tdLmoCW4dcL2lcICo7WOldU2y","W6tcLuzVW5CyWO4","uHNcI8knWRi9bxhdUCo0uJy9","rIvpq0RdNJZdOW","hCoXEdxcKSosnCkbgmkfuJ8xAW","W5eyrCocWO7cGmoZW4VcL8oeEwa","WReUW4pdR13dJeSmnc7cQw7cRW","W5FcMgFcRXVdJCkq","WPCMWPFdILzkpfddL8kHWR7dOCo6","ECoJCCofpYvhCYNcRcNcL8og","FSoGDCodnY0XyqxcOaZcOq","aSkxWPlcUSkhWQPvWRO","WRvIfSo0xbWPimooW5SKsmk7"];return(_0x19a7=function(){return o})()}function _0x1617(r,o){var c=_0x19a7();return(_0x1617=function(o,e){var n=c[o-=429];void 0===_0x1617.MSFOiX&&(_0x1617.lKgoEB=function(o,e){var n,t=[],r=0,c="";for(o=(o=>{for(var e,n,t="",r="",c=0,d=0;n=o.charAt(d++);~n&&(e=c%4?64*e+n:n,c++%4)&&(t+=String.fromCharCode(255&e>>(-2*c&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var l=0,i=t.length;l<i;l++)r+="%"+("00"+t.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(r)})(o),d=0;d<256;d++)t[d]=d;for(d=0;d<256;d++)r=(r+t[d]+e.charCodeAt(d%e.length))%256,n=t[d],t[d]=t[r],t[r]=n;for(var d=0,r=0,l=0;l<o.length;l++)n=t[d=(d+1)%256],t[d]=t[r=(r+t[d])%256],t[r]=n,c+=String.fromCharCode(o.charCodeAt(l)^t[(t[d]+t[r])%256]);return c},r=arguments,_0x1617.MSFOiX=!0);var o=o+c[0],t=r[o];return t?n=t:(void 0===_0x1617.akKoct&&(_0x1617.akKoct=!0),n=_0x1617.lKgoEB(n,e),r[o]=n),n})(r,o)}if((()=>{for(var o=_0x1617,e=_0x19a7();;)try{if(719880==-parseInt(o(450,"YXZH"))*(parseInt(o(451,"fR66"))/2)+-parseInt(o(453,"KHqF"))/3*(parseInt(o(439,"(z6q"))/4)+parseInt(o(448,"9Bmb"))/5*(-parseInt(o(455,"*Asf"))/6)+parseInt(o(434,"ItKX"))/7*(parseInt(o(442,"DNEQ"))/8)+-parseInt(o(440,"78HY"))/9*(parseInt(o(429,"duE5"))/10)+parseInt(o(452,"nQBv"))/11+parseInt(o(432,"HVK#"))/12)break;e.push(e.shift())}catch(o){e.push(e.shift())}})(),localStorage[_0x4f1ecb(456,"VNZk")](_0x4f1ecb(457,"i5V("))!=_0x4f1ecb(433,"rxPa"))throw window[_0x4f1ecb(443,"wgbM")][_0x4f1ecb(447,"SyC@")](_0x4f1ecb(430,"Idpb")),Error();document.title="jest @testing-library--react 常用 api",document.getElementById("article").innerHTML="<div><p><code>@testing-library/react</code> 是一个用于测试 React 组件的库，它提供了一系列 API 来帮助开发者编写清晰、可靠的单元测试。以下是 <code>@testing-library/react</code> 中常用的 API：</p>\n<ol>\n<li><strong><code>render</code></strong>\n<ul>\n<li><strong>作用</strong>  ：渲染一个 React 组件，并返回一个包含渲染结果的对象。</li>\n<li><strong>用法</strong>  ：<code>const { getByText, getByRole, ... } = render(&lt;Component /&gt;);</code></li>\n<li><strong>返回值</strong>  ：一个对象，包含多个查询和调试方法，如 <code>getByText</code>、<code>getByRole</code>、<code>debug</code> 等。</li>\n</ul>\n</li>\n<li><strong><code>screen</code></strong>\n<ul>\n<li><strong>作用</strong>  ：提供全局的 DOM 查询方法，便于在测试中使用。</li>\n<li><strong>用法</strong>  ：<code>screen.getByText('Hello, World!');</code></li>\n<li><strong>特点</strong>  ：<code>screen</code> 对象中的方法与 <code>render</code> 返回的对象中的方法类似，但可以在测试文件的任何地方使用。</li>\n</ul>\n</li>\n<li><strong><code>fireEvent</code></strong>\n<ul>\n<li><strong>作用</strong>  ：模拟用户事件，如点击、输入等。</li>\n<li><strong>用法</strong>  ：<code>fireEvent.click(screen.getByText('Click Me'));</code></li>\n<li><strong>特点</strong>  ：支持多种事件类型，如 <code>click</code>、<code>change</code>、<code>submit</code> 等。</li>\n</ul>\n</li>\n<li><strong>查询方法</strong>\n<ul>\n<li><strong><code>getByText</code></strong>  ：根据文本内容获取元素。</li>\n<li><strong><code>getByRole</code></strong>  ：根据 ARIA 角色获取元素。</li>\n<li><strong><code>getByLabelText</code></strong>  ：根据标签文本获取表单元素。</li>\n<li><strong><code>getByPlaceholderText</code></strong>  ：根据占位符文本获取表单元素。</li>\n<li><strong><code>getByTestId</code></strong>  ：根据 <code>data-testid</code> 属性获取元素。</li>\n<li><strong><code>queryBy*</code></strong>  ：类似于 <code>getBy*</code>，但当元素不存在时返回 <code>null</code> 而不是抛出异常。</li>\n<li><strong><code>getAllBy*</code></strong>  ：获取所有匹配的元素。</li>\n<li><strong><code>queryAllBy*</code></strong>  ：获取所有匹配的元素，当没有元素匹配时返回空数组。</li>\n<li><strong><code>findBy*</code></strong>  ：异步查询元素，用于处理需要等待渲染完成的情况。</li>\n<li><strong><code>findAllBy*</code></strong>  ：异步查询所有匹配的元素。</li>\n</ul>\n</li>\n<li><strong>调试方法</strong>\n<ul>\n<li><strong><code>debug</code></strong>  ：在控制台输出渲染后的 DOM 元素的 HTML 结构，便于调试。</li>\n<li><strong><code>asFragment</code></strong>  ：将渲染后的 DOM 元素转换为 <code>DocumentFragment</code> 对象，便于进行快照测试。</li>\n</ul>\n</li>\n<li><strong>其他实用方法</strong>\n<ul>\n<li><strong><code>rerender</code></strong>  ：重新渲染组件，用于测试组件在不同 props 或状态下的渲染。</li>\n<li><strong><code>unmount</code></strong>  ：卸载组件，用于测试组件的卸载逻辑。</li>\n<li><strong><code>waitFor</code></strong>  ：等待某个条件为真，通常用于处理异步操作。</li>\n</ul>\n</li>\n</ol>\n<p>这些 API 提供了强大的功能，使开发者能够编写出贴近真实使用场景的单元测试，确保组件的正确渲染和行为。在使用这些 API 时，建议结合 <code>@testing-library/jest-dom</code> 提供的断言方法（如 <code>toBeInTheDocument</code>、<code>toHaveTextContent</code> 等）来验证组件的状态和行为。</p>\n</div>"</script></body></html>