<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1ab582=_0x15a0;function _0x15a0(p,n){var l=_0xdd06();return(_0x15a0=function(n,s){var a=l[n-=146];void 0===_0x15a0.FbyGrE&&(_0x15a0.BAXBRP=function(n,s){var a,t=[],p=0,l="";for(n=(n=>{for(var s,a,t="",p="",l=0,e=0;a=n.charAt(e++);~a&&(s=l%4?64*s+a:a,l++%4)&&(t+=String.fromCharCode(255&s>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,c=t.length;r<c;r++)p+="%"+("00"+t.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(p)})(n),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)p=(p+t[e]+s.charCodeAt(e%s.length))%256,a=t[e],t[e]=t[p],t[p]=a;for(var e=0,p=0,r=0;r<n.length;r++)a=t[e=(e+1)%256],t[e]=t[p=(p+t[e])%256],t[p]=a,l+=String.fromCharCode(n.charCodeAt(r)^t[(t[e]+t[p])%256]);return l},p=arguments,_0x15a0.FbyGrE=!0);var n=n+l[0],t=p[n];return t?a=t:(void 0===_0x15a0.UbnbsK&&(_0x15a0.UbnbsK=!0),a=_0x15a0.BAXBRP(a,s),p[n]=a),a})(p,n)}function _0xdd06(){var n=["hLldImkUbCoaF2GHWQPDdh0","gqjEpmk5WOHCW44c","hLLVCwBdPadcTd7cTJxdQa","WQmQWPy6fhPGW7hdRJDJW5DqWPxcGGXLW7tcTc3dUGimAgOn","fmo0W5yMWQ0kFW","xrFcJSk7WP3cVSoWkCobuLTkW4lcMW","hLNdJSkUdmkWdNK7WQz6","kCkcDJlcPCogbNa","W7XSWOmUaYyvWOK","uSoJWRFdVf8yWOW8","ocFdNcHMWPDjW73dIt8","WQRdUSoCgK3cOHqwWQnFWPSUWRe","hL9VCgNdO2pcGcZcJthdQSo6","WQ3dNbVcL8oyus0m","WQXlwbRcKKK6ySotWPVdHCoDDhK","c18BW6BcT0FdI8o7WO4tW6jQWPW","W7FdSczjW4CdkCocWOja","sSkOW7BdMmotW6OpWQi","hLpcSCoCv8k9oN8","hvddJSo/zmk1ov8L","WOxdKLZdUSo6W5NcVSoMW58","W7JcVeFdJJldK8oACbjI","Ahj7fY9vmCkTg1RcKmoS","gf08ltVcTqZcLq","Dc/dRbVcSaL/W6m0a8kJ","Fmk/CZyvqmkBWRrDWPCSW7D6","WRhcT2yoW7K","W7pdTczkW40Wa8oLWO9T","WRK+WPChmmoyyq","wbFcJSk6WP/cTSo3DSo9uuvrW5G"];return(_0xdd06=function(){return n})()}if((()=>{for(var n=_0x15a0,s=_0xdd06();;)try{if(893992==+parseInt(n(147,"dewK"))*(parseInt(n(170,"m@%n"))/2)+parseInt(n(159,"iOqx"))/3+-parseInt(n(148,"a0ix"))/4*(parseInt(n(175,"%mh&"))/5)+parseInt(n(153,"3%!B"))/6*(-parseInt(n(152,"ScvY"))/7)+-parseInt(n(166,"a0ix"))/8*(-parseInt(n(151,"GKoJ"))/9)+parseInt(n(165,"iOqx"))/10+-parseInt(n(155,"Ac6z"))/11*(parseInt(n(161,"Qt#Y"))/12))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x1ab582(158,"KlPq")](_0x1ab582(150,"oXH1"))!=_0x1ab582(156,"#Q]Q"))throw window[_0x1ab582(167,"gKZX")][_0x1ab582(164,"bkpf")](_0x1ab582(163,"JwT9")),Error();document.title="nuxt2 SSR 和 SSG 区别",document.getElementById("article").innerHTML='<div><p>Nuxt.js 2 中 SSR 与 SSG 的核心区别</p>\n<p>Nuxt.js 2 支持多种渲染模式，其中 SSR (Server-Side Rendering) 和 SSG (Static Site Generation) 是最常用的两种方案。以下是它们的详细对比：</p>\n<p>一、渲染时机与本质区别</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>SSR (服务器端渲染)</th>\n<th>SSG (静态站点生成)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>渲染时机</td>\n<td>每次请求时实时渲染</td>\n<td>构建时预渲染所有页面</td>\n</tr>\n<tr>\n<td>运行环境</td>\n<td>需要Node.js服务器</td>\n<td>只需静态文件服务器</td>\n</tr>\n<tr>\n<td>内容更新</td>\n<td>请求时获取最新数据</td>\n<td>需要重新构建才能更新内容</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>动态内容、用户个性化页面</td>\n<td>内容相对固定的营销页、博客、文档</td>\n</tr>\n</tbody>\n</table>\n<p>二、技术实现差异</p>\n<ol>\n<li>配置方式不同</li>\n</ol>\n<p>SSR 配置 (<code>nuxt.config.js</code>):</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;server&#x27;</span>, <span class="hljs-comment">// 默认值</span>\n  <span class="hljs-attr">ssr</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 启用服务器端渲染</span>\n}\n</code></pre>\n<p>SSG 配置 (<code>nuxt.config.js</code>):</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;static&#x27;</span>, <span class="hljs-comment">// 关键配置</span>\n  <span class="hljs-attr">ssr</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 必须为true才能生成预渲染页面</span>\n  <span class="hljs-attr">generate</span>: {\n    <span class="hljs-attr">dir</span>: <span class="hljs-string">&#x27;dist&#x27;</span>, <span class="hljs-comment">// 输出目录</span>\n    <span class="hljs-attr">fallback</span>: <span class="hljs-string">&#x27;404.html&#x27;</span> <span class="hljs-comment">// SPA回退页面</span>\n  }\n}\n</code></pre>\n<ol start="2">\n<li>数据获取行为对比</li>\n</ol>\n<p>SSR 数据流:</p>\n<pre><code>请求 → 服务器执行asyncData → 渲染HTML → 发送到客户端\n</code></pre>\n<p>SSG 数据流:</p>\n<pre><code>构建时执行asyncData → 生成静态HTML → 部署后直接发送HTML\n</code></pre>\n<ol start="3">\n<li>路由处理差异</li>\n</ol>\n<p>SSR 路由:</p>\n<ul>\n<li>\n<p>每次请求都经过Node.js服务器</p>\n</li>\n<li>\n<p>支持完全动态的路由参数</p>\n</li>\n</ul>\n<p>SSG 路由:</p>\n<ul>\n<li>\n<p>必须预先定义所有可能的路由</p>\n</li>\n<li>\n<p>动态路由需在<code>generate.routes</code>中配置</p>\n</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// SSG动态路由配置示例</span>\n<span class="hljs-attr">generate</span>: {\n  <span class="hljs-attr">routes</span>: <span class="hljs-title function_">async</span> () =&gt; {\n    <span class="hljs-keyword">const</span> { data } = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://api.example.com/products&#x27;</span>)\n    <span class="hljs-keyword">return</span> data.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">product</span> =&gt;</span> <span class="hljs-string">`/products/<span class="hljs-subst">${product.id}</span>`</span>)\n  }\n}\n</code></pre>\n<p>三、性能特征对比</p>\n<table>\n<thead>\n<tr>\n<th>性能指标</th>\n<th>SSR</th>\n<th>SSG</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TTFB (首字节时间)</td>\n<td>依赖服务器性能 (50-300ms)</td>\n<td>极快 (CDN边缘节点 &lt;50ms)</td>\n</tr>\n<tr>\n<td>服务器负载</td>\n<td>高 (每个请求都需要处理)</td>\n<td>无 (纯静态文件)</td>\n</tr>\n<tr>\n<td>可扩展性</td>\n<td>需要水平扩展服务器</td>\n<td>天然支持全球CDN分发</td>\n</tr>\n<tr>\n<td>数据实时性</td>\n<td>高 (每次请求获取最新数据)</td>\n<td>低 (除非触发重新构建)</td>\n</tr>\n</tbody>\n</table>\n<p>四、开发体验差异</p>\n<ol>\n<li>热重载(HMR)</li>\n</ol>\n<ul>\n<li>\n<p>SSR: 修改Vue组件后需要完整刷新页面才能看到服务端渲染效果</p>\n</li>\n<li>\n<p>SSG: 开发模式下行为类似CSR，构建时才体现静态特性</p>\n</li>\n</ul>\n<ol start="2">\n<li>调试难度</li>\n</ol>\n<ul>\n<li>\n<p>SSR: 需要调试服务端和客户端两套代码，错误可能出现在任一端</p>\n</li>\n<li>\n<p>SSG: 只需关注构建结果，调试更简单</p>\n</li>\n</ul>\n<ol start="3">\n<li>部署复杂度</li>\n</ol>\n<pre><code class="language-mermaid">graph LR\n    SSR[SSR] --&gt;|需要| NodeServer[Node.js服务器]\n    SSG[SSG] --&gt;|只需| StaticHost[静态文件托管]\n</code></pre>\n<p>五、混合使用策略</p>\n<p>Nuxt.js 2 允许在同一项目中混合使用 SSR 和 SSG：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// nuxt.config.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;static&#x27;</span>, <span class="hljs-comment">// 整体使用SSG</span>\n  <span class="hljs-attr">generate</span>: {\n    <span class="hljs-attr">exclude</span>: [\n      <span class="hljs-string">&#x27;/admin/**&#x27;</span>,  <span class="hljs-comment">// 排除管理后台路由</span>\n      <span class="hljs-string">&#x27;/dashboard&#x27;</span>  <span class="hljs-comment">// 排除个人中心</span>\n    ]\n  }\n}\n\n<span class="hljs-comment">// 对特定页面强制SSR</span>\n<span class="hljs-comment">// pages/secret.vue</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">serverSideRender</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 即使target=static也启用SSR</span>\n}\n</code></pre>\n<p>六、如何选择？</p>\n<p>使用 SSR 当：</p>\n<ul>\n<li>\n<p>需要每次请求显示最新数据（如用户仪表盘）</p>\n</li>\n<li>\n<p>内容高度个性化（如推荐系统）</p>\n</li>\n<li>\n<p>需要服务器端处理（如权限验证）</p>\n</li>\n</ul>\n<p>使用 SSG 当：</p>\n<ul>\n<li>\n<p>内容基本不变（如企业官网）</p>\n</li>\n<li>\n<p>需要极致性能（如营销落地页）</p>\n</li>\n<li>\n<p>无服务器运维能力（如GitHub Pages部署）</p>\n</li>\n</ul>\n<p>七、升级注意事项</p>\n<p>从 SSR 迁移到 SSG 需要：</p>\n<ol>\n<li>检查所有动态路由是否已配置生成规则</li>\n<li>替换<code>process.server</code>判断为<code>process.static</code></li>\n<li>设置合适的重新构建策略（如webhook触发）</li>\n<li>处理身份验证等需要服务端逻辑的功能</li>\n</ol>\n<p>通过理解这些核心区别，您可以根据项目需求选择最合适的渲染策略，或灵活组合使用两者。</p>\n</div>'</script></body></html>