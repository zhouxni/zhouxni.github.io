<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2cb748=_0x110e;if((()=>{for(var n=_0x110e,s=_0x17fd();;)try{if(214741==-parseInt(n(442,"aDEL"))+parseInt(n(435,"aDEL"))/2*(parseInt(n(415,"8Y(n"))/3)+parseInt(n(422,"sA87"))/4+-parseInt(n(429,"PdZ["))/5*(parseInt(n(419,"#4SE"))/6)+parseInt(n(432,"87n)"))/7+-parseInt(n(439,"^D&B"))/8*(-parseInt(n(436,"9W%$"))/9)+parseInt(n(427,"Mv49"))/10*(-parseInt(n(434,"aDEL"))/11))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x2cb748(438,"ruM(")](_0x2cb748(437,"jZGw"))!=_0x2cb748(430,"Ijiq"))throw window[_0x2cb748(440,"PdZ[")][_0x2cb748(418,"Ijiq")](_0x2cb748(431,"ZGM(")),Error();function _0x110e(e,n){var c=_0x17fd();return(_0x110e=function(n,s){var a=c[n-=415];void 0===_0x110e.WrSfen&&(_0x110e.VnMKQM=function(n,s){var a,l=[],e=0,c="";for(n=(n=>{for(var s,a,l="",e="",c=0,t=0;a=n.charAt(t++);~a&&(s=c%4?64*s+a:a,c++%4)&&(l+=String.fromCharCode(255&s>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,r=l.length;o<r;o++)e+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(e)})(n),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)e=(e+l[t]+s.charCodeAt(t%s.length))%256,a=l[t],l[t]=l[e],l[e]=a;for(var t=0,e=0,o=0;o<n.length;o++)a=l[t=(t+1)%256],l[t]=l[e=(e+l[t])%256],l[e]=a,c+=String.fromCharCode(n.charCodeAt(o)^l[(l[t]+l[e])%256]);return c},e=arguments,_0x110e.WrSfen=!0);var n=n+c[0],l=e[n];return l?a=l:(void 0===_0x110e.XnFNtJ&&(_0x110e.XnFNtJ=!0),a=_0x110e.VnMKQM(a,s),e[n]=a),a})(e,n)}function _0x17fd(){var n=["DZW0W6r2WRbcemoulqlcSa","cLaQzCodsqRcOZ81j8kC","dSkOvdFcTb5lD8kupCkcW7X7","xq9KBCkvwxC","gwa+u0Thw8otW7S","kuNcHxhcMmkkDtuexq","rSkzWPL1W69IuW","emoJtLnAW59Rlv/dKmorcmo+","hLGHmComdIi4W7HPW5FcTwC","W6ldLfOLu2ddRSkIs8kjWQi","i0/cG3BdMmoBzbuKuCktpW","pN/cTGBcQ8kotYbg","sMxdNIzuWPZcRCodW6P9","xCo2W6CoamojkCkVedW","fCoMh8kCxY/cHmkaWQpcUCkc","xX9NCSkn","WQZcISk2ieBdG8k3lmkcgSo5BbXtW5O2mCodW67cIdxcQSkYW4yhW6C","W5O2WRHwhCoUWR9OWOlcMmoIsCk+","WQ7cQWhdNd97xSkbW4dcMa","WRpdR1TyWPlcTSk8FhZdMa","WRBcLISGWRBcO8ku","d1uIBmkxpq7cKYqQ","uSkPWRL8W7yoW7tdOL4","xYPgoeuuWPW","W641h8oUBCk4FSonWODU","t8k9rmokhItcGmk2","qwldMsfnWQ/cHCo+W6LF","WRpdQ1vFW4tdKSkczh7dJIFdNW"];return(_0x17fd=function(){return n})()}document.title="css will-change",document.getElementById("article").innerHTML='<div><p><code>will-change</code> 是 CSS 中一个用于性能优化的属性，它允许开发者提前提前知会浏览器元素可能即将发生的变化，以便浏览器提前做好准备，优化后续渲染性能。它的核心作用是<strong>减少突发变化带来的性能损耗</strong>   ，让动画和交互更加流畅。</p>\n<h3>一、工作原理：提前“预告”浏览器</h3>\n<p>浏览器的渲染流程（重排、重绘、合成）通常是“被动触发”的——只有当元素样式变化时，浏览器才会执行相应计算。而 <code>will-change</code> 则是“主动预告”：</p>\n<ul>\n<li>当设置 <code>will-change: transform</code> 时，浏览器会提前：\n<ol>\n<li>为元素分配 GPU 资源（如果需要）；</li>\n<li>预计算可能的变换状态；</li>\n<li>优化图层合成策略。</li>\n</ol>\n</li>\n<li>这样，当元素实际发生 <code>transform</code> 变化时，浏览器就能快速响应，避免卡顿。</li>\n</ul>\n<h3>二、语法与取值</h3>\n<p><code>will-change</code> 支持多种取值，覆盖不同类型的变化场景：</p>\n<h4>1. 具体 CSS 属性名（最常用）</h4>\n<p>直接指定元素可能变化的 CSS 属性，浏览器会针对性优化：</p>\n<pre><code class="language-css"><span class="hljs-comment">/* 可能会执行 transform 动画（如位移、缩放） */</span>\n<span class="hljs-selector-class">.box</span> {\n  <span class="hljs-attribute">will-change</span>: transform;\n}\n\n<span class="hljs-comment">/* 可能会改变透明度（如淡入淡出） */</span>\n<span class="hljs-selector-class">.box</span> {\n  <span class="hljs-attribute">will-change</span>: opacity;\n}\n\n<span class="hljs-comment">/* 可能会改变尺寸（谨慎使用，可能触发重排） */</span>\n<span class="hljs-selector-class">.box</span> {\n  <span class="hljs-attribute">will-change</span>: width, height;\n}\n\n<span class="hljs-comment">/* 多个可能的变化，用逗号分隔 */</span>\n<span class="hljs-selector-class">.box</span> {\n  <span class="hljs-attribute">will-change</span>: transform, opacity, left;\n}\n</code></pre>\n<h4>2. 关键字值</h4>\n<ul>\n<li>\n<p><strong><code>auto</code></strong>   ：默认值，浏览器自动判断是否需要优化，不做提前准备。通常在元素变化结束后恢复此值，释放资源。</p>\n<pre><code class="language-css"><span class="hljs-selector-class">.box</span> {\n  <span class="hljs-attribute">will-change</span>: auto;\n} <span class="hljs-comment">/* 取消提前优化 */</span>\n</code></pre>\n</li>\n<li>\n<p><strong><code>scroll-position</code></strong>   ：告知浏览器元素（或其祖先）可能会滚动，优化滚动性能（如预渲染滚动区域）。</p>\n<pre><code class="language-css"><span class="hljs-selector-class">.custom-scrollbar</span> {\n  <span class="hljs-attribute">will-change</span>: scroll-position;\n}\n</code></pre>\n</li>\n<li>\n<p><strong><code>contents</code></strong>   ：告知浏览器元素内容可能大幅变化（如动态插入大量子元素），但现代浏览器对此支持有限，且可能降低缓存效率，谨慎使用。</p>\n</li>\n</ul>\n<h3>三、适用场景：哪些情况需要用？</h3>\n<p><code>will-change</code> 并非万能，以下场景使用效果最明显：</p>\n<ol>\n<li>\n<p><strong>即将发生的动画</strong><br>\n对即将执行动画的元素（如 hover 触发的位移、淡入）提前声明，避免动画开始时的卡顿：</p>\n<pre><code class="language-css"><span class="hljs-comment">/* 鼠标悬停时会有 transform 动画 */</span>\n<span class="hljs-selector-class">.btn</span> {\n  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.3s</span>;\n}\n<span class="hljs-selector-class">.btn</span><span class="hljs-selector-pseudo">:hover</span> {\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.1</span>);\n}\n<span class="hljs-comment">/* 提前预告，优化 hover 动画启动速度 */</span>\n<span class="hljs-selector-class">.btn</span> {\n  <span class="hljs-attribute">will-change</span>: transform;\n}\n</code></pre>\n</li>\n<li>\n<p><strong>频繁交互的元素</strong><br>\n如可拖拽元素、滚动触发的视差效果，提前告知浏览器可能的变化：</p>\n<pre><code class="language-css"><span class="hljs-selector-class">.draggable</span> {\n  <span class="hljs-attribute">will-change</span>: transform, left, top;\n}\n</code></pre>\n</li>\n<li>\n<p><strong>复杂渲染的元素</strong><br>\n包含阴影、渐变、滤镜等复杂样式的元素，变化时计算成本高，提前优化可减少延迟。</p>\n</li>\n</ol>\n<h3>四、禁忌：这些用法会适得其反</h3>\n<ol>\n<li>\n<p><strong>不要全局滥用</strong><br>\n给所有元素设置 <code>will-change: transform</code> 会导致浏览器创建大量冗余图层，消耗过多 GPU 内存，反而降低性能：</p>\n<pre><code class="language-css"><span class="hljs-comment">/* 错误：全局滥用，导致图层爆炸 */</span>\n* {\n  <span class="hljs-attribute">will-change</span>: transform;\n}\n</code></pre>\n</li>\n<li>\n<p><strong>避免提前太久设置</strong><br>\n元素变化前几秒设置即可，不要页面加载时就全局设置。例如，鼠标悬停前才激活：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 正确：动态控制，变化前设置，变化后移除</span>\nelement.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;mouseenter&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  element.<span class="hljs-property">style</span>.<span class="hljs-property">willChange</span> = <span class="hljs-string">&quot;transform&quot;</span>;\n});\nelement.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;mouseleave&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  element.<span class="hljs-property">style</span>.<span class="hljs-property">willChange</span> = <span class="hljs-string">&quot;auto&quot;</span>; <span class="hljs-comment">// 及时释放</span>\n});\n</code></pre>\n</li>\n<li>\n<p><strong>不用于触发 GPU 加速</strong><br>\n不要为了强制启用 GPU 而使用 <code>will-change: transform</code>（直接用 <code>transform</code> 即可）。<code>will-change</code> 是“预告”，不是“开关”。</p>\n</li>\n<li>\n<p><strong>慎用于会触发重排的属性</strong><br>\n对 <code>width</code>、<code>top</code>、<code>margin</code> 等会引发重排的属性，<code>will-change</code> 优化效果有限，反而可能浪费资源。</p>\n</li>\n</ol>\n<h3>五、与其他优化方式的对比</h3>\n<table>\n<thead>\n<tr>\n<th>优化方式</th>\n<th>作用</th>\n<th>与 will-change 的关系</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>transform</code></td>\n<td>触发 GPU 加速，减少重排</td>\n<td><code>will-change: transform</code> 可提前优化此过程</td>\n</tr>\n<tr>\n<td><code>opacity</code></td>\n<td>触发 GPU 加速，无重排</td>\n<td><code>will-change: opacity</code> 可提前分配资源</td>\n</tr>\n<tr>\n<td><code>contain</code></td>\n<td>限制元素渲染范围（隔离重排）</td>\n<td>与 <code>will-change</code> 配合使用，优化更精准</td>\n</tr>\n</tbody>\n</table>\n<h3>六、检测与调试</h3>\n<p>使用 Chrome 开发者工具查看 <code>will-change</code> 效果：</p>\n<ol>\n<li>打开「More Tools」→「Layers」，查看元素是否被提前分配到独立图层；</li>\n<li>在「Performance」面板录制动画，对比使用 <code>will-change</code> 前后的帧率（FPS）是否提升。</li>\n</ol>\n<h3>总结</h3>\n<p><code>will-change</code> 的核心价值是<strong>提前预告变化，让浏览器有备而来</strong>   ，而非主动提升性能。使用时需遵循：</p>\n<ul>\n<li>只给“即将变化”的元素设置；</li>\n<li>变化结束后立即恢复 <code>auto</code>；</li>\n<li>优先针对 <code>transform</code>、<code>opacity</code> 等 GPU 友好的属性；</li>\n<li>拒绝全局滥用，避免资源浪费。</li>\n</ul>\n<p>合理使用 <code>will-change</code> 能让动画更流畅，但过度依赖反而会导致性能问题——它是“优化的辅助工具”，而非“银弹”。</p>\n</div>'</script></body></html>