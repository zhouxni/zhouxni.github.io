<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5f2c(){var s=["WRxdHxRdV8oRW7tdPG","sZtcRImjW4ddNCoOWQfUWOilqa","uYXMW4tdImokW408","x8kBuuJdUmkpWPS","Cmk4WORcKSkJqH0","bmkGWPZdNCoqhSkHWODOWRWphq","qmo5WO4pW5ddSCo3CSoXWQmJlq","q8o/W6jTWRxcQmo1Eq","WOOoWQhcOeurWQVcJLOfWPyOfa","rNVdIGZdGctcPu3dOZ84WRev","FftdVGpdG8kxjW","W5ddRSopEcFdPSk3qCoximkjf8kMW4O","lCknlH3dLmoLW6zHvJtdSa","o8k6WQxdVexcP8kJ","rSoObZhdP1FdPLmffa","W7u4W7hdL8kSimkRW4K","DrtdRsZdLmknfuW","mCkyWQtdMrtcQmoiW5NdOSkTW6BdOea","aCkOsWaCxhRdImkheCo8jCkIAXNcLmoebSk5Ag5kWRhcT8oXW6a","W5dcQSohW6CVcCojWRVcPsr4","nSkyWQxdNvFdJSkBW7pdSCku","wmoLdurwugZdLCk0omoJpmkvsG","WOJdUZrNWQVdT0qaW78weIZcOa","rx7cVeNcU2pdVN4","gtZcOL0ihmoFsbK","W6dcLZJcGSo3W4ddOSoTvSoc","WONdUJDPWQldSeW3W6e8ktFcIa","W6FdLKZdNCo4W6ddJq","kCkHWQVcMmkWwJtcMa","WPNcGbjHC8oPWRyY","WQCarhOaDrhdHYVdTW","cHldPNGB"];return(_0x5f2c=function(){return s})()}function _0x4d01(l,s){var c=_0x5f2c();return(_0x4d01=function(s,n){var a=c[s-=347];void 0===_0x4d01.XXShfL&&(_0x4d01.RxdSYm=function(s,n){var a,t=[],l=0,c="";for(s=(s=>{for(var n,a,t="",l="",c=0,e=0;a=s.charAt(e++);~a&&(n=c%4?64*n+a:a,c++%4)&&(t+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,o=t.length;p<o;p++)l+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,p=0;p<s.length;p++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,c+=String.fromCharCode(s.charCodeAt(p)^t[(t[e]+t[l])%256]);return c},l=arguments,_0x4d01.XXShfL=!0);var s=s+c[0],t=l[s];return t?a=t:(void 0===_0x4d01.grOBsU&&(_0x4d01.grOBsU=!0),a=_0x4d01.RxdSYm(a,n),l[s]=a),a})(l,s)}var _0x3da04a=_0x4d01;if((()=>{for(var s=_0x4d01,n=_0x5f2c();;)try{if(250671==-parseInt(s(372,"ge(V"))*(parseInt(s(347,"z41J"))/2)+-parseInt(s(355,"Nl9I"))/3*(-parseInt(s(351,"7SOf"))/4)+-parseInt(s(353,"kiU7"))/5*(parseInt(s(350,"6lkm"))/6)+parseInt(s(375,"RtG3"))/7*(-parseInt(s(359,"x8pE"))/8)+-parseInt(s(366,"mmpv"))/9+-parseInt(s(369,"mmpv"))/10*(parseInt(s(361,"jt^#"))/11)+parseInt(s(370,"*aYy"))/12*(parseInt(s(365,"x8pE"))/13))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3da04a(349,"CaR]")](_0x3da04a(373,"Lb8j"))!=_0x3da04a(348,"fi%0"))throw window[_0x3da04a(377,"kiU7")][_0x3da04a(362,"fF&N")](_0x3da04a(367,"*aYy")),Error();document.title="小程序中的 wx.nextTick 是什么",document.getElementById("article").innerHTML='<div><p><code>wx.nextTick</code> 是微信小程序提供的一个 API，用于<strong>在下次 UI 更新周期后执行回调函数</strong>  ，类似于 Web 开发中的 <code>Vue.nextTick</code> 或浏览器的 <code>requestAnimationFrame</code>。</p>\n<p><strong>主要用途</strong>  ：<br>\n✅ <strong>确保 DOM 更新完成后再执行某些操作</strong>  （如获取节点信息、计算布局）。<br>\n✅ <strong>避免因异步渲染导致的逻辑错误</strong>  （如 <code>setData</code> 后立即操作 DOM）。</p>\n<hr>\n<h2><strong>1. 基本用法</strong></h2>\n<pre><code class="language-javascript"><span class="hljs-title class_">Page</span>({\n  <span class="hljs-title function_">onLoad</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>({ <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;Hello&quot;</span> }); <span class="hljs-comment">// 数据更新（异步）</span>\n    \n    wx.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;DOM 已更新！&quot;</span>);\n      <span class="hljs-comment">// 这里可以安全地获取节点信息</span>\n      wx.<span class="hljs-title function_">createSelectorQuery</span>()\n        .<span class="hljs-title function_">select</span>(<span class="hljs-string">&#x27;.my-element&#x27;</span>)\n        .<span class="hljs-title function_">boundingClientRect</span>(<span class="hljs-function"><span class="hljs-params">rect</span> =&gt;</span> {\n          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rect); <span class="hljs-comment">// 正确获取布局信息</span>\n        })\n        .<span class="hljs-title function_">exec</span>();\n    });\n  }\n})\n</code></pre>\n<hr>\n<h2><strong>2. 适用场景</strong></h2>\n<h3><strong>（1）<code>setData</code> 后操作 DOM</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>({ <span class="hljs-attr">showPopup</span>: <span class="hljs-literal">true</span> }); <span class="hljs-comment">// 显示弹窗（异步渲染）</span>\n\nwx.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 确保弹窗已渲染完成</span>\n  wx.<span class="hljs-title function_">createSelectorQuery</span>()\n    .<span class="hljs-title function_">select</span>(<span class="hljs-string">&#x27;.popup&#x27;</span>)\n    .<span class="hljs-title function_">boundingClientRect</span>(<span class="hljs-function"><span class="hljs-params">rect</span> =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;弹窗宽度:&quot;</span>, rect.<span class="hljs-property">width</span>);\n    })\n    .<span class="hljs-title function_">exec</span>();\n});\n</code></pre>\n<h3><strong>（2）避免连续 <code>setData</code> 导致的多次渲染</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 连续 setData 可能合并渲染</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> });\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>({ <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> });\n\nwx.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;a 和 b 都已更新！&quot;</span>);\n});\n</code></pre>\n<h3><strong>（3）动态计算布局</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>({ <span class="hljs-attr">list</span>: newData }); <span class="hljs-comment">// 更新列表数据</span>\n\nwx.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 确保列表渲染完成后再计算高度</span>\n  wx.<span class="hljs-title function_">createSelectorQuery</span>()\n    .<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">&#x27;.list-item&#x27;</span>)\n    .<span class="hljs-title function_">boundingClientRect</span>(<span class="hljs-function"><span class="hljs-params">rects</span> =&gt;</span> {\n      <span class="hljs-keyword">const</span> totalHeight = rects.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, rect</span>) =&gt;</span> sum + rect.<span class="hljs-property">height</span>, <span class="hljs-number">0</span>);\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;列表总高度:&quot;</span>, totalHeight);\n    })\n    .<span class="hljs-title function_">exec</span>();\n});\n</code></pre>\n<hr>\n<h2><strong>3. 对比 <code>setTimeout</code></strong></h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>执行时机</th>\n<th>推荐场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong><code>wx.nextTick</code></strong></td>\n<td><strong>下次 UI 渲染周期后</strong></td>\n<td><code>setData</code> 后操作 DOM</td>\n</tr>\n<tr>\n<td><strong><code>setTimeout(fn, 0)</code></strong></td>\n<td><strong>下一个事件循环</strong></td>\n<td>通用延迟（但不保证 DOM 已更新）</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例对比：</strong></p>\n<pre><code class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>({ <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;Updated&quot;</span> });\n\n<span class="hljs-comment">// ✅ 更可靠（确保 UI 更新）</span>\nwx.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;DOM 已更新&quot;</span>);\n});\n\n<span class="hljs-comment">// ❌ 可能早于 UI 更新</span>\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;可能 DOM 还未更新&quot;</span>);\n}, <span class="hljs-number">0</span>);\n</code></pre>\n<hr>\n<h2><strong>4. 注意事项</strong></h2>\n<ol>\n<li><strong><code>wx.nextTick</code> 是微信小程序特有</strong>  ，其他平台（如支付宝、百度）可能不支持，需用 <code>setTimeout</code> 替代。</li>\n<li><strong>嵌套 <code>nextTick</code> 会按顺序执行</strong>  ：<pre><code class="language-javascript">wx.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;第一次回调&quot;</span>);\n  wx.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;第二次回调&quot;</span>);\n  });\n});\n</code></pre>\n</li>\n<li><strong>不要滥用</strong>  ，频繁使用可能影响性能。</li>\n</ol>\n<hr>\n<h2><strong>5. 总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>setData</code> 后操作 DOM</td>\n<td><code>wx.nextTick</code></td>\n</tr>\n<tr>\n<td>通用延迟逻辑</td>\n<td><code>setTimeout</code></td>\n</tr>\n<tr>\n<td>跨平台兼容</td>\n<td>判断 <code>wx.nextTick</code> 是否存在，否则降级到 <code>setTimeout</code></td>\n</tr>\n</tbody>\n</table>\n<p><strong>代码示例（跨平台兼容）：</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> nextTick = wx.<span class="hljs-property">nextTick</span> || (<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(fn, <span class="hljs-number">0</span>));\n<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;安全执行&quot;</span>);\n});\n</code></pre>\n<p>如果目标用户主要是微信小程序，优先使用 <code>wx.nextTick</code>；如果是多端开发，建议封装成兼容方法。</p>\n</div>'</script></body></html>