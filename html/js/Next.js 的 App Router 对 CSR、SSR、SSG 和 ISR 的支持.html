<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x44a0(l,s){var p=_0x39e7();return(_0x44a0=function(s,a){var n=p[s-=463];void 0===_0x44a0.TsdBux&&(_0x44a0.BbLrsV=function(s,a){var n,t=[],l=0,p="";for(s=(s=>{for(var a,n,t="",l="",p=0,c=0;n=s.charAt(c++);~n&&(a=p%4?64*a+n:n,p++%4)&&(t+=String.fromCharCode(255&a>>(-2*p&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var e=0,o=t.length;e<o;e++)l+="%"+("00"+t.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(l)})(s),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)l=(l+t[c]+a.charCodeAt(c%a.length))%256,n=t[c],t[c]=t[l],t[l]=n;for(var c=0,l=0,e=0;e<s.length;e++)n=t[c=(c+1)%256],t[c]=t[l=(l+t[c])%256],t[l]=n,p+=String.fromCharCode(s.charCodeAt(e)^t[(t[c]+t[l])%256]);return p},l=arguments,_0x44a0.TsdBux=!0);var s=s+p[0],t=l[s];return t?n=t:(void 0===_0x44a0.gDvkKf&&(_0x44a0.gDvkKf=!0),n=_0x44a0.BbLrsV(n,a),l[s]=n),n})(l,s)}var _0x21bf5c=_0x44a0;function _0x39e7(){var s=["br8JW7tdPrrwoCo0lSohc14","dtLWWRu9k0K","WPpcN8olWONdKSoYymoFwCosoZNcIq","bXKGWQpcMgKen8oc","W63cTmkLWQ7dJ8o9W58raGmE","DZtdG8k7ACkUWP0Yht7dOGS","WRhdOmkZjmkMiWmD","W4D+W4ZcRJVcSeO","WPxdV3pdQf3dK1W","WOlcLu0KW7qMsxBdReCJW67cNq","WQVdN8obW7KwfmoVuW","ymoxW7efW4yRWPjqWR/cUSo+c8kN","WOm3W5vouqP+jCki","WPLGW4q3rq","W67dJCk0WRVdVCk0W40iWPC","WQlcS1ddGSk7ymkKBwLwW68","xHxdOGutW5hcGfnmW5KpzvBdPGVdVxtdHdXhWO0ND0BcQhS","WPNcMmoVW6JcUCo+WR81WPzGWOe9fa","WOLNdmoopfjtW6S","W4NdRCo5DbBdPSojW58","Bb3dVCoMWRSwWO3dR8kfsdvkDa","W47dRSkpdeZcSmkPW7ddGHJcTmoyW50","h8o6WPVdR8kxaCo8C8kHWQWzEG","W4tdMCoMcCoeWQaoiCogWQiOaW","lColgCkBW5Kuhbe","WQxcTf7dICk5b8kWzhvtW4lcVq","WPFdJKpcNquzW6fRWPiyWQvTsG","hsldVszDWR3cRq"];return(_0x39e7=function(){return s})()}if((()=>{for(var s=_0x44a0,a=_0x39e7();;)try{if(691650==+parseInt(s(469,"j@5U"))*(parseInt(s(485,"C!XP"))/2)+parseInt(s(477,"sJbE"))/3*(-parseInt(s(473,"OoUw"))/4)+-parseInt(s(476,"g2NQ"))/5+-parseInt(s(481,"Jv@7"))/6*(parseInt(s(471,"L(6t"))/7)+-parseInt(s(475,"OoUw"))/8*(-parseInt(s(478,"CBbe"))/9)+parseInt(s(463,"3OOf"))/10+-parseInt(s(465,"hpLQ"))/11)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x21bf5c(490,"oFRD")](_0x21bf5c(468,"L(6t"))!=_0x21bf5c(467,"qh64"))throw window[_0x21bf5c(464,"M0)R")][_0x21bf5c(483,"W9ah")](_0x21bf5c(470,"AtdA")),Error();document.title="Next.js 的 App Router 对 CSR、SSR、SSG 和 ISR 的支持",document.getElementById("article").innerHTML='<div><p>好的！Next.js 的 <strong>App Router</strong>   对 CSR、SSR、SSG 和 ISR 的支持更加直观和统一，主要通过 <strong>路由段配置（Route Segment Config）</strong>   和 <strong>数据获取方式</strong>   来实现。以下是完整的指南。</p>\n<hr>\n<h2>🧠 核心心智模型：App Router 的变革</h2>\n<p>在 App Router 中，每个页面（Page）都是一个 <strong>Server Component by default</strong>   （默认服务端组件）。你通过 <strong>组件类型</strong>   和 <strong>配置选项</strong>   来决定渲染策略。</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">策略</th>\n<th style="text-align:left">实现方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>SSG</strong></td>\n<td style="text-align:left"><code>generateStaticParams</code> + 静态 <code>fetch</code></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>ISR</strong></td>\n<td style="text-align:left"><code>fetch</code> 选项 <code>{ next: { revalidate: 60 } }</code></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>SSR</strong></td>\n<td style="text-align:left">动态 <code>fetch</code> 或 <code>dynamic = \'force-dynamic\'</code></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>CSR</strong></td>\n<td style="text-align:left">在 <code>\'use client\'</code> 组件中使用 <code>useEffect</code> 获取数据</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>🛠️ 具体实现方式</h2>\n<h3>1. 静态站点生成 (SSG)</h3>\n<p><strong>目标</strong>   ：在构建时生成静态页面。\n<strong>方法</strong>   ：使用 <code>generateStaticParams</code> 并发送静态 <code>fetch</code> 请求。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/products/[id]/page.js</span>\n<span class="hljs-comment">// 此页面在构建时静态生成</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">generateStaticParams</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> products = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://api.com/products&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span>\n    res.<span class="hljs-title function_">json</span>(),\n  );\n  <span class="hljs-comment">// 为每个产品生成静态路径</span>\n  <span class="hljs-keyword">return</span> products.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">product</span>) =&gt;</span> ({ <span class="hljs-attr">id</span>: product.<span class="hljs-property">id</span> }));\n}\n\n<span class="hljs-comment">// 这个 fetch 会自动被缓存（相当于 getStaticProps）</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getProduct</span>(<span class="hljs-params">id</span>) {\n  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://api.com/products/<span class="hljs-subst">${id}</span>`</span>); <span class="hljs-comment">// 默认缓存</span>\n  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductPage</span>(<span class="hljs-params">{ params }</span>) {\n  <span class="hljs-keyword">const</span> product = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getProduct</span>(params.<span class="hljs-property">id</span>); <span class="hljs-comment">// 在服务端获取数据</span>\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{product.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{product.description}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h3>2. 增量静态再生 (ISR)</h3>\n<p><strong>目标</strong>   ：静态生成但定期重新验证。\n<strong>方法</strong>   ：在 <code>fetch</code> 中使用 <code>next: { revalidate }</code> 选项。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/blog/page.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">BlogPage</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 此页面静态生成，但每60秒重新验证一次</span>\n  <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://api.com/posts&quot;</span>, {\n    <span class="hljs-attr">next</span>: { <span class="hljs-attr">revalidate</span>: <span class="hljs-number">60</span> }, <span class="hljs-comment">// ISR 关键配置</span>\n  }).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>());\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">PostList</span> <span class="hljs-attr">posts</span>=<span class="hljs-string">{posts}</span> /&gt;</span></span>;\n}\n\n<span class="hljs-comment">// 或者在布局级别配置</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> revalidate = <span class="hljs-number">60</span>; <span class="hljs-comment">// 所有该布局下的页面都每60秒再生</span>\n</code></pre>\n<h3>3. 服务端渲染 (SSR)</h3>\n<p><strong>目标</strong>   ：每次请求时在服务端渲染。\n<strong>方法</strong>   ：使用动态 <code>fetch</code> 或设置 <code>dynamic = \'force-dynamic\'</code>。</p>\n<p><strong>方式一：使用动态函数（cookies, headers, searchParams）</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/dashboard/page.js</span>\n<span class="hljs-keyword">import</span> { cookies } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/headers&quot;</span>;\n\n<span class="hljs-comment">// 此页面会在每次请求时动态渲染</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">DashboardPage</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 使用动态函数（如 cookies）会自动选择动态渲染</span>\n  <span class="hljs-keyword">const</span> cookieStore = <span class="hljs-title function_">cookies</span>();\n  <span class="hljs-keyword">const</span> session = cookieStore.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;session&quot;</span>);\n\n  <span class="hljs-keyword">const</span> userData = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://api.com/user&quot;</span>, {\n    <span class="hljs-attr">headers</span>: { <span class="hljs-title class_">Authorization</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${session?.value}</span>`</span> },\n    <span class="hljs-attr">cache</span>: <span class="hljs-string">&quot;no-store&quot;</span>, <span class="hljs-comment">// 不缓存，每次请求都重新获取</span>\n  }).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>());\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Dashboard</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{userData}</span> /&gt;</span></span>;\n}\n</code></pre>\n<p><strong>方式二：强制动态渲染</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/orders/page.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> dynamic = <span class="hljs-string">&quot;force-dynamic&quot;</span>; <span class="hljs-comment">// 强制动态渲染</span>\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">OrdersPage</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> orders = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://api.com/orders&quot;</span>, {\n    <span class="hljs-attr">cache</span>: <span class="hljs-string">&quot;no-store&quot;</span>, <span class="hljs-comment">// 不缓存</span>\n  }).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>());\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">OrderList</span> <span class="hljs-attr">orders</span>=<span class="hljs-string">{orders}</span> /&gt;</span></span>;\n}\n</code></pre>\n<h3>4. 客户端渲染 (CSR)</h3>\n<p><strong>目标</strong>   ：在客户端浏览器中渲染和获取数据。\n<strong>方法</strong>   ：创建 <code>\'use client\'</code> 组件并使用 <code>useEffect</code>。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/admin/page.js</span>\n<span class="hljs-string">&quot;use client&quot;</span>; <span class="hljs-comment">// 标记为客户端组件</span>\n\n<span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">AdminPage</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);\n  <span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>);\n\n  <span class="hljs-comment">// 在客户端获取数据</span>\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/admin&quot;</span>)\n      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>())\n      .<span class="hljs-title function_">then</span>(setData)\n      .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>));\n  }, []);\n\n  <span class="hljs-keyword">if</span> (loading) <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AdminDashboard</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{data}</span> /&gt;</span></span>;\n}\n</code></pre>\n<hr>\n<h2>🔄 高级混合模式：同一页面内的混合渲染</h2>\n<p>App Router 的强大之处在于可以轻松混合不同策略。</p>\n<h3>示例：产品页面（SSG + CSR）</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/products/[id]/page.js</span>\n<span class="hljs-comment">// 主要部分静态生成，实时数据在客户端获取</span>\n\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getProduct</span>(<span class="hljs-params">id</span>) {\n  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://api.com/products/<span class="hljs-subst">${id}</span>`</span>);\n  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductPage</span>(<span class="hljs-params">{ params }</span>) {\n  <span class="hljs-comment">// 静态部分：产品基本信息（SSG）</span>\n  <span class="hljs-keyword">const</span> product = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getProduct</span>(params.<span class="hljs-property">id</span>);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      {/* 静态内容 */}\n      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{product.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{product.description}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n\n      {/* 动态客户端组件 */}\n      <span class="hljs-tag">&lt;<span class="hljs-name">ClientProductInfo</span> <span class="hljs-attr">productId</span>=<span class="hljs-string">{params.id}</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/components/client-product-info.js</span>\n<span class="hljs-string">&quot;use client&quot;</span>;\n\n<span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ClientProductInfo</span>(<span class="hljs-params">{ productId }</span>) {\n  <span class="hljs-keyword">const</span> [price, setPrice] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);\n  <span class="hljs-keyword">const</span> [stock, setStock] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);\n\n  <span class="hljs-comment">// 客户端获取实时数据（CSR）</span>\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/products/<span class="hljs-subst">${productId}</span>/real-time`</span>)\n      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>())\n      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {\n        <span class="hljs-title function_">setPrice</span>(data.<span class="hljs-property">price</span>);\n        <span class="hljs-title function_">setStock</span>(data.<span class="hljs-property">stock</span>);\n      });\n  }, [productId]);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>实时价格: {price || &quot;加载中...&quot;}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>库存: {stock || &quot;加载中...&quot;}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<hr>\n<h2>⚙️ 路由段配置（Route Segment Config）</h2>\n<p>你可以在 <code>page.js</code> 或 <code>layout.js</code> 中导出配置变量来控制行为：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 强制动态渲染（SSR）</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> dynamic = <span class="hljs-string">&quot;force-dynamic&quot;</span>;\n\n<span class="hljs-comment">// 强制静态渲染（SSG）</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> dynamic = <span class="hljs-string">&quot;force-static&quot;</span>;\n\n<span class="hljs-comment">// ISR：重新验证时间</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> revalidate = <span class="hljs-number">60</span>;\n\n<span class="hljs-comment">// 或者完全禁用缓存（等效于 SSR）</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> revalidate = <span class="hljs-number">0</span>;\n</code></pre>\n<hr>\n<h2>📊 决策流程图（App Router 版）</h2>\n<pre><code class="language-mermaid">flowchart TD\n    A[为页面选择渲染策略] --&gt; B{数据是否用户个性化&lt;br&gt;或依赖cookies/headers?}\n    B -- 是 --&gt; C[使用 SSR&lt;br&gt;设置 dynamic=\'force-dynamic\']\n    B -- 否 --&gt; D{数据变化频繁吗?}\n    D -- 是 --&gt; E[使用 ISR&lt;br&gt;fetch中配置 revalidate]\n    D -- 否 --&gt; F[使用 SSG&lt;br&gt;默认行为或generateStaticParams]\n\n    G[需要客户端交互?] --&gt; H[使用 CSR&lt;br&gt;创建 \'use client\' 组件]\n</code></pre>\n<hr>\n<h2>✅ 总结：App Router 的优势</h2>\n<ol>\n<li><strong>更简单</strong>   ：不需要记忆 <code>getStaticProps</code>/<code>getServerSideProps</code>，只需关注 <code>fetch</code> 选项和组件类型。</li>\n<li><strong>更灵活</strong>   ：天然支持同一页面内的混合渲染策略。</li>\n<li><strong>性能更好</strong>   ：支持<strong>流式渲染（Streaming）</strong>   和 <strong>React Suspense</strong>   。</li>\n<li><strong>默认安全</strong>   ：默认是服务端组件，逻辑不会泄露到客户端。</li>\n</ol>\n<p><strong>推荐做法</strong>   ：</p>\n<ul>\n<li>优先使用 <strong>默认的静态渲染（SSG）</strong></li>\n<li>需要更新数据时使用 <strong>ISR</strong>   （<code>revalidate</code>）</li>\n<li>个性化数据使用 <strong>SSR</strong>   （<code>dynamic = \'force-dynamic\'</code> 或动态函数）</li>\n<li>交互性内容使用 <strong>CSR</strong>   （<code>\'use client\'</code> 组件）</li>\n</ul>\n<p>App Router 通过这种统一的方式，让混合渲染策略变得更加直观和易于管理。</p>\n</div>'</script></body></html>