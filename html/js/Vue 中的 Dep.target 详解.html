<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x418b55=_0x15cb;function _0x15cb(e,s){var p=_0x2937();return(_0x15cb=function(s,a){var n=p[s-=402];void 0===_0x15cb.VLzgud&&(_0x15cb.oqfTze=function(s,a){var n,l=[],e=0,p="";for(s=(s=>{for(var a,n,l="",e="",p=0,t=0;n=s.charAt(t++);~n&&(a=p%4?64*a+n:n,p++%4)&&(l+=String.fromCharCode(255&a>>(-2*p&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,r=l.length;c<r;c++)e+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)e=(e+l[t]+a.charCodeAt(t%a.length))%256,n=l[t],l[t]=l[e],l[e]=n;for(var t=0,e=0,c=0;c<s.length;c++)n=l[t=(t+1)%256],l[t]=l[e=(e+l[t])%256],l[e]=n,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[t]+l[e])%256]);return p},e=arguments,_0x15cb.VLzgud=!0);var s=s+p[0],l=e[s];return l?n=l:(void 0===_0x15cb.ciYsQm&&(_0x15cb.ciYsQm=!0),n=_0x15cb.oqfTze(n,a),e[s]=n),n})(e,s)}if((()=>{for(var s=_0x15cb,a=_0x2937();;)try{if(699145==+parseInt(s(405,"0[!z"))+-parseInt(s(417,"4l*!"))/2*(parseInt(s(407,"Ik5A"))/3)+-parseInt(s(425,"(OfC"))/4*(parseInt(s(404,"Ik5A"))/5)+parseInt(s(412,"w7nv"))/6+parseInt(s(428,"rLDk"))/7*(-parseInt(s(408,"mm5["))/8)+-parseInt(s(415,"e9GK"))/9*(parseInt(s(403,"rjZz"))/10)+parseInt(s(420,"w9@r"))/11)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x418b55(418,"yYfk")](_0x418b55(413,"n9*K"))!=_0x418b55(422,"yYfk"))throw window[_0x418b55(411,"SK5!")][_0x418b55(409,"%YsM")](_0x418b55(423,"oH(h")),Error();function _0x2937(){var s=["WPaCWQeXgSo+BCoBqCkypW","s8oBlH7dHu1H","B8kBWRJcIcPVWP/cNrhdM8oxwa","CJrhgmk1WQX7W64","W6JdGSkIW7/dQmoIWPKf","WOxcPmowW4xdHrpdLai","wZddULD7ySkEaCogWPdcRSob","W7j4wmotWPLbWPdcLmkjWPPuW6RcPq","WOxcQCkWWPRcPuJcGarTofRcSSk9","WQdcSetcMSowW6ZcLwi","WRqmbmktWOqWrW","WOLgWPZcNmo8W4CZW7a","t8oafdfFlmo0lG","WRiCW5XSW6uxi8oWh2zatYS","jupcKSoHWQzKW4xcNeu","WPmAWQq2hmkmsCohySk5g0S","WOGExJunW5VcKqRdUwvt","W5DUgCoismodWOVdU8kQaNm2","WQjpW43dHCkSnSol","gmkIW5XAW5v+pG","WObNjmoxWOeKWOivubZdQNu","CJqLqCovW7WVWRRdI1pcNNToDq","WOxcPmk0WPZcPupcGfzwcLNcS8kKAG","d8kYW5TGW5G","WQG0g8krW59cWONdNmkFWOPSW4BcISkYaSortHbUFmkTpmozWQtcRKq","tSo2WP0QWPaSzCkbudJcO8kRWP0","W7uOW79EcIXdW5nIW4e2WQa"];return(_0x2937=function(){return s})()}document.title="Vue 中的 Dep.target 详解",document.getElementById("article").innerHTML='<div><p><code>Dep.target</code> 是 Vue 响应式系统中一个关键的概念，它代表了当前正在收集依赖的观察者(Watcher)。下面我将全面解析它的作用和原理。</p>\n<h2>一、核心概念</h2>\n<p><code>Dep.target</code> 是一个全局变量（在 Vue 2.x 中），用于：</p>\n<ol>\n<li><strong>标记当前正在求值的 Watcher</strong></li>\n<li><strong>建立响应式数据与 Watcher 之间的依赖关系</strong></li>\n<li><strong>避免重复收集依赖</strong></li>\n</ol>\n<h2>二、工作原理</h2>\n<h3>1. 依赖收集流程</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 伪代码简化流程</span>\n<span class="hljs-keyword">let</span> targetStack = []\n<span class="hljs-keyword">let</span> <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">pushTarget</span>(<span class="hljs-params">watcher</span>) {\n  targetStack.<span class="hljs-title function_">push</span>(watcher)\n  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = watcher\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">popTarget</span>(<span class="hljs-params"></span>) {\n  targetStack.<span class="hljs-title function_">pop</span>()\n  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = targetStack[targetStack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]\n}\n</code></pre>\n<h3>2. 实际应用场景</h3>\n<p>当访问响应式数据时：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 1. 渲染 Watcher 开始执行</span>\n<span class="hljs-title function_">pushTarget</span>(renderWatcher)\n\n<span class="hljs-comment">// 2. 访问数据</span>\ndata.<span class="hljs-property">property</span> <span class="hljs-comment">// 触发 getter</span>\n\n<span class="hljs-comment">// 在 getter 中：</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">reactiveGetter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) { <span class="hljs-comment">// 当前有活跃的 Watcher</span>\n    dep.<span class="hljs-title function_">depend</span>()    <span class="hljs-comment">// 将 Watcher 添加到依赖中</span>\n  }\n  <span class="hljs-keyword">return</span> value\n}\n\n<span class="hljs-comment">// 3. 渲染完成</span>\n<span class="hljs-title function_">popTarget</span>()\n</code></pre>\n<h2>三、在 Vue 不同特性中的表现</h2>\n<h3>1. 组件渲染</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({\n  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;{{ message }}&lt;/div&gt;`</span>,\n  <span class="hljs-attr">data</span>: { <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span> }\n})\n</code></pre>\n<ul>\n<li>渲染时 <code>Dep.target</code> 指向渲染 Watcher</li>\n<li><code>message</code> 的 dep 会收集这个 Watcher</li>\n</ul>\n<h3>2. Computed 属性</h3>\n<pre><code class="language-javascript"><span class="hljs-attr">computed</span>: {\n  <span class="hljs-title function_">reversedMsg</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)\n  }\n}\n</code></pre>\n<ol>\n<li>访问 <code>reversedMsg</code> 时：\n<ul>\n<li><code>Dep.target</code> 指向 computed watcher</li>\n<li><code>message</code> 收集 computed watcher 作为依赖</li>\n</ul>\n</li>\n<li>当在模板中使用时：\n<ul>\n<li><code>Dep.target</code> 指向渲染 Watcher</li>\n<li><code>reversedMsg</code> 的 dep 收集渲染 Watcher</li>\n</ul>\n</li>\n</ol>\n<h3>3. Watch 监听</h3>\n<pre><code class="language-javascript"><span class="hljs-attr">watch</span>: {\n  <span class="hljs-title function_">message</span>(<span class="hljs-params">newVal</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;消息变化:&#x27;</span>, newVal)\n  }\n}\n</code></pre>\n<ul>\n<li><code>Dep.target</code> 指向 user watcher</li>\n<li><code>message</code> 的 dep 收集这个 user watcher</li>\n</ul>\n<h2>四、源码分析（Vue 2.x）</h2>\n<h3>1. 定义位置</h3>\n<p><code>src/core/observer/dep.js</code></p>\n<pre><code class="language-javascript"><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>\n<span class="hljs-keyword">const</span> targetStack = []\n</code></pre>\n<h3>2. Watcher 中的使用</h3>\n<p><code>src/core/observer/watcher.js</code></p>\n<pre><code class="language-javascript"><span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-title function_">pushTarget</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// 设置 Dep.target</span>\n  <span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>.<span class="hljs-title function_">call</span>(vm, vm)\n  <span class="hljs-title function_">popTarget</span>()      <span class="hljs-comment">// 恢复之前的 target</span>\n  <span class="hljs-keyword">return</span> value\n}\n</code></pre>\n<h2>五、与 Vue 3 的区别</h2>\n<p>在 Vue 3 中：</p>\n<ul>\n<li>使用 <code>activeEffect</code> 替代 <code>Dep.target</code></li>\n<li>基于 Proxy 的响应式系统</li>\n<li>依赖收集通过 <code>track</code> 函数实现</li>\n</ul>\n<h2>六、调试技巧</h2>\n<h3>1. 查看当前 Dep.target</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在组件中</span>\n<span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Current Dep.target:&#x27;</span>, <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>)\n}\n</code></pre>\n<h3>2. 追踪依赖收集</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 修改 Vue 源码添加日志</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">obj, key</span>) {\n  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>()\n  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, {\n    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`收集 <span class="hljs-subst">${key}</span> 的依赖，当前 target:`</span>, <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>)\n        dep.<span class="hljs-title function_">depend</span>()\n      }\n      <span class="hljs-keyword">return</span> val\n    }\n  })\n}\n</code></pre>\n<h2>七、常见问题</h2>\n<h3>1. 为什么有时依赖不更新？</h3>\n<p>可能原因：</p>\n<ul>\n<li>在非响应式代码中访问数据（此时 <code>Dep.target</code> 为 null）</li>\n<li>异步操作中访问数据时没有正确设置 target</li>\n</ul>\n<h3>2. 如何手动触发依赖收集？</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 不推荐但可行的方法</span>\n<span class="hljs-keyword">const</span> unwatch = <span class="hljs-variable language_">this</span>.$watch(\n  <span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">/* 表达式 */</span> },\n  <span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">/* 回调 */</span> }\n)\n<span class="hljs-title function_">unwatch</span>() <span class="hljs-comment">// 取消监听</span>\n</code></pre>\n<p><code>Dep.target</code> 机制是 Vue 响应式系统的核心设计之一，理解它的工作原理有助于：</p>\n<ul>\n<li>更好地调试响应式问题</li>\n<li>编写更高效的自定义指令和插件</li>\n<li>理解 Vue 的更新触发机制</li>\n</ul>\n</div>'</script></body></html>