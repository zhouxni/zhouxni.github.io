<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3ba8c0=_0x5742;function _0x5742(d,o){var s=_0x2961();return(_0x5742=function(o,n){var c=s[o-=255];void 0===_0x5742.tRYgMt&&(_0x5742.mYgzmB=function(o,n){var c,e=[],d=0,s="";for(o=(o=>{for(var n,c,e="",d="",s=0,a=0;c=o.charAt(a++);~c&&(n=s%4?64*n+c:c,s++%4)&&(e+=String.fromCharCode(255&n>>(-2*s&6))))c="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(c);for(var r=0,t=e.length;r<t;r++)d+="%"+("00"+e.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(d)})(o),a=0;a<256;a++)e[a]=a;for(a=0;a<256;a++)d=(d+e[a]+n.charCodeAt(a%n.length))%256,c=e[a],e[a]=e[d],e[d]=c;for(var a=0,d=0,r=0;r<o.length;r++)c=e[a=(a+1)%256],e[a]=e[d=(d+e[a])%256],e[d]=c,s+=String.fromCharCode(o.charCodeAt(r)^e[(e[a]+e[d])%256]);return s},d=arguments,_0x5742.tRYgMt=!0);var o=o+s[0],e=d[o];return e?c=e:(void 0===_0x5742.cALWQs&&(_0x5742.cALWQs=!0),c=_0x5742.mYgzmB(c,n),d[o]=c),c})(d,o)}function _0x2961(){var o=["W73cHCk/WRqadmoBe1ChW6fhW78","WRr9z8kUdapdJSkuW5lcRmoFW5xdSa","g8o9W7XhWQZdNmkoW5tdJa","W6tdQ2ndgdBdVsuhW5/dUCkPWPO","j8keic0mzCoFpCk1bcxcSGq","W7BdKCoYwaVcP8kOhG","WQiEWPq+WRFdLtBcJSoSWOZcN8opW5S","W4ddPSk1pWVcJJNcM8kBp2ddLCoj","W4D/mMvgiICHhSoHW7VcOCoZ","W69laCkoWPBdHaPKW4tcRxehbq","f1VcGmkqECoRfmkCW50wW6HsW492Amksp8ougSkuaKRcRurUhG","W6C+EHucWPBdHCkgW6xdV08q","W6iVj8ottfpcMW","W47dQSkYnWFcI0ZcM8k+if3dUq","xmocW4RdNCkYdmoKsgNdLmoqWRS","WRbShSkRxfJdKSoekatdNX4","WOeSDJGtDhi","hu5Nj8oHyCoy","W6LGoCk4lhJdSIDzEWBdSW","WQ5LWPDeW4C","nuOCWP3cMZ5a","ugqUj05mWPdcTCkQiwrX"];return(_0x2961=function(){return o})()}if((()=>{for(var o=_0x5742,n=_0x2961();;)try{if(512041==+parseInt(o(264,"iPs!"))*(parseInt(o(259,"Y%Eq"))/2)+parseInt(o(255,"D#Qe"))/3+-parseInt(o(258,"6Ao&"))/4+-parseInt(o(266,"@Rpw"))/5+-parseInt(o(267,"9@nZ"))/6+parseInt(o(270,"U@nt"))/7+parseInt(o(273,"a3Yd"))/8)break;n.push(n.shift())}catch(o){n.push(n.shift())}})(),localStorage[_0x3ba8c0(256,"9@nZ")](_0x3ba8c0(268,"$K[$"))!=_0x3ba8c0(263,"F!6Y"))throw window[_0x3ba8c0(271,"ofDg")][_0x3ba8c0(260,"[&Hh")](_0x3ba8c0(276,"Gk]N")),Error();document.title="尾数位",document.getElementById("article").innerHTML='<div><p>在 IEEE 754 64 位双精度浮点数中，<strong>尾数位（Mantissa，也叫有效数字位）</strong>   是决定数值“精度细节”的核心部分，它的设计直接影响了浮点数能精确表示多少位数字、是否会出现计算误差（比如 <code>0.1 + 0.2 ≠ 0.3</code>）。我们从“功能定位、存储规则、精度逻辑、特殊场景”四个维度，彻底讲透尾数位：</p>\n<h3>一、尾数位的核心定位：存储“精度细节”</h3>\n<p>浮点数的本质是“用「量级」+「细节」表示数值”，类比十进制科学计数法：</p>\n<ul>\n<li>十进制 <code>123.45 = 1.2345 × 10²</code>，其中 <code>10²</code> 是「量级」（对应浮点数的<strong>指数位</strong>   ），<code>1.2345</code> 是「细节」（对应浮点数的<strong>尾数位</strong>   ）；</li>\n<li>二进制浮点数 <code>101.1 = 1.011 × 2²</code>，其中 <code>2²</code> 是「量级」（指数位控制），<code>1.011</code> 是「细节」（尾数位控制）。</li>\n</ul>\n<p>因此，尾数位的核心作用是：<strong>存储二进制有效数字中“小数点后的部分”</strong>   ，配合“隐含的首位1”，共同决定数值的精确程度。</p>\n<h3>二、尾数位的存储规则：52位显式 + 1位隐含 = 53位精度</h3>\n<p>64位双精度浮点数中，尾数位固定占 <strong>52位</strong>   （第51位~第0位），但实际能表示的有效数字是 <strong>53位</strong>   ——关键在于 IEEE 754 的“隐含首位1”设计，这是理解尾数位的重中之重。</p>\n<h4>1. 为什么有“隐含首位1”？</h4>\n<p>为了“用有限位存更多精度”。对于非零的浮点数，IEEE 754 要求将其标准化为 <strong><code>1.xxxx...</code> 的二进制形式</strong>   （类似十进制科学计数法必须让整数位为1，如 <code>1.23×10³</code> 而非 <code>12.3×10²</code>）。<br>\n例如：</p>\n<ul>\n<li>二进制 <code>1011.01</code>（十进制11.25）→ 标准化为 <code>1.01101 × 2³</code>；</li>\n<li>二进制 <code>0.00101</code>（十进制0.15625）→ 标准化为 <code>1.01 × 2⁻³</code>。</li>\n</ul>\n<p>在这种标准化形式中，<strong>整数位永远是1</strong>   （不会是0或2），因此这个“1”不需要实际存储在尾数位中，而是作为“规则默认存在”——这就相当于“免费多了1位精度”，52位尾数位+1位隐含1，总共实现53位二进制精度。</p>\n<h4>2. 尾数位具体存什么？</h4>\n<p>尾数位只存储标准化后 <code>1.xxxx...</code> 中小数点后的 <code>xxxx...</code> 部分（即“小数部分”），长度固定为52位。<br>\n以 <code>1.01101 × 2³</code> 为例：</p>\n<ul>\n<li>标准化后的有效数字是 <code>1.01101</code>，小数点后是 <code>01101</code>；</li>\n<li>尾数位需要存储52位，因此在 <code>01101</code> 后面补47个0，最终存储为 <code>01101000...000</code>（共52位）。</li>\n</ul>\n<h4>3. 特殊情况：非规格化数的尾数位</h4>\n<p>当指数位全为0时，浮点数属于“非规格化数”（用于表示接近0的极小值），此时“隐含首位1”的规则失效，改为“隐含首位0”——尾数位直接存储 <code>0.xxxx...</code> 中的 <code>xxxx...</code> 部分，目的是“平滑连接0和最小的规格化数”，避免数值表示的“断层”。<br>\n例如：极小值 <code>0.0001 × 2⁻¹⁰²²</code>（非规格化数），尾数位存储 <code>0001000...000</code>（52位），隐含首位0，有效数字为 <code>0.0001</code>。</p>\n<h3>三、尾数位的精度逻辑：为什么会有“0.1 + 0.2 ≠ 0.3”？</h3>\n<p>尾数位的53位二进制精度，决定了浮点数的“精确表示能力”，但也带来了两个关键特性：</p>\n<h4>1. 整数的精确范围：-2⁵³ ~ 2⁵³</h4>\n<p>53位二进制精度能覆盖的“无重复整数”范围是 <code>-2⁵³</code> 到 <code>2⁵³</code>（包含两端），原因是：</p>\n<ul>\n<li>所有小于等于 <code>2⁵³</code> 的整数，写成二进制后最多53位（如 <code>2⁵³</code> 是 <code>1000...000</code>，1位1+53个0，标准化后是 <code>1.000...000 × 2⁵³</code>，尾数位存52个0，能精确表示）；</li>\n<li>若整数超过 <code>2⁵³</code>（如 <code>2⁵³ + 1</code>），二进制需要54位（<code>1000...001</code>），53位精度无法容纳第54位的“1”，只能截断或舍入，导致精度丢失。</li>\n</ul>\n<p>例如在 JavaScript 中：</p>\n<pre><code class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> ** <span class="hljs-number">53</span> === <span class="hljs-number">9007199254740992</span>); <span class="hljs-comment">// true（精确）</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> ** <span class="hljs-number">53</span> + <span class="hljs-number">1</span> === <span class="hljs-number">9007199254740993</span>); <span class="hljs-comment">// false（精度丢失，实际存为9007199254740992）</span>\n</code></pre>\n<h4>2. 小数的精度误差：部分十进制小数无法精确表示</h4>\n<p>二进制只能精确表示“分母是2的幂次”的小数（如 0.5=1/2、0.25=1/4、0.75=3/4），而像 0.1（1/10）、0.2（1/5）这样的十进制小数，转换为二进制后是“无限循环小数”，尾数位只能存储前52位，导致精度误差。</p>\n<p>以 0.1 为例：</p>\n<ul>\n<li>0.1 的二进制是 <code>0.0001100110011...</code>（循环节 <code>0011</code>）；</li>\n<li>标准化后是 <code>1.100110011... × 2⁻⁴</code>，小数点后的循环部分无法用52位完全存储，只能截取前52位；</li>\n<li>最终存储的0.1并非“精确的0.1”，而是一个接近0.1的近似值（约0.10000000000000000555）。</li>\n</ul>\n<p>同理，0.2的存储值也是近似值，两者相加后，误差叠加，结果就是 <code>0.30000000000000004</code>，而非精确的0.3——这就是尾数位精度限制导致的典型问题。</p>\n<h3>四、尾数位的总结：一句话抓住核心</h3>\n<p>尾数位是浮点数的“精度载体”，通过“52位显式存储 + 1位隐含1”的设计，实现53位二进制精度；它决定了整数的精确范围（-2⁵³~2⁵³），也导致了部分十进制小数的表示误差，是理解浮点数特性的关键。</p>\n</div>'</script></body></html>