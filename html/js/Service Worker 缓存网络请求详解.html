<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1b7de8=_0x1f94;function _0x2a8c(){var s=["W7eRgxJcVIiFySkwWRBdRmk9bW","WO5HW6jOW5eJACoaWR3cRCoKaJS","WPPbASkJWQ9OjmopWPNcItmAqW","WPi9AhDbuCkNyaRdTq","mmoiWRjDW6VcPgi","z0RdHCo8W5D3tG","DLlcTmkwWRxdU8oB","bgZcSHRcGq","v8kPW6lcIf/dVCk+ra","CmoCWRddKfzdWOZdMa","EeddGmkBW70wWPxdICo3WPbAW5mwW7H9WRtcMxnVW74zWR7cNdD9WRi","vSkXWQvzW40XW4WWWPhcJZhdTmki","vMNdOSosca/cSYJdQCkoueS","WP1mkgldM8kSz8k2ba","W5WXWRxdGCk9smoeW73cRrCDW5nQ","W7HZxCkrw8k3zW","hCkkECooW57dQgpdMSkPWQOyWQJcSa","d8orDYTIySkyCSoJbX3cIq","WRSHh8opd8k7BNroshi","WRSMgSolASk6sufuwG","aSkVW6BdPCkqWOSjC8kalrRcNCkl","WOnikKuKW7mLW6zSDYu","WP5pg8o4W7SbqmoB","xCobW5pcOemZW4tdKSoxWQudW7O","gePvWRjSwhdcQ8kvdgXsW6u","W40SFGybc8kxdK54qc8"];return(_0x2a8c=function(){return s})()}function _0x1f94(e,s){var l=_0x2a8c();return(_0x1f94=function(s,n){var a=l[s-=227];void 0===_0x1f94.UImBnH&&(_0x1f94.OYLMmX=function(s,n){var a,p=[],e=0,l="";for(s=(s=>{for(var n,a,p="",e="",l=0,t=0;a=s.charAt(t++);~a&&(n=l%4?64*n+a:a,l++%4)&&(p+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,h=p.length;c<h;c++)e+="%"+("00"+p.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),t=0;t<256;t++)p[t]=t;for(t=0;t<256;t++)e=(e+p[t]+n.charCodeAt(t%n.length))%256,a=p[t],p[t]=p[e],p[e]=a;for(var t=0,e=0,c=0;c<s.length;c++)a=p[t=(t+1)%256],p[t]=p[e=(e+p[t])%256],p[e]=a,l+=String.fromCharCode(s.charCodeAt(c)^p[(p[t]+p[e])%256]);return l},e=arguments,_0x1f94.UImBnH=!0);var s=s+l[0],p=e[s];return p?a=p:(void 0===_0x1f94.jJUniC&&(_0x1f94.jJUniC=!0),a=_0x1f94.OYLMmX(a,n),e[s]=a),a})(e,s)}if((()=>{for(var s=_0x1f94,n=_0x2a8c();;)try{if(606482==+parseInt(s(245,"CJ*B"))*(-parseInt(s(233,"nw!H"))/2)+-parseInt(s(240,"#nW@"))/3+parseInt(s(231,"vPM0"))/4*(parseInt(s(249,"@iI9"))/5)+parseInt(s(242,"$S^G"))/6+-parseInt(s(248,"8&0L"))/7+-parseInt(s(239,"v4B["))/8*(-parseInt(s(236,"J$aZ"))/9)+parseInt(s(228,"ZQfx"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1b7de8(232,"Iwf7")](_0x1b7de8(241,"9hY)"))!=_0x1b7de8(235,"uCSr"))throw window[_0x1b7de8(237,"J7@1")][_0x1b7de8(243,"OY6y")](_0x1b7de8(238,"%PK]")),Error();document.title="Service Worker 缓存网络请求详解",document.getElementById("article").innerHTML='<div><p>Service Worker 可以通过拦截网络请求来实现灵活的缓存策略，但需要开发者手动实现缓存逻辑。以下是完整的实现方法和策略：</p>\n<h2>基础缓存实现</h2>\n<h3>1. 预缓存核心资源（安装阶段）</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在install阶段缓存关键静态资源</span>\nself.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">waitUntil</span>(\n    caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">addAll</span>([\n        <span class="hljs-string">&#x27;/&#x27;</span>,\n        <span class="hljs-string">&#x27;/index.html&#x27;</span>,\n        <span class="hljs-string">&#x27;/styles/main.css&#x27;</span>,\n        <span class="hljs-string">&#x27;/scripts/app.js&#x27;</span>,\n        <span class="hljs-string">&#x27;/images/logo.png&#x27;</span>\n      ]);\n    })\n  );\n});\n</code></pre>\n<h3>2. 拦截请求并返回缓存（运行时）</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 拦截所有fetch请求</span>\nself.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">respondWith</span>(\n    caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>)\n      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cachedResponse</span> =&gt;</span> {\n        <span class="hljs-comment">// 返回缓存或继续网络请求</span>\n        <span class="hljs-keyword">return</span> cachedResponse || <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>);\n      })\n  );\n});\n</code></pre>\n<h2>高级缓存策略</h2>\n<h3>1. 缓存优先，网络回退</h3>\n<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">respondWith</span>(\n    caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>)\n      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cachedResponse</span> =&gt;</span> {\n        <span class="hljs-comment">// 有缓存直接返回</span>\n        <span class="hljs-keyword">if</span> (cachedResponse) <span class="hljs-keyword">return</span> cachedResponse;\n        \n        <span class="hljs-comment">// 无缓存则请求网络</span>\n        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">networkResponse</span> =&gt;</span> {\n          <span class="hljs-comment">// 将新响应加入缓存</span>\n          <span class="hljs-keyword">const</span> responseClone = networkResponse.<span class="hljs-title function_">clone</span>();\n          caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n            cache.<span class="hljs-title function_">put</span>(event.<span class="hljs-property">request</span>, responseClone);\n          });\n          <span class="hljs-keyword">return</span> networkResponse;\n        });\n      })\n  );\n});\n</code></pre>\n<h3>2. 网络优先，缓存回退</h3>\n<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">respondWith</span>(\n    <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>)\n      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">networkResponse</span> =&gt;</span> {\n        <span class="hljs-comment">// 网络请求成功，更新缓存</span>\n        <span class="hljs-keyword">const</span> responseClone = networkResponse.<span class="hljs-title function_">clone</span>();\n        caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n          cache.<span class="hljs-title function_">put</span>(event.<span class="hljs-property">request</span>, responseClone);\n        });\n        <span class="hljs-keyword">return</span> networkResponse;\n      })\n      .<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> {\n        <span class="hljs-comment">// 网络失败时返回缓存</span>\n        <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>);\n      })\n  );\n});\n</code></pre>\n<h3>3. 快速响应（缓存+网络更新）</h3>\n<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">respondWith</span>(\n    caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cached</span> =&gt;</span> {\n      <span class="hljs-comment">// 立即返回缓存（如果有）</span>\n      <span class="hljs-keyword">const</span> fetchPromise = <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">networkResponse</span> =&gt;</span> {\n        <span class="hljs-comment">// 网络响应后更新缓存</span>\n        <span class="hljs-keyword">const</span> responseClone = networkResponse.<span class="hljs-title function_">clone</span>();\n        caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n          cache.<span class="hljs-title function_">put</span>(event.<span class="hljs-property">request</span>, responseClone);\n        });\n      });\n      <span class="hljs-keyword">return</span> cached || fetchPromise;\n    })\n  );\n});\n</code></pre>\n<h2>特殊请求处理</h2>\n<h3>1. 处理POST请求</h3>\n<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">request</span>.<span class="hljs-property">method</span> === <span class="hljs-string">&#x27;POST&#x27;</span>) {\n    <span class="hljs-comment">// POST请求不缓存，直接转发</span>\n    event.<span class="hljs-title function_">respondWith</span>(<span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>));\n    <span class="hljs-keyword">return</span>;\n  }\n  <span class="hljs-comment">// 其他请求走缓存逻辑</span>\n  <span class="hljs-comment">// ...</span>\n});\n</code></pre>\n<h3>2. 处理图片缓存</h3>\n<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">request</span>.<span class="hljs-property">destination</span> === <span class="hljs-string">&#x27;image&#x27;</span>) {\n    event.<span class="hljs-title function_">respondWith</span>(\n      caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cached</span> =&gt;</span> {\n        <span class="hljs-keyword">return</span> cached || <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {\n          <span class="hljs-comment">// 只缓存成功的图片响应</span>\n          <span class="hljs-keyword">if</span> (response.<span class="hljs-property">ok</span>) {\n            <span class="hljs-keyword">const</span> clone = response.<span class="hljs-title function_">clone</span>();\n            caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;images-cache&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n              cache.<span class="hljs-title function_">put</span>(event.<span class="hljs-property">request</span>, clone);\n            });\n          }\n          <span class="hljs-keyword">return</span> response;\n        });\n      })\n    );\n    <span class="hljs-keyword">return</span>;\n  }\n  <span class="hljs-comment">// 其他资源处理...</span>\n});\n</code></pre>\n<h2>缓存管理</h2>\n<h3>1. 清理旧缓存</h3>\n<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">waitUntil</span>(\n    caches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cacheNames</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(\n        cacheNames.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> name !== <span class="hljs-string">&#x27;v2&#x27;</span>)\n          .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> caches.<span class="hljs-title function_">delete</span>(name))\n      );\n    })\n  );\n});\n</code></pre>\n<h3>2. 限制缓存大小</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trimCache</span>(<span class="hljs-params">cacheName, maxItems</span>) {\n  caches.<span class="hljs-title function_">open</span>(cacheName).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n    cache.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">keys</span> =&gt;</span> {\n      <span class="hljs-keyword">if</span> (keys.<span class="hljs-property">length</span> &gt; maxItems) {\n        cache.<span class="hljs-title function_">delete</span>(keys[<span class="hljs-number">0</span>]).<span class="hljs-title function_">then</span>(<span class="hljs-title function_">trimCache</span>(cacheName, maxItems));\n      }\n    });\n  });\n}\n</code></pre>\n<h2>注意事项</h2>\n<ol>\n<li><strong>HTTPS要求</strong>  ：生产环境必须使用HTTPS（localhost除外）</li>\n<li><strong>缓存时效性</strong>  ：需要实现合理的缓存更新机制</li>\n<li><strong>存储限制</strong>  ：浏览器对缓存空间有限制（通常为域名存储空间的50%）</li>\n<li><strong>非GET请求</strong>  ：默认不应缓存POST等非GET请求</li>\n<li><strong>CORS请求</strong>  ：跨域请求需要特殊处理</li>\n</ol>\n<p>通过合理组合这些策略，可以构建出适合自己应用的缓存系统，显著提升Web应用的性能和离线体验。</p>\n</div>'</script></body></html>