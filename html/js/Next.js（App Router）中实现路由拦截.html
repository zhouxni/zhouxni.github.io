<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x45e407=_0xe8dd;function _0xe8dd(l,s){var e=_0x29a3();return(_0xe8dd=function(s,n){var a=e[s-=360];void 0===_0xe8dd.IjpECo&&(_0xe8dd.dxFOyd=function(s,n){var a,t=[],l=0,e="";for(s=(s=>{for(var n,a,t="",l="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,r=t.length;o<r;o++)l+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)l=(l+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[l],t[l]=a;for(var p=0,l=0,o=0;o<s.length;o++)a=t[p=(p+1)%256],t[p]=t[l=(l+t[p])%256],t[l]=a,e+=String.fromCharCode(s.charCodeAt(o)^t[(t[p]+t[l])%256]);return e},l=arguments,_0xe8dd.IjpECo=!0);var s=s+e[0],t=l[s];return t?a=t:(void 0===_0xe8dd.NAxEtf&&(_0xe8dd.NAxEtf=!0),a=_0xe8dd.dxFOyd(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0xe8dd,n=_0x29a3();;)try{if(827444==-parseInt(s(367,"#](O"))+-parseInt(s(371,"PZ^("))/2+parseInt(s(375,"MpRh"))/3*(parseInt(s(379,"U$wC"))/4)+parseInt(s(363,"NGAH"))/5*(parseInt(s(361,"z3F["))/6)+parseInt(s(378,"ew0a"))/7+-parseInt(s(383,"[OK2"))/8+-parseInt(s(370,"46!8"))/9*(-parseInt(s(377,"4V4y"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x45e407(366,"i@pk")](_0x45e407(362,"PZ^("))!=_0x45e407(380,"iXrE"))throw window[_0x45e407(372,"cNc8")][_0x45e407(376,"xy!D")](_0x45e407(360,"K7&e")),Error();function _0x29a3(){var s=["W5L9W6HoWPO7lSojfW","EaTGfSoXu3X7WQ7cUG","W4tdPCkHW7hdVhiW","WP90f3XXW6XHmCkcr8kIta","WOddMSkhawbkzG","W6SMWQBcSmoQwGZdOCoSWRCQW5S","W6BdTce0WP5LhZGLvCojWR8","WRDlqGiCWPKBWRb9WPHZyW","WQzdySo/ySkWyCksd2ib","WQ8NWRKFW51Wp8oQamo5WQvT","W64Ce1fyW4GXWPW","CCo8FSohoNpcMN3dOCkb","W73dR8ofomkQlSk2FSoPW6Wa","i8ktkSkVsN4pvvHmbCku","WO0GWONdRmkWWRpdTG","f0Xhq8otW5WdW67dPCoJ","r3uwWP9vESo1gmoMCCkkDte","WRy2uCkvbhpdHG","WOZdGCk/W5RdTq","CSo/W5PwFbpdTCoGW4LBWR7dPmkV","nwlcTmknW4eiW64jWQVdGa","WQeczdOzCCoJWQldSmkmWQmeCG","sN4mCthcHwCDAvCaoh0","DCo+ECoedudcHM7dHSkY","WRNcTw10W5LMsfygwSoJWRVcH0f0WQJcIdTzWRhdRmoBW7j9FN0","WPRdRmoHW7/dHxNdICkvo0y"];return(_0x29a3=function(){return s})()}document.title="Next.js（App Router）中实现路由拦截",document.getElementById("article").innerHTML='<div><p>在 Next.js（App Router）中实现路由拦截（Route Interception），可以通过 <strong>动态路由</strong>   、<strong>中间件（Middleware）</strong>   或 <strong>布局（Layout）</strong>   结合条件渲染来实现。以下是具体方案：</p>\n<hr>\n<h3><strong>1. 中间件（Middleware）全局拦截</strong></h3>\n<p>适用于 <strong>全局路由守卫</strong>   （如身份验证、权限控制）。<br>\n在项目根目录创建 <code>middleware.js</code>：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// middleware.js</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/server&quot;</span>;\n<span class="hljs-keyword">import</span> { verifyToken } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./lib/auth&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request</span>) {\n  <span class="hljs-keyword">const</span> token = request.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;token&quot;</span>)?.<span class="hljs-property">value</span>;\n  <span class="hljs-keyword">const</span> { pathname } = request.<span class="hljs-property">nextUrl</span>;\n\n  <span class="hljs-comment">// 拦截未登录用户访问 /dashboard</span>\n  <span class="hljs-keyword">if</span> (pathname.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;/dashboard&quot;</span>) &amp;&amp; !token) {\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">redirect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&quot;/login&quot;</span>, request.<span class="hljs-property">url</span>));\n  }\n\n  <span class="hljs-comment">// 拦截已登录用户访问 /login 或 /register</span>\n  <span class="hljs-keyword">if</span> ([<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-string">&quot;/register&quot;</span>].<span class="hljs-title function_">includes</span>(pathname) &amp;&amp; token) {\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">redirect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&quot;/dashboard&quot;</span>, request.<span class="hljs-property">url</span>));\n  }\n\n  <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>();\n}\n\n<span class="hljs-comment">// 配置拦截范围（可选）</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> config = {\n  <span class="hljs-attr">matcher</span>: [<span class="hljs-string">&quot;/dashboard/:path*&quot;</span>, <span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-string">&quot;/register&quot;</span>],\n};\n</code></pre>\n<hr>\n<h3><strong>2. 动态路由局部拦截</strong></h3>\n<p>适用于 <strong>按需拦截特定路由</strong>   （如模态框叠加路由）。</p>\n<h4><strong>(1) 定义拦截路由结构</strong></h4>\n<pre><code>app\n├── @auth\n│   └── login\n│       └── page.tsx  # 拦截后的模态框内容\n├── login\n│   └── page.tsx      # 原始登录页\n└── layout.tsx        # 处理拦截逻辑\n</code></pre>\n<h4><strong>(2) 在布局中处理拦截逻辑</strong></h4>\n<pre><code class="language-tsx"><span class="hljs-comment">// app/layout.tsx</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">InterceptedLogin</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/components/intercepted-login&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Layout</span>(<span class="hljs-params">{ children }: { children: React.ReactNode }</span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>\n      {children}\n      {/* 拦截 /login 时显示模态框 */}\n      <span class="hljs-tag">&lt;<span class="hljs-name">InterceptedLogin</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/&gt;</span></span>\n  );\n}\n</code></pre>\n<h4><strong>(3) 定义拦截组件</strong></h4>\n<pre><code class="language-tsx"><span class="hljs-comment">// components/intercepted-login.tsx</span>\n<span class="hljs-string">&quot;use client&quot;</span>;\n\n<span class="hljs-keyword">import</span> { usePathname } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/navigation&quot;</span>;\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Modal</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/components/ui/modal&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">InterceptedLogin</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> pathname = <span class="hljs-title function_">usePathname</span>();\n  <span class="hljs-keyword">const</span> isIntercepted = pathname === <span class="hljs-string">&quot;/@auth/login&quot;</span>;\n\n  <span class="hljs-keyword">if</span> (!isIntercepted) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Modal</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;p-4&quot;</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登录（模态框）<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n        {/* 此处放置登录表单 */}\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">Modal</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<hr>\n<h3><strong>3. 路由组（Route Groups） + 条件渲染</strong></h3>\n<p>适用于 <strong>分组路由的权限控制</strong>   。</p>\n<h4><strong>(1) 创建路由组</strong></h4>\n<pre><code>app\n├── (auth)\n│   ├── login\n│   │   └── page.tsx\n│   └── register\n│       └── page.tsx\n├── (protected)\n│   └── dashboard\n│       └── page.tsx\n└── layout.tsx\n</code></pre>\n<h4><strong>(2) 在布局中校验权限</strong></h4>\n<pre><code class="language-tsx"><span class="hljs-comment">// app/(protected)/layout.tsx</span>\n<span class="hljs-keyword">import</span> { redirect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/navigation&quot;</span>;\n<span class="hljs-keyword">import</span> { getSession } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/lib/auth&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProtectedLayout</span>(<span class="hljs-params">{\n  children,\n}: {\n  children: React.ReactNode;\n}</span>) {\n  <span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getSession</span>();\n\n  <span class="hljs-keyword">if</span> (!session) {\n    <span class="hljs-title function_">redirect</span>(<span class="hljs-string">&quot;/login&quot;</span>); <span class="hljs-comment">// 未登录则重定向</span>\n  }\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>{children}<span class="hljs-tag">&lt;/&gt;</span></span>;\n}\n</code></pre>\n<hr>\n<h3><strong>4. 高级场景：并行路由（Parallel Routes）</strong></h3>\n<p>适用于 <strong>复杂拦截逻辑</strong>   （如同时展示主页面和拦截内容）。</p>\n<h4><strong>(1) 定义并行路由结构</strong></h4>\n<pre><code>app\n├── @modal\n│   └── (.)login      # (.)表示相对路径\n│       └── page.tsx\n├── login\n│   └── page.tsx\n└── layout.tsx\n</code></pre>\n<h4><strong>(2) 配置布局文件</strong></h4>\n<pre><code class="language-tsx"><span class="hljs-comment">// app/layout.tsx</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Layout</span>(<span class="hljs-params">{\n  children,\n  modal,\n}: {\n  children: React.ReactNode;\n  modal: React.ReactNode;\n}</span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>\n      {children}\n      {modal}\n    <span class="hljs-tag">&lt;/&gt;</span></span>\n  );\n}\n</code></pre>\n<p>访问 <code>/login</code> 时：</p>\n<ul>\n<li>默认显示 <code>login/page.tsx</code></li>\n<li>访问 <code>/(@modal)/login</code> 会同时渲染主页面和模态框。</li>\n</ul>\n<hr>\n<h3><strong>5. 对比与选型</strong></h3>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>适用场景</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>中间件</strong></td>\n<td>全局权限控制</td>\n<td>统一管理，性能好</td>\n<td>无法处理复杂 UI 拦截</td>\n</tr>\n<tr>\n<td><strong>动态路由</strong></td>\n<td>模态框/局部拦截</td>\n<td>灵活搭配 UI</td>\n<td>需要手动处理路由结构</td>\n</tr>\n<tr>\n<td><strong>路由组 + 布局</strong></td>\n<td>分组路由权限</td>\n<td>逻辑清晰</td>\n<td>仅适用于组内路由</td>\n</tr>\n<tr>\n<td><strong>并行路由</strong></td>\n<td>同时展示主页面和拦截内容</td>\n<td>支持复杂场景</td>\n<td>配置较复杂</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>常见问题</strong></h3>\n<h4><strong>Q1: 如何获取拦截前的路由路径？</strong></h4>\n<ul>\n<li>在中间件中通过 <code>request.nextUrl</code> 获取：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> referer = request.<span class="hljs-property">headers</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;referer&quot;</span>);\n</code></pre>\n</li>\n<li>在客户端通过 <code>useRouter</code>：<pre><code class="language-tsx"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>();\n<span class="hljs-keyword">const</span> previousPath = router.<span class="hljs-title function_">back</span>();\n</code></pre>\n</li>\n</ul>\n<h4><strong>Q2: 如何取消拦截？</strong></h4>\n<ul>\n<li>使用 <code>router.replace()</code> 清除拦截状态：<pre><code class="language-tsx">router.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;/dashboard&quot;</span>, { <span class="hljs-attr">scroll</span>: <span class="hljs-literal">false</span> });\n</code></pre>\n</li>\n</ul>\n<h4><strong>Q3: 如何区分硬导航和客户端导航？</strong></h4>\n<ul>\n<li>在中间件中检查 <code>request.headers.get(\'sec-fetch-mode\') === \'navigate\'</code>。</li>\n</ul>\n<hr>\n<p>按需选择上述方案即可实现 Next.js App Router 的路由拦截。如果需要更具体的实现（如结合身份验证库），可以进一步说明需求！</p>\n</div>'</script></body></html>