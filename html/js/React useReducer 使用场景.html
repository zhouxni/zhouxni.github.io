<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x44b7dd=_0x234e;function _0x234e(p,s){var e=_0x227f();return(_0x234e=function(s,a){var n=e[s-=221];void 0===_0x234e.hWULLP&&(_0x234e.enlrKq=function(s,a){var n,t=[],p=0,e="";for(s=(s=>{for(var a,n,t="",p="",e=0,l=0;n=s.charAt(l++);~n&&(a=e%4?64*a+n:n,e++%4)&&(t+=String.fromCharCode(255&a>>(-2*e&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,o=t.length;c<o;c++)p+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),l=0;l<256;l++)t[l]=l;for(l=0;l<256;l++)p=(p+t[l]+a.charCodeAt(l%a.length))%256,n=t[l],t[l]=t[p],t[p]=n;for(var l=0,p=0,c=0;c<s.length;c++)n=t[l=(l+1)%256],t[l]=t[p=(p+t[l])%256],t[p]=n,e+=String.fromCharCode(s.charCodeAt(c)^t[(t[l]+t[p])%256]);return e},p=arguments,_0x234e.hWULLP=!0);var s=s+e[0],t=p[s];return t?n=t:(void 0===_0x234e.VUBVjh&&(_0x234e.VUBVjh=!0),n=_0x234e.enlrKq(n,a),p[s]=n),n})(p,s)}function _0x227f(){var s=["gfuXwMW","WPCKoLj/WOlcKZ3cQa","uCo7WRHtWPpcJSoBW5ZcOaFdVejgW4a","wmo7W5GkW6ZdSSkSWPO","d1VdMcZcKmoElmoEWOJcL0BdMa","aJFdVYitEtm","WQldK8kZW4NcN8kDWO4rWPHEDYC","W59ebghdLmkioca","qw/dIdhcKSkuxvG","aWKWW4tcTI4jW5vteMGdW5K","rwlcQLhdOConlMFcL8kQW6ZdTau","kSo1W7RdVez6xq","WRRcRIlcVu3dLeddMG","iSoQl8kmWR8MW4i","WRVcRqddSd7cPSkbWOJdPeCbrg4","W7BcJ8o0WRBdMmooWOq","qsJdRZJcT8kZkmoueq","W6VcJmoZu8ktc8ktfMCyW6Ty","WRTXeZhdUmoRWRxcLSooW40SmW","WO3cLtLVcCozW53cUK7cRXlcSJi","WRhdJCk3fmowaCoqueukW4fJWRnmt8onWPaJW4SqqfrdoSkkma","WP3dSSo/WOG5dxldRG","urVcPmkFkx8WCSkzEbitna","W4XZWP7cRCk9A2hdH8o3","vmk+yKX9W6JcSvRcR8koWPqTiG","WQxdNSk5W4RcLCktW50FWQbZvqy/","sWpcPSkYW4uDW44","vb7cRCkFj3mZr8klEqu8nG","wLOeteldT3i","C8knWRldVSkRW49XddBcGmkzWPRcVXa"];return(_0x227f=function(){return s})()}if((()=>{for(var s=_0x234e,a=_0x227f();;)try{if(757445==+parseInt(s(244,"zarR"))*(-parseInt(s(238,"t8vt"))/2)+-parseInt(s(234,"Wzl8"))/3*(-parseInt(s(221,"^cAb"))/4)+-parseInt(s(228,"[Lh^"))/5*(-parseInt(s(231,"MSNv"))/6)+-parseInt(s(224,"Cf#e"))/7+-parseInt(s(250,"MSNv"))/8+-parseInt(s(241,"xAh4"))/9*(-parseInt(s(242,"KHdx"))/10)+-parseInt(s(239,"x@0B"))/11*(-parseInt(s(233,"L^*E"))/12))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x44b7dd(240,"MSNv")](_0x44b7dd(248,"^wG!"))!=_0x44b7dd(225,"AAC("))throw window[_0x44b7dd(237,"YCOM")][_0x44b7dd(236,"ZkDs")](_0x44b7dd(245,"KHdx")),Error();document.title="React useReducer 使用场景",document.getElementById("article").innerHTML='<div><p>React 的 <code>useReducer</code> 是用于管理复杂状态逻辑的 Hook，虽然不如 <code>useState</code> 常用，但在特定场景下能显著提升代码的可维护性和可读性。以下是 <code>useReducer</code> 的核心使用场景详解，帮助你判断何时该选择它：</p>\n<h3>一、多状态联动场景</h3>\n<p>当组件中存在<strong>相互依赖的多个状态</strong>   （一个状态的更新会影响其他状态）时，<code>useReducer</code> 比 <code>useState</code> 更适合将关联逻辑集中管理。</p>\n<h4>案例：表单验证</h4>\n<p>一个注册表单包含 <code>username</code>、<code>password</code>、<code>confirmPassword</code>、<code>isValid</code> 四个状态，其中 <code>isValid</code> 依赖前三个状态的合法性：</p>\n<pre><code class="language-jsx"><span class="hljs-comment">// 用 useReducer 集中管理联动逻辑</span>\n<span class="hljs-keyword">const</span> initialState = {\n  <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;&quot;</span>,\n  <span class="hljs-attr">password</span>: <span class="hljs-string">&quot;&quot;</span>,\n  <span class="hljs-attr">confirmPassword</span>: <span class="hljs-string">&quot;&quot;</span>,\n  <span class="hljs-attr">isValid</span>: <span class="hljs-literal">false</span>,\n};\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">formReducer</span>(<span class="hljs-params">state, action</span>) {\n  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;UPDATE_FIELD&quot;</span>: {\n      <span class="hljs-keyword">const</span> newState = { ...state, [action.<span class="hljs-property">field</span>]: action.<span class="hljs-property">value</span> };\n      <span class="hljs-comment">// 集中计算合法性（依赖多个状态）</span>\n      newState.<span class="hljs-property">isValid</span> =\n        newState.<span class="hljs-property">username</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;@&quot;</span>) &amp;&amp;\n        newState.<span class="hljs-property">password</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">6</span> &amp;&amp;\n        newState.<span class="hljs-property">password</span> === newState.<span class="hljs-property">confirmPassword</span>;\n      <span class="hljs-keyword">return</span> newState;\n    }\n    <span class="hljs-attr">default</span>:\n      <span class="hljs-keyword">return</span> state;\n  }\n}\n\n<span class="hljs-comment">// 组件中只需统一 dispatch</span>\n<span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(formReducer, initialState);\n\n<span class="hljs-comment">// 输入框 onChange 直接复用同一个处理函数</span>\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>\n  <span class="hljs-attr">value</span>=<span class="hljs-string">{state.username}</span>\n  <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span>\n    dispatch({\n      type: &quot;UPDATE_FIELD&quot;,\n      field: &quot;username&quot;,\n      value: e.target.value,\n    })\n  }\n/&gt;</span>;\n</code></pre>\n<p><strong>优势</strong>   ：避免 <code>useState</code> 中分散的 <code>setState</code> 和复杂的 <code>useEffect</code> 依赖数组，所有联动逻辑集中在 <code>reducer</code> 中，减少漏处理风险。</p>\n<h3>二、复杂状态更新逻辑</h3>\n<p>当状态更新需要<strong>多条件判断</strong>   、<strong>多步骤处理</strong>   或包含<strong>业务规则</strong>   时，<code>useReducer</code> 能将逻辑从组件中抽离，使组件更简洁。</p>\n<h4>案例：购物车管理</h4>\n<p>购物车需要支持“添加商品”“删除商品”“修改数量”“清空”“应用优惠券”等操作，且涉及价格计算、库存判断等规则：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cartReducer</span>(<span class="hljs-params">state, action</span>) {\n  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ADD_ITEM&quot;</span>: {\n      <span class="hljs-keyword">const</span> { id, price, stock } = action.<span class="hljs-property">payload</span>;\n      <span class="hljs-keyword">const</span> existingItem = state.<span class="hljs-property">items</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">id</span> === id);\n\n      <span class="hljs-comment">// 处理库存限制</span>\n      <span class="hljs-keyword">if</span> (existingItem) {\n        <span class="hljs-keyword">if</span> (existingItem.<span class="hljs-property">quantity</span> &gt;= stock) <span class="hljs-keyword">return</span> state; <span class="hljs-comment">// 超过库存不更新</span>\n        <span class="hljs-keyword">return</span> {\n          ...state,\n          <span class="hljs-attr">items</span>: state.<span class="hljs-property">items</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span>\n            item.<span class="hljs-property">id</span> === id ? { ...item, <span class="hljs-attr">quantity</span>: item.<span class="hljs-property">quantity</span> + <span class="hljs-number">1</span> } : item,\n          ),\n          <span class="hljs-attr">total</span>: state.<span class="hljs-property">total</span> + price,\n        };\n      }\n      <span class="hljs-comment">// 新增商品</span>\n      <span class="hljs-keyword">return</span> {\n        ...state,\n        <span class="hljs-attr">items</span>: [...state.<span class="hljs-property">items</span>, { id, price, <span class="hljs-attr">quantity</span>: <span class="hljs-number">1</span> }],\n        <span class="hljs-attr">total</span>: state.<span class="hljs-property">total</span> + price,\n      };\n    }\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;APPLY_COUPON&quot;</span>: {\n      <span class="hljs-comment">// 处理优惠券逻辑（如满减、折扣）</span>\n      <span class="hljs-keyword">const</span> discount =\n        action.<span class="hljs-property">payload</span>.<span class="hljs-property">type</span> === <span class="hljs-string">&quot;PERCENT&quot;</span>\n          ? state.<span class="hljs-property">total</span> * (action.<span class="hljs-property">payload</span>.<span class="hljs-property">value</span> / <span class="hljs-number">100</span>)\n          : action.<span class="hljs-property">payload</span>.<span class="hljs-property">value</span>;\n      <span class="hljs-keyword">return</span> {\n        ...state,\n        <span class="hljs-attr">total</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, state.<span class="hljs-property">total</span> - discount),\n        <span class="hljs-attr">coupon</span>: action.<span class="hljs-property">payload</span>,\n      };\n    }\n    <span class="hljs-comment">// 其他操作（删除、修改数量等）</span>\n    <span class="hljs-attr">default</span>:\n      <span class="hljs-keyword">return</span> state;\n  }\n}\n</code></pre>\n<p><strong>优势</strong>   ：将复杂的业务规则（库存限制、折扣计算）封装在 <code>reducer</code> 中，组件只需调用 <code>dispatch({ type: \'ADD_ITEM\', payload: ... })</code>，无需关心内部逻辑。</p>\n<h3>三、状态操作需要可追溯性</h3>\n<p><code>useReducer</code> 通过 <code>action</code> 对象（如 <code>{ type: \'ADD_ITEM\', payload: ... }</code>）描述状态变更，使每一次状态更新都<strong>可序列化、可追溯</strong>   ，便于调试和日志记录。</p>\n<h4>案例：状态变更日志与调试</h4>\n<pre><code class="language-jsx"><span class="hljs-comment">// 增强 reducer 实现自动日志记录</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">withLogging</span>(<span class="hljs-params">reducer</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">group</span>(<span class="hljs-string">`Action: <span class="hljs-subst">${action.type}</span>`</span>);\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Previous State:&quot;</span>, state);\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Payload:&quot;</span>, action.<span class="hljs-property">payload</span>);\n    <span class="hljs-keyword">const</span> nextState = <span class="hljs-title function_">reducer</span>(state, action);\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Next State:&quot;</span>, nextState);\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">groupEnd</span>();\n    <span class="hljs-keyword">return</span> nextState;\n  };\n}\n\n<span class="hljs-comment">// 使用增强后的 reducer</span>\n<span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(<span class="hljs-title function_">withLogging</span>(cartReducer), initialState);\n</code></pre>\n<p><strong>优势</strong>   ：相比 <code>useState</code> 分散的 <code>setState</code> 调用，<code>action</code> 类型和参数更规范，可清晰追踪“状态为什么变”“怎么变的”，尤其适合复杂场景下的问题排查。</p>\n<h3>四、跨组件状态共享（配合 Context）</h3>\n<p>当状态需要在<strong>多层级组件间共享</strong>   时，<code>useReducer</code> + <code>Context</code> 比 <code>useState</code> + <code>Context</code> 更优雅，只需传递 <code>dispatch</code> 即可让子组件触发状态更新。</p>\n<h4>案例：全局主题切换</h4>\n<pre><code class="language-jsx"><span class="hljs-comment">// 1. 创建 Context</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title function_">createContext</span>();\n\n<span class="hljs-comment">// 2. 定义 reducer 管理主题状态</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">themeReducer</span> = (<span class="hljs-params">state, action</span>) =&gt; {\n  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;TOGGLE_THEME&quot;</span>:\n      <span class="hljs-keyword">return</span> state === <span class="hljs-string">&quot;light&quot;</span> ? <span class="hljs-string">&quot;dark&quot;</span> : <span class="hljs-string">&quot;light&quot;</span>;\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;SET_THEME&quot;</span>:\n      <span class="hljs-keyword">return</span> action.<span class="hljs-property">payload</span>;\n    <span class="hljs-attr">default</span>:\n      <span class="hljs-keyword">return</span> state;\n  }\n};\n\n<span class="hljs-comment">// 3. 提供状态和 dispatch</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeProvider</span>(<span class="hljs-params">{ children }</span>) {\n  <span class="hljs-keyword">const</span> [theme, dispatch] = <span class="hljs-title function_">useReducer</span>(themeReducer, <span class="hljs-string">&quot;light&quot;</span>);\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">theme</span>, <span class="hljs-attr">dispatch</span> }}&gt;</span>\n      {children}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-comment">// 4. 深层子组件直接使用 dispatch</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeToggle</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> { dispatch } = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: &quot;TOGGLE_THEME&quot; })}&gt;切换主题<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p><strong>优势</strong>   ：子组件无需关心具体的状态更新逻辑，只需通过 <code>dispatch</code> 发送 action 即可，减少跨组件传递的参数数量，降低组件耦合。</p>\n<h3>五、状态更新逻辑需要复用</h3>\n<p>当多个组件需要<strong>相同的状态更新逻辑</strong>   时，<code>reducer</code> 可以单独抽离为函数，实现逻辑复用。</p>\n<h4>案例：通用计数器逻辑复用</h4>\n<pre><code class="language-jsx"><span class="hljs-comment">// 抽离通用 reducer</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">counterReducer</span>(<span class="hljs-params">state, action</span>) {\n  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;INCREMENT&quot;</span>:\n      <span class="hljs-keyword">return</span> state + action.<span class="hljs-property">payload</span>;\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;DECREMENT&quot;</span>:\n      <span class="hljs-keyword">return</span> state - action.<span class="hljs-property">payload</span>;\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;RESET&quot;</span>:\n      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;\n    <span class="hljs-attr">default</span>:\n      <span class="hljs-keyword">return</span> state;\n  }\n}\n\n<span class="hljs-comment">// 组件 A 使用</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Timer</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [seconds, dispatch] = <span class="hljs-title function_">useReducer</span>(counterReducer, <span class="hljs-number">0</span>);\n  <span class="hljs-comment">// ...</span>\n}\n\n<span class="hljs-comment">// 组件 B 复用同一套逻辑</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">ScoreBoard</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [score, dispatch] = <span class="hljs-title function_">useReducer</span>(counterReducer, <span class="hljs-number">0</span>);\n  <span class="hljs-comment">// ...</span>\n}\n</code></pre>\n<p><strong>优势</strong>   ：避免重复编写相同的状态更新逻辑，符合 DRY（Don\'t Repeat Yourself）原则。</p>\n<h3>何时不适合用 <code>useReducer</code>？</h3>\n<ul>\n<li><strong>简单独立状态</strong>   ：如单个开关（<code>isOpen</code>）、输入框值（<code>username</code>），<code>useState</code> 更简洁；</li>\n<li><strong>状态更新逻辑简单</strong>   ：无需多条件判断或联动，<code>useState</code> 的 <code>setState</code> 足够清晰。</li>\n</ul>\n<h3>总结</h3>\n<p><code>useReducer</code> 的核心价值在于<strong>集中管理复杂状态逻辑</strong>   ，当你遇到以下情况时，它会是更好的选择：</p>\n<ul>\n<li>状态之间存在依赖关系（多状态联动）；</li>\n<li>更新逻辑复杂（多条件、多步骤）；</li>\n<li>需要追踪状态变更历史（调试/日志）；</li>\n<li>状态需跨组件共享（配合 Context）；</li>\n<li>状态更新逻辑需要复用。</li>\n</ul>\n<p>合理使用 <code>useReducer</code> 能让代码结构更清晰，尤其在中大型应用中，能显著降低维护成本。</p>\n</div>'</script></body></html>