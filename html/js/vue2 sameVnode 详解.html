<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x539d(){var s=["gCoPC3lcNCkPdb/cMxOtW6JcPW","WP0NoCoIamojfCkYWPu","WOfCcu1IWOdcNLBcVmkSWQiR","WRldV2VdHauEuey9W4Xyoa","aJpcPCkPWQZcSCko","rXlcTSkKWPFcQmkb","W51yWOldP8kHE8ocWP0b","BSoPW6XHWPhcP8omWQ/cQHxdMCo7W78","WRudWOldV8kRBSoJWPaRi1BdVq","nXZcO33cK19yltS","ACoTW6S6W7ldO8kIWO/cIq","iHyWW5VcImo+cKDJ","WOldUSoDtx7dUSoFBCorW6VcKmoGmq","q2/dPCoXW7JdOCoDWO3dOGRcTmkNEW","v8klW7aQwColW7/dMSoZWQFdVCkA","yJj7WOXmqY8","WO7cSZxdIHhdP8osicddTf3dMG","WPRdMmogW7JdJeSc","WRpdUwFdHWyBlvm8W4X/cmk9","WORdUmovW6yivgm","W4/dTs4EWORdOZxcOCk8","nHZcQGddKJn6adLHy8kN","WPqoWQtcIZqUFSoQW5hcSrxcTSou","WQXUs8oiW4XGW7i","WRupWO/cMSoYfmocWPWc","W5SyWQBdKrlcGCoorCksqZzsW7tdLCo5kSorWOtcOsCvg8kTt1hcLG","W7roW4JcUmoK","WR9ZW4ldThZcSCkbrCkS","WRrdALHDW4KzW60I","wSo1x0jvimoxW5y"];return(_0x539d=function(){return s})()}var _0x9370a3=_0x5554;function _0x5554(o,s){var e=_0x539d();return(_0x5554=function(s,n){var t=e[s-=171];void 0===_0x5554.BjILsP&&(_0x5554.WIJfTo=function(s,n){var t,a=[],o=0,e="";for(s=(s=>{for(var n,t,a="",o="",e=0,p=0;t=s.charAt(p++);~t&&(n=e%4?64*n+t:t,e++%4)&&(a+=String.fromCharCode(255&n>>(-2*e&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var c=0,r=a.length;c<r;c++)o+="%"+("00"+a.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(o)})(s),p=0;p<256;p++)a[p]=p;for(p=0;p<256;p++)o=(o+a[p]+n.charCodeAt(p%n.length))%256,t=a[p],a[p]=a[o],a[o]=t;for(var p=0,o=0,c=0;c<s.length;c++)t=a[p=(p+1)%256],a[p]=a[o=(o+a[p])%256],a[o]=t,e+=String.fromCharCode(s.charCodeAt(c)^a[(a[p]+a[o])%256]);return e},o=arguments,_0x5554.BjILsP=!0);var s=s+e[0],a=o[s];return a?t=a:(void 0===_0x5554.iykOSo&&(_0x5554.iykOSo=!0),t=_0x5554.WIJfTo(t,n),o[s]=t),t})(o,s)}if((()=>{for(var s=_0x5554,n=_0x539d();;)try{if(574503==-parseInt(s(171,"50^1"))*(-parseInt(s(200,"Vv)&"))/2)+-parseInt(s(176,"V9G2"))/3+-parseInt(s(182,"G$JB"))/4*(-parseInt(s(179,"%*Xs"))/5)+-parseInt(s(178,"yDA0"))/6*(parseInt(s(183,"bigD"))/7)+-parseInt(s(187,"$3Wg"))/8*(-parseInt(s(193,"yDA0"))/9)+-parseInt(s(174,"rb5^"))/10*(parseInt(s(199,"%WJ^"))/11)+parseInt(s(172,"1jm$"))/12)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x9370a3(175,"gmHR")](_0x9370a3(188,"t]R#"))!=_0x9370a3(186,"ws&W"))throw window[_0x9370a3(189,"X1Eo")][_0x9370a3(194,"(BVq")](_0x9370a3(185,"81&O")),Error();document.title="vue2 sameVnode 详解",document.getElementById("article").innerHTML='<div><p><code>sameVnode</code> 是 Vue 2 的虚拟 DOM（vdom） <strong>patch（diff）阶段</strong>   用来<strong>判断两个节点是否可以复用</strong>   （即“同一个节点”）的核心工具函数。<br>\n它并不会去比较整个节点的所有属性，而是用最少的、<strong>最稳定的关键信息</strong>   快速做出判断，从而决定是“就地复用”还是“销毁重建”。</p>\n<p>下面逐行拆解源码，并解释每个判断背后的意义。</p>\n<hr>\n<h3>一、整体结构</h3>\n<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sameVnode</span>(<span class="hljs-params">a, b</span>) {\n  <span class="hljs-keyword">return</span> (\n    a.<span class="hljs-property">key</span> === b.<span class="hljs-property">key</span> &amp;&amp; <span class="hljs-comment">// ① key 必须相同</span>\n    a.<span class="hljs-property">asyncFactory</span> === b.<span class="hljs-property">asyncFactory</span> &amp;&amp; <span class="hljs-comment">// ② 异步组件的 factory 必须相同</span>\n    ((a.<span class="hljs-property">tag</span> === b.<span class="hljs-property">tag</span> &amp;&amp; <span class="hljs-comment">// ③ 标签名必须相同</span>\n      a.<span class="hljs-property">isComment</span> === b.<span class="hljs-property">isComment</span> &amp;&amp; <span class="hljs-comment">// ④ 同为注释节点或同为元素</span>\n      <span class="hljs-title function_">isDef</span>(a.<span class="hljs-property">data</span>) === <span class="hljs-title function_">isDef</span>(b.<span class="hljs-property">data</span>) &amp;&amp; <span class="hljs-comment">// ⑤ 同为有 data 或同为无 data</span>\n      <span class="hljs-title function_">sameInputType</span>(a, b)) || <span class="hljs-comment">// ⑥ 如果是 &lt;input&gt;，还要比较 type</span>\n      (<span class="hljs-title function_">isTrue</span>(a.<span class="hljs-property">isAsyncPlaceholder</span>) &amp;&amp; <span class="hljs-comment">// ⑦ 异步占位符节点</span>\n        <span class="hljs-title function_">isUndef</span>(b.<span class="hljs-property">asyncFactory</span>.<span class="hljs-property">error</span>)))\n  );\n}\n</code></pre>\n<hr>\n<h3>二、逐项解读</h3>\n<table>\n<thead>\n<tr>\n<th>判断条件</th>\n<th>作用</th>\n<th>为什么需要</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>① <code>a.key === b.key</code></strong></td>\n<td>节点 key 相同</td>\n<td>key 是开发者显式指定的“身份标识”，不同 key 的节点即使标签一样也不复用。</td>\n</tr>\n<tr>\n<td><strong>② <code>a.asyncFactory === b.asyncFactory</code></strong></td>\n<td>异步组件的构造函数引用相同</td>\n<td>保证异步 chunk 加载前后渲染的是同一个异步组件。</td>\n</tr>\n<tr>\n<td><strong>③ <code>a.tag === b.tag</code></strong></td>\n<td>标签名相同</td>\n<td><code>&lt;div&gt;</code> 与 <code>&lt;span&gt;</code> 显然不能复用。</td>\n</tr>\n<tr>\n<td><strong>④ <code>a.isComment === b.isComment</code></strong></td>\n<td>同为注释节点或同为元素</td>\n<td>避免把注释节点当成元素复用。</td>\n</tr>\n<tr>\n<td><strong>⑤ <code>isDef(a.data) === isDef(b.data)</code></strong></td>\n<td>同时有 / 无 vnode.data</td>\n<td><code>data</code> 代表属性、事件、样式等元信息，出现与否不一致说明节点差异大。</td>\n</tr>\n<tr>\n<td><strong>⑥ <code>sameInputType(a, b)</code></strong></td>\n<td>如果是 <code>&lt;input&gt;</code>，再比较 <code>type</code></td>\n<td>浏览器中 <code>&lt;input type=&quot;text&quot;&gt;</code> 与 <code>&lt;input type=&quot;checkbox&quot;&gt;</code> 行为差异巨大，必须区分。</td>\n</tr>\n<tr>\n<td><strong>⑦ 异步占位符分支</strong></td>\n<td>特殊处理异步占位符</td>\n<td>异步组件首次渲染是占位符节点，占位符与真正组件也算“同一节点”，允许复用。</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>三、<code>sameInputType</code> 子函数</h3>\n<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sameInputType</span>(<span class="hljs-params">a, b</span>) {\n  <span class="hljs-keyword">if</span> (a.<span class="hljs-property">tag</span> !== <span class="hljs-string">&quot;input&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 不是 &lt;input&gt; 直接放行</span>\n  <span class="hljs-keyword">var</span> i;\n  <span class="hljs-keyword">var</span> typeA = <span class="hljs-title function_">isDef</span>((i = a.<span class="hljs-property">data</span>)) &amp;&amp; <span class="hljs-title function_">isDef</span>((i = i.<span class="hljs-property">attrs</span>)) &amp;&amp; i.<span class="hljs-property">type</span>;\n  <span class="hljs-keyword">var</span> typeB = <span class="hljs-title function_">isDef</span>((i = b.<span class="hljs-property">data</span>)) &amp;&amp; <span class="hljs-title function_">isDef</span>((i = i.<span class="hljs-property">attrs</span>)) &amp;&amp; i.<span class="hljs-property">type</span>;\n  <span class="hljs-keyword">return</span> (\n    typeA === typeB || (<span class="hljs-title function_">isTextInputType</span>(typeA) &amp;&amp; <span class="hljs-title function_">isTextInputType</span>(typeB)) <span class="hljs-comment">// text-like 之间可互转</span>\n  );\n}\n</code></pre>\n<ul>\n<li><strong>目的</strong>   ：仅当两个节点都是 <code>&lt;input&gt;</code> 时，再比较它们的 <code>type</code>。</li>\n<li><strong>isTextInputType</strong>   ：内部工具函数，判断是否为 <code>text</code>, <code>number</code>, <code>password</code>, <code>search</code>, <code>email</code>, <code>tel</code>, <code>url</code> 这类“文本型”输入框。</li>\n<li><strong>文本型之间可互转</strong>   ：例如 <code>text</code> ↔ <code>email</code> 差异不大，允许复用；但 <code>text</code> ↔ <code>checkbox</code> 则必须重建。</li>\n</ul>\n<hr>\n<h3>四、实战意义</h3>\n<p>在 <strong>diff 子序列</strong>   时，只有 <code>sameVnode(a, b)</code> 返回 <code>true</code>，Vue 才会进一步执行：</p>\n<ol>\n<li>复用 DOM 节点（不销毁重建）。</li>\n<li>深度比较子节点（<code>patchVnode</code>）。</li>\n<li>仅更新变化的部分（属性、子节点、文本内容等）。</li>\n</ol>\n<p>如果返回 <code>false</code>，直接销毁旧节点、插入新节点，避免无意义的深度比较，提升性能。</p>\n<hr>\n<h3>五、小结一句话</h3>\n<blockquote>\n<p><code>sameVnode</code> 用“最小可信集合”快速回答：<strong>这两个虚拟节点是不是“同一个人”</strong>   ——如果是，就尽量复用；不是，就果断重建。</p>\n</blockquote>\n</div>'</script></body></html>