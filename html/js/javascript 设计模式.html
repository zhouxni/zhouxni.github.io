<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3d7af2=_0x9d20;function _0x9d20(p,s){var t=_0x122d();return(_0x9d20=function(s,a){var n=t[s-=477];void 0===_0x9d20.KHSboT&&(_0x9d20.vRPWfO=function(s,a){var n,l=[],p=0,t="";for(s=(s=>{for(var a,n,l="",p="",t=0,e=0;n=s.charAt(e++);~n&&(a=t%4?64*a+n:n,t++%4)&&(l+=String.fromCharCode(255&a>>(-2*t&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,r=l.length;c<r;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+a.charCodeAt(e%a.length))%256,n=l[e],l[e]=l[p],l[p]=n;for(var e=0,p=0,c=0;c<s.length;c++)n=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=n,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[p])%256]);return t},p=arguments,_0x9d20.KHSboT=!0);var s=s+t[0],l=p[s];return l?n=l:(void 0===_0x9d20.xwFLXe&&(_0x9d20.xwFLXe=!0),n=_0x9d20.vRPWfO(n,a),p[s]=n),n})(p,s)}if((()=>{for(var s=_0x9d20,a=_0x122d();;)try{if(731109==-parseInt(s(480,"qzde"))*(-parseInt(s(484,"qzde"))/2)+-parseInt(s(499,"5V#o"))/3*(-parseInt(s(483,"HdhL"))/4)+parseInt(s(502,"H0b#"))/5*(parseInt(s(496,"D]f("))/6)+parseInt(s(497,"ya(K"))/7*(-parseInt(s(490,")xOj"))/8)+-parseInt(s(485,"oN[5"))/9+parseInt(s(498,"S3@!"))/10+-parseInt(s(494,"s874"))/11*(parseInt(s(488,"6^TP"))/12))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x3d7af2(492,"Ab4W")](_0x3d7af2(477,"L9Hh"))!=_0x3d7af2(504,"pWc@"))throw window[_0x3d7af2(482,"H0b#")][_0x3d7af2(491,"lW5S")](_0x3d7af2(487,"xdda")),Error();function _0x122d(){var s=["WOtdSKumW75FoCk5qhq","AbqOW4pdVbaUW4vcWPZcSW","bZdcNmklySorrq","edFcQ8oiBsZdTJjqiCkXzSkB","h8kLWQvAWQZcMmk8W4zCn8o9ua","xr7dUCkAkSo6wGuA","nmoMcZddSmoGWOroh0lcHWpcVG","kMZcTmoQW4ddSbNcNCkYiG","e8osWR1GW6HbWR4leNddGCow","WPRdQxpcNsa","W51hWPeBDCkqWO8","W4JcTfNdLmkgwH5Zea","WORcSGKoC3yLl0W","gcH1tSovWO/dRmk9wmoRBW","jZNcP2dcTmoaW7H/Ds4","fW9IaCossXtcIIWa","W47dTIGzuMFdVCk8W6Wokmo8WOtdLq","DthdOCk+W7xdKtlcTq","jt3dMclcNCoJW5rG","eWLHymoAEHhcJam","nmoVcZpdT8oMWOXJfwdcQH/cGa","W73cLComsvjhW7VdVa","W5FcLSkeFCkWW6LMrcVcI8oEW73dHc3cR8kwCxtdL8klyCkWWRtcUNHK","wdpdSvCEWPpdJgdcUCojWQdcQG","W57cRZJdN2ZcN8klWQxcJCkjeSkp","gHz8oSk0umkWWORdGW4UW6yWW4G","bSoVz17cQCogiW","W6qoW7tcV8o9WO7dOG","e8oCWRLKW6XaW48zcuxdJ8owW74","WQCUia7cUhFcTSkRW68"];return(_0x122d=function(){return s})()}document.title="javascript 设计模式",document.getElementById("article").innerHTML='<div><p>JavaScript 设计模式是解决软件设计中常见问题的可重用解决方案，它们帮助开发者更有效地组织和设计代码，提高代码的可维护性和可扩展性。JavaScript 设计模式主要分为三大类：创建型、结构型和行为型。以下是对这三类设计模式的详细解释和示例：</p>\n<h3>一、创建型设计模式</h3>\n<p>创建型设计模式主要关注对象的创建机制，提供以灵活和可控的方式实例化对象的方法。</p>\n<ol>\n<li><strong>单例模式（Singleton Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：确保一个类只有一个实例，并提供一个全局访问点来获取该实例。</li>\n<li><strong>优势</strong>  ：全局唯一性，更好地控制共享资源，优化性能。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> {\n  <span class="hljs-keyword">static</span> instance;\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}\n  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getInstance</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Singleton</span>.<span class="hljs-property">instance</span>) {\n      <span class="hljs-title class_">Singleton</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Singleton</span>.<span class="hljs-property">instance</span>;\n  }\n}\n<span class="hljs-keyword">const</span> instance1 = <span class="hljs-title class_">Singleton</span>.<span class="hljs-title function_">getInstance</span>();\n<span class="hljs-keyword">const</span> instance2 = <span class="hljs-title class_">Singleton</span>.<span class="hljs-title function_">getInstance</span>();\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance1 === instance2); <span class="hljs-comment">// true</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>工厂模式（Factory Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：对代码逻辑进行封装，只暴露出通用接口直接调用。</li>\n<li><strong>优势</strong>  ：降低耦合度，易于维护代码和提高后续扩展性。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;\n  }\n}\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">createProduct</span>(<span class="hljs-params">name</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>(name);\n}\n<span class="hljs-keyword">const</span> product1 = <span class="hljs-title function_">createProduct</span>(<span class="hljs-string">&#x27;Product 1&#x27;</span>);\n<span class="hljs-keyword">const</span> product2 = <span class="hljs-title function_">createProduct</span>(<span class="hljs-string">&#x27;Product 2&#x27;</span>);\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>构造函数模式（Constructor Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：定义一个通用的构造函数，方便多次传递参数调用。</li>\n<li><strong>优势</strong>  ：减少重复代码，提高可维护性和扩展性。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;\n  }\n}\n<span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">30</span>);\n<span class="hljs-keyword">const</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">25</span>);\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>原型模式（Prototype Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：使用原型对象作为模板来创建对象，通过原型链继承属性和方法。</li>\n<li><strong>优势</strong>  ：实现属性和方法的共享，节省内存，动态添加或修改属性。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) {\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;\n}\n<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> is eating.`</span>);\n};\n<span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&#x27;Dog&#x27;</span>);\ndog.<span class="hljs-title function_">eat</span>();\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>建造者模式（Builder Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：将一个复杂对象的构建过程与它的表示分离，通过指挥者按照一定的顺序调用建造者来创建对象。</li>\n<li><strong>优势</strong>  ：提高代码的可读性和可维护性。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">parts</span> = [];\n  }\n  <span class="hljs-title function_">addPart</span>(<span class="hljs-params">part</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">parts</span>.<span class="hljs-title function_">push</span>(part);\n  }\n  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Car Parts: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.parts.join(<span class="hljs-string">&#x27;, &#x27;</span>)}</span>`</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">CarBuilder</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">car</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();\n  }\n  <span class="hljs-title function_">buildEngine</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">car</span>.<span class="hljs-title function_">addPart</span>(<span class="hljs-string">&#x27;Engine&#x27;</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;\n  }\n  <span class="hljs-title function_">buildWheels</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">car</span>.<span class="hljs-title function_">addPart</span>(<span class="hljs-string">&#x27;Wheels&#x27;</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;\n  }\n  <span class="hljs-title function_">getCar</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">car</span>;\n  }\n}\n<span class="hljs-keyword">const</span> builder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CarBuilder</span>();\n<span class="hljs-keyword">const</span> car = builder.<span class="hljs-title function_">buildEngine</span>().<span class="hljs-title function_">buildWheels</span>().<span class="hljs-title function_">getCar</span>();\ncar.<span class="hljs-title function_">show</span>();\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h3>二、结构型设计模式</h3>\n<p>结构型设计模式主要关注对象之间的组合，以及对象之间的关系和交互方式。</p>\n<ol>\n<li><strong>适配器模式（Adapter Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：将一个类的接口转换成客户端所期望的另一种接口，使原本因接口不兼容而不能一起工作的类可以一起工作。</li>\n<li><strong>优势</strong>  ：提高复用性，降低耦合度，增强灵活性。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OldInterface</span> {\n  <span class="hljs-title function_">specificRequest</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Old Interface Response&#x27;</span>;\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">oldInterface</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">oldInterface</span> = oldInterface;\n  }\n  <span class="hljs-title function_">request</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">oldInterface</span>.<span class="hljs-title function_">specificRequest</span>();\n  }\n}\n<span class="hljs-keyword">const</span> oldInterface = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OldInterface</span>();\n<span class="hljs-keyword">const</span> adapter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Adapter</span>(oldInterface);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(adapter.<span class="hljs-title function_">request</span>());\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>装饰器模式（Decorator Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：动态地给对象添加额外的职责，通过创建一个对象来包裹原始对象，在不修改原始对象本身的情况下，动态扩展功能。</li>\n<li><strong>优势</strong>  ：方便动态扩展功能，复用现有函数，增强灵活性。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> {\n  <span class="hljs-title function_">operation</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Component Operation&#x27;</span>;\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">component</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">component</span> = component;\n  }\n  <span class="hljs-title function_">operation</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">`Decorator (<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.component.operation()}</span>)`</span>;\n  }\n}\n<span class="hljs-keyword">const</span> component = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Component</span>();\n<span class="hljs-keyword">const</span> decorator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Decorator</span>(component);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(decorator.<span class="hljs-title function_">operation</span>());\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>代理模式（Proxy Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：为其他对象提供一种代理，以便控制对这个对象的访问。</li>\n<li><strong>优势</strong>  ：控制访问权限，延迟对象创建，增强灵活性。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealImage</span> {\n  <span class="hljs-title function_">display</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Displaying Real Image&#x27;</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyImage</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">realImage</span> = <span class="hljs-literal">null</span>;\n  }\n  <span class="hljs-title function_">display</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">realImage</span>) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">realImage</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealImage</span>();\n    }\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">realImage</span>.<span class="hljs-title function_">display</span>();\n  }\n}\n<span class="hljs-keyword">const</span> proxyImage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyImage</span>();\nproxyImage.<span class="hljs-title function_">display</span>();\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>外观模式（Facade Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：为子系统中的一组接口提供一个一致的界面，使得子系统更容易使用。</li>\n<li><strong>优势</strong>  ：简化子系统使用，降低系统复杂度。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystem1</span> {\n  <span class="hljs-title function_">operation1</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;SubSystem1 Operation1&#x27;</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystem2</span> {\n  <span class="hljs-title function_">operation2</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;SubSystem2 Operation2&#x27;</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subSystem1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystem1</span>();\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subSystem2</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystem2</span>();\n  }\n  <span class="hljs-title function_">execute</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subSystem1</span>.<span class="hljs-title function_">operation1</span>();\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subSystem2</span>.<span class="hljs-title function_">operation2</span>();\n  }\n}\n<span class="hljs-keyword">const</span> facade = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Facade</span>();\nfacade.<span class="hljs-title function_">execute</span>();\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>桥接模式（Bridge Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：将抽象部分与它的实现部分分离，使它们可以独立变化。</li>\n<li><strong>优势</strong>  ：提高系统的可扩展性和灵活性。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Abstraction</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">implementor</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">implementor</span> = implementor;\n  }\n  <span class="hljs-title function_">operation</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">implementor</span>.<span class="hljs-title function_">operation</span>();\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteImplementorA</span> {\n  <span class="hljs-title function_">operation</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ConcreteImplementorA Operation&#x27;</span>;\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteImplementorB</span> {\n  <span class="hljs-title function_">operation</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ConcreteImplementorB Operation&#x27;</span>;\n  }\n}\n<span class="hljs-keyword">const</span> implementorA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteImplementorA</span>();\n<span class="hljs-keyword">const</span> abstractionA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Abstraction</span>(implementorA);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(abstractionA.<span class="hljs-title function_">operation</span>());\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>组合模式（Composite Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：将对象组合成树结构，以表示“部分-整体”的层次结构，使客户端可以一致地处理单个对象和组合对象。</li>\n<li><strong>优势</strong>  ：简化客户端代码，提高系统的灵活性和可扩展性。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> {\n  <span class="hljs-title function_">operation</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Operation must be overridden.&#x27;</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {\n  <span class="hljs-title function_">operation</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Leaf Operation&#x27;</span>;\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">super</span>();\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span> = [];\n  }\n  <span class="hljs-title function_">add</span>(<span class="hljs-params">child</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(child);\n  }\n  <span class="hljs-title function_">remove</span>(<span class="hljs-params">child</span>) {\n    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span>.<span class="hljs-title function_">indexOf</span>(child);\n    <span class="hljs-keyword">if</span> (index !== -<span class="hljs-number">1</span>) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);\n    }\n  }\n  <span class="hljs-title function_">operation</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">let</span> result = <span class="hljs-string">&#x27;&#x27;</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> {\n      result += child.<span class="hljs-title function_">operation</span>() + <span class="hljs-string">&#x27;\\n&#x27;</span>;\n    });\n    <span class="hljs-keyword">return</span> result;\n  }\n}\n<span class="hljs-keyword">const</span> leaf1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>();\n<span class="hljs-keyword">const</span> leaf2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>();\n<span class="hljs-keyword">const</span> composite = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>();\ncomposite.<span class="hljs-title function_">add</span>(leaf1);\ncomposite.<span class="hljs-title function_">add</span>(leaf2);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(composite.<span class="hljs-title function_">operation</span>());\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>享元模式（Flyweight Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：通过共享对象，减少内存使用，提高性能。</li>\n<li><strong>优势</strong>  ：节省内存空间，提高系统性能。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyweight</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">sharedState</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sharedState</span> = sharedState;\n  }\n  <span class="hljs-title function_">operation</span>(<span class="hljs-params">uniqueState</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">`Flyweight: Shared State <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.sharedState}</span>, Unique State <span class="hljs-subst">${uniqueState}</span>`</span>;\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyweightFactory</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">flyweights</span> = {};\n  }\n  <span class="hljs-title function_">getFlyweight</span>(<span class="hljs-params">sharedState</span>) {\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">flyweights</span>[sharedState]) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">flyweights</span>[sharedState] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Flyweight</span>(sharedState);\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">flyweights</span>[sharedState];\n  }\n}\n<span class="hljs-keyword">const</span> factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlyweightFactory</span>();\n<span class="hljs-keyword">const</span> flyweight1 = factory.<span class="hljs-title function_">getFlyweight</span>(<span class="hljs-string">&#x27;Shared State 1&#x27;</span>);\n<span class="hljs-keyword">const</span> flyweight2 = factory.<span class="hljs-title function_">getFlyweight</span>(<span class="hljs-string">&#x27;Shared State 1&#x27;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(flyweight1 === flyweight2); <span class="hljs-comment">// true</span>\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h3>三、行为型设计模式</h3>\n<p>行为型设计模式主要关注对象之间的交互和通信方式，以及对象如何以一种灵活的方式完成任务和行为。</p>\n<ol>\n<li><strong>观察者模式（Observer Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：定义了一种对象之间的依赖关系，当一个对象的状态发生变化时，其相关的对象都会得到通知并自动更新。</li>\n<li><strong>优势</strong>  ：实现对象间的解耦，提高系统的可扩展性和可维护性。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = [];\n  }\n  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">observer</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">push</span>(observer);\n  }\n  <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params">observer</span>) {\n    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">indexOf</span>(observer);\n    <span class="hljs-keyword">if</span> (index !== -<span class="hljs-number">1</span>) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);\n    }\n  }\n  <span class="hljs-title function_">notify</span>(<span class="hljs-params">data</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.<span class="hljs-title function_">update</span>(data));\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> {\n  <span class="hljs-title function_">update</span>(<span class="hljs-params">data</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Observer: <span class="hljs-subst">${data}</span>`</span>);\n  }\n}\n<span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>();\n<span class="hljs-keyword">const</span> observer1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>();\n<span class="hljs-keyword">const</span> observer2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>();\nsubject.<span class="hljs-title function_">subscribe</span>(observer1);\nsubject.<span class="hljs-title function_">subscribe</span>(observer2);\nsubject.<span class="hljs-title function_">notify</span>(<span class="hljs-string">&#x27;Data Changed&#x27;</span>);\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>迭代器模式（Iterator Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：提供一种方法，顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部结构。</li>\n<li><strong>优势</strong>  ：实现聚合对象的遍历，提高代码的灵活性和可扩展性。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Aggregate</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = [];\n  }\n  <span class="hljs-title function_">addItem</span>(<span class="hljs-params">item</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(item);\n  }\n  <span class="hljs-title function_">getIterator</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">items</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = items;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> = <span class="hljs-number">0</span>;\n  }\n  <span class="hljs-title function_">hasNext</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>;\n  }\n  <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span>++];\n  }\n}\n<span class="hljs-keyword">const</span> aggregate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Aggregate</span>();\naggregate.<span class="hljs-title function_">addItem</span>(<span class="hljs-string">&#x27;Item 1&#x27;</span>);\naggregate.<span class="hljs-title function_">addItem</span>(<span class="hljs-string">&#x27;Item 2&#x27;</span>);\n<span class="hljs-keyword">const</span> iterator = aggregate.<span class="hljs-title function_">getIterator</span>();\n<span class="hljs-keyword">while</span> (iterator.<span class="hljs-title function_">hasNext</span>()) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>策略模式（Strategy Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：定义一系列的算法，封装每个算法，并使它们可以互相替换，使得算法的变化不影响使用算法的客户端。</li>\n<li><strong>优势</strong>  ：提高系统的灵活性和可扩展性，方便算法的动态切换。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Strategy</span> {\n  <span class="hljs-title function_">doAction</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;doAction method must be overridden.&#x27;</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Strategy</span> {\n  <span class="hljs-title function_">doAction</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ConcreteStrategyA Action&#x27;</span>;\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Strategy</span> {\n  <span class="hljs-title function_">doAction</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ConcreteStrategyB Action&#x27;</span>;\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">strategy</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">strategy</span> = strategy;\n  }\n  <span class="hljs-title function_">executeStrategy</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">strategy</span>.<span class="hljs-title function_">doAction</span>();\n  }\n}\n<span class="hljs-keyword">const</span> strategyA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStrategyA</span>();\n<span class="hljs-keyword">const</span> contextA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>(strategyA);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(contextA.<span class="hljs-title function_">executeStrategy</span>());\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>命令模式（Command Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：将一个请求封装成一个对象，从而使你可以用不同的请求对客户进行参数化。</li>\n<li><strong>优势</strong>  ：实现请求的发送者和接收者之间的解耦，提高系统的灵活性和可扩展性。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span> {\n  <span class="hljs-title function_">execute</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;execute method must be overridden.&#x27;</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCommand</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Command</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">receiver</span>) {\n    <span class="hljs-variable language_">super</span>();\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">receiver</span> = receiver;\n  }\n  <span class="hljs-title function_">execute</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">receiver</span>.<span class="hljs-title function_">action</span>();\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> {\n  <span class="hljs-title function_">action</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Receiver Action&#x27;</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span> {\n  <span class="hljs-title function_">setCommand</span>(<span class="hljs-params">command</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">command</span> = command;\n  }\n  <span class="hljs-title function_">invoke</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">command</span>.<span class="hljs-title function_">execute</span>();\n  }\n}\n<span class="hljs-keyword">const</span> receiver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Receiver</span>();\n<span class="hljs-keyword">const</span> command = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteCommand</span>(receiver);\n<span class="hljs-keyword">const</span> invoker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Invoker</span>();\ninvoker.<span class="hljs-title function_">setCommand</span>(command);\ninvoker.<span class="hljs-title function_">invoke</span>();\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>备忘录模式（Memento Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：在不破坏对象封装的前提下，捕获内部对象的状态，并在对象外部保存这个状态，使得以后可以恢复对象到原来的状态。</li>\n<li><strong>优势</strong>  ：实现对象状态的保存和恢复，提高系统的容错性和可维护性。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Originator</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">state</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = state;\n  }\n  <span class="hljs-title function_">createMemento</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Memento</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>);\n  }\n  <span class="hljs-title function_">setMemento</span>(<span class="hljs-params">memento</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = memento.<span class="hljs-property">state</span>;\n  }\n  <span class="hljs-title function_">getState</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">state</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = state;\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Caretaker</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">memento</span> = <span class="hljs-literal">null</span>;\n  }\n  <span class="hljs-title function_">saveMemento</span>(<span class="hljs-params">memento</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">memento</span> = memento;\n  }\n  <span class="hljs-title function_">getMemento</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">memento</span>;\n  }\n}\n<span class="hljs-keyword">const</span> originator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Originator</span>(<span class="hljs-string">&#x27;State 1&#x27;</span>);\n<span class="hljs-keyword">const</span> caretaker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Caretaker</span>();\ncaretaker.<span class="hljs-title function_">saveMemento</span>(originator.<span class="hljs-title function_">createMemento</span>());\noriginator.<span class="hljs-title function_">setState</span>(<span class="hljs-string">&#x27;State 2&#x27;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(originator.<span class="hljs-title function_">getState</span>()); <span class="hljs-comment">// State 2</span>\noriginator.<span class="hljs-title function_">setMemento</span>(caretaker.<span class="hljs-title function_">getMemento</span>());\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(originator.<span class="hljs-title function_">getState</span>()); <span class="hljs-comment">// State 1</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>状态模式（State Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：允许对象在其内部状态改变时改变其行为，对象看起来似乎修改了它的类。</li>\n<li><strong>优势</strong>  ：实现对象行为的动态切换，提高系统的灵活性和可扩展性。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span> {\n  <span class="hljs-title function_">handle</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;handle method must be overridden.&#x27;</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStateA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">State</span> {\n  <span class="hljs-title function_">handle</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ConcreteStateA Handle&#x27;</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStateB</span>();\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStateB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">State</span> {\n  <span class="hljs-title function_">handle</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ConcreteStateB Handle&#x27;</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStateA</span>();\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">state</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = state;\n  }\n  <span class="hljs-title function_">request</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-title function_">handle</span>();\n  }\n}\n<span class="hljs-keyword">const</span> stateA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStateA</span>();\n<span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>(stateA);\ncontext.<span class="hljs-title function_">request</span>(); <span class="hljs-comment">// ConcreteStateA Handle</span>\ncontext.<span class="hljs-title function_">request</span>(); <span class="hljs-comment">// ConcreteStateB Handle</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>模板方法模式（Template Method Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：定义一个操作中的算法的骨架，将一些步骤的实现延迟到子类中。</li>\n<li><strong>优势</strong>  ：实现算法的复用，提高系统的灵活性和可扩展性。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span> {\n  <span class="hljs-title function_">templateMethod</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">primitiveOperation1</span>();\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">primitiveOperation2</span>();\n  }\n  <span class="hljs-title function_">primitiveOperation1</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;primitiveOperation1 method must be overridden.&#x27;</span>);\n  }\n  <span class="hljs-title function_">primitiveOperation2</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;primitiveOperation2 method must be overridden.&#x27;</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AbstractClass</span> {\n  <span class="hljs-title function_">primitiveOperation1</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ConcreteClass Primitive Operation 1&#x27;</span>);\n  }\n  <span class="hljs-title function_">primitiveOperation2</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ConcreteClass Primitive Operation 2&#x27;</span>);\n  }\n}\n<span class="hljs-keyword">const</span> concreteClass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteClass</span>();\nconcreteClass.<span class="hljs-title function_">templateMethod</span>();\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>中介者模式（Mediator Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：用一个中介对象来封装一系列的对象交互，使对象之间解耦。</li>\n<li><strong>优势</strong>  ：降低对象之间的耦合度，提高系统的可维护性和可扩展性。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colleague1</span> = <span class="hljs-literal">null</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colleague2</span> = <span class="hljs-literal">null</span>;\n  }\n  <span class="hljs-title function_">setColleague1</span>(<span class="hljs-params">colleague</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colleague1</span> = colleague;\n  }\n  <span class="hljs-title function_">setColleague2</span>(<span class="hljs-params">colleague</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colleague2</span> = colleague;\n  }\n  <span class="hljs-title function_">send</span>(<span class="hljs-params">message, colleague</span>) {\n    <span class="hljs-keyword">if</span> (colleague === <span class="hljs-variable language_">this</span>.<span class="hljs-property">colleague1</span>) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">colleague2</span>.<span class="hljs-title function_">notify</span>(message);\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">colleague1</span>.<span class="hljs-title function_">notify</span>(message);\n    }\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Colleague</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">mediator</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">mediator</span> = mediator;\n  }\n  <span class="hljs-title function_">send</span>(<span class="hljs-params">message</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">mediator</span>.<span class="hljs-title function_">send</span>(message, <span class="hljs-variable language_">this</span>);\n  }\n  <span class="hljs-title function_">notify</span>(<span class="hljs-params">message</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;notify method must be overridden.&#x27;</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteColleague1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Colleague</span> {\n  <span class="hljs-title function_">notify</span>(<span class="hljs-params">message</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`ConcreteColleague1 received: <span class="hljs-subst">${message}</span>`</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteColleague2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Colleague</span> {\n  <span class="hljs-title function_">notify</span>(<span class="hljs-params">message</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`ConcreteColleague2 received: <span class="hljs-subst">${message}</span>`</span>);\n  }\n}\n<span class="hljs-keyword">const</span> mediator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mediator</span>();\n<span class="hljs-keyword">const</span> colleague1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteColleague1</span>(mediator);\n<span class="hljs-keyword">const</span> colleague2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteColleague2</span>(mediator);\nmediator.<span class="hljs-title function_">setColleague1</span>(colleague1);\nmediator.<span class="hljs-title function_">setColleague2</span>(colleague2);\ncolleague1.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello from Colleague1&#x27;</span>);\ncolleague2.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello from Colleague2&#x27;</span>);\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>访问者模式（Visitor Pattern）</strong>\n<ul>\n<li><strong>主要思想</strong>  ：在不改变对象结构的前提下，定义作用于对象结构中的各个元素操作。</li>\n<li><strong>优势</strong>  ：实现操作的复用，提高系统的灵活性和可扩展性。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Visitor</span> {\n  <span class="hljs-title function_">visitConcreteElementA</span>(<span class="hljs-params">element</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;visitConcreteElementA method must be overridden.&#x27;</span>);\n  }\n  <span class="hljs-title function_">visitConcreteElementB</span>(<span class="hljs-params">element</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;visitConcreteElementB method must be overridden.&#x27;</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Visitor</span> {\n  <span class="hljs-title function_">visitConcreteElementA</span>(<span class="hljs-params">element</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Visitor visiting ConcreteElementA: <span class="hljs-subst">${element.operationA()}</span>`</span>);\n  }\n  <span class="hljs-title function_">visitConcreteElementB</span>(<span class="hljs-params">element</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Visitor visiting ConcreteElementB: <span class="hljs-subst">${element.operationB()}</span>`</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Element</span> {\n  <span class="hljs-title function_">accept</span>(<span class="hljs-params">visitor</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;accept method must be overridden.&#x27;</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteElementA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Element</span> {\n  <span class="hljs-title function_">operationA</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ConcreteElementA Operation&#x27;</span>;\n  }\n  <span class="hljs-title function_">accept</span>(<span class="hljs-params">visitor</span>) {\n    visitor.<span class="hljs-title function_">visitConcreteElementA</span>(<span class="hljs-variable language_">this</span>);\n  }\n}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteElementB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Element</span> {\n  <span class="hljs-title function_">operationB</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ConcreteElementB Operation&#x27;</span>;\n  }\n  <span class="hljs-title function_">accept</span>(<span class="hljs-params">visitor</span>) {\n    visitor.<span class="hljs-title function_">visitConcreteElementB</span>(<span class="hljs-variable language_">this</span>);\n  }\n}\n<span class="hljs-keyword">const</span> elementA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteElementA</span>();\n<span class="hljs-keyword">const</span> elementB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteElementB</span>();\n<span class="hljs-keyword">const</span> visitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteVisitor</span>();\nelementA.<span class="hljs-title function_">accept</span>(visitor);\nelementB.<span class="hljs-title function_">accept</span>(visitor);\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h3>四、总结</h3>\n<p>JavaScript 设计模式为开发者提供了一套经过验证的解决方案，帮助开发者更有效地组织和设计代码。通过学习和应用这些设计模式，开发者可以提高代码的可读性、可维护性和可扩展性，从而构建出更加健壮和高效的软件系统。在实际开发中，开发者应根据具体的需求和场景选择合适的设计模式，并结合实际情况进行灵活应用和调整。</p>\n</div>'</script></body></html>