<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0xa0dd(){var s=["iNamWOddKvbmlCoXW6ldMCoonq","gmkCWOdcK8ouirVcRCkhWPDQW7zM","cmoxWOvwuCoIWRKIuWldRCkIWRW","lSoRtGOY","dMzwWOldRZpcJ8kWW4GVqcNdIfJdTCobBSk0oCkZW5RdGmonW4FcUZu","ib0jzwxdTZtdVZRdGCoKW63dGa","W7JdHtFcKmk/eHtdImk/FfJdMdy","E8k9c1RdICkiAq","ctRcUSoYW5pdNMpcUxpcHL0","W6eUWP4JtH8rWQ41W5S","cmo9WRPkbJNcGCke","W4JcQwFdGatdRZhcIq","omoVtvVdSCkFBZPm","WQFdI1egl8opW6PoW7i","WRzZW53cKCosW4GQdg3dTa","zCk8W6vtuSoCDeiQ","ASkMbePYn8oUW5CKAHpcNmoQ","DdWwW58BWQKsaLRdHghcVgK","WQn6bKvHW5pdRxNcKsVdS8kqza","W4ldPe/dRmkyW6NcVSk0WPK","wauZAezhb8kPlSkTW7biWP8","WRtcTbRdJ8kfW63cRCkNWRu","WQRdNaPHACokg8ocexrM","W4JcRdFcVx3cJNZcPxFcJmo8s8ki","fCkVWPZdHCkrWQtdIfq","bmkDaKJcMSosya"];return(_0xa0dd=function(){return s})()}var _0x1dda62=_0x4c88;function _0x4c88(t,s){var c=_0xa0dd();return(_0x4c88=function(s,n){var a=c[s-=362];void 0===_0x4c88.OYoHOZ&&(_0x4c88.xybHwy=function(s,n){var a,l=[],t=0,c="";for(s=(s=>{for(var n,a,l="",t="",c=0,o=0;a=s.charAt(o++);~a&&(n=c%4?64*n+a:a,c++%4)&&(l+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var i=0,e=l.length;i<e;i++)t+="%"+("00"+l.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(t)})(s),o=0;o<256;o++)l[o]=o;for(o=0;o<256;o++)t=(t+l[o]+n.charCodeAt(o%n.length))%256,a=l[o],l[o]=l[t],l[t]=a;for(var o=0,t=0,i=0;i<s.length;i++)a=l[o=(o+1)%256],l[o]=l[t=(t+l[o])%256],l[t]=a,c+=String.fromCharCode(s.charCodeAt(i)^l[(l[o]+l[t])%256]);return c},t=arguments,_0x4c88.OYoHOZ=!0);var s=s+c[0],l=t[s];return l?a=l:(void 0===_0x4c88.YZGmdH&&(_0x4c88.YZGmdH=!0),a=_0x4c88.xybHwy(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x4c88,n=_0xa0dd();;)try{if(641578==-parseInt(s(387,"WPA1"))*(-parseInt(s(386,"#mJv"))/2)+-parseInt(s(373,"G(ll"))/3+parseInt(s(384,"tclz"))/4*(parseInt(s(379,"J4X5"))/5)+-parseInt(s(365,"xr3s"))/6+parseInt(s(363,"&CYk"))/7+-parseInt(s(366,"JvK4"))/8*(parseInt(s(369,"3EYY"))/9)+parseInt(s(375,"#vCS"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1dda62(372,"*!sy")](_0x1dda62(368,"JvK4"))!=_0x1dda62(376,"&CYk"))throw window[_0x1dda62(383,"WzQA")][_0x1dda62(380,"B5vy")](_0x1dda62(377,"e29B")),Error();document.title="css grid 布局",document.getElementById("article").innerHTML='<div><p><strong>CSS Grid 布局详解</strong></p>\n<p>CSS Grid 布局是一种二维布局模型，是目前唯一一种 CSS 二维布局方式。它允许开发者将网页划分为多个主要区域，并定义这些区域的大小、位置、层次等关系。以下是关于 CSS Grid 布局的详细解析：</p>\n<h3><strong>一、基本概念</strong></h3>\n<ol>\n<li><strong>容器（Grid Container）</strong>  ：\n<ul>\n<li>设置了 <code>display: grid</code> 或 <code>display: inline-grid</code> 的元素。</li>\n<li>容器内的直接子元素称为网格项目（Grid Items）。</li>\n</ul>\n</li>\n<li><strong>行（Row）</strong>  ：\n<ul>\n<li>垂直方向上的线，用于定义网格的水平区域。</li>\n</ul>\n</li>\n<li><strong>列（Column）</strong>  ：\n<ul>\n<li>水平方向上的线，用于定义网格的垂直区域。</li>\n</ul>\n</li>\n<li><strong>网格轨道（Grid Track）</strong>  ：\n<ul>\n<li>两个相邻行或列之间的空间。</li>\n<li>包括行轨道（Row Track）和列轨道（Column Track）。</li>\n</ul>\n</li>\n<li><strong>网格单元（Grid Cell）</strong>  ：\n<ul>\n<li>行和列的交叉区域，是网格中的最小单位。</li>\n</ul>\n</li>\n<li><strong>网格线（Grid Line）</strong>  ：\n<ul>\n<li>划分网格的线，用于定位网格元素。</li>\n<li>m 列有 m + 1 根垂直网格线，n 行有 n + 1 根水平网格线。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>二、容器属性</strong></h3>\n<ol>\n<li><strong><code>display</code></strong>  ：\n<ul>\n<li><code>grid</code>：创建一个块级网格容器。</li>\n<li><code>inline-grid</code>：创建一个行内网格容器。</li>\n</ul>\n</li>\n<li><strong><code>grid-template-columns</code></strong>  ：\n<ul>\n<li>定义网格的列宽。</li>\n<li>可以使用长度单位（如 <code>px</code>、<code>%</code>）、<code>fr</code>（表示可用空间的比例）、<code>repeat()</code> 函数等。</li>\n</ul>\n</li>\n<li><strong><code>grid-template-rows</code></strong>  ：\n<ul>\n<li>定义网格的行高。</li>\n<li>用法与 <code>grid-template-columns</code> 类似。</li>\n</ul>\n</li>\n<li><strong><code>grid-gap</code></strong>  ：\n<ul>\n<li>定义网格行列之间的间距。</li>\n<li>是 <code>grid-row-gap</code> 和 <code>grid-column-gap</code> 的简写形式。</li>\n</ul>\n</li>\n<li><strong><code>grid-template-areas</code></strong>  ：\n<ul>\n<li>定义命名区域，以便在网格中引用。</li>\n<li>与网格项目的 <code>grid-area</code> 属性配合使用。</li>\n</ul>\n</li>\n<li><strong><code>grid-auto-flow</code></strong>  ：\n<ul>\n<li>控制网格项的排列方式。</li>\n<li>取值：<code>row</code>（默认值）、<code>row dense</code>、<code>column</code>。</li>\n</ul>\n</li>\n<li><strong><code>grid-auto-columns</code> 和 <code>grid-auto-rows</code></strong>  ：\n<ul>\n<li>定义自动生成的列和行的大小。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>三、项目属性</strong></h3>\n<ol>\n<li><strong><code>grid-column-start</code> 和 <code>grid-column-end</code></strong>  ：\n<ul>\n<li>定义项目在列方向上的起始和结束位置。</li>\n</ul>\n</li>\n<li><strong><code>grid-row-start</code> 和 <code>grid-row-end</code></strong>  ：\n<ul>\n<li>定义项目在行方向上的起始和结束位置。</li>\n</ul>\n</li>\n<li><strong><code>grid-column</code> 和 <code>grid-row</code></strong>  ：\n<ul>\n<li><code>grid-column-start</code> 和 <code>grid-column-end</code> 的简写形式。</li>\n<li><code>grid-row-start</code> 和 <code>grid-row-end</code> 的简写形式。</li>\n</ul>\n</li>\n<li><strong><code>grid-area</code></strong>  ：\n<ul>\n<li>指定项目放在哪一个命名区域。</li>\n</ul>\n</li>\n<li><strong><code>justify-self</code> 和 <code>align-self</code></strong>  ：\n<ul>\n<li>定义项目在单元格内的对齐方式。</li>\n<li>取值与容器的 <code>justify-items</code> 和 <code>align-items</code> 属性类似。</li>\n</ul>\n</li>\n<li><strong><code>place-self</code></strong>  ：\n<ul>\n<li><code>justify-self</code> 和 <code>align-self</code> 的简写形式。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>四、优势与应用场景</strong></h3>\n<ol>\n<li><strong>优势</strong>  ：\n<ul>\n<li>更灵活的排版方式：支持多列和多行的布局，且支持在不同列和行的交叉位置进行对齐。</li>\n<li>简化 HTML 结构：减少 HTML 结构中的 <code>div</code> 和 <code>class</code> 的使用。</li>\n<li>更容易实现响应式布局：支持自适应布局与媒体查询。</li>\n</ul>\n</li>\n<li><strong>应用场景</strong>  ：\n<ul>\n<li>复杂的页面布局：如仪表盘、后台管理系统等。</li>\n<li>响应式设计：根据不同设备和屏幕大小自动调整布局。</li>\n<li>网格布局：如图片画廊、卡片布局等。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>五、示例</strong></h3>\n<p>以下是一个简单的 CSS Grid 布局示例：</p>\n<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Grid 布局示例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">\n    <span class="hljs-selector-class">.grid-container</span> {\n      <span class="hljs-attribute">display</span>: grid;\n      <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);\n      <span class="hljs-attribute">grid-template-rows</span>: auto;\n      <span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span>;\n      <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f0f0f0</span>;\n    }\n\n    <span class="hljs-selector-class">.grid-item</span> {\n      <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#4CAF50</span>;\n      <span class="hljs-attribute">color</span>: white;\n      <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;\n      <span class="hljs-attribute">text-align</span>: center;\n    }\n  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;grid-container&quot;</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;grid-item&quot;</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;grid-item&quot;</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;grid-item&quot;</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;grid-item&quot;</span>&gt;</span>Item 4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;grid-item&quot;</span>&gt;</span>Item 5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;grid-item&quot;</span>&gt;</span>Item 6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li><code>.grid-container</code> 是一个网格容器，设置了 <code>display: grid</code>。</li>\n<li><code>grid-template-columns: repeat(3, 1fr)</code> 表示将容器分为三列等宽的轨道。</li>\n<li><code>gap: 10px</code> 设置网格行列之间的间距。</li>\n<li><code>.grid-item</code> 是网格项目，设置了背景色、文本颜色、内边距和对齐方式。</li>\n</ul>\n<h3><strong>六、总结</strong></h3>\n<p>CSS Grid 布局是一种强大而灵活的布局模型，适用于各种复杂的页面布局需求。通过掌握容器属性和项目属性，开发者可以轻松实现响应式、对齐精确、代码简洁的页面布局。在实际开发中，应根据具体需求合理使用 CSS Grid 布局，以达到最佳的布局效果。</p>\n</div>'</script></body></html>