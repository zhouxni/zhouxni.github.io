<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2a82d6=_0x98ea;function _0x98ea(c,s){var e=_0x4b53();return(_0x98ea=function(s,a){var n=e[s-=324];void 0===_0x98ea.AvYBNe&&(_0x98ea.dWpbsj=function(s,a){var n,l=[],c=0,e="";for(s=(s=>{for(var a,n,l="",c="",e=0,p=0;n=s.charAt(p++);~n&&(a=e%4?64*a+n:n,e++%4)&&(l+=String.fromCharCode(255&a>>(-2*e&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var t=0,o=l.length;t<o;t++)c+="%"+("00"+l.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(c)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)c=(c+l[p]+a.charCodeAt(p%a.length))%256,n=l[p],l[p]=l[c],l[c]=n;for(var p=0,c=0,t=0;t<s.length;t++)n=l[p=(p+1)%256],l[p]=l[c=(c+l[p])%256],l[c]=n,e+=String.fromCharCode(s.charCodeAt(t)^l[(l[p]+l[c])%256]);return e},c=arguments,_0x98ea.AvYBNe=!0);var s=s+e[0],l=c[s];return l?n=l:(void 0===_0x98ea.sjrnxV&&(_0x98ea.sjrnxV=!0),n=_0x98ea.dWpbsj(n,a),c[s]=n),n})(c,s)}if((()=>{for(var s=_0x98ea,a=_0x4b53();;)try{if(914637==-parseInt(s(334,"t&M("))+parseInt(s(330,"$Al("))/2+parseInt(s(333,"avfc"))/3+parseInt(s(338,"]2D]"))/4+-parseInt(s(342,"(nuN"))/5+parseInt(s(341,"(c#7"))/6*(-parseInt(s(335,"3Yb]"))/7)+-parseInt(s(327,"gx*z"))/8)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x2a82d6(328,"NE$B")](_0x2a82d6(340,"(c#7"))!=_0x2a82d6(337,"$efo"))throw window[_0x2a82d6(345,"7etN")][_0x2a82d6(344,"EX2o")](_0x2a82d6(326,"ALfT")),Error();function _0x4b53(){var s=["WPqvWQm6FhpcGfxdOSk9WO53WPxcPq","W5/dMSkWAhTbnG","W61xpaRcU8kHWRldPSkICIhdLW","gCkaCSo8WOVdNGODoxOnqGy","x8kIW6BdSZpcOHVdPLvgaSkz","h34BW5z2ifD4WQq","W4xcImkmW6eoy3hdU3ZdRabWyq","WRddRSkJnvb4katdJCkECem","W61roGRdOSo7WPddJmkLAq","W7WQvqTIhGZdOSk0h8kKe8oJ","imouWPdcJLK","ACo0WQfhaSoxDK9GDJFcVNC","nCokWRBdRGGUW75rWPFcTG","CmklWRddVCk+WO3cKqZcLa","a8oAW6VdKCkIWOJcIJdcMq","nComWRddRLf0W5X7WPdcRr7cTG","W5jLdYGlrCkzeK7dGwFdGmk5","W4FcHXffW43cVCks","WQ0XFN9DWR7cTCka","WRpdICoYqu/cH8olECodW4JcS8obWR4","kSoKW5ZcT8kNAHXPWOidWQBdRw9+","aSoNWQtcUNpcQKlcNMTOcCkoWP9VW6i2hmojfcKLW5n8W7pdM2i"];return(_0x4b53=function(){return s})()}document.title="vue3 源码activeEffectScope",document.getElementById("article").innerHTML='<div><p>在 Vue 3 源码里，<code>activeEffectScope</code> 是一个重要的全局变量，它和响应式系统中的副作用作用域紧密相关。下面我会从概念、作用、源码实现以及使用场景几个方面来介绍它。</p>\n<h3>概念与作用</h3>\n<p><code>activeEffectScope</code> 用于追踪当前活跃的副作用作用域（<code>EffectScope</code>）。副作用作用域是 Vue 3 引入的一个特性，它允许你对一组副作用（像计算属性、监听器这类）进行分组管理。借助副作用作用域，你能够批量地停止或者销毁一组副作用，避免内存泄漏，还能更有效地管理资源。</p>\n<h3>源码实现</h3>\n<p>在 Vue 3 的源码里，<code>activeEffectScope</code> 是一个全局变量，在副作用作用域激活或者停用的时候会更新它的值。下面是简化后的源码示例：</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// 当前活跃的副作用作用域</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">activeEffectScope</span>: <span class="hljs-title class_">EffectScope</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>\n\n<span class="hljs-comment">// EffectScope 类定义</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">EffectScope</span> {\n  <span class="hljs-comment">// 存储该作用域内的所有副作用</span>\n  <span class="hljs-attr">effects</span>: <span class="hljs-title class_">ReactiveEffect</span>[] = [] \n  <span class="hljs-comment">// 存储子作用域</span>\n  <span class="hljs-attr">scopes</span>: <span class="hljs-title class_">EffectScope</span>[] | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span> \n  <span class="hljs-comment">// 表示该作用域是否被销毁</span>\n  active = <span class="hljs-literal">true</span> \n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">detached = <span class="hljs-literal">false</span></span>) {\n    <span class="hljs-keyword">if</span> (!detached &amp;&amp; activeEffectScope) {\n      <span class="hljs-comment">// 将当前作用域添加到父作用域的子作用域列表中</span>\n      (activeEffectScope.<span class="hljs-property">scopes</span> || (activeEffectScope.<span class="hljs-property">scopes</span> = [])).<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>) \n    }\n  }\n\n  run&lt;T&gt;(<span class="hljs-attr">fn</span>: <span class="hljs-function">() =&gt;</span> T): T | <span class="hljs-literal">undefined</span> {\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span>) {\n      <span class="hljs-keyword">const</span> currentEffectScope = activeEffectScope\n      <span class="hljs-keyword">try</span> {\n        <span class="hljs-comment">// 将当前作用域设置为活跃作用域</span>\n        activeEffectScope = <span class="hljs-variable language_">this</span> \n        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>()\n      } <span class="hljs-keyword">finally</span> {\n        <span class="hljs-comment">// 恢复之前的活跃作用域</span>\n        activeEffectScope = currentEffectScope \n      }\n    }\n  }\n\n  <span class="hljs-title function_">stop</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span>) {\n      <span class="hljs-comment">// 停止该作用域内的所有副作用</span>\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">effects</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.<span class="hljs-title function_">stop</span>()) \n      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">scopes</span>) {\n        <span class="hljs-comment">// 停止所有子作用域</span>\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">scopes</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">scope</span> =&gt;</span> scope.<span class="hljs-title function_">stop</span>()) \n      }\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span> = <span class="hljs-literal">false</span>\n    }\n  }\n}\n\n<span class="hljs-comment">// 创建一个新的副作用作用域</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">effectScope</span>(<span class="hljs-params"><span class="hljs-attr">detached</span>?: <span class="hljs-built_in">boolean</span></span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EffectScope</span>(detached)\n}\n</code></pre>\n<h3>代码解释</h3>\n<ol>\n<li><strong><code>activeEffectScope</code> 变量</strong>  ：这是一个全局变量，用于记录当前活跃的副作用作用域。</li>\n<li><strong><code>EffectScope</code> 类</strong>  ：\n<ul>\n<li><strong><code>effects</code></strong>  ：用来存储该作用域内的所有副作用。</li>\n<li><strong><code>scopes</code></strong>  ：存储子作用域。</li>\n<li><strong><code>active</code></strong>  ：表示该作用域是否处于活跃状态。</li>\n<li><strong><code>run</code> 方法</strong>  ：在这个作用域内执行传入的函数。在执行前，会把当前作用域设为活跃作用域；执行结束后，恢复之前的活跃作用域。</li>\n<li><strong><code>stop</code> 方法</strong>  ：停止该作用域内的所有副作用，并且递归地停止所有子作用域。</li>\n</ul>\n</li>\n<li><strong><code>effectScope</code> 函数</strong>  ：用于创建一个新的副作用作用域实例。</li>\n</ol>\n<h3>使用场景</h3>\n<ul>\n<li><strong>组件销毁时清理副作用</strong>  ：在 Vue 组件销毁时，你可以使用副作用作用域来批量停止组件内的所有副作用，避免内存泄漏。</li>\n</ul>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-comment">&lt;!-- 组件模板 --&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n<span class="hljs-keyword">import</span> { effectScope, onUnmounted } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>\n\n<span class="hljs-keyword">const</span> scope = <span class="hljs-title function_">effectScope</span>()\n\nscope.<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 在这里创建副作用，比如计算属性、监听器等</span>\n})\n\n<span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 组件销毁时停止作用域内的所有副作用</span>\n  scope.<span class="hljs-title function_">stop</span>() \n})\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<ul>\n<li><strong>批量管理副作用</strong>  ：当你需要批量管理一组副作用时，使用副作用作用域能够让代码更简洁、易维护。</li>\n</ul>\n<p>通过 <code>activeEffectScope</code> 和 <code>EffectScope</code>，Vue 3 提供了一种强大且灵活的方式来管理副作用，有助于提升代码的性能和可维护性。</p>\n</div>'</script></body></html>