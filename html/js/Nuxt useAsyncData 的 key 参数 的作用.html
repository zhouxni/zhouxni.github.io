<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x333b(){var n=["oSkLW41NoHyyzmkeBHddSW","DZJcGmkWWRW4eq","FSk+W7/cRv0vWO8VDW","pmkifxO4","lmoMemklWONdONldRxK","imoJgmohW5/cJchdTf1vW4TwWRW","dSoqWQaiW4NcLu8bsNpdJGBdP3GDn8kVWPZcNqCZW4RcImk2WQJcTa","zmo3kmkiWRafWO3cQYi6dbtcVq","WQGeW6ldRCkFgWVdJctcPwOtW6O","A8o6WP8kExXdvSk0rmk4","W7DXWQ1ZduFdTxqRxghcISoD","W6FcOWmYB8ouyG","qmoVW7PghtPjW6CYACo3W4CbiW","f8kCsCoYW4zlWPpdMK7cHYddRCoi","imksbwG1jajI","W5RdRb/dVYHtDG","WO8NW74IsG3cI2ar","WOzPW6tdRHNcISkDW5ldJwnLCZe","imkXyCk3WQ/dGuu","oNpcS3VdNMtcMCkJwmkXaCkSkq","WPhcVfJcPNGcz07cGSoXhSoE","tmoiDWPLfIHasqOzWQJcGI8","n2vKW54+CIW","EW7cGSk9WR0Hka","WQifWPi+W4NdVmklt8o7W5FcSa","WOzMW6ddRbNcGmkFW5xdV1zCDI0"];return(_0x333b=function(){return n})()}var _0x2402be=_0x5608;function _0x5608(o,n){var e=_0x333b();return(_0x5608=function(n,s){var t=e[n-=239];void 0===_0x5608.UAZciG&&(_0x5608.RqniFk=function(n,s){var t,a=[],o=0,e="";for(n=(n=>{for(var s,t,a="",o="",e=0,r=0;t=n.charAt(r++);~t&&(s=e%4?64*s+t:t,e++%4)&&(a+=String.fromCharCode(255&s>>(-2*e&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var c=0,l=a.length;c<l;c++)o+="%"+("00"+a.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(o)})(n),r=0;r<256;r++)a[r]=r;for(r=0;r<256;r++)o=(o+a[r]+s.charCodeAt(r%s.length))%256,t=a[r],a[r]=a[o],a[o]=t;for(var r=0,o=0,c=0;c<n.length;c++)t=a[r=(r+1)%256],a[r]=a[o=(o+a[r])%256],a[o]=t,e+=String.fromCharCode(n.charCodeAt(c)^a[(a[r]+a[o])%256]);return e},o=arguments,_0x5608.UAZciG=!0);var n=n+e[0],a=o[n];return a?t=a:(void 0===_0x5608.dxlWMJ&&(_0x5608.dxlWMJ=!0),t=_0x5608.RqniFk(t,s),o[n]=t),t})(o,n)}if((()=>{for(var n=_0x5608,s=_0x333b();;)try{if(850781==+parseInt(n(264,"(!ZU"))+-parseInt(n(261,"WN^t"))/2+-parseInt(n(253,"E@Ta"))/3*(parseInt(n(246,"TYIK"))/4)+-parseInt(n(255,"HkeJ"))/5*(-parseInt(n(239,"YgbL"))/6)+parseInt(n(249,"F06c"))/7+-parseInt(n(251,"h71I"))/8+parseInt(n(262,"F06c"))/9*(-parseInt(n(243,"WN^t"))/10))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x2402be(240,"wDeU")](_0x2402be(260,"Mhde"))!=_0x2402be(247,"A(Bs"))throw window[_0x2402be(258,"A(Bs")][_0x2402be(259,"(!ZU")](_0x2402be(250,"sPA6")),Error();document.title="Nuxt useAsyncData 的 key 参数 的作用",document.getElementById("article").innerHTML='<div><p><code>useAsyncData</code> 的 <code>key</code> 参数，<strong>核心作用就是「唯一标识这次异步请求」</strong>   ，从而让 Nuxt 在服务端和客户端之间<strong>正确复用缓存结果</strong>   ，避免重复请求。</p>\n<hr>\n<h3>🔑 key 的三大作用</h3>\n<h4>1. <strong>缓存的唯一标识</strong></h4>\n<ul>\n<li>Nuxt 在 SSR 阶段会通过这个 <code>key</code> 缓存异步结果。</li>\n<li>当浏览器端 hydration 时，Nuxt 会检查是否存在相同 <code>key</code> 的缓存。\n<ul>\n<li>如果有 → 直接复用，<strong>不再发请求</strong>   。</li>\n<li>如果没有 → 重新执行异步逻辑。</li>\n</ul>\n</li>\n</ul>\n<h4>2. <strong>避免重复请求</strong></h4>\n<ul>\n<li>如果多个组件使用<strong>相同的 key</strong>   ，它们会共享缓存结果。</li>\n<li>如果 key 不同（即使逻辑相同），Nuxt 会认为它们是不同的请求，<strong>会重复执行</strong>   。</li>\n</ul>\n<h4>3. <strong>手动刷新缓存</strong></h4>\n<ul>\n<li>通过 <code>refreshNuxtData(key)</code> 可以强制刷新特定 key 的缓存。</li>\n</ul>\n<hr>\n<h3>🎯 举个例子</h3>\n<h4>❌ 错误用法（key 不唯一 → 重复请求）</h4>\n<pre><code class="language-ts"><span class="hljs-comment">// 组件 A</span>\n<span class="hljs-keyword">const</span> { data } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">useAsyncData</span>(<span class="hljs-function">() =&gt;</span> $fetch(<span class="hljs-string">&quot;/api/user&quot;</span>));\n\n<span class="hljs-comment">// 组件 B</span>\n<span class="hljs-keyword">const</span> { data } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">useAsyncData</span>(<span class="hljs-function">() =&gt;</span> $fetch(<span class="hljs-string">&quot;/api/user&quot;</span>));\n</code></pre>\n<ul>\n<li>虽然请求的是同一个接口，但 key 默认是 <code>[function anonymous]</code>（不唯一），<strong>会重复执行两次</strong>   。</li>\n</ul>\n<h4>✅ 正确用法（key 唯一 → 共享缓存）</h4>\n<pre><code class="language-ts"><span class="hljs-comment">// 组件 A 和 B 都用同一个 key</span>\n<span class="hljs-keyword">const</span> { data } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">useAsyncData</span>(<span class="hljs-string">&quot;user-data&quot;</span>, <span class="hljs-function">() =&gt;</span> $fetch(<span class="hljs-string">&quot;/api/user&quot;</span>));\n</code></pre>\n<ul>\n<li>无论多少组件调用，<strong>只会执行一次请求</strong>   ，结果共享。</li>\n</ul>\n<hr>\n<h3>📌 总结一句话</h3>\n<blockquote>\n<p><strong>key 就是 Nuxt 缓存的「身份证」</strong>   ，确保 SSR 和客户端 hydration 时数据一致，避免重复请求。</p>\n</blockquote>\n<p>如果你不关心缓存复用（比如每次都需要最新数据），可以随便传 key，但通常建议用<strong>语义化、唯一的 key</strong>   。</p>\n</div>'</script></body></html>