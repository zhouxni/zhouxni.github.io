<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4d77(l,n){var e=_0x42b2();return(_0x4d77=function(n,s){var a=e[n-=212];void 0===_0x4d77.RzXlYh&&(_0x4d77.ZttXZV=function(n,s){var a,o=[],l=0,e="";for(n=(n=>{for(var s,a,o="",l="",e=0,t=0;a=n.charAt(t++);~a&&(s=e%4?64*s+a:a,e++%4)&&(o+=String.fromCharCode(255&s>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,c=o.length;r<c;r++)l+="%"+("00"+o.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(n),t=0;t<256;t++)o[t]=t;for(t=0;t<256;t++)l=(l+o[t]+s.charCodeAt(t%s.length))%256,a=o[t],o[t]=o[l],o[l]=a;for(var t=0,l=0,r=0;r<n.length;r++)a=o[t=(t+1)%256],o[t]=o[l=(l+o[t])%256],o[l]=a,e+=String.fromCharCode(n.charCodeAt(r)^o[(o[t]+o[l])%256]);return e},l=arguments,_0x4d77.RzXlYh=!0);var n=n+e[0],o=l[n];return o?a=o:(void 0===_0x4d77.tPCcgQ&&(_0x4d77.tPCcgQ=!0),a=_0x4d77.ZttXZV(a,s),l[n]=a),a})(l,n)}function _0x42b2(){var n=["WP0axCkKn0ldNrVcVuBdRCou","W6VdKCkcg8o+kXldH8k+AaRcSam","CmoKWRhcIHhcVSkUWRyrWQBdU8oabq","W5G+WP42W4SCWQXJW6On","rH4mf8kADmkUk8kiWOnWWRJdHq","WRhcK8oMq8o6qCoJWQZdKmkCe8om","W5OZW7TIW7u9WQnw","W5DEAJPdWOpdSmo/WPa","DsHohCoYWPvofd1oW5Kj","Csjke8oXWPmyhczbW641AG","WPZcKCkSemoOWOCivGL4WRzU","o8kykrODWROI","xgvLbxDAk8o7pW","W4KLwt0HWP5j","WRlcNCofuSk1iq3cO8kdtsRcGZtcG8o6oWGfimoAl0ybWRKlua","WPBdGtpdRqbepN/dQG","WRdcOZRcQ8k7gdbFtuBcVq","zSkrWOSby8oiWQK2W53cSZKPjG","vCoGaSkFxSoisCkX","adjvpmoTCSkLz8oQ","W7BcVa3cSJtdVCosu8o3","tHGnfmkxlmoQoSkEWOfS","W55bW4FdU8oamSk8aYWoWQVdIxS","WQueoMP4WP/dVSoCWO3dRa","WRdcOfVdVSo1pWLw","W59hhmoVDG"];return(_0x42b2=function(){return n})()}var _0xd8e9d4=_0x4d77;if((()=>{for(var n=_0x4d77,s=_0x42b2();;)try{if(853958==+parseInt(n(236,"nyMy"))*(parseInt(n(237,"GX&0"))/2)+-parseInt(n(226,"WefZ"))/3+-parseInt(n(225,"ZJ*o"))/4*(-parseInt(n(228,"uM^S"))/5)+-parseInt(n(220,"(%!s"))/6*(-parseInt(n(213,"JVgM"))/7)+-parseInt(n(214,"JVgM"))/8+-parseInt(n(222,"]yAp"))/9+-parseInt(n(233,"m7Oh"))/10)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0xd8e9d4(216,"5ENV")](_0xd8e9d4(212,"uM^S"))!=_0xd8e9d4(230,"dmU2"))throw window[_0xd8e9d4(223,"ymh!")][_0xd8e9d4(218,"brAX")](_0xd8e9d4(219,"s(W9")),Error();document.title="vue2 项目性能优化",document.getElementById("article").innerHTML='<div><p>在 Vue 2 项目中，性能优化是一个重要的课题，尤其是在项目规模较大或数据量较多时。以下是一些常见的 Vue 2 性能优化方法，涵盖了 <strong>代码优化</strong>  、<strong>构建优化</strong>  、<strong>运行时优化</strong>   等多个方面：</p>\n<hr>\n<h3><strong>1. 代码优化</strong></h3>\n<h4><strong>1.1 减少不必要的响应式数据</strong></h4>\n<ul>\n<li>Vue 会将 <code>data</code> 中的属性转换为响应式数据，如果某些数据不需要响应式，可以使用 <code>Object.freeze()</code> 冻结对象，避免 Vue 对其进行响应式处理。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">staticData</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>({ ... }) <span class="hljs-comment">// 冻结对象</span>\n  };\n}\n</code></pre>\n<h4><strong>1.2 避免不必要的计算属性</strong></h4>\n<ul>\n<li>计算属性（<code>computed</code>）是基于依赖的缓存，但如果计算属性过于复杂或依赖过多，可能会影响性能。可以优化计算逻辑或使用 <code>methods</code> 替代。</li>\n</ul>\n<h4><strong>1.3 使用 <code>v-if</code> 和 <code>v-show</code> 的合理场景</strong></h4>\n<ul>\n<li><code>v-if</code>：适合在条件不频繁变化的场景，因为它会销毁和重建 DOM。</li>\n<li><code>v-show</code>：适合在条件频繁变化的场景，因为它只是切换 <code>display</code> 属性。</li>\n</ul>\n<h4><strong>1.4 避免不必要的 DOM 操作</strong></h4>\n<ul>\n<li>尽量减少直接操作 DOM，利用 Vue 的声明式渲染特性。</li>\n</ul>\n<h4><strong>1.5 使用 <code>key</code> 优化列表渲染</strong></h4>\n<ul>\n<li>在 <code>v-for</code> 渲染列表时，为每个元素添加唯一的 <code>key</code>，帮助 Vue 更高效地更新 DOM。</li>\n</ul>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>{{ item.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n<h4><strong>1.6 拆分复杂组件</strong></h4>\n<ul>\n<li>将复杂组件拆分为多个小组件，提高代码的可维护性和渲染性能。</li>\n</ul>\n<hr>\n<h3><strong>2. 构建优化</strong></h3>\n<h4><strong>2.1 使用生产环境构建</strong></h4>\n<ul>\n<li>在生产环境中，确保使用 Vue 的生产版本，避免开发环境的警告和调试工具。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({\n  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,\n  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),\n  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;production&#x27;</span> <span class="hljs-comment">// 生产模式</span>\n});\n</code></pre>\n<h4><strong>2.2 代码分割（Code Splitting）</strong></h4>\n<ul>\n<li>使用 <code>import()</code> 动态加载组件，减少首屏加载时间。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">LazyComponent</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./LazyComponent.vue&#x27;</span>);\n</code></pre>\n<h4><strong>2.3 压缩代码</strong></h4>\n<ul>\n<li>使用 <code>UglifyJS</code> 或 <code>Terser</code> 压缩 JavaScript 代码，减少文件体积。</li>\n</ul>\n<h4><strong>2.4 优化图片和静态资源</strong></h4>\n<ul>\n<li>使用工具（如 <code>image-webpack-loader</code>）压缩图片，或者使用 WebP 格式图片。</li>\n<li>将静态资源上传到 CDN，加速加载。</li>\n</ul>\n<h4><strong>2.5 使用 Tree Shaking</strong></h4>\n<ul>\n<li>通过 <code>Webpack</code> 的 <code>Tree Shaking</code> 功能，移除未使用的代码。</li>\n</ul>\n<h4><strong>2.6 开启 Gzip 压缩</strong></h4>\n<ul>\n<li>在服务器端开启 Gzip 压缩，减少文件传输体积。</li>\n</ul>\n<hr>\n<h3><strong>3. 运行时优化</strong></h3>\n<h4><strong>3.1 使用 <code>v-once</code> 优化静态内容</strong></h4>\n<ul>\n<li>对于不会变化的静态内容，使用 <code>v-once</code> 避免重新渲染。</li>\n</ul>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-once</span>&gt;</span>{{ staticContent }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n<h4><strong>3.2 使用 <code>Object.freeze()</code> 冻结大列表</strong></h4>\n<ul>\n<li>如果列表数据不需要响应式更新，可以使用 <code>Object.freeze()</code> 冻结，减少 Vue 的响应式处理开销。</li>\n</ul>\n<h4><strong>3.3 优化 <code>watch</code> 监听</strong></h4>\n<ul>\n<li>避免监听过多数据，或者使用 <code>immediate: true</code> 和 <code>deep: true</code> 时注意性能开销。</li>\n</ul>\n<h4><strong>3.4 使用异步组件</strong></h4>\n<ul>\n<li>将非首屏组件设置为异步组件，减少首屏加载时间。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">AsyncComponent</span> = (<span class="hljs-params"></span>) =&gt; ({\n  <span class="hljs-attr">component</span>: <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./AsyncComponent.vue&#x27;</span>),\n  <span class="hljs-attr">loading</span>: <span class="hljs-title class_">LoadingComponent</span>,\n  <span class="hljs-attr">error</span>: <span class="hljs-title class_">ErrorComponent</span>,\n  <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,\n  <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>\n});\n</code></pre>\n<h4><strong>3.5 使用 <code>keep-alive</code> 缓存组件</strong></h4>\n<ul>\n<li>对于频繁切换的组件，使用 <code>&lt;keep-alive&gt;</code> 缓存组件实例，避免重复渲染。</li>\n</ul>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;currentComponent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>\n</code></pre>\n<hr>\n<h3><strong>4. 其他优化</strong></h3>\n<h4><strong>4.1 使用 Vue Devtools 进行性能分析</strong></h4>\n<ul>\n<li>通过 Vue Devtools 的 Performance 面板，分析组件的渲染性能，找出性能瓶颈。</li>\n</ul>\n<h4><strong>4.2 使用虚拟列表优化大数据渲染</strong></h4>\n<ul>\n<li>对于大数据列表，使用虚拟列表（如 <code>vue-virtual-scroller</code>）只渲染可见区域的内容，减少 DOM 数量。</li>\n</ul>\n<h4><strong>4.3 优化网络请求</strong></h4>\n<ul>\n<li>减少不必要的请求，合并请求、或者使用缓存（如 <code>localStorage</code>、<code>sessionStorage</code>）存储数据，http 缓存策略、CDN 缓存、GZIP 压缩。</li>\n</ul>\n<h4><strong>4.4 使用 Service Worker 实现离线缓存</strong></h4>\n<ul>\n<li>通过 <code>Workbox</code> 或 <code>PWA</code> 技术，使用 Service Worker 缓存静态资源，提升加载速度。</li>\n</ul>\n<h4><strong>4.5 优化第三方库</strong></h4>\n<ul>\n<li>移除未使用的第三方库，或者使用按需加载（如 <code>lodash</code> 的 <code>lodash-es</code> 版本）。</li>\n</ul>\n<hr>\n<h3><strong>5. 工具推荐</strong></h3>\n<ul>\n<li><strong>Webpack Bundle Analyzer</strong>  ：分析打包文件体积，找出优化点。</li>\n<li><strong>Lighthouse</strong>  ：检测页面性能，提供优化建议。</li>\n<li><strong>Vue Devtools</strong>  ：调试 Vue 应用，分析性能问题。</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>Vue 2 项目的性能优化需要从 <strong>代码</strong>  、<strong>构建</strong>  、<strong>运行时</strong>   等多个方面入手，结合具体场景选择合适的优化方法。通过合理的优化手段，可以显著提升项目的加载速度和运行性能，提供更好的用户体验。</p>\n</div>'</script></body></html>