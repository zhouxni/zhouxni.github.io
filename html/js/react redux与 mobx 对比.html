<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2cd562=_0x3c2b;function _0x3c2b(c,n){var e=_0x5f53();return(_0x3c2b=function(n,s){var a=e[n-=462];void 0===_0x3c2b.nATVda&&(_0x3c2b.TqMous=function(n,s){var a,l=[],c=0,e="";for(n=(n=>{for(var s,a,l="",c="",e=0,o=0;a=n.charAt(o++);~a&&(s=e%4?64*s+a:a,e++%4)&&(l+=String.fromCharCode(255&s>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,r=l.length;t<r;t++)c+="%"+("00"+l.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(c)})(n),o=0;o<256;o++)l[o]=o;for(o=0;o<256;o++)c=(c+l[o]+s.charCodeAt(o%s.length))%256,a=l[o],l[o]=l[c],l[c]=a;for(var o=0,c=0,t=0;t<n.length;t++)a=l[o=(o+1)%256],l[o]=l[c=(c+l[o])%256],l[c]=a,e+=String.fromCharCode(n.charCodeAt(t)^l[(l[o]+l[c])%256]);return e},c=arguments,_0x3c2b.nATVda=!0);var n=n+e[0],l=c[n];return l?a=l:(void 0===_0x3c2b.cEjMUn&&(_0x3c2b.cEjMUn=!0),a=_0x3c2b.TqMous(a,s),c[n]=a),a})(c,n)}if((()=>{for(var n=_0x3c2b,s=_0x5f53();;)try{if(643759==+parseInt(n(465,"(!x@"))+parseInt(n(472,"qaT2"))/2*(-parseInt(n(480,"PXEV"))/3)+parseInt(n(478,"oBu6"))/4*(parseInt(n(463,"npBo"))/5)+-parseInt(n(464,"S3T2"))/6*(-parseInt(n(479,"oBu6"))/7)+-parseInt(n(467,"jf4F"))/8*(-parseInt(n(477,"vp^u"))/9)+-parseInt(n(476,"e)cy"))/10+-parseInt(n(487,"**t%"))/11)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x2cd562(471,"hcZS")](_0x2cd562(466,"VKhg"))!=_0x2cd562(483,"t@jq"))throw window[_0x2cd562(489,"(skh")][_0x2cd562(481,"jf4F")](_0x2cd562(484,"!8)d")),Error();function _0x5f53(){var n=["WQjIWP8zW6ldJglcN8kRWQNdJspcPG","W77dGgpdLCkiW7BcM8kdWRJdJCkQlrRdMW","WQdcMZn0m8k5W6fceG","iZ8FW68qWRxdNs8","iqNdQG3dPMrbFa","W5OmlmogWQ4YWOqcdNpcGCob","WPyUWRdcSmoQWOfxW6NcHqyQWO8N","WReAW5xdGW1fwmk9dSofzCk0WP4","W6NdL8oEW4tcT8k4W6dcKfG","WQyxWPKQhLSBW6pdOwlcPCouoa","WQNcGCkWkSkfW4pcVSosW7xdQbmaeG","WQbGWPGyW6JdItNcSmk7WRhdOJi","W7jEW7pcN8keWPnRDrTZW5ZcKSkh","kv7dHCo3pdNcNa","WRRdStiPdmk9rMK","WQ07ggrCWQBdKva","W5nSW5fmWP7cNmoZACopgv4","WP/dSConW4VcNmkHW6C","BSkfWQNcNgC5W63dJrzbw8kQiG","Be1qntldNwBcSW","zCkxpSkkCSonW6WyW6e","y8oLEmk2FCoGW7y","eXVdHfjqW741tmoIuua","W6zbW5bZsa5g","W7vvW7lcN8kkWPrQmsXXW43cP8k6EW","Dmk0W5dcQSkk","WQ8sWRddM8opWPP0kIvtW7FcI8k4C1BdTmo7WRhdJv1OW4pdJrj5W5m","uSoBW4pcOColjSkIWQeXAmoAW6FdUW"];return(_0x5f53=function(){return n})()}document.title="react redux与 mobx 对比",document.getElementById("article").innerHTML='<div><p>Redux和MobX都是用于管理前端应用状态的库，在不同的项目场景中各有优势。下面从多个维度对它们进行对比分析。</p>\n<h3>1. 设计理念</h3>\n<ul>\n<li><strong>Redux</strong>\n<ul>\n<li>采用单向数据流架构，严格遵循可预测性原则。状态以单一的树形结构存储在一个全局的<code>store</code>中，状态是只读的，唯一改变状态的方式是触发一个<code>action</code>，<code>action</code>会被<code>reducer</code>处理，<code>reducer</code>是一个纯函数，它接收当前状态和<code>action</code>作为参数，返回一个新的状态。</li>\n<li>这种设计使得状态的变化过程可追溯和调试，开发者能清晰了解状态是如何从一个状态转变到另一个状态的。</li>\n</ul>\n</li>\n<li><strong>MobX</strong>\n<ul>\n<li>基于响应式编程思想，状态是可变的。它使用<code>observable</code>来定义可观察的状态，当<code>observable</code>状态发生变化时，所有依赖该状态的组件会自动更新。</li>\n<li>更强调代码的简洁性和开发的高效性，减少了样板代码，让开发者能更专注于业务逻辑。</li>\n</ul>\n</li>\n</ul>\n<h3>2. 代码结构与复杂度</h3>\n<ul>\n<li><strong>Redux</strong>\n<ul>\n<li>代码结构较为复杂，需要定义<code>action types</code>、<code>action creators</code>、<code>reducers</code>等。例如，实现一个简单的计数器功能，代码如下：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// 定义 action types</span>\n<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">INCREMENT</span> = <span class="hljs-string">&#x27;INCREMENT&#x27;</span>;\n<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DECREMENT</span> = <span class="hljs-string">&#x27;DECREMENT&#x27;</span>;\n\n<span class="hljs-comment">// 定义 action creators</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; ({ <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">INCREMENT</span> });\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">decrement</span> = (<span class="hljs-params"></span>) =&gt; ({ <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">DECREMENT</span> });\n\n<span class="hljs-comment">// 定义 reducer</span>\n<span class="hljs-keyword">const</span> initialState = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">counterReducer</span> = (<span class="hljs-params">state = initialState, action</span>) =&gt; {\n    <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {\n        <span class="hljs-keyword">case</span> <span class="hljs-attr">INCREMENT</span>:\n            <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> };\n        <span class="hljs-keyword">case</span> <span class="hljs-attr">DECREMENT</span>:\n            <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span> };\n        <span class="hljs-attr">default</span>:\n            <span class="hljs-keyword">return</span> state;\n    }\n};\n</code></pre>\n<pre><code>- 对于大型项目，虽然这种严格的结构有助于代码的管理和维护，但对于小型项目，会显得冗余。\n</code></pre>\n<ul>\n<li><strong>MobX</strong>\n<ul>\n<li>代码结构相对简洁，只需定义<code>observable</code>状态和修改状态的<code>action</code>。同样实现计数器功能，代码如下：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { makeObservable, observable, action } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mobx&#x27;</span>;\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterStore</span> {\n    count = <span class="hljs-number">0</span>;\n\n    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, {\n            <span class="hljs-attr">count</span>: observable,\n            <span class="hljs-attr">increment</span>: action,\n            <span class="hljs-attr">decrement</span>: action\n        });\n    }\n\n    increment = <span class="hljs-function">() =&gt;</span> {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;\n    };\n\n    decrement = <span class="hljs-function">() =&gt;</span> {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>--;\n    };\n}\n\n<span class="hljs-keyword">const</span> counterStore = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterStore</span>();\n</code></pre>\n<pre><code>- 代码量明显减少，开发效率更高。\n</code></pre>\n<h3>3. 状态更新方式</h3>\n<ul>\n<li><strong>Redux</strong>\n<ul>\n<li>状态更新是通过触发<code>action</code>，<code>action</code>传递到<code>reducer</code>中进行处理。由于<code>reducer</code>是纯函数，每次更新状态都会返回一个新的状态对象，这保证了状态的不可变性。</li>\n<li>例如：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// action</span>\n<span class="hljs-keyword">const</span> incrementAction = { <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> };\n<span class="hljs-comment">// reducer</span>\n<span class="hljs-keyword">const</span> newState = <span class="hljs-title function_">counterReducer</span>(currentState, incrementAction);\n</code></pre>\n<ul>\n<li><strong>MobX</strong>\n<ul>\n<li>状态更新是直接修改<code>observable</code>状态。MobX会自动跟踪状态的变化，并通知依赖该状态的组件进行更新。</li>\n<li>例如：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-javascript">counterStore.<span class="hljs-title function_">increment</span>();\n</code></pre>\n<h3>4. 性能表现</h3>\n<ul>\n<li><strong>Redux</strong>\n<ul>\n<li>由于每次状态更新都会创建新的状态对象，可能会带来一定的性能开销，尤其是在处理大量数据时。不过，可通过<code>shouldComponentUpdate</code>、<code>React.memo</code>等方法进行性能优化。</li>\n</ul>\n</li>\n<li><strong>MobX</strong>\n<ul>\n<li>采用细粒度的响应式更新机制，只有依赖发生变化的组件才会重新渲染，性能通常较好。但如果状态更新过于频繁，可能会导致过多的组件重新渲染，影响性能。</li>\n</ul>\n</li>\n</ul>\n<h3>5. 调试和开发体验</h3>\n<ul>\n<li><strong>Redux</strong>\n<ul>\n<li>拥有强大的调试工具，如Redux DevTools，支持时间旅行调试，能方便地查看状态的历史变化和回放。但由于代码结构复杂，调试过程可能会比较繁琐。</li>\n</ul>\n</li>\n<li><strong>MobX</strong>\n<ul>\n<li>调试相对简单，因为状态的变化是直接的，没有复杂的<code>action</code>和<code>reducer</code>流程。但缺乏像Redux DevTools这样强大的调试工具。</li>\n</ul>\n</li>\n</ul>\n<h3>6. 可维护性和扩展性</h3>\n<ul>\n<li><strong>Redux</strong>\n<ul>\n<li>严格的单向数据流和规范的代码结构使得代码的可维护性和扩展性较好，适合大型团队协作开发。但在需求频繁变更时，修改<code>action</code>和<code>reducer</code>可能需要花费较多时间。</li>\n</ul>\n</li>\n<li><strong>MobX</strong>\n<ul>\n<li>代码结构灵活，易于扩展和修改。但随着项目规模的增大，如果缺乏良好的代码组织，状态管理可能会变得混乱。</li>\n</ul>\n</li>\n</ul>\n<h3>7. 学习成本</h3>\n<ul>\n<li><strong>Redux</strong>\n<ul>\n<li>学习曲线较陡，需要理解<code>action</code>、<code>reducer</code>、<code>store</code>等概念，以及单向数据流的工作原理。对于初学者来说，掌握起来有一定难度。</li>\n</ul>\n</li>\n<li><strong>MobX</strong>\n<ul>\n<li>学习成本相对较低，因为其响应式编程的思想与JavaScript的对象操作较为接近，开发者容易上手。</li>\n</ul>\n</li>\n</ul>\n<p>综上所述，Redux适用于大型复杂应用，对状态管理的严格性、可预测性和调试有较高要求的场景；而MobX更适合小型项目或快速迭代的项目，追求开发效率和代码简洁性的场景。</p>\n</div>'</script></body></html>