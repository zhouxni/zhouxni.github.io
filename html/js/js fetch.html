<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x35f5(){var n=["puWZl8kDmmkga8kWa8o3WOZdUmk0","W6LxWQ3cT0tdI8oxA8oOi8kOW7T8","fCo9BxLFbMJdMqNdT8okWPJdGG","fSkkW5PWefNdGd0","nfvGg2xcRMRdMx/cJ8kjqCoS","g201ywRcSCooW6VdO8kGmqG","idK2W7FdRXZcIrW","WOldHSkGWQddTtT9sSkaE8k9tCoV","FCkQWP5JWRpdN38","W4/cPmoSWOBdKCkNWO7cHCkG","j8osW6tcVKBdRbhcKa","WPWuhSodrKddTmoQW6fNyG83AJa0DmoSwSo5W7/dUcDiWQL7","emoYW4tdTcpcUSoPtHFcIMG2W6q","F8oUW6eLW5ZcMGCLWQzGnSkCWOS","de1oW48Zkmk2","f8oFsmkeE03cMCooAmofW7HxWRv0","WPLnnu9VWOnaWO0eBJ8spG","s8kxySo2W7JdG8kaW7ayW4hcUSoXzW","W7pdKchcUX3cImoVz0Olh8oLBq","wComWQNdS8kGrxzrW4RdKaS0","WPe4tmk4xCoRea","WPKjsW0iW4q4","o8kHW4tcJv/cSHy8tCkLqtvj","FaPWzCos"];return(_0x35f5=function(){return n})()}function _0x3404(o,n){var c=_0x35f5();return(_0x3404=function(n,s){var e=c[n-=233];void 0===_0x3404.imGizn&&(_0x3404.wsrzjJ=function(n,s){var e,l=[],o=0,c="";for(n=(n=>{for(var s,e,l="",o="",c=0,a=0;e=n.charAt(a++);~e&&(s=c%4?64*s+e:e,c++%4)&&(l+=String.fromCharCode(255&s>>(-2*c&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var i=0,r=l.length;i<r;i++)o+="%"+("00"+l.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(o)})(n),a=0;a<256;a++)l[a]=a;for(a=0;a<256;a++)o=(o+l[a]+s.charCodeAt(a%s.length))%256,e=l[a],l[a]=l[o],l[o]=e;for(var a=0,o=0,i=0;i<n.length;i++)e=l[a=(a+1)%256],l[a]=l[o=(o+l[a])%256],l[o]=e,c+=String.fromCharCode(n.charCodeAt(i)^l[(l[a]+l[o])%256]);return c},o=arguments,_0x3404.imGizn=!0);var n=n+c[0],l=o[n];return l?e=l:(void 0===_0x3404.tSowiS&&(_0x3404.tSowiS=!0),e=_0x3404.wsrzjJ(e,s),o[n]=e),e})(o,n)}var _0x3074b7=_0x3404;if((()=>{for(var n=_0x3404,s=_0x35f5();;)try{if(877343==-parseInt(n(248,"lC0#"))*(parseInt(n(256,"Tjug"))/2)+-parseInt(n(239,"xrGR"))/3+-parseInt(n(253,"^esf"))/4+-parseInt(n(243,"lC0#"))/5+-parseInt(n(240,"MJBU"))/6+-parseInt(n(244,"17*T"))/7+parseInt(n(233,"SLqP"))/8*(parseInt(n(242,"Z4N1"))/9))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x3074b7(247,"rpmt")](_0x3074b7(236,"zv!A"))!=_0x3074b7(250,"Saub"))throw window[_0x3074b7(254,"Ev*Q")][_0x3074b7(241,"bp@x")](_0x3074b7(238,"EFP!")),Error();document.title="js fetch",document.getElementById("article").innerHTML='<div><p><code>fetch</code> 是一个现代 JavaScript API，用于在 Web 浏览器中进行网络请求。它提供了一种更简洁、更强大的方式来处理网络请求，相比传统的 <code>XMLHttpRequest</code> 对象，<code>fetch</code> API 更易于使用且功能更丰富。以下是 <code>fetch</code> 的配置详解：</p>\n<h3>基本语法</h3>\n<pre><code class="language-javascript"><span class="hljs-title function_">fetch</span>(url, options)\n</code></pre>\n<ul>\n<li><strong>url</strong>  ：要请求的资源的 URL。</li>\n<li><strong>options</strong>  （可选）：一个配置对象，用于自定义请求的选项。</li>\n</ul>\n<h3>配置选项</h3>\n<p><code>fetch</code> 的配置选项通过 <code>options</code> 对象传递，以下是常用的配置选项及其说明：</p>\n<ol>\n<li><strong>method</strong>\n<ul>\n<li>类型：字符串</li>\n<li>描述：请求使用的方法，如 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code> 等。</li>\n<li>默认值：<code>GET</code></li>\n</ul>\n</li>\n<li><strong>headers</strong>\n<ul>\n<li>类型：<code>Headers</code> 对象或包含字符串值的对象字面量</li>\n<li>描述：请求的头信息，用于设置自定义的请求头。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-attr">headers</span>: {\n  <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>body</strong>\n<ul>\n<li>类型：<code>Blob</code>、<code>BufferSource</code>、<code>FormData</code>、<code>URLSearchParams</code> 或 <code>USVString</code></li>\n<li>描述：请求的 body 信息，用于发送数据到服务器。注意，<code>GET</code> 或 <code>HEAD</code> 方法的请求不能包含 body 信息。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> })\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>mode</strong>\n<ul>\n<li>类型：字符串</li>\n<li>描述：请求的模式，决定发起的是同源请求还是跨域请求。</li>\n<li>可选值：\n<ul>\n<li><code>cors</code>：允许跨域请求，但需要服务器支持 CORS。</li>\n<li><code>no-cors</code>：只允许使用 <code>HEAD</code>、<code>GET</code> 和 <code>POST</code> 方法，且 JavaScript 不允许访问响应的内容。</li>\n<li><code>same-origin</code>：只允许同源请求。</li>\n</ul>\n</li>\n<li>默认值：<code>cors</code></li>\n</ul>\n</li>\n<li><strong>credentials</strong>\n<ul>\n<li>类型：字符串</li>\n<li>描述：请求的凭证模式，决定请求是否携带 cookie。</li>\n<li>可选值：\n<ul>\n<li><code>omit</code>：不携带 cookie。</li>\n<li><code>same-origin</code>：仅在同源时携带 cookie。</li>\n<li><code>include</code>：无论是否同源都携带 cookie。</li>\n</ul>\n</li>\n<li>默认值：<code>same-origin</code></li>\n</ul>\n</li>\n<li><strong>cache</strong>\n<ul>\n<li>类型：字符串</li>\n<li>描述：请求的缓存模式。</li>\n<li>可选值：\n<ul>\n<li><code>default</code>：默认值，浏览器根据 HTTP 头来决定是否从缓存中读取。</li>\n<li><code>no-store</code>：不使用缓存，每次请求都向服务器获取最新的数据。</li>\n<li><code>reload</code>：忽略缓存，强制从服务器获取数据。</li>\n<li><code>no-cache</code>：使用缓存，但会向服务器验证缓存是否仍然有效。</li>\n<li><code>force-cache</code>：只使用缓存，不向服务器发送请求。</li>\n<li><code>only-if-cached</code>：只使用缓存，如果缓存不存在则请求失败。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>redirect</strong>\n<ul>\n<li>类型：字符串</li>\n<li>描述：可用的重定向模式。</li>\n<li>可选值：\n<ul>\n<li><code>follow</code>：自动重定向。</li>\n<li><code>error</code>：如果产生重定向将自动终止并且抛出一个错误。</li>\n<li><code>manual</code>：手动处理重定向。</li>\n</ul>\n</li>\n<li>默认值：<code>follow</code></li>\n</ul>\n</li>\n<li><strong>referrer</strong>\n<ul>\n<li>类型：字符串</li>\n<li>描述：设置请求的来源地址。</li>\n<li>可选值：\n<ul>\n<li><code>no-referrer</code>：不发送 referrer。</li>\n<li><code>client</code>：发送完整的 URL 作为 referrer。</li>\n<li>一个 URL：发送指定的 URL 作为 referrer。</li>\n</ul>\n</li>\n<li>默认值：<code>client</code></li>\n</ul>\n</li>\n<li><strong>referrerPolicy</strong>\n<ul>\n<li>类型：字符串</li>\n<li>描述：指定 HTTP 头部 <code>referrer</code> 字段的值。</li>\n<li>可选值：\n<ul>\n<li><code>no-referrer</code></li>\n<li><code>no-referrer-when-downgrade</code></li>\n<li><code>origin</code></li>\n<li><code>origin-when-cross-origin</code></li>\n<li><code>unsafe-url</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>integrity</strong>\n<ul>\n<li>类型：字符串</li>\n<li>描述：包括请求的子资源完整性值，用于验证资源的完整性。</li>\n</ul>\n</li>\n</ol>\n<h3>示例</h3>\n<p>以下是一个使用 <code>fetch</code> 发送 POST 请求的示例，包含自定义的请求头和请求体：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> headers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Headers</span>();\nheaders.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>);\n\n<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>, {\n  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,\n  <span class="hljs-attr">headers</span>: headers,\n  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> }),\n  <span class="hljs-attr">credentials</span>: <span class="hljs-string">&#x27;include&#x27;</span>,\n  <span class="hljs-attr">cache</span>: <span class="hljs-string">&#x27;no-store&#x27;</span>\n})\n.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {\n  <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Network response was not ok&#x27;</span>);\n  }\n  <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();\n})\n.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);\n})\n.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;There was a problem with the fetch operation:&#x27;</span>, error);\n});\n</code></pre>\n<h3>注意事项</h3>\n<ol>\n<li><strong>跨域请求</strong>  ：<code>fetch</code> 默认支持跨域请求，但在某些情况下可能需要额外配置以处理 CORS（跨域资源共享）。</li>\n<li><strong>错误处理</strong>  ：<code>fetch</code> 不会将 HTTP 错误状态码（如 404、500）视为请求失败，而是返回一个 <code>ok</code> 属性为 <code>false</code> 的 <code>Response</code> 对象。因此，在处理响应时，需要检查 <code>response.ok</code> 属性来判断请求是否成功。</li>\n<li><strong>Promise 链式调用</strong>  ：<code>fetch</code> 返回的是一个 <code>Promise</code> 对象，可以使用 <code>.then()</code> 和 <code>.catch()</code> 方法来处理异步操作。</li>\n</ol>\n<p>通过合理配置 <code>fetch</code> 的选项，可以灵活地处理各种网络请求场景，满足不同的需求。</p>\n</div>'</script></body></html>