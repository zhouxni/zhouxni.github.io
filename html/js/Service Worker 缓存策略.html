<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x98ae(t,s){var e=_0x5a20();return(_0x98ae=function(s,n){var a=e[s-=333];void 0===_0x98ae.dmczZq&&(_0x98ae.PgMeKy=function(s,n){var a,l=[],t=0,e="";for(s=(s=>{for(var n,a,l="",t="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,c=l.length;r<c;r++)t+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(t)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)t=(t+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[t],l[t]=a;for(var p=0,t=0,r=0;r<s.length;r++)a=l[p=(p+1)%256],l[p]=l[t=(t+l[p])%256],l[t]=a,e+=String.fromCharCode(s.charCodeAt(r)^l[(l[p]+l[t])%256]);return e},t=arguments,_0x98ae.dmczZq=!0);var s=s+e[0],l=t[s];return l?a=l:(void 0===_0x98ae.qWpMaa&&(_0x98ae.qWpMaa=!0),a=_0x98ae.PgMeKy(a,n),t[s]=a),a})(t,s)}var _0x450853=_0x98ae;if((()=>{for(var s=_0x98ae,n=_0x5a20();;)try{if(116797==-parseInt(s(361,"P!#z"))*(parseInt(s(337,"uimB"))/2)+parseInt(s(356,"uA$l"))/3*(parseInt(s(338,"9ruS"))/4)+parseInt(s(340,"t#le"))/5*(parseInt(s(346,"RJmE"))/6)+-parseInt(s(359,"t#le"))/7*(-parseInt(s(353,"(Zq!"))/8)+parseInt(s(350,"x5[I"))/9+-parseInt(s(345,"kQs#"))/10*(parseInt(s(341,"p2Id"))/11)+parseInt(s(344,"auj0"))/12)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x450853(355,"OxUy")](_0x450853(333,"OxUy"))!=_0x450853(351,"hvKj"))throw window[_0x450853(343,"Rs]o")][_0x450853(352,"Ony4")](_0x450853(342,"XUri")),Error();function _0x5a20(){var s=["WPLddmkWn8klE3/cVdJcTmkG","W55sW6ldQK4","l8kTW4pcISkwsSkR","oSk9WRBcTYCijSk1WPG","WRWfW7RdTSkkWQjf","W7lcU0KbWOddVMC","WRDLW5hdNSkMWOrOnW","f8o3W5ztWOLRD1RcG8oylq","CJfoySkGmrxcNa","WPPrc8oGECoFASkTW5ONWRW","wSkByrL8sSoKW4NcRtOyWO8","yGnUASopWORcHxzrWPOK","WP9ybCoLFSoouSk1W7mQWRK","W5tcVv4TWOFdQeefla","xmoJxCo+o8kjWO/dTCohpxHama","z8keWRNdNSkLpKXS","uXZdQrWckmkDF2i","W4lcNqhdTmobW5/dRa","wSoIW5uZxYDOW7/cMSoJ","W7hdSM0DWPNdUCo5ja","WPLrbmoNFmoaESkwW4KkWPS","W5OQqduUWPVdOru7W47cTCo+W6m","WP0fWPFcSmoFzKFcUSo6W4e/WRRdJeZcKSolzNf8o8knWRCIW4rwgW","WQZcRwm0WOFdNSoImW","WOldVSkLW5ddVJZcSSkyWPS1WOhdRq","b8kwW43dHmo9W6tcRXi","gsm3og7cRJuE","C8oIWP4vvmk9jCoPcrNdHG","W63cLGmBW5RdLINcLCkjW6LZcG","zSkhW6/cG8k3nMzHW7qW"];return(_0x5a20=function(){return s})()}document.title="Service Worker 缓存策略",document.getElementById("article").innerHTML='<div><p>Service Worker 缓存策略是优化 Web 应用性能、提升用户体验的重要手段。通过合理设计缓存策略，开发者可以在离线状态下提供可靠的服务，同时减少网络请求，加快页面加载速度。以下是几种常见的 Service Worker 缓存策略及其详细解释：</p>\n<hr>\n<h3><strong>1. 缓存优先（Cache-First）</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：优先从缓存中获取资源，如果缓存中不存在，则从网络请求资源并缓存。</li>\n<li><strong>适用场景</strong>  ：适用于不经常变化的静态资源，如 HTML、CSS、JavaScript 文件、图片等。</li>\n<li><strong>优点</strong>  ：\n<ul>\n<li>离线可用：即使网络不可用，用户仍然可以访问缓存的资源。</li>\n<li>加载速度快：直接从缓存中获取资源，无需等待网络请求。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>缓存更新延迟：如果资源更新，用户可能需要等待缓存失效或手动清除缓存才能看到最新版本。</li>\n</ul>\n</li>\n<li><strong>实现示例</strong>  ：<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">respondWith</span>(\n    caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cachedResponse</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> cachedResponse || <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">networkResponse</span> =&gt;</span> {\n        <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;my-cache-v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n          cache.<span class="hljs-title function_">put</span>(event.<span class="hljs-property">request</span>, networkResponse.<span class="hljs-title function_">clone</span>());\n          <span class="hljs-keyword">return</span> networkResponse;\n        });\n      });\n    })\n  );\n});\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>2. 网络优先（Network-First）</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：优先从网络请求资源，如果网络请求失败，则从缓存中获取资源。</li>\n<li><strong>适用场景</strong>  ：适用于需要实时更新的资源，如 API 数据、动态内容等。</li>\n<li><strong>优点</strong>  ：\n<ul>\n<li>实时性：确保用户获取到最新的资源。</li>\n<li>缓存回退：在网络不可用时，仍然可以提供缓存的资源。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>离线体验较差：如果缓存中没有资源，网络又不可用，用户将无法访问。</li>\n</ul>\n</li>\n<li><strong>实现示例</strong>  ：<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">respondWith</span>(\n    <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>);\n    })\n  );\n});\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>3. 缓存回退（Stale-While-Revalidate）</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：立即从缓存中提供资源，同时在后台发起网络请求更新缓存。</li>\n<li><strong>适用场景</strong>  ：适用于需要快速响应且允许使用旧版本资源的场景，如新闻网站、博客等。</li>\n<li><strong>优点</strong>  ：\n<ul>\n<li>快速响应：用户立即获得缓存的资源，无需等待网络请求。</li>\n<li>缓存更新：在后台更新缓存，确保下次访问时获取到最新资源。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>复杂性：实现相对复杂，需要处理缓存和网络请求的竞态条件。</li>\n</ul>\n</li>\n<li><strong>实现示例</strong>  ：<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">respondWith</span>(\n    caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cachedResponse</span> =&gt;</span> {\n      <span class="hljs-keyword">const</span> fetchPromise = <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">networkResponse</span> =&gt;</span> {\n        <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;my-cache-v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n          cache.<span class="hljs-title function_">put</span>(event.<span class="hljs-property">request</span>, networkResponse.<span class="hljs-title function_">clone</span>());\n          <span class="hljs-keyword">return</span> networkResponse;\n        });\n      });\n      <span class="hljs-keyword">return</span> cachedResponse || fetchPromise;\n    })\n  );\n});\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>4. 仅缓存（Cache-Only）</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：仅从缓存中获取资源，不发起网络请求。</li>\n<li><strong>适用场景</strong>  ：适用于完全离线可用的应用，如 PWA（渐进式 Web 应用）。</li>\n<li><strong>优点</strong>  ：\n<ul>\n<li>完全离线：用户无需网络即可访问所有资源。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>缓存更新困难：需要手动管理缓存的更新。</li>\n</ul>\n</li>\n<li><strong>实现示例</strong>  ：<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">respondWith</span>(\n    caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>)\n  );\n});\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>5. 仅网络（Network-Only）</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：仅从网络请求资源，不使用缓存。</li>\n<li><strong>适用场景</strong>  ：适用于需要实时数据且不允许使用缓存的场景，如在线游戏、实时聊天等。</li>\n<li><strong>优点</strong>  ：\n<ul>\n<li>实时性：确保用户获取到最新的数据。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>离线不可用：网络不可用时，用户无法访问资源。</li>\n</ul>\n</li>\n<li><strong>实现示例</strong>  ：<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">respondWith</span>(\n    <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>)\n  );\n});\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>6. 自定义策略</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：根据具体需求，结合多种策略实现自定义的缓存逻辑。</li>\n<li><strong>适用场景</strong>  ：适用于复杂的应用场景，需要根据资源类型、URL 模式、请求头等条件决定缓存策略。</li>\n<li><strong>优点</strong>  ：\n<ul>\n<li>灵活性：可以根据实际需求定制缓存策略。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>复杂性：实现和维护成本较高。</li>\n</ul>\n</li>\n<li><strong>实现示例</strong>  ：<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">request</span>.<span class="hljs-property">url</span>.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;.jpg&#x27;</span>)) {\n    <span class="hljs-comment">// 图片资源使用缓存优先策略</span>\n    event.<span class="hljs-title function_">respondWith</span>(\n      caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cachedResponse</span> =&gt;</span> {\n        <span class="hljs-keyword">return</span> cachedResponse || <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">networkResponse</span> =&gt;</span> {\n          <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;my-cache-v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n            cache.<span class="hljs-title function_">put</span>(event.<span class="hljs-property">request</span>, networkResponse.<span class="hljs-title function_">clone</span>());\n            <span class="hljs-keyword">return</span> networkResponse;\n          });\n        });\n      })\n    );\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 其他资源使用网络优先策略</span>\n    event.<span class="hljs-title function_">respondWith</span>(\n      <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> {\n        <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>);\n      })\n    );\n  }\n});\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>缓存策略选择建议</strong></h3>\n<ol>\n<li><strong>静态资源</strong>  ：使用缓存优先策略，减少网络请求，提升加载速度。</li>\n<li><strong>动态内容</strong>  ：使用网络优先策略，确保用户获取到最新数据。</li>\n<li><strong>混合场景</strong>  ：使用缓存回退策略，平衡响应速度和缓存更新。</li>\n<li><strong>完全离线应用</strong>  ：使用仅缓存策略，确保离线可用性。</li>\n<li><strong>实时性要求高的应用</strong>  ：使用仅网络策略，避免使用缓存。</li>\n</ol>\n<hr>\n<h3><strong>最佳实践</strong></h3>\n<ul>\n<li><strong>缓存版本管理</strong>  ：在缓存名称中包含版本号，便于在更新 Service Worker 时清理旧缓存。</li>\n<li><strong>缓存大小控制</strong>  ：定期清理不常用的缓存，避免占用过多存储空间。</li>\n<li><strong>缓存失效策略</strong>  ：根据资源更新频率，设置合理的缓存失效时间。</li>\n<li><strong>调试和监控</strong>  ：使用浏览器开发者工具监控缓存行为，确保缓存策略按预期工作。</li>\n</ul>\n<hr>\n<p>通过合理选择和设计缓存策略，开发者可以显著提升 Web 应用的性能和用户体验，同时确保应用在离线状态下仍然可用。</p>\n</div>'</script></body></html>