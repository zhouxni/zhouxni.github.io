<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x14a77a=_0x4045;function _0x4045(t,n){var e=_0x2efe();return(_0x4045=function(n,s){var a=e[n-=436];void 0===_0x4045.XTxUGk&&(_0x4045.XXMOrq=function(n,s){var a,l=[],t=0,e="";for(n=(n=>{for(var s,a,l="",t="",e=0,r=0;a=n.charAt(r++);~a&&(s=e%4?64*s+a:a,e++%4)&&(l+=String.fromCharCode(255&s>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=l.length;o<c;o++)t+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(t)})(n),r=0;r<256;r++)l[r]=r;for(r=0;r<256;r++)t=(t+l[r]+s.charCodeAt(r%s.length))%256,a=l[r],l[r]=l[t],l[t]=a;for(var r=0,t=0,o=0;o<n.length;o++)a=l[r=(r+1)%256],l[r]=l[t=(t+l[r])%256],l[t]=a,e+=String.fromCharCode(n.charCodeAt(o)^l[(l[r]+l[t])%256]);return e},t=arguments,_0x4045.XTxUGk=!0);var n=n+e[0],l=t[n];return l?a=l:(void 0===_0x4045.mgiEsb&&(_0x4045.mgiEsb=!0),a=_0x4045.XXMOrq(a,s),t[n]=a),a})(t,n)}if((()=>{for(var n=_0x4045,s=_0x2efe();;)try{if(354965==+parseInt(n(450,"9O%J"))*(-parseInt(n(448,")12^"))/2)+parseInt(n(458,"Dh!D"))/3+parseInt(n(445,"XJ5%"))/4+parseInt(n(441,"nrpR"))/5*(-parseInt(n(456,"Dh!D"))/6)+parseInt(n(454,"l!sV"))/7*(parseInt(n(457,"yWVO"))/8)+-parseInt(n(439,")12^"))/9+-parseInt(n(437,"l!sV"))/10*(parseInt(n(462,")vCp"))/11))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x14a77a(453,"Qi^r")](_0x14a77a(444,"Qi^r"))!=_0x14a77a(455,")vCp"))throw window[_0x14a77a(443,"Ille")][_0x14a77a(436,"yWVO")](_0x14a77a(447,"!7GZ")),Error();function _0x2efe(){var n=["W7igf0xcO8ohxmkiW7PkWO1QW7W","WOPOfmo5qdJdRW","dhy3W44XWRZdSmkFW6i","DGpcJY4bWQZcLSox","W7BcMSk4EcKQzW","WQ/dKuddR8o1vudcMCoKf1xdNa","W4NcKSk2iehcHCkWsg1FWQa","cJJcT8k7ebaqW7ZdT8kVWOldGCka","Adf6zNyvaSkJWOFdR8kIW6rb","W6X2i0dcUblcUa","W6SLuIRdNvBcNsbWW4tdU8of","nMyPpJDjx8kM","WPuAW4qVWPtcOI1hEG","WO3cGSkMaCogmCoIpXzTWQ7dIdW","W61TtYHigu7dH8kg","WRxdLxqoo8otW7DDuCo3W6OAlZSVWPnIovtcGsJcQ1OwDrG","dd7dJmoJqLf7W6G","WReyzK/dI8oyWQ3cHYLLesO","i8k8W4XFWPrbW4mBFCkPW5K","WOa6W40omCkYW4lcJCo5ma","WQ/dLeFcImkspetcJCoK","WRmCW5mdWPpcTaS","WQZdKuhdR8oXveFcT8ofmgZdHG","tJz3W6KC","WQT7WR8PW7nQW7ddQCkjgq","WRBdJ8oWrJ8UuNLp","WQ9+WRKRWQK0WPNdG8kgg05VW4a","W6PRq0OmtIFdVSkzqmoiWRTJ"];return(_0x2efe=function(){return n})()}document.title="JavaScript 函数调用栈帧详解",document.getElementById("article").innerHTML='<div><p>函数调用栈帧（Stack Frame）是 JavaScript 执行机制中的核心概念，它记录了函数调用时的关键信息。下面我将从原理到实践全面解析栈帧的工作机制。</p>\n<h2>一、什么是调用栈（Call Stack）？</h2>\n<p>调用栈是一种后进先出（LIFO）的数据结构，用于管理函数调用关系。当函数被调用时，会创建一个新的栈帧压入调用栈；函数执行完毕，对应的栈帧从调用栈弹出。</p>\n<h3>调用栈的特点：</h3>\n<ul>\n<li><strong>后进先出</strong>   ：最后调用的函数最先执行完成</li>\n<li><strong>大小有限</strong>   ：栈空间有限，递归过深会导致&quot;栈溢出&quot;（Stack Overflow）</li>\n<li><strong>同步执行</strong>   ：JavaScript 是单线程，调用栈一次只处理一个函数</li>\n</ul>\n<h2>二、栈帧的组成结构</h2>\n<p>每个栈帧包含以下关键信息：</p>\n<ol>\n<li><strong>函数参数（Arguments）</strong></li>\n<li><strong>局部变量（Local Variables）</strong></li>\n<li><strong>返回地址（Return Address）</strong></li>\n<li><strong>this 值</strong></li>\n<li><strong>作用域链（Scope Chain）</strong></li>\n<li><strong>闭包引用（Closure References）</strong></li>\n</ol>\n<h2>三、栈帧生命周期示例</h2>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) {\n  <span class="hljs-keyword">let</span> sum = a + b;\n  <span class="hljs-keyword">return</span> sum;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;\n  <span class="hljs-keyword">let</span> y = <span class="hljs-number">3</span>;\n  <span class="hljs-keyword">let</span> result = <span class="hljs-title function_">add</span>(x, y);\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);\n}\n\n<span class="hljs-title function_">calculate</span>();\n</code></pre>\n<h3>执行过程分析：</h3>\n<ol>\n<li>\n<p><strong>初始状态</strong>   ：空调用栈</p>\n<pre><code>Call Stack: []\n</code></pre>\n</li>\n<li>\n<p><strong>calculate() 调用</strong>   ：</p>\n<pre><code>Call Stack: [\n  calculate()栈帧 {\n    variables: {x: undefined, y: undefined, result: undefined},\n    this: window,\n    returnAddress: global\n  }\n]\n</code></pre>\n</li>\n<li>\n<p><strong>执行到 add() 调用</strong>   ：</p>\n<pre><code>Call Stack: [\n  add()栈帧 {\n    arguments: {a: 5, b: 3},\n    variables: {sum: undefined},\n    this: window,\n    returnAddress: calculate()\n  },\n  calculate()栈帧 {\n    variables: {x: 5, y: 3, result: undefined},\n    this: window,\n    returnAddress: global\n  }\n]\n</code></pre>\n</li>\n<li>\n<p><strong>add() 执行完毕</strong>   ：</p>\n<pre><code>Call Stack: [\n  calculate()栈帧 {\n    variables: {x: 5, y: 3, result: 8},\n    this: window,\n    returnAddress: global\n  }\n]\n</code></pre>\n</li>\n<li>\n<p><strong>calculate() 执行完毕</strong>   ：</p>\n<pre><code>Call Stack: []\n</code></pre>\n</li>\n</ol>\n<h2>四、栈帧的特殊情况处理</h2>\n<h3>1. 闭包中的栈帧</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> ++count;\n  };\n}\n<span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>();\n</code></pre>\n<ul>\n<li><code>createCounter</code> 执行完后，其栈帧中的 <code>count</code> 变量被闭包保留</li>\n<li>闭包函数持有对父函数作用域的引用</li>\n</ul>\n<h3>2. 递归调用的栈帧</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>) {\n  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;\n  <span class="hljs-keyword">return</span> n * <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>);\n}\n<span class="hljs-title function_">factorial</span>(<span class="hljs-number">3</span>);\n</code></pre>\n<p>每次递归都会创建新的栈帧：</p>\n<pre><code>Call Stack: [\n  factorial(1),\n  factorial(2),\n  factorial(3),\n  global\n]\n</code></pre>\n<h3>3. 异步回调的栈帧</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncTask</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Async done&quot;</span>);\n  }, <span class="hljs-number">1000</span>);\n}\n<span class="hljs-title function_">asyncTask</span>();\n</code></pre>\n<ul>\n<li><code>asyncTask</code> 执行完后栈帧立即弹出</li>\n<li>回调函数执行时创建全新的调用栈</li>\n</ul>\n<h2>五、栈帧的内存管理</h2>\n<ol>\n<li>\n<p><strong>栈内存分配</strong>   ：</p>\n<ul>\n<li>固定大小的连续内存空间</li>\n<li>由系统自动管理，分配和释放速度快</li>\n</ul>\n</li>\n<li>\n<p><strong>栈溢出</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-title function_">infiniteLoop</span>();\n}\n<span class="hljs-title function_">infiniteLoop</span>(); <span class="hljs-comment">// 抛出 &quot;Maximum call stack size exceeded&quot;</span>\n</code></pre>\n</li>\n<li>\n<p><strong>栈帧优化</strong>   ：</p>\n<ul>\n<li>尾调用优化（Tail Call Optimization）</li>\n<li>内联函数优化</li>\n</ul>\n</li>\n</ol>\n<h2>六、调试工具中的栈帧</h2>\n<p>Chrome DevTools 中的调用栈示例：</p>\n<ol>\n<li>在源代码中设置断点</li>\n<li>执行到断点时查看 Call Stack 面板</li>\n<li>可以查看每个栈帧的：\n<ul>\n<li>局部变量值</li>\n<li>闭包变量</li>\n<li>this 值</li>\n<li>作用域链</li>\n</ul>\n</li>\n</ol>\n<h2>七、最佳实践</h2>\n<ol>\n<li><strong>避免深层递归</strong>   ：改用循环或尾递归</li>\n<li><strong>减少闭包滥用</strong>   ：不必要的闭包会延长变量生命周期</li>\n<li><strong>控制栈帧大小</strong>   ：减少大型局部变量的使用</li>\n<li><strong>合理使用异步</strong>   ：将耗时操作转为异步避免阻塞调用栈</li>\n</ol>\n<p>理解栈帧机制对于调试递归问题、内存泄漏和性能优化都有重要意义。它是 JavaScript 执行模型的基础组成部分。</p>\n</div>'</script></body></html>