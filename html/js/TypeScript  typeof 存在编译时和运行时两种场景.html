<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x37fe(l,s){var o=_0x5bfb();return(_0x37fe=function(s,n){var a=o[s-=299];void 0===_0x37fe.rInCMN&&(_0x37fe.JApqZm=function(s,n){var a,t=[],l=0,o="";for(s=(s=>{for(var n,a,t="",l="",o=0,e=0;a=s.charAt(e++);~a&&(n=o%4?64*n+a:a,o++%4)&&(t+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,c=t.length;p<c;p++)l+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,p=0;p<s.length;p++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,o+=String.fromCharCode(s.charCodeAt(p)^t[(t[e]+t[l])%256]);return o},l=arguments,_0x37fe.rInCMN=!0);var s=s+o[0],t=l[s];return t?a=t:(void 0===_0x37fe.NuGbXQ&&(_0x37fe.NuGbXQ=!0),a=_0x37fe.JApqZm(a,n),l[s]=a),a})(l,s)}function _0x5bfb(){var s=["FmokW5tcVKxdTdWZlK1VW404","EYVdUXj7b30aW7JcISkyWP4JW7RcSdv4WO0lW7P3WRSmqsBcTG","fmoqEe/cSSkjwCop","ucJcVCkCWPhdLWxcTmkZWPdcQCkxFG","W71wbSknW4ddJCobDc1iDCkYW6vB","nc3cNv/dSx3dNfldI8kWWPuV","vmowgXRdLmolWOKm","W5jQjr9aW6ZdNrFcMxJcLmkO","qSo6iSkgumkcxSoXWQqnp8or","DSoKWORcNIJcUxvd","WOZcJGVdH8k6ms9sW43cOSkfua","x8oeW54QemkmWRr0W6FcPmkkdG","hmoCfaFdJCoWFSoOW5NcVXpdSa","f8oDfWFdISo4cmk+W4NcRIJdGWddJa","WP/cQmkNdIaOWRHn","hCoEfWBdJSo4BCoaW6NcVHhdLq","W4ryWQldHSkg","fmoACK7cTCkLvSoj","W7fRWRldG8oGDSkQ","gCoEWRVcMSk9A8kcuSom","s8o+xCo+kCoIB8ov","WQRcTXZcRmk7WOtdGCkDWODjWROK","W6hcNXpdQmkSW6nSWRa","W71tcSkmW4ddISoenITQqmkWW6e","W6BcT1T/WR0CCXOnqKH7tG","W40VW5ZdVsewcW"];return(_0x5bfb=function(){return s})()}var _0x47402f=_0x37fe;if((()=>{for(var s=_0x37fe,n=_0x5bfb();;)try{if(546804==-parseInt(s(323,"7qH5"))+-parseInt(s(315,"18f7"))/2+parseInt(s(319,"YAgb"))/3*(parseInt(s(306,"m!AN"))/4)+parseInt(s(317,"i33F"))/5*(parseInt(s(318,"4rN!"))/6)+-parseInt(s(310,"rY7["))/7+parseInt(s(301,"H%n["))/8*(parseInt(s(314,"H%n["))/9)+parseInt(s(299,"H%n["))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x47402f(311,"Mcl(")](_0x47402f(305,"1mvQ"))!=_0x47402f(302,"TWRZ"))throw window[_0x47402f(300,"HzB%")][_0x47402f(304,"PXlp")](_0x47402f(313,"&2X)")),Error();document.title="TypeScript  typeof 存在编译时和运行时两种场景",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>typeof</code> 关键字确实存在<strong>编译时</strong>   和<strong>运行时</strong>   两种场景，但其具体行为和用途差异较大：</p>\n<h3><strong>1. 编译时 <code>typeof</code>（类型查询）</strong></h3>\n<h4><strong>用途</strong></h4>\n<ul>\n<li>获取<strong>变量或属性的类型</strong>   ，用于类型注解、泛型约束等静态类型系统中。</li>\n<li><strong>仅在编译阶段生效</strong>   ，运行时不存在。</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> user = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>,\n  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,\n};\n\n<span class="hljs-comment">// 编译时获取 user 对象的类型</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">UserType</span> = <span class="hljs-keyword">typeof</span> user; <span class="hljs-comment">// 等价于 { name: string; age: number }</span>\n\n<span class="hljs-comment">// 使用 typeof 进行类型注解</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">anotherUser</span>: <span class="hljs-title class_">UserType</span> = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> };\n</code></pre>\n<h4><strong>常见场景</strong></h4>\n<ul>\n<li>\n<p><strong>获取函数返回值类型</strong>   ：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createUser</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> };\n}\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> createUser&gt;; <span class="hljs-comment">// { id: number; name: string }</span>\n</code></pre>\n</li>\n<li>\n<p><strong>获取类的静态类型</strong>   ：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {\n  <span class="hljs-keyword">static</span> version = <span class="hljs-string">&quot;1.0&quot;</span>;\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>) {}\n}\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">ClassStaticType</span> = <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">MyClass</span>; <span class="hljs-comment">// 包含静态属性和方法的类型</span>\n</code></pre>\n</li>\n</ul>\n<h3><strong>2. 运行时 <code>typeof</code>（JavaScript 原生操作符）</strong></h3>\n<h4><strong>用途</strong></h4>\n<ul>\n<li>返回一个表示<strong>值的基本类型</strong>   的字符串（如 <code>&quot;number&quot;</code>、<code>&quot;string&quot;</code>、<code>&quot;object&quot;</code> 等）。</li>\n<li><strong>在 JavaScript 运行时执行</strong>   ，与 TypeScript 类型系统无关。</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> num = <span class="hljs-number">42</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> num); <span class="hljs-comment">// 输出: &quot;number&quot;</span>\n\n<span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;value&quot;</span> };\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> obj); <span class="hljs-comment">// 输出: &quot;object&quot;</span>\n</code></pre>\n<h4><strong>返回值注意事项</strong></h4>\n<p>JavaScript 的 <code>typeof</code> 返回值有局限性：</p>\n<ul>\n<li>对于 <code>null</code>，返回 <code>&quot;object&quot;</code>（历史遗留问题）。</li>\n<li>对于数组、正则等对象，均返回 <code>&quot;object&quot;</code>。</li>\n<li>对于函数，返回 <code>&quot;function&quot;</code>。</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>); <span class="hljs-comment">// &quot;object&quot;</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> []); <span class="hljs-comment">// &quot;object&quot;</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> /abc/); <span class="hljs-comment">// &quot;object&quot;</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeof</span> (<span class="hljs-function">() =&gt;</span> {})); <span class="hljs-comment">// &quot;function&quot;</span>\n</code></pre>\n<h3><strong>3. 对比总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>编译时 <code>typeof</code></th>\n<th>运行时 <code>typeof</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>语法位置</strong></td>\n<td>类型注解、泛型、类型别名中</td>\n<td>表达式、条件语句中</td>\n</tr>\n<tr>\n<td><strong>作用域</strong></td>\n<td>仅在 TypeScript 编译阶段有效</td>\n<td>在 JavaScript 运行时执行</td>\n</tr>\n<tr>\n<td><strong>返回值</strong></td>\n<td>类型（如 <code>string</code>、<code>{ name: string }</code>）</td>\n<td>字符串（如 <code>&quot;string&quot;</code>、<code>&quot;object&quot;</code>）</td>\n</tr>\n<tr>\n<td><strong>示例</strong></td>\n<td><code>type T = typeof myVar</code></td>\n<td><code>if (typeof value === &quot;number&quot;)</code></td>\n</tr>\n</tbody>\n</table>\n<h3><strong>4. 常见混淆场景</strong></h3>\n<h4><strong>错误示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-comment">// 错误：编译时尝试访问运行时变量</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">printType</span>(<span class="hljs-params"><span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span></span>) {\n  <span class="hljs-keyword">type</span> T = <span class="hljs-keyword">typeof</span> value; <span class="hljs-comment">// 报错：&#x27;value&#x27; 仅在运行时存在</span>\n  <span class="hljs-comment">// ...</span>\n}\n</code></pre>\n<h4><strong>正确做法</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-comment">// 运行时使用 JavaScript 的 typeof</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">printType</span>(<span class="hljs-params"><span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span></span>) {\n  <span class="hljs-keyword">const</span> typeStr = <span class="hljs-keyword">typeof</span> value; <span class="hljs-comment">// &quot;number&quot;、&quot;string&quot; 等</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(typeStr);\n}\n\n<span class="hljs-comment">// 编译时使用类型系统</span>\n<span class="hljs-keyword">function</span> createPair&lt;T&gt;(<span class="hljs-attr">a</span>: T, <span class="hljs-attr">b</span>: T): [T, T] {\n  <span class="hljs-keyword">return</span> [a, b];\n}\n</code></pre>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>编译时 <code>typeof</code></strong>   ：是 TypeScript 类型系统的一部分，用于静态类型查询。</li>\n<li><strong>运行时 <code>typeof</code></strong>   ：是 JavaScript 的原生操作符，用于动态类型检查。</li>\n<li>两者语法相同但用途完全不同，需根据上下文区分使用。</li>\n</ul>\n</div>'</script></body></html>