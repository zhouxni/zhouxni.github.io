<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4083ee=_0x3d87;function _0x32b9(){var s=["WOhdUCkXFmkLawf0ESocWR1bWQC","W7GDWOX3W7O8w8obWRDnscK","W4jfqSozW7dcVKtcP8kOWRpdSmkomq","W6i5W5pdRf3cMSoMW7y","ECoEdayqWQm0CgTXk8ku","lbn4W6tdQmkwWRNdIchdOSkRWPS3","ymoheSoRW4tdTSokWQq","W5lcPCoAW40EW4JdMGyfW5VcNmo5W4a","WOKcv8kBW5ObW5ZdUq","mSkRBYjA","c2LVW6z7hCkD","W5rvaComWPHFWOFdLfHmWOZdOmo/","WOLzWQ/dNmksW53cQmk8WR95ECot","sd5XW4nvcSk7DW","W5DVWPuaWR1qW7m","WQNdMvNcGuqjWRpdKCoXDr7cUq","WO1DWQVdKSkqW5ZdGCk7WRHeu8o5lG","huBcKmkbWR5eWOJcLa","W5KcW514u8kFW7hdHwy1WOJdKSkyW5RdMhxcUmk1j8oYiSoYimonCHe","WOK/W5HWW7GfW7NcTZVcR8oJbW","s8kHWRfdW4lcS8kYvbi8WQva","WPpcOSoknLOWW6BcQCoQ","WQhdLfxcJKmoW6ddVCo2CZVcRMq","W7euWOL/W7C1fCosWPzqFGFcUq"];return(_0x32b9=function(){return s})()}function _0x3d87(p,s){var c=_0x32b9();return(_0x3d87=function(s,n){var a=c[s-=459];void 0===_0x3d87.xtaUEp&&(_0x3d87.pQkTFA=function(s,n){var a,l=[],p=0,c="";for(s=(s=>{for(var n,a,l="",p="",c=0,t=0;a=s.charAt(t++);~a&&(n=c%4?64*n+a:a,c++%4)&&(l+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,o=l.length;r<o;r++)p+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(p)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)p=(p+l[t]+n.charCodeAt(t%n.length))%256,a=l[t],l[t]=l[p],l[p]=a;for(var t=0,p=0,r=0;r<s.length;r++)a=l[t=(t+1)%256],l[t]=l[p=(p+l[t])%256],l[p]=a,c+=String.fromCharCode(s.charCodeAt(r)^l[(l[t]+l[p])%256]);return c},p=arguments,_0x3d87.xtaUEp=!0);var s=s+c[0],l=p[s];return l?a=l:(void 0===_0x3d87.fEJxQE&&(_0x3d87.fEJxQE=!0),a=_0x3d87.pQkTFA(a,n),p[s]=a),a})(p,s)}if((()=>{for(var s=_0x3d87,n=_0x32b9();;)try{if(746013==-parseInt(s(466,"&Lg]"))+parseInt(s(460,"YP@G"))/2+-parseInt(s(461,"qto7"))/3+parseInt(s(478,"yf#i"))/4+-parseInt(s(463,"qto7"))/5*(parseInt(s(479,"QN*x"))/6)+-parseInt(s(477,"YP@G"))/7+parseInt(s(464,"M3GN"))/8*(parseInt(s(465,"IZrB"))/9))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x4083ee(476,"nOj$")](_0x4083ee(459,"APUF"))!=_0x4083ee(471,"$uFo"))throw window[_0x4083ee(470,"xAa$")][_0x4083ee(472,"th9i")](_0x4083ee(480,"#vwP")),Error();document.title="尾递归",document.getElementById("article").innerHTML='<div><p>尾递归是一种特殊的递归形式，在 JavaScript 中它是解决递归调用栈溢出问题的重要技术。下面详细解析尾递归的概念、工作原理和实际应用。</p>\n<h3>什么是尾递归</h3>\n<p>尾递归是指递归函数的最后一个操作是递归调用本身，且没有其他后续操作（如运算、处理等）。</p>\n<p><strong>普通递归 vs 尾递归：</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 普通递归（非尾递归）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">n</span>) {\n  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;\n  <span class="hljs-comment">// 递归调用后还有加法操作</span>\n  <span class="hljs-keyword">return</span> n + <span class="hljs-title function_">sum</span>(n - <span class="hljs-number">1</span>);\n}\n\n<span class="hljs-comment">// 尾递归</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">n, accumulator = <span class="hljs-number">0</span></span>) {\n  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> accumulator;\n  <span class="hljs-comment">// 递归调用是函数的最后一个操作</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">sum</span>(n - <span class="hljs-number">1</span>, n + accumulator);\n}\n</code></pre>\n<h3>尾递归的工作原理</h3>\n<p>普通递归的问题在于每次递归调用都会在调用栈上创建新的帧，保存当前状态，当递归深度过大时就会导致栈溢出。</p>\n<p>尾递归的优势在于：</p>\n<ul>\n<li>递归调用是函数的最后一步操作</li>\n<li>不需要保留当前函数的执行上下文（因为没有后续操作）</li>\n<li>支持尾递归优化的引擎会复用当前栈帧，而不是创建新的栈帧</li>\n</ul>\n<p>这意味着即使递归深度很大，调用栈的深度也不会增加，从而避免栈溢出。</p>\n<h3>尾递归优化（TCO）</h3>\n<p>尾递归优化是 JavaScript 引擎的一项特性，它能识别尾递归模式并优化执行，防止栈溢出。</p>\n<p><strong>现状说明：</strong></p>\n<ul>\n<li>ES6 标准规定了尾递归优化，但实际支持情况有限</li>\n<li>目前只有 Safari 的 JavaScriptCore 引擎完全支持</li>\n<li>Chrome、Node.js（V8 引擎）暂不支持尾递归优化</li>\n<li>未来可能会有更多引擎支持这一特性</li>\n</ul>\n<h3>实现尾递归的关键步骤</h3>\n<ol>\n<li><strong>添加累加器参数</strong>   ：用于保存中间计算结果</li>\n<li><strong>调整递归逻辑</strong>   ：确保递归调用是函数的最后操作</li>\n<li><strong>设置终止条件</strong>   ：明确递归结束的条件并返回累加器</li>\n</ol>\n<p><strong>示例：计算阶乘的尾递归实现</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 尾递归版本的阶乘计算</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n, accumulator = <span class="hljs-number">1</span></span>) {\n  <span class="hljs-comment">// 终止条件</span>\n  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> accumulator;\n  <span class="hljs-comment">// 尾递归调用：最后一步且无后续操作</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>, n * accumulator);\n}\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">factorial</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 120</span>\n</code></pre>\n<h3>不支持 TCO 时的替代方案</h3>\n<p>由于并非所有 JavaScript 环境都支持尾递归优化，我们可以使用<strong>蹦床函数（trampoline）</strong>   来模拟类似效果：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 蹦床函数：将递归调用转换为循环执行</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">trampoline</span>(<span class="hljs-params">fn</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {\n    <span class="hljs-keyword">let</span> result = <span class="hljs-title function_">fn</span>(...args);\n    <span class="hljs-comment">// 循环执行，直到不再返回函数</span>\n    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;function&quot;</span>) {\n      result = <span class="hljs-title function_">result</span>();\n    }\n    <span class="hljs-keyword">return</span> result;\n  };\n}\n\n<span class="hljs-comment">// 改造递归函数，使其返回一个函数而不是直接调用</span>\n<span class="hljs-keyword">const</span> sum = <span class="hljs-title function_">trampoline</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">sumRecursive</span>(<span class="hljs-params">n, accumulator = <span class="hljs-number">0</span></span>) {\n  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> accumulator;\n  <span class="hljs-comment">// 返回一个函数而非直接递归调用</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">sumRecursive</span>(n - <span class="hljs-number">1</span>, n + accumulator);\n});\n\n<span class="hljs-comment">// 可以安全处理大数递归</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">100000</span>)); <span class="hljs-comment">// 不会栈溢出</span>\n</code></pre>\n<h3>尾递归适用场景</h3>\n<ol>\n<li><strong>数值计算</strong>   ：阶乘、斐波那契数列、累加求和等</li>\n<li><strong>树结构遍历</strong>   ：深度优先遍历可以用尾递归实现</li>\n<li><strong>状态转换</strong>   ：需要保持中间状态的递归操作</li>\n</ol>\n<h3>注意事项</h3>\n<ol>\n<li>尾递归优化依赖 JavaScript 引擎支持，编写跨环境代码时需谨慎</li>\n<li>并非所有递归都能改写成尾递归形式</li>\n<li>当处理极深递归时，即使使用尾递归，也应考虑性能影响</li>\n<li>在不支持 TCO 的环境中，蹦床函数是可靠的替代方案</li>\n</ol>\n<p>总结来说，尾递归是一种优雅的递归优化技术，理解它的原理和实现方式，有助于我们编写更高效、更安全的递归代码。在实际开发中，结合具体运行环境选择合适的递归优化策略是关键。</p>\n</div>'</script></body></html>