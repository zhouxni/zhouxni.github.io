<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4967(t,s){var p=_0x4291();return(_0x4967=function(s,a){var n=p[s-=320];void 0===_0x4967.SmoFUP&&(_0x4967.wuGPkd=function(s,a){var n,l=[],t=0,p="";for(s=(s=>{for(var a,n,l="",t="",p=0,c=0;n=s.charAt(c++);~n&&(a=p%4?64*a+n:n,p++%4)&&(l+=String.fromCharCode(255&a>>(-2*p&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var e=0,o=l.length;e<o;e++)t+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)t=(t+l[c]+a.charCodeAt(c%a.length))%256,n=l[c],l[c]=l[t],l[t]=n;for(var c=0,t=0,e=0;e<s.length;e++)n=l[c=(c+1)%256],l[c]=l[t=(t+l[c])%256],l[t]=n,p+=String.fromCharCode(s.charCodeAt(e)^l[(l[c]+l[t])%256]);return p},t=arguments,_0x4967.SmoFUP=!0);var s=s+p[0],l=t[s];return l?n=l:(void 0===_0x4967.JbLXId&&(_0x4967.JbLXId=!0),n=_0x4967.wuGPkd(n,a),t[s]=n),n})(t,s)}var _0x2f6c47=_0x4967;function _0x4291(){var s=["jCoZWPPmg8ojWRXdWORdN0C","W5xdSWldSGFcOmkpqXu","tSkykt1iWQFcLX3cIMjS","W7tcV8kHgSoJWRtdImk3gmkFpa","gSkByG9rdMedWRusWQ7cVSo0","p21RoqrXW701","W59lWQxcL2yIc8oHW4eCW5BcRSkM","W57dUqddIdtcUmkstqW","W5ldJSoQW5bO","W4OXW4v4bSkIW5GA","WRBdLsnTFNZcGCocgGRcNa","bmoHWOijW5j7W4ddOIFcLq0","zmkFWOK6CmoODqxcMCoPWOxcQ8obWQBdPKBdQCoUW6uopK7dJCohW5FcRW","rCkxkemVWOdcKrpcSq","W7FcUSkVh8oGW5dcN8k1kSkRhmo/WPy","x8k6W5LFWPzeW4ddPa","A0tcRCoZW6RdJ8kcbmkkWOzgA00","W7xcUmkVh8oRW5xcLCkwkCkjcCoIWQG","fCkByuWpsaKhWO4","WRndfCojFmkjEq","WQZcSstdPuFcP0r/WOlcOCoJW5j8","vmkWW453WPziW4i","WQdcV8k0aaS4W5JcJSk/aCkEW5pdKa","W57dUq/cU1hcV8k8qJbNWQi","WRPMW5rkiSkjW4yZta","FmklW61aWPPvdCktgaGKW67dRq"];return(_0x4291=function(){return s})()}if((()=>{for(var s=_0x4967,a=_0x4291();;)try{if(925562==-parseInt(s(345,"8w[L"))+-parseInt(s(329,"@S8t"))/2+-parseInt(s(323,"]^sb"))/3+parseInt(s(333,")%1J"))/4+-parseInt(s(330,"Zb]s"))/5*(-parseInt(s(339,"(Fx7"))/6)+-parseInt(s(334,"*SEF"))/7*(-parseInt(s(325,"7wB!"))/8)+-parseInt(s(342,"#rZ]"))/9*(parseInt(s(340,"db]v"))/10))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x2f6c47(324,"db]v")](_0x2f6c47(327,"MV0d"))!=_0x2f6c47(337,"Lzwa"))throw window[_0x2f6c47(344,"db]v")][_0x2f6c47(322,"rTZ%")](_0x2f6c47(341,"DNl3")),Error();document.title="script 标签 ESM",document.getElementById("article").innerHTML='<div><p>在现代 Web 开发中，使用 <code>&lt;script&gt;</code> 标签加载 ECMAScript 模块（ESM）是一种常见的方式。ESM 提供了模块化的代码组织方式，支持动态导入和更好的工具支持。要在 HTML 中使用 <code>&lt;script&gt;</code> 标签加载 ESM，需要设置 <code>type</code> 属性为 <code>module</code>。以下是详细步骤和注意事项：</p>\n<h3>1. 基本用法</h3>\n<p>要在 HTML 文件中使用 ESM，你需要在 <code>&lt;script&gt;</code> 标签中设置 <code>type=&quot;module&quot;</code>：</p>\n<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>ESM Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, ESM!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript">\n    <span class="hljs-keyword">import</span> { sayHello } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>;\n\n    <span class="hljs-title function_">sayHello</span>();\n  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n</code></pre>\n<h3>2. 注意事项</h3>\n<ul>\n<li><strong>文件路径</strong>  ：\n<ul>\n<li>使用相对路径或绝对路径引用模块文件。</li>\n<li>如果使用相对路径，确保路径相对于 HTML 文件的位置是正确的。</li>\n<li>浏览器通常要求模块文件具有 <code>.js</code> 扩展名，即使省略，浏览器也会自动补全。</li>\n</ul>\n</li>\n<li><strong>跨域请求</strong>  ：\n<ul>\n<li>如果模块文件托管在不同的域名上，确保服务器设置了正确的 CORS 头，以允许跨域请求。</li>\n</ul>\n</li>\n<li><strong>加载顺序</strong>  ：\n<ul>\n<li>由于 ESM 是异步加载的，浏览器会在下载和解析完模块后执行代码。</li>\n<li>如果需要在模块加载完成后执行某些操作，可以使用 <code>import()</code> 动态导入或处理模块内的逻辑。</li>\n</ul>\n</li>\n<li><strong>浏览器支持</strong>  ：\n<ul>\n<li>大多数现代浏览器都支持 ESM，但旧版浏览器（如 IE）不支持。</li>\n<li>确保目标用户使用的浏览器版本支持 ESM。</li>\n</ul>\n</li>\n</ul>\n<h3>3. 动态导入</h3>\n<p>除了使用 <code>type=&quot;module&quot;</code> 的 <code>&lt;script&gt;</code> 标签静态导入模块，你还可以使用 <code>import()</code> 函数动态导入模块：</p>\n<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Dynamic Import Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Dynamic Import<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\n    <span class="hljs-comment">// 动态导入模块</span>\n    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./module.js&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) =&gt;</span> {\n      <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">sayHello</span>();\n    }).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to load module:&#x27;</span>, error);\n    });\n  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n</code></pre>\n<ul>\n<li><strong>优点</strong>  ：\n<ul>\n<li>动态导入允许你根据需要加载模块，有助于减少初始加载时间。</li>\n<li>可以与条件逻辑结合使用，以根据用户操作或其他条件加载模块。</li>\n</ul>\n</li>\n<li><strong>注意事项</strong>  ：\n<ul>\n<li>动态导入返回一个 Promise，因此需要使用 <code>.then()</code> 和 <code>.catch()</code> 处理异步操作。</li>\n</ul>\n</li>\n</ul>\n<h3>4. 与非模块脚本的兼容性</h3>\n<ul>\n<li><strong>执行顺序</strong>  ：\n<ul>\n<li>非模块脚本（即没有设置 <code>type=&quot;module&quot;</code> 的 <code>&lt;script&gt;</code> 标签）会按照它们在 HTML 中出现的顺序同步执行。</li>\n<li>模块脚本是异步执行的，不会阻塞 HTML 的解析。</li>\n</ul>\n</li>\n<li><strong>作用域</strong>  ：\n<ul>\n<li>模块脚本有自己的作用域，不会污染全局作用域。</li>\n<li>非模块脚本共享全局作用域，可能导致命名冲突。</li>\n</ul>\n</li>\n</ul>\n<h3>5. 示例模块文件 (<code>module.js</code>)</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from ESM module!&#x27;</span>);\n}\n</code></pre>\n<h3>6. 调试和错误处理</h3>\n<ul>\n<li><strong>控制台错误</strong>  ：\n<ul>\n<li>如果模块加载失败（如路径错误或网络问题），浏览器会在控制台中显示错误信息。</li>\n</ul>\n</li>\n<li><strong>网络请求</strong>  ：\n<ul>\n<li>使用浏览器的开发者工具查看网络请求，确保模块文件被正确加载。</li>\n</ul>\n</li>\n</ul>\n<h3>7. 总结</h3>\n<p>使用 <code>&lt;script type=&quot;module&quot;&gt;</code> 标签加载 ESM 是一种简单而强大的方式，可以让你的 Web 应用受益于模块化的代码组织。确保你的浏览器支持 ESM，并注意处理跨域请求和加载顺序。通过动态导入，你可以进一步优化应用的性能和加载时间。</p>\n</div>'</script></body></html>