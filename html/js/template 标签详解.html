<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x521d(){var s=["nSk5wSoKW40wW4WclW","WQPAySo3W6hcKSoaWRRdMfr5WQpdVW","WRFdOgRdOmo+DYtdUq","EHZdGqlcLrvke8oRW5u","W4aEW6RcMuvfcmkIWQxcQ2bSW4nbW4XUWOFcS8kcxCo6z1SLW7SP","WPWJgqPrWRnpW5i","kIpcUCktW67cP8ojW6tcGvFcHHm","k8o/W73cGNZcP8kHxgjg","pmk1uCkwWO0BW48YguuT","usVcOaDmW5q5sCoxE8kuWR4","W5z7W7xcP8o1qSoWWRCPBWtdSSo5","WP/dQcVcHb7dI1ZdGSoIBam","WODjc8orW74","W51tamkhdmoGCmkYW7SjdW","lIBcVSktW6RcO8oLW7FcGMxcGbe","kmkOWQ7dVu0Ah8kidexdOG","W6JcUZhdG8oYst3dKw4","WQ5QuSoNWP/cR8ki","bLNcUmo7W7D9v8ooCJfz","W648gSosWRFcJSk/htK","WPeMqNCDW6jkW53cHvi0WPa","W7FdGwe5WOpdJSo6FcO","WQyTWO/cKW1LWQxdQW","wSkJWQLIWRqWldOe","rCk3ASkxzsiV"];return(_0x521d=function(){return s})()}var _0x1ae1f7=_0x2ae8;function _0x2ae8(l,s){var p=_0x521d();return(_0x2ae8=function(s,n){var a=p[s-=273];void 0===_0x2ae8.HCiUXb&&(_0x2ae8.FtqYxu=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=t.length;c<o;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,c=0;c<s.length;c++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(c)^t[(t[e]+t[l])%256]);return p},l=arguments,_0x2ae8.HCiUXb=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x2ae8.fsXUlU&&(_0x2ae8.fsXUlU=!0),a=_0x2ae8.FtqYxu(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x2ae8,n=_0x521d();;)try{if(116117==+parseInt(s(273,"5TaY"))+-parseInt(s(289,"DS)j"))/2+parseInt(s(297,"DS)j"))/3+-parseInt(s(283,"@0)J"))/4*(-parseInt(s(286,"boAb"))/5)+-parseInt(s(293,"#Pm4"))/6+-parseInt(s(279,"s)qp"))/7*(-parseInt(s(294,"9BLu"))/8)+parseInt(s(280,"xD$l"))/9*(-parseInt(s(276,"U&@6"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1ae1f7(282,"qP2P")](_0x1ae1f7(281,"ox#R"))!=_0x1ae1f7(295,"sD]["))throw window[_0x1ae1f7(285,"ZRhh")][_0x1ae1f7(275,"dO73")](_0x1ae1f7(287,"UmK6")),Error();document.title="template 标签详解",document.getElementById("article").innerHTML='<div><h3><strong><code>&lt;template&gt;</code> 标签详解</strong></h3>\n<p><code>&lt;template&gt;</code> 是 HTML5 提供的原生标签，用于<strong>定义可复用的 HTML 模板片段</strong>   ，它不会直接渲染到页面上，但可以通过 JavaScript 动态激活并插入到 DOM 中。</p>\n<hr>\n<h2><strong>一、<code>&lt;template&gt;</code> 的核心特性</strong></h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>惰性加载</strong></td>\n<td>模板内容不会在页面加载时渲染，也不会加载其中的图片、脚本等资源。</td>\n</tr>\n<tr>\n<td><strong>隔离性</strong></td>\n<td>模板内的样式和脚本不会影响主文档，直到被激活。</td>\n</tr>\n<tr>\n<td><strong>可复用性</strong></td>\n<td>可以多次克隆并插入到 DOM 的不同位置。</td>\n</tr>\n<tr>\n<td><strong><code>content</code> 属性</strong></td>\n<td><code>template.content</code> 返回一个 <code>DocumentFragment</code>，包含模板的所有子节点。</td>\n</tr>\n<tr>\n<td><strong>必须克隆使用</strong></td>\n<td>必须用 <code>cloneNode(true)</code> 克隆模板内容，否则原模板会被清空。</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>二、基本用法</strong></h2>\n<h3><strong>1. 定义模板</strong></h3>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user-card&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">\n    <span class="hljs-selector-class">.card</span> {\n      <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;\n      <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;\n    }\n  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>Unknown<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bio&quot;</span>&gt;</span>No bio provided.<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n<ul>\n<li>这段代码不会在页面上显示任何内容，也不会加载其中的资源（如 CSS、图片等）。</li>\n</ul>\n<h3><strong>2. 通过 JavaScript 激活模板</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> template = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;user-card&quot;</span>);\n<span class="hljs-keyword">const</span> content = template.<span class="hljs-property">content</span>.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 深拷贝模板内容</span>\n\n<span class="hljs-comment">// 插入到 DOM</span>\n<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(content);\n</code></pre>\n<ul>\n<li><strong><code>cloneNode(true)</code></strong>   是必须的，否则原模板会被清空。</li>\n</ul>\n<hr>\n<h2><strong>三、<code>&lt;template&gt;</code> 的常见用途</strong></h2>\n<h3><strong>1. 动态生成重复内容</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> users = [\n  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">bio</span>: <span class="hljs-string">&quot;Frontend Developer&quot;</span> },\n  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-attr">bio</span>: <span class="hljs-string">&quot;Backend Engineer&quot;</span> },\n];\n\n<span class="hljs-keyword">const</span> template = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;user-card&quot;</span>);\n<span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;user-list&quot;</span>);\n\nusers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> instance = template.<span class="hljs-property">content</span>.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>);\n  instance.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;h2&quot;</span>).<span class="hljs-property">textContent</span> = user.<span class="hljs-property">name</span>;\n  instance.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;p&quot;</span>).<span class="hljs-property">textContent</span> = user.<span class="hljs-property">bio</span>;\n  container.<span class="hljs-title function_">appendChild</span>(instance);\n});\n</code></pre>\n<h3><strong>2. 结合 Web Components 使用</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserCard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">super</span>();\n    <span class="hljs-keyword">const</span> template = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;user-card&quot;</span>);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;open&quot;</span> }).<span class="hljs-title function_">appendChild</span>(\n      template.<span class="hljs-property">content</span>.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>),\n    );\n  }\n}\ncustomElements.<span class="hljs-title function_">define</span>(<span class="hljs-string">&quot;user-card&quot;</span>, <span class="hljs-title class_">UserCard</span>);\n</code></pre>\n<ul>\n<li>这样可以在 HTML 中直接使用 <code>&lt;user-card&gt;</code> 标签，并复用模板结构。</li>\n</ul>\n<h3><strong>3. 延迟加载资源</strong></h3>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;lazy-content&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;large-image.jpg&quot;</span> <span class="hljs-attr">loading</span>=<span class="hljs-string">&quot;lazy&quot;</span> /&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;video.mp4&quot;</span> <span class="hljs-attr">preload</span>=<span class="hljs-string">&quot;none&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n<ul>\n<li>这些资源<strong>不会立即加载</strong>   ，只有在模板被激活时才会下载。</li>\n</ul>\n<h3><strong>4. 服务端渲染 (SSR) 配合</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 服务端返回的 HTML 包含模板</span>\n<span class="hljs-keyword">const</span> serverData = {\n  <span class="hljs-attr">html</span>: <span class="hljs-string">`&lt;div&gt;Server-rendered content&lt;/div&gt;`</span>,\n};\n\n<span class="hljs-comment">// 客户端接收并激活</span>\n<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`&lt;template id=&quot;ssr-content&quot;&gt;<span class="hljs-subst">${serverData.html}</span>&lt;/template&gt;`</span>;\n<span class="hljs-keyword">const</span> template = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;ssr-content&quot;</span>);\n<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(template.<span class="hljs-property">content</span>.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>));\n</code></pre>\n<hr>\n<h2><strong>四、<code>&lt;template&gt;</code> vs 其他方案</strong></h2>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>特点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong><code>&lt;template&gt;</code></strong></td>\n<td>原生支持，惰性加载，可复用</td>\n<td>动态内容、Web Components</td>\n</tr>\n<tr>\n<td><strong>字符串拼接</strong></td>\n<td>灵活但易出错，难以维护</td>\n<td>简单 HTML 片段</td>\n</tr>\n<tr>\n<td><strong><code>innerHTML</code></strong></td>\n<td>直接渲染，无隔离性</td>\n<td>即时插入的非复用内容</td>\n</tr>\n<tr>\n<td><strong>框架模板语法</strong>   （如 Vue、React）</td>\n<td>依赖框架，功能强大</td>\n<td>前端框架项目</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>五、高级用法</strong></h2>\n<h3><strong>1. 动态修改模板</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> template = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;my-template&quot;</span>);\ntemplate.<span class="hljs-property">content</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;h1&quot;</span>).<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;New Title&quot;</span>;\n</code></pre>\n<ul>\n<li>修改模板后，后续克隆的内容会使用新值。</li>\n</ul>\n<h3><strong>2. 嵌套模板</strong></h3>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Nested content<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n<ul>\n<li>可以通过 <code>template.content</code> 访问嵌套的模板。</li>\n</ul>\n<h3><strong>3. 配合 <code>&lt;slot&gt;</code> 实现插槽</strong></h3>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 主文档 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">user-card</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>Custom Name<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">user-card</span>&gt;</span>\n\n<span class="hljs-comment">&lt;!-- 模板 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user-card&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>Default Name<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n<ul>\n<li>使用 <code>&lt;slot&gt;</code> 可以让外部 HTML 动态填充模板内容。</li>\n</ul>\n<hr>\n<h2><strong>六、注意事项</strong></h2>\n<ol>\n<li>\n<p><strong>必须使用 <code>cloneNode(true)</code></strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// ❌ 错误：原模板会被清空</span>\n<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(template.<span class="hljs-property">content</span>);\n\n<span class="hljs-comment">// ✅ 正确：克隆后再插入</span>\n<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(template.<span class="hljs-property">content</span>.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>));\n</code></pre>\n</li>\n<li>\n<p><strong>样式和脚本行为</strong></p>\n<ul>\n<li><code>&lt;style&gt;</code> 和 <code>&lt;script&gt;</code> 只有在模板被激活后才会生效。</li>\n<li>脚本只会执行一次（即使模板被多次克隆）。</li>\n</ul>\n</li>\n<li>\n<p><strong>SEO 影响</strong></p>\n<ul>\n<li>搜索引擎通常不会索引未激活的模板内容。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2><strong>七、总结</strong></h2>\n<ul>\n<li><strong><code>&lt;template&gt;</code> 的核心作用</strong>   ：定义可复用的 HTML 片段，避免手动拼接字符串。</li>\n<li><strong>适用场景</strong>   ：\n<ul>\n<li>动态生成重复内容（如列表、卡片）。</li>\n<li>构建 Web Components（结合 Shadow DOM）。</li>\n<li>延迟加载资源（图片、视频等）。</li>\n</ul>\n</li>\n<li><strong>关键 API</strong>   ：\n<ul>\n<li><code>template.content</code>：获取模板的 <code>DocumentFragment</code>。</li>\n<li><code>cloneNode(true)</code>：克隆模板内容，避免原模板被清空。</li>\n</ul>\n</li>\n</ul>\n<p><code>&lt;template&gt;</code> 是构建现代 Web 应用的重要工具，特别是在组件化开发中，它能大幅提升代码的可维护性和复用性。</p>\n</div>'</script></body></html>