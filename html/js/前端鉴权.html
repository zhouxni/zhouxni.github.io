<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2866(){var t=["WO86xCk4pa","W5hdLfldVComWRVcJ1DtrSoilW","W5WefHZdUdJcR8oakCokWOxdMW","WQbCWRrkWONdGcfYWOVcLXxdVa","EMNdNJ59WO9WWQldPw/dTq","W6ldO8kjWOTmCCkvWRH3","WPvHatnzWP7cQXv2W50","W5OhfrVdSd/dUmondmo2WO3dGvO","W5DkW7zdWQhcLCkUW6RdGCkQW7tdLSkpms/cTmo0EmoEWQrvC8k4lKNdVa","FSo3WOFcLxBcQ8ovW503","W59/w1dcGLJcHG","BLjNWOxdS8onv8oRfW","u0ZcGHRcMLnL","WRldNCoKDCkTWO/dULRdLhyg","imkHW5pcShFcICo+W6K","hhRcTSoBWODAdmkeW4hcI2tdVG","WQ3dGNpdT8k5WQddNgj+dqKc","ouNdI8k/i8kOWPpcGqFdMG","o07dImkWC8oBWQpcVJJdNspdPa","W4FcG8o+E2pcTGHmWRRcLCosmaq","WQDCW7NcHc1UWOi","sCo3WQpcKM15Ea","W4f2lSo9WRSynSkNW5WvhSoyWR0","CCoOW53cVN1AumoXW6KVANTm"];return(_0x2866=function(){return t})()}var _0x14d6da=_0x2869;function _0x2869(l,t){var r=_0x2866();return(_0x2869=function(t,n){var o=r[t-=330];void 0===_0x2869.HErbKd&&(_0x2869.UjkZPB=function(t,n){var o,e=[],l=0,r="";for(t=(t=>{for(var n,o,e="",l="",r=0,s=0;o=t.charAt(s++);~o&&(n=r%4?64*n+o:o,r++%4)&&(e+=String.fromCharCode(255&n>>(-2*r&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var i=0,g=e.length;i<g;i++)l+="%"+("00"+e.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(l)})(t),s=0;s<256;s++)e[s]=s;for(s=0;s<256;s++)l=(l+e[s]+n.charCodeAt(s%n.length))%256,o=e[s],e[s]=e[l],e[l]=o;for(var s=0,l=0,i=0;i<t.length;i++)o=e[s=(s+1)%256],e[s]=e[l=(l+e[s])%256],e[l]=o,r+=String.fromCharCode(t.charCodeAt(i)^e[(e[s]+e[l])%256]);return r},l=arguments,_0x2869.HErbKd=!0);var t=t+r[0],e=l[t];return e?o=e:(void 0===_0x2869.aDQfHq&&(_0x2869.aDQfHq=!0),o=_0x2869.UjkZPB(o,n),l[t]=o),o})(l,t)}if((()=>{for(var t=_0x2869,n=_0x2866();;)try{if(696035==-parseInt(t(344,"W3)6"))+-parseInt(t(335,"uDEH"))/2+parseInt(t(336,"8lJg"))/3+parseInt(t(348,"7]Lx"))/4+parseInt(t(333,"^zgg"))/5+-parseInt(t(330,"]!yg"))/6*(parseInt(t(351,"7]Lx"))/7)+-parseInt(t(347,"fTt)"))/8*(parseInt(t(346,"tD8J"))/9))break;n.push(n.shift())}catch(t){n.push(n.shift())}})(),localStorage[_0x14d6da(338,"peBk")](_0x14d6da(352,"irrd"))!=_0x14d6da(341,"sqHl"))throw window[_0x14d6da(331,"J(Dm")][_0x14d6da(353,"3m#e")](_0x14d6da(349,"B)ub")),Error();document.title="前端鉴权",document.getElementById("article").innerHTML='<div><p>好的，前端鉴权是一个非常重要的主题，它决定了用户能访问什么资源以及能执行什么操作。以下是前端鉴权的主流方式，从经典到现代排列，并附有详细解释和最佳实践建议。</p>\n<hr>\n<h3><strong>前端鉴权主要方式</strong></h3>\n<p>前端鉴权方式主要分为以下几种，它们常常结合使用，构成完整的身份认证与授权体系：</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">方式</th>\n<th style="text-align:left">描述</th>\n<th style="text-align:left">优点</th>\n<th style="text-align:left">缺点</th>\n<th style="text-align:left">适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>1. Cookie-Based Auth</strong></td>\n<td style="text-align:left">依靠 HTTP Cookie 在客户端自动存储和发送会话凭证</td>\n<td style="text-align:left">简单通用，浏览器自动管理</td>\n<td style="text-align:left">有CSRF风险，跨域问题</td>\n<td style="text-align:left">传统Web应用，SSO</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>2. Token-Based Auth</strong></td>\n<td style="text-align:left">使用自包含的Token（如JWT）作为凭证</td>\n<td style="text-align:left">无状态，扩展性好，适合跨域</td>\n<td style="text-align:left">Token需妥善存储，无法轻易失效</td>\n<td style="text-align:left">现代Web应用，移动API</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>3. Session-Based Auth</strong></td>\n<td style="text-align:left">在服务器存储会话状态，客户端只存Session ID</td>\n<td style="text-align:left">服务端可严格控制会话</td>\n<td style="text-align:left">服务器有状态，难以水平扩展</td>\n<td style="text-align:left">传统服务器渲染应用</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>4. OAuth 2.0 / OIDC</strong></td>\n<td style="text-align:left">行业标准的授权/认证框架</td>\n<td style="text-align:left">安全、标准、支持第三方登录</td>\n<td style="text-align:left">实现复杂</td>\n<td style="text-align:left">第三方登录（如微信登录）、授权第三方应用访问资源</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>5. SSO (Single Sign-On)</strong></td>\n<td style="text-align:left">单点登录，一套凭证登录多个系统</td>\n<td style="text-align:left">用户体验好，管理方便</td>\n<td style="text-align:left">架构复杂</td>\n<td style="text-align:left">企业内部系统，生态产品线</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>一、Cookie-Based Authentication（基于Cookie的认证）</strong></h3>\n<p>这是最传统的方式，通常与 <strong>Session</strong>   机制结合使用。</p>\n<ol>\n<li>\n<p><strong>流程：</strong></p>\n<ol>\n<li>用户输入用户名密码登录。</li>\n<li>服务端验证通过后，创建一个 Session 记录，并将 <strong>Session ID</strong>   通过 <code>Set-Cookie</code> 头部种到浏览器。</li>\n<li>浏览器后续对同域名的所有请求都会<strong>自动携带</strong>   此 Cookie。</li>\n<li>服务端通过验证 Cookie 中的 Session ID 来确认用户身份。</li>\n</ol>\n</li>\n<li>\n<p><strong>关键特点：</strong></p>\n<ul>\n<li><strong>HTTP-Only Cookie</strong>   ：防止 XSS 攻击读取 Cookie。</li>\n<li><strong>Secure Cookie</strong>   ：仅在 HTTPS 下传输，防止窃听。</li>\n<li><strong>SameSite Attribute</strong>   ：设置 <code>Strict</code> 或 <code>Lax</code>，有效防御 CSRF 攻击。</li>\n</ul>\n</li>\n<li>\n<p><strong>安全隐患与防护：</strong></p>\n<ul>\n<li><strong>CSRF（跨站请求伪造）</strong>   ：攻击者诱使用户在已登录的状态下访问恶意网站，该网站伪造一个请求到目标网站。\n<ul>\n<li><strong>防御</strong>   ：使用 <code>SameSite Cookie</code>、CSRF Token（如 Anti-Forgery Token）。</li>\n</ul>\n</li>\n<li><strong>XSS（跨站脚本攻击）</strong>   ：攻击者注入恶意脚本，窃取 Cookie。\n<ul>\n<li><strong>防御</strong>   ：设置 <code>HttpOnly Cookie</code>，对用户输入进行转义和过滤。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>二、Token-Based Authentication（基于Token的认证）</strong></h3>\n<p>这是目前<strong>最主流</strong>   的API认证方式，最常见的是 <strong>JWT（JSON Web Token）</strong>   。</p>\n<ol>\n<li>\n<p><strong>流程（以JWT为例）：</strong></p>\n<ol>\n<li>用户登录，服务端验证凭据。</li>\n<li>服务端生成一个<strong>JWT</strong>   （包含用户ID、角色、过期时间等信息的签名令牌），返回给前端。</li>\n<li>前端将 JWT <strong>存储起来</strong>   （通常放在 <code>localStorage</code>, <code>sessionStorage</code> 或 <strong>内存</strong>   中）。</li>\n<li>前端在后续请求的 <strong>Authorization Header</strong>   中携带 JWT（格式：<code>Bearer &lt;token&gt;</code>）。</li>\n<li>服务端验证 JWT 的签名和有效性，并解析出用户信息。</li>\n</ol>\n</li>\n<li>\n<p><strong>JWT 结构（三段式，由 <code>.</code> 分隔）：</strong></p>\n<ul>\n<li><strong>Header</strong>   ：说明令牌类型和签名算法（如 <code>{&quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;}</code>）。</li>\n<li><strong>Payload</strong>   ：存放实际传递的数据（如 <code>{&quot;sub&quot;: &quot;123&quot;, &quot;name&quot;: &quot;John&quot;, &quot;role&quot;: &quot;admin&quot;}</code>）。</li>\n<li><strong>Signature</strong>   ：对前两部分的签名，用于防篡改。</li>\n</ul>\n</li>\n<li>\n<p><strong>Token存储方案对比：</strong></p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">存储位置</th>\n<th style="text-align:left">优点</th>\n<th style="text-align:left">缺点</th>\n<th style="text-align:left">推荐度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>localStorage</strong></td>\n<td style="text-align:left">持久化，不随会话结束消失</td>\n<td style="text-align:left">易受XSS攻击</td>\n<td style="text-align:left">⭐⭐</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>sessionStorage</strong></td>\n<td style="text-align:left">会话级，关闭标签页即失效</td>\n<td style="text-align:left">易受XSS攻击</td>\n<td style="text-align:left">⭐⭐</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>Cookie (HttpOnly)</strong></td>\n<td style="text-align:left">防XSS读取</td>\n<td style="text-align:left">需防范CSRF，操作不如前端方便</td>\n<td style="text-align:left">⭐⭐⭐⭐</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>内存 (JS变量)</strong></td>\n<td style="text-align:left">最安全，几乎免疫XSS和CSRF</td>\n<td style="text-align:left">刷新页面即丢失，需重新登录</td>\n<td style="text-align:left">⭐⭐⭐</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p><strong>Token的失效问题：</strong></p>\n<ul>\n<li>JWT 一旦签发，在过期前一直有效。服务端无法直接“废除”某个JWT。</li>\n<li><strong>解决方案</strong>   ：\n<ul>\n<li>设置较短的过期时间（<code>exp</code>）。</li>\n<li>使用<strong>黑名单/白名单</strong>   机制（牺牲部分无状态特性）。</li>\n<li>采用 <strong>Refresh Token</strong>   机制（见下文）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>三、Refresh Token 机制</strong></h3>\n<p>为了解决 JWT 失效问题，引入双 Token 机制。</p>\n<ol>\n<li>\n<p><strong>流程：</strong></p>\n<ol>\n<li>登录后，服务端返回两个 Token：\n<ul>\n<li><strong>Access Token (AT)</strong>   ：短期有效（如 2小时），用于访问API。</li>\n<li><strong>Refresh Token (RT)</strong>   ：长期有效（如 7天、30天），存储于服务端（如数据库），用于换取新的 AT。</li>\n</ul>\n</li>\n<li>当 AT 过期后，前端用 RT 请求一个特定的接口（如 <code>/auth/refresh</code>）换取新的 AT 和 RT。</li>\n<li>如果 RT 也过期或被服务端列入黑名单，则用户需要重新登录。</li>\n</ol>\n</li>\n<li>\n<p><strong>最佳实践：</strong></p>\n<ul>\n<li>RT 应存储于 <code>HttpOnly Cookie</code> 中，比存储在 localStorage 更安全。</li>\n<li>AT 可以存储在内存中，最大化安全性。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>四、OAuth 2.0 与 OpenID Connect (OIDC)</strong></h3>\n<p>这不是具体的实现，而是一套<strong>行业标准协议</strong>   。</p>\n<ul>\n<li><strong>OAuth 2.0</strong>   ：一个<strong>授权</strong>   （Authorization）框架。解决的是“<strong>让第三方应用在用户授权下，访问用户在某个服务中的特定资源</strong>   ”的问题。\n<ul>\n<li><strong>场景</strong>   ：你用微信登录某个小程序、授权某网站访问你的GitHub仓库。</li>\n</ul>\n</li>\n<li><strong>OpenID Connect (OIDC)</strong>   ：建立在 OAuth 2.0 之上的一个<strong>认证</strong>   （Authentication）协议。它扩展了 OAuth，提供了用户身份信息（ID Token，通常是一个JWT）。\n<ul>\n<li><strong>场景</strong>   ：“使用Google/微软/微信登录”。</li>\n</ul>\n</li>\n</ul>\n<p>前端在 OAuth 流程中通常是 <strong>Authorization Code Flow with PKCE</strong>   的参与者，负责引导用户跳转到认证服务器，并在回调后通过授权码换取 Token。</p>\n<hr>\n<h3><strong>五、单点登录 (SSO)</strong></h3>\n<p>SSO 是一种用户体验，底层实现通常基于上述的 Cookie 或 OAuth/OIDC 协议。\n核心思想是：用户只需在<strong>一个系统（认证中心）</strong>   登录一次，即可获得访问所有其他<strong>信任系统</strong>   的权限。</p>\n<hr>\n<h3><strong>总结与最佳实践建议</strong></h3>\n<ol>\n<li>\n<p><strong>现代前后端分离架构首选</strong>   ：<strong>JWT + Refresh Token</strong>   机制。</p>\n<ul>\n<li>Access Token 存内存，Refresh Token 存 <code>HttpOnly Cookie</code>。</li>\n<li>设置合理的 AT 过期时间。</li>\n</ul>\n</li>\n<li>\n<p><strong>安全重中之重</strong>   ：</p>\n<ul>\n<li><strong>必须使用 HTTPS</strong>   。</li>\n<li>防御 <strong>XSS</strong>   ：对用户输入做处理，避免使用 <code>innerHTML</code>，设置 <code>Content-Security-Policy</code> 头部。</li>\n<li>防御 <strong>CSRF</strong>   ：Token-Based 方案天然免疫（因为Cookie里没有Token），若用Cookie方案，务必设置 <code>SameSite</code> 和 CSRF Token。</li>\n</ul>\n</li>\n<li>\n<p><strong>权限控制（Authorization）</strong>   ：</p>\n<ul>\n<li>认证（Authentication）解决“你是谁”，授权（Authorization）解决“你能做什么”。</li>\n<li>前端可进行<strong>粗粒度权限</strong>   控制（如根据角色/权限码显示或隐藏按钮、路由），但<strong>后端必须进行最终的细粒度权限校验</strong>   （每次API调用都检查）。</li>\n</ul>\n</li>\n<li>\n<p><strong>选择合适的存储</strong>   ：</p>\n<ul>\n<li>追求极致安全且不介意刷新页面需重新登录 → <strong>内存</strong>   。</li>\n<li>平衡安全与用户体验 → <strong>Refresh Token 存 HttpOnly Cookie，Access Token 存内存</strong>   。</li>\n</ul>\n</li>\n</ol>\n<p>对于全新的项目，推荐采用 <strong>OIDC + PKCE</strong>   作为认证层，内部使用 <strong>JWT</strong>   作为 API 访问凭证，这是目前业界公认的安全且标准的最佳实践。</p>\n</div>'</script></body></html>