<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2de704=_0x1ca9;function _0x3e29(){var s=["WR4IaSoWpCoVACkd","W4fLDfbZySkLDYxcQ8oIW7/dP8kyWP7dUmkEdsDsoCkkWOxcJvpdQa","WOJcG8oMjJhdGCk0W4lcMmkgqXNcTq","lLq0yCoTWRKyWOznW5C","tmo5msnGv8oVaq","W7ego8otW4/cLb0rW4aoWOrKW50","kmomzX/dT3/cVW","WQK4W5ZdR8kYWOKqWO/dRW","nHNdKdXcW6xcGIBcUq","mxBcPeyzqmksDCk5f8ocWPG","d8oTW7NcISkpWOzIWR1qe8oIWR0x","W7LZWOWWW5FdVL3dP8o8WPtdTLBcSq","FSoAEsddOvFcVa","xwpdNqKNW7xcI8kEe1yvkW","WR8Lx8ktD8kXbmkoWPddI8oyWQVdKq","u8oABwLPW5rlwHLnBSkZBq","i8ogCdFdT3pcVrC","ox57WQxcSmkuwG","rCoYWR7dRSoUjSkKkCodWPGcW7pdKa","WRHzi8kdW4FcVXNcN8oYWOS","W4fhW5v5i8kHsa","WRPMpCotlmoQzq","WRfBFSkkWPJdHeO","W7aDAmoaW5i","C1zjWRBcTdqokCoQ","WP7cO8kfW4rgW6lcUKhdVKuZwaq","aSoMhGNcV8o/n0NcVGBcOSovWPO","qflcLsVcV8oXW7SkumkIWRnmW7y"];return(_0x3e29=function(){return s})()}function _0x1ca9(e,s){var p=_0x3e29();return(_0x1ca9=function(s,a){var n=p[s-=492];void 0===_0x1ca9.edqCVa&&(_0x1ca9.cibkoZ=function(s,a){var n,l=[],e=0,p="";for(s=(s=>{for(var a,n,l="",e="",p=0,t=0;n=s.charAt(t++);~n&&(a=p%4?64*a+n:n,p++%4)&&(l+=String.fromCharCode(255&a>>(-2*p&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,r=l.length;c<r;c++)e+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)e=(e+l[t]+a.charCodeAt(t%a.length))%256,n=l[t],l[t]=l[e],l[e]=n;for(var t=0,e=0,c=0;c<s.length;c++)n=l[t=(t+1)%256],l[t]=l[e=(e+l[t])%256],l[e]=n,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[t]+l[e])%256]);return p},e=arguments,_0x1ca9.edqCVa=!0);var s=s+p[0],l=e[s];return l?n=l:(void 0===_0x1ca9.wZeARz&&(_0x1ca9.wZeARz=!0),n=_0x1ca9.cibkoZ(n,a),e[s]=n),n})(e,s)}if((()=>{for(var s=_0x1ca9,a=_0x3e29();;)try{if(588912==+parseInt(s(515,"lN(4"))*(parseInt(s(500,"F&Yp"))/2)+parseInt(s(510,"KYF&"))/3*(-parseInt(s(506,"A87c"))/4)+parseInt(s(501,"zK@&"))/5*(-parseInt(s(496,"IGli"))/6)+parseInt(s(502,"O]ry"))/7+-parseInt(s(508,"@Yc2"))/8+parseInt(s(507,"WqfX"))/9*(parseInt(s(512,"6S#p"))/10)+parseInt(s(517,"IGli"))/11)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x2de704(509,"lN(4")](_0x2de704(499,"k&yR"))!=_0x2de704(498,"7mf&"))throw window[_0x2de704(519,"lN(4")][_0x2de704(497,"@Yc2")](_0x2de704(504,"P4KD")),Error();document.title="Vue 中 Computed 属性的 Dep 和 Watcher 机制详解",document.getElementById("article").innerHTML='<div><p>是的，Vue 中的每个 computed 属性<strong>确实会拥有自己的 Dep 和 Watcher</strong>  ，这是 Vue 响应式系统的核心设计。下面我将详细解析其工作原理：</p>\n<h2>一、Computed 属性的双重身份</h2>\n<h3>1. 作为观察者（Watcher）</h3>\n<ul>\n<li>每个 computed 属性都会创建一个 <strong>computed watcher</strong></li>\n<li>这个 watcher 负责：\n<ul>\n<li>追踪依赖的响应式数据变化</li>\n<li>管理计算结果的缓存</li>\n<li>触发依赖更新通知</li>\n</ul>\n</li>\n</ul>\n<h3>2. 作为被观察者（Dep）</h3>\n<ul>\n<li>每个 computed 属性也会创建一个 <strong>Dep 实例</strong></li>\n<li>这个 Dep 负责：\n<ul>\n<li>收集依赖该 computed 属性的其他 watcher（通常是渲染 watcher）</li>\n<li>当 computed 值变化时通知这些订阅者</li>\n</ul>\n</li>\n</ul>\n<h2>二、完整生命周期流程</h2>\n<h3>1. 初始化阶段</h3>\n<pre><code class="language-javascript"><span class="hljs-attr">computed</span>: {\n  <span class="hljs-title function_">fullName</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span>\n  }\n}\n</code></pre>\n<ol>\n<li>Vue 为 <code>fullName</code> 创建 computed watcher（<code>computedWatcher</code>）</li>\n<li>为该 watcher 创建专属的 Dep 实例（<code>computedWatcher.dep</code>）</li>\n<li>设置 <code>lazy: true</code> 标志表示延迟计算</li>\n</ol>\n<h3>2. 依赖收集阶段（首次访问）</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 模板中使用 {{ fullName }}</span>\n</code></pre>\n<ol>\n<li>渲染 watcher 执行渲染函数，访问 <code>fullName</code></li>\n<li><code>computedWatcher.evaluate()</code> 被调用：<pre><code class="language-javascript"><span class="hljs-title function_">evaluate</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>() <span class="hljs-comment">// 触发计算函数</span>\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-literal">false</span>      <span class="hljs-comment">// 标记为已计算</span>\n}\n</code></pre>\n</li>\n<li>计算过程中访问 <code>firstName</code> 和 <code>lastName</code>：\n<ul>\n<li>它们的 Dep 会收集 <code>computedWatcher</code> 作为依赖</li>\n</ul>\n</li>\n<li><code>fullName</code> 的 Dep 会收集当前的渲染 watcher</li>\n</ol>\n<h3>3. 更新阶段（依赖数据变化）</h3>\n<pre><code class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = <span class="hljs-string">&#x27;张&#x27;</span> <span class="hljs-comment">// 修改依赖数据</span>\n</code></pre>\n<ol>\n<li><code>firstName</code> 的 Dep 通知 <code>computedWatcher</code></li>\n<li><code>computedWatcher.update()</code>：<pre><code class="language-javascript"><span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">// 标记需要重新计算</span>\n  }\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">dep</span>.<span class="hljs-title function_">notify</span>()  <span class="hljs-comment">// 通知依赖 fullName 的 watchers</span>\n}\n</code></pre>\n</li>\n<li>渲染 watcher 被通知，触发重新渲染</li>\n</ol>\n<h2>三、源码关键实现（Vue 2.x）</h2>\n<h3>1. Computed Watcher 创建</h3>\n<p><code>src/core/instance/state.js</code></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">initComputed</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> watchers = (vm.<span class="hljs-property">_computedWatchers</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>))\n  \n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> computed) {\n    <span class="hljs-keyword">const</span> userDef = computed[key]\n    watchers[key] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(\n      vm,\n      getter, <span class="hljs-comment">// computed 函数</span>\n      noop,   <span class="hljs-comment">// 回调</span>\n      { <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span> } <span class="hljs-comment">// 特殊标记</span>\n    )\n  }\n}\n</code></pre>\n<h3>2. Computed 属性定义</h3>\n<p><code>src/core/instance/state.js</code></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineComputed</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, key, {\n    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-keyword">const</span> watcher = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_computedWatchers</span>[key]\n      <span class="hljs-keyword">if</span> (watcher.<span class="hljs-property">dirty</span>) {\n        watcher.<span class="hljs-title function_">evaluate</span>() <span class="hljs-comment">// 重新计算</span>\n      }\n      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) {\n        watcher.<span class="hljs-title function_">depend</span>()   <span class="hljs-comment">// 收集当前 watcher</span>\n      }\n      <span class="hljs-keyword">return</span> watcher.<span class="hljs-property">value</span>\n    }\n  })\n}\n</code></pre>\n<h2>四、与普通 Watcher 的区别</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Computed Watcher</th>\n<th>普通 Watcher</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>lazy</strong>   标志</td>\n<td>有 (<code>true</code>)</td>\n<td>无</td>\n</tr>\n<tr>\n<td><strong>缓存机制</strong></td>\n<td>有 (<code>dirty</code> 标志)</td>\n<td>无</td>\n</tr>\n<tr>\n<td><strong>依赖关系</strong></td>\n<td>既是观察者也是被观察者</td>\n<td>只是观察者</td>\n</tr>\n<tr>\n<td><strong>触发时机</strong></td>\n<td>惰性计算</td>\n<td>立即执行</td>\n</tr>\n</tbody>\n</table>\n<h2>五、实际应用示例</h2>\n<h3>1. 条件性依赖</h3>\n<pre><code class="language-javascript"><span class="hljs-attr">computed</span>: {\n  <span class="hljs-title function_">displayName</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">showNickname</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">nickname</span> : <span class="hljs-variable language_">this</span>.<span class="hljs-property">realName</span>\n  }\n}\n</code></pre>\n<ul>\n<li>根据 <code>showNickname</code> 的值，动态切换依赖</li>\n<li>Vue 会自动管理这种动态依赖关系</li>\n</ul>\n<h3>2. 多级计算</h3>\n<pre><code class="language-javascript"><span class="hljs-attr">computed</span>: {\n  <span class="hljs-title function_">totalPrice</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, item</span>) =&gt;</span> sum + item.<span class="hljs-property">price</span>, <span class="hljs-number">0</span>)\n  },\n  <span class="hljs-title function_">formattedTotal</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">`¥<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.totalPrice.toFixed(<span class="hljs-number">2</span>)}</span>`</span>\n  }\n}\n</code></pre>\n<ul>\n<li><code>formattedTotal</code> 的 watcher 会依赖 <code>totalPrice</code> 的 watcher</li>\n<li>形成 watcher 依赖链</li>\n</ul>\n<h2>六、性能优化要点</h2>\n<ol>\n<li><strong>避免在 computed 中执行高开销操作</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 不推荐</span>\n<span class="hljs-attr">computed</span>: {\n  <span class="hljs-title function_">heavyCompute</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-comment">// 复杂计算或大循环</span>\n  }\n}\n</code></pre>\n</li>\n<li><strong>合理使用缓存</strong>  ：\n<ul>\n<li>只有依赖变化时才会重新计算</li>\n<li>多次访问直接返回缓存值</li>\n</ul>\n</li>\n<li><strong>避免副作用</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 错误用法（computed 应该是纯函数）</span>\n<span class="hljs-attr">computed</span>: {\n  <span class="hljs-title function_">badExample</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sideEffect</span>++ <span class="hljs-comment">// 绝对不要这样做</span>\n    <span class="hljs-keyword">return</span> ...\n  }\n}\n</code></pre>\n</li>\n</ol>\n<p>理解 computed 属性的 Dep 和 Watcher 机制，可以帮助开发者：</p>\n<ul>\n<li>更好地组织响应式数据</li>\n<li>避免不必要的重新计算</li>\n<li>调试复杂的依赖关系问题</li>\n<li>编写更高效的 Vue 应用</li>\n</ul>\n</div>'</script></body></html>