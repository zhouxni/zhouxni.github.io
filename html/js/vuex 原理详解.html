<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4c20df=_0x2a7c;if((()=>{for(var s=_0x2a7c,n=_0x10a9();;)try{if(800913==-parseInt(s(265,"OJPM"))+parseInt(s(284,"tZvT"))/2+parseInt(s(283,"%BTT"))/3*(-parseInt(s(281,"Dwdx"))/4)+-parseInt(s(271,"Nuki"))/5*(parseInt(s(278,"#u3G"))/6)+parseInt(s(276,"z#X@"))/7*(parseInt(s(266,"#HWQ"))/8)+parseInt(s(289,"6j&b"))/9+parseInt(s(288,"#u3G"))/10*(parseInt(s(287,"015%"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x4c20df(270,"#HWQ")](_0x4c20df(275,"CozC"))!=_0x4c20df(285,"%BTT"))throw window[_0x4c20df(272,"ftu)")][_0x4c20df(280,"015%")](_0x4c20df(292,"Dwdx")),Error();function _0x2a7c(p,s){var l=_0x10a9();return(_0x2a7c=function(s,n){var a=l[s-=265];void 0===_0x2a7c.lqFZhD&&(_0x2a7c.cuxipo=function(s,n){var a,t=[],p=0,l="";for(s=(s=>{for(var n,a,t="",p="",l=0,e=0;a=s.charAt(e++);~a&&(n=l%4?64*n+a:a,l++%4)&&(t+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=t.length;c<o;c++)p+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)p=(p+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[p],t[p]=a;for(var e=0,p=0,c=0;c<s.length;c++)a=t[e=(e+1)%256],t[e]=t[p=(p+t[e])%256],t[p]=a,l+=String.fromCharCode(s.charCodeAt(c)^t[(t[e]+t[p])%256]);return l},p=arguments,_0x2a7c.lqFZhD=!0);var s=s+l[0],t=p[s];return t?a=t:(void 0===_0x2a7c.GAzVVK&&(_0x2a7c.GAzVVK=!0),a=_0x2a7c.cuxipo(a,n),p[s]=a),a})(p,s)}function _0x10a9(){var s=["sM7cICooWRChWPa","WQWLW7dcNrNcNXvvWPddSbXq","iSoCqCkRWQ0tr2tcHCknWQje","mYHfDIhdHLjXW6NdG8oeDCkA","yCkDa8oPW6C","ntNdOSkUe8okW64","WQ0qvCkftCk5W6PHWR0SoG","sqPSW7FdVSoaASkNlbi","FSkYWO/cSCk7DfiVB8oBWQ4I","obtdHCo4W6P8W6xdJIffWRxdOG","kmoLWQSpWQyLW5RdUSoiESk7W7y","gMJcLCo1WRbXW7JdVbWHW4NdRxq1AM8hWQtdO8o3WPTCrCkwWQXp","mbldGCo9W6z6WRtdHI1yWPBdJSkG","WQKRWQKcW6q0W6xcKa","ASonW5qDW6OpWQpdUWqCiG","xSksWOj3W4JcU8kKBNvrWOZcLcK","AY/cQSo0W6BdUCoYW6vKomkphG","W7P+WP4iW6usW7a","ysZcQCo2W63dSmouW7vVmCkDna","wCkzWPZcGwK5WPtdSG","WQKRW5TXW7qdW5dcT8oNWOa","pmk7WPfFWR07W5v+bqLdhSoi","tmoQW4ykW7DXWQzCeq","pfZcSeBcOmo2W6ddLeWZkeu","nCoOW7D7xGbPha","taGAWO3dO8odq8k/","WQpcQ0pcKa9JW6Pl","W6The8oFfCkCW5S"];return(_0x10a9=function(){return s})()}document.title="vuex 原理详解",document.getElementById("article").innerHTML='<div><p>Vuex 是 Vue.js 的状态管理库，采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。它的核心设计借鉴了 Flux 和 Redux，但针对 Vue 进行了优化。</p>\n<hr>\n<p><strong>1. Vuex 核心概念</strong></p>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>State</td>\n<td>单一状态树，存储应用的所有状态（响应式数据）</td>\n</tr>\n<tr>\n<td>Getter</td>\n<td>从 State 派生的计算属性（类似 Vue 的 <code>computed</code>）</td>\n</tr>\n<tr>\n<td>Mutation</td>\n<td>同步修改 State 的唯一方式（通过 <code>commit</code> 触发）</td>\n</tr>\n<tr>\n<td>Action</td>\n<td>异步操作，可包含任意异步逻辑，最终通过 <code>commit</code> 提交 Mutation</td>\n</tr>\n<tr>\n<td>Module</td>\n<td>将 Store 分割成模块，每个模块拥有自己的 State、Mutation、Action 等</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>2. Vuex 工作流程</strong></p>\n<pre><code class="language-mermaid">sequenceDiagram\n    participant Component\n    participant Actions\n    participant Mutations\n    participant State\n\n    Component-&gt;&gt;Actions: dispatch(\'asyncAction\')\n    Actions-&gt;&gt;Mutations: commit(\'syncMutation\')\n    Mutations-&gt;&gt;State: 修改 State\n    State--&gt;&gt;Component: 自动更新视图\n</code></pre>\n<ol>\n<li>组件通过 <code>dispatch</code> 调用 Action</li>\n<li>Action 执行异步操作后，通过 <code>commit</code> 提交 Mutation</li>\n<li>Mutation 同步修改 State</li>\n<li>State 变化后，自动触发视图更新</li>\n</ol>\n<hr>\n<p><strong>3. Vuex 源码核心实现</strong><br>\n<strong>(1) Store 构造函数</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options = {}</span>) {\n    <span class="hljs-comment">// 1. 初始化 State（使其响应式）</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_vm</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({\n      <span class="hljs-attr">data</span>: { <span class="hljs-attr">state</span>: options.<span class="hljs-property">state</span> }\n    });\n\n    <span class="hljs-comment">// 2. 注册 Mutations 和 Actions</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_mutations</span> = options.<span class="hljs-property">mutations</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_actions</span> = options.<span class="hljs-property">actions</span>;\n\n    <span class="hljs-comment">// 3. 绑定 dispatch 和 commit 的 this 指向</span>\n    <span class="hljs-keyword">const</span> store = <span class="hljs-variable language_">this</span>;\n    <span class="hljs-keyword">const</span> { dispatch, commit } = <span class="hljs-variable language_">this</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dispatch</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">boundDispatch</span>(<span class="hljs-params">...args</span>) {\n      <span class="hljs-keyword">return</span> dispatch.<span class="hljs-title function_">call</span>(store, ...args);\n    };\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">commit</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">boundCommit</span>(<span class="hljs-params">...args</span>) {\n      <span class="hljs-keyword">return</span> commit.<span class="hljs-title function_">call</span>(store, ...args);\n    };\n  }\n\n  <span class="hljs-keyword">get</span> <span class="hljs-title function_">state</span>() {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_vm</span>.<span class="hljs-property">_data</span>.<span class="hljs-property">state</span>;\n  }\n\n  <span class="hljs-title function_">commit</span>(<span class="hljs-params">type, payload</span>) {\n    <span class="hljs-keyword">const</span> mutation = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_mutations</span>[type];\n    <span class="hljs-title function_">mutation</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>, payload);\n  }\n\n  <span class="hljs-title function_">dispatch</span>(<span class="hljs-params">type, payload</span>) {\n    <span class="hljs-keyword">const</span> action = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_actions</span>[type];\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">action</span>(<span class="hljs-variable language_">this</span>, payload);\n  }\n}\n</code></pre>\n<p>关键点：</p>\n<ul>\n<li>\n<p>使用 Vue 实例的 <code>data</code> 使 State 响应式</p>\n</li>\n<li>\n<p><code>commit</code> 和 <code>dispatch</code> 通过闭包绑定 <code>this</code></p>\n</li>\n</ul>\n<hr>\n<p><strong>(2) 响应式 State 实现</strong><br>\nVuex 利用 Vue 的响应式系统，当 State 变化时，依赖它的组件自动更新：</p>\n<pre><code class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">_vm</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({\n  <span class="hljs-attr">data</span>: {\n    <span class="hljs-attr">state</span>: options.<span class="hljs-property">state</span>  <span class="hljs-comment">// State 变为响应式</span>\n  }\n});\n</code></pre>\n<hr>\n<p><strong>(3) 插件机制（Plugin）</strong><br>\nVuex 允许通过插件扩展功能（如日志、持久化）：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 示例：日志插件</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">logger</span>(<span class="hljs-params">store</span>) {\n  store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mutation.<span class="hljs-property">type</span>, mutation.<span class="hljs-property">payload</span>);\n  });\n}\n\n<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>({\n  <span class="hljs-attr">plugins</span>: [logger]\n});\n</code></pre>\n<hr>\n<p><strong>4. Vuex 与 Redux 的对比</strong></p>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>Vuex</th>\n<th>Redux</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>响应式</td>\n<td>基于 Vue 的响应式系统</td>\n<td>需手动监听变化（如 <code>useSelector</code>）</td>\n</tr>\n<tr>\n<td>异步处理</td>\n<td>原生支持 Action（异步）</td>\n<td>需中间件（如 <code>redux-thunk</code>）</td>\n</tr>\n<tr>\n<td>修改状态</td>\n<td>必须通过 Mutation（同步）</td>\n<td>直接调用 Reducer</td>\n</tr>\n<tr>\n<td>开发体验</td>\n<td>与 Vue 深度集成</td>\n<td>通用 JavaScript 库</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>5. Vuex 最佳实践</strong><br>\n<strong>(1) 模块化组织</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> moduleA = {\n  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> ({ ... }),\n  <span class="hljs-attr">mutations</span>: { ... },\n  <span class="hljs-attr">actions</span>: { ... }\n};\n\n<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>({\n  <span class="hljs-attr">modules</span>: {\n    <span class="hljs-attr">a</span>: moduleA\n  }\n});\n</code></pre>\n<p><strong>(2) 使用 Map 辅助函数</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { mapState, mapActions } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">computed</span>: {\n    ...<span class="hljs-title function_">mapState</span>([<span class="hljs-string">&#x27;count&#x27;</span>])\n  },\n  <span class="hljs-attr">methods</span>: {\n    ...<span class="hljs-title function_">mapActions</span>([<span class="hljs-string">&#x27;increment&#x27;</span>])\n  }\n};\n</code></pre>\n<p><strong>(3) 严格模式</strong><br>\n检测是否直接修改 State（仅开发环境）：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>({\n  <span class="hljs-attr">strict</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>\n});\n</code></pre>\n<hr>\n<p><strong>6. Vuex 的局限性</strong></p>\n<ol>\n<li>模板代码多：即使是简单场景也需要定义 Mutation/Action。</li>\n<li>TypeScript 支持弱：与 Redux 相比类型推断不够友好。</li>\n<li>Pinia 的竞争：Vue 官方推荐的新状态管理库（更轻量、组合式 API）。</li>\n</ol>\n<hr>\n<p><strong>总结</strong></p>\n<ul>\n<li>\n<p>核心机制：通过 Vue 的响应式系统实现状态管理，严格规范修改流程（Mutation → Action）。</p>\n</li>\n<li>\n<p>适用场景：中大型 Vue 项目，需要集中式状态管理时。</p>\n</li>\n<li>\n<p>未来趋势：新项目可考虑 Pinia（Vuex 的下一代替代品）。</p>\n</li>\n</ul>\n</div>'</script></body></html>