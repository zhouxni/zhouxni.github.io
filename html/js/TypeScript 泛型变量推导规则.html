<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3cfa(){var s=["kKBdQJmHW4FcIComWQH3WOuN","WQvWyvu6vCo2WOBdV2FcRSkF","a8k7WQZcO8k7z1ddHvzzWPlcOa","WRBcISoREa3cQg5QW6CCW6eIxbBdVWNcOeJcVmkTFmkvWPhcImkKAG","tCkYW7XyW4VdKCk7","xgy6WQpcK3Cg","WQnvlSkSW6lcVCoyWPK","W6/dJ8kQmeVcPheuW5q9W58LBa","umkGfqVdGcFcGxzxWR/cMmkh","i01qW4JcPK7cQq","WRNcGSkFW5NdImo2WQtdMW","WQCWWPKvWPzgg2e","WQuXgmkOW4VcOmo4","WPNcTSkNW7tcHW","W5nlWPa2lsi+W5f6W4DQW4u","DCopWP9NWR4xW47cMmoSbmk6WRFcOa","vmogsvZcQ3FcRq","W6tdN8oeWOJcHCkRWRVdRqVdOq4+","DmowWPVcICoReXmo","W4WKvby4eCkflG","DmosW5RdSCk+tqiat11Dgq","d8oLDKtcHCo6qSkcW6/dGMhcLCkp","W51mWPm3ls0VW6vJW6vtW4S","W6/dImkdWO5NesxdMCkC","W4hdVCk6FttdO8of","WRTEWRVdGxhdM8obWOaHW4bvW7r2","wHO2W6mrWOagW7HglcLx","e8oJWRSLWO/cG8kgmJ88zhG"];return(_0x3cfa=function(){return s})()}function _0x5116(p,s){var t=_0x3cfa();return(_0x5116=function(s,n){var a=t[s-=245];void 0===_0x5116.zrfLKS&&(_0x5116.lKNRLN=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,c=0;a=s.charAt(c++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,r=l.length;e<r;e++)p+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(p)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)p=(p+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[p],l[p]=a;for(var c=0,p=0,e=0;e<s.length;e++)a=l[c=(c+1)%256],l[c]=l[p=(p+l[c])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(e)^l[(l[c]+l[p])%256]);return t},p=arguments,_0x5116.zrfLKS=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x5116.FTWoez&&(_0x5116.FTWoez=!0),a=_0x5116.lKNRLN(a,n),p[s]=a),a})(p,s)}var _0x12989b=_0x5116;if((()=>{for(var s=_0x5116,n=_0x3cfa();;)try{if(362231==+parseInt(s(248,"vS$G"))+parseInt(s(249,"3P7U"))/2*(parseInt(s(251,"3P7U"))/3)+parseInt(s(259,"8Rrq"))/4*(-parseInt(s(268,"BlDV"))/5)+parseInt(s(246,"t**S"))/6*(parseInt(s(271,"YELK"))/7)+-parseInt(s(256,"cGQc"))/8+-parseInt(s(253,"!Fv("))/9+-parseInt(s(261,"^^Sv"))/10*(parseInt(s(270,"cSC9"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x12989b(263,"6nAq")](_0x12989b(254,"VBCj"))!=_0x12989b(272,"*OO6"))throw window[_0x12989b(269,"vS$G")][_0x12989b(264,"v*zv")](_0x12989b(262,"eBLQ")),Error();document.title="TypeScript 泛型变量推导规则",document.getElementById("article").innerHTML='<div><p>TypeScript 的泛型变量推导是一个基于上下文和用法的智能类型系统，以下是其核心推导规则的完整解析：</p>\n<h2>1. 基础推导规则</h2>\n<h3>从左到右参数推断</h3>\n<p>TypeScript 会从左到右根据传入参数的类型推断泛型参数：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T { <span class="hljs-keyword">return</span> arg; }\n<span class="hljs-keyword">const</span> result = <span class="hljs-title function_">identity</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// T 推断为 string</span>\n</code></pre>\n<h3>返回值类型反馈</h3>\n<p>如果部分泛型参数无法通过参数推断，则会尝试通过返回值类型反向推导：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> factory&lt;T&gt;(): T { <span class="hljs-comment">/*...*/</span> }\n<span class="hljs-keyword">const</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span> = <span class="hljs-title function_">factory</span>(); <span class="hljs-comment">// T 推断为 number</span>\n</code></pre>\n<h3>默认类型 (TypeScript 2.3+)</h3>\n<p>泛型参数可以指定默认类型：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> fetch&lt;T = <span class="hljs-built_in">unknown</span>&gt;(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; { <span class="hljs-comment">/*...*/</span> }\n<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api&quot;</span>); <span class="hljs-comment">// T 默认为 unknown</span>\n</code></pre>\n<h2>2. 优先级规则</h2>\n<p>类型推断的优先级从高到低：</p>\n<ol>\n<li><strong>显式指定的泛型参数</strong><pre><code class="language-typescript">identity&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-string">&quot;123&quot;</span>); <span class="hljs-comment">// 错误！显式优先级最高</span>\n</code></pre>\n</li>\n<li><strong>参数类型推断</strong><pre><code class="language-typescript"><span class="hljs-title function_">parseJSON</span>(<span class="hljs-string">&#x27;{&quot;a&quot;: 1}&#x27;</span>); <span class="hljs-comment">// 根据参数推断返回类型</span>\n</code></pre>\n</li>\n<li><strong>上下文类型（返回值/赋值目标）</strong><pre><code class="language-typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = []; <span class="hljs-comment">// 根据目标推断泛型</span>\n</code></pre>\n</li>\n<li><strong>默认类型</strong><pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;T = <span class="hljs-built_in">string</span>&gt; {}\n<span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>(); <span class="hljs-comment">// T 为 string</span>\n</code></pre>\n</li>\n</ol>\n<h2>3. 高级推导场景</h2>\n<h3>多泛型参数推断</h3>\n<p>每个泛型参数独立推断，位置对应：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> map&lt;T, U&gt;(<span class="hljs-attr">arr</span>: T[], <span class="hljs-attr">fn</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">x</span>: T</span>) =&gt;</span> U): U[] { <span class="hljs-comment">/*...*/</span> }\n<span class="hljs-title function_">map</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// T=number, U=string</span>\n</code></pre>\n<h3>函数参数类型逆变</h3>\n<p>在回调函数场景中，参数类型遵循逆变规则：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Handler</span>&lt;T&gt; = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">input</span>: T</span>) =&gt;</span> <span class="hljs-built_in">void</span>;\n<span class="hljs-keyword">const</span> <span class="hljs-attr">handler</span>: <span class="hljs-title class_">Handler</span>&lt;<span class="hljs-title class_">Animal</span>&gt; = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">dog</span>: <span class="hljs-title class_">Dog</span></span>) =&gt;</span> {}; <span class="hljs-comment">// Dog → Animal 合法</span>\n</code></pre>\n<h3>条件类型推断（infer）</h3>\n<p>使用 <code>infer</code> 关键字提取嵌套类型：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">UnpackPromise</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Promise</span>&lt;infer U&gt; ? U : T;\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Num</span> = <span class="hljs-title class_">UnpackPromise</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt;; <span class="hljs-comment">// number</span>\n</code></pre>\n<h2>4. 特殊场景处理</h2>\n<h3>方法链式调用</h3>\n<p>泛型类型会在链式调用中传递：</p>\n<pre><code class="language-typescript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// Promise&lt;number&gt;</span>\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-title function_">toString</span>()) <span class="hljs-comment">// Promise&lt;string&gt;</span>\n</code></pre>\n<h3>JSX/TSX 中的泛型</h3>\n<p>需添加逗号避免语法歧义：</p>\n<pre><code class="language-tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = &lt;T,&gt;<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">props</span>: { data: T }</span>) =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{props.data}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n</code></pre>\n<h3>泛型约束（extends）</h3>\n<p>约束条件会影响推断范围：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> longest&lt;T <span class="hljs-keyword">extends</span> { <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span> }&gt;(<span class="hljs-attr">a</span>: T, <span class="hljs-attr">b</span>: T): T {\n  <span class="hljs-keyword">return</span> a.<span class="hljs-property">length</span> &gt; b.<span class="hljs-property">length</span> ? a : b;\n}\n<span class="hljs-title function_">longest</span>(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// 合法，T=string</span>\n<span class="hljs-title function_">longest</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 错误，number 不满足约束</span>\n</code></pre>\n<h2>5. 最佳实践</h2>\n<ol>\n<li><strong>优先让 TypeScript 自动推断</strong></li>\n<li><strong>合理使用默认类型</strong></li>\n<li><strong>复杂类型使用显式注解</strong></li>\n<li><strong>利用泛型约束明确参数范围</strong></li>\n</ol>\n<h2>类型推断流程图</h2>\n<pre><code class="language-mermaid">graph TD\n    A[调用泛型函数] --&gt; B{是否显式指定泛型?}\n    B --&gt;|是| C[使用显式类型]\n    B --&gt;|否| D{能否从参数推断?}\n    D --&gt;|是| E[根据参数类型推断]\n    D --&gt;|否| F{是否有上下文类型?}\n    F --&gt;|是| G[根据返回值/赋值目标推断]\n    F --&gt;|否| H[使用默认类型或 unknown]\n</code></pre>\n<p>TypeScript 的泛型推导系统通过这套规则，在保持类型安全的同时最大程度减少了显式类型标注的需求。</p>\n</div>'</script></body></html>