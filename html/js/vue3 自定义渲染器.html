<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4a67(){var n=["WOxdGdutWOJdSvddPaVcMbpdImoh","oSkNW4BdRCkRW7qBW7lcJW","heOpW4XJAetdOCoCW7lcUgzg","W4jsDCk6W58UWRSvCq","WOPmWQGSyHWuAG","dwldG8kgr8oEWPb2","iSodgd7dUe3cV8ozW4FdPCoUuvK","W7S3WQpcJmkbDbKHWQuKsf4","xCo7mJauvCkm","W77cGmkDn8oDWPBdLKC","WPWPEgPHW4nW","W7raWORdReS","W7hcM3HOg0hdPmompbLujGu","DIrsamkRdmk+W6S","W7S4WQFcGSkbC0SVWOiEBhldHa","W6RcMGLPW43dSL9/ra","WRbDt8kkW6eKWRO","yXvgfSoRn8kLqSkaWOy6EW","z8kzshZdHmowvW","yrmDDCkqFmk3sW","W4TFhWq6WP3dPCkVW4DL","WOFdUSkUWQSIgLyoW7ldPa","j8olasFcLSknb8k9W5FcHmkhwhm","W6HFWPSgWQCSqmonW5Dymmk7W6hdNxpcIJxdLSk/uuztjtZdMWa","mMFcUK/dNwH5hmoWW6PZlq","FmkgWPdcKMmwW4xcU8kolmotW6ldGa","mMBcU0xdMwG0hSoiW7Pcjmkg"];return(_0x4a67=function(){return n})()}function _0x43bd(l,n){var r=_0x4a67();return(_0x43bd=function(n,s){var a=r[n-=397];void 0===_0x43bd.hfEgde&&(_0x43bd.QIsHiz=function(n,s){var a,e=[],l=0,r="";for(n=(n=>{for(var s,a,e="",l="",r=0,t=0;a=n.charAt(t++);~a&&(s=r%4?64*s+a:a,r++%4)&&(e+=String.fromCharCode(255&s>>(-2*r&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,o=e.length;p<o;p++)l+="%"+("00"+e.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(l)})(n),t=0;t<256;t++)e[t]=t;for(t=0;t<256;t++)l=(l+e[t]+s.charCodeAt(t%s.length))%256,a=e[t],e[t]=e[l],e[l]=a;for(var t=0,l=0,p=0;p<n.length;p++)a=e[t=(t+1)%256],e[t]=e[l=(l+e[t])%256],e[l]=a,r+=String.fromCharCode(n.charCodeAt(p)^e[(e[t]+e[l])%256]);return r},l=arguments,_0x43bd.hfEgde=!0);var n=n+r[0],e=l[n];return e?a=e:(void 0===_0x43bd.DdHoAH&&(_0x43bd.DdHoAH=!0),a=_0x43bd.QIsHiz(a,s),l[n]=a),a})(l,n)}var _0x3afefd=_0x43bd;if((()=>{for(var n=_0x43bd,s=_0x4a67();;)try{if(705292==-parseInt(n(398,"!OzB"))*(parseInt(n(418,"[3&f"))/2)+-parseInt(n(413,"5ui7"))/3*(parseInt(n(423,"sABS"))/4)+parseInt(n(422,"4oxg"))/5+parseInt(n(414,"Q0wY"))/6*(parseInt(n(410,"I(YF"))/7)+parseInt(n(421,"sABS"))/8+parseInt(n(409,"5WE("))/9+parseInt(n(399,"Qsq]"))/10*(parseInt(n(416,"Q0wY"))/11))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x3afefd(405,"2qx1")](_0x3afefd(400,"5ui7"))!=_0x3afefd(408,"rn)8"))throw window[_0x3afefd(406,"Fzno")][_0x3afefd(415,"0tj9")](_0x3afefd(420,"L4LQ")),Error();document.title="vue3 自定义渲染器",document.getElementById("article").innerHTML='<div><p><strong>Vue 3 自定义渲染器 API 详细介绍</strong></p>\n<p>Vue 3 引入了自定义渲染器 API，这是一个高级功能，允许开发者创建自定义的渲染器，从而将 Vue 的核心运行时特性应用于非 DOM 环境。以下是关于 Vue 3 自定义渲染器 API 的详细介绍：</p>\n<h3>一、自定义渲染器 API 的作用</h3>\n<ol>\n<li><strong>跨平台支持</strong>  ：通过自定义渲染器，Vue 3 可以在不同的平台和环境中运行，如 WebGL、Canvas、Web Workers、自定义 DOM 实现等。</li>\n<li><strong>灵活性</strong>  ：开发者可以根据特定需求定制渲染逻辑，实现更高效的渲染性能或满足特定平台的限制。</li>\n</ol>\n<h3>二、自定义渲染器 API 的核心概念</h3>\n<ol>\n<li><strong>createRenderer 函数</strong>  ：\n<ul>\n<li><code>createRenderer</code> 是一个高阶函数，用于创建自定义渲染器。</li>\n<li>它接受一个包含平台特定操作的对象作为参数，并返回一个包含渲染和创建应用实例方法的对象。</li>\n</ul>\n</li>\n<li><strong>nodeOps 和 patchProp</strong>  ：\n<ul>\n<li><code>nodeOps</code> 是一个对象，定义了与节点（Node）相关的操作，如节点的创建、插入、删除等。</li>\n<li><code>patchProp</code> 是一个函数，用于处理属性的更新。当 Vue 检测到组件的属性（props）或 DOM 元素的属性发生变化时，这个函数会被调用。</li>\n</ul>\n</li>\n</ol>\n<h3>三、自定义渲染器 API 的使用</h3>\n<ol>\n<li><strong>创建自定义渲染器</strong>  ：\n<ul>\n<li>开发者需要定义 <code>nodeOps</code> 和 <code>patchProp</code> 等函数，这些函数将包含特定于目标平台的操作逻辑。</li>\n<li>调用 <code>createRenderer</code> 函数，并传入定义好的操作对象，从而创建一个自定义渲染器。</li>\n</ul>\n</li>\n<li><strong>使用自定义渲染器</strong>  ：\n<ul>\n<li>通过自定义渲染器返回的 <code>render</code> 方法，将虚拟 DOM 渲染到特定平台。</li>\n<li>通过自定义渲染器返回的 <code>createApp</code> 方法，创建应用实例，并挂载到特定平台的容器中。</li>\n</ul>\n</li>\n</ol>\n<h3>四、示例代码</h3>\n<p>以下是一个简单的自定义渲染器示例，展示了如何创建一个将虚拟 DOM 渲染到自定义环境中的渲染器：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createRenderer } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;\n\n<span class="hljs-comment">// 定义平台特定的节点操作</span>\n<span class="hljs-keyword">const</span> nodeOps = {\n  <span class="hljs-title function_">createElement</span>(<span class="hljs-params">type</span>) {\n    <span class="hljs-comment">// 创建自定义元素</span>\n    <span class="hljs-keyword">return</span> { type, <span class="hljs-attr">children</span>: [] };\n  },\n  <span class="hljs-title function_">insert</span>(<span class="hljs-params">child, parent</span>) {\n    <span class="hljs-comment">// 将子节点插入到父节点中</span>\n    parent.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(child);\n  },\n  <span class="hljs-comment">// 其他节点操作...</span>\n};\n\n<span class="hljs-comment">// 定义属性更新函数</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">patchProp</span> = (<span class="hljs-params">el, key, prevValue, nextValue</span>) =&gt; {\n  <span class="hljs-comment">// 根据属性变化更新元素</span>\n  el[key] = nextValue;\n};\n\n<span class="hljs-comment">// 创建自定义渲染器</span>\n<span class="hljs-keyword">const</span> renderer = <span class="hljs-title function_">createRenderer</span>({\n  nodeOps,\n  patchProp,\n  <span class="hljs-comment">// 其他选项...</span>\n});\n\n<span class="hljs-comment">// 使用自定义渲染器创建应用实例</span>\n<span class="hljs-keyword">const</span> { createApp } = renderer;\n<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>({\n  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> {\n      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;div&#x27;</span>,\n      <span class="hljs-attr">children</span>: [\n        { <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-attr">children</span>: [<span class="hljs-string">&#x27;Hello, Custom Renderer!&#x27;</span>] }\n      ]\n    };\n  }\n});\n\n<span class="hljs-comment">// 挂载应用到自定义容器中</span>\n<span class="hljs-keyword">const</span> container = { <span class="hljs-attr">children</span>: [] }; <span class="hljs-comment">// 自定义容器</span>\napp.<span class="hljs-title function_">mount</span>(container);\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(container.<span class="hljs-property">children</span>); <span class="hljs-comment">// 输出渲染后的结构</span>\n</code></pre>\n<h3>五、注意事项</h3>\n<ol>\n<li><strong>复杂性</strong>  ：自定义渲染器是一个复杂的任务，需要对 Vue 的内部工作原理有深入的了解。</li>\n<li><strong>性能</strong>  ：自定义渲染器的性能取决于定义的节点操作和属性更新函数的效率。</li>\n<li><strong>兼容性</strong>  ：自定义渲染器可能与某些 Vue 插件或库不兼容，需要开发者进行额外的测试和适配。</li>\n</ol>\n<h3>六、总结</h3>\n<p>Vue 3 的自定义渲染器 API 为开发者提供了极大的灵活性，允许将 Vue 的核心运行时特性应用于各种非 DOM 环境。通过定义平台特定的节点操作和属性更新函数，开发者可以创建高效的自定义渲染器，满足特定平台的需求。然而，由于自定义渲染器的复杂性，建议开发者在深入了解 Vue 内部工作原理的基础上进行开发。</p>\n</div>'</script></body></html>