<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3911ee=_0x4f1d;function _0x4ca6(){var s=["qaFcGJzyW5NcJCkKnbjfW5e","C3bIW57cUSooiSkBW7VcSSorWQ0","W6BcSCoNhJddT8kPbG","WRlcGmkIWRq1W5JdNSkIrSoJCCo2","WQXusI7dV28sW48DuSoTW6ZdUaGevs9xc8kqWPKQiSkXeee","oY0EW7WramoODG","smo2wxm2WOZdUa","W6vTn0hdS8oHB8kvqSoEcSkC","C8oFhXFdJ8oGdbtdTwCFxa","W5DPW7bqW5y6W5tcIuJcRmkgWRW","waZcMCozlG","d8kcWRxdRfTxwG","W67dUSk2qeXLW6ZdGJuTqCkQ","WP4UdwldMmklzY8","AhpdSrHJj8owaSks","CSo1fxNcHe3dISo4","W5fhAMxcNqubWOCQWQ3cJmoF","A8odkCoEdMldIqnCWR0","W7WZo2iaWQOBDXqsW6PS","W70XpMrqW7CLuraO","W61OW65HWOb5iq","WP4IcSkIkvaEoCkrW519","WO8WsNpcOLNdUSkEW6VdKmktWQu","guVcPmohgtFcVHi","W57dSJHvW6GUWR5gW67cPHlcUG","W55YtSo7EfKn","bCo9BJmmx8ocWQ/cTSodwhC"];return(_0x4ca6=function(){return s})()}function _0x4f1d(e,s){var p=_0x4ca6();return(_0x4f1d=function(s,a){var n=p[s-=418];void 0===_0x4f1d.KNSCoj&&(_0x4f1d.arntPT=function(s,a){var n,l=[],e=0,p="";for(s=(s=>{for(var a,n,l="",e="",p=0,t=0;n=s.charAt(t++);~n&&(a=p%4?64*a+n:n,p++%4)&&(l+=String.fromCharCode(255&a>>(-2*p&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,r=l.length;c<r;c++)e+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)e=(e+l[t]+a.charCodeAt(t%a.length))%256,n=l[t],l[t]=l[e],l[e]=n;for(var t=0,e=0,c=0;c<s.length;c++)n=l[t=(t+1)%256],l[t]=l[e=(e+l[t])%256],l[e]=n,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[t]+l[e])%256]);return p},e=arguments,_0x4f1d.KNSCoj=!0);var s=s+p[0],l=e[s];return l?n=l:(void 0===_0x4f1d.DTyuFC&&(_0x4f1d.DTyuFC=!0),n=_0x4f1d.arntPT(n,a),e[s]=n),n})(e,s)}if((()=>{for(var s=_0x4f1d,a=_0x4ca6();;)try{if(150200==-parseInt(s(430,"v9D("))*(parseInt(s(420,"Bm30"))/2)+parseInt(s(428,"jrk]"))/3*(-parseInt(s(421,"MT3N"))/4)+-parseInt(s(422,"2S[5"))/5*(-parseInt(s(442,"k$LB"))/6)+-parseInt(s(431,"[*a4"))/7+-parseInt(s(427,"&8Ji"))/8+-parseInt(s(426,"BXsf"))/9+-parseInt(s(440,"@qO0"))/10*(-parseInt(s(438,"YAQO"))/11))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x3911ee(439,"ue5e")](_0x3911ee(433,"0jLC"))!=_0x3911ee(429,"k$LB"))throw window[_0x3911ee(434,"Z6$n")][_0x3911ee(444,"@qO0")](_0x3911ee(423,"SNZ8")),Error();document.title="TypeScript 映射类型",document.getElementById("article").innerHTML='<div><p>TypeScript 的映射类型（Mapped Types）是一种强大的类型转换工具，它允许你基于已有类型创建新类型，通过遍历已有类型的属性并对每个属性进行转换。</p>\n<h3>映射类型的基本语法</h3>\n<p>映射类型的基本形式如下：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MappedType</span>&lt;T&gt; = {\n  [P <span class="hljs-keyword">in</span> keyof T]: T[P];\n};\n</code></pre>\n<ul>\n<li><code>keyof T</code> 获取类型 <code>T</code> 所有属性名组成的联合类型</li>\n<li><code>P in ...</code> 遍历这个联合类型，<code>P</code> 代表每个属性名</li>\n<li><code>T[P]</code> 获取属性 <code>P</code> 的类型</li>\n</ul>\n<h3>常用映射类型操作</h3>\n<h4>1. 只读映射（Readonly）</h4>\n<p>创建一个所有属性都是只读的新类型：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Readonly</span>&lt;T&gt; = {\n  <span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> keyof T]: T[P];\n};\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">ReadonlyUser</span> = <span class="hljs-title class_">Readonly</span>&lt;<span class="hljs-title class_">User</span>&gt;;\n<span class="hljs-comment">// 等价于：{ readonly name: string; readonly age: number; }</span>\n</code></pre>\n<h4>2. 可选映射（Partial）</h4>\n<p>创建一个所有属性都是可选的新类型：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Partial</span>&lt;T&gt; = {\n  [P <span class="hljs-keyword">in</span> keyof T]?: T[P];\n};\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialUser</span> = <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">User</span>&gt;;\n<span class="hljs-comment">// 等价于：{ name?: string; age?: number; }</span>\n</code></pre>\n<h4>3. 选取部分属性（Pick）</h4>\n<p>从类型中选取指定的属性：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Pick</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = {\n  [P <span class="hljs-keyword">in</span> K]: T[P];\n};\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">UserName</span> = <span class="hljs-title class_">Pick</span>&lt;<span class="hljs-title class_">User</span>, <span class="hljs-string">&quot;name&quot;</span>&gt;;\n<span class="hljs-comment">// 等价于：{ name: string; }</span>\n</code></pre>\n<h4>4. 排除部分属性（Omit）</h4>\n<p>从类型中排除指定的属性：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Omit</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof <span class="hljs-built_in">any</span>&gt; = <span class="hljs-title class_">Pick</span>&lt;T, <span class="hljs-title class_">Exclude</span>&lt;keyof T, K&gt;&gt;;\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">UserAge</span> = <span class="hljs-title class_">Omit</span>&lt;<span class="hljs-title class_">User</span>, <span class="hljs-string">&quot;name&quot;</span>&gt;;\n<span class="hljs-comment">// 等价于：{ age: number; }</span>\n</code></pre>\n<h4>5. 条件类型映射</h4>\n<p>结合条件类型进行更复杂的映射：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Nullable</span>&lt;T&gt; = {\n  [P <span class="hljs-keyword">in</span> keyof T]: T[P] | <span class="hljs-literal">null</span>;\n};\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">NullableUser</span> = <span class="hljs-title class_">Nullable</span>&lt;<span class="hljs-title class_">User</span>&gt;;\n<span class="hljs-comment">// 等价于：{ name: string | null; age: number | null; }</span>\n</code></pre>\n<h4>6. 键名重映射（Key Remapping）</h4>\n<p>TypeScript 4.1 引入了键名重映射，可以修改属性名：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MapToGetters</span>&lt;T&gt; = {\n  [P <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> <span class="hljs-string">`get<span class="hljs-subst">${Capitalize&lt;<span class="hljs-built_in">string</span> &amp; P&gt;}</span>`</span>]: <span class="hljs-function">() =&gt;</span> T[P];\n};\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">UserGetters</span> = <span class="hljs-title class_">MapToGetters</span>&lt;<span class="hljs-title class_">User</span>&gt;;\n<span class="hljs-comment">// 等价于：{ getName: () =&gt; string; getAge: () =&gt; number; }</span>\n</code></pre>\n<p>当在键名重映射中返回 never 时，该属性会被从结果类型中移除：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">FilterKeys</span>&lt;T, <span class="hljs-title class_">Condition</span>&gt; = {\n  [P <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> T[P] <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Condition</span> ? P : <span class="hljs-built_in">never</span>]: T[P];\n};\n\n<span class="hljs-comment">// 示例：过滤出类型为 string 的属性</span>\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Example</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">active</span>: <span class="hljs-built_in">boolean</span>;\n}\n\n<span class="hljs-comment">// 只保留 string 类型的属性</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">StringProperties</span> = <span class="hljs-title class_">FilterKeys</span>&lt;<span class="hljs-title class_">Example</span>, <span class="hljs-built_in">string</span>&gt;;\n<span class="hljs-comment">// 结果：{ name: string; email: string; }</span>\n</code></pre>\n<h3>映射类型的应用场景</h3>\n<ol>\n<li><strong>类型转换</strong>   ：快速创建与原始类型相关但有细微差别的类型</li>\n<li><strong>工具类型</strong>   ：实现如 <code>Partial</code>、<code>Readonly</code> 等通用工具类型</li>\n<li><strong>属性修饰</strong>   ：批量修改属性的只读性、可选性或类型</li>\n<li><strong>API 适配</strong>   ：将一种数据结构转换为另一种适配不同 API 的结构</li>\n</ol>\n<h3>注意事项</h3>\n<ul>\n<li>映射类型是<strong>同态</strong>   的，它会保留原始类型的结构信息</li>\n<li>可以通过 <code>+</code> 或 <code>-</code> 显式添加或移除 <code>readonly</code> 和 <code>?</code> 修饰符：<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyType</span>&lt;T&gt; = {\n  -<span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> keyof T]-?: T[P];\n};\n</code></pre>\n</li>\n<li>结合 <code>infer</code> 关键字可以实现更复杂的类型提取和转换</li>\n</ul>\n<p>映射类型是 TypeScript 类型系统中非常强大的特性，熟练掌握可以极大提升类型定义的灵活性和可维护性。</p>\n</div>'</script></body></html>