<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x13caf5=_0x3da2;function _0x3da2(p,s){var c=_0x1826();return(_0x3da2=function(s,a){var n=c[s-=441];void 0===_0x3da2.iEXBKt&&(_0x3da2.GJEwXr=function(s,a){var n,e=[],p=0,c="";for(s=(s=>{for(var a,n,e="",p="",c=0,l=0;n=s.charAt(l++);~n&&(a=c%4?64*a+n:n,c++%4)&&(e+=String.fromCharCode(255&a>>(-2*c&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var t=0,r=e.length;t<r;t++)p+="%"+("00"+e.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(p)})(s),l=0;l<256;l++)e[l]=l;for(l=0;l<256;l++)p=(p+e[l]+a.charCodeAt(l%a.length))%256,n=e[l],e[l]=e[p],e[p]=n;for(var l=0,p=0,t=0;t<s.length;t++)n=e[l=(l+1)%256],e[l]=e[p=(p+e[l])%256],e[p]=n,c+=String.fromCharCode(s.charCodeAt(t)^e[(e[l]+e[p])%256]);return c},p=arguments,_0x3da2.iEXBKt=!0);var s=s+c[0],e=p[s];return e?n=e:(void 0===_0x3da2.NuPVLT&&(_0x3da2.NuPVLT=!0),n=_0x3da2.GJEwXr(n,a),p[s]=n),n})(p,s)}if((()=>{for(var s=_0x3da2,a=_0x1826();;)try{if(841420==+parseInt(s(442,"51v]"))*(-parseInt(s(449,"jrq@"))/2)+parseInt(s(465,"THK7"))/3+-parseInt(s(457,"zE2q"))/4*(-parseInt(s(447,"XSLi"))/5)+-parseInt(s(456,"HNoc"))/6+-parseInt(s(459,"51v]"))/7*(-parseInt(s(467,"egXS"))/8)+parseInt(s(450,"tV3r"))/9*(parseInt(s(446,"@yWe"))/10)+-parseInt(s(461,"57bB"))/11)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x13caf5(444,"M@VY")](_0x13caf5(453,"gP3D"))!=_0x13caf5(454,"rp8O"))throw window[_0x13caf5(443,"84sX")][_0x13caf5(464,"0YJ#")](_0x13caf5(455,"aAKL")),Error();function _0x1826(){var s=["tq3dGGVcTdJdV8oZoxFdSCkB","W6m0drjBWPRcTG","lColWQhcSSouuvXHWRe","BuldMx1QW6TEamoV","zrRcH0Wo","iq7cPZdcIcBcIczpnv9ad8kpW7bsWP4TaflcUCommxL5W7G","gdldUMDjW6D6gff2tWzV","d8kgW5dcVIFcM8kV","aMOoimklqSkrWQvytSoNWRS","ACk0WPnHW6nkW7jcWOKkW6HPda","fCoHWOxcSeVdTmofFXZcKmo2WPChiW","W67cMaRdNSkLWRZcUg9CgHhcOqVcVW","W7xcTY4FW6LjjSk5","WPZcUSoFC8oSl8kjWRDeWO/cTLW","z0axW4JdNH16","WQBcLu/dKmk7l0lcLYtcHaVcQgK","WPH3l8kRz8oucCkMW43dTrv6W5i","W4/dUSo0jW7dRZa","W4dcJXqXkIVdMa","W4pcHCkaqhFcJ1hcV8keW5VdN8o0W5q","yCk1W5y0WR0gWQPj","W4xdG8obsSoIBeyJ","mCoclgHJW5vJ","W7vDh8kYbh7cPrZdLK/dS8kIW5O","nCkmWOCppIL5W7aI","lColWQFdHmkylIDmWPiIjCk/W68","hrFcGYWQWQSHcmoKFZZdR8ko","ncBdVq8SWPqEWQP1WRLDpa"];return(_0x1826=function(){return s})()}document.title="typescript as 关键字",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>as</code> 关键字有几种用途，主要用于类型断言和映射类型中的键重映射。以下是 <code>as</code> 的两种主要用法：</p>\n<h3>1. 类型断言（Type Assertion）</h3>\n<p>类型断言允许你告诉 TypeScript 编译器某个值的具体类型。这在某些情况下非常有用，比如当你比编译器更了解某个值的类型时。</p>\n<p><strong>语法</strong>  ：</p>\n<pre><code class="language-typescript">value <span class="hljs-keyword">as</span> <span class="hljs-title class_">TargetType</span>\n</code></pre>\n<p>或</p>\n<pre><code class="language-typescript">&lt;<span class="hljs-title class_">TargetType</span>&gt;value\n</code></pre>\n<p>（注意：在 JSX 环境中，建议使用 <code>as</code> 语法，因为尖括号语法可能与 JSX 的标签语法冲突。）</p>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;\n<span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;\n</code></pre>\n<p>在这个示例中，<code>someValue</code> 的类型被断言为 <code>string</code>，以便访问其 <code>length</code> 属性。</p>\n<h3>2. 映射类型中的键重映射</h3>\n<p>在映射类型中，<code>as</code> 关键字用于重映射键名。它允许你在遍历一个类型的键时，对键名进行某种转换。</p>\n<p><strong>语法</strong>  ：</p>\n<pre><code class="language-typescript">{ [P <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> <span class="hljs-title class_">NewKeyType</span>]: T[P] }\n</code></pre>\n<p><strong>示例</strong>  ：\n假设你有一个接口，并希望将其所有键名转换为大写形式：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Original</span> {\n  <span class="hljs-attr">propA</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">propB</span>: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">UppercaseKeys</span>&lt;T&gt; = {\n  [P <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> <span class="hljs-title class_">Uppercase</span>&lt;<span class="hljs-built_in">string</span> &amp; P&gt;]: T[P];\n};\n\n<span class="hljs-comment">// 由于 TypeScript 映射类型不支持直接字符串操作，这里仅为示例说明。</span>\n<span class="hljs-comment">// 实际上，TypeScript 不提供直接的字符串大写转换工具，需自定义逻辑或使用第三方库。</span>\n<span class="hljs-comment">// 假设有一个虚构的 Uppercase 工具类型用于演示</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Transformed</span> = <span class="hljs-title class_">UppercaseKeys</span>&lt;<span class="hljs-title class_">Original</span>&gt;; \n<span class="hljs-comment">// 实际实现中需要自定义逻辑或工具库来处理键名转换</span>\n</code></pre>\n<p><strong>说明</strong>  ：</p>\n<ul>\n<li><code>P in keyof T</code> 遍历类型 <code>T</code> 的所有键。</li>\n<li><code>as Uppercase&lt;string &amp; P&gt;</code> 是重映射部分，假设有一个工具类型 <code>Uppercase</code> 可以将键名转换为大写（实际 TypeScript 中没有内置的 <code>Uppercase</code> 工具类型用于键名，这里仅为演示）。</li>\n<li><code>T[P]</code> 保留原类型 <code>T</code> 中键 <code>P</code> 的属性类型。</li>\n</ul>\n<p><strong>实际键名转换</strong>  ：\n由于 TypeScript 本身不支持直接对键名进行字符串操作（如大写转换），通常需要使用第三方库或自定义逻辑来实现类似的功能。例如，可以通过构建阶段的工具（如 Babel 插件）或在代码中手动映射键名。</p>\n<h3>注意事项</h3>\n<ul>\n<li>类型断言应谨慎使用，因为它绕过了 TypeScript 的类型检查，可能导致运行时错误。</li>\n<li>在映射类型中使用 <code>as</code> 进行键重映射时，需要确保转换逻辑是有效的，并且不会导致键名冲突或丢失。</li>\n</ul>\n</div>'</script></body></html>