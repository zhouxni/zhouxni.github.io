<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2527(p,s){var e=_0x3099();return(_0x2527=function(s,a){var n=e[s-=418];void 0===_0x2527.OeFWoO&&(_0x2527.QNRwrc=function(s,a){var n,l=[],p=0,e="";for(s=(s=>{for(var a,n,l="",p="",e=0,r=0;n=s.charAt(r++);~n&&(a=e%4?64*a+n:n,e++%4)&&(l+=String.fromCharCode(255&a>>(-2*e&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var o=0,c=l.length;o<c;o++)p+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(p)})(s),r=0;r<256;r++)l[r]=r;for(r=0;r<256;r++)p=(p+l[r]+a.charCodeAt(r%a.length))%256,n=l[r],l[r]=l[p],l[p]=n;for(var r=0,p=0,o=0;o<s.length;o++)n=l[r=(r+1)%256],l[r]=l[p=(p+l[r])%256],l[p]=n,e+=String.fromCharCode(s.charCodeAt(o)^l[(l[r]+l[p])%256]);return e},p=arguments,_0x2527.OeFWoO=!0);var s=s+e[0],l=p[s];return l?n=l:(void 0===_0x2527.dRtuRk&&(_0x2527.dRtuRk=!0),n=_0x2527.QNRwrc(n,a),p[s]=n),n})(p,s)}var _0xaa377c=_0x2527;function _0x3099(){var s=["FWnTuuXKcZi","WQGuW7O8WOtdTW0","WQvEbSoHW4BdLta","W4FdLsFdLmkHWOyFW4CnW6BdRCoU","eSogW7JcVSoyq8kr","pmoorJiheCol","k0ddU8oywx5U","W5JdIq7cHCoEpaOChmozkG","WPNdNCoKWODMW7qQrmkrqLm","DKOXlIFdV8oQW7eBWQJdTmotW5a","WQTWWPtdVCo2p3FdUCooASo1","W6zidNhdO8kfW4lcPahcQ1a","xttcJHddRadcLdhdU8kBjcpcLq","WOHJoYlcSwVdPmkRW4bLoq","mcbvW6tdLLVcVCkWWRK","q8kHyhXOBSkuWRtcOSobW6b6","eCo2lqmSm8ku","sSoplLOTWQX1WONcUeCxvW","rXxdJHzeWOFcQ8og","gr/cHhJdVGTSm8kmxc8gWPmMefJcJejpW6dcRgFdK8oGE8oc","WRvflmkYWOpdKSo9WQpcIr8","ACk5W7GaWP3cMGK1v8oz","WOLVDSoGW5bEW4ep","WRVcJSkhqSonWOBcN0FdHCo+","lqdcJCk2wu1dWPCUWO8","m8kwCSkduCoyob7dTq","qNmoW47dTxVcHCkmWRa","WRNdT8oFimoVvCkfiXTFe8oJ","WOnUmclcT1ldOSkIW4f3kG","C2uEW5JdVW"];return(_0x3099=function(){return s})()}if((()=>{for(var s=_0x2527,a=_0x3099();;)try{if(279143==+parseInt(s(440,"D&YX"))+parseInt(s(423,"ncZJ"))/2*(-parseInt(s(420,"cyfo"))/3)+-parseInt(s(432,"CvKw"))/4+-parseInt(s(434,"3&VV"))/5*(parseInt(s(437,"yVpO"))/6)+parseInt(s(430,"d)Td"))/7*(parseInt(s(427,"QB9T"))/8)+parseInt(s(438,"6)x7"))/9*(-parseInt(s(447,"gYFl"))/10)+-parseInt(s(424,"Nldy"))/11*(-parseInt(s(446,"AV#]"))/12))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0xaa377c(445,"2LsC")](_0xaa377c(425,"bqmF"))!=_0xaa377c(428,"bqmF"))throw window[_0xaa377c(421,"rloS")][_0xaa377c(431,"W5q)")](_0xaa377c(418,"U&B1")),Error();document.title="webpack 自定义 loader",document.getElementById("article").innerHTML='<div><p>在 Webpack 中，自定义 Loader 是一种强大的工具，用于在资源文件被添加到依赖图中之前，对其进行转换。Loader 本质上是一个导出为函数的 Node.js 模块，它接收源文件内容作为输入，并返回转换后的内容。以下是关于 Webpack 自定义 Loader 的详细指南：</p>\n<hr>\n<h3>1. <strong>Loader 的基本概念</strong></h3>\n<ul>\n<li><strong>作用</strong>  ：Loader 用于转换模块源代码，例如将 TypeScript 转换为 JavaScript，将 Sass 转换为 CSS，或者对代码进行自定义的文本处理。</li>\n<li><strong>执行顺序</strong>  ：Loader 可以链式调用，从右到左（或从下到上）执行。例如，如果你使用 <code>loader1</code> 和 <code>loader2</code>，实际执行顺序是 <code>loader2</code> -&gt; <code>loader1</code>。</li>\n<li><strong>异步或同步</strong>  ：Loader 可以是同步的，也可以是异步的。</li>\n</ul>\n<hr>\n<h3>2. <strong>创建自定义 Loader</strong></h3>\n<h4>（1）基本结构</h4>\n<p>一个自定义 Loader 通常是一个 Node.js 模块，导出一个函数。该函数接收源代码作为参数，并返回转换后的代码。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// my-custom-loader.js</span>\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) {\n  <span class="hljs-comment">// 对源代码进行处理</span>\n  <span class="hljs-keyword">const</span> transformedSource = source.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/foo/g</span>, <span class="hljs-string">&#x27;bar&#x27;</span>);\n  \n  <span class="hljs-comment">// 返回转换后的源代码</span>\n  <span class="hljs-keyword">return</span> transformedSource;\n};\n</code></pre>\n<h4>（2）使用自定义 Loader</h4>\n<p>在 Webpack 配置文件中，通过 <code>module.rules</code> 配置自定义 Loader：</p>\n<pre><code class="language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-comment">// ...其他配置</span>\n  <span class="hljs-attr">module</span>: {\n    <span class="hljs-attr">rules</span>: [\n      {\n        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.txt$/</span>, <span class="hljs-comment">// 匹配 .txt 文件</span>\n        <span class="hljs-attr">use</span>: [\n          {\n            <span class="hljs-attr">loader</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;my-custom-loader.js&#x27;</span>), <span class="hljs-comment">// 使用自定义 Loader</span>\n          },\n        ],\n      },\n    ],\n  },\n};\n</code></pre>\n<hr>\n<h3>3. <strong>Loader 的高级特性</strong></h3>\n<h4>（1）异步 Loader</h4>\n<p>如果 Loader 需要进行异步操作（如读取文件或网络请求），可以使用 <code>this.async()</code> 获取异步回调。</p>\n<pre><code class="language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) {\n  <span class="hljs-keyword">const</span> callback = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">async</span>();\n\n  <span class="hljs-comment">// 模拟异步操作</span>\n  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-keyword">const</span> transformedSource = source.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/foo/g</span>, <span class="hljs-string">&#x27;bar&#x27;</span>);\n    <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, transformedSource); <span class="hljs-comment">// 第一个参数为错误，第二个参数为转换后的源代码</span>\n  }, <span class="hljs-number">1000</span>);\n};\n</code></pre>\n<h4>（2）获取 Loader 选项</h4>\n<p>Loader 可以通过 <code>this.getOptions()</code> 获取传递给它的选项。</p>\n<pre><code class="language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) {\n  <span class="hljs-keyword">const</span> options = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getOptions</span>();\n  <span class="hljs-keyword">const</span> { replaceFrom, replaceTo } = options;\n\n  <span class="hljs-keyword">const</span> transformedSource = source.<span class="hljs-title function_">replace</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(replaceFrom, <span class="hljs-string">&#x27;g&#x27;</span>), replaceTo);\n  <span class="hljs-keyword">return</span> transformedSource;\n};\n</code></pre>\n<p><strong>在 Webpack 配置中使用选项</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-comment">// ...其他配置</span>\n  <span class="hljs-attr">module</span>: {\n    <span class="hljs-attr">rules</span>: [\n      {\n        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.txt$/</span>,\n        <span class="hljs-attr">use</span>: [\n          {\n            <span class="hljs-attr">loader</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;my-custom-loader.js&#x27;</span>),\n            <span class="hljs-attr">options</span>: {\n              <span class="hljs-attr">replaceFrom</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,\n              <span class="hljs-attr">replaceTo</span>: <span class="hljs-string">&#x27;baz&#x27;</span>,\n            },\n          },\n        ],\n      },\n    ],\n  },\n};\n</code></pre>\n<h4>（3）处理二进制数据</h4>\n<p>对于非文本文件（如图像、字体等），Loader 可以设置为处理二进制数据。</p>\n<pre><code class="language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) {\n  <span class="hljs-comment">// 检查是否为二进制数据</span>\n  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cacheable</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cacheable</span>(); <span class="hljs-comment">// 标记为可缓存</span>\n  }\n\n  <span class="hljs-comment">// 对二进制数据进行处理（如果需要）</span>\n  <span class="hljs-comment">// 这里只是简单返回原始数据</span>\n  <span class="hljs-keyword">return</span> source;\n};\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">raw</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记 Loader 可以处理二进制数据</span>\n</code></pre>\n<hr>\n<h3>4. <strong>Loader 的开发调试</strong></h3>\n<ul>\n<li><strong>使用 <code>console.log</code></strong>  ：在 Loader 中使用 <code>console.log</code> 输出调试信息，帮助理解数据流和转换过程。</li>\n<li><strong>利用 Webpack 的缓存</strong>  ：在开发过程中，可以禁用缓存或清除缓存，确保每次构建都使用最新的 Loader 代码。</li>\n<li><strong>单元测试</strong>  ：为 Loader 编写单元测试，确保其在各种输入下的行为符合预期。</li>\n</ul>\n<hr>\n<h3>5. <strong>Loader 的最佳实践</strong></h3>\n<ul>\n<li><strong>单一职责原则</strong>  ：每个 Loader 应该只负责一种转换任务，避免过于复杂的逻辑。</li>\n<li><strong>性能优化</strong>  ：尽量减少 Loader 的执行时间，避免不必要的同步操作。</li>\n<li><strong>错误处理</strong>  ：在 Loader 中捕获并处理可能的错误，确保构建过程不会因单个文件的错误而中断。</li>\n<li><strong>文档和示例</strong>  ：为自定义 Loader 编写清晰的文档和示例，方便其他开发者使用。</li>\n</ul>\n<hr>\n<h3>6. <strong>示例：自定义 Loader 替换文本</strong></h3>\n<p>以下是一个完整的自定义 Loader 示例，用于将文件中的特定文本替换为其他文本：</p>\n<p><strong><code>replace-loader.js</code></strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) {\n  <span class="hljs-keyword">const</span> options = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getOptions</span>();\n  <span class="hljs-keyword">const</span> { search, replace } = options;\n\n  <span class="hljs-keyword">if</span> (!search || !replace) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;replace-loader options &quot;search&quot; and &quot;replace&quot; are required.&#x27;</span>);\n  }\n\n  <span class="hljs-keyword">const</span> transformedSource = source.<span class="hljs-title function_">replace</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(search, <span class="hljs-string">&#x27;g&#x27;</span>), replace);\n  <span class="hljs-keyword">return</span> transformedSource;\n};\n</code></pre>\n<p><strong>Webpack 配置</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-comment">// ...其他配置</span>\n  <span class="hljs-attr">module</span>: {\n    <span class="hljs-attr">rules</span>: [\n      {\n        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.txt$/</span>,\n        <span class="hljs-attr">use</span>: [\n          {\n            <span class="hljs-attr">loader</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;replace-loader.js&#x27;</span>),\n            <span class="hljs-attr">options</span>: {\n              <span class="hljs-attr">search</span>: <span class="hljs-string">&#x27;hello&#x27;</span>,\n              <span class="hljs-attr">replace</span>: <span class="hljs-string">&#x27;world&#x27;</span>,\n            },\n          },\n        ],\n      },\n    ],\n  },\n};\n</code></pre>\n<hr>\n<h3>7. <strong>总结</strong></h3>\n<p>自定义 Loader 是 Webpack 生态系统中的重要组成部分，它允许开发者在构建过程中灵活地转换和处理模块源代码。通过理解 Loader 的基本概念、开发流程和最佳实践，开发者可以创建出强大且高效的自定义 Loader，满足各种复杂的构建需求。</p>\n</div>'</script></body></html>