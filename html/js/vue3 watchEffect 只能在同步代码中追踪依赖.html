<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5a9575=_0x4e4d;function _0xb6b7(){var s=["s8kaWOVcPq7cKSoRW67cKuO","W6NdJmkIW7GsWQ8StmkQWOFdKG","WPPUWR7cI8omctRcMIC9","WPTPW4ZdNSoeoJ/cOq","t8okAmoPWO4","W5hdMqrkWQTAuCkaW5RcJ8kh","WRVcHbrFW6rTW6FdOq","W4NdN8o0W5D5WRigW4hdQKxcOfxdTei","WQ7dOZddNCotngfnWQO","cqpcPmoZvu3dPCkwxJtdLq","W6NdHCkOW7qyW5TtySkGWQRdUmkaW5m","WQ/dQd3dJmoSeKDZWOq","hSk7oNfznMnoWQaHENlcKa","WQ3cSCoNWR3dOmkSWOpdHmkH","W68jfSozW4xcMtldQsO5W4y","g8k3jwXyuHOohG","W6uIWR7dHfNdR8oR","oCkSW4ZdLalcRSkdWPBdGW","WQi1zCoxW5xdGgzt","W5/dMrJcJer7WQZcP1q9DLdcIq","W6GmA8kKs8ojqmoqfM4","s8kaWO/cOx/dSmkZWRpcVxZdUhddSSob","WQ7dOJXnfCkraSkNBNK","stbTm8kpWONdICo/","W5FdNWvbWQ0CkSkAW4xcISksW7m7","eSoeW47dOZxdVmkLWQNcSxpdN1pdRCoIW7BdMCkMufOooSozWPeHtSoX","WPy7W5mrq0ZdN8oSW616W6dcImk6","W4fSmmksW4PxzW","W7i9wCorwSoefCoqdKf3WQ4M","s8kcW7xdQXFcKSoSW7q"];return(_0xb6b7=function(){return s})()}function _0x4e4d(e,s){var o=_0xb6b7();return(_0x4e4d=function(s,n){var t=o[s-=411];void 0===_0x4e4d.aoZxnC&&(_0x4e4d.gtUiCC=function(s,n){var t,a=[],e=0,o="";for(s=(s=>{for(var n,t,a="",e="",o=0,c=0;t=s.charAt(c++);~t&&(n=o%4?64*n+t:t,o++%4)&&(a+=String.fromCharCode(255&n>>(-2*o&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var r=0,l=a.length;r<l;r++)e+="%"+("00"+a.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(e)})(s),c=0;c<256;c++)a[c]=c;for(c=0;c<256;c++)e=(e+a[c]+n.charCodeAt(c%n.length))%256,t=a[c],a[c]=a[e],a[e]=t;for(var c=0,e=0,r=0;r<s.length;r++)t=a[c=(c+1)%256],a[c]=a[e=(e+a[c])%256],a[e]=t,o+=String.fromCharCode(s.charCodeAt(r)^a[(a[c]+a[e])%256]);return o},e=arguments,_0x4e4d.aoZxnC=!0);var s=s+o[0],a=e[s];return a?t=a:(void 0===_0x4e4d.lugaLb&&(_0x4e4d.lugaLb=!0),t=_0x4e4d.gtUiCC(t,n),e[s]=t),t})(e,s)}if((()=>{for(var s=_0x4e4d,n=_0xb6b7();;)try{if(905251==-parseInt(s(411,"PTaO"))+parseInt(s(431,"3l#0"))/2*(-parseInt(s(416,"6owL"))/3)+-parseInt(s(412,"#l#1"))/4*(-parseInt(s(438,"!Zf9"))/5)+parseInt(s(423,"v[4)"))/6+-parseInt(s(413,"EExw"))/7*(-parseInt(s(429,"EetV"))/8)+parseInt(s(418,"LMwL"))/9*(parseInt(s(432,"3l#0"))/10)+parseInt(s(420,"EetV"))/11*(-parseInt(s(435,"uJ5A"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5a9575(415,"xA1J")](_0x5a9575(414,"Z*4E"))!=_0x5a9575(433,"ullV"))throw window[_0x5a9575(422,"]084")][_0x5a9575(426,"mvpv")](_0x5a9575(424,"EetV")),Error();document.title="vue3 watchEffect 只能在同步代码中追踪依赖",document.getElementById("article").innerHTML='<div><p><code>watchEffect</code> 只能在<strong>同步代码</strong>   中追踪依赖，这是由 Vue 的响应式系统设计决定的。主要原因包括：</p>\n<hr>\n<h3><strong>1. 依赖收集的时机是同步的</strong></h3>\n<p>Vue 的响应式系统在 <code>watchEffect</code> 执行时，会<strong>立即运行传入的函数</strong>   ，并在同步执行过程中：</p>\n<ul>\n<li><strong>建立依赖收集上下文</strong>   （<code>ReactiveEffect</code>）</li>\n<li><strong>记录所有访问的响应式变量</strong>   （如 <code>ref</code>、<code>reactive</code>）</li>\n<li><strong>在变量变化时重新触发副作用</strong></li>\n</ul>\n<p>而异步代码（如 <code>setTimeout</code>、<code>Promise.then</code>、<code>await</code>）会在<strong>后续事件循环</strong>   中执行，此时<strong>依赖收集已经结束</strong>   ，因此无法追踪依赖。</p>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">value</span>); <span class="hljs-comment">// ✅ 同步访问，会被追踪</span>\n  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">value</span>); <span class="hljs-comment">// ❌ 异步回调，不会追踪</span>\n  }, <span class="hljs-number">1000</span>);\n});\n</code></pre>\n<hr>\n<h3><strong>2. 响应式系统的工作机制</strong></h3>\n<p>Vue 使用 <strong>Proxy/Reflect</strong>   或 <code>Object.defineProperty</code>（Vue 2）来拦截属性的访问（getter）和修改（setter）。</p>\n<ul>\n<li><strong>同步代码</strong>   ：<code>watchEffect</code> 运行时，访问 <code>state.value</code> 会触发 <code>getter</code>，此时 Vue 可以记录这个依赖关系。</li>\n<li><strong>异步代码</strong>   ：当异步回调执行时，<code>watchEffect</code> 的依赖收集阶段已经结束，即使访问 <code>state.value</code>，也不会被当前的 <code>watchEffect</code> 记录。</li>\n</ul>\n<hr>\n<h3><strong>3. 避免不可预测的依赖关系</strong></h3>\n<p>如果允许异步代码追踪依赖，会导致：</p>\n<ul>\n<li><strong>依赖关系变得动态且不可预测</strong>   （例如，某些依赖可能在某个异步回调后才被访问）</li>\n<li><strong>内存泄漏风险</strong>   （长期存活的异步任务可能持续持有响应式依赖）</li>\n<li><strong>性能问题</strong>   （需要额外机制来管理异步依赖的绑定和清理）</li>\n</ul>\n<p>Vue 选择<strong>显式且同步的依赖追踪</strong>   ，使响应式行为更加可控和高效。</p>\n<hr>\n<h3><strong>4. 如何正确处理异步依赖？</strong></h3>\n<h4><strong>方法 1：使用 <code>watch</code> 显式指定依赖</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-title function_">watch</span>([state], <span class="hljs-title function_">async</span> ([stateValue]) =&gt; {\n  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>(stateValue); <span class="hljs-comment">// 明确依赖 state</span>\n});\n</code></pre>\n<h4><strong>方法 2：拆分同步和异步逻辑</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> currentValue = state.<span class="hljs-property">value</span>; <span class="hljs-comment">// ✅ 同步捕获值</span>\n  <span class="hljs-title function_">doAsyncTask</span>(currentValue); <span class="hljs-comment">// 传递值而非响应式对象</span>\n});\n</code></pre>\n<h4><strong>方法 3：手动触发响应（如 <code>triggerRef</code>）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n  state.<span class="hljs-property">value</span> = <span class="hljs-number">1</span>;\n  <span class="hljs-title function_">triggerRef</span>(state); <span class="hljs-comment">// 手动触发更新</span>\n}, <span class="hljs-number">1000</span>);\n</code></pre>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><code>watchEffect</code> 的依赖收集是<strong>同步</strong>   的，因为 Vue 需要在函数执行时立即确定依赖关系。</li>\n<li>异步代码的执行<strong>脱离了依赖收集的上下文</strong>   ，因此无法自动追踪。</li>\n<li>这种设计保证了响应式系统的<strong>性能</strong>   和<strong>可预测性</strong>   ，避免复杂场景下的潜在问题。</li>\n</ul>\n<p>如果需要响应异步变化，应使用 <code>watch</code> 或显式传递值，而非依赖自动追踪。</p>\n</div>'</script></body></html>