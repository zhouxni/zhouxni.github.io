<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x18d691=_0x2bbd;function _0x2bbd(e,s){var t=_0x4d6b();return(_0x2bbd=function(s,n){var a=t[s-=372];void 0===_0x2bbd.iiLGHK&&(_0x2bbd.fuCZrf=function(s,n){var a,l=[],e=0,t="";for(s=(s=>{for(var n,a,l="",e="",t=0,o=0;a=s.charAt(o++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,p=l.length;c<p;c++)e+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),o=0;o<256;o++)l[o]=o;for(o=0;o<256;o++)e=(e+l[o]+n.charCodeAt(o%n.length))%256,a=l[o],l[o]=l[e],l[e]=a;for(var o=0,e=0,c=0;c<s.length;c++)a=l[o=(o+1)%256],l[o]=l[e=(e+l[o])%256],l[e]=a,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[o]+l[e])%256]);return t},e=arguments,_0x2bbd.iiLGHK=!0);var s=s+t[0],l=e[s];return l?a=l:(void 0===_0x2bbd.QCGWhM&&(_0x2bbd.QCGWhM=!0),a=_0x2bbd.fuCZrf(a,n),e[s]=a),a})(e,s)}if((()=>{for(var s=_0x2bbd,n=_0x4d6b();;)try{if(198026==+parseInt(s(373,"ME9["))*(parseInt(s(384,"1LDa"))/2)+-parseInt(s(403,"ME9["))/3*(parseInt(s(377,"Wc@X"))/4)+parseInt(s(380,"]IJk"))/5*(-parseInt(s(402,"Wc@X"))/6)+parseInt(s(391,"su)1"))/7*(-parseInt(s(390,"#N)r"))/8)+-parseInt(s(385,"fREj"))/9+parseInt(s(400,"Wc@X"))/10*(-parseInt(s(376,"Wc@X"))/11)+-parseInt(s(394,"B@7G"))/12*(-parseInt(s(383,"y^#x"))/13))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x18d691(381,"#iRb")](_0x18d691(401,"y^#x"))!=_0x18d691(397,"SN1E"))throw window[_0x18d691(387,"^Bb$")][_0x18d691(396,"J!6Z")](_0x18d691(389,"fREj")),Error();function _0x4d6b(){var s=["WPZdPwhcH8kdW7qRW6WAomkMWP0R","WRKdlWOuW5JcKSkApbJcJ1VcJq","WPGHW4KeWRaBW5Hs","W5nNWParW5K7WQ8","WP/cIXZcOSkLWPL1","jb7dQmojWPO","WPqlvvi0WOJcPa","rg/dOmkuF8kMgN3dJ0tdQG","W6BdKCktmmkqrglcHmko","WQK9CX3dLf7dSmoKdW","W6ldL8ktFmoXfMBcHmknW4qZW4i","W5aYW6bKWOLjWQ9iwCowxay","W4ygW6uHECopyq7cOmorWPtdSq","W5m2W6fTWOHiWPvHFSoazcu","hmkLWQRcMXStWOJdQCoxzCktpYG","zvVdImokWPpcSrvZ","W6tdLSkxFSo3Ae7cUmk9W5Gv","W6xcKmojiCklBv4","y8oKWR7dS8kDc8o0fdCeyCke","h8ovWRfoWPBdVhW","W6dcKXxdKrZdLe0V","ufZdKsHHaCoX","W7BcPMBdJxy9m8kg","W55Uje7cKXZcJmoahdTrW6RdPq","WP3dSmoYC1FdMSow","u1WsW63cHeBdV2iDW5zlW6jT","zCo6W7bfW69KpSobWPfSbh0","a8kknqDTpeXY","ps8/jmouW5L2lNu","cHLqWQZdG07dOW4SW7P3W5z5W5mikb/cPXtdSKldSgOaW7dcLq","fCo8W4VdJ2fIW74","WQWIWOZdImoYW57cJf0fW7JcUWis"];return(_0x4d6b=function(){return s})()}document.title="React 18异步批处理实现方式",document.getElementById("article").innerHTML='<div><p><strong>不是直接用 <code>Promise.then</code> 实现的</strong>   ，但<strong>最终效果</strong>   跟“把更新排进同一个微任务队列”非常接近，所以很多人会误以为 React 18 就是靠 <code>Promise.then</code> 做批处理。下面把内部机制拆开说清：</p>\n<hr>\n<h3>1. React 18 的批处理由谁驱动？</h3>\n<ul>\n<li><strong>调度器（Scheduler）</strong>   ：React 18 引入了新的并发特性，调度器会把所有同步代码跑完后，再把更新任务排进一个<strong>统一的微任务队列</strong>   。</li>\n<li><strong>内部用的是 <code>queueMicrotask</code> 或 <code>MessageChannel</code></strong>   ，而不是裸露的 <code>Promise.then</code>（虽然 <code>queueMicrotask</code> 和 <code>Promise.then</code> 都属于微任务）。</li>\n<li><strong>代码层面</strong>   ：React 的源码里用了一个叫 <code>scheduleMicrotask</code> 的封装，它会优先用 <code>queueMicrotask</code>，在不支持的环境中降级到 <code>Promise.then</code> 或 <code>MessageChannel</code>。</li>\n</ul>\n<hr>\n<h3>2. 为什么看起来像是 <code>Promise.then</code>？</h3>\n<ul>\n<li><strong>执行时机相同</strong>   ：因为微任务队列的特性，所有同步代码执行完后，<strong>微任务队列里的更新会被一次性处理</strong>   。这跟手动写：<pre><code class="language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">/* 批量处理所有更新 */</span>\n});\n</code></pre>\n的效果几乎一致，所以开发者常常感知为“React 用 Promise.then 做批处理”。</li>\n</ul>\n<hr>\n<h3>3. 验证实验</h3>\n<pre><code class="language-js"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);\n\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> c + <span class="hljs-number">1</span>);\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;同步日志&quot;</span>);\n\n    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;微任务日志&quot;</span>);\n    });\n\n    <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> c + <span class="hljs-number">1</span>);\n  };\n\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;渲染 Counter&quot;</span>, count);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n</code></pre>\n<p><strong>输出顺序（React 18）</strong>   ：</p>\n<ol>\n<li><code>渲染 Counter 0</code>（初始渲染）</li>\n<li>点击按钮：\n<ul>\n<li><code>同步日志</code></li>\n<li><code>渲染 Counter 2</code>（批处理后一次性更新）</li>\n<li><code>微任务日志</code></li>\n</ul>\n</li>\n</ol>\n<p>可以看到 <strong>React 的批处理发生在微任务阶段</strong>   ，但它是通过调度器管理的，而<strong>不是直接依赖 <code>Promise.then</code></strong>   。</p>\n<hr>\n<h3>结论</h3>\n<ul>\n<li><strong>实现上</strong>   ：React 18 用 <code>queueMicrotask</code>/<code>MessageChannel</code> 等更底层的 API，不直接写 <code>Promise.then</code>。</li>\n<li><strong>效果上</strong>   ：更新被推迟到<strong>当前宏任务结束后的微任务阶段</strong>   ，和 <code>Promise.then</code> 的执行时机一致，所以常被类比。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">var</span> scheduleTimeout = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">setTimeout</span> === <span class="hljs-string">&quot;function&quot;</span> ? <span class="hljs-built_in">setTimeout</span> : <span class="hljs-literal">undefined</span>;\n<span class="hljs-keyword">var</span> cancelTimeout =\n  <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">clearTimeout</span> === <span class="hljs-string">&quot;function&quot;</span> ? <span class="hljs-built_in">clearTimeout</span> : <span class="hljs-literal">undefined</span>;\n<span class="hljs-keyword">var</span> noTimeout = -<span class="hljs-number">1</span>;\n<span class="hljs-keyword">var</span> localPromise = <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Promise</span> === <span class="hljs-string">&quot;function&quot;</span> ? <span class="hljs-title class_">Promise</span> : <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// -------------------</span>\n<span class="hljs-keyword">var</span> scheduleMicrotask =\n  <span class="hljs-keyword">typeof</span> queueMicrotask === <span class="hljs-string">&quot;function&quot;</span>\n    ? queueMicrotask\n    : <span class="hljs-keyword">typeof</span> localPromise !== <span class="hljs-string">&quot;undefined&quot;</span>\n      ? <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) {\n          <span class="hljs-keyword">return</span> localPromise\n            .<span class="hljs-title function_">resolve</span>(<span class="hljs-literal">null</span>)\n            .<span class="hljs-title function_">then</span>(callback)\n            .<span class="hljs-title function_">catch</span>(handleErrorInNextTick);\n        }\n      : scheduleTimeout; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Determine the best fallback here.</span>\n</code></pre>\n</div>'</script></body></html>