<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x295e27=_0x529b;function _0x3d73(){var s=["kmovd8okA8o/lG","jCkdAH94huXECSoPW5O/","W6tcHf3dMmoJCCkVWQXhW4T/rGBdSG","eHlcM8oAnCkMDmkpzcFcJWRdVSoC","WOrYq3BdV1hcRCkDWQKoW5SD","s8oqntLkvhNcICkHfSkzW7Do","vmomW7hcTIJcOSoLW5ddL8kTm2y","WRC9W59/WO5NW4VcV0tdJSoNC8ot","g8kMWRjzmmk1lhCGWR8sWP4","dXVdKGhcSHjbBCkPWRVdNL82","W5iuW68ZBrBdSW","qSo7W6CoDmoSnvC","ehOKW5e9WPKHn8oWW4pcMLu","sCoXW7aMDmoGnW","F0tcOtpcJtuqW4WkiComza5RWRflkmkrWOa8kmkPW59MgfS","WOOuWONcLSos","m0jGvSovWRZdNsBdMW","WP0GW7dcRv7cRvT0W7yQW5GlWOy","WQdcV1rbsCoDkKHxWRz9WQ8e","W43cNW/cHmkhyuJcGvfEW7fKW6W","W4ilhmkRW4juW5W","W49tW4ZdK8kBW4rUiW7cK8oAW50"];return(_0x3d73=function(){return s})()}function _0x529b(t,s){var p=_0x3d73();return(_0x529b=function(s,n){var a=p[s-=349];void 0===_0x529b.XOehnm&&(_0x529b.QzzvZw=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=l.length;c<o;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[t],l[t]=a;for(var e=0,t=0,c=0;c<s.length;c++)a=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[t])%256]);return p},t=arguments,_0x529b.XOehnm=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x529b.BHgXOs&&(_0x529b.BHgXOs=!0),a=_0x529b.QzzvZw(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x529b,n=_0x3d73();;)try{if(321847==-parseInt(s(357,"*tW2"))+-parseInt(s(368,"6HvP"))/2+-parseInt(s(349,"mKOt"))/3*(parseInt(s(355,")7Bl"))/4)+-parseInt(s(367,"99un"))/5+parseInt(s(366,"D3AL"))/6+-parseInt(s(361,"uhuG"))/7+parseInt(s(351,"YVDb"))/8)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x295e27(362,"*tW2")](_0x295e27(365,"*[od"))!=_0x295e27(364,"JNhV"))throw window[_0x295e27(360,"*tW2")][_0x295e27(369,"YF(0")](_0x295e27(363,"2G&[")),Error();document.title="Promise 静态方法全解析",document.getElementById("article").innerHTML='<div><p>Promise 提供了多个静态方法来处理多个 Promise 实例的组合与协调，以下是所有 Promise 静态方法的详细说明：</p>\n<h2>一、核心静态方法</h2>\n<h3>1. <code>Promise.all(iterable)</code></h3>\n<p><strong>作用</strong>   ：等待所有 Promise 成功，或第一个失败</p>\n<p><strong>特点</strong>   ：</p>\n<ul>\n<li>输入值可以是任何可迭代对象</li>\n<li>返回值的顺序与输入顺序一致</li>\n<li>快速失败：任一 Promise 被拒绝立即拒绝</li>\n</ul>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> promises = [<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>), <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>), <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>)];\n\n<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises)\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values); <span class="hljs-comment">// [1, 2, 3]</span>\n  })\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);\n  });\n</code></pre>\n<h3>2. <code>Promise.allSettled(iterable)</code></h3>\n<p><strong>作用</strong>   ：等待所有 Promise 完成（无论成功或失败）</p>\n<p><strong>特点</strong>   ：</p>\n<ul>\n<li>不会拒绝，总是返回已完成状态</li>\n<li>每个结果对象包含 <code>status</code> 和 <code>value</code>/<code>reason</code></li>\n</ul>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> promises = [\n  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>),\n  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;Error&quot;</span>),\n  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>),\n];\n\n<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(promises).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results);\n  <span class="hljs-comment">/* [\n      { status: &#x27;fulfilled&#x27;, value: 1 },\n      { status: &#x27;rejected&#x27;, reason: &#x27;Error&#x27; },\n      { status: &#x27;fulfilled&#x27;, value: 3 }\n    ] */</span>\n});\n</code></pre>\n<h3>3. <code>Promise.race(iterable)</code></h3>\n<p><strong>作用</strong>   ：返回第一个落定（完成或拒绝）的 Promise</p>\n<p><strong>特点</strong>   ：</p>\n<ul>\n<li>可用于设置超时机制</li>\n<li>结果可能是完成或拒绝</li>\n</ul>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> timeout = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> {\n  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;Timeout&quot;</span>), <span class="hljs-number">1000</span>);\n});\n\n<span class="hljs-keyword">const</span> fetch = <span class="hljs-title function_">fetchData</span>(); <span class="hljs-comment">// 假设返回Promise</span>\n\n<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([fetch, timeout])\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据获取成功:&quot;</span>, data);\n  })\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;错误:&quot;</span>, error); <span class="hljs-comment">// 可能是超时或请求错误</span>\n  });\n</code></pre>\n<h3>4. <code>Promise.any(iterable)</code></h3>\n<p><strong>作用</strong>   ：返回第一个成功的 Promise（忽略拒绝，除非全部拒绝）</p>\n<p><strong>特点</strong>   ：</p>\n<ul>\n<li>ES2021 新增</li>\n<li>全部拒绝时抛出 <code>AggregateError</code></li>\n<li>适用于多备用方案场景</li>\n</ul>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> servers = [\n  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://server1.com&quot;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> {}),\n  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://server2.com&quot;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> {}),\n  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://server3.com&quot;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> {}),\n];\n\n<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>(servers)\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;最先响应的服务器:&quot;</span>, response.<span class="hljs-property">url</span>);\n  })\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;所有服务器都失败了:&quot;</span>, error.<span class="hljs-property">errors</span>);\n  });\n</code></pre>\n<h2>二、工具型静态方法</h2>\n<h3>5. <code>Promise.resolve(value)</code></h3>\n<p><strong>作用</strong>   ：返回一个已解析的 Promise 对象</p>\n<p><strong>使用场景</strong>   ：</p>\n<ul>\n<li>将值包装为 Promise</li>\n<li>开始 Promise 链</li>\n</ul>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 将同步值转为Promise</span>\n<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">42</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)); <span class="hljs-comment">// 42</span>\n\n<span class="hljs-comment">// 处理可能同步/异步的函数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> cachedData ? <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(cachedData) : <span class="hljs-title function_">asyncFetch</span>();\n}\n</code></pre>\n<h3>6. <code>Promise.reject(reason)</code></h3>\n<p><strong>作用</strong>   ：返回一个已拒绝的 Promise 对象</p>\n<p><strong>使用场景</strong>   ：</p>\n<ul>\n<li>创建立即拒绝的 Promise</li>\n<li>在链式调用中抛出错误</li>\n</ul>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Failed&quot;</span>)).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));\n\n<span class="hljs-comment">// 在条件不满足时提前终止链</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">getUser</span>(<span class="hljs-params">id</span>) {\n  <span class="hljs-keyword">if</span> (!id) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;Invalid ID&quot;</span>);\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/users/<span class="hljs-subst">${id}</span>`</span>);\n}\n</code></pre>\n<h2>三、方法对比总结</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>等待条件</th>\n<th>返回值</th>\n<th>拒绝条件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Promise.all</code></td>\n<td>所有成功</td>\n<td>值数组</td>\n<td>任一失败</td>\n</tr>\n<tr>\n<td><code>Promise.allSettled</code></td>\n<td>全部完成</td>\n<td>结果数组</td>\n<td>永不拒绝</td>\n</tr>\n<tr>\n<td><code>Promise.race</code></td>\n<td>第一个落定</td>\n<td>第一个结果</td>\n<td>可能拒绝</td>\n</tr>\n<tr>\n<td><code>Promise.any</code></td>\n<td>第一个成功</td>\n<td>第一个成功值</td>\n<td>全部失败</td>\n</tr>\n<tr>\n<td><code>Promise.resolve</code></td>\n<td>-</td>\n<td>解析值</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>Promise.reject</code></td>\n<td>-</td>\n<td>-</td>\n<td>拒绝原因</td>\n</tr>\n</tbody>\n</table>\n<h2>四、高级使用模式</h2>\n<h3>1. 组合使用</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 超时+批量请求</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchWithTimeout</span>(<span class="hljs-params">urls, timeout = <span class="hljs-number">5000</span></span>) {\n  <span class="hljs-keyword">const</span> timeoutPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> {\n    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;Timeout&quot;</span>), timeout);\n  });\n\n  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([\n    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(urls.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">url</span>) =&gt;</span> <span class="hljs-title function_">fetch</span>(url))),\n    timeoutPromise,\n  ]);\n}\n</code></pre>\n<h3>2. 渐进加载</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 优先使用缓存，同时更新数据</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([<span class="hljs-title function_">getFromCache</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> {}), <span class="hljs-title function_">fetchFromNetwork</span>()]);\n}\n</code></pre>\n<h3>3. 错误分类处理</h3>\n<pre><code class="language-javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(requests).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> successes = results\n    .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> r.<span class="hljs-property">status</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)\n    .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> r.<span class="hljs-property">value</span>);\n\n  <span class="hljs-keyword">const</span> errors = results\n    .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> r.<span class="hljs-property">status</span> === <span class="hljs-string">&quot;rejected&quot;</span>)\n    .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> r.<span class="hljs-property">reason</span>);\n\n  <span class="hljs-keyword">if</span> (errors.<span class="hljs-property">length</span>) {\n    <span class="hljs-title function_">logErrors</span>(errors);\n  }\n  <span class="hljs-keyword">return</span> successes;\n});\n</code></pre>\n<h2>五、注意事项</h2>\n<ol>\n<li>\n<p><strong>输入处理</strong>   ：</p>\n<ul>\n<li>非 Promise 值会被 <code>Promise.resolve()</code> 包装</li>\n<li>空迭代对象：\n<ul>\n<li><code>Promise.all([])</code> 立即完成</li>\n<li><code>Promise.any([])</code> 立即拒绝</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>性能影响</strong>   ：</p>\n<ul>\n<li>未被采用的 Promise 仍会继续执行</li>\n<li>大量 Promise 需考虑内存占用</li>\n</ul>\n</li>\n<li>\n<p><strong>取消问题</strong>   ：</p>\n<ul>\n<li>原生 Promise 不支持取消</li>\n<li>可考虑 AbortController 或第三方库</li>\n</ul>\n</li>\n<li>\n<p><strong>浏览器兼容性</strong>   ：</p>\n<ul>\n<li><code>Promise.any()</code> 需要较新浏览器</li>\n<li>旧环境需要 polyfill</li>\n</ul>\n</li>\n</ol>\n<h2>六、Polyfill 示例</h2>\n<pre><code class="language-javascript"><span class="hljs-comment">// Promise.allSettled polyfill</span>\n<span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Promise</span>.<span class="hljs-property">allSettled</span>) {\n  <span class="hljs-title class_">Promise</span>.<span class="hljs-property">allSettled</span> = <span class="hljs-function">(<span class="hljs-params">promises</span>) =&gt;</span>\n    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(\n      promises.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span>\n        promise\n          .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> ({ <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;fulfilled&quot;</span>, value }))\n          .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> ({ <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;rejected&quot;</span>, reason })),\n      ),\n    );\n}\n\n<span class="hljs-comment">// Promise.any polyfill</span>\n<span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Promise</span>.<span class="hljs-property">any</span>) {\n  <span class="hljs-title class_">Promise</span>.<span class="hljs-property">any</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n      <span class="hljs-keyword">const</span> errors = [];\n      <span class="hljs-keyword">let</span> rejectedCount = <span class="hljs-number">0</span>;\n\n      promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> {\n        <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise)\n          .<span class="hljs-title function_">then</span>(resolve)\n          .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n            errors[index] = error;\n            <span class="hljs-keyword">if</span> (++rejectedCount === promises.<span class="hljs-property">length</span>) {\n              <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(errors, <span class="hljs-string">&quot;All promises were rejected&quot;</span>));\n            }\n          });\n      });\n    });\n  };\n}\n</code></pre>\n<p>这些静态方法为 Promise 提供了强大的组合能力，合理使用可以优雅地处理复杂的异步流程控制。</p>\n</div>'</script></body></html>