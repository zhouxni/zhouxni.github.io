<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x17b4b9=_0x2420;function _0x2420(l,s){var e=_0x26a1();return(_0x2420=function(s,n){var a=e[s-=148];void 0===_0x2420.xcZaDe&&(_0x2420.RPVSMn=function(s,n){var a,t=[],l=0,e="";for(s=(s=>{for(var n,a,t="",l="",e=0,r=0;a=s.charAt(r++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,o=t.length;p<o;p++)l+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(l)})(s),r=0;r<256;r++)t[r]=r;for(r=0;r<256;r++)l=(l+t[r]+n.charCodeAt(r%n.length))%256,a=t[r],t[r]=t[l],t[l]=a;for(var r=0,l=0,p=0;p<s.length;p++)a=t[r=(r+1)%256],t[r]=t[l=(l+t[r])%256],t[l]=a,e+=String.fromCharCode(s.charCodeAt(p)^t[(t[r]+t[l])%256]);return e},l=arguments,_0x2420.xcZaDe=!0);var s=s+e[0],t=l[s];return t?a=t:(void 0===_0x2420.KsczFU&&(_0x2420.KsczFU=!0),a=_0x2420.RPVSMn(a,n),l[s]=a),a})(l,s)}function _0x26a1(){var s=["yvvVC8oan8k0W7BdMtxcMmoZW7S","WOlcGf4djdm+W6u6WOvzW4hcMW","W4SgW6JcJSoigqdcRq","z8ooENBdV8kIWQvvW54xDSkyWRq","WOG3WPRcT1VcGKG","W77dQcbNg8kdv8kN","AI8lrr1CAfO","W7hcKZLaWRf8WRhdUeO","qmk/ySovBmkyW7K6w8oThmoXj8ky","WOFdIwGCWQzNWRddUgPu","W7f+BSkJW4tdKghdO8oKWRW0WPS","CaKllSokWOhdGG","hSk8W4BdHSoZWPBcUJhdKmo5ocdcIa","W7b3cSotWRFcGutdUq","W4THWOywW75UW7ZcN8kUW7JdPLvLW5CYWPrhj8kriColW4WpWQBdVSoG","EuChFe7cMSoyW48CWQuQWOu","ohNcRIZcPSoZvdnYie4jvmk7","pLGfWP7dGJStW7m1aNtcT3S","WPBdSXbTBbnM","WQLNW7m6mMZcMb8","EtxdQ23dPG","AKb9pdVdHWae","WRtdJ39cnSkhW6FdI8ktWRTE","k03cMYCaW5VdG8oYxYNdTYBcVq","WQLJWPvgzwlcNGVdMG/dRG","W4yyW446mYGSWQu","ACofEhldTSoAW5TTW7qgrW","W7ethmoBWOBcS3y","W6qXW43cNmoZBmkgESolfa"];return(_0x26a1=function(){return s})()}if((()=>{for(var s=_0x2420,n=_0x26a1();;)try{if(879569==-parseInt(s(171,"QfJI"))+-parseInt(s(167,"6[MY"))/2*(parseInt(s(154,"v3dJ"))/3)+-parseInt(s(149,"UpE1"))/4+-parseInt(s(162,"cE2E"))/5*(-parseInt(s(166,"8m*C"))/6)+-parseInt(s(173,"5g7["))/7*(parseInt(s(150,"WPwV"))/8)+-parseInt(s(160,"7Icg"))/9*(-parseInt(s(156,"Y9UC"))/10)+-parseInt(s(148,"oTZm"))/11*(-parseInt(s(151,"Y9UC"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x17b4b9(172,"70mQ")](_0x17b4b9(168,"Ja3F"))!=_0x17b4b9(152,"oTZm"))throw window[_0x17b4b9(163,"4(Ca")][_0x17b4b9(165,"r^jQ")](_0x17b4b9(175,"K315")),Error();document.title=" Fetch 与 XMLHttpRequest 的关系解析",document.getElementById("article").innerHTML='<div><p>Fetch API 和 XMLHttpRequest (XHR) 都是浏览器提供的用于发起网络请求的 JavaScript API，但它们之间存在重要区别和演进关系。</p>\n<h2>核心关系</h2>\n<ol>\n<li>\n<p><strong>非继承关系</strong>   ：</p>\n<ul>\n<li>Fetch <strong>不是</strong>   基于 XMLHttpRequest 构建的</li>\n<li>两者是浏览器网络层的<strong>并行实现</strong>   ，有各自独立的底层实现</li>\n</ul>\n</li>\n<li>\n<p><strong>设计代际差异</strong>   ：</p>\n<ul>\n<li>XMLHttpRequest：1999年提出，2006年标准化</li>\n<li>Fetch API：2015年引入的现代替代方案</li>\n</ul>\n</li>\n</ol>\n<h2>技术对比</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Fetch API</th>\n<th>XMLHttpRequest</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>设计范式</strong></td>\n<td>Promise-based</td>\n<td>事件回调机制</td>\n</tr>\n<tr>\n<td><strong>请求初始化</strong></td>\n<td><code>fetch(url, options)</code></td>\n<td><code>new XMLHttpRequest()</code> + 配置</td>\n</tr>\n<tr>\n<td><strong>响应处理</strong></td>\n<td>链式Promise调用</td>\n<td>事件监听(onload, onerror等)</td>\n</tr>\n<tr>\n<td><strong>数据格式</strong></td>\n<td>内置对JSON、Blob等支持</td>\n<td>需手动处理响应数据</td>\n</tr>\n<tr>\n<td><strong>流式读取</strong></td>\n<td>原生支持ReadableStream</td>\n<td>需手动实现分块读取</td>\n</tr>\n<tr>\n<td><strong>CORS处理</strong></td>\n<td>更严格的默认安全策略</td>\n<td>较宽松的默认行为</td>\n</tr>\n<tr>\n<td><strong>请求取消</strong></td>\n<td>通过AbortController</td>\n<td>直接调用abort()方法</td>\n</tr>\n<tr>\n<td><strong>进度跟踪</strong></td>\n<td>需手动实现</td>\n<td>原生支持progress事件</td>\n</tr>\n<tr>\n<td><strong>HTTP/2支持</strong></td>\n<td>原生支持</td>\n<td>有限支持</td>\n</tr>\n<tr>\n<td><strong>请求优先级</strong></td>\n<td>实验性支持</td>\n<td>不支持</td>\n</tr>\n</tbody>\n</table>\n<h2>底层实现差异</h2>\n<h3>XMLHttpRequest 底层</h3>\n<pre><code class="language-mermaid">sequenceDiagram\n    JS代码-&gt;&gt;XHR对象: 创建实例\n    XHR对象-&gt;&gt;浏览器网络层: 封装请求\n    浏览器网络层-&gt;&gt;操作系统: TCP连接\n    操作系统--&gt;&gt;浏览器网络层: 响应数据\n    浏览器网络层-&gt;&gt;XHR对象: 触发事件\n    XHR对象-&gt;&gt;JS代码: onload/onerror回调\n</code></pre>\n<h3>Fetch API 底层</h3>\n<pre><code class="language-mermaid">sequenceDiagram\n    JS代码-&gt;&gt;Fetch API: 发起请求\n    Fetch API-&gt;&gt;网络进程: 创建任务\n    网络进程-&gt;&gt;操作系统: HTTP/2或QUIC连接\n    操作系统--&gt;&gt;网络进程: 流式响应\n    网络进程-&gt;&gt;Fetch API: 返回Promise\n    Fetch API-&gt;&gt;JS代码: then/catch处理\n</code></pre>\n<h2>为什么需要 Fetch API？</h2>\n<ol>\n<li>\n<p><strong>更现代的异步模型</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// Fetch (Promise链)</span>\n<span class="hljs-title function_">fetch</span>(url)\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.<span class="hljs-title function_">json</span>())\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));\n\n<span class="hljs-comment">// XHR (事件回调)</span>\n<span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();\nxhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>));\n  }\n};\nxhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Request failed&quot;</span>);\n};\nxhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url);\nxhr.<span class="hljs-title function_">send</span>();\n</code></pre>\n</li>\n<li>\n<p><strong>更合理的默认行为</strong>   ：</p>\n<ul>\n<li>Fetch 默认不会发送/接收 cookies（需显式设置<code>credentials</code>）</li>\n<li>Fetch 对CORS的处理更严格</li>\n</ul>\n</li>\n<li>\n<p><strong>更好的流式支持</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// Fetch流式处理</span>\n<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);\n<span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();\n\n<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n  <span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();\n  <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">break</span>;\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 处理数据块</span>\n}\n</code></pre>\n</li>\n</ol>\n<h2>实际开发中的选择建议</h2>\n<h3>使用 Fetch 当：</h3>\n<ul>\n<li>需要简洁的Promise语法</li>\n<li>处理现代Web API（如Service Worker）</li>\n<li>需要流式处理大文件</li>\n<li>项目不需要支持老旧浏览器</li>\n</ul>\n<h3>使用 XMLHttpRequest 当：</h3>\n<ul>\n<li>需要精确的上传/下载进度跟踪</li>\n<li>需要支持IE11等老旧浏览器</li>\n<li>项目已有大量基于XHR的代码</li>\n<li>需要更细粒度的请求控制</li>\n</ul>\n<h2>互操作方案</h2>\n<h3>1. Fetch 转 XHR 风格</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchWithProgress</span>(<span class="hljs-params">url, onProgress</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();\n    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url);\n    xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;blob&quot;</span>;\n\n    xhr.<span class="hljs-property">onprogress</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n      <span class="hljs-keyword">if</span> (event.<span class="hljs-property">lengthComputable</span>) {\n        <span class="hljs-title function_">onProgress</span>(event.<span class="hljs-property">loaded</span> / event.<span class="hljs-property">total</span>);\n      }\n    };\n\n    xhr.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(xhr.<span class="hljs-property">response</span>);\n    xhr.<span class="hljs-property">onerror</span> = reject;\n    xhr.<span class="hljs-title function_">send</span>();\n  });\n}\n</code></pre>\n<h3>2. XHR 转 Promise</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">xhrToPromise</span>(<span class="hljs-params">url</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();\n    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url);\n    xhr.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(xhr.<span class="hljs-property">responseText</span>);\n    xhr.<span class="hljs-property">onerror</span> = reject;\n    xhr.<span class="hljs-title function_">send</span>();\n  });\n}\n</code></pre>\n<h2>演进趋势</h2>\n<ol>\n<li>\n<p><strong>Fetch 是未来标准</strong>   ：</p>\n<ul>\n<li>已被所有现代浏览器支持</li>\n<li>成为Web平台的基础设施（如Service Worker）</li>\n<li>正在扩展更多功能（如请求优先级、缓存控制）</li>\n</ul>\n</li>\n<li>\n<p><strong>XHR 的现状</strong>   ：</p>\n<ul>\n<li>仍被广泛使用（特别是需要进度跟踪的场景）</li>\n<li>浏览器会长期保持兼容</li>\n<li>不再有新功能开发</li>\n</ul>\n</li>\n</ol>\n<p>理解两者的关系和区别，有助于在不同场景选择最合适的网络请求方案。</p>\n</div>'</script></body></html>