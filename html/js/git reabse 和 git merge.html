<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x417bd1=_0x5d2c;function _0x3981(){var n=["v0TcWO3cK8ofjxuNza","W6CMxeHrfmk8","uuXcWOVdMCk0vxuKt8o+jSou","WPpdNrOLs1bdprZcQcOk","W6tdOCk5ibJcNmkeW53dH8kXFCoV","BaZdPSoaWRldSuPE","hCkZEfyHgmo0BCk4lq","WRfUyCksfCoKW7ZdG1ODWPddGx8","WRpcNmkBrNvYDCo5W5/cOWxcGqC","W6NcICkcWQhcJXpdK3G","WPmuCg7dJ8ohdSoT","xrqJCmoLWQ00hCo4jG","cSk8hYWdWO1QWPBdNW","W6FcIKb0cXfQpGO","WOOAW4BcKw5pumkSWQBdVmocW4q","t8oYx3WbsmoBW6uO","cSk6h39sW79vWOxdGbtdUSoN","WO/cNmkWW6ddLCoTWR0RWROAWPO/","jarOfmkwdeNdNqNcPCoNWPS","k3hdL8kxW65Fh8kSWPjMr0S","iSkJWRmyW4pcTsq","WPhdNbiKcIrJlXFcMq","W6NdMCoCadvWASkAW6BcPG/cSI5ZW7tdTWBcKxZdUSkXhs/cVZjy","iCoWWQhcNti","W7GcW6pdN8o0W5KcWQxcGSoDAG/dKG"];return(_0x3981=function(){return n})()}function _0x5d2c(r,n){var s=_0x3981();return(_0x5d2c=function(n,e){var o=s[n-=497];void 0===_0x5d2c.MVgeDl&&(_0x5d2c.eMGNJj=function(n,e){var o,t=[],r=0,s="";for(n=(n=>{for(var e,o,t="",r="",s=0,c=0;o=n.charAt(c++);~o&&(e=s%4?64*e+o:o,s++%4)&&(t+=String.fromCharCode(255&e>>(-2*s&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var g=0,d=t.length;g<d;g++)r+="%"+("00"+t.charCodeAt(g).toString(16)).slice(-2);return decodeURIComponent(r)})(n),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)r=(r+t[c]+e.charCodeAt(c%e.length))%256,o=t[c],t[c]=t[r],t[r]=o;for(var c=0,r=0,g=0;g<n.length;g++)o=t[c=(c+1)%256],t[c]=t[r=(r+t[c])%256],t[r]=o,s+=String.fromCharCode(n.charCodeAt(g)^t[(t[c]+t[r])%256]);return s},r=arguments,_0x5d2c.MVgeDl=!0);var n=n+s[0],t=r[n];return t?o=t:(void 0===_0x5d2c.BgrtWB&&(_0x5d2c.BgrtWB=!0),o=_0x5d2c.eMGNJj(o,e),r[n]=o),o})(r,n)}if((()=>{for(var n=_0x5d2c,e=_0x3981();;)try{if(429384==-parseInt(n(517,"g#PJ"))*(parseInt(n(509,"ML&j"))/2)+parseInt(n(501,"7muk"))/3+-parseInt(n(503,"8WQ&"))/4+parseInt(n(518,"fbJX"))/5+parseInt(n(514,"UY0$"))/6*(parseInt(n(513,"d3(@"))/7)+-parseInt(n(510,"QqaR"))/8*(-parseInt(n(520,"(K%n"))/9)+-parseInt(n(507,"1wzf"))/10)break;e.push(e.shift())}catch(n){e.push(e.shift())}})(),localStorage[_0x417bd1(500,"$MP8")](_0x417bd1(512,"(K%n"))!=_0x417bd1(497,"%yT["))throw window[_0x417bd1(504,"iTGL")][_0x417bd1(519,"gaqq")](_0x417bd1(521,"1wzf")),Error();document.title="git reabse 和 git merge",document.getElementById("article").innerHTML='<div><p><code>git merge</code> 和 <code>git rebase</code> 是 Git 中整合分支的两种核心策略，它们的本质区别在于 <strong>如何将分支历史记录合并到目标分支</strong>  。以下是深度解析，结合原理、工作流和实际场景说明：</p>\n<hr>\n<h3><strong>一、本质区别（底层原理）</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>维度</strong></th>\n<th><code>git merge</code></th>\n<th><code>git rebase</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>操作原理</strong></td>\n<td>创建新的合并提交（Merge Commit），保留原始分支结构</td>\n<td>将提交复制到目标分支末端，重写历史</td>\n</tr>\n<tr>\n<td><strong>历史记录</strong></td>\n<td>保留分支的并行结构，形成&quot;分叉-合并&quot;的图形</td>\n<td>生成线性历史，隐藏原始分支痕迹</td>\n</tr>\n<tr>\n<td><strong>冲突处理</strong></td>\n<td>在合并时一次性解决所有冲突</td>\n<td>在复制每个提交时可能重复解决冲突</td>\n</tr>\n<tr>\n<td><strong>提交哈希值</strong></td>\n<td>保留原提交的哈希值不变</td>\n<td>生成全新的提交哈希值（历史被重写）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>二、工作流对比（图文解析）</strong></h3>\n<h4><strong>初始分支状态</strong></h4>\n<pre><code>      A---B---C  feature\n     /\nD---E---F        main\n</code></pre>\n<h4><strong>1. 使用 <code>git merge</code> 后</strong></h4>\n<pre><code class="language-sh">git checkout main\ngit merge feature\n</code></pre>\n<p><strong>历史记录</strong>  ：</p>\n<pre><code>      A---B---C  feature\n     /         \\\nD---E---F-------G  main\n</code></pre>\n<ul>\n<li><strong>特点</strong>  ：生成新的合并提交 <code>G</code>，保留 <code>feature</code> 分支的独立历史。</li>\n</ul>\n<h4><strong>2. 使用 <code>git rebase</code> 后</strong></h4>\n<pre><code class="language-sh">git checkout feature\ngit rebase main\ngit checkout main\ngit merge feature  <span class="hljs-comment"># 此时是快进合并（FF）</span>\n</code></pre>\n<p><strong>历史记录</strong>  ：</p>\n<pre><code>D---E---F---A\'---B\'---C\'  main (feature)\n</code></pre>\n<ul>\n<li><strong>特点</strong>  ：<code>feature</code> 的提交被复制为 <code>A\'</code>、<code>B\'</code>、<code>C\'</code>，形成直线历史。</li>\n</ul>\n<hr>\n<h3><strong>三、核心使用场景</strong></h3>\n<h4><strong>何时用 <code>merge</code>？</strong></h4>\n<ul>\n<li><strong>公共分支整合</strong>  （如 <code>main</code> 合并 <code>feature</code>）</li>\n<li><strong>需要保留完整开发历史</strong>  （例如团队协作时）</li>\n<li><strong>避免重写历史</strong>  （防止影响他人基于原分支的开发）</li>\n</ul>\n<h4><strong>何时用 <code>rebase</code>？</strong></h4>\n<ul>\n<li><strong>整理本地分支提交</strong>  （如压缩、编辑提交信息）</li>\n<li><strong>更新本地分支基础</strong>  （避免不必要的合并提交）</li>\n<li><strong>需要清晰线性历史</strong>  （便于代码审查或故障排查）</li>\n</ul>\n<hr>\n<h3><strong>四、冲突处理差异</strong></h3>\n<h4><strong><code>git merge</code> 冲突</strong></h4>\n<ul>\n<li><strong>触发时机</strong>  ：仅在合并提交时一次性解决</li>\n<li><strong>解决流程</strong>  ：</li>\n</ul>\n<pre><code class="language-sh">git merge feature\n<span class="hljs-comment"># 手动解决冲突后</span>\ngit add &lt;冲突文件&gt;\ngit commit  <span class="hljs-comment"># 生成合并提交</span>\n</code></pre>\n<h4><strong><code>git rebase</code> 冲突</strong></h4>\n<ul>\n<li><strong>触发时机</strong>  ：可能在复制每个提交时重复出现</li>\n<li><strong>解决流程</strong>  ：</li>\n</ul>\n<pre><code class="language-sh">git rebase main\n<span class="hljs-comment"># 遇到冲突时...</span>\ngit add &lt;冲突文件&gt;\ngit rebase --<span class="hljs-built_in">continue</span>  <span class="hljs-comment"># 继续处理下一个提交</span>\ngit rebase --abort     <span class="hljs-comment"># 放弃变基</span>\n</code></pre>\n<hr>\n<h3><strong>五、风险与最佳实践</strong></h3>\n<h4><strong><code>rebase</code> 的黄金法则</strong></h4>\n<blockquote>\n<p><strong>永远不要对已推送到远程的公共分支执行变基</strong><br>\n（否则会强制其他协作者重新同步分支，导致混乱）</p>\n</blockquote>\n<h4><strong>推荐工作流</strong></h4>\n<ol>\n<li><strong>本地开发分支</strong>  ：优先使用 <code>rebase</code> 保持历史整洁<pre><code class="language-sh">git checkout feature\ngit rebase main\n</code></pre>\n</li>\n<li><strong>合并到主分支</strong>  ：始终使用 <code>merge</code> 保留历史<pre><code class="language-sh">git checkout main\ngit merge --no-ff feature  <span class="hljs-comment"># 禁用快进合并</span>\n</code></pre>\n</li>\n<li><strong>更新本地分支</strong>  ：用 <code>rebase</code> 替代 <code>pull</code><pre><code class="language-sh">git pull --rebase origin main  <span class="hljs-comment"># 相当于 fetch + rebase</span>\n</code></pre>\n</li>\n</ol>\n<hr>\n<h3><strong>六、高级技巧</strong></h3>\n<h4><strong>1. 交互式变基（整理提交历史）</strong></h4>\n<pre><code class="language-sh">git rebase -i HEAD~3  <span class="hljs-comment"># 编辑最近3个提交</span>\n</code></pre>\n<ul>\n<li><strong>操作选项</strong>  ：\n<ul>\n<li><code>squash</code>：合并提交</li>\n<li><code>edit</code>：修改提交</li>\n<li><code>reword</code>：更改提交信息</li>\n</ul>\n</li>\n</ul>\n<h4><strong>2. 合并时保留分支拓扑</strong></h4>\n<pre><code class="language-sh">git merge --no-ff feature  <span class="hljs-comment"># 强制生成合并节点</span>\n</code></pre>\n<p><strong>效果</strong>  ：即使能快进合并，也显式保留分支合并记录。</p>\n<h4><strong>3. 从变基中恢复</strong></h4>\n<pre><code class="language-sh">git reflog                  <span class="hljs-comment"># 找到变基前的提交哈希</span>\ngit reset --hard HEAD@{1}   <span class="hljs-comment"># 回退到变基前状态</span>\n</code></pre>\n<hr>\n<h3><strong>七、企业级开发建议</strong></h3>\n<ol>\n<li><strong>团队规范</strong>  ：</li>\n</ol>\n<ul>\n<li>主分支（<code>main</code>/<code>master</code>）只允许 <code>merge --no-ff</code></li>\n<li>功能分支在推送前需用 <code>rebase</code> 整理历史</li>\n</ul>\n<ol start="2">\n<li><strong>代码审查</strong>  ：</li>\n</ol>\n<ul>\n<li>线性历史（<code>rebase</code>）更易追踪修改</li>\n<li>合并提交（<code>merge</code>）明确记录功能边界</li>\n</ul>\n<ol start="3">\n<li><strong>CI/CD 集成</strong>  ：</li>\n</ol>\n<ul>\n<li>确保 CI 系统能处理 <code>merge</code> 和 <code>rebase</code> 两种策略</li>\n</ul>\n<hr>\n<h3><strong>总结：选择决策树</strong></h3>\n<pre><code class="language-mermaid">graph TD\n    A[需要整合分支] --&gt; B{是否已推送远程?}\n    B --&gt;|是| C[使用 git merge]\n    B --&gt;|否| D{需要线性历史?}\n    D --&gt;|是| E[使用 git rebase]\n    D --&gt;|否| C\n</code></pre>\n<p>掌握两者的差异后，可根据团队规范灵活选择，最终目标是 <strong>既保持历史可读性，又不破坏协作流程</strong>  。</p>\n</div>'</script></body></html>