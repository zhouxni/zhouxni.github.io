<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x431637=_0x370a;function _0x370a(l,s){var p=_0x3e99();return(_0x370a=function(s,n){var a=p[s-=107];void 0===_0x370a.gjLXBZ&&(_0x370a.ZLgbzR=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,o=t.length;r<o;r++)l+="%"+("00"+t.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,r=0;r<s.length;r++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(r)^t[(t[e]+t[l])%256]);return p},l=arguments,_0x370a.gjLXBZ=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x370a.BDICug&&(_0x370a.BDICug=!0),a=_0x370a.ZLgbzR(a,n),l[s]=a),a})(l,s)}function _0x3e99(){var s=["eCkEbCkGW4/cISkPCG","WRFdLCoDW67dQGv0CW","pmoYW7FdJZRdQ8oQemomy8kFuG","WRFdKCk9WRVcU3yjtSkeuspdLL4","oSk2c8kpWOCnwIr6W5Dyaq","vmoricVdUmkJDCkoW5BdKbRdVa","WPFcLmoVbSkIptfu","phmxEbFdOtxcQKiOW5nugW","p8kCWRFdHmo0","nhqzDbxdQ2ZcL1mNW6XW","WP/dNSkeemkIW4K/","W6TvW7VdH8oEW6NcKW0hx8okW48","WO/cRuVdTCojy8kcsmkKWQLSlq","W59ZWOaQxWZcLvW","h8kis29FWRzv","k33cNI7cPtifBgisW6vk","hCk3W4BdP8kMwueK","WOCoW6u3pWWpWOm","ws3dIxVdPNuGxu8","W5H7W6rkiWBdRCkcqmo5W67cJW","ighcOmohWOZdIdJdSCo7W4umWPL9ja","WQq9WQ5iBCovW77dUa","CupdVmk6WQVdG8kpdeRcGKT/WP/cOsLnnwSBW6xcLxLFWO7cPM8","tmobmmkGW5NcQmkktW","WPJdP2/cGt82WOhcSmkpWPZcSghcNmoE","gmkzzSoYWP/dSCkatSkWWQXUW70","W6LxWONcSCkQWQFcJqO","W65iCqlcHehcOK4","yh/dSmk7h8kLDqO","W6GYy8kcgmoSW4epW7NdQ1qV"];return(_0x3e99=function(){return s})()}if((()=>{for(var s=_0x370a,n=_0x3e99();;)try{if(741867==-parseInt(s(135,"4ub^"))+-parseInt(s(112,"WMUY"))/2+parseInt(s(121,")lQK"))/3*(parseInt(s(111,"1A^Y"))/4)+-parseInt(s(129,"IOL0"))/5*(parseInt(s(117,"pk16"))/6)+parseInt(s(119,"@y@G"))/7*(parseInt(s(128,"i1qq"))/8)+-parseInt(s(107,"!OK8"))/9*(parseInt(s(131,"#RuG"))/10)+parseInt(s(127,"gga&"))/11*(parseInt(s(124,"M!o*"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x431637(110,"xNDs")](_0x431637(118,"iPyW"))!=_0x431637(108,"PBdT"))throw window[_0x431637(123,"XYUy")][_0x431637(114,"68Kk")](_0x431637(122,"o**[")),Error();document.title="@tanstack--react-query 详解",document.getElementById("article").innerHTML='<div><h3><strong>@tanstack/react-query 详解</strong></h3>\n<p><strong><code>@tanstack/react-query</code></strong>   （原 <code>react-query</code>）是 React 生态中最强大的<strong>服务器状态管理库</strong>   ，专为高效的数据获取、缓存、同步和更新而设计。它完美替代了传统的 <code>useEffect</code> + <code>fetch</code> 模式，适用于 Next.js、Remix、Vite 等现代 React 框架。</p>\n<hr>\n<h2><strong>一、核心概念</strong></h2>\n<h3><strong>1. 为什么需要 React Query？</strong></h3>\n<ul>\n<li><strong>问题</strong>   ：传统的 <code>useEffect</code> + <code>fetch</code> 存在以下痛点：\n<ul>\n<li>手动管理加载状态（<code>isLoading</code>、<code>isError</code>）。</li>\n<li>重复请求相同数据（缓存失效问题）。</li>\n<li>复杂的分页、无限加载、后台数据更新逻辑。</li>\n</ul>\n</li>\n<li><strong>解决方案</strong>   ：\n<ul>\n<li><strong>自动缓存</strong>   ：相同查询的请求自动去重。</li>\n<li><strong>后台刷新</strong>   ：数据过期时自动重新获取。</li>\n<li><strong>乐观更新</strong>   ：先更新 UI，再确认服务器状态。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>2. 核心功能</strong></h3>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>查询（Queries）</strong></td>\n<td>获取数据（GET 请求）</td>\n</tr>\n<tr>\n<td><strong>变更（Mutations）</strong></td>\n<td>修改数据（POST/PUT/DELETE）</td>\n</tr>\n<tr>\n<td><strong>缓存管理</strong></td>\n<td>自动缓存数据，减少重复请求</td>\n</tr>\n<tr>\n<td><strong>后台同步</strong></td>\n<td>数据过期时自动重新获取</td>\n</tr>\n<tr>\n<td><strong>乐观更新</strong></td>\n<td>先更新 UI，再同步到服务器</td>\n</tr>\n<tr>\n<td><strong>分页 &amp; 无限加载</strong></td>\n<td>内置 <code>useInfiniteQuery</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>二、安装与基本配置</strong></h2>\n<h3><strong>1. 安装</strong></h3>\n<pre><code class="language-bash">npm install @tanstack/react-query\n<span class="hljs-comment"># 或</span>\nyarn add @tanstack/react-query\n</code></pre>\n<h3><strong>2. 设置 QueryClient</strong></h3>\n<p>在应用根组件（如 <code>app/layout.tsx</code>）中配置 <code>QueryClientProvider</code>：</p>\n<pre><code class="language-tsx"><span class="hljs-comment">// app/layout.tsx</span>\n<span class="hljs-string">&quot;use client&quot;</span>;\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">QueryClient</span>, <span class="hljs-title class_">QueryClientProvider</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@tanstack/react-query&quot;</span>;\n\n<span class="hljs-keyword">const</span> queryClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryClient</span>();\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RootLayout</span>(<span class="hljs-params">{\n  children,\n}: {\n  children: React.ReactNode;\n}</span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">QueryClientProvider</span> <span class="hljs-attr">client</span>=<span class="hljs-string">{queryClient}</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">QueryClientProvider</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<hr>\n<h2><strong>三、数据查询（Queries）</strong></h2>\n<h3><strong>1. 基本查询 (<code>useQuery</code>)</strong></h3>\n<pre><code class="language-tsx"><span class="hljs-keyword">import</span> { useQuery } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@tanstack/react-query&quot;</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchPosts</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/posts&quot;</span>);\n  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();\n};\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">PostsList</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> {\n    data, <span class="hljs-comment">// 数据</span>\n    isLoading, <span class="hljs-comment">// 是否正在加载</span>\n    isError, <span class="hljs-comment">// 是否出错</span>\n    error, <span class="hljs-comment">// 错误信息</span>\n  } = <span class="hljs-title function_">useQuery</span>({\n    <span class="hljs-attr">queryKey</span>: [<span class="hljs-string">&quot;posts&quot;</span>], <span class="hljs-comment">// 查询的唯一键</span>\n    <span class="hljs-attr">queryFn</span>: fetchPosts, <span class="hljs-comment">// 查询函数</span>\n  });\n\n  <span class="hljs-keyword">if</span> (isLoading) <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n  <span class="hljs-keyword">if</span> (isError) <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Error: {error.message}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n      {data.map((post) =&gt; (\n        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{post.id}</span>&gt;</span>{post.title}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n      ))}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h3><strong>2. 查询键（Query Key）</strong></h3>\n<p><code>queryKey</code> 是一个数组，用于唯一标识查询，并决定缓存策略：</p>\n<pre><code class="language-ts"><span class="hljs-comment">// 普通查询</span>\n<span class="hljs-attr">queryKey</span>: [<span class="hljs-string">&quot;posts&quot;</span>];\n\n<span class="hljs-comment">// 带参数的查询</span>\n<span class="hljs-attr">queryKey</span>: [<span class="hljs-string">&quot;posts&quot;</span>, { <span class="hljs-attr">userId</span>: <span class="hljs-number">1</span> }];\n\n<span class="hljs-comment">// 分页查询</span>\n<span class="hljs-attr">queryKey</span>: [<span class="hljs-string">&quot;posts&quot;</span>, { <span class="hljs-attr">page</span>: <span class="hljs-number">1</span> }];\n</code></pre>\n<h3><strong>3. 自动重新获取（Stale Time vs Cache Time）</strong></h3>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong><code>staleTime</code></strong></td>\n<td>数据多久后视为“过期”（默认 <code>0</code>，即立即过期）</td>\n</tr>\n<tr>\n<td><strong><code>cacheTime</code></strong></td>\n<td>数据在缓存中保留的时间（默认 <code>5分钟</code>）</td>\n</tr>\n</tbody>\n</table>\n<pre><code class="language-ts"><span class="hljs-title function_">useQuery</span>({\n  <span class="hljs-attr">queryKey</span>: [<span class="hljs-string">&quot;posts&quot;</span>],\n  <span class="hljs-attr">queryFn</span>: fetchPosts,\n  <span class="hljs-attr">staleTime</span>: <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>, <span class="hljs-comment">// 1分钟后数据过期</span>\n});\n</code></pre>\n<hr>\n<h2><strong>四、数据变更（Mutations）</strong></h2>\n<h3><strong>1. 基本变更 (<code>useMutation</code>)</strong></h3>\n<pre><code class="language-tsx"><span class="hljs-keyword">import</span> { useMutation } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@tanstack/react-query&quot;</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">addPost</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">newPost</span>) =&gt; {\n  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/posts&quot;</span>, {\n    <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,\n    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(newPost),\n  });\n  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();\n};\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">AddPostForm</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> mutation = <span class="hljs-title function_">useMutation</span>({\n    <span class="hljs-attr">mutationFn</span>: addPost,\n    <span class="hljs-attr">onSuccess</span>: <span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-comment">// 成功后的操作（如刷新列表）</span>\n      queryClient.<span class="hljs-title function_">invalidateQueries</span>({ <span class="hljs-attr">queryKey</span>: [<span class="hljs-string">&quot;posts&quot;</span>] });\n    },\n  });\n\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params">e</span>) =&gt; {\n    e.<span class="hljs-title function_">preventDefault</span>();\n    mutation.<span class="hljs-title function_">mutate</span>({ <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;New Post&quot;</span> });\n  };\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{handleSubmit}</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">{mutation.isPending}</span>&gt;</span>\n        {mutation.isPending ? &quot;Saving...&quot; : &quot;Add Post&quot;}\n      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h3><strong>2. 乐观更新（Optimistic Updates）</strong></h3>\n<p>先更新 UI，再确认服务器状态：</p>\n<pre><code class="language-ts"><span class="hljs-title function_">useMutation</span>({\n  <span class="hljs-attr">mutationFn</span>: updatePost,\n  <span class="hljs-attr">onMutate</span>: <span class="hljs-title function_">async</span> (newPost) =&gt; {\n    <span class="hljs-comment">// 取消当前查询，避免冲突</span>\n    <span class="hljs-keyword">await</span> queryClient.<span class="hljs-title function_">cancelQueries</span>({ <span class="hljs-attr">queryKey</span>: [<span class="hljs-string">&quot;posts&quot;</span>] });\n    <span class="hljs-comment">// 保存旧数据（用于回滚）</span>\n    <span class="hljs-keyword">const</span> previousPosts = queryClient.<span class="hljs-title function_">getQueryData</span>([<span class="hljs-string">&quot;posts&quot;</span>]);\n    <span class="hljs-comment">// 乐观更新</span>\n    queryClient.<span class="hljs-title function_">setQueryData</span>([<span class="hljs-string">&quot;posts&quot;</span>], <span class="hljs-function">(<span class="hljs-params">old</span>) =&gt;</span> [...old, newPost]);\n    <span class="hljs-keyword">return</span> { previousPosts };\n  },\n  <span class="hljs-attr">onError</span>: <span class="hljs-function">(<span class="hljs-params">err, newPost, context</span>) =&gt;</span> {\n    <span class="hljs-comment">// 出错时回滚</span>\n    queryClient.<span class="hljs-title function_">setQueryData</span>([<span class="hljs-string">&quot;posts&quot;</span>], context.<span class="hljs-property">previousPosts</span>);\n  },\n  <span class="hljs-attr">onSettled</span>: <span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-comment">// 无论成功或失败，都刷新数据</span>\n    queryClient.<span class="hljs-title function_">invalidateQueries</span>({ <span class="hljs-attr">queryKey</span>: [<span class="hljs-string">&quot;posts&quot;</span>] });\n  },\n});\n</code></pre>\n<hr>\n<h2><strong>五、高级功能</strong></h2>\n<h3><strong>1. 无限加载 (<code>useInfiniteQuery</code>)</strong></h3>\n<pre><code class="language-tsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchPosts</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">{ pageParam = <span class="hljs-number">1</span> }</span>) =&gt; {\n  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/posts?page=<span class="hljs-subst">${pageParam}</span>`</span>);\n  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();\n};\n\n<span class="hljs-keyword">const</span> { data, fetchNextPage, hasNextPage } = <span class="hljs-title function_">useInfiniteQuery</span>({\n  <span class="hljs-attr">queryKey</span>: [<span class="hljs-string">&quot;posts&quot;</span>],\n  <span class="hljs-attr">queryFn</span>: fetchPosts,\n  <span class="hljs-attr">getNextPageParam</span>: <span class="hljs-function">(<span class="hljs-params">lastPage</span>) =&gt;</span> lastPage.<span class="hljs-property">nextPage</span>,\n});\n\n<span class="hljs-keyword">return</span> (\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    {data.pages.map((page) =&gt;\n      page.posts.map((post) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{post.id}</span>&gt;</span>{post.title}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>),\n    )}\n    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> fetchNextPage()} disabled={!hasNextPage}&gt;\n      Load More\n    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n);\n</code></pre>\n<h3><strong>2. 预加载数据 (<code>prefetchQuery</code>)</strong></h3>\n<pre><code class="language-ts"><span class="hljs-comment">// 在路由跳转前预加载数据</span>\n<span class="hljs-keyword">await</span> queryClient.<span class="hljs-title function_">prefetchQuery</span>({\n  <span class="hljs-attr">queryKey</span>: [<span class="hljs-string">&quot;post&quot;</span>, id],\n  <span class="hljs-attr">queryFn</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">fetchPost</span>(id),\n});\n</code></pre>\n<h3><strong>3. Next.js 集成（Server Components）</strong></h3>\n<p>在 Next.js 的 Server Component 中预取数据：</p>\n<pre><code class="language-ts"><span class="hljs-comment">// app/posts/page.tsx</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">HydrationBoundary</span>, <span class="hljs-title class_">QueryClient</span>, dehydrate } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@tanstack/react-query&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">PostsPage</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> queryClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryClient</span>();\n  <span class="hljs-keyword">await</span> queryClient.<span class="hljs-title function_">prefetchQuery</span>({\n    <span class="hljs-attr">queryKey</span>: [<span class="hljs-string">&quot;posts&quot;</span>],\n    <span class="hljs-attr">queryFn</span>: fetchPosts,\n  });\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">HydrationBoundary</span> <span class="hljs-attr">state</span>=<span class="hljs-string">{dehydrate(queryClient)}</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">PostsList</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">HydrationBoundary</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<hr>\n<h2><strong>六、总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>使用的 Hook</th>\n<th>关键功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>获取数据</strong></td>\n<td><code>useQuery</code></td>\n<td>自动缓存、后台刷新</td>\n</tr>\n<tr>\n<td><strong>修改数据</strong></td>\n<td><code>useMutation</code></td>\n<td>乐观更新、错误回滚</td>\n</tr>\n<tr>\n<td><strong>无限加载</strong></td>\n<td><code>useInfiniteQuery</code></td>\n<td>分页数据流式加载</td>\n</tr>\n<tr>\n<td><strong>全局状态</strong></td>\n<td><code>QueryClient</code></td>\n<td>跨组件共享缓存</td>\n</tr>\n<tr>\n<td><strong>SSR 支持</strong></td>\n<td><code>dehydrate</code> + <code>HydrationBoundary</code></td>\n<td>Next.js 服务端预取</td>\n</tr>\n</tbody>\n</table>\n<p><strong>React Query 是现代 React 应用的必备工具</strong>   ，适用于：</p>\n<ul>\n<li><strong>REST API</strong>   或 <strong>GraphQL</strong>   数据管理。</li>\n<li><strong>实时数据更新</strong>   （如聊天应用）。</li>\n<li><strong>复杂缓存策略</strong>   （如分页、无限加载）。</li>\n<li><strong>Next.js、Remix、Vite</strong>   等框架。</li>\n</ul>\n<p><strong>官方文档</strong>   ：https://tanstack.com/query/latest</p>\n</div>'</script></body></html>