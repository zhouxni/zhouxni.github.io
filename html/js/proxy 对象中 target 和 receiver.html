<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x55d2(t,s){var l=_0x43c6();return(_0x55d2=function(s,n){var a=l[s-=400];void 0===_0x55d2.jsbubL&&(_0x55d2.dlaUTM=function(s,n){var a,e=[],t=0,l="";for(s=(s=>{for(var n,a,e="",t="",l=0,r=0;a=s.charAt(r++);~a&&(n=l%4?64*n+a:a,l++%4)&&(e+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=e.length;o<c;o++)t+="%"+("00"+e.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(t)})(s),r=0;r<256;r++)e[r]=r;for(r=0;r<256;r++)t=(t+e[r]+n.charCodeAt(r%n.length))%256,a=e[r],e[r]=e[t],e[t]=a;for(var r=0,t=0,o=0;o<s.length;o++)a=e[r=(r+1)%256],e[r]=e[t=(t+e[r])%256],e[t]=a,l+=String.fromCharCode(s.charCodeAt(o)^e[(e[r]+e[t])%256]);return l},t=arguments,_0x55d2.jsbubL=!0);var s=s+l[0],e=t[s];return e?a=e:(void 0===_0x55d2.EIFcFg&&(_0x55d2.EIFcFg=!0),a=_0x55d2.dlaUTM(a,n),t[s]=a),a})(t,s)}var _0x21408b=_0x55d2;if((()=>{for(var s=_0x55d2,n=_0x43c6();;)try{if(590290==+parseInt(s(417,"4KQf"))*(parseInt(s(414,"5%)c"))/2)+parseInt(s(415,"e03F"))/3+parseInt(s(402,"0iP&"))/4*(parseInt(s(406,"ZXcS"))/5)+-parseInt(s(403,"aEyM"))/6+parseInt(s(407,"9o0^"))/7*(parseInt(s(420,"0iP&"))/8)+-parseInt(s(413,"]LUa"))/9+parseInt(s(419,"(umV"))/10*(-parseInt(s(421,"pF3G"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x21408b(410,"JCDH")](_0x21408b(418,"lSsq"))!=_0x21408b(409,"$tbc"))throw window[_0x21408b(408,"W^e9")][_0x21408b(423,"6nd&")](_0x21408b(422,"5&l0")),Error();function _0x43c6(){var s=["WOldNmoBE8kRxmkLW6tdMCkbW6FcUgm","WR9qWQ8jWPZcNCkLWQxdUmkxWOpcLv8","mCkBFSoje8otyG","W77cNtulWOBcRmkoW51ChZa","WOJdLSoGdNtcPCks","gaayW7pcUgy/rmkVgG","eNPHFSk8ng98","WRhcRXvDCa","W4e7zIlcMrxcPW","WP7cTfpcLbVdN8k0W74jE2RcMmkm","WPhdRqtdOrRcOSoRgSkeaxOEpa","lSoZl0ZdVmkgCdOnWPrrD8kb","mmoRfCkWCmkXyxf2ivDs","aCkRCxpcH8owovNdO8kKWQKbW5a","jmoWWPlcM3WfWQm","WPCUBSoRWPBdJ8oc","W7/dTCk3WPZdPtO0wYm","W5bDzmoBW5ChvSkczI3cKrLBW6u","WOFdM8oyFmkNhmoZW4tdKCkIW50","ytrykCoGvdNdUa","u2ddHmk9bgBcHCobW6yjmSoWxfb3qZibWPrGW6TkWPxcHSktmW","WRBcRfhdTmoknxy","W57dV8oLW7f2bSkaWP0","WONcPSkpFbBdH8oIsKtdTCkdWOZdRq","W4v5W4nOWOxdGXqgrMxcM8oae1O","WOJdGmocW4lcMmoQnCoWwZy","W4/dMSkpW6xdOSkioCkFaCoLcCoBWQ8","gSkpW7CKWOlcOqFdN8oxA8oXW60"];return(_0x43c6=function(){return s})()}document.title="proxy 对象中 target 和 receiver",document.getElementById("article").innerHTML='<div><p>在 JavaScript 的 <code>Proxy</code> 对象中，<code>target</code> 和 <code>receiver</code> 是两个重要的概念，它们在代理行为中扮演着不同的角色。以下是对这两个概念的详细解释：</p>\n<hr>\n<h3><strong>1. <code>target</code></strong></h3>\n<ul>\n<li><strong>定义</strong>  ：<code>target</code> 是被代理的目标对象。<code>Proxy</code> 会对这个对象的基本操作（如属性查找、赋值、枚举、函数调用等）进行拦截和自定义。</li>\n<li><strong>作用</strong>  ：<code>target</code> 是代理行为的实际作用对象，所有对 <code>Proxy</code> 实例的操作最终都会转发到 <code>target</code> 对象上（通过捕获器进行自定义处理）。</li>\n<li><strong>示例</strong>  ：</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> target = {\n  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,\n  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>\n};\n\n<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {\n  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop, receiver</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Getting <span class="hljs-subst">${prop}</span>`</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, prop, receiver);\n  }\n});\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">a</span>); <span class="hljs-comment">// 输出 &quot;Getting a&quot;，然后输出 1</span>\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li><code>target</code> 是 <code>{ a: 1, b: 2 }</code>。</li>\n<li>当访问 <code>proxy.a</code> 时，<code>get</code> 捕获器被触发，<code>target</code> 作为第一个参数传入。</li>\n</ul>\n<hr>\n<h3><strong>2. <code>receiver</code></strong></h3>\n<ul>\n<li><strong>定义</strong>  ：<code>receiver</code> 是指向代理对象本身的引用，或者在继承场景中指向继承代理对象的子类实例。</li>\n<li><strong>作用</strong>  ：<code>receiver</code> 允许在捕获器中访问代理对象本身，特别是在处理继承关系时，<code>receiver</code> 可以确保方法调用绑定到正确的对象上。</li>\n<li><strong>常见用途</strong>  ：\n<ul>\n<li>在 <code>get</code> 捕获器中，当代理对象被继承时，<code>receiver</code> 可以确保返回的方法绑定到正确的对象上。</li>\n<li>在 <code>construct</code> 捕获器中，<code>receiver</code> 指向正在构造的代理对象。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：</li>\n</ul>\n<h4><strong>示例 1：基本用法</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> target = {\n  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>;\n  }\n};\n\n<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {\n  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop, receiver</span>) {\n    <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">&#x27;greet&#x27;</span>) {\n      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(target[prop], receiver, <span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">// 使用 receiver 确保 this 指向代理对象</span>\n      };\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, prop, receiver);\n  }\n});\n\nproxy.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Alice&#x27;</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-title function_">greet</span>()); <span class="hljs-comment">// 输出 &quot;Hello, Alice&quot;</span>\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li>当调用 <code>proxy.greet()</code> 时，<code>get</code> 捕获器返回了一个新函数。</li>\n<li>在新函数中，使用 <code>Reflect.apply</code> 调用原始方法，并将 <code>receiver</code> 作为 <code>this</code> 的值，确保 <code>this.name</code> 访问的是 <code>proxy.name</code>。</li>\n</ul>\n<h4><strong>示例 2：继承场景</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {\n  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello from Base`</span>;\n  }\n}\n\n<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Base</span>(), {\n  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop, receiver</span>) {\n    <span class="hljs-keyword">if</span> (prop <span class="hljs-keyword">in</span> target) {\n      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> target[prop] === <span class="hljs-string">&#x27;function&#x27;</span> ? target[prop].<span class="hljs-title function_">bind</span>(receiver) : target[prop];\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;\n  }\n});\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Base</span> {\n  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello from Derived`</span>;\n  }\n}\n\n<span class="hljs-keyword">const</span> derivedProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Derived</span>(), {\n  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop, receiver</span>) {\n    <span class="hljs-keyword">if</span> (prop <span class="hljs-keyword">in</span> target) {\n      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> target[prop] === <span class="hljs-string">&#x27;function&#x27;</span> ? target[prop].<span class="hljs-title function_">bind</span>(receiver) : target[prop];\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, prop, receiver);\n  }\n});\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-title function_">greet</span>()); <span class="hljs-comment">// 输出 &quot;Hello from Base&quot;</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(derivedProxy.<span class="hljs-title function_">greet</span>()); <span class="hljs-comment">// 输出 &quot;Hello from Derived&quot;</span>\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li>在继承场景中，<code>receiver</code> 确保方法调用绑定到正确的子类实例上。</li>\n</ul>\n<hr>\n<h3><strong>3. <code>target</code> 与 <code>receiver</code> 的区别</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong><code>target</code></strong></th>\n<th><strong><code>receiver</code></strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>定义</strong></td>\n<td>被代理的目标对象</td>\n<td>指向代理对象本身或继承代理对象的子类实例</td>\n</tr>\n<tr>\n<td><strong>作用</strong></td>\n<td>代理行为的实际作用对象</td>\n<td>确保方法调用绑定到正确的对象上</td>\n</tr>\n<tr>\n<td><strong>常见用途</strong></td>\n<td>作为捕获器的第一个参数，用于操作目标对象</td>\n<td>在继承场景中，确保 <code>this</code> 指向正确的对象</td>\n</tr>\n<tr>\n<td><strong>示例场景</strong></td>\n<td>访问或修改目标对象的属性</td>\n<td>调用代理对象的方法，确保 <code>this</code> 指向代理对象</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>4. 总结</strong></h3>\n<ul>\n<li><strong><code>target</code></strong>   是被代理的目标对象，所有代理行为最终都会作用在这个对象上。</li>\n<li><strong><code>receiver</code></strong>   是指向代理对象本身的引用，确保在继承场景中方法调用绑定到正确的对象上。</li>\n<li>在编写捕获器时，理解 <code>target</code> 和 <code>receiver</code> 的区别和作用，可以帮助你更准确地控制代理行为，特别是在处理复杂对象结构和继承关系时。</li>\n</ul>\n<hr>\n<h3><strong>扩展：<code>Proxy</code> 的其他捕获器参数</strong></h3>\n<p>除了 <code>get</code> 捕获器外，其他捕获器（如 <code>set</code>、<code>apply</code>、<code>construct</code> 等）也会使用 <code>target</code> 和 <code>receiver</code> 参数。理解这些参数的作用，可以帮助你更全面地掌握 <code>Proxy</code> 的使用。</p>\n</div>'</script></body></html>