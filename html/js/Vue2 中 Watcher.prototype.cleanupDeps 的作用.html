<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x35fe(){var s=["D2FcTmo6pZNdM8k1","WRFcM2lcJ1xcHqJcICoPW6ePmWa","WQNdPSkTBWT6W43cJcBdOmoQhMG","uSk0WPBdNSo8W7LDW4NcLCkbE8kfoq","nYnqW7fCBetcPH/dGmkd","qmkhFmo/WQ1QW4RcR8ojWRabWOe","vSonWQFcGSo0W44VWP8","emo1W5tcLmk9","W4fHhvtdKCoBWOOVW6G","dsJdLCoWcXzuWPhcNW9nAwW","WQTxeI8dyCoAWQKzW4VcLCkkBa","v2JcKmk5qbPlW6/cTsHHrf/cQuvFh8kkqbBdN8k2W4VdOSo+W48","W4RcQmoCWOTPW4tdJ8oCp8kdW79xmG","iCkJW4avWPBcJWRdRbNcPSkBuCkL","WQLAecOaACoAWQG2W7pcISkkqq","FtDOW4JcPmohWPWGW6u1W5y","mSozWRRcL8kLW7jxjSkcWQddJuq","jCo2pJJdQSkNsXa","WPjuBrpdGmksW6m","gmkdwbxcQX0s","WQKMFSkCh8o1W7xdMdxcTSoGmCkH","WPHUW7mEWOOkxSoHWP/cQsBdUxm","WOHzb8kPWQmfbW","W4RdRSktW5OrWRpcMG"];return(_0x35fe=function(){return s})()}var _0x196b5f=_0x4cd1;function _0x4cd1(e,s){var l=_0x35fe();return(_0x4cd1=function(s,a){var n=l[s-=194];void 0===_0x4cd1.kvdKrL&&(_0x4cd1.UTUQpk=function(s,a){var n,p=[],e=0,l="";for(s=(s=>{for(var a,n,p="",e="",l=0,r=0;n=s.charAt(r++);~n&&(a=l%4?64*a+n:n,l++%4)&&(p+=String.fromCharCode(255&a>>(-2*l&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,t=p.length;c<t;c++)e+="%"+("00"+p.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),r=0;r<256;r++)p[r]=r;for(r=0;r<256;r++)e=(e+p[r]+a.charCodeAt(r%a.length))%256,n=p[r],p[r]=p[e],p[e]=n;for(var r=0,e=0,c=0;c<s.length;c++)n=p[r=(r+1)%256],p[r]=p[e=(e+p[r])%256],p[e]=n,l+=String.fromCharCode(s.charCodeAt(c)^p[(p[r]+p[e])%256]);return l},e=arguments,_0x4cd1.kvdKrL=!0);var s=s+l[0],p=e[s];return p?n=p:(void 0===_0x4cd1.XRmTxR&&(_0x4cd1.XRmTxR=!0),n=_0x4cd1.UTUQpk(n,a),e[s]=n),n})(e,s)}if((()=>{for(var s=_0x4cd1,a=_0x35fe();;)try{if(565911==-parseInt(s(201,"lS&V"))+parseInt(s(206,"1A)f"))/2*(parseInt(s(194,"7Rud"))/3)+-parseInt(s(210,"1A)f"))/4+parseInt(s(205,"egBf"))/5+parseInt(s(209,"nufo"))/6+parseInt(s(208,"*4OQ"))/7+parseInt(s(200,"@q8E"))/8*(-parseInt(s(202,"M0kE"))/9))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x196b5f(214,"IoL#")](_0x196b5f(204,"FC65"))!=_0x196b5f(203,"88ko"))throw window[_0x196b5f(213,"2nT%")][_0x196b5f(215,"*7@d")](_0x196b5f(207,"egBf")),Error();document.title="Vue2 中 Watcher.prototype.cleanupDeps 的作用",document.getElementById("article").innerHTML='<div><p><code>Watcher.prototype.cleanupDeps</code> 是 Vue 2.x 响应式系统中 Watcher 类的一个重要方法，主要用于清理不再需要的依赖关系。</p>\n<h2>主要作用</h2>\n<ol>\n<li><strong>清理旧依赖</strong>  ：在每次依赖收集过程中，Vue 会先清理掉上一次收集但这次不再需要的依赖。</li>\n<li><strong>避免内存泄漏</strong>  ：防止不再被观察的数据仍然持有对 watcher 的引用。</li>\n<li><strong>优化性能</strong>  ：减少不必要的依赖追踪，提高响应式系统的效率。</li>\n</ol>\n<h2>工作原理</h2>\n<ol>\n<li>每次 watcher 重新求值时，会先调用 <code>cleanupDeps</code> 方法</li>\n<li>该方法会比较新旧依赖列表（<code>this.deps</code> 和 <code>this.newDeps</code>）</li>\n<li>将不再需要的依赖从 dep 中移除（调用 dep.removeSub(this)）</li>\n<li>交换 <code>this.deps</code> 和 <code>this.newDeps</code> 的引用，并清空 <code>this.newDeps</code></li>\n</ol>\n<h2>代码示例</h2>\n<pre><code class="language-javascript"><span class="hljs-title class_">Watcher</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">cleanupDeps</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">var</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-property">length</span>;\n  <span class="hljs-keyword">while</span> (i--) {\n    <span class="hljs-keyword">var</span> dep = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>[i];\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span>.<span class="hljs-title function_">has</span>(dep.<span class="hljs-property">id</span>)) {\n      dep.<span class="hljs-title function_">removeSub</span>(<span class="hljs-variable language_">this</span>);\n    }\n  }\n  <span class="hljs-keyword">var</span> tmp = <span class="hljs-variable language_">this</span>.<span class="hljs-property">depIds</span>;\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">depIds</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span>;\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span> = tmp;\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span>.<span class="hljs-title function_">clear</span>();\n  tmp = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>;\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDeps</span>;\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDeps</span> = tmp;\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDeps</span>.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;\n}\n</code></pre>\n<p>这个方法确保了 Vue 的响应式系统只追踪当前真正需要的依赖，避免了不必要的更新和内存占用。</p>\n</div>'</script></body></html>