<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3ce78a=_0x2777;function _0xba5d(){var s=["puauW6FdJCoDW7rZWOq","WQ7dIHpcS2RcNmkqWRFdHCkIWPrzqdddOmkVWQHNExVdTSoIj8k/DeW","W5v1pLT5W71Ob8kEba","pYrkW77dPCoEW5W","WP0jW5eHW5xcRKldTGG","FSoiW4KRW5xcJcK","WQSjvCkiqSoLWR4fEmk4WR0","W6iQW5dcNZtcHt4cW4K","BSkwWRFcPmknW6ddOmo1","W681mmkAWPi","owBcSLzmsbZcLmonzCoaW7VdGq","oSonW6xcOSkQW4pdN8oPW7e","eSkUc8ojwvbfWQhcI3tdRSkZWQ4","WRL0A8k4WPS0vhzf","W59XWR5KfSomWQ7cRW","tKnhDuvsWOBdGv0","WPOMBmkyamkYW4DiW4uPWPy","oCkMmSkjk8k8WPXSWPa","gmo+W4xdOchcG33cRKe5W4hdGmkH","ASksW5ZdKsWSrCoKF8k0pW","C8kyWR1KWO9sW4tcQ8o5cW","pCkLBSkklmkSWOPL","W60Lm8kfWOPNjG","W4ynEKJcVCkKAmkuWOC","W7mXqJ0QiCoTWQdcICk/Eq","Ba/dIKdcT8oCmG","W7pcHL/cTepdQCoYW53dTW","W4KVpmoLW5eTteztW6eI","z2NdMmosnehcTYBcSvXA","bX4zW7aqFSocWQKWk8op","hCo8W4xdOI3cG3VcRuW1W6xdKCkY","gYpcPvNdJ8kgW558WPFcPmkH"];return(_0xba5d=function(){return s})()}function _0x2777(l,s){var t=_0xba5d();return(_0x2777=function(s,n){var a=t[s-=422];void 0===_0x2777.ckBixo&&(_0x2777.WRjCXH=function(s,n){var a,e=[],l=0,t="";for(s=(s=>{for(var n,a,e="",l="",t=0,o=0;a=s.charAt(o++);~a&&(n=t%4?64*n+a:a,t++%4)&&(e+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,c=e.length;p<c;p++)l+="%"+("00"+e.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(l)})(s),o=0;o<256;o++)e[o]=o;for(o=0;o<256;o++)l=(l+e[o]+n.charCodeAt(o%n.length))%256,a=e[o],e[o]=e[l],e[l]=a;for(var o=0,l=0,p=0;p<s.length;p++)a=e[o=(o+1)%256],e[o]=e[l=(l+e[o])%256],e[l]=a,t+=String.fromCharCode(s.charCodeAt(p)^e[(e[o]+e[l])%256]);return t},l=arguments,_0x2777.ckBixo=!0);var s=s+t[0],e=l[s];return e?a=e:(void 0===_0x2777.fjnRca&&(_0x2777.fjnRca=!0),a=_0x2777.WRjCXH(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x2777,n=_0xba5d();;)try{if(457058==+parseInt(s(430,"l6Sk"))*(parseInt(s(441,"N7*R"))/2)+parseInt(s(445,"(OQN"))/3*(parseInt(s(452,"h^z&"))/4)+-parseInt(s(446,"y4k]"))/5*(parseInt(s(431,"]P!d"))/6)+parseInt(s(432,"(lQy"))/7*(parseInt(s(449,"gMjP"))/8)+parseInt(s(436,"uLUP"))/9+-parseInt(s(447,"v4]R"))/10*(parseInt(s(438,"hvPt"))/11)+-parseInt(s(422,"I9^d"))/12*(parseInt(s(425,"QGv$"))/13))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3ce78a(451,"V%pM")](_0x3ce78a(439,"bhvS"))!=_0x3ce78a(435,"3xDS"))throw window[_0x3ce78a(434,"I8Fo")][_0x3ce78a(448,"3xDS")](_0x3ce78a(427,"h^z&")),Error();document.title="Webpack 动态调用构建",document.getElementById("article").innerHTML='<div><p>在 Webpack 动态调用构建时，<strong>是否使用原项目 <code>node_modules</code> 中的 loader 和 plugins，取决于模块解析的上下文和配置</strong>  。以下是关键原理和解决方案：</p>\n<hr>\n<h3>一、核心机制解析</h3>\n<h4>1. <strong>Webpack 的模块解析规则</strong></h4>\n<p>Webpack 默认会从以下位置查找 loader/plugin：</p>\n<ol>\n<li><strong>当前项目的 <code>node_modules</code></strong>  （即调用 <code>webpack()</code> 的所在目录）</li>\n<li><strong>配置中 <code>resolveLoader.modules</code> 指定的路径</strong></li>\n<li><strong>全局 <code>NODE_PATH</code> 环境变量指定的路径</strong></li>\n</ol>\n<h4>2. **动态调用时的常见问题</h4>\n<pre><code class="language-sh"><span class="hljs-comment"># 假设目录结构</span>\n├── dynamic-builder/  <span class="hljs-comment"># 调用webpack的脚本位置</span>\n│   └── node_modules/ <span class="hljs-comment"># 可能缺少部分依赖</span>\n└── target-project/\n    ├── webpack.config.js\n    └── node_modules/  <span class="hljs-comment"># 实际需要的loader在这里</span>\n</code></pre>\n<p>此时动态构建可能报错：<br>\n<code>Error: Cannot find module \'babel-loader\'</code></p>\n<hr>\n<h3>二、正确解决方案</h3>\n<h4>1. <strong>方法一：强制使用目标项目的 <code>node_modules</code></strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);\n<span class="hljs-keyword">const</span> targetProjectPath = <span class="hljs-string">&#x27;./target-project&#x27;</span>;\n\n<span class="hljs-comment">// 修改Node模块解析路径</span>\nprocess.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_PATH</span> = path.<span class="hljs-title function_">resolve</span>(targetProjectPath, <span class="hljs-string">&#x27;node_modules&#x27;</span>);\n<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;module&#x27;</span>).<span class="hljs-property">Module</span>.<span class="hljs-title function_">_initPaths</span>();\n\n<span class="hljs-comment">// 或使用resolveLoader配置</span>\n<span class="hljs-keyword">const</span> config = {\n  ...<span class="hljs-built_in">require</span>(<span class="hljs-string">`<span class="hljs-subst">${targetProjectPath}</span>/webpack.config.js`</span>),\n  <span class="hljs-attr">resolveLoader</span>: {\n    <span class="hljs-attr">modules</span>: [\n      path.<span class="hljs-title function_">resolve</span>(targetProjectPath, <span class="hljs-string">&#x27;node_modules&#x27;</span>),\n      <span class="hljs-string">&#x27;node_modules&#x27;</span> <span class="hljs-comment">// 后备查找</span>\n    ]\n  }\n};\n</code></pre>\n<h4>2. <strong>方法二：动态修正 require 上下文</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> targetRequire = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;module&#x27;</span>).<span class="hljs-title function_">createRequire</span>(\n  path.<span class="hljs-title function_">resolve</span>(targetProjectPath, <span class="hljs-string">&#x27;package.json&#x27;</span>)\n);\n\n<span class="hljs-comment">// 通过此require加载loader/plugin</span>\n<span class="hljs-keyword">const</span> babelLoader = <span class="hljs-title function_">targetRequire</span>(<span class="hljs-string">&#x27;babel-loader&#x27;</span>);\n<span class="hljs-keyword">const</span> config = {\n  <span class="hljs-attr">module</span>: {\n    <span class="hljs-attr">rules</span>: [{\n      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.js$/</span>,\n      <span class="hljs-attr">use</span>: [babelLoader] <span class="hljs-comment">// 使用目标项目的loader</span>\n    }]\n  }\n};\n</code></pre>\n<h4>3. <strong>方法三：进程级工作目录切换</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> originalCwd = process.<span class="hljs-title function_">cwd</span>();\nprocess.<span class="hljs-title function_">chdir</span>(targetProjectPath); <span class="hljs-comment">// 切换工作目录</span>\n\n<span class="hljs-comment">// 此时webpack会自动使用目标项目的node_modules</span>\n<span class="hljs-title function_">webpack</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.config.js&#x27;</span>)).<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {\n  process.<span class="hljs-title function_">chdir</span>(originalCwd); <span class="hljs-comment">// 恢复目录</span>\n});\n</code></pre>\n<hr>\n<h3>三、验证方案</h3>\n<h4>1. <strong>检查实际加载的模块路径</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> res = <span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;babel-loader&#x27;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); \n<span class="hljs-comment">// 应输出：/path/to/target-project/node_modules/babel-loader/...</span>\n</code></pre>\n<h4>2. <strong>Webpack内部调试</strong></h4>\n<pre><code class="language-sh"><span class="hljs-comment"># 显示模块解析过程</span>\nNODE_DEBUG=module webpack --config ./config.js\n</code></pre>\n<hr>\n<h3>四、高级场景处理</h3>\n<h4>1. <strong>多项目共存的情况</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 使用Yarn Workspaces或NPM的alias功能</span>\n<span class="hljs-keyword">const</span> config = {\n  <span class="hljs-attr">resolveLoader</span>: {\n    <span class="hljs-attr">alias</span>: {\n      <span class="hljs-string">&#x27;babel-loader$&#x27;</span>: <span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(\n        <span class="hljs-string">&#x27;babel-loader&#x27;</span>, \n        { <span class="hljs-attr">paths</span>: [targetProjectPath] }\n      )\n    }\n  }\n};\n</code></pre>\n<h4>2. <strong>PNPM等非扁平化包管理</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 处理.pnpm虚拟存储</span>\n<span class="hljs-attr">resolveLoader</span>: {\n  <span class="hljs-attr">modules</span>: [\n    path.<span class="hljs-title function_">resolve</span>(targetProjectPath, <span class="hljs-string">&#x27;node_modules/.pnpm/node_modules&#x27;</span>),\n    path.<span class="hljs-title function_">resolve</span>(targetProjectPath, <span class="hljs-string">&#x27;node_modules&#x27;</span>)\n  ]\n}\n</code></pre>\n<hr>\n<h3>五、常见误区</h3>\n<ol>\n<li><strong>误以为 <code>webpack.config.js</code> 中的依赖会自动继承</strong><br>\n→ 实际依赖Node.js的模块缓存机制，与配置文件位置无关</li>\n<li>**混淆 <code>require()</code> 和 <code>import()**     → 动态导入需使用 </code>await import()<code>+</code>file://` URL（Node.js 20+）</li>\n<li><strong>忽略peerDependencies</strong><br>\n→ 即使loader路径正确，缺少peer依赖仍会报错</li>\n</ol>\n<hr>\n<h3>六、最佳实践建议</h3>\n<ol>\n<li><strong>推荐方案组合</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 在动态构建脚本中</span>\n<span class="hljs-keyword">const</span> targetRequire = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;module&#x27;</span>).<span class="hljs-title function_">createRequire</span>(\n  path.<span class="hljs-title function_">join</span>(targetProjectPath, <span class="hljs-string">&#x27;package.json&#x27;</span>)\n);\n\n<span class="hljs-keyword">const</span> config = {\n  ...<span class="hljs-built_in">require</span>(<span class="hljs-string">`<span class="hljs-subst">${targetProjectPath}</span>/webpack.config.js`</span>),\n  <span class="hljs-attr">resolveLoader</span>: {\n    <span class="hljs-attr">modules</span>: [\n      path.<span class="hljs-title function_">join</span>(targetProjectPath, <span class="hljs-string">&#x27;node_modules&#x27;</span>),\n      <span class="hljs-string">&#x27;node_modules&#x27;</span>\n    ]\n  }\n};\n\n<span class="hljs-comment">// 确保所有require通过targetRequire执行</span>\n<span class="hljs-title function_">targetRequire</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>)(config);\n</code></pre>\n</li>\n<li><strong>容器化构建环境</strong>  ：<br>\n使用Docker绑定挂载项目目录，彻底隔离依赖环境：<pre><code class="language-dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /app</span>\n<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span>\n<span class="hljs-keyword">RUN</span><span class="language-bash"> npm install</span>\n</code></pre>\n</li>\n</ol>\n<hr>\n<p>通过以上方法，可以确保动态构建时<strong>精确使用目标项目自身的 <code>node_modules</code></strong>  ，避免因依赖路径错乱导致的构建失败。关键点在于<strong>控制模块解析的上下文</strong>  ，而非简单地读取配置文件。</p>\n</div>'</script></body></html>