<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x114b2d=_0x4b40;function _0x1938(){var s=["WRiOngaSw8oU","W6RdUmkxgmk1WQyBE2hdU8oapW","W67dTSkChSk0WQ0jELZdH8o4oG","W74OoWHaWP7dOsjPW68JhmkH","vI7cMZ5LddmeW7/cLIa2","FLldP2/dNeJdPsvAcwu","zSkfF8kpWR7cTg4QW5ldH3hdQq","WRxcTSosW7ddQMBcVCkTB8kRWRBcGq","nxRcPNvDwIywbCovW6jSaq","rCkdWRVdL8oe","vmovcSkTWOpcTv0","W6VdUmkxhmk3WQywC2ddLSoRha","d23dNxKNbxrGW7dcUduhcmowW7zpW77cSeJcHCoJvqLoW6Wz","eSkhsSkZWOxcNx7cGmoM","WOCOtSkFb8kgwfxcLG","W7ZdIMzEyWOQ","o8oEW6iEn3pcM8o+WRy","Cq9CW75smmkKkmkL","WQvDdImiW7Lj","W7TIWRdcT8k7W7RdKsmQW4uAWRa","ESoWW7CxWPTfkmkX","twaaxbe5W7mqWPa","EqLuWPLKmmkknSktyW","trVcOfBdNmoIlN4hWRr2","W6f6CfS/DCofiSkR","otzquqepW506WPO","e8kjq8oWW5ldRKlcNSoKdHDW","xuxcRuZdPmooBIfmWQC"];return(_0x1938=function(){return s})()}function _0x4b40(o,s){var t=_0x1938();return(_0x4b40=function(s,n){var a=t[s-=188];void 0===_0x4b40.AiNHCK&&(_0x4b40.SafEqv=function(s,n){var a,l=[],o=0,t="";for(s=(s=>{for(var n,a,l="",o="",t=0,p=0;a=s.charAt(p++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,r=l.length;e<r;e++)o+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(o)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)o=(o+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[o],l[o]=a;for(var p=0,o=0,e=0;e<s.length;e++)a=l[p=(p+1)%256],l[p]=l[o=(o+l[p])%256],l[o]=a,t+=String.fromCharCode(s.charCodeAt(e)^l[(l[p]+l[o])%256]);return t},o=arguments,_0x4b40.AiNHCK=!0);var s=s+t[0],l=o[s];return l?a=l:(void 0===_0x4b40.tnyZCJ&&(_0x4b40.tnyZCJ=!0),a=_0x4b40.SafEqv(a,n),o[s]=a),a})(o,s)}if((()=>{for(var s=_0x4b40,n=_0x1938();;)try{if(101514==-parseInt(s(204,"xRsi"))+-parseInt(s(191,"HHzY"))/2*(-parseInt(s(196,"HHzY"))/3)+-parseInt(s(200,"*zav"))/4*(-parseInt(s(192,"PdOK"))/5)+parseInt(s(197,"nvO)"))/6*(parseInt(s(188,"mJvx"))/7)+parseInt(s(208,"&[AK"))/8+parseInt(s(210,"v%jZ"))/9+-parseInt(s(215,"*zav"))/10*(parseInt(s(193,"JEDU"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x114b2d(202,"fZZK")](_0x114b2d(195,"HPrD"))!=_0x114b2d(211,"CqSa"))throw window[_0x114b2d(194,"hg]B")][_0x114b2d(212,"*zav")](_0x114b2d(214,"nW)Y")),Error();document.title="webSocket 心跳机制",document.getElementById("article").innerHTML='<div><h3>WebSocket 心跳机制详解</h3>\n<p>WebSocket 心跳机制是一种用于保持 WebSocket 连接活跃和检测连接状态的技术。由于 WebSocket 连接可能会因为网络问题、服务器超时或客户端异常等原因而中断，心跳机制通过定期发送“心跳”消息来确保连接的稳定性，并在连接断开时及时进行处理。</p>\n<hr>\n<h4><strong>一、为什么需要心跳机制？</strong></h4>\n<ol>\n<li><strong>检测连接状态</strong>  ：\n<ul>\n<li>WebSocket 协议本身没有提供内置的机制来检测连接是否仍然有效。如果连接因为网络问题或服务器超时等原因断开，客户端和服务器可能无法立即感知。</li>\n<li>心跳机制通过定期发送和接收消息，可以检测到连接是否仍然活跃。</li>\n</ul>\n</li>\n<li><strong>防止连接超时</strong>  ：\n<ul>\n<li>某些网络设备或服务器可能会因为长时间没有数据传输而自动关闭连接。心跳机制通过定期发送消息，可以保持连接活跃，防止超时断开。</li>\n</ul>\n</li>\n<li><strong>提高可靠性</strong>  ：\n<ul>\n<li>在实时通信应用中，连接的可靠性至关重要。心跳机制可以确保在连接断开时及时进行处理，如尝试重连或通知用户。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4><strong>二、心跳机制的实现方式</strong></h4>\n<p>心跳机制通常通过以下两种方式实现：</p>\n<ol>\n<li><strong>客户端发送心跳消息</strong>  ：\n<ul>\n<li>客户端定期向服务器发送心跳消息（如 <code>ping</code> 或自定义的心跳消息）。</li>\n<li>服务器接收到心跳消息后，可以回复一个响应（如 <code>pong</code> 或自定义的响应消息）。</li>\n</ul>\n</li>\n<li><strong>服务器发送心跳消息</strong>  ：\n<ul>\n<li>服务器也可以定期向客户端发送心跳消息，客户端接收到后回复响应。</li>\n<li>这种方式在某些场景下可能更合适，特别是当服务器需要主动检测客户端状态时。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4><strong>三、心跳机制的实现示例</strong></h4>\n<p>以下是一个简单的心跳机制实现示例，使用客户端发送心跳消息的方式：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:8080&quot;</span>);\n<span class="hljs-keyword">var</span> heartCheck = {\n    <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>, <span class="hljs-comment">// 心跳间隔时间（毫秒）</span>\n    <span class="hljs-attr">timeoutObj</span>: <span class="hljs-literal">null</span>,\n    <span class="hljs-attr">serverTimeoutObj</span>: <span class="hljs-literal">null</span>,\n    <span class="hljs-attr">reset</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n        <span class="hljs-built_in">clearTimeout</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timeoutObj</span>);\n        <span class="hljs-built_in">clearTimeout</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">serverTimeoutObj</span>);\n        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">start</span>();\n    },\n    <span class="hljs-attr">start</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n        <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">timeoutObj</span> = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n            <span class="hljs-comment">// 发送心跳消息</span>\n            ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;ping&quot;</span>);\n            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;ping!&quot;</span>);\n\n            <span class="hljs-comment">// 如果在一定时间内没有收到服务器的响应，则关闭连接</span>\n            self.<span class="hljs-property">serverTimeoutObj</span> = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n                ws.<span class="hljs-title function_">close</span>();\n            }, self.<span class="hljs-property">timeout</span>);\n        }, <span class="hljs-variable language_">this</span>.<span class="hljs-property">timeout</span>);\n    }\n};\n\nws.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;WebSocket connection opened.&quot;</span>);\n    heartCheck.<span class="hljs-title function_">start</span>(); <span class="hljs-comment">// 开始心跳检测</span>\n};\n\nws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Message from server: &quot;</span> + event.<span class="hljs-property">data</span>);\n    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span> === <span class="hljs-string">&quot;pong&quot;</span>) {\n        heartCheck.<span class="hljs-title function_">reset</span>(); <span class="hljs-comment">// 收到服务器的响应，重置心跳检测</span>\n    }\n};\n\nws.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;WebSocket connection closed.&quot;</span>);\n};\n\nws.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;WebSocket error: &quot;</span> + error);\n};\n</code></pre>\n<hr>\n<h4><strong>四、心跳机制的关键点</strong></h4>\n<ol>\n<li><strong>心跳间隔时间</strong>  ：\n<ul>\n<li>心跳间隔时间应根据应用需求和网络环境进行设置。过短的时间间隔会增加网络负载，过长的时间间隔可能导致连接断开时无法及时检测。</li>\n</ul>\n</li>\n<li><strong>超时处理</strong>  ：\n<ul>\n<li>如果在一定时间内没有收到服务器的响应，应视为连接断开，并进行相应的处理（如尝试重连或通知用户）。</li>\n</ul>\n</li>\n<li><strong>重连机制</strong>  ：\n<ul>\n<li>在连接断开后，可以实现自动重连机制，以提高应用的可靠性。重连机制应设置合理的重试间隔和重试次数，避免频繁重连导致服务器负载过高。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4><strong>五、心跳机制的优化建议</strong></h4>\n<ol>\n<li><strong>使用 WebSocket 协议内置的 <code>ping</code>/<code>pong</code> 帧</strong>  ：\n<ul>\n<li>WebSocket 协议提供了 <code>ping</code>/<code>pong</code> 帧，可以用于心跳检测。服务器可以配置自动发送 <code>ping</code> 帧，客户端接收到后自动回复 <code>pong</code> 帧。</li>\n<li>这种方式比自定义心跳消息更简洁和高效。</li>\n</ul>\n</li>\n<li><strong>结合应用层心跳消息</strong>  ：\n<ul>\n<li>在某些场景下，可以结合应用层的心跳消息来实现更复杂的业务逻辑。例如，心跳消息可以携带客户端的状态信息或服务器的指令。</li>\n</ul>\n</li>\n<li><strong>监控网络状态</strong>  ：\n<ul>\n<li>在客户端实现网络状态监控，当检测到网络断开时，及时关闭 WebSocket 连接并尝试重连。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4><strong>六、总结</strong></h4>\n<p>WebSocket 心跳机制是确保 WebSocket 连接稳定性和可靠性的重要手段。通过定期发送和接收心跳消息，可以检测到连接是否仍然活跃，并在连接断开时及时进行处理。在实现心跳机制时，应根据应用需求和网络环境进行合理设置，并结合重连机制和网络状态监控来提高应用的可靠性。</p>\n</div>'</script></body></html>