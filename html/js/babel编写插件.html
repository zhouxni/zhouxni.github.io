<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x39940c=_0x3422;function _0x13a0(){var n=["kKyrW690W53cK8kq","ibCSpmoKbNa","zmoOWRHfsCkKs8o4gGFdOxRcOa","fCkmamo/WRBdGSkeW5NcT8k5W63dPbi","WOBdUgVcRqVdISkxWPK","Ew8ZWQNdICoVlSk+WOj3W6BcLW","W63dV8oIWOhdKehdQ0ldTaqY","CGKLlfHrh8oE","W5TkW4xcI8kckmkClSoJsJGQhHFcVSodAIPWDrldVbhcPmkpfq","WRSWWOpdJ8kBWPNcPSk1","EgC1WQNdJ8kOm8kIWRfiW5q","DguJW75OW4tcTW","FwbVW7xcR8kDhmkU","kKldICoengBdIZRcKHLuWPri","WPldPCoTWOurBIVcO8kfWQW9W77dMW","fxpcMSopBbVcVd7dHKmlW67dQG","Ca8OkMrMdCoD","luegW5xcSchcIKOrW7hcVmofWRW","WPK9bCovW4W","BbBcOfCTrCoSWQyumGZdHmkQ","WRTNdZaJW7eYW7tcMedcQd0z","B8o4WQxcSHDnWPS","W7HrDmo0W5DGW64","WOqkWOBdICobiSkdzCoCvWePpG","W6rFWRtdV8oDWOmiW7/cMuFcICoO","WQGRfCodW4y1WO/dGLa","jmkFW7JcV8kaWPeVza","lKybW5tcTIpcI1GVW6pcVmoDWPa"];return(_0x13a0=function(){return n})()}function _0x3422(c,n){var s=_0x13a0();return(_0x3422=function(n,e){var o=s[n-=223];void 0===_0x3422.paBDaw&&(_0x3422.iViBPK=function(n,e){var o,a=[],c=0,s="";for(n=(n=>{for(var e,o,a="",c="",s=0,t=0;o=n.charAt(t++);~o&&(e=s%4?64*e+o:o,s++%4)&&(a+=String.fromCharCode(255&e>>(-2*s&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var l=0,d=a.length;l<d;l++)c+="%"+("00"+a.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(c)})(n),t=0;t<256;t++)a[t]=t;for(t=0;t<256;t++)c=(c+a[t]+e.charCodeAt(t%e.length))%256,o=a[t],a[t]=a[c],a[c]=o;for(var t=0,c=0,l=0;l<n.length;l++)o=a[t=(t+1)%256],a[t]=a[c=(c+a[t])%256],a[c]=o,s+=String.fromCharCode(n.charCodeAt(l)^a[(a[t]+a[c])%256]);return s},c=arguments,_0x3422.paBDaw=!0);var n=n+s[0],a=c[n];return a?o=a:(void 0===_0x3422.LEPHTj&&(_0x3422.LEPHTj=!0),o=_0x3422.iViBPK(o,e),c[n]=o),o})(c,n)}if((()=>{for(var n=_0x3422,e=_0x13a0();;)try{if(974260==+parseInt(n(249,"STr$"))*(parseInt(n(237,"HHO6"))/2)+parseInt(n(230,"[q@B"))/3+parseInt(n(246,"q]UZ"))/4+-parseInt(n(247,"x&mr"))/5+-parseInt(n(228,"STr$"))/6*(parseInt(n(250,"FDt$"))/7)+-parseInt(n(233,"@B1Q"))/8*(parseInt(n(248,"Hoel"))/9)+parseInt(n(225,"!0C7"))/10*(-parseInt(n(243,"@B1Q"))/11))break;e.push(e.shift())}catch(n){e.push(e.shift())}})(),localStorage[_0x39940c(238,"Z1C8")](_0x39940c(241,"&Yit"))!=_0x39940c(234,"&Yit"))throw window[_0x39940c(244,"h61I")][_0x39940c(245,"9PTQ")](_0x39940c(224,"7ZXx")),Error();document.title="babel编写插件",document.getElementById("article").innerHTML='<div><p>下面为你编写一个简单的 Babel 插件，此插件的功能是把代码里所有的 <code>const</code> 变量声明替换成 <code>let</code> 变量声明。</p>\n<h3>实现思路</h3>\n<ul>\n<li>借助 Babel 把 JavaScript 代码解析成抽象语法树（AST）。</li>\n<li>遍历 AST 并找出所有的 <code>VariableDeclaration</code> 节点。</li>\n<li>若 <code>VariableDeclaration</code> 节点的 <code>kind</code> 属性为 <code>const</code>，就将其改为 <code>let</code>。</li>\n<li>把修改后的 AST 转换回 JavaScript 代码。</li>\n</ul>\n<h3>代码实现</h3>\n<pre><code>const-to-let-plugin.js\n\n\nmodule.exports = function (babel,options:参数对象) {\n    const { types: t } = babel;\n    return {\n        name: \'transform-const-to-let\',\n        visitor: {\n            VariableDeclaration(path) {\n                if (path.node.kind === \'const\') {\n                    path.node.kind = \'let\';\n                }\n            }\n        }\n    };\n};    \n</code></pre>\n<h3>代码解释</h3>\n<ul>\n<li><strong><code>module.exports</code></strong>  ：把插件作为一个 Node.js 模块导出，它接收 <code>babel</code> 对象作为参数。</li>\n<li><strong><code>const { types: t } = babel</code></strong>  ：从 <code>babel</code> 对象中解构出 <code>types</code> 对象，该对象可用于创建、检查和修改 AST 节点。</li>\n<li><strong><code>name</code></strong>  ：插件的名称，用于调试和日志记录。</li>\n<li><strong><code>visitor</code></strong>  ：一个对象，其中包含了各种节点类型的访问器函数。这里的 <code>VariableDeclaration</code> 访问器函数会遍历所有的变量声明节点。</li>\n<li><strong><code>path.node.kind === \'const\'</code></strong>  ：检查当前变量声明的类型是否为 <code>const</code>。</li>\n<li><strong><code>path.node.kind = \'let\'</code></strong>  ：若为 <code>const</code> 声明，则将其类型改为 <code>let</code>。</li>\n</ul>\n<h3>使用方法</h3>\n<h4>1. 安装依赖</h4>\n<p>假设你已初始化了一个 Node.js 项目（有 <code>package.json</code> 文件），安装 Babel 核心库和 CLI 工具：</p>\n<pre><code class="language-sh">npm install --save-dev @babel/core @babel/cli\n</code></pre>\n<h4>2. 创建 Babel 配置文件</h4>\n<p>在项目根目录下创建 <code>.babelrc</code> 文件，内容如下：</p>\n<pre><code class="language-json"><span class="hljs-punctuation">{</span>\n    <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;./const-to-let-plugin&quot;</span><span class="hljs-punctuation">]</span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n<h4>3. 测试插件</h4>\n<p>创建一个测试文件 <code>test.js</code>，内容如下：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> message = <span class="hljs-string">&#x27;Hello, World!&#x27;</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);\n</code></pre>\n<h4>4. 编译代码</h4>\n<p>使用 Babel 编译 <code>test.js</code> 文件：</p>\n<pre><code class="language-sh">npx babel test.js --out-file output.js\n</code></pre>\n<h4>5. 查看结果</h4>\n<p>打开 <code>output.js</code> 文件，你会发现 <code>const</code> 声明已被替换成 <code>let</code> 声明：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> message = <span class="hljs-string">&#x27;Hello, World!&#x27;</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);\n</code></pre>\n<p>通过上述步骤，你可以实现一个简单的 Babel 插件，并将其应用到代码编译中。你可以根据需求修改访问器函数，以实现不同的代码转换逻辑。</p>\n</div>'</script></body></html>