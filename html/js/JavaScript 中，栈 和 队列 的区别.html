<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x148d(l,n){var p=_0x5e6e();return(_0x148d=function(n,s){var a=p[n-=396];void 0===_0x148d.nrdwCy&&(_0x148d.dBRcfU=function(n,s){var a,t=[],l=0,p="";for(n=(n=>{for(var s,a,t="",l="",p=0,e=0;a=n.charAt(e++);~a&&(s=p%4?64*s+a:a,p++%4)&&(t+=String.fromCharCode(255&s>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=t.length;o<c;o++)l+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(n),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+s.charCodeAt(e%s.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,o=0;o<n.length;o++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,p+=String.fromCharCode(n.charCodeAt(o)^t[(t[e]+t[l])%256]);return p},l=arguments,_0x148d.nrdwCy=!0);var n=n+p[0],t=l[n];return t?a=t:(void 0===_0x148d.QZTWGk&&(_0x148d.QZTWGk=!0),a=_0x148d.dBRcfU(a,s),l[n]=a),a})(l,n)}var _0x3fd8c0=_0x148d;if((()=>{for(var n=_0x148d,s=_0x5e6e();;)try{if(367193==-parseInt(n(411,"!8u5"))*(-parseInt(n(413,"c*iW"))/2)+parseInt(n(409,"5G68"))/3+parseInt(n(412,"NSlx"))/4+parseInt(n(408,"Fm90"))/5+parseInt(n(416,"NY28"))/6+parseInt(n(406,"$zkg"))/7+-parseInt(n(415,"5G68"))/8)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x3fd8c0(398,"gQze")](_0x3fd8c0(407,"PbTy"))!=_0x3fd8c0(403,"oQoa"))throw window[_0x3fd8c0(397,"TIEP")][_0x3fd8c0(414,"s3wY")](_0x3fd8c0(417,"yp#f")),Error();function _0x5e6e(){var n=["W4j/W7hdU0bCW6tdLW","W4ldHIFdHwDEW6i","EKhcO8o5fXNcSNRdISkpbxK","FMTfWOvdjeVdSW","W7ldNMBdOYeTsCoNWP7dJ8oWvW","rb/cK8kfW6hcRmkFW5pcS1zzW57dVq","FCoFgLHH","WPfHcf7cQ11KpCkQW4RdS8oVgW","WPv5WRNcNmkmDcNdJN0+rCkBW74","W5BcRXWxg8oyWPJdHmoHW5pcKuBdGa","u8k5hmo/r8oCWQ5XW6m","WRVdLCk0W6q7W5tdUSkbWPVdTsFcSq","W5/dTSoJEalcJ8o5rCouku14","cCkchXuQWOCyWOpcLmoi","e8olW4RcLqNcRuNcJG","mSkTkquTuKRdKu3dMgNdJZK","xefNE23cNCkMWPjBW4y","WR1+W7fmW6HpW4q","W5NdSmoMDGFcHCkAu8o5k1zuWQ8","W7BcVJlcMh5tW50xW5FdStna","WOKCy8kkW6/dQN7dTmkJa8oOtxFdV8kEWQPCW5RdRLWOvghcNwT4","qHNcLSklW6tcPSo8W4xcNLrcW7i"];return(_0x5e6e=function(){return n})()}document.title="JavaScript 中，栈 和 队列 的区别",document.getElementById("article").innerHTML='<div><p>在 JavaScript 中，<strong>栈（Stack）</strong>   和 <strong>队列（Queue）</strong>   是两种常见的数据结构，它们主要区别在于 <strong>数据的添加和移除顺序（即元素的进出规则）</strong>   ，这个规则也分别被称为：</p>\n<ul>\n<li><strong>栈：后进先出（LIFO, Last In First Out）</strong></li>\n<li><strong>队列：先进先出（FIFO, First In First Out）</strong></li>\n</ul>\n<p>下面我们从 <strong>定义、特点、区别、JavaScript 中的实现方式</strong>   等方面来详细讲解它们的区别。</p>\n<hr>\n<h2>一、栈（Stack）—— 后进先出（LIFO）</h2>\n<h3>✅ 定义：</h3>\n<p>栈是一种只能从 <strong>一端（称为栈顶）</strong>   进行数据插入和删除的数据结构。</p>\n<h3>🧠 特点：</h3>\n<ul>\n<li><strong>先进后出</strong>   或 <strong>后进先出（LIFO）</strong></li>\n<li>主要操作：\n<ul>\n<li><strong>push</strong>   ：将元素压入栈顶（添加）</li>\n<li><strong>pop</strong>   ：将栈顶元素弹出（移除）</li>\n<li><strong>peek / top</strong>   ：查看栈顶元素（不移除）</li>\n</ul>\n</li>\n<li>想象一叠盘子，你总是从 <strong>最上面放盘子、也从最上面取盘子</strong></li>\n</ul>\n<h3>📦 JavaScript 模拟实现（用数组）：</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> stack = []; <span class="hljs-comment">// 用数组模拟栈</span>\n\nstack.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 入栈</span>\nstack.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>);\nstack.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>);\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack); <span class="hljs-comment">// [1, 2, 3]</span>\n\n<span class="hljs-keyword">let</span> top = stack.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 出栈 -&gt; 3</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(top); <span class="hljs-comment">// 3</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack); <span class="hljs-comment">// [1, 2]</span>\n</code></pre>\n<blockquote>\n<p>✅ 在 JavaScript 中，可以用数组的 <code>push()</code> 和 <code>pop()</code> 方法非常方便地模拟栈的行为。</p>\n</blockquote>\n<hr>\n<h2>二、队列（Queue）—— 先进先出（FIFO）</h2>\n<h3>✅ 定义：</h3>\n<p>队列是一种从 <strong>一端（队尾）添加元素，从另一端（队头）移除元素</strong>   的数据结构。</p>\n<h3>🧠 特点：</h3>\n<ul>\n<li><strong>先进先出（FIFO）</strong></li>\n<li>主要操作：\n<ul>\n<li><strong>enqueue / push</strong>   ：将元素加入队尾（添加）</li>\n<li><strong>dequeue / shift</strong>   ：将队头元素移除（取出）</li>\n<li><strong>front</strong>   ：查看队头元素（不移除）</li>\n</ul>\n</li>\n<li>想象排队买票，<strong>先来的人先买票离开队伍</strong></li>\n</ul>\n<h3>📦 JavaScript 模拟实现（用数组）：</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> queue = []; <span class="hljs-comment">// 用数组模拟队列</span>\n\nqueue.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 入队</span>\nqueue.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>);\nqueue.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>);\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(queue); <span class="hljs-comment">// [1, 2, 3]</span>\n\n<span class="hljs-keyword">let</span> first = queue.<span class="hljs-title function_">shift</span>(); <span class="hljs-comment">// 出队 -&gt; 1</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first); <span class="hljs-comment">// 1</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(queue); <span class="hljs-comment">// [2, 3]</span>\n</code></pre>\n<blockquote>\n<p>✅ 在 JavaScript 中，通常用数组的 <code>push()</code> 方法模拟入队，用 <code>shift()</code> 方法模拟出队。</p>\n</blockquote>\n<blockquote>\n<p>⚠️ 注意：<code>shift()</code> 会改变原数组，并且<strong>性能相对较低（尤其在大型数组时）</strong>   ，因为要移动所有元素。如果对性能要求高，可以用更高效的方式（比如链表，或者使用索引控制）。</p>\n</blockquote>\n<hr>\n<h2>三、栈 和 队列 的核心区别总结</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>栈（Stack）</th>\n<th>队列（Queue）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>原则</strong></td>\n<td>后进先出（LIFO）</td>\n<td>先进先出（FIFO）</td>\n</tr>\n<tr>\n<td><strong>添加元素的一端</strong></td>\n<td>栈顶（通常用 push）</td>\n<td>队尾（通常用 push）</td>\n</tr>\n<tr>\n<td><strong>移除元素的一端</strong></td>\n<td>栈顶（通常用 pop）</td>\n<td>队头（通常用 shift）</td>\n</tr>\n<tr>\n<td><strong>查看元素</strong></td>\n<td>栈顶元素（一般用栈顶索引）</td>\n<td>队头元素（一般不用 shift 查）</td>\n</tr>\n<tr>\n<td><strong>JavaScript 模拟</strong></td>\n<td><code>push()</code> 入栈，<code>pop()</code> 出栈</td>\n<td><code>push()</code> 入队，<code>shift()</code> 出队</td>\n</tr>\n<tr>\n<td><strong>常见用途</strong></td>\n<td>函数调用栈、撤销操作、括号匹配等</td>\n<td>任务队列、消息队列、BFS等</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>四、JavaScript 中的常见应用场景</h2>\n<h3>✅ 栈（Stack）的典型应用：</h3>\n<ol>\n<li>\n<p><strong>函数调用栈（Call Stack）</strong></p>\n<ul>\n<li>JS 执行函数时，内部通过栈来管理函数的调用顺序</li>\n<li>先调用的函数后执行完（后进先出）</li>\n</ul>\n</li>\n<li>\n<p><strong>括号匹配</strong></p>\n<ul>\n<li>比如判断 <code>{[()]}</code> 是否合法，可以用栈来匹配</li>\n</ul>\n</li>\n<li>\n<p><strong>撤销（Undo）操作</strong></p>\n<ul>\n<li>比如编辑器的撤销功能，最近的操作最先撤销</li>\n</ul>\n</li>\n<li>\n<p><strong>表达式求值 / 转换（如中缀转后缀）</strong></p>\n</li>\n</ol>\n<hr>\n<h3>✅ 队列（Queue）的典型应用：</h3>\n<ol>\n<li>\n<p><strong>任务队列 / 消息队列</strong></p>\n<ul>\n<li>比如定时执行任务、异步任务调度</li>\n</ul>\n</li>\n<li>\n<p><strong>BFS（广度优先搜索）</strong></p>\n<ul>\n<li>图或树的层次遍历，用队列来实现</li>\n</ul>\n</li>\n<li>\n<p><strong>打印队列 / 请求排队</strong></p>\n<ul>\n<li>先来的任务先处理</li>\n</ul>\n</li>\n<li>\n<p><strong>JavaScript 中的异步队列</strong></p>\n<ul>\n<li>比如事件循环中的 <strong>回调队列（Callback Queue） / 微任务队列（Microtask Queue） / 宏任务队列（Macrotask Queue）</strong></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2>五、补充：用对象/链表实现高性能队列（可选）</h2>\n<p>虽然用数组可以快速模拟栈和队列，但：</p>\n<ul>\n<li>栈用 <code>push()</code> 和 <code>pop()</code> 是高效的（都是操作数组末尾）</li>\n<li>队列如果用 <code>shift()</code> 从数组头部删除元素，<strong>性能较差（O(n)）</strong></li>\n</ul>\n<p>🔧 <strong>如果需要高性能队列，可以用对象 + 指针（头尾索引） 或者链表实现。</strong></p>\n<p>简单高性能队列示例（用对象模拟）：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = {};\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontIndex</span> = <span class="hljs-number">0</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">backIndex</span> = <span class="hljs-number">0</span>;\n  }\n\n  <span class="hljs-title function_">enqueue</span>(<span class="hljs-params">item</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">backIndex</span>] = item;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">backIndex</span>++;\n  }\n\n  <span class="hljs-title function_">dequeue</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;\n    <span class="hljs-keyword">const</span> item = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">frontIndex</span>];\n    <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">frontIndex</span>];\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontIndex</span>++;\n    <span class="hljs-keyword">return</span> item;\n  }\n\n  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontIndex</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">backIndex</span>;\n  }\n}\n\n<span class="hljs-comment">// 使用</span>\n<span class="hljs-keyword">const</span> q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>();\nq.<span class="hljs-title function_">enqueue</span>(<span class="hljs-number">1</span>);\nq.<span class="hljs-title function_">enqueue</span>(<span class="hljs-number">2</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(q.<span class="hljs-title function_">dequeue</span>()); <span class="hljs-comment">// 1</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(q.<span class="hljs-title function_">dequeue</span>()); <span class="hljs-comment">// 2</span>\n</code></pre>\n<hr>\n<h2>✅ 总结一句话：</h2>\n<blockquote>\n<p><strong>栈是后进先出（LIFO），像一叠盘子，你最后放上去的最先拿走；队列是先进先出（FIFO），像排队，先来的人先走。</strong></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>栈（Stack）</th>\n<th>队列（Queue）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>顺序</td>\n<td>后进先出 LIFO</td>\n<td>先进先出 FIFO</td>\n</tr>\n<tr>\n<td>添加</td>\n<td>push（栈顶）</td>\n<td>push（队尾）</td>\n</tr>\n<tr>\n<td>移除</td>\n<td>pop（栈顶）</td>\n<td>shift（队头） 或 自定义高效方式</td>\n</tr>\n<tr>\n<td>模拟</td>\n<td>数组：push / pop</td>\n<td>数组：push / shift（或用对象优化）</td>\n</tr>\n<tr>\n<td>用途</td>\n<td>函数调用、撤销、括号匹配</td>\n<td>任务调度、BFS、排队系统</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>🎯 <strong>如果你有具体使用场景，比如要用栈实现某个功能，或者队列在异步任务中的应用，我可以进一步举例说明！</strong></p>\n</div>'</script></body></html>