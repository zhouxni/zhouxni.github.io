<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x58a6(p,s){var t=_0x18a1();return(_0x58a6=function(s,n){var a=t[s-=214];void 0===_0x58a6.UvsuJB&&(_0x58a6.HCpyzq=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,e=0;a=s.charAt(e++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=l.length;c<o;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[p],l[p]=a;for(var e=0,p=0,c=0;c<s.length;c++)a=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[p])%256]);return t},p=arguments,_0x58a6.UvsuJB=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x58a6.QqNlSV&&(_0x58a6.QqNlSV=!0),a=_0x58a6.HCpyzq(a,n),p[s]=a),a})(p,s)}function _0x18a1(){var s=["WQZcJ8ozW4/dKctdIq","W5eiWQHMW7/dTSkPlM/dKbhcIsy1","WPBcKZBcH10YD8kynMPB","WQaIWPaAW47dUCoVW6u","dxP7jZjCW69ffu7cGNhcQCkZ","yNebr25iomowW7TsFcnZBsldJMTGDmofrmoPheqPbW","dW0Lt8kMrdVcQG","bmkltmkJW6FcU2dcJCk0W7i","rCoodCoPW7O","WQaMW4HYWONcISkCWPJcS8kas3DyW5a","WRmOW67cOSoVW6HPW78kW7m","kdbdsgPxW7qi","f8krW4T1qceviuG","WQLVASkteKxcHSoq","WQPJjmopuKdcHmoOoGBdQq","W7xcRmoansdcJMhcUvb/he3cSG","WQyHW4X7WOZcHCkEW7JcSCkZv2DF","W5FdHSkuWOWWuwNdVHpcM8kP","WRpdVmkaW7xcJxlcJ8kEWOpdJZtcTmk9","W6XFWOWme8kJp8ocgCkZuCowW6nz","qZNcL8oGWRrsW6jYaSkx","i2pcRSkkWPjYBSkgWOddVa","WOldOmo9WRZdS8o5W6xdNSktvSo0z8oD","WRGGWRJdLmkiW4exW5ew","ySoGW5KQWO/dP8kZyq","W7dcUSkTW63cSCk9WPJdKCk8","gCozaSoQW7bJWP8","WRKUW6JcRSkWW6fkW6WlW6uh"];return(_0x18a1=function(){return s})()}var _0x1d4c54=_0x58a6;if((()=>{for(var s=_0x58a6,n=_0x18a1();;)try{if(840601==+parseInt(s(234,"bx[f"))*(-parseInt(s(219,"*HuJ"))/2)+parseInt(s(239,"SE@#"))/3*(-parseInt(s(241,"9AoY"))/4)+parseInt(s(215,"B]wk"))/5+parseInt(s(226,"!Lwq"))/6*(parseInt(s(240,"9AoY"))/7)+-parseInt(s(214,"O#]j"))/8+-parseInt(s(231,"f@O7"))/9+parseInt(s(233,"2AQp"))/10*(parseInt(s(236,"B]wk"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1d4c54(225,"T#3c")](_0x1d4c54(224,"N!d3"))!=_0x1d4c54(235,"bx[f"))throw window[_0x1d4c54(238,"%%[P")][_0x1d4c54(227,"cAPS")](_0x1d4c54(232,"hJ)c")),Error();document.title="react HOC",document.getElementById("article").innerHTML='<div><p>高阶组件（Higher-Order Component，简称 HOC）是 React 中一种复用代码和逻辑的高级技巧，它并非 React API 的一部分，而是一种基于 React 组合特性形成的设计模式。下面从定义、使用场景、实现方式、优缺点等方面详细介绍 React HOC。</p>\n<h3>定义</h3>\n<p>高阶组件是一个函数，它接收一个组件作为参数，并返回一个新的组件。其形式如下：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EnhancedComponent</span> = <span class="hljs-title function_">higherOrderComponent</span>(<span class="hljs-title class_">WrappedComponent</span>);\n</code></pre>\n<p>这里 <code>higherOrderComponent</code> 是高阶组件函数，<code>WrappedComponent</code> 是被包裹的原始组件，<code>EnhancedComponent</code> 是经过增强后的新组件。</p>\n<h3>使用场景</h3>\n<h4>1. 代码复用</h4>\n<p>将多个组件中共享的逻辑提取到高阶组件中，避免代码重复。例如，多个组件都需要进行用户登录验证，可将验证逻辑封装在高阶组件中。</p>\n<h4>2. 状态管理</h4>\n<p>在高阶组件中管理状态，并将状态和操作传递给被包裹的组件。比如，使用高阶组件实现表单数据的状态管理。</p>\n<h4>3. 渲染劫持</h4>\n<p>高阶组件可以控制被包裹组件的渲染过程，根据不同条件决定是否渲染或如何渲染。例如，根据用户权限决定是否渲染某个组件。</p>\n<h4>4. 代码增强</h4>\n<p>为被包裹的组件添加额外的功能，如日志记录、错误处理等。</p>\n<h3>实现方式</h3>\n<h4>1. 属性代理（Props Proxy）</h4>\n<p>属性代理是最常见的高阶组件实现方式，高阶组件通过包裹被包裹组件，对传递给被包裹组件的属性进行修改或增强。</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n\n<span class="hljs-comment">// 高阶组件函数</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">withLogging</span> = (<span class="hljs-params">WrappedComponent</span>) =&gt; {\n    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Props received:&#x27;</span>, props);\n        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> {<span class="hljs-attr">...props</span>} /&gt;</span></span>;\n    };\n};\n\n<span class="hljs-comment">// 被包裹的组件</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">MyComponent</span> = (<span class="hljs-params">props</span>) =&gt; {\n    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{props.message}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n};\n\n<span class="hljs-comment">// 使用高阶组件增强 MyComponent</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">EnhancedComponent</span> = <span class="hljs-title function_">withLogging</span>(<span class="hljs-title class_">MyComponent</span>);\n\n<span class="hljs-comment">// 使用增强后的组件</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">EnhancedComponent</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;Hello, World!&quot;</span> /&gt;</span></span>;\n};\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;\n</code></pre>\n<p>在上述代码中，<code>withLogging</code> 是一个高阶组件，它接收 <code>MyComponent</code> 作为参数，并返回一个新的组件。在新组件中，打印传递的属性信息，然后将属性传递给 <code>MyComponent</code> 进行渲染。</p>\n<h4>2. 反向继承（Inheritance Inversion）</h4>\n<p>反向继承是指高阶组件返回的新组件继承自被包裹的组件。这种方式可以访问和修改被包裹组件的状态和生命周期方法。</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n\n<span class="hljs-comment">// 高阶组件函数</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">withErrorBoundary</span> = (<span class="hljs-params">WrappedComponent</span>) =&gt; {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">WrappedComponent</span> {\n        <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {\n            <span class="hljs-variable language_">super</span>(props);\n            <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = { <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> };\n        }\n\n        <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>) {\n            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error caught:&#x27;</span>, error, errorInfo);\n            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> });\n        }\n\n        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hasError</span>) {\n                <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Something went wrong.<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n            }\n            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">render</span>();\n        }\n    };\n};\n\n<span class="hljs-comment">// 被包裹的组件</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {\n    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{this.props.message}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n    }\n}\n\n<span class="hljs-comment">// 使用高阶组件增强 MyComponent</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">EnhancedComponent</span> = <span class="hljs-title function_">withErrorBoundary</span>(<span class="hljs-title class_">MyComponent</span>);\n\n<span class="hljs-comment">// 使用增强后的组件</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">EnhancedComponent</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;Hello, World!&quot;</span> /&gt;</span></span>;\n};\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;\n</code></pre>\n<p>在这个例子中，<code>withErrorBoundary</code> 是一个高阶组件，它返回的新组件继承自 <code>MyComponent</code>。在新组件中，添加了错误捕获逻辑，当发生错误时，显示错误信息。</p>\n<h3>优缺点</h3>\n<h4>优点</h4>\n<ul>\n<li><strong>代码复用</strong>  ：减少代码重复，提高代码的可维护性和可复用性。</li>\n<li><strong>逻辑分离</strong>  ：将公共逻辑提取到高阶组件中，使组件职责更加单一，便于管理和测试。</li>\n<li><strong>增强组件功能</strong>  ：可以为组件添加额外的功能，而不影响组件的原有结构。</li>\n</ul>\n<h4>缺点</h4>\n<ul>\n<li><strong>命名冲突</strong>  ：多个高阶组件嵌套使用时，可能会导致属性命名冲突。</li>\n<li><strong>调试困难</strong>  ：高阶组件增加了组件的嵌套层级，可能会使调试变得更加困难。</li>\n<li><strong>学习成本</strong>  ：对于初学者来说，理解和使用高阶组件可能需要一定的时间和精力。</li>\n</ul>\n<h3>注意事项</h3>\n<ul>\n<li><strong>保持纯净</strong>  ：高阶组件应该是纯函数，不应该有副作用，确保每次传入相同的组件都返回相同的增强组件。</li>\n<li><strong>传递属性</strong>  ：在高阶组件中，要确保将所有必要的属性传递给被包裹的组件，避免丢失属性。</li>\n<li><strong>避免过度嵌套</strong>  ：过多的高阶组件嵌套会增加代码的复杂度，尽量保持组件结构的简洁。</li>\n</ul>\n<p>高阶组件是 React 中一种强大的代码复用和逻辑封装工具，合理使用高阶组件可以提高代码的质量和可维护性。</p>\n</div>'</script></body></html>