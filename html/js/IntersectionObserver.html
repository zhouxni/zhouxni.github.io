<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4ea728=_0x407e;function _0x407e(l,s){var e=_0x4451();return(_0x407e=function(s,n){var a=e[s-=500];void 0===_0x407e.BjFLQM&&(_0x407e.WJmGTN=function(s,n){var a,t=[],l=0,e="";for(s=(s=>{for(var n,a,t="",l="",e=0,r=0;a=s.charAt(r++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,p=t.length;o<p;o++)l+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),r=0;r<256;r++)t[r]=r;for(r=0;r<256;r++)l=(l+t[r]+n.charCodeAt(r%n.length))%256,a=t[r],t[r]=t[l],t[l]=a;for(var r=0,l=0,o=0;o<s.length;o++)a=t[r=(r+1)%256],t[r]=t[l=(l+t[r])%256],t[l]=a,e+=String.fromCharCode(s.charCodeAt(o)^t[(t[r]+t[l])%256]);return e},l=arguments,_0x407e.BjFLQM=!0);var s=s+e[0],t=l[s];return t?a=t:(void 0===_0x407e.YHUJJg&&(_0x407e.YHUJJg=!0),a=_0x407e.WJmGTN(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x407e,n=_0x4451();;)try{if(879003==+parseInt(s(530,"9A01"))*(parseInt(s(526,"Pi(T"))/2)+parseInt(s(501,"#sox"))/3*(-parseInt(s(510,"@KEN"))/4)+-parseInt(s(521,"ctlL"))/5*(parseInt(s(514,"F&6D"))/6)+-parseInt(s(525,"Ui7@"))/7*(parseInt(s(513,"69Up"))/8)+-parseInt(s(506,"6IjL"))/9*(parseInt(s(528,"#VxQ"))/10)+parseInt(s(524,"!$K1"))/11*(-parseInt(s(507,"VJ%s"))/12)+-parseInt(s(532,"U]wu"))/13*(-parseInt(s(519,"2*6w"))/14))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x4ea728(500,"#sox")](_0x4ea728(531,"6IjL"))!=_0x4ea728(520,"hWOB"))throw window[_0x4ea728(527,"gDr3")][_0x4ea728(504,"OC^#")](_0x4ea728(529,"%h$o")),Error();function _0x4451(){var s=["emo8WOnVeSoSeq","WOiCWOFcJsJcU1i","yCoyWPGeW6BcKmk8W5JcOHzYWRza","WOHQWRnEWRhdSmkp","WP9rWOWpW5hdSCouWRa","WPOZtSkCWODzW459","WQ9CswpcUCkarNOywGFcJCoz","bmoIpSoXW4VcRCouaW","W4e7pmkvW4fBW4bCW6NdSmknWPNdKW","mqW7caiFWPW","WPvQWQOtWP/dHG7dIc5BWPNcTNe","WQvMfbrJW7m+","WPdcR2dcMX9QjslcKYfsW54EsG","WRqaoxrmzmkfW4S","W4K9mmkuW4zEW4roW7/dT8ktWPZdLG","WPaRWPj1AcHX","uY9FctVdS8opW5m","Bg/dKgtcPG","W5BcReHTWOJdNCopWOeWDXxcKmkD","WPdcNSoiWOjLb3jP","W4yPWPRcTY/cVLe","WRWhsYWxjmojW4hcJ8ktW5pcQx0","yCoMASkEWPJdIXa","DIJdKHWvF8kdEmkNWQdcQ8kPcG","WRtdI8kOW7nfWRnJmW","WRdcVL3dH3f6BsLcW58kgKy","qSoPWRDvWPxcGMTGW7hdP8onWOyknqzqWP52WORcUHpcKG3cImodWOy","WQ4CbGVdH8o3hq","W7bJWPfnWRRdRmkWt8kw","b8omrwVcPw8CmMbgorvEW4S","W4amWQXrBsT4","WPjyW6GOlNzDAmoGWQVdS8oA","w1ddIuJcOsjkgmoeBKqBiq"];return(_0x4451=function(){return s})()}document.title="IntersectionObserver",document.getElementById("article").innerHTML='<div><h3><strong>Intersection Observer API 详解</strong></h3>\n<h4><strong>什么是 Intersection Observer API？</strong></h4>\n<p>Intersection Observer API 是一种现代浏览器提供的接口，用于异步检测元素与视口（viewport）或其他元素的交叉状态变化。它允许开发者在元素进入或离开视口时执行特定的操作，常用于实现懒加载、无限滚动、广告曝光统计等功能。</p>\n<hr>\n<h3><strong>核心功能</strong></h3>\n<ul>\n<li><strong>异步检测</strong>  ：无需手动监听滚动事件，性能更优。</li>\n<li><strong>精确控制</strong>  ：可以检测元素是否进入视口，以及进入的程度（如可见比例）。</li>\n<li><strong>灵活配置</strong>  ：支持设置阈值（threshold），决定元素可见多少比例时触发回调。</li>\n</ul>\n<hr>\n<h3><strong>基本用法</strong></h3>\n<h4><strong>步骤</strong></h4>\n<ol>\n<li><strong>创建 Intersection Observer 实例</strong>  ：\n<ul>\n<li>传入一个回调函数，该函数在元素可见性发生变化时被调用。</li>\n<li>可选地传入一个配置对象，设置根元素、阈值等。</li>\n</ul>\n</li>\n<li><strong>观察目标元素</strong>  ：\n<ul>\n<li>使用 <code>observe()</code> 方法开始观察目标元素。</li>\n</ul>\n</li>\n<li><strong>停止观察</strong>  ：\n<ul>\n<li>使用 <code>unobserve()</code> 方法停止观察目标元素。</li>\n</ul>\n</li>\n<li><strong>停止所有观察</strong>  ：\n<ul>\n<li>使用 <code>disconnect()</code> 方法停止观察所有目标元素。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>示例代码</strong></h3>\n<h4><strong>实现图片懒加载</strong></h4>\n<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Intersection Observer Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">\n        <span class="hljs-selector-tag">img</span> {\n            <span class="hljs-attribute">display</span>: block;\n            <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span> auto;\n            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;\n            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;\n            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f0f0f0</span>;\n        }\n    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;https://via.placeholder.com/300x200?text=Image+1&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Image 1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lazyload&quot;</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;https://via.placeholder.com/300x200?text=Image+2&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Image 2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lazyload&quot;</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;https://via.placeholder.com/300x200?text=Image+3&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Image 3&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lazyload&quot;</span>&gt;</span>\n\n    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\n        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n            <span class="hljs-keyword">const</span> lazyImages = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;img.lazyload&quot;</span>);\n\n            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;IntersectionObserver&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>) {\n                <span class="hljs-keyword">let</span> lazyImageObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">entries, observer</span>) {\n                    entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">entry</span>) {\n                        <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {\n                            <span class="hljs-keyword">let</span> img = entry.<span class="hljs-property">target</span>;\n                            img.<span class="hljs-property">src</span> = img.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>;\n                            img.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&quot;lazyload&quot;</span>);\n                            lazyImageObserver.<span class="hljs-title function_">unobserve</span>(img);\n                        }\n                    });\n                });\n\n                lazyImages.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">lazyImage</span>) {\n                    lazyImageObserver.<span class="hljs-title function_">observe</span>(lazyImage);\n                });\n            } <span class="hljs-keyword">else</span> {\n                <span class="hljs-comment">// Fallback for browsers that don&#x27;t support Intersection Observer</span>\n                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;Intersection Observer is not supported by your browser.&quot;</span>);\n            }\n        });\n    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n</code></pre>\n<hr>\n<h3><strong>配置选项</strong></h3>\n<p>创建 Intersection Observer 实例时，可以传入一个配置对象，常用选项包括：</p>\n<ul>\n<li><strong><code>root</code></strong>  ：指定根元素，默认为视口（viewport）。</li>\n<li><strong><code>rootMargin</code></strong>  ：根元素的边距，类似于 CSS 的 <code>margin</code>，可以扩展或缩小根元素的检测范围。</li>\n<li><strong><code>threshold</code></strong>  ：一个数组或单个数值，表示目标元素可见的比例，当可见比例达到阈值时触发回调。</li>\n</ul>\n<h4><strong>示例：使用配置选项</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> options = {\n    <span class="hljs-attr">root</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 默认为视口</span>\n    <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">&#x27;0px&#x27;</span>,\n    <span class="hljs-attr">threshold</span>: <span class="hljs-number">0.1</span> <span class="hljs-comment">// 当目标元素 10% 可见时触发回调</span>\n};\n\n<span class="hljs-keyword">let</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(callback, options);\n</code></pre>\n<hr>\n<h3><strong>回调函数参数</strong></h3>\n<p>回调函数接收一个数组 <code>entries</code>，每个 <code>entry</code> 对象包含以下属性：</p>\n<ul>\n<li><strong><code>boundingClientRect</code></strong>  ：目标元素的边界矩形。</li>\n<li><strong><code>intersectionRect</code></strong>  ：目标元素与根元素的交叉矩形。</li>\n<li><strong><code>intersectionRatio</code></strong>  ：目标元素与根元素的交叉比例。</li>\n<li><strong><code>isIntersecting</code></strong>  ：布尔值，表示目标元素是否与根元素交叉。</li>\n<li><strong><code>rootBounds</code></strong>  ：根元素的边界矩形。</li>\n<li><strong><code>target</code></strong>  ：被观察的目标元素。</li>\n<li><strong><code>time</code></strong>  ：交叉状态变化的时间戳。</li>\n</ul>\n<h4><strong>示例：回调函数</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> callback = <span class="hljs-keyword">function</span>(<span class="hljs-params">entries, observer</span>) {\n    entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Element is intersecting: <span class="hljs-subst">${entry.isIntersecting}</span>`</span>);\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Intersection ratio: <span class="hljs-subst">${entry.intersectionRatio}</span>`</span>);\n    });\n};\n</code></pre>\n<hr>\n<h3><strong>优点</strong></h3>\n<ul>\n<li><strong>性能优越</strong>  ：相比手动监听滚动事件，Intersection Observer API 减少了不必要的计算和 DOM 操作。</li>\n<li><strong>简单易用</strong>  ：API 设计直观，易于理解和使用。</li>\n<li><strong>灵活性强</strong>  ：支持多种配置选项，满足不同场景的需求。</li>\n</ul>\n<hr>\n<h3><strong>兼容性</strong></h3>\n<ul>\n<li><strong>现代浏览器</strong>  ：大多数现代浏览器（如 Chrome、Firefox、Edge、Safari）都支持 Intersection Observer API。</li>\n<li><strong>Polyfill</strong>  ：对于不支持的浏览器，可以使用 Polyfill（如 <code>intersection-observer</code> 库）来实现类似功能。</li>\n</ul>\n<hr>\n<h3><strong>常见应用场景</strong></h3>\n<ul>\n<li><strong>懒加载图片和视频</strong>  ：延迟加载非关键资源，减少初始加载时间。</li>\n<li><strong>无限滚动</strong>  ：检测用户滚动到底部，加载更多内容。</li>\n<li><strong>广告曝光统计</strong>  ：统计广告在用户视口中的展示次数。</li>\n<li><strong>动画触发</strong>  ：当元素进入视口时触发动画效果。</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>Intersection Observer API 是一种强大且高效的工具，适用于需要检测元素可见性变化的场景。通过异步检测和灵活的配置选项，它能够帮助开发者实现更流畅、更高效的网页交互。如果你的项目需要实现懒加载、无限滚动等功能，Intersection Observer API 是一个值得考虑的选择。</p>\n</div>'</script></body></html>