<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3072(){var s=["wmkqW5aqWQ5ZW6G","hLCvWRbSl2reoZmDW47cQq","W5GVWPeOrImp","W7pdOZKRv8kYASoEW44","uSoFhCkIW5JcQKvbW7f0a8ke","WRvnWRZcLr3dRZ5PhCouWQGxBW","WQdcHtJcKSoyW5hdR1PtFSoq","WQFdM38fW7tdHfuCvCktW4DZW6y","p8oZpmodmSkliZy","aCkVu17dNeD8vmo8nqNcLg8","qqTwW40PCJ0","t8kBB8oyfSk/W6NdLmo/yG7cLa","mLrKW7ddHYxcUCoWW5ikWOfKWQq","WRldPL5JWOaPwW","W4ztjcqaW7JcRMq2WPBdLCouja","nLVdOvtcPCoICvHlBmolWOS6","W6VdUSk0WOJdJ2abuCkH","W5pcO00pWPrCamkfWQfzjw8g","WPT4W5fYfNjycCkyWRWXwCkO","W6rQWPBcJdj3rvlcTG","WPtdPGzkW5S","f14AWRbTFJn3dq0G","sYuZsJ4AWR4zieCXWOVdLqjCW5hdKxJdJmo9CCoeDh44W5S","WQhcRZHyW4O1FKBcGmoNcWRdPa"];return(_0x3072=function(){return s})()}var _0x219f18=_0x1df4;function _0x1df4(l,s){var o=_0x3072();return(_0x1df4=function(s,n){var a=o[s-=283];void 0===_0x1df4.EZwudM&&(_0x1df4.FObwBq=function(s,n){var a,r=[],l=0,o="";for(s=(s=>{for(var n,a,r="",l="",o=0,e=0;a=s.charAt(e++);~a&&(n=o%4?64*n+a:a,o++%4)&&(r+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,p=r.length;t<p;t++)l+="%"+("00"+r.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)r[e]=e;for(e=0;e<256;e++)l=(l+r[e]+n.charCodeAt(e%n.length))%256,a=r[e],r[e]=r[l],r[l]=a;for(var e=0,l=0,t=0;t<s.length;t++)a=r[e=(e+1)%256],r[e]=r[l=(l+r[e])%256],r[l]=a,o+=String.fromCharCode(s.charCodeAt(t)^r[(r[e]+r[l])%256]);return o},l=arguments,_0x1df4.EZwudM=!0);var s=s+o[0],r=l[s];return r?a=r:(void 0===_0x1df4.YMBQtI&&(_0x1df4.YMBQtI=!0),a=_0x1df4.FObwBq(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x1df4,n=_0x3072();;)try{if(953095==-parseInt(s(285,"L&ko"))+parseInt(s(288,"&UCi"))/2+-parseInt(s(300,"m3]n"))/3*(parseInt(s(302,"A%A8"))/4)+parseInt(s(298,"zlol"))/5+-parseInt(s(304,"ECwp"))/6+-parseInt(s(294,"c(#y"))/7*(-parseInt(s(290,"iaH0"))/8)+-parseInt(s(293,"nRO6"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x219f18(291,"A%A8")](_0x219f18(284,"SbCc"))!=_0x219f18(301,"zlol"))throw window[_0x219f18(289,"zbR3")][_0x219f18(283,"gzhJ")](_0x219f18(303,"$PzG")),Error();document.title="web worker 详解",document.getElementById("article").innerHTML='<div><p><strong>Web Worker 是浏览器提供的一种 API，允许在后台线程中运行 JavaScript，从而避免阻塞主线程，提升网页的响应速度和性能。</strong></p>\n<hr>\n<h3><strong>1. 基本概念</strong></h3>\n<ul>\n<li><strong>多线程环境</strong>  ：Web Worker 允许在浏览器环境中创建多线程，使得耗时的计算任务可以在后台线程中执行，而不会阻塞用户界面。</li>\n<li><strong>主线程与工作线程分离</strong>  ：主线程（通常是 UI 线程）负责处理用户交互和页面渲染，而工作线程负责执行后台任务。</li>\n<li><strong>通信机制</strong>  ：主线程和工作线程之间通过消息传递进行通信，使用 <code>postMessage</code> 方法和 <code>onmessage</code> 事件处理程序。</li>\n</ul>\n<hr>\n<h3><strong>2. 工作原理</strong></h3>\n<ul>\n<li><strong>创建 Worker</strong>  ：使用 <code>new Worker(url)</code> 构造函数创建一个新的 Worker 实例，<code>url</code> 指向一个单独的 JavaScript 文件。</li>\n<li><strong>消息传递</strong>  ：\n<ul>\n<li><strong>主线程到 Worker</strong>  ：使用 <code>worker.postMessage(data)</code> 方法发送消息。</li>\n<li><strong>Worker 到主线程</strong>  ：在 Worker 线程中使用 <code>postMessage(data)</code> 方法发送消息，主线程通过 <code>worker.onmessage</code> 事件处理程序接收。</li>\n</ul>\n</li>\n<li><strong>终止 Worker</strong>  ：使用 <code>worker.terminate()</code> 方法终止 Worker，释放资源。</li>\n</ul>\n<hr>\n<h3><strong>3. 使用示例</strong></h3>\n<h4><strong>3.1 基本示例</strong></h4>\n<p><strong>主线程代码</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 创建一个新的 Worker</span>\n<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;worker.js&#x27;</span>);\n\n<span class="hljs-comment">// 监听来自 Worker 的消息</span>\nworker.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received from worker:&#x27;</span>, event.<span class="hljs-property">data</span>);\n};\n\n<span class="hljs-comment">// 向 Worker 发送消息</span>\nworker.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Hello Worker!&#x27;</span>);\n</code></pre>\n<p><strong>Worker 线程代码（worker.js）</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 监听来自主线程的消息</span>\nonmessage = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received from main thread:&#x27;</span>, event.<span class="hljs-property">data</span>);\n\n  <span class="hljs-comment">// 处理消息并发送响应</span>\n  <span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Hello Main Thread!&#x27;</span>);\n};\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li>主线程创建了一个 Worker，并监听来自 Worker 的消息。</li>\n<li>主线程向 Worker 发送了一条消息。</li>\n<li>Worker 接收到消息后，处理并发送响应回主线程。</li>\n</ul>\n<hr>\n<h4><strong>3.2 处理复杂计算</strong></h4>\n<p><strong>场景</strong>  ：在主线程中执行大量计算会导致页面卡顿，使用 Web Worker 可以在后台线程中处理计算。</p>\n<p><strong>主线程代码</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;computeWorker.js&#x27;</span>);\n\nworker.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Result from worker:&#x27;</span>, event.<span class="hljs-property">data</span>);\n};\n\n<span class="hljs-comment">// 发送计算任务给 Worker</span>\nworker.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;calculate&#x27;</span>, <span class="hljs-attr">data</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>] });\n</code></pre>\n<p><strong>Worker 线程代码（computeWorker.js）</strong>  ：</p>\n<pre><code class="language-javascript">onmessage = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span>.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;calculate&#x27;</span>) {\n    <span class="hljs-keyword">const</span> numbers = event.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>;\n    <span class="hljs-keyword">const</span> sum = numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, num</span>) =&gt;</span> acc + num, <span class="hljs-number">0</span>);\n\n    <span class="hljs-comment">// 发送计算结果回主线程</span>\n    <span class="hljs-title function_">postMessage</span>(sum);\n  }\n};\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li>主线程将计算任务发送给 Worker。</li>\n<li>Worker 接收到任务后，执行计算并将结果发送回主线程。</li>\n<li>主线程接收到结果后进行处理，如更新 UI。</li>\n</ul>\n<hr>\n<h3><strong>4. 优势</strong></h3>\n<ul>\n<li><strong>提升性能</strong>  ：将耗时任务移到后台线程，避免阻塞主线程，提升页面响应速度。</li>\n<li><strong>改善用户体验</strong>  ：确保用户界面流畅，避免卡顿和延迟。</li>\n<li><strong>并行处理</strong>  ：利用多核处理器的优势，实现并行计算。</li>\n</ul>\n<hr>\n<h3><strong>5. 限制与注意事项</strong></h3>\n<ul>\n<li><strong>同源策略</strong>  ：Worker 脚本必须与主页面同源，或者通过 CORS 允许跨域访问。</li>\n<li><strong>DOM 访问限制</strong>  ：Worker 线程没有直接访问 DOM 的能力，无法操作页面元素。</li>\n<li><strong>通信开销</strong>  ：主线程与 Worker 之间的通信是异步的，但频繁的消息传递可能会带来性能开销。</li>\n<li><strong>资源管理</strong>  ：及时终止不再需要的 Worker，避免资源泄漏。</li>\n</ul>\n<hr>\n<h3><strong>6. 适用场景</strong></h3>\n<ul>\n<li><strong>复杂计算</strong>  ：如图像处理、数据分析、物理模拟等。</li>\n<li><strong>预加载资源</strong>  ：在后台线程中预加载数据或资源，提升页面加载速度。</li>\n<li><strong>实时数据处理</strong>  ：如音频处理、视频编码等。</li>\n</ul>\n<hr>\n<h3><strong>7. 与其他技术的比较</strong></h3>\n<ul>\n<li><strong><code>setTimeout</code> 和 <code>setInterval</code></strong>  ：\n<ul>\n<li><strong>用途</strong>  ：用于延迟执行或周期性执行任务。</li>\n<li><strong>限制</strong>  ：仍然在主线程中执行，无法避免阻塞。</li>\n</ul>\n</li>\n<li><strong><code>requestAnimationFrame</code></strong>  ：\n<ul>\n<li><strong>用途</strong>  ：用于动画和渲染优化。</li>\n<li><strong>限制</strong>  ：在主线程中执行，无法处理耗时任务。</li>\n</ul>\n</li>\n<li><strong>Web Worker</strong>  ：\n<ul>\n<li><strong>用途</strong>  ：用于后台任务处理，避免阻塞主线程。</li>\n<li><strong>优势</strong>  ：真正的多线程环境，适合处理复杂计算。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>8. 高级特性</strong></h3>\n<ul>\n<li><strong>共享 Worker</strong>  ：允许多个页面或标签页共享同一个 Worker 实例，适用于需要在多个上下文之间共享数据的场景。</li>\n<li><strong>Service Worker</strong>  ：一种特殊的 Worker，用于拦截和处理网络请求，实现离线缓存、推送通知等功能。</li>\n<li><strong>子 Worker</strong>  ：Worker 线程中可以创建子 Worker，实现更复杂的任务分解和并行处理。</li>\n</ul>\n<hr>\n<h3><strong>9. 示例：使用 Web Worker 处理大量数据</strong></h3>\n<p><strong>主线程代码</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;dataWorker.js&#x27;</span>);\n\nworker.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Processed data:&#x27;</span>, event.<span class="hljs-property">data</span>);\n};\n\n<span class="hljs-comment">// 发送大量数据给 Worker</span>\n<span class="hljs-keyword">const</span> largeData = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">1000000</span> }, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> i);\nworker.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;process&#x27;</span>, <span class="hljs-attr">data</span>: largeData });\n</code></pre>\n<p><strong>Worker 线程代码（dataWorker.js）</strong>  ：</p>\n<pre><code class="language-javascript">onmessage = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span>.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;process&#x27;</span>) {\n    <span class="hljs-keyword">const</span> data = event.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>;\n    <span class="hljs-keyword">const</span> processedData = data.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num * <span class="hljs-number">2</span>); <span class="hljs-comment">// 示例处理：每个数乘以 2</span>\n\n    <span class="hljs-comment">// 发送处理后的数据回主线程</span>\n    <span class="hljs-title function_">postMessage</span>(processedData);\n  }\n};\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li>主线程将大量数据发送给 Worker。</li>\n<li>Worker 接收到数据后进行处理，并将处理后的数据发送回主线程。</li>\n<li>主线程接收到处理后的数据进行进一步处理或展示。</li>\n</ul>\n<hr>\n<h3><strong>10. 总结</strong></h3>\n<p>Web Worker 是浏览器提供的一种强大的工具，允许开发者在后台线程中执行 JavaScript，从而避免阻塞主线程，提升网页的性能和响应速度。通过合理使用 Web Worker，开发者可以处理复杂的计算任务、预加载资源、实现实时数据处理等，为用户提供更流畅、更高效的体验。</p>\n</div>'</script></body></html>