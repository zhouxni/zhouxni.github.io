<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3ca18e=_0x57d5;function _0x5943(){var s=["WONdR0SFWQqKD17dLwpcOXC","WPSAWQFdL8kMiSoLBSoLW6bksW","dCoqW5lcQmosW4xdTa","tmoOvMRdI2OOrCkaW6CtW6G","ASkfWRKwc8krWRuXemoIW44g","WPepW7aed0NcI8kAze/cOtS","pqC/h8kWWP3cTmoaCKu9W6m3rmofxCoLFsFcLmkUW7VdJGBdTZK","W7xcQZVdJeBdHCkc","WQNcPSoCW63dShdcUwPwiCoQW4W","WPytwCoadWfRWPC","W4pcNJazW5W6xmkvC8ooW5ldSW","WPBcIZRdNSoU","W5FdJJddI8oIlmk+mq","vuhcMMaNn8k1","W5hdJNdcLmkIDSkJaLFdJCkkzW","gSosW6HgqCoxWOKZba","W4RdRSk4aSoRlcCCW5tcMLjl","WPGxWQhdLCkRi8kVumoQW6XByty","iSkNmCkCowiJwW","aSkxWOJcGCkjWRRcVW","WQH1muaAW7tdG8oYW67cVmk8W5y","CHbnW7pdSh57W60","m8oeWPNdM1JdImodba","WQpcM8ozz8kQWOBdNWddOHfQna","rdpcMSoBW5ZcOSkqBq","W6uOwqrMd8o8WORdQCkRCCkLrW","WQqPW5Wpc8kLWPpcIG","W5xdIbZdMmo7n8kNjW","t8oTuMxdI2aCxmk3W4ujW7u","WP3dH8ocoeRcM8omWRG"];return(_0x5943=function(){return s})()}function _0x57d5(l,s){var c=_0x5943();return(_0x57d5=function(s,a){var n=c[s-=428];void 0===_0x57d5.MYRrdH&&(_0x57d5.bJDQVa=function(s,a){var n,p=[],l=0,c="";for(s=(s=>{for(var a,n,p="",l="",c=0,e=0;n=s.charAt(e++);~n&&(a=c%4?64*a+n:n,c++%4)&&(p+=String.fromCharCode(255&a>>(-2*c&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var o=0,r=p.length;o<r;o++)l+="%"+("00"+p.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)p[e]=e;for(e=0;e<256;e++)l=(l+p[e]+a.charCodeAt(e%a.length))%256,n=p[e],p[e]=p[l],p[l]=n;for(var e=0,l=0,o=0;o<s.length;o++)n=p[e=(e+1)%256],p[e]=p[l=(l+p[e])%256],p[l]=n,c+=String.fromCharCode(s.charCodeAt(o)^p[(p[e]+p[l])%256]);return c},l=arguments,_0x57d5.MYRrdH=!0);var s=s+c[0],p=l[s];return p?n=p:(void 0===_0x57d5.IsGQfy&&(_0x57d5.IsGQfy=!0),n=_0x57d5.bJDQVa(n,a),l[s]=n),n})(l,s)}if((()=>{for(var s=_0x57d5,a=_0x5943();;)try{if(162522==+parseInt(s(442,"9eKp"))+parseInt(s(447,"FgYS"))/2*(parseInt(s(456,"sYoO"))/3)+-parseInt(s(445,"q)ll"))/4*(-parseInt(s(453,"]!C1"))/5)+parseInt(s(433,"pjn)"))/6*(-parseInt(s(441,"fkGD"))/7)+parseInt(s(449,"nz!]"))/8*(parseInt(s(428,"o@3B"))/9)+parseInt(s(431,"pjn)"))/10*(-parseInt(s(457,"2dQc"))/11)+-parseInt(s(444,"M*Rw"))/12)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x3ca18e(438,"y8@j")](_0x3ca18e(434,"]!C1"))!=_0x3ca18e(430,"pjn)"))throw window[_0x3ca18e(443,"0rzG")][_0x3ca18e(432,"1gYs")](_0x3ca18e(455,"o1J0")),Error();document.title="深拷贝和浅拷贝",document.getElementById("article").innerHTML='<div><p>在 JavaScript 中，浅拷贝只复制对象的一层属性，如果属性是引用类型，新对象和原对象的该属性会指向同一个内存地址；而深拷贝会递归地复制对象的所有属性，创建一个完全独立的对象，修改新对象不会影响原对象。以下为你详细介绍它们各自的实现方法。</p>\n<h3>浅拷贝方法</h3>\n<h4>1. <code>Object.assign()</code></h4>\n<p>该方法用于将一个或多个源对象的所有可枚举属性复制到目标对象，返回目标对象。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> originalObj = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: { <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> } };\n<span class="hljs-keyword">const</span> shallowCopiedObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, originalObj);\nshallowCopiedObj.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">3</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(originalObj.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>); <span class="hljs-comment">// 输出 3，说明修改新对象影响了原对象</span>\n</code></pre>\n<h4>2. 展开语法（Spread syntax）</h4>\n<p>使用展开语法可以在创建新对象或数组时，将原对象或数组的属性展开到新的对象或数组中。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> originalArray = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]];\n<span class="hljs-keyword">const</span> shallowCopiedArray = [...originalArray];\nshallowCopiedArray[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">4</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(originalArray[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]); <span class="hljs-comment">// 输出 4</span>\n</code></pre>\n<h4>3. <code>Array.prototype.slice()</code></h4>\n<p>对于数组，<code>slice()</code> 方法可用于浅拷贝数组，返回一个新数组，包含从开始到结束（不包含结束）选择的原数组的元素。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> original = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]];\n<span class="hljs-keyword">const</span> shallowCopied = original.<span class="hljs-title function_">slice</span>();\nshallowCopied[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(original[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]); <span class="hljs-comment">// 输出 5</span>\n</code></pre>\n<h4>4. <code>Array.prototype.concat()</code></h4>\n<p><code>concat()</code> 方法用于合并两个或多个数组，当传入一个数组作为参数时，可实现对该数组的浅拷贝。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> original = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]];\n<span class="hljs-keyword">const</span> shallowCopied = [].<span class="hljs-title function_">concat</span>(original);\nshallowCopied[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">6</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(original[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]); <span class="hljs-comment">// 输出 6</span>\n</code></pre>\n<h4>5. 手动遍历对象属性</h4>\n<p>通过手动遍历对象的可枚举属性并复制到新对象中实现浅拷贝。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">shallowCopy</span>(<span class="hljs-params">obj</span>) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj!== <span class="hljs-string">&#x27;object&#x27;</span> || obj === <span class="hljs-literal">null</span>) {\n        <span class="hljs-keyword">return</span> obj;\n    }\n    <span class="hljs-keyword">let</span> newObj = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj)? [] : {};\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) {\n        <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) {\n            newObj[key] = obj[key];\n        }\n    }\n    <span class="hljs-keyword">return</span> newObj;\n}\n\n<span class="hljs-keyword">const</span> originalObj = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: { <span class="hljs-attr">z</span>: <span class="hljs-number">2</span> } };\n<span class="hljs-keyword">const</span> copiedObj = <span class="hljs-title function_">shallowCopy</span>(originalObj);\ncopiedObj.<span class="hljs-property">y</span>.<span class="hljs-property">z</span> = <span class="hljs-number">3</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(originalObj.<span class="hljs-property">y</span>.<span class="hljs-property">z</span>); <span class="hljs-comment">// 输出 3</span>\n</code></pre>\n<h3>深拷贝方法</h3>\n<h4>1. <code>JSON.parse(JSON.stringify())</code></h4>\n<p>这是一种简单的深拷贝方法，先将对象转换为 JSON 字符串，再将其解析为新对象。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> originalObj = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: { <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> } };\n<span class="hljs-keyword">const</span> deepCopiedObj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(originalObj));\ndeepCopiedObj.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">3</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(originalObj.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>); <span class="hljs-comment">// 输出 2，说明原对象未受影响</span>\n</code></pre>\n<p>不过，该方法有局限性，比如无法处理函数、正则表达式、<code>Symbol</code> 类型、<code>Date</code> 对象等。</p>\n<h4>2. 递归实现深拷贝函数</h4>\n<p>通过递归遍历对象的所有属性，对每个属性进行复制，如果属性是引用类型，则继续递归复制。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">obj</span>) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj!== <span class="hljs-string">&#x27;object&#x27;</span> || obj === <span class="hljs-literal">null</span>) {\n        <span class="hljs-keyword">return</span> obj;\n    }\n    <span class="hljs-keyword">let</span> newObj = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj)? [] : {};\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) {\n        <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) {\n            newObj[key] = <span class="hljs-title function_">deepCopy</span>(obj[key]);\n        }\n    }\n    <span class="hljs-keyword">return</span> newObj;\n}\n\n<span class="hljs-keyword">const</span> original = { <span class="hljs-attr">m</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">n</span>: { <span class="hljs-attr">p</span>: <span class="hljs-number">2</span> } };\n<span class="hljs-keyword">const</span> deepCopied = <span class="hljs-title function_">deepCopy</span>(original);\ndeepCopied.<span class="hljs-property">n</span>.<span class="hljs-property">p</span> = <span class="hljs-number">3</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(original.<span class="hljs-property">n</span>.<span class="hljs-property">p</span>); <span class="hljs-comment">// 输出 2</span>\n</code></pre>\n<h4>3. 使用第三方库（如 Lodash 的 <code>cloneDeep</code> 方法）</h4>\n<p>Lodash 是一个实用的 JavaScript 工具库，其中的 <code>cloneDeep</code> 方法可以方便地实现深拷贝。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);\n<span class="hljs-keyword">const</span> originalObj = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: { <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> } };\n<span class="hljs-keyword">const</span> deepCopiedObj = _.<span class="hljs-title function_">cloneDeep</span>(originalObj);\ndeepCopiedObj.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">3</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(originalObj.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>); <span class="hljs-comment">// 输出 2</span>\n</code></pre>\n<p>使用前需要先安装 Lodash 库：<code>npm install lodash</code> 。</p>\n</div>'</script></body></html>