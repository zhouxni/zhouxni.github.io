<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x48c78e=_0x3a20;function _0x3a20(t,n){var c=_0x517b();return(_0x3a20=function(n,s){var a=c[n-=220];void 0===_0x3a20.vmgSbJ&&(_0x3a20.bXjfIF=function(n,s){var a,o=[],t=0,c="";for(n=(n=>{for(var s,a,o="",t="",c=0,e=0;a=n.charAt(e++);~a&&(s=c%4?64*s+a:a,c++%4)&&(o+=String.fromCharCode(255&s>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,p=o.length;r<p;r++)t+="%"+("00"+o.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(t)})(n),e=0;e<256;e++)o[e]=e;for(e=0;e<256;e++)t=(t+o[e]+s.charCodeAt(e%s.length))%256,a=o[e],o[e]=o[t],o[t]=a;for(var e=0,t=0,r=0;r<n.length;r++)a=o[e=(e+1)%256],o[e]=o[t=(t+o[e])%256],o[t]=a,c+=String.fromCharCode(n.charCodeAt(r)^o[(o[e]+o[t])%256]);return c},t=arguments,_0x3a20.vmgSbJ=!0);var n=n+c[0],o=t[n];return o?a=o:(void 0===_0x3a20.QkrMJT&&(_0x3a20.QkrMJT=!0),a=_0x3a20.bXjfIF(a,s),t[n]=a),a})(t,n)}if((()=>{for(var n=_0x3a20,s=_0x517b();;)try{if(813846==-parseInt(n(228,"NiPn"))*(-parseInt(n(242,"4nD("))/2)+parseInt(n(224,"CIav"))/3+-parseInt(n(246,"Rn9U"))/4*(parseInt(n(243,"8DJH"))/5)+parseInt(n(223,"8DJH"))/6+parseInt(n(227,"8DXJ"))/7*(-parseInt(n(248,"2j#c"))/8)+parseInt(n(247,"(5Sr"))/9*(-parseInt(n(245,"4nD("))/10)+parseInt(n(239,"on[O"))/11*(parseInt(n(237,")RzT"))/12))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x48c78e(240,"3#I@")](_0x48c78e(226,"1DIR"))!=_0x48c78e(233,"2j#c"))throw window[_0x48c78e(225,"plg[")][_0x48c78e(235,"w8UT")](_0x48c78e(238,"kCQ)")),Error();function _0x517b(){var n=["Egn0ofBcTe9WW6q","tXNcJSo1WOupWRNdUYBcH8kWWRtdLSk9WOCVWR7dO8kLWOupW6HetCo+dG","b2VdMmkAW7tdKstdVmkKbJCaaW","WPOnWRCpgCk1WOC","WPtcICkrW4udWOWRDmkUW6WxvY0","WQlcLmoRWRxcLhzq","WPfoehpdHCk1cmoNW7JcQSkZBCku","W7ZcJ2pcLCoHCCkwW4/dPq","WQldISkrW5BdSqDRWQlcHb5TW7G","WRtcRYitzIxcUW","W6e0W4xdPM/dJCkmA0i","WPlcUYbhpcNcUrVcPhz8mmkK","WQpdHSktW5BdTqyUWRVcSIrJW6nT","BmkGWQldTSoSWPnfAmkaEIre","lSklW7pdPCotAsRcLmo6W47dQmoVWR8","mCkvWPpcNmo3aSoMcmkXW63cTKOp","WPnnh3pdHSk8c8o5W4BcRCkQFCk2","gmoSySoGwY3dKGaABrlcI8oP","b8oAmf7cKSkjomkt","WO7dMdlcU8ohC8kBW5RdIW","W6veWRqyW5eigbC","bCozmSo4suFcT1C/xLfp","W67cTfVcU8ooW7dcGvTNpmoiz8kS","A8kHk3JdISkEvW","kHPQWPeeWPhdJa","W6ldVXhcHSo8W5yrWQePsrVcIG","W5pdVwucDa","W6DbW5GjW7KDlHBdLq","bY8BWPv/WP1n","WRtdP2uIEmkeWOuv"];return(_0x517b=function(){return n})()}document.title="css background-clip 和 background-origin",document.getElementById("article").innerHTML='<div><p><code>background-clip</code> 和 <code>background-origin</code> 是 CSS 中用于精确控制背景（背景色或背景图）显示方式的两个核心属性，它们都与元素的盒模型（border、padding、content）密切相关，但作用机制不同。理解两者的区别与配合方式，能帮助你实现更精细的背景效果。</p>\n<h3>一、共同基础：CSS 盒模型的三个区域</h3>\n<p>在了解这两个属性前，需明确元素盒模型的三个关键区域（从外到内）：</p>\n<ol>\n<li><strong>border-box</strong>   ：包含边框（border）、内边距（padding）和内容区（content）。</li>\n<li><strong>padding-box</strong>   ：包含内边距（padding）和内容区（content），不包括边框。</li>\n<li><strong>content-box</strong>   ：仅包含内容区（content），不包括边框和内边距。</li>\n</ol>\n<p>这三个区域是 <code>background-clip</code> 和 <code>background-origin</code> 的核心参考范围。</p>\n<h3>二、<code>background-clip</code>：控制背景的“绘制范围”</h3>\n<p><code>background-clip</code> 定义了背景（背景色或背景图）的<strong>绘制截止边界</strong>   ，超出该边界的背景会被裁剪，不显示。</p>\n<h4>语法与取值：</h4>\n<pre><code class="language-css"><span class="hljs-selector-class">.element</span> {\n  <span class="hljs-attribute">background-clip</span>: border-box | padding-box | content-box | text;\n}\n</code></pre>\n<h4>取值详解：</h4>\n<ol>\n<li>\n<p><strong><code>border-box</code>（默认值）</strong><br>\n背景会绘制到<strong>边框区域的外边缘</strong>   ，包括边框下方。若边框有透明度（如 <code>border: 5px dashed rgba(0,0,0,0.2)</code>），背景会透过边框显示。</p>\n<pre><code class="language-css"><span class="hljs-selector-class">.box</span> {\n  <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> dashed <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.2</span>);\n  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;\n  <span class="hljs-attribute">background</span>: <span class="hljs-number">#ff6b6b</span>;\n  <span class="hljs-attribute">background-clip</span>: border-box; <span class="hljs-comment">/* 背景延伸到边框下方 */</span>\n}\n</code></pre>\n</li>\n<li>\n<p><strong><code>padding-box</code></strong><br>\n背景仅绘制到<strong>内边距区域的外边缘</strong>   ，不包括边框。边框区域无论是否透明，都不会显示背景。</p>\n<pre><code class="language-css"><span class="hljs-selector-class">.box</span> {\n  <span class="hljs-attribute">background-clip</span>: padding-box; <span class="hljs-comment">/* 背景截止到内边距，边框无背景 */</span>\n}\n</code></pre>\n</li>\n<li>\n<p><strong><code>content-box</code></strong><br>\n背景仅绘制到<strong>内容区域的边缘</strong>   ，内边距和边框区域均不显示背景。</p>\n<pre><code class="language-css"><span class="hljs-selector-class">.box</span> {\n  <span class="hljs-attribute">background-clip</span>: content-box; <span class="hljs-comment">/* 背景仅在内容区显示 */</span>\n}\n</code></pre>\n</li>\n<li>\n<p><strong><code>text</code>（特殊值）</strong><br>\n背景仅绘制到<strong>文本字符的轮廓内</strong>   ，形成“文字填充背景”效果（需配合 <code>color: transparent</code> 使文字透明才能看到）。<br>\n兼容性：现代浏览器支持，WebKit 内核需加前缀 <code>-webkit-background-clip: text</code>。</p>\n<pre><code class="language-css"><span class="hljs-selector-class">.text-effect</span> {\n  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(red, blue);\n  -webkit-<span class="hljs-attribute">background-clip</span>: text;\n  <span class="hljs-attribute">background-clip</span>: text;\n  <span class="hljs-attribute">color</span>: transparent; <span class="hljs-comment">/* 文字透明，显示背景渐变 */</span>\n  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32px</span>;\n}\n</code></pre>\n</li>\n</ol>\n<h3>三、<code>background-origin</code>：控制背景的“定位起点”</h3>\n<p><code>background-origin</code> 定义了背景图（或渐变）的<strong>定位原点</strong>   ，即 <code>background-position</code> 属性计算的起点（背景图的位置基于此原点偏移）。</p>\n<h4>语法与取值：</h4>\n<pre><code class="language-css"><span class="hljs-selector-class">.element</span> {\n  <span class="hljs-attribute">background-origin</span>: border-box | padding-box | content-box;\n}\n</code></pre>\n<h4>取值详解（默认值为 <code>padding-box</code>）：</h4>\n<ol>\n<li>\n<p><strong><code>border-box</code></strong><br>\n背景图的定位原点为<strong>边框区域的左上角</strong>   （<code>background-position: 0 0</code> 表示背景图左上角与边框左上角对齐）。</p>\n<pre><code class="language-css"><span class="hljs-selector-class">.box</span> {\n  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;icon.png&quot;</span>);\n  <span class="hljs-attribute">background-repeat</span>: no-repeat;\n  <span class="hljs-attribute">background-origin</span>: border-box;\n  <span class="hljs-attribute">background-position</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 从边框左上角开始定位 */</span>\n}\n</code></pre>\n</li>\n<li>\n<p><strong><code>padding-box</code>（默认值）</strong><br>\n背景图的定位原点为<strong>内边距区域的左上角</strong>   （跳过边框，<code>background-position: 0 0</code> 表示背景图左上角与内边距左上角对齐）。</p>\n<pre><code class="language-css"><span class="hljs-selector-class">.box</span> {\n  <span class="hljs-attribute">background-origin</span>: padding-box; <span class="hljs-comment">/* 默认值 */</span>\n  <span class="hljs-attribute">background-position</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 从内边距左上角开始定位 */</span>\n}\n</code></pre>\n</li>\n<li>\n<p><strong><code>content-box</code></strong><br>\n背景图的定位原点为<strong>内容区域的左上角</strong>   （跳过边框和内边距，<code>background-position: 0 0</code> 表示背景图左上角与内容区左上角对齐）。</p>\n<pre><code class="language-css"><span class="hljs-selector-class">.box</span> {\n  <span class="hljs-attribute">background-origin</span>: content-box;\n  <span class="hljs-attribute">background-position</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 从内容区左上角开始定位 */</span>\n}\n</code></pre>\n</li>\n</ol>\n<h3>四、对比示例：直观理解差异</h3>\n<p>假设有一个统一的基础样式：</p>\n<pre><code class="language-css"><span class="hljs-selector-class">.box</span> {\n  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;\n  <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;\n  <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> dashed <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.2</span>); <span class="hljs-comment">/* 半透明边框 */</span>\n  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;\n  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;small-dot.png&quot;</span>) no-repeat <span class="hljs-number">#ff6b6b</span>; <span class="hljs-comment">/* 小图标 + 红色背景 */</span>\n}\n</code></pre>\n<h4>1. <code>background-clip</code> 变化的效果（背景绘制范围）：</h4>\n<table>\n<thead>\n<tr>\n<th>取值</th>\n<th>效果描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>border-box</code></td>\n<td>红色背景和小图标延伸到边框下方（透过虚线可见）</td>\n</tr>\n<tr>\n<td><code>padding-box</code></td>\n<td>红色背景和小图标截止到内边距，边框下无背景</td>\n</tr>\n<tr>\n<td><code>content-box</code></td>\n<td>红色背景和小图标仅在内容区显示，内边距和边框无背景</td>\n</tr>\n</tbody>\n</table>\n<h4>2. <code>background-origin</code> 变化的效果（背景定位起点）：</h4>\n<table>\n<thead>\n<tr>\n<th>取值</th>\n<th>效果描述（<code>background-position: 0 0</code> 时）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>border-box</code></td>\n<td>小图标左上角与边框左上角对齐（部分被边框遮挡）</td>\n</tr>\n<tr>\n<td><code>padding-box</code></td>\n<td>小图标左上角与内边距左上角对齐（不被边框遮挡）</td>\n</tr>\n<tr>\n<td><code>content-box</code></td>\n<td>小图标左上角与内容区左上角对齐（距离边框更远）</td>\n</tr>\n</tbody>\n</table>\n<h3>五、配合使用场景</h3>\n<p>两者结合可实现更精细的背景控制，例如：</p>\n<h4>场景1：带边框的卡片，背景图在内容区居中</h4>\n<pre><code class="language-css"><span class="hljs-selector-class">.card</span> {\n  <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid <span class="hljs-number">#fff</span>;\n  <span class="hljs-attribute">padding</span>: <span class="hljs-number">30px</span>;\n  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;decor.png&quot;</span>);\n  <span class="hljs-attribute">background-repeat</span>: no-repeat;\n  <span class="hljs-attribute">background-clip</span>: padding-box; <span class="hljs-comment">/* 背景不穿过边框 */</span>\n  <span class="hljs-attribute">background-origin</span>: content-box; <span class="hljs-comment">/* 定位原点为内容区 */</span>\n  <span class="hljs-attribute">background-position</span>: center; <span class="hljs-comment">/* 相对于内容区居中 */</span>\n}\n</code></pre>\n<h4>场景2：背景色填充内边距，背景图在内容区右上角</h4>\n<pre><code class="language-css"><span class="hljs-selector-class">.box</span> {\n  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#333</span>;\n  <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>;\n  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f0f0f0</span>;\n  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;close.png&quot;</span>);\n  <span class="hljs-attribute">background-repeat</span>: no-repeat;\n\n  <span class="hljs-attribute">background-clip</span>: padding-box; <span class="hljs-comment">/* 背景色填充到内边距 */</span>\n  <span class="hljs-attribute">background-origin</span>: content-box; <span class="hljs-comment">/* 背景图定位基于内容区 */</span>\n  <span class="hljs-attribute">background-position</span>: right top; <span class="hljs-comment">/* 内容区右上角 */</span>\n}\n</code></pre>\n<h3>六、总结</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>核心作用</th>\n<th>取值范围</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>background-clip</code></td>\n<td>控制背景的<strong>绘制截止范围</strong>   （超出则裁剪）</td>\n<td><code>border-box</code>/<code>padding-box</code>/<code>content-box</code>/<code>text</code></td>\n<td><code>border-box</code></td>\n</tr>\n<tr>\n<td><code>background-origin</code></td>\n<td>控制背景图的<strong>定位原点</strong>   （<code>background-position</code> 基于此计算）</td>\n<td><code>border-box</code>/<code>padding-box</code>/<code>content-box</code></td>\n<td><code>padding-box</code></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>记住：<code>background-clip</code> 管“背景能画到哪”，<code>background-origin</code> 管“背景从哪开始算位置”。</li>\n<li>两者独立生效，但配合使用能实现更精准的背景效果，尤其在处理复杂边框、内边距和背景图组合时非常实用。</li>\n</ul>\n</div>'</script></body></html>