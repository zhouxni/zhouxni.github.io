<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2958(e,s){var p=_0x3af9();return(_0x2958=function(s,n){var a=p[s-=374];void 0===_0x2958.gedXKh&&(_0x2958.vQJbnY=function(s,n){var a,l=[],e=0,p="";for(s=(s=>{for(var n,a,l="",e="",p=0,o=0;a=s.charAt(o++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,c=l.length;t<c;t++)e+="%"+("00"+l.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(e)})(s),o=0;o<256;o++)l[o]=o;for(o=0;o<256;o++)e=(e+l[o]+n.charCodeAt(o%n.length))%256,a=l[o],l[o]=l[e],l[e]=a;for(var o=0,e=0,t=0;t<s.length;t++)a=l[o=(o+1)%256],l[o]=l[e=(e+l[o])%256],l[e]=a,p+=String.fromCharCode(s.charCodeAt(t)^l[(l[o]+l[e])%256]);return p},e=arguments,_0x2958.gedXKh=!0);var s=s+p[0],l=e[s];return l?a=l:(void 0===_0x2958.ipJUll&&(_0x2958.ipJUll=!0),a=_0x2958.vQJbnY(a,n),e[s]=a),a})(e,s)}var _0x42381c=_0x2958;if((()=>{for(var s=_0x2958,n=_0x3af9();;)try{if(879647==+parseInt(s(385,"V0rR"))+-parseInt(s(376,"^lla"))/2+-parseInt(s(387,"cXGb"))/3*(-parseInt(s(380,"MLAI"))/4)+parseInt(s(382,"*12y"))/5*(parseInt(s(397,"1$fS"))/6)+-parseInt(s(378,"JpGt"))/7+parseInt(s(389,"8h4d"))/8*(-parseInt(s(396,"O3HR"))/9)+parseInt(s(393,"S4!v"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x42381c(375,"DGFG")](_0x42381c(386,"p*g0"))!=_0x42381c(398,"V0rR"))throw window[_0x42381c(384,"9&%0")][_0x42381c(388,"c0Zr")](_0x42381c(379,"AC7M")),Error();function _0x3af9(){var s=["rMnSBZJcU8ogwSk+","cfmkhCklWQ/dRSodWQH6vW","W7JcN8o+seLUjW","W4b/WOhcMSkqimkxAa","nJC6oxJdSmk/C8k9W4JdMSkJFW","W7xcI8oNW5VcOSoYWPn7bSoaWQ8","W5qesCkAW6H8tSoH","W6fXWQBcOt/cVConvmkjW7rlW67cJay","W7xcICkYWPJdSSoQWQbj","gmk9amkjWPqRW7zwW7OUWRxcISoTW4S","gw7dGhaExmojWOVcTItdI34","W5ZcSmk8yNa1WRdcGCo0WQWQWQfX","WRxdIaGcW7u","sSoLbCkzs0CCWQRcU8kFASoD","WQfgWP0xWPGopq","WPaUW70wce0PWQHbW7OgcCoQ","WRtdQmkod8knvSkDWR13W6G4Eg8","W7xcICoJW5RcQ8keW4alkmolWQ3dVvez","WOuSW6JcS1WoWQhdIZqroCk0WQtcOXpdVHpdKd8VWRFcHmkmWOhcRuy","oxddLSk7vmkAW73dLmkJ","WRndwaVcRSkYF8o4WRW","WPtcSCoRb8kZFu7dPa","uSkAW5HnW6VdQSkqWR/cISovnHZcSG","rCoIv8ozW5b6WQ0a","W7tcIeTaWRRdHCk5W4bSW7NcQJldJW"];return(_0x3af9=function(){return s})()}document.title="vue3 diff 双端指针跳出",document.getElementById("article").innerHTML='<div><p>在 Vue 3 的虚拟 DOM diff 算法里，双端比较是一种用于高效对比新旧子节点列表的策略。不过，当双端比较无法处理当前情况时，就会进入后续的处理流程，下面详细阐述指针移动以及后续处理的情况。</p>\n<h3>双端比较无法处理的情况</h3>\n<p>当双端比较中旧头节点、旧尾节点、新头节点、新尾节点两两对比时，若都找不到可复用的节点，双端比较就无法继续进行，此时会跳出双端比较的循环。</p>\n<h3>后续处理及指针移动</h3>\n<h4>1. 建立新节点的映射表</h4>\n<p>在双端比较无法处理时，会创建一个新节点的映射表 <code>keyToNewIndexMap</code>，用于记录新节点在新子节点列表中的位置信息。映射表的键是新节点的 <code>key</code>，值是新节点在新子节点列表中的索引。</p>\n<h4>2. 遍历旧节点列表</h4>\n<p>接着会遍历旧节点列表，对于每个旧节点，在 <code>keyToNewIndexMap</code> 中查找是否存在对应的新节点。</p>\n<ul>\n<li><strong>找到对应新节点</strong>  ：\n<ul>\n<li>调用 <code>patch</code> 函数更新该节点的属性和子节点。</li>\n<li>将该旧节点在旧子节点列表中的索引加 1 后，记录到 newIndexToOldIndexMap 数组中对应新节点索引的位置。加 1 是为了区分初始值 0，因为初始值 0 表示该新节点在旧节点列表中没有对应节点。</li>\n<li>同时将 <code>moved</code> 标志设为 <code>true</code>，表示存在节点移动的情况。</li>\n</ul>\n</li>\n<li><strong>未找到对应新节点</strong>  ：\n<ul>\n<li>直接移除该旧节点对应的真实 DOM 元素。</li>\n</ul>\n</li>\n</ul>\n<h4>3. 计算最长递增子序列</h4>\n<p>当遍历完旧节点列表后，如果 <code>moved</code> 标志为 <code>true</code>，就需要计算 <code>newIndexToOldIndexMap</code> 数组的最长递增子序列（LIS）。最长递增子序列中的节点不需要移动，而其他节点需要移动到合适的位置。</p>\n<h4>4. 插入新节点</h4>\n<p>从后往前遍历新节点列表，对于不在最长递增子序列中的节点，将其插入到正确的位置。同时，指针的移动逻辑如下：</p>\n<ul>\n<li><strong>旧节点指针</strong>  ：在遍历旧节点列表时，<code>oldIndex</code> 指针会从 <code>oldStartIndex</code> 逐步增加到 <code>oldEndIndex</code>。</li>\n<li><strong>新节点指针</strong>  ：在插入新节点时，会根据 <code>newIndexToOldIndexMap</code> 数组和最长递增子序列的结果来确定新节点的插入位置，并没有像双端比较那样有固定的指针移动方式。</li>\n</ul>\n<h3>代码示例</h3>\n<p>以下是一个简化的代码示例，展示了双端比较无法处理时的后续处理逻辑：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 简化的虚拟 DOM 节点类</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">VNode</span> {\n    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">tag, props, children, key</span>) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span> = props;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span> = children;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;\n    }\n}\n\n<span class="hljs-comment">// 简化的 patch 函数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">oldVNode, newVNode, container</span>) {\n    <span class="hljs-keyword">if</span> (!oldVNode) {\n        <span class="hljs-comment">// 旧节点不存在，直接插入新节点</span>\n        <span class="hljs-title function_">mount</span>(newVNode, container);\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!newVNode) {\n        <span class="hljs-comment">// 新节点不存在，移除旧节点</span>\n        <span class="hljs-title function_">unmount</span>(oldVNode);\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldVNode.<span class="hljs-property">tag</span> !== newVNode.<span class="hljs-property">tag</span>) {\n        <span class="hljs-comment">// 节点类型不同，替换旧节点</span>\n        <span class="hljs-title function_">unmount</span>(oldVNode);\n        <span class="hljs-title function_">mount</span>(newVNode, container);\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-comment">// 节点类型相同，更新属性和子节点</span>\n        <span class="hljs-title function_">patchProps</span>(oldVNode.<span class="hljs-property">props</span>, newVNode.<span class="hljs-property">props</span>, oldVNode.<span class="hljs-property">el</span>);\n        <span class="hljs-title function_">patchChildren</span>(oldVNode.<span class="hljs-property">children</span>, newVNode.<span class="hljs-property">children</span>, oldVNode.<span class="hljs-property">el</span>);\n    }\n}\n\n<span class="hljs-comment">// 挂载新节点</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">mount</span>(<span class="hljs-params">vNode, container</span>) {\n    <span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(vNode.<span class="hljs-property">tag</span>);\n    vNode.<span class="hljs-property">el</span> = el;\n    <span class="hljs-title function_">patchProps</span>({}, vNode.<span class="hljs-property">props</span>, el);\n    <span class="hljs-title function_">patchChildren</span>([], vNode.<span class="hljs-property">children</span>, el);\n    container.<span class="hljs-title function_">appendChild</span>(el);\n}\n\n<span class="hljs-comment">// 移除旧节点</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">unmount</span>(<span class="hljs-params">vNode</span>) {\n    vNode.<span class="hljs-property">el</span>.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(vNode.<span class="hljs-property">el</span>);\n}\n\n<span class="hljs-comment">// 更新属性</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">patchProps</span>(<span class="hljs-params">oldProps, newProps, el</span>) {\n    <span class="hljs-comment">// 移除旧属性</span>\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> oldProps) {\n        <span class="hljs-keyword">if</span> (!newProps[key]) {\n            el.<span class="hljs-title function_">removeAttribute</span>(key);\n        }\n    }\n    <span class="hljs-comment">// 更新或添加新属性</span>\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> newProps) {\n        el.<span class="hljs-title function_">setAttribute</span>(key, newProps[key]);\n    }\n}\n\n<span class="hljs-comment">// 双端比较更新子节点</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">patchChildren</span>(<span class="hljs-params">oldChildren, newChildren, container</span>) {\n    <span class="hljs-keyword">let</span> oldStartIndex = <span class="hljs-number">0</span>;\n    <span class="hljs-keyword">let</span> oldEndIndex = oldChildren.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;\n    <span class="hljs-keyword">let</span> newStartIndex = <span class="hljs-number">0</span>;\n    <span class="hljs-keyword">let</span> newEndIndex = newChildren.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;\n\n    <span class="hljs-keyword">while</span> (oldStartIndex &lt;= oldEndIndex &amp;&amp; newStartIndex &lt;= newEndIndex) {\n        <span class="hljs-keyword">const</span> oldStartVNode = oldChildren[oldStartIndex];\n        <span class="hljs-keyword">const</span> oldEndVNode = oldChildren[oldEndIndex];\n        <span class="hljs-keyword">const</span> newStartVNode = newChildren[newStartIndex];\n        <span class="hljs-keyword">const</span> newEndVNode = newChildren[newEndIndex];\n\n        <span class="hljs-keyword">if</span> (oldStartVNode.<span class="hljs-property">key</span> === newStartVNode.<span class="hljs-property">key</span> &amp;&amp; oldStartVNode.<span class="hljs-property">tag</span> === newStartVNode.<span class="hljs-property">tag</span>) {\n            <span class="hljs-comment">// 旧头节点和新头节点相同</span>\n            <span class="hljs-title function_">patch</span>(oldStartVNode, newStartVNode, container);\n            oldStartIndex++;\n            newStartIndex++;\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldEndVNode.<span class="hljs-property">key</span> === newEndVNode.<span class="hljs-property">key</span> &amp;&amp; oldEndVNode.<span class="hljs-property">tag</span> === newEndVNode.<span class="hljs-property">tag</span>) {\n            <span class="hljs-comment">// 旧尾节点和新尾节点相同</span>\n            <span class="hljs-title function_">patch</span>(oldEndVNode, newEndVNode, container);\n            oldEndIndex--;\n            newEndIndex--;\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldStartVNode.<span class="hljs-property">key</span> === newEndVNode.<span class="hljs-property">key</span> &amp;&amp; oldStartVNode.<span class="hljs-property">tag</span> === newEndVNode.<span class="hljs-property">tag</span>) {\n            <span class="hljs-comment">// 旧头节点和新尾节点相同</span>\n            <span class="hljs-title function_">patch</span>(oldStartVNode, newEndVNode, container);\n            container.<span class="hljs-title function_">insertBefore</span>(oldStartVNode.<span class="hljs-property">el</span>, oldEndVNode.<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span>);\n            oldStartIndex++;\n            newEndIndex--;\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldEndVNode.<span class="hljs-property">key</span> === newStartVNode.<span class="hljs-property">key</span> &amp;&amp; oldEndVNode.<span class="hljs-property">tag</span> === newStartVNode.<span class="hljs-property">tag</span>) {\n            <span class="hljs-comment">// 旧尾节点和新头节点相同</span>\n            <span class="hljs-title function_">patch</span>(oldEndVNode, newStartVNode, container);\n            container.<span class="hljs-title function_">insertBefore</span>(oldEndVNode.<span class="hljs-property">el</span>, oldStartVNode.<span class="hljs-property">el</span>);\n            oldEndIndex--;\n            newStartIndex++;\n        } <span class="hljs-keyword">else</span> {\n            <span class="hljs-comment">// 双端比较无法处理，跳出循环</span>\n            <span class="hljs-keyword">break</span>;\n        }\n    }\n\n    <span class="hljs-keyword">if</span> (oldStartIndex &lt;= oldEndIndex || newStartIndex &lt;= newEndIndex) {\n        <span class="hljs-comment">// 建立新节点的映射表</span>\n        <span class="hljs-keyword">const</span> keyToNewIndexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = newStartIndex; i &lt;= newEndIndex; i++) {\n            <span class="hljs-keyword">const</span> newVNode = newChildren[i];\n            <span class="hljs-keyword">if</span> (newVNode.<span class="hljs-property">key</span> != <span class="hljs-literal">null</span>) {\n                keyToNewIndexMap.<span class="hljs-title function_">set</span>(newVNode.<span class="hljs-property">key</span>, i);\n            }\n        }\n\n        <span class="hljs-comment">// 遍历旧节点列表</span>\n        <span class="hljs-keyword">let</span> moved = <span class="hljs-literal">false</span>;\n        <span class="hljs-keyword">let</span> maxNewIndexSoFar = <span class="hljs-number">0</span>;\n        <span class="hljs-keyword">const</span> newIndexToOldIndexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(newEndIndex - newStartIndex + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = oldStartIndex; i &lt;= oldEndIndex; i++) {\n            <span class="hljs-keyword">const</span> oldVNode = oldChildren[i];\n            <span class="hljs-keyword">let</span> newIndex;\n            <span class="hljs-keyword">if</span> (oldVNode.<span class="hljs-property">key</span> != <span class="hljs-literal">null</span>) {\n                newIndex = keyToNewIndexMap.<span class="hljs-title function_">get</span>(oldVNode.<span class="hljs-property">key</span>);\n            } <span class="hljs-keyword">else</span> {\n                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = newStartIndex; j &lt;= newEndIndex; j++) {\n                    <span class="hljs-keyword">if</span> (newIndexToOldIndexMap[j - newStartIndex] === <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-title function_">isSameVNodeType</span>(oldVNode, newChildren[j])) {\n                        newIndex = j;\n                        <span class="hljs-keyword">break</span>;\n                    }\n                }\n            }\n\n            <span class="hljs-keyword">if</span> (newIndex === <span class="hljs-literal">undefined</span>) {\n                <span class="hljs-comment">// 未找到对应新节点，移除旧节点</span>\n                <span class="hljs-title function_">unmount</span>(oldVNode);\n            } <span class="hljs-keyword">else</span> {\n                newIndexToOldIndexMap[newIndex - newStartIndex] = i + <span class="hljs-number">1</span>;\n                <span class="hljs-keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) {\n                    maxNewIndexSoFar = newIndex;\n                } <span class="hljs-keyword">else</span> {\n                    moved = <span class="hljs-literal">true</span>;\n                }\n                <span class="hljs-title function_">patch</span>(oldVNode, newChildren[newIndex], container);\n            }\n        }\n\n        <span class="hljs-comment">// 计算最长递增子序列</span>\n        <span class="hljs-keyword">const</span> increasingNewIndexSequence = moved ? <span class="hljs-title function_">getSequence</span>(newIndexToOldIndexMap) : [];\n        <span class="hljs-keyword">let</span> j = increasingNewIndexSequence.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = newEndIndex; i &gt;= newStartIndex; i--) {\n            <span class="hljs-keyword">const</span> nextIndex = i + <span class="hljs-number">1</span>;\n            <span class="hljs-keyword">const</span> nextVNode = nextIndex &lt; newChildren.<span class="hljs-property">length</span> ? newChildren[nextIndex] : <span class="hljs-literal">null</span>;\n            <span class="hljs-keyword">const</span> anchor = nextVNode ? nextVNode.<span class="hljs-property">el</span> : <span class="hljs-literal">null</span>;\n            <span class="hljs-keyword">const</span> newIndex = i;\n            <span class="hljs-keyword">if</span> (newIndexToOldIndexMap[newIndex - newStartIndex] === <span class="hljs-number">0</span>) {\n                <span class="hljs-comment">// 插入新节点</span>\n                <span class="hljs-title function_">mount</span>(newChildren[newIndex], container, anchor);\n            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (moved) {\n                <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span> || increasingNewIndexSequence[j]!== newIndex) {\n                    <span class="hljs-comment">// 需要移动节点</span>\n                    container.<span class="hljs-title function_">insertBefore</span>(newChildren[newIndex].<span class="hljs-property">el</span>, anchor);\n                } <span class="hljs-keyword">else</span> {\n                    j--;\n                }\n            }\n        }\n    }\n}\n\n<span class="hljs-comment">// 判断两个节点是否类型相同</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">isSameVNodeType</span>(<span class="hljs-params">n1, n2</span>) {\n    <span class="hljs-keyword">return</span> n1.<span class="hljs-property">tag</span> === n2.<span class="hljs-property">tag</span> &amp;&amp; n1.<span class="hljs-property">key</span> === n2.<span class="hljs-property">key</span>;\n}\n\n<span class="hljs-comment">// 计算最长递增子序列</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">getSequence</span>(<span class="hljs-params">arr</span>) {\n    <span class="hljs-keyword">const</span> p = arr.<span class="hljs-title function_">slice</span>();\n    <span class="hljs-keyword">const</span> result = [<span class="hljs-number">0</span>];\n    <span class="hljs-keyword">let</span> i, j, u, v, c;\n    <span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>;\n    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {\n        <span class="hljs-keyword">const</span> arrI = arr[i];\n        <span class="hljs-keyword">if</span> (arrI!== <span class="hljs-number">0</span>) {\n            j = result[result.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];\n            <span class="hljs-keyword">if</span> (arr[j] &lt; arrI) {\n                p[i] = j;\n                result.<span class="hljs-title function_">push</span>(i);\n                <span class="hljs-keyword">continue</span>;\n            }\n            u = <span class="hljs-number">0</span>;\n            v = result.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;\n            <span class="hljs-keyword">while</span> (u &lt; v) {\n                c = (u + v) &gt;&gt; <span class="hljs-number">1</span>;\n                <span class="hljs-keyword">if</span> (arr[result[c]] &lt; arrI) {\n                    u = c + <span class="hljs-number">1</span>;\n                } <span class="hljs-keyword">else</span> {\n                    v = c;\n                }\n            }\n            <span class="hljs-keyword">if</span> (arrI &lt; arr[result[u]]) {\n                <span class="hljs-keyword">if</span> (u &gt; <span class="hljs-number">0</span>) {\n                    p[i] = result[u - <span class="hljs-number">1</span>];\n                }\n                result[u] = i;\n            }\n        }\n    }\n    u = result.<span class="hljs-property">length</span>;\n    v = result[u - <span class="hljs-number">1</span>];\n    <span class="hljs-keyword">while</span> (u-- &gt; <span class="hljs-number">0</span>) {\n        result[u] = v;\n        v = p[v];\n    }\n    <span class="hljs-keyword">return</span> result;\n}\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-keyword">const</span> oldChildren = [\n    <span class="hljs-keyword">new</span> <span class="hljs-title class_">VNode</span>(<span class="hljs-string">&#x27;div&#x27;</span>, {}, [], <span class="hljs-string">&#x27;A&#x27;</span>),\n    <span class="hljs-keyword">new</span> <span class="hljs-title class_">VNode</span>(<span class="hljs-string">&#x27;div&#x27;</span>, {}, [], <span class="hljs-string">&#x27;B&#x27;</span>),\n    <span class="hljs-keyword">new</span> <span class="hljs-title class_">VNode</span>(<span class="hljs-string">&#x27;div&#x27;</span>, {}, [], <span class="hljs-string">&#x27;C&#x27;</span>)\n];\n<span class="hljs-keyword">const</span> newChildren = [\n    <span class="hljs-keyword">new</span> <span class="hljs-title class_">VNode</span>(<span class="hljs-string">&#x27;div&#x27;</span>, {}, [], <span class="hljs-string">&#x27;D&#x27;</span>),\n    <span class="hljs-keyword">new</span> <span class="hljs-title class_">VNode</span>(<span class="hljs-string">&#x27;div&#x27;</span>, {}, [], <span class="hljs-string">&#x27;A&#x27;</span>),\n    <span class="hljs-keyword">new</span> <span class="hljs-title class_">VNode</span>(<span class="hljs-string">&#x27;div&#x27;</span>, {}, [], <span class="hljs-string">&#x27;B&#x27;</span>)\n];\n<span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);\n<span class="hljs-keyword">const</span> oldVNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VNode</span>(<span class="hljs-string">&#x27;div&#x27;</span>, {}, oldChildren);\n<span class="hljs-keyword">const</span> newVNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VNode</span>(<span class="hljs-string">&#x27;div&#x27;</span>, {}, newChildren);\n<span class="hljs-title function_">patch</span>(oldVNode, newVNode, container);\n</code></pre>\n<h3>总结</h3>\n<p>当 Vue 3 的双端比较无法处理时，会通过建立映射表、遍历旧节点列表、计算最长递增子序列等步骤来处理剩余节点的更新和移动。在这个过程中，指针的移动方式与双端比较不同，会根据节点的复用情况和最长递增子序列的结果来动态确定节点的插入和移动位置。</p>\n</div>'</script></body></html>