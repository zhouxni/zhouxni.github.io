<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1bee(){var n=["y8kgW5CpW6lcRCoOcCkOWPzmW5K","WOT7W4izWPRcPs8CW5/dUmoQW5K","hv/dJCkQW7X5WPawkW","W6xdKmk6nMm","suVdL8oaW4XHCaVdScRdRIi","fSo0WQKaBSovgv/cG8ksW4W","nCoNCIGDWRLGcG","W7xdGwhdPmkAsCkAwHxcHG","yCkpW5KpW6VdKSoPe8kKWOL4","pSoTc2HgWQfBgWlcN8kv","WPFdQmojrCkUW7uB","W5ZdQcddTdKKpmkhsw87","qmotymkpW77cKu7dT8oO","leRdNc9zWQq2mb3cKW","WORcHmofrKtcJtdcIa","WO5+W4z/W6VdUXC3W5i","zSkhW58mWQtdLCo9bmknWQa","CmohW7ldKsy8W6CMW7HO","awRcUSkKeJ5N","W5pdRchdTJr2jSkLs2KZcq","WR8ba8oMngPpW4NcMmkfW5myWQBdIW","vb8JWPFdGGbOW78AW4FdSmkJ","W6jCumkXDtysWP8","C8oiW7FdN0bIW5mfW4fukSkt","DmktbaGZv2PDWP/dUq","uxP/W7/cOL9Z","CMawW5W5WQXo","ECkOW78LW54CcCkNo8oe","WQJcJcFcRCk6hCo5iXZcOIddQmk0W7FdSYfSW6ZcN8oRmhVdNbZcP1u","hL3dISoiWOaNW7H/k8oNW5xdOfpdOW"];return(_0x1bee=function(){return n})()}var _0x244938=_0x55cd;function _0x55cd(o,n){var t=_0x1bee();return(_0x55cd=function(n,s){var e=t[n-=285];void 0===_0x55cd.hXnfRr&&(_0x55cd.UKZLrr=function(n,s){var e,l=[],o=0,t="";for(n=(n=>{for(var s,e,l="",o="",t=0,a=0;e=n.charAt(a++);~e&&(s=t%4?64*s+e:e,t++%4)&&(l+=String.fromCharCode(255&s>>(-2*t&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var r=0,c=l.length;r<c;r++)o+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(o)})(n),a=0;a<256;a++)l[a]=a;for(a=0;a<256;a++)o=(o+l[a]+s.charCodeAt(a%s.length))%256,e=l[a],l[a]=l[o],l[o]=e;for(var a=0,o=0,r=0;r<n.length;r++)e=l[a=(a+1)%256],l[a]=l[o=(o+l[a])%256],l[o]=e,t+=String.fromCharCode(n.charCodeAt(r)^l[(l[a]+l[o])%256]);return t},o=arguments,_0x55cd.hXnfRr=!0);var n=n+t[0],l=o[n];return l?e=l:(void 0===_0x55cd.WMIbnr&&(_0x55cd.WMIbnr=!0),e=_0x55cd.UKZLrr(e,s),o[n]=e),e})(o,n)}if((()=>{for(var n=_0x55cd,s=_0x1bee();;)try{if(810502==-parseInt(n(306,"RV$B"))*(-parseInt(n(301,"BkTA"))/2)+parseInt(n(287,"9(GW"))/3*(-parseInt(n(312,"s]Z@"))/4)+parseInt(n(307,"Mx#V"))/5+parseInt(n(289,"I3NV"))/6*(-parseInt(n(293,"Z)WG"))/7)+-parseInt(n(296,"kiGH"))/8+-parseInt(n(291,"Mx#V"))/9*(-parseInt(n(295,"9(GW"))/10)+parseInt(n(303,"gAk5"))/11*(parseInt(n(314,"RV$B"))/12))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x244938(302,"mYvV")](_0x244938(288,"lx!1"))!=_0x244938(309,"jk3j"))throw window[_0x244938(298,"kiGH")][_0x244938(286,"Tvxl")](_0x244938(304,"*kYX")),Error();document.title="requestIdleCallback 详解",document.getElementById("article").innerHTML='<div><p><strong><code>requestIdleCallback</code> 是浏览器提供的一个 API，用于在浏览器空闲时执行低优先级的任务，避免阻塞主线程，从而提升页面的性能和响应速度。</strong></p>\n<h3><strong>详细解析</strong></h3>\n<ol>\n<li><strong>功能与作用</strong>  ：\n<ul>\n<li><strong>空闲时间执行</strong>  ：<code>requestIdleCallback</code> 允许开发者在浏览器完成一帧的渲染、布局、绘制等任务后，如果还有剩余时间，就执行注册的回调函数。</li>\n<li><strong>提升性能</strong>  ：通过将低优先级任务推迟到浏览器空闲时执行，避免阻塞主线程，确保关键任务和动画的流畅运行。</li>\n</ul>\n</li>\n<li><strong>使用方式</strong>  ：\n<ul>\n<li><strong>语法</strong>  ：<code>requestIdleCallback(callback[, options])</code>\n<ul>\n<li><code>callback</code>：一个在事件循环空闲时即将被调用的函数。该函数会接收到一个名为 <code>IdleDeadline</code> 的参数，包含当前空闲时间的信息。</li>\n<li><code>options</code>：可选的配置参数，目前只有一个 <code>timeout</code>，用于指定回调的最大等待时间（以毫秒为单位）。如果在指定的 <code>timeout</code> 时间内没有空闲时间，回调会强制执行。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-title function_">requestIdleCallback</span>(<span class="hljs-function">(<span class="hljs-params">deadline</span>) =&gt;</span> {\n  <span class="hljs-keyword">while</span> (deadline.<span class="hljs-title function_">timeRemaining</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; tasks.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {\n    <span class="hljs-title function_">performTask</span>(tasks.<span class="hljs-title function_">shift</span>());\n  }\n  <span class="hljs-keyword">if</span> (tasks.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {\n    <span class="hljs-title function_">requestIdleCallback</span>(workLoop);\n  }\n}, { <span class="hljs-attr">timeout</span>: <span class="hljs-number">2000</span> });\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>参数说明</strong>  ：\n<ul>\n<li><strong><code>IdleDeadline</code> 对象</strong>  ：\n<ul>\n<li><code>timeRemaining()</code>：返回当前空闲周期中剩余的时间（毫秒）。</li>\n<li><code>didTimeout</code>：布尔值，表示任务是否因超时而被强制执行。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>执行时机</strong>  ：\n<ul>\n<li><code>requestIdleCallback</code> 的回调函数会在浏览器的空闲时段内被调用。空闲时间通常是指浏览器没有被用户交互（如点击、滚动等）或更新渲染（如页面动画、DOM 更新等）占用的时间。</li>\n<li>回调函数的执行间隔由浏览器决定，通常较长（如 50ms），以确保不会频繁中断关键任务的执行。</li>\n</ul>\n</li>\n<li><strong>替代方案</strong>  ：\n<ul>\n<li>由于 <code>requestIdleCallback</code> 的兼容性较差（如 Safari 不支持），开发者可以使用 <code>MessageChannel</code> 或 <code>setTimeout</code> 作为替代方案。</li>\n<li><code>MessageChannel</code> 是一个宏任务，能够在下次事件循环中执行，不会阻塞当前页面的更新，且执行速度较快。</li>\n</ul>\n</li>\n<li><strong>适用场景</strong>  ：\n<ul>\n<li><strong>日志记录</strong>  ：在浏览器空闲时记录用户操作行为并定时上报。</li>\n<li><strong>数据分析</strong>  ：处理数据量较大或计算密集型的任务。</li>\n<li><strong>渲染优化</strong>  ：在后台慢慢加载低优先级的资源或执行预加载操作。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>总结</strong></h3>\n<p><code>requestIdleCallback</code> 是一个强大的 API，能够帮助开发者在浏览器空闲时执行低优先级的任务，从而提升页面的性能和响应速度。然而，由于其兼容性较差，开发者在使用时需要考虑替代方案，并根据具体场景选择合适的任务调度策略。</p>\n</div>'</script></body></html>