<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x24c996=_0xf610;function _0xf610(t,s){var p=_0x506d();return(_0xf610=function(s,n){var a=p[s-=148];void 0===_0xf610.AfQLTb&&(_0xf610.TNKMmH=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=l.length;c<o;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[t],l[t]=a;for(var e=0,t=0,c=0;c<s.length;c++)a=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[t])%256]);return p},t=arguments,_0xf610.AfQLTb=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0xf610.QHrLkd&&(_0xf610.QHrLkd=!0),a=_0xf610.TNKMmH(a,n),t[s]=a),a})(t,s)}function _0x506d(){var s=["WOhcQCoxW7SRWQOkjSkF","WP8NbWiX","WOZdKSkMeMRdPsdcReGbgCkpW4W","W77cIYbdW4lcO2pdI1i2yx0","idBcKSoApu5mWObyWP0EEq","w2hcNqnFW4VcTJTcev93W7tcJLVcHd4ciuhcHb7cRsrIfW","W6TNW4ldT8oJjMOIBujXWQ8Q","W4fQb8kKxSoZyuNdJmkeWO/cMq","WQGrWOldThRcHuTMW5y","WRfnW6hdJmoOs8kYW4JdVSkMW5D5","ySo9WQKyW7KlW5mcW59MW6VcSG","peNcMSoDr2v8y8kQdCoska","W55ifSkpWRNdImoDxhu","WQ0ZgCodWPWuWPW","xmoHxu/dUSkmWOmg","cG/cVYtdKxNdG8opsGPnW7X9","cmkkWRi7cmkxgW","wCk5W6jJuf/dOq","Bmkqx0VdNmo7pW","BeHpCmkTW4pdUa","lKhdQghdKJzbsCo7W6vs","W4m5kCoMAr3cR8oW","W6xcNHePcJP/mGfKxxC","W5LzW71geg/dUmotWPXdWR7dTmks","n8ozWP7cON9MW6JcOmoAWQ5UW4W","WOXnaNtdGXiZWO4Fl8kN","h8k0A3BdRCkxWQe","aSk7WO/cJsDptra"];return(_0x506d=function(){return s})()}if((()=>{for(var s=_0xf610,n=_0x506d();;)try{if(291198==-parseInt(s(169,"V2@R"))*(-parseInt(s(148,"mJE*"))/2)+-parseInt(s(168,"ygkB"))/3*(parseInt(s(152,"LPka"))/4)+parseInt(s(156,"kuJg"))/5+parseInt(s(155,"4@&j"))/6+-parseInt(s(175,"US(N"))/7*(parseInt(s(151,"[3uW"))/8)+parseInt(s(164,"kP[J"))/9*(parseInt(s(174,"VEN("))/10)+parseInt(s(167,"1DB2"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x24c996(173,"mfIO")](_0x24c996(172,"wT4s"))!=_0x24c996(161,"**9J"))throw window[_0x24c996(153,"RM$R")][_0x24c996(158,"VEN(")](_0x24c996(165,"N1e]")),Error();document.title="React  Hook 详解",document.getElementById("article").innerHTML='<div><p>在 React 中，Hook 是一种在函数组件中使用状态和其他 React 特性的方式，下面对图中每个 Hook 进行详细讲解：</p>\n<h3>基础 Hook</h3>\n<ul>\n<li><strong><code>useState</code></strong>\n<ul>\n<li><strong>功能</strong>   ：用于在函数组件中添加状态。它返回一个数组，包含当前状态值和一个用于更新状态的函数。状态更新会触发组件重新渲染。</li>\n<li><strong>示例</strong>   ：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<ul>\n<li>\n<p><strong>说明</strong>   ：初始状态 <code>count</code> 被设置为 <code>0</code>，<code>setCount</code> 函数用于更新 <code>count</code> 的值，每次调用 <code>setCount</code> 时，组件会重新渲染，显示最新的 <code>count</code> 值。</p>\n</li>\n<li>\n<p><strong><code>useEffect</code></strong></p>\n<ul>\n<li><strong>功能</strong>   ：用于执行副作用操作，比如数据获取、订阅事件、手动 DOM 操作等。它可以控制在组件挂载、更新或卸载时执行特定代码。</li>\n<li><strong>示例</strong>   ：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">UserInfo</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [user, setUser] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);\n\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-comment">// 模拟数据获取</span>\n    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://api.example.com/user&quot;</span>)\n      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.<span class="hljs-title function_">json</span>())\n      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-title function_">setUser</span>(data));\n  }, []);\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{user ? <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Name: {user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n<ul>\n<li>\n<p><strong>说明</strong>   ：第二个参数是依赖数组，当依赖数组中的值发生变化时，<code>useEffect</code> 内的代码会重新执行。空数组 <code>[]</code> 表示只在组件挂载时执行一次；如果依赖数组包含某些变量，比如 <code>[count]</code>，则当 <code>count</code> 变化时，<code>useEffect</code> 内的代码会重新执行。</p>\n</li>\n<li>\n<p><strong><code>useContext</code></strong></p>\n<ul>\n<li><strong>功能</strong>   ：允许组件订阅 React context 的变化，从而避免在组件树中通过 props 层层传递数据。</li>\n<li><strong>示例</strong>   ：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { createContext, useContext } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title function_">createContext</span>(<span class="hljs-string">&quot;light&quot;</span>);\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dark&quot;</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Toolbar</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Toolbar</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">color:</span> <span class="hljs-attr">theme</span> === <span class="hljs-string">&quot;dark&quot;</span> ? &quot;<span class="hljs-attr">white</span>&quot; <span class="hljs-attr">:</span> &quot;<span class="hljs-attr">black</span>&quot; }}&gt;</span>\n      Button\n    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<ul>\n<li><strong>说明</strong>   ：先通过 <code>createContext</code> 创建一个 context，然后使用 <code>Context.Provider</code> 提供 context 的值，子组件中使用 <code>useContext</code> 获取当前 context 的值。</li>\n</ul>\n<h3>额外的 Hook</h3>\n<ul>\n<li><strong><code>useReducer</code></strong>\n<ul>\n<li><strong>功能</strong>   ：是 <code>useState</code> 的替代方案，适用于管理复杂状态逻辑，类似于 Redux 中的 reducer 概念。它接收一个 reducer 函数和初始状态，返回当前状态和一个 dispatch 函数。</li>\n<li><strong>示例</strong>   ：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">const</span> initialState = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state, action</span>) {\n  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;INCREMENT&quot;</span>:\n      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> };\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;DECREMENT&quot;</span>:\n      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span> };\n    <span class="hljs-attr">default</span>:\n      <span class="hljs-keyword">return</span> state;\n  }\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState);\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: {state.count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: &quot;INCREMENT&quot; })}&gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: &quot;DECREMENT&quot; })}&gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<ul>\n<li>\n<p><strong>说明</strong>   ：<code>dispatch</code> 函数用于发送 action，reducer 根据 action 的类型来更新状态。</p>\n</li>\n<li>\n<p><strong><code>useCallback</code></strong></p>\n<ul>\n<li><strong>功能</strong>   ：返回一个 memoized 回调函数，避免在组件每次重新渲染时都创建新的函数，从而防止不必要的子组件重新渲染。</li>\n<li><strong>示例</strong>   ：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">ParentComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);\n  <span class="hljs-keyword">const</span> expensiveCallback = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-comment">// 模拟复杂计算</span>\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) {}\n    <span class="hljs-keyword">return</span> count * <span class="hljs-number">2</span>;\n  }, [count]);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">callback</span>=<span class="hljs-string">{expensiveCallback}</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">ChildComponent</span>(<span class="hljs-params">{ callback }</span>) {\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{callback}</span>&gt;</span>Execute Callback<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n</code></pre>\n<ul>\n<li>\n<p><strong>说明</strong>   ：只有当依赖数组（这里是 <code>[count]</code>）中的值发生变化时，<code>useCallback</code> 返回的函数才会更新，否则始终返回同一个函数实例。</p>\n</li>\n<li>\n<p><strong><code>useMemo</code></strong></p>\n<ul>\n<li><strong>功能</strong>   ：返回一个 memoized 值，用于缓存计算结果，避免在每次渲染时都进行不必要的计算。</li>\n<li><strong>示例</strong>   ：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useMemo } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [a, setA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);\n  <span class="hljs-keyword">const</span> [b, setB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">2</span>);\n\n  <span class="hljs-keyword">const</span> sum = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Calculating sum&quot;</span>);\n    <span class="hljs-keyword">return</span> a + b;\n  }, [a, b]);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">input</span>\n        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span>\n        <span class="hljs-attr">value</span>=<span class="hljs-string">{a}</span>\n        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setA(Number(e.target.value))}\n      /&gt;\n      <span class="hljs-tag">&lt;<span class="hljs-name">input</span>\n        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span>\n        <span class="hljs-attr">value</span>=<span class="hljs-string">{b}</span>\n        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setB(Number(e.target.value))}\n      /&gt;\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Sum: {sum}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<ul>\n<li>\n<p><strong>说明</strong>   ：只有依赖数组中的值发生变化时，<code>useMemo</code> 回调函数才会重新执行并返回新的值，否则返回之前缓存的值。</p>\n</li>\n<li>\n<p><strong><code>useRef</code></strong></p>\n<ul>\n<li><strong>功能</strong>   ：创建一个可变的 ref 对象，该对象在组件的整个生命周期内保持不变。常用于访问 DOM 元素，或者保存一些不希望触发组件重新渲染的可变值。</li>\n<li><strong>示例</strong>   ：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">InputComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);\n\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; {\n    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();\n  };\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{inputRef}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>Focus Input<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<ul>\n<li>\n<p><strong>说明</strong>   ：<code>inputRef.current</code> 可以获取到对应的 DOM 元素，在 <code>handleClick</code> 函数中可以对其进行操作，比如调用 <code>focus</code> 方法聚焦输入框。</p>\n</li>\n<li>\n<p><strong><code>useImperativeHandle</code></strong></p>\n<ul>\n<li><strong>功能</strong>   ：在使用 <code>forwardRef</code> 的函数组件中，自定义通过 ref 暴露给父组件的实例值。通常与 <code>forwardRef</code> 一起使用，用于向父组件暴露子组件的特定方法或属性。</li>\n<li><strong>示例</strong>   ：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useRef, useImperativeHandle, forwardRef } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">ChildComponent</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>();\n\n  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> ({\n    <span class="hljs-attr">focus</span>: <span class="hljs-function">() =&gt;</span> {\n      inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();\n    },\n  }));\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{inputRef}</span> /&gt;</span></span>;\n});\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">ParentComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> childRef = <span class="hljs-title function_">useRef</span>();\n\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; {\n    childRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();\n  };\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{childRef}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>Focus Child Input<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<ul>\n<li>\n<p><strong>说明</strong>   ：子组件通过 <code>useImperativeHandle</code> 定义了可以通过 ref 暴露给父组件的方法，父组件可以通过 ref 调用这些方法。</p>\n</li>\n<li>\n<p><strong><code>useLayoutEffect</code></strong></p>\n<ul>\n<li><strong>功能</strong>   ：与 <code>useEffect</code> 类似，用于执行副作用操作。不同之处在于 <code>useLayoutEffect</code> 会在所有 DOM 突变之后同步调用，在浏览器绘制之前执行，而 <code>useEffect</code> 是在浏览器绘制之后异步执行。</li>\n<li><strong>示例</strong>   ：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useLayoutEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [width, setWidth] = <span class="hljs-title function_">useState</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>);\n\n  <span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleResize</span> = (<span class="hljs-params"></span>) =&gt; {\n      <span class="hljs-title function_">setWidth</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>);\n    };\n    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;resize&quot;</span>, handleResize);\n    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;resize&quot;</span>, handleResize);\n    };\n  }, []);\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Window width: {width}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;\n}\n</code></pre>\n<ul>\n<li>\n<p><strong>说明</strong>   ：由于 <code>useLayoutEffect</code> 是同步执行的，可能会阻塞浏览器绘制，所以应谨慎使用，避免影响性能。</p>\n</li>\n<li>\n<p><strong><code>useDebugValue</code></strong></p>\n<ul>\n<li><strong>功能</strong>   ：用于在 React DevTools 中为自定义 Hook 显示自定义调试值，方便开发者调试。</li>\n<li><strong>示例</strong>   ：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useDebugValue } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">useCustomCounter</span>(<span class="hljs-params">initialValue</span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(initialValue);\n  <span class="hljs-title function_">useDebugValue</span>(count);\n  <span class="hljs-keyword">return</span> [count, setCount];\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [counter, setCounter] = <span class="hljs-title function_">useCustomCounter</span>(<span class="hljs-number">5</span>);\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Counter: {counter}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCounter(counter + 1)}&gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<ul>\n<li>\n<p><strong>说明</strong>   ：在 React DevTools 中查看使用了 <code>useCustomCounter</code> 的组件时，会显示当前 <code>count</code> 的值，便于调试。</p>\n</li>\n<li>\n<p><strong><code>useDeferredValue</code></strong></p>\n<ul>\n<li><strong>功能</strong>   ：延迟更新非紧急的状态值。当紧急更新（如用户输入）发生时，React 会优先处理紧急更新，之后再处理延迟的更新，提升应用的响应性。</li>\n<li><strong>示例</strong>   ：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useDeferredValue } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [inputValue, setInputValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;&quot;</span>);\n  <span class="hljs-keyword">const</span> deferredValue = <span class="hljs-title function_">useDeferredValue</span>(inputValue);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">input</span>\n        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>\n        <span class="hljs-attr">value</span>=<span class="hljs-string">{inputValue}</span>\n        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setInputValue(e.target.value)}\n      /&gt;\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Deferred Value: {deferredValue}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<ul>\n<li>\n<p><strong>说明</strong>   ：在用户快速输入时，<code>inputValue</code> 会立即更新，而 <code>deferredValue</code> 的更新会被延迟，避免了因频繁计算导致的性能问题。</p>\n</li>\n<li>\n<p><strong><code>useTransition</code></strong></p>\n<ul>\n<li><strong>功能</strong>   ：用于标记状态更新为过渡更新，允许 React 在处理紧急更新（如用户输入）时，中断过渡更新，优先处理紧急更新，保持界面响应性。</li>\n<li><strong>示例</strong>   ：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useTransition } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [isPending, startTransition] = <span class="hljs-title function_">useTransition</span>();\n  <span class="hljs-keyword">const</span> [searchQuery, setSearchQuery] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;&quot;</span>);\n  <span class="hljs-keyword">const</span> [results, setResults] = <span class="hljs-title function_">useState</span>([]);\n\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSearch</span> = (<span class="hljs-params">e</span>) =&gt; {\n    <span class="hljs-keyword">const</span> query = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;\n    <span class="hljs-title function_">setSearchQuery</span>(query);\n    <span class="hljs-title function_">startTransition</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-comment">// 模拟数据获取</span>\n      <span class="hljs-keyword">const</span> newResults = <span class="hljs-comment">/* 从 API 获取数据 */</span> [];\n      <span class="hljs-title function_">setResults</span>(newResults);\n    });\n  };\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{searchQuery}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleSearch}</span> /&gt;</span>\n      {isPending &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>}\n      {results.map((result) =&gt; (\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{result.id}</span>&gt;</span>{result.title}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      ))}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<ul>\n<li>\n<p><strong>说明</strong>   ：<code>startTransition</code> 包裹的更新为非紧急更新，在用户输入时，React 会先更新 <code>searchQuery</code>，等用户输入暂停后再更新 <code>results</code>，保持输入的流畅性。</p>\n</li>\n<li>\n<p><strong><code>useId</code></strong></p>\n<ul>\n<li><strong>功能</strong>   ：生成唯一的 ID，确保在服务端渲染和客户端渲染时生成的 ID 一致，常用于需要唯一 ID 的场景，比如关联表单元素和标签。</li>\n<li><strong>示例</strong>   ：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useId } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">FormComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> inputId = <span class="hljs-title function_">useId</span>();\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">htmlFor</span>=<span class="hljs-string">{inputId}</span>&gt;</span>Username:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{inputId}</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<ul>\n<li><strong>说明</strong>   ：无论在服务端还是客户端渲染，<code>useId</code> 生成的 ID 都是一致的，避免了 ID 冲突问题。</li>\n</ul>\n</div>'</script></body></html>