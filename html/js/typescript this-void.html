<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2b7774=_0x31b1;function _0x31b1(t,s){var a=_0x19eb();return(_0x31b1=function(s,n){var o=a[s-=295];void 0===_0x31b1.DZLnBO&&(_0x31b1.QsOupg=function(s,n){var o,c=[],t=0,a="";for(s=(s=>{for(var n,o,c="",t="",a=0,l=0;o=s.charAt(l++);~o&&(n=a%4?64*n+o:o,a++%4)&&(c+=String.fromCharCode(255&n>>(-2*a&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var e=0,i=c.length;e<i;e++)t+="%"+("00"+c.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(s),l=0;l<256;l++)c[l]=l;for(l=0;l<256;l++)t=(t+c[l]+n.charCodeAt(l%n.length))%256,o=c[l],c[l]=c[t],c[t]=o;for(var l=0,t=0,e=0;e<s.length;e++)o=c[l=(l+1)%256],c[l]=c[t=(t+c[l])%256],c[t]=o,a+=String.fromCharCode(s.charCodeAt(e)^c[(c[l]+c[t])%256]);return a},t=arguments,_0x31b1.DZLnBO=!0);var s=s+a[0],c=t[s];return c?o=c:(void 0===_0x31b1.dkkjtV&&(_0x31b1.dkkjtV=!0),o=_0x31b1.QsOupg(o,n),t[s]=o),o})(t,s)}function _0x19eb(){var s=["W4lcNX3cUIdcHrmM","WOldHuBcKSkKzCkw","gmoqW4vxDHTnW55aW63dMNFcUG","wvpcGJ1Mn8ovfK5xe0q","WPjcwx3cL1RcT8ouiK5nnmkq","B8kQoSoHW7xcMCowFq","eCkJWO7cL8otrmoyWRBcQuVdRSkCw8kPx8o1W5izxSkBEmoxFSozWQtdIW","WPfpvN/cNvdcTmo5mMbkbmku","W4Htsmktqr/cVJjjgZK","W7SbW4hdQqtcOuO","WRRcOa/dMWtdQ8og","W6lcNmo0cSoxqmo8rd14WQlcP8kx","WORdMeBcTSoJW7qr","WQlcMrDxW6G8WO1DWO/dPCkp","v17dLMqKWPHSu3lcLmoPWPK","W4dcNf3dI2JdU0SIESkffCkMWRe","hmoAWPO3bMyoW6C","W5WAW6FcN8ol","wGqesCknh8k+WQm","W50hW5BdHqpcT2ZdHNC","WRZdUhyHWPubhW","WRibrLytmgBdSa","e1BcPetcJCoBWPe","WO/cJJ7dKmoJg8oFW4GjqeldVmkS","WQlcNXbCW6j6W7nPWRNdO8kFWOVdMG","w8oai1uXW47cJSkBgmk8CY3dPq","WOaxnqFdVg0RWRj0j8otgmoM","WQxdPtRdSCoGp1xcKg7cQCo7g8oP"];return(_0x19eb=function(){return s})()}if((()=>{for(var s=_0x31b1,n=_0x19eb();;)try{if(573908==-parseInt(s(317,"g8%w"))*(parseInt(s(302,"EgrV"))/2)+parseInt(s(313,"*ArL"))/3*(-parseInt(s(295,"k[bZ"))/4)+-parseInt(s(305,"i1H["))/5*(-parseInt(s(308,"[amm"))/6)+-parseInt(s(301,"FQW8"))/7*(-parseInt(s(297,"MtPo"))/8)+-parseInt(s(304,"^g1k"))/9+parseInt(s(309,"q8(E"))/10+-parseInt(s(303,"RcVs"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x2b7774(314,"BLvk")](_0x2b7774(296,"BLvk"))!=_0x2b7774(322,"3*Zj"))throw window[_0x2b7774(310,"xz@i")][_0x2b7774(299,"UrYI")](_0x2b7774(311,"dBK8")),Error();document.title="typescript this-void",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>this: void</code> 是一种特殊的语法，用于指定某个函数或方法中的 <code>this</code> 上下文不应该被使用或绑定。这通常用于静态方法或箭头函数中，因为这些上下文中 <code>this</code> 的值通常是未定义或不相关的。</p>\n<h3><strong>用法和解释</strong></h3>\n<ol>\n<li><strong>静态方法中的 <code>this: void</code></strong>  ：\n<ul>\n<li>静态方法属于类本身，而不是类的实例。因此，静态方法中的 <code>this</code> 不指向类的实例，而是指向类本身。在大多数情况下，你不需要在静态方法中使用 <code>this</code>，因此可以使用 <code>this: void</code> 来明确表示这一点。</li>\n</ul>\n</li>\n<li><strong>箭头函数中的 <code>this</code></strong>  ：\n<ul>\n<li>箭头函数不会创建自己的 <code>this</code> 上下文，而是继承自外部函数。因此，在箭头函数中，<code>this</code> 通常不需要被显式绑定或使用。<code>this: void</code> 可以用于箭头函数参数列表中，以表明该函数不会使用 <code>this</code>。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>示例</strong></h3>\n<h4><strong>1. 静态方法</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {\n  <span class="hljs-keyword">static</span> <span class="hljs-title function_">myStaticMethod</span>(<span class="hljs-attr">this</span>: <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This is a static method.&#x27;</span>);\n    <span class="hljs-comment">// 这里不能使用 this，因为它是静态方法</span>\n  }\n}\n\n<span class="hljs-title class_">MyClass</span>.<span class="hljs-title function_">myStaticMethod</span>(); <span class="hljs-comment">// 输出: This is a static method.</span>\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li><code>myStaticMethod</code> 是一个静态方法，因此它不会使用实例的 <code>this</code>。</li>\n<li><code>this: void</code> 明确表示该方法不会使用 <code>this</code>。</li>\n</ul>\n<h4><strong>2. 箭头函数（在类方法中作为回调）</strong></h4>\n<p>虽然 <code>this: void</code> 不直接用于箭头函数的定义（因为箭头函数本身就不绑定 <code>this</code>），但在某些情况下，你可以在函数类型定义中使用 <code>this: void</code> 来约束函数。不过，更常见的是在方法中使用箭头函数来避免 <code>this</code> 绑定问题。</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {\n  <span class="hljs-title function_">myMethod</span>(): <span class="hljs-built_in">void</span> {\n    <span class="hljs-keyword">const</span> callback = (<span class="hljs-attr">this</span>: <span class="hljs-built_in">void</span>, <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);\n    };\n\n    <span class="hljs-comment">// 使用回调，不依赖 this</span>\n    <span class="hljs-title function_">callback</span>(<span class="hljs-string">&#x27;Hello from callback!&#x27;</span>);\n  }\n}\n\n<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();\ninstance.<span class="hljs-title function_">myMethod</span>(); <span class="hljs-comment">// 输出: Hello from callback!</span>\n</code></pre>\n<p><strong>注意</strong>  ：</p>\n<ul>\n<li>在上面的例子中，<code>callback</code> 是一个箭头函数，它本身不绑定 <code>this</code>。虽然 <code>this: void</code> 在箭头函数的类型定义中不是必需的（因为箭头函数本身就没有 <code>this</code>），但你可以在某些高级类型定义或约束中使用它。</li>\n<li>更常见的是直接在类方法中使用箭头函数来确保 <code>this</code> 的正确性，而不需要显式指定 <code>this: void</code>。</li>\n</ul>\n<h3><strong>实际用途</strong></h3>\n<ul>\n<li><strong>静态方法</strong>  ：明确表明静态方法不会使用 <code>this</code>。</li>\n<li><strong>类型定义</strong>  ：在定义函数类型时，可以使用 <code>this: void</code> 来约束函数不会使用 <code>this</code>。</li>\n<li><strong>代码清晰性</strong>  ：通过显式指定 <code>this: void</code>，可以提高代码的可读性和维护性，让其他开发者更容易理解函数的意图。</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><code>this: void</code> 是一种类型注解，用于表明函数或方法不会使用 <code>this</code> 上下文。</li>\n<li>它通常用于静态方法或某些不需要 <code>this</code> 的函数类型定义中。</li>\n<li>使用 <code>this: void</code> 可以提高代码的可读性和类型安全性。</li>\n</ul>\n</div>'</script></body></html>