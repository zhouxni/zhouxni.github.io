<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3115(){var s=["bmozWQxcPMBcT8kxvgBcGCko","W5eAW6OZW7BdTr8ca8k0WQeLkG","WP9Er1ldRtjXWP3cQmklfwy","iSojgeBcRq","WPKWW7RdSw3dHfSKWR98vCoR","WPNdQmk1mSoxD8kIlmoEmL14Dq","WPRcVCowymkTcSoH","W5BdLCoadSkrcSkW","WPLyqfNdRtyuWPpcQSkBi2dcRG","q8o5zmk8c8k5W7G","fCowfKz1WOVdPaBcN3G1W5je","WOhcQmoagmofsCoZWOu","W5xdLmkQp8kzfCoYWRO","bCkTW7fuW4TXWOS","WOFcM8kBWOqNWPW8WRtdVG","sWZcQ8oqnMdcK0fWkSoGWPm6","W6NcLqfYFCobyW","a8kOW5xdUbRcPmkk","tmkPW6C1yvhcR1WfWPXCWQC","e8oqeu11WO/cGqJcNwGdW5q","WP5zithcRg5rWQa","W77dOatcJGu6ichdTCkYDCkecG","dSk0gXSKBSkRBmo0WQtcGmooztC5WRj6ffn9WOT3d8kkW7j5","tG/cRmklxZRdPM1M","WOlcR8kMk8oVtmoeWOrP","W7tdICojW5LKW5PbWQJdQYdcImoqW5K","WPKWWObodxezChxcMCka"];return(_0x3115=function(){return s})()}function _0x3bcd(e,s){var t=_0x3115();return(_0x3bcd=function(s,n){var a=t[s-=436];void 0===_0x3bcd.rHANqJ&&(_0x3bcd.CkpFCG=function(s,n){var a,o=[],e=0,t="";for(s=(s=>{for(var n,a,o="",e="",t=0,c=0;a=s.charAt(c++);~a&&(n=t%4?64*n+a:a,t++%4)&&(o+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var l=0,p=o.length;l<p;l++)e+="%"+("00"+o.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(e)})(s),c=0;c<256;c++)o[c]=c;for(c=0;c<256;c++)e=(e+o[c]+n.charCodeAt(c%n.length))%256,a=o[c],o[c]=o[e],o[e]=a;for(var c=0,e=0,l=0;l<s.length;l++)a=o[c=(c+1)%256],o[c]=o[e=(e+o[c])%256],o[e]=a,t+=String.fromCharCode(s.charCodeAt(l)^o[(o[c]+o[e])%256]);return t},e=arguments,_0x3bcd.rHANqJ=!0);var s=s+t[0],o=e[s];return o?a=o:(void 0===_0x3bcd.BOUfzR&&(_0x3bcd.BOUfzR=!0),a=_0x3bcd.CkpFCG(a,n),e[s]=a),a})(e,s)}var _0x41dc6f=_0x3bcd;if((()=>{for(var s=_0x3bcd,n=_0x3115();;)try{if(756221==-parseInt(s(460,"hElo"))*(parseInt(s(443,"QjTw"))/2)+-parseInt(s(461,"QjTw"))/3+parseInt(s(457,"5ROb"))/4*(parseInt(s(451,"O*]@"))/5)+-parseInt(s(445,"SQhl"))/6+parseInt(s(452,"UEnQ"))/7+parseInt(s(449,"y!^H"))/8*(-parseInt(s(462,"wbMV"))/9)+-parseInt(s(442,"6rWK"))/10*(-parseInt(s(448,"wbMV"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x41dc6f(437,"t@lV")](_0x41dc6f(438,"y!^H"))!=_0x41dc6f(454,"li]F"))throw window[_0x41dc6f(436,"xSQh")][_0x41dc6f(440,"SuNm")](_0x41dc6f(446,"O7@%")),Error();document.title="typescript keyof",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>keyof</code> 是一个用于获取对象类型键的联合类型的操作符。它可以帮助你从对象的类型中提取所有可能的键，并生成一个由这些键组成的字符串字面量类型。</p>\n<h3>基本用法</h3>\n<p>假设你有一个接口或类型：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">location</span>: <span class="hljs-built_in">string</span>;\n}\n</code></pre>\n<p>你可以使用 <code>keyof</code> 来获取 <code>Person</code> 类型的所有键：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">PersonKeys</span> = keyof <span class="hljs-title class_">Person</span>; <span class="hljs-comment">// &quot;name&quot; | &quot;age&quot; | &quot;location&quot;</span>\n</code></pre>\n<p>在这个例子中，<code>PersonKeys</code> 类型的值可以是 <code>&quot;name&quot;</code>、<code>&quot;age&quot;</code> 或 <code>&quot;location&quot;</code> 中的任何一个。</p>\n<h3>使用场景</h3>\n<ol>\n<li><strong>限制对象的访问</strong>  ：你可以使用 <code>keyof</code> 来确保你只访问对象中存在的属性。</li>\n<li><strong>映射类型</strong>  ：结合映射类型，<code>keyof</code> 可以用于创建新的类型，其中每个属性都基于原类型的属性进行某种转换。</li>\n<li><strong>类型安全</strong>  ：在编写通用函数或组件时，<code>keyof</code> 可以帮助确保类型安全，防止访问不存在的属性。</li>\n</ol>\n<h3>示例</h3>\n<h4>示例 1：限制对象访问</h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> getPropertyValue&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt;(<span class="hljs-attr">obj</span>: T, <span class="hljs-attr">key</span>: K): T[K] {\n  <span class="hljs-keyword">return</span> obj[key];\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">person</span>: <span class="hljs-title class_">Person</span> = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>, <span class="hljs-attr">location</span>: <span class="hljs-string">&quot;Wonderland&quot;</span> };\n\n<span class="hljs-comment">// 正确用法</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getPropertyValue</span>(person, <span class="hljs-string">&quot;name&quot;</span>)); <span class="hljs-comment">// 输出: Alice</span>\n\n<span class="hljs-comment">// 错误用法（编译时错误）</span>\n<span class="hljs-comment">// console.log(getPropertyValue(person, &quot;height&quot;)); // Error: Argument of type &#x27;&quot;height&quot;&#x27; is not assignable to parameter of type &#x27;&quot;name&quot; | &quot;age&quot; | &quot;location&quot;&#x27;.</span>\n</code></pre>\n<h4>示例 2：映射类型</h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReadonlyPerson</span> = {\n  <span class="hljs-keyword">readonly</span> [K <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Person</span>]: <span class="hljs-title class_">Person</span>[K];\n};\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">readonlyPerson</span>: <span class="hljs-title class_">ReadonlyPerson</span> = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>, <span class="hljs-attr">location</span>: <span class="hljs-string">&quot;Nowhere&quot;</span> };\n\n<span class="hljs-comment">// readonlyPerson.age = 26; // Error: Cannot assign to &#x27;age&#x27; because it is a read-only property.</span>\n</code></pre>\n<p>在这个例子中，我们创建了一个新类型 <code>ReadonlyPerson</code>，其中 <code>Person</code> 类型的所有属性都被设置为只读。</p>\n<p><code>keyof</code> 是 TypeScript 中一个非常有用的工具，特别是在处理复杂类型系统和需要确保类型安全的情况下。通过它，你可以更精确地控制你的代码，并减少运行时错误的可能性。</p>\n</div>'</script></body></html>