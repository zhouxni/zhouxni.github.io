<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x18f087=_0xb419;function _0xb419(t,n){var c=_0x3752();return(_0xb419=function(n,s){var o=c[n-=437];void 0===_0xb419.bOZZle&&(_0xb419.nVzUUQ=function(n,s){var o,e=[],t=0,c="";for(n=(n=>{for(var s,o,e="",t="",c=0,a=0;o=n.charAt(a++);~o&&(s=c%4?64*s+o:o,c++%4)&&(e+=String.fromCharCode(255&s>>(-2*c&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var l=0,r=e.length;l<r;l++)t+="%"+("00"+e.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(t)})(n),a=0;a<256;a++)e[a]=a;for(a=0;a<256;a++)t=(t+e[a]+s.charCodeAt(a%s.length))%256,o=e[a],e[a]=e[t],e[t]=o;for(var a=0,t=0,l=0;l<n.length;l++)o=e[a=(a+1)%256],e[a]=e[t=(t+e[a])%256],e[t]=o,c+=String.fromCharCode(n.charCodeAt(l)^e[(e[a]+e[t])%256]);return c},t=arguments,_0xb419.bOZZle=!0);var n=n+c[0],e=t[n];return e?o=e:(void 0===_0xb419.HnyUVg&&(_0xb419.HnyUVg=!0),o=_0xb419.nVzUUQ(o,s),t[n]=o),o})(t,n)}if((()=>{for(var n=_0xb419,s=_0x3752();;)try{if(492364==-parseInt(n(453,"3nuw"))*(-parseInt(n(450,"9J92"))/2)+-parseInt(n(442,"[]PB"))/3+-parseInt(n(438,"vase"))/4+-parseInt(n(460,"55zi"))/5+-parseInt(n(452,"d5X4"))/6+parseInt(n(457,"s@[d"))/7+parseInt(n(455,"pgpE"))/8*(parseInt(n(437,"^Rqe"))/9))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x18f087(446,"d5X4")](_0x18f087(441,"G&$i"))!=_0x18f087(458,"G&$i"))throw window[_0x18f087(456,"G&$i")][_0x18f087(449,"pZDP")](_0x18f087(448,"3s3G")),Error();function _0x3752(){var n=["W6/cHfHHW4SKyq","WOJcHtRdRYJdUSkYWOlcOdnNWQ81","j8oUBZpcKutdS8kRiSodWPtdH8kYW5BdRL0uWRTzWRGGW6hcOCo7WObD","ufOBW7VdUSoyWP4","oepcKmk1iwLfWO/cJZ4eeCoP","BfxdQ1y5FJnuAmoOpmkz","WR3dKrGFWOXYnmowWRSJychcQq","uxlcJmoFWPldR1i","WRNcU2rXW645FG","sCowzSktAKlcRJtcUCopWOq4px0","WQ5RWQVdLdpcPKtcQq","lK/cUSkRW4/cT301WOddRSkiW7FcKa","WRjXWRVdHJ4","WRJdTCkSCSkMyhz6W63cMtC8Db0","WOBdK8oLi8o6zXKdyaq8v1y","W6/dJmkHx8kTWPvM","WRRcSSobgSosgSosFqddTazsxa","erLSuGuwWOJdKNtcOSkoACkY","W7FdP3JdH8kJWRtdOazoW5VcGYxcMG","WOnNWQVdKdtcVgdcOSo+","W4yqdfZcOIL0W6q1AJVdKq","W7r7dLbtW43dGq","BSk0hqxdKmkkWPCWWPVcR8khWR9l","WOFdK8oPimo6Ar0FEH4sDf8"];return(_0x3752=function(){return n})()}document.title="webSocket 详解",document.getElementById("article").innerHTML='<div><p><strong>前端 WebSocket API 详解</strong></p>\n<p>WebSocket API 是 HTML5 标准化之后的一项 API，它允许浏览器与服务器之间建立双向通信连接，实现实时数据传输。以下是对前端 WebSocket API 的详细解析：</p>\n<h3>一、WebSocket API 的基本概念</h3>\n<ul>\n<li><strong>WebSocket 对象</strong>  ：通过 <code>WebSocket</code> 构造函数创建，用于与服务器建立和管理 WebSocket 连接。</li>\n<li><strong>连接状态</strong>  ：WebSocket 连接的状态通过 <code>readyState</code> 属性表示，可能的状态值包括：\n<ul>\n<li><code>0</code>：<code>CONNECTING</code>，表示正在连接。</li>\n<li><code>1</code>：<code>OPEN</code>，表示已连接。</li>\n<li><code>2</code>：<code>CLOSING</code>，表示正在关闭。</li>\n<li><code>3</code>：<code>CLOSED</code>，表示已关闭。</li>\n</ul>\n</li>\n</ul>\n<h3>二、WebSocket API 的常用方法</h3>\n<ul>\n<li><strong><code>send(data)</code></strong>  ：向服务器发送数据。数据可以是字符串、Blob 或 ArrayBuffer 类型。</li>\n<li><strong><code>close([code[, reason]])</code></strong>  ：关闭 WebSocket 连接。可以指定关闭连接的状态码和原因。</li>\n</ul>\n<h3>三、WebSocket API 的常用事件</h3>\n<ul>\n<li><strong><code>onopen</code></strong>  ：当 WebSocket 连接打开时触发。</li>\n<li><strong><code>onmessage</code></strong>  ：当接收到服务器发送的消息时触发。</li>\n<li><strong><code>onclose</code></strong>  ：当 WebSocket 连接关闭时触发。</li>\n<li><strong><code>onerror</code></strong>  ：当 WebSocket 连接发生错误时触发。</li>\n</ul>\n<h3>四、WebSocket API 的使用示例</h3>\n<p>以下是一个简单的前端 WebSocket API 使用示例：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 创建 WebSocket 对象，并指定服务端地址</span>\n<span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:8080&quot;</span>);\n\n<span class="hljs-comment">// 监听连接打开事件</span>\nws.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;WebSocket connection opened.&quot;</span>);\n    ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;Hello, server!&quot;</span>); <span class="hljs-comment">// 向服务器发送消息</span>\n};\n\n<span class="hljs-comment">// 监听接收到消息事件</span>\nws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Message from server: &quot;</span> + event.<span class="hljs-property">data</span>);\n};\n\n<span class="hljs-comment">// 监听连接关闭事件</span>\nws.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;WebSocket connection closed.&quot;</span>);\n};\n\n<span class="hljs-comment">// 监听错误事件</span>\nws.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;WebSocket error: &quot;</span> + error);\n};\n</code></pre>\n<h3>五、WebSocket API 的优势</h3>\n<ul>\n<li><strong>实时性</strong>  ：WebSocket 允许服务器主动向客户端推送数据，实现实时通信，适用于需要实时更新的应用场景。</li>\n<li><strong>高效性</strong>  ：相比于 HTTP 请求/响应模式，WebSocket 通过单个 TCP 连接实现全双工通信，减少了连接建立和断开的开销，提高了传输效率。</li>\n<li><strong>跨域支持</strong>  ：WebSocket 协议支持跨域请求，使得不同域之间的实时通信成为可能。</li>\n</ul>\n<h3>六、WebSocket API 的应用场景</h3>\n<ul>\n<li><strong>实时聊天应用</strong>  ：如在线聊天室、即时通讯工具等，WebSocket 可以实现用户之间的实时消息传递。</li>\n<li><strong>实时数据更新</strong>  ：如股票市场实时报价、天气预报等，WebSocket 可以实时推送最新数据到客户端。</li>\n<li><strong>多人在线游戏</strong>  ：WebSocket 可以实现游戏数据的实时同步，提高游戏的实时性和互动性。</li>\n<li><strong>实时监控</strong>  ：如设备状态监控、系统性能监控等，WebSocket 可以实时传输监控数据到客户端进行展示。</li>\n</ul>\n<h3>七、WebSocket API 的注意事项</h3>\n<ul>\n<li><strong>浏览器兼容性</strong>  ：虽然现代浏览器大多支持 WebSocket，但在某些旧版浏览器中可能存在兼容性问题。因此，在使用 WebSocket 时需要考虑浏览器的兼容性。</li>\n<li><strong>安全性</strong>  ：WebSocket 协议本身不提供加密功能，因此在使用时应考虑使用加密连接（<code>wss://</code>）来确保数据安全。</li>\n<li><strong>心跳机制</strong>  ：为了保持 WebSocket 连接的稳定性，可以引入心跳机制来检测连接是否仍然有效。如果长时间没有数据传输，可以通过发送心跳包来保持连接活跃。</li>\n<li><strong>错误处理</strong>  ：在使用 WebSocket 时需要处理各种可能的错误情况，如连接失败、消息发送失败等。可以通过监听 <code>onerror</code> 事件来捕获和处理这些错误。</li>\n</ul>\n<h3>八、WebSocket API 的调试工具</h3>\n<ul>\n<li><strong>浏览器开发者工具</strong>  ：大多数现代浏览器都提供了开发者工具，可以用于调试 WebSocket 连接和消息。通过开发者工具可以查看 WebSocket 的连接状态、发送和接收的消息等信息。</li>\n<li><strong>第三方工具</strong>  ：如 Apifox 等接口测试工具也支持 WebSocket 协议的调试。使用这些工具可以更方便地测试 WebSocket 接口的功能和性能。</li>\n</ul>\n</div>'</script></body></html>