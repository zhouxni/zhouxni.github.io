<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x50d1(){var s=["cCkHWPP5WRBcVXBdPa","W6izWP1yW7FdRLa0W7hcSmowCSo/","W49xsreUWQhdMq","WRfmn8oDcdFcPNRdLtz8pmk8","WQyBvmkQW4nCv8kVcgnm","W4XlWP3cISkIjCokWPCuuCk3","kLtdHWdcPhSr","WONdMCkHW4VcT8kOWRqBqmkYWOddVM8","c13dJ3CL","W65+fsm2qIuRsMzp","W6ZcRSkTW7qyxConiXxcReRcNG","W7/cIJBcM3uEWQ/dU8kidgqilW","WRvjBCkfs1ddL2a","iSowW6FcICo1WP1Mh8kHjG","WP4dWQrJE1WgW54","bCkGxCo1cN7cLCoJWPjsdLTUW6zPW4NdTSk/WQddNSkLW4ldTxRdPCoy","DqBcI3VdPe4xcSkUWOlcKq","WPr4hCkLW5JdSCkFWQK/WQy","WQKUxaldJhRdTCoNWRldJq","WObfxuhcIfNcV04EW6y","W4SqW5D7W4VdMmolBmo2","tSoqWOXVW4r2xJZcMW","W4vpWPZcImkGbSoKWRi1DSkl","o8klW58+WODiFH7cRCohWOK","txhcOSkclq0kW5W","sbdcI2yfomoGnCow","W5LhWRKHW7ZdUdhdT3hdPCkVCG","FGldQYhcTxaYoW"];return(_0x50d1=function(){return s})()}var _0x4804b1=_0x4e60;function _0x4e60(c,s){var o=_0x50d1();return(_0x4e60=function(s,n){var e=o[s-=459];void 0===_0x4e60.lsyAEN&&(_0x4e60.DoUoSy=function(s,n){var e,a=[],c=0,o="";for(s=(s=>{for(var n,e,a="",c="",o=0,r=0;e=s.charAt(r++);~e&&(n=o%4?64*n+e:e,o++%4)&&(a+=String.fromCharCode(255&n>>(-2*o&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var t=0,l=a.length;t<l;t++)c+="%"+("00"+a.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(c)})(s),r=0;r<256;r++)a[r]=r;for(r=0;r<256;r++)c=(c+a[r]+n.charCodeAt(r%n.length))%256,e=a[r],a[r]=a[c],a[c]=e;for(var r=0,c=0,t=0;t<s.length;t++)e=a[r=(r+1)%256],a[r]=a[c=(c+a[r])%256],a[c]=e,o+=String.fromCharCode(s.charCodeAt(t)^a[(a[r]+a[c])%256]);return o},c=arguments,_0x4e60.lsyAEN=!0);var s=s+o[0],a=c[s];return a?e=a:(void 0===_0x4e60.xvUYJn&&(_0x4e60.xvUYJn=!0),e=_0x4e60.DoUoSy(e,n),c[s]=e),e})(c,s)}if((()=>{for(var s=_0x4e60,n=_0x50d1();;)try{if(243493==+parseInt(s(464,"KR9#"))*(parseInt(s(473,"WCxq"))/2)+-parseInt(s(478,"G%ll"))/3*(parseInt(s(480,"TvTT"))/4)+parseInt(s(482,"N@(v"))/5*(parseInt(s(481,"K^NQ"))/6)+-parseInt(s(462,"xc]7"))/7+-parseInt(s(468,"93@B"))/8*(parseInt(s(484,"4G[!"))/9)+parseInt(s(471,"b5B6"))/10+-parseInt(s(465,"5ijP"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x4804b1(470,"TvTT")](_0x4804b1(485,"lflq"))!=_0x4804b1(472,"O)kJ"))throw window[_0x4804b1(460,"Kh6J")][_0x4804b1(466,"Hf%%")](_0x4804b1(479,"j*Ae")),Error();document.title="vue3 reactiveMap",document.getElementById("article").innerHTML='<div><p>在 Vue 3 中，<code>reactiveMap</code> 是 Vue 内部使用的一个 <strong>全局 WeakMap</strong>  ，主要用于存储原始对象（<code>target</code>）与其对应的响应式代理对象（<code>Proxy</code>）之间的映射关系。它的核心作用是 <strong>避免重复创建响应式代理</strong>  ，确保同一原始对象始终返回同一个代理实例，从而保证响应式数据的一致性。</p>\n<hr>\n<h3>主要作用：</h3>\n<ol>\n<li><strong>性能优化</strong><br>\n当多次对同一个原始对象调用 <code>reactive()</code> 时，<code>reactiveMap</code> 会直接返回已创建的代理，避免重复的 Proxy 构造开销。</li>\n<li><strong>保持引用一致性</strong><br>\n确保在应用的不同部分访问同一对象时，返回的是同一个代理实例，避免因代理不一致导致的响应式更新问题。</li>\n<li><strong>内存管理</strong><br>\n使用 <code>WeakMap</code> 存储，当原始对象不再被引用时，其对应的代理会自动被垃圾回收，防止内存泄漏。</li>\n</ol>\n<hr>\n<h3>源码中的角色：</h3>\n<p>在 Vue 3 的响应式系统源码中（如 <code>reactive.ts</code>），<code>reactiveMap</code> 的定义类似：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> reactiveMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>&lt;<span class="hljs-title class_">Target</span>, <span class="hljs-built_in">any</span>&gt;()\n</code></pre>\n<p>当调用 <code>reactive(target)</code> 时，会先检查 <code>reactiveMap</code> 中是否已有该 <code>target</code> 的代理：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-title class_">Target</span></span>) {\n  <span class="hljs-keyword">if</span> (existingProxy) {\n    <span class="hljs-keyword">return</span> existingProxy <span class="hljs-comment">// 直接返回已存在的代理</span>\n  }\n  <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handlers) <span class="hljs-comment">// 创建新代理</span>\n  reactiveMap.<span class="hljs-title function_">set</span>(target, proxy) <span class="hljs-comment">// 存储映射</span>\n  <span class="hljs-keyword">return</span> proxy\n}\n</code></pre>\n<hr>\n<h3>开发者注意事项：</h3>\n<ul>\n<li><strong>无需直接操作</strong>  ：<code>reactiveMap</code> 是 Vue 内部实现细节，开发者通常不需要直接使用它。</li>\n<li><strong>原始对象唯一性</strong>  ：如果需要对同一对象多次调用 <code>reactive()</code>，Vue 会自动通过 <code>reactiveMap</code> 优化。</li>\n<li><strong>不可变原则</strong>  ：直接修改 <code>reactiveMap</code> 可能导致响应式系统异常，应始终通过 Vue 提供的 API（如 <code>reactive()</code>、<code>ref()</code>）操作数据。</li>\n</ul>\n<hr>\n<h3>示例：</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>\n\n<span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> }\n<span class="hljs-keyword">const</span> proxy1 = <span class="hljs-title function_">reactive</span>(obj)\n<span class="hljs-keyword">const</span> proxy2 = <span class="hljs-title function_">reactive</span>(obj) <span class="hljs-comment">// 返回同一个代理</span>\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy1 === proxy2) <span class="hljs-comment">// true</span>\n</code></pre>\n<p>通过 <code>reactiveMap</code>，Vue 确保了 <code>proxy1</code> 和 <code>proxy2</code> 是同一个实例，维护了响应式数据的一致性。</p>\n</div>'</script></body></html>