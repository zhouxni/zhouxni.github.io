<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3068(p,s){var t=_0x1252();return(_0x3068=function(s,a){var n=t[s-=422];void 0===_0x3068.xLZyAx&&(_0x3068.YDjBFe=function(s,a){var n,l=[],p=0,t="";for(s=(s=>{for(var a,n,l="",p="",t=0,c=0;n=s.charAt(c++);~n&&(a=t%4?64*a+n:n,t++%4)&&(l+=String.fromCharCode(255&a>>(-2*t&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var e=0,r=l.length;e<r;e++)p+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(p)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)p=(p+l[c]+a.charCodeAt(c%a.length))%256,n=l[c],l[c]=l[p],l[p]=n;for(var c=0,p=0,e=0;e<s.length;e++)n=l[c=(c+1)%256],l[c]=l[p=(p+l[c])%256],l[p]=n,t+=String.fromCharCode(s.charCodeAt(e)^l[(l[c]+l[p])%256]);return t},p=arguments,_0x3068.xLZyAx=!0);var s=s+t[0],l=p[s];return l?n=l:(void 0===_0x3068.zPpJcX&&(_0x3068.zPpJcX=!0),n=_0x3068.YDjBFe(n,a),p[s]=n),n})(p,s)}var _0x39657b=_0x3068;function _0x1252(){var s=["DgBdKCoCxCkbWPtcQrBdPYxdOCoQb2ddIt9MWR7dNmkceComW7lcV8oM","WPr3W5yoW4m6AHPuqrDzea","uqDtWQNcGCo0dYRdKW","W6hcLCoFhGvVsa","W7ZcNSoZWOldVSowWOpcSSkQW4tdQgnL","g2bCWPNcJmknwW","W6hdK2VcGCo7WRtdRG","ESkqW7RcO37dNSkTW5tcKCkVWRJcMdm","d8k+rmoMW4ldSCksW5KrE8k5Amk8","u8oaW54FW4/cHmka","nSkCumkHW4ldJXe","bZrsb0BdUCo/WRH1WPWRW6eu","dInMg8opWOFdJG","W7VcIK02FSoHnW","ebuPWQdcVSkcvSovBq","srRdUSolWOmUWQLPWRDKktDd","tSocWRf9DmkRCKJdOqKRot8","aCoIfqWqDCkDW6JdMXnfm8o0","xSkyWQXLWQRdL8ogvxL0ESkQiG","rKSuzMJcJ8kEW7NcSG","pmocttdcMa","iIBdNmkic8oYW64wWO3dSSoEeYG","WQ7dMW1ko8kWAMHeW4umwcC","W7/cM8oYWOpdS8oBW7dcKCktW7BdQx0","WR/cUxlcSCkDWR1jyG","W5JdUCoeW48UzqddICobxSoIEq","omoBxmkgWOXBEa","tNFdJ8oEW58qAfHnW6DnDca"];return(_0x1252=function(){return s})()}if((()=>{for(var s=_0x3068,a=_0x1252();;)try{if(807508==+parseInt(s(425,"H5W$"))*(-parseInt(s(424,"I0We"))/2)+-parseInt(s(443,"ZQzt"))/3*(-parseInt(s(435,"RnY$"))/4)+parseInt(s(423,"GyCS"))/5*(-parseInt(s(428,"BnBE"))/6)+parseInt(s(433,"1b@v"))/7+-parseInt(s(434,"!@3r"))/8*(-parseInt(s(431,"*o9x"))/9)+parseInt(s(437,"9yaA"))/10+parseInt(s(447,"S9PH"))/11)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x39657b(439,"uK5G")](_0x39657b(445,"rXvD"))!=_0x39657b(446,"h6#c"))throw window[_0x39657b(422,"k]t(")][_0x39657b(432,"Gt]5")](_0x39657b(426,"HzV(")),Error();document.title=" TypeScript 子类型与父类型详解",document.getElementById("article").innerHTML='<div><p>在 TypeScript 的类型系统中，子类型（Subtype）和父类型（Supertype）是类型关系的核心概念，理解它们对于掌握类型兼容性和类型安全至关重要。</p>\n<h2>基本概念</h2>\n<h3>1. 子类型 (Subtype)</h3>\n<ul>\n<li><strong>定义</strong>   ：如果类型 S 可以赋值给类型 T（<code>S extends T</code> 或 <code>S assignable to T</code>），则 S 是 T 的子类型</li>\n<li><strong>特点</strong>   ：\n<ul>\n<li>子类型比父类型更具体</li>\n<li>包含父类型的所有特性，并可能扩展新特性</li>\n<li>可以安全地用在期望父类型的任何地方</li>\n</ul>\n</li>\n</ul>\n<h3>2. 父类型 (Supertype)</h3>\n<ul>\n<li><strong>定义</strong>   ：如果类型 T 可以接受类型 S 的赋值，则 T 是 S 的父类型</li>\n<li><strong>特点</strong>   ：\n<ul>\n<li>比子类型更抽象、更通用</li>\n<li>定义了一个更宽泛的契约</li>\n</ul>\n</li>\n</ul>\n<h2>类型关系示例</h2>\n<h3>1. 基本类型</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Parent</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Child</span> = <span class="hljs-built_in">string</span>; <span class="hljs-comment">// Child 是 Parent 的子类型</span>\n\n<span class="hljs-keyword">let</span> <span class="hljs-attr">parent</span>: <span class="hljs-title class_">Parent</span>;\n<span class="hljs-keyword">let</span> <span class="hljs-attr">child</span>: <span class="hljs-title class_">Child</span> = <span class="hljs-string">&quot;hello&quot;</span>;\n\nparent = child; <span class="hljs-comment">// ✅ 安全，子类型可以赋值给父类型</span>\n<span class="hljs-comment">// child = parent; // ❌ 错误，父类型不能直接赋值给子类型</span>\n</code></pre>\n<h3>2. 对象类型</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-attr">breed</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-title function_">bark</span>(): <span class="hljs-built_in">void</span>;\n}\n\n<span class="hljs-keyword">let</span> <span class="hljs-attr">animal</span>: <span class="hljs-title class_">Animal</span>;\n<span class="hljs-keyword">let</span> <span class="hljs-attr">dog</span>: <span class="hljs-title class_">Dog</span> = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Buddy&quot;</span>,\n  <span class="hljs-attr">age</span>: <span class="hljs-number">3</span>,\n  <span class="hljs-attr">breed</span>: <span class="hljs-string">&quot;Golden Retriever&quot;</span>,\n  <span class="hljs-attr">bark</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Woof!&quot;</span>),\n};\n\nanimal = dog; <span class="hljs-comment">// ✅ 安全，Dog 是 Animal 的子类型</span>\n<span class="hljs-comment">// dog = animal; // ❌ 错误，缺少 breed 和 bark 属性</span>\n</code></pre>\n<h2>类型系统规则</h2>\n<h3>1. 结构化类型（鸭子类型）</h3>\n<p>TypeScript 使用结构化类型系统：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point2D</span> {\n  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point3D</span> {\n  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">z</span>: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-keyword">let</span> <span class="hljs-attr">point2D</span>: <span class="hljs-title class_">Point2D</span> = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> };\n<span class="hljs-keyword">let</span> <span class="hljs-attr">point3D</span>: <span class="hljs-title class_">Point3D</span> = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> };\n\npoint2D = point3D; <span class="hljs-comment">// ✅ Point3D 是 Point2D 的子类型</span>\n<span class="hljs-comment">// point3D = point2D; // ❌ 缺少 z 属性</span>\n</code></pre>\n<h3>2. 函数类型</h3>\n<p>函数参数的子类型关系是<strong>逆变</strong>   的，返回类型是<strong>协变</strong>   的：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Handler</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">arg</span>: <span class="hljs-title class_">Animal</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">dogHandler</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">arg</span>: <span class="hljs-title class_">Dog</span></span>) =&gt;</span> <span class="hljs-built_in">void</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">dog</span>: <span class="hljs-title class_">Dog</span></span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog.<span class="hljs-property">breed</span>);\n};\n\n<span class="hljs-comment">// Handler 是 dogHandler 的子类型</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">handler</span>: <span class="hljs-title class_">Handler</span> = dogHandler; <span class="hljs-comment">// ✅ 安全</span>\n\n<span class="hljs-comment">// 反例（不安全）</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">StringProcessor</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">arg</span>: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span>;\n<span class="hljs-keyword">const</span> <span class="hljs-attr">anyProcessor</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">arg</span>: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">string</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">arg</span>: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-title class_">String</span>(arg);\n\n<span class="hljs-comment">// let processor: StringProcessor = anyProcessor; // ❌ 不安全</span>\n</code></pre>\n<h2>高级概念</h2>\n<h3>1. 协变 (Covariance)</h3>\n<p>保持子类型关系的方向：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Co</span>&lt;T&gt; = { <span class="hljs-attr">value</span>: T };\n\n<span class="hljs-keyword">let</span> <span class="hljs-attr">coAnimal</span>: <span class="hljs-title class_">Co</span>&lt;<span class="hljs-title class_">Animal</span>&gt;;\n<span class="hljs-keyword">let</span> <span class="hljs-attr">coDog</span>: <span class="hljs-title class_">Co</span>&lt;<span class="hljs-title class_">Dog</span>&gt; = { <span class="hljs-attr">value</span>: dog };\n\ncoAnimal = coDog; <span class="hljs-comment">// ✅ 协变 - 安全</span>\n</code></pre>\n<h3>2. 逆变 (Contravariance)</h3>\n<p>反转子类型关系的方向（常见于函数参数）：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Contra</span>&lt;T&gt; = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">arg</span>: T</span>) =&gt;</span> <span class="hljs-built_in">void</span>;\n\n<span class="hljs-keyword">let</span> <span class="hljs-attr">contraAnimal</span>: <span class="hljs-title class_">Contra</span>&lt;<span class="hljs-title class_">Animal</span>&gt; = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-title class_">Animal</span></span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">name</span>);\n<span class="hljs-keyword">let</span> <span class="hljs-attr">contraDog</span>: <span class="hljs-title class_">Contra</span>&lt;<span class="hljs-title class_">Dog</span>&gt; = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">d</span>: <span class="hljs-title class_">Dog</span></span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d.<span class="hljs-property">breed</span>);\n  d.<span class="hljs-title function_">bark</span>();\n};\n\ncontraDog = contraAnimal; <span class="hljs-comment">// ✅ 逆变 - 安全</span>\n<span class="hljs-comment">// contraAnimal = contraDog; // ❌ 不安全</span>\n</code></pre>\n<h3>3. 双变 (Bivariance)</h3>\n<p>TypeScript 中函数参数默认是双变的（出于实用考虑）：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">funcAnimal</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">arg</span>: <span class="hljs-title class_">Animal</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;\n<span class="hljs-keyword">let</span> <span class="hljs-attr">funcDog</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">arg</span>: <span class="hljs-title class_">Dog</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;\n\nfuncAnimal = funcDog; <span class="hljs-comment">// ✅ 允许（不安全但实用）</span>\nfuncDog = funcAnimal; <span class="hljs-comment">// ✅ 允许</span>\n</code></pre>\n<h2>实际应用</h2>\n<h3>1. 类型放宽（父类型使用）</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logAnimal</span>(<span class="hljs-params"><span class="hljs-attr">animal</span>: <span class="hljs-title class_">Animal</span></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(animal.<span class="hljs-property">name</span>);\n}\n\n<span class="hljs-title function_">logAnimal</span>(dog); <span class="hljs-comment">// ✅ 接受子类型</span>\n</code></pre>\n<h3>2. 类型收缩（子类型使用）</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trainDog</span>(<span class="hljs-params"><span class="hljs-attr">dog</span>: <span class="hljs-title class_">Dog</span></span>) {\n  dog.<span class="hljs-title function_">bark</span>();\n}\n\n<span class="hljs-comment">// trainDog(animal); // ❌ 需要更具体的类型</span>\n</code></pre>\n<h3>3. 泛型约束</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> getProperty&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt;(<span class="hljs-attr">obj</span>: T, <span class="hljs-attr">key</span>: K) {\n  <span class="hljs-keyword">return</span> obj[key];\n}\n\n<span class="hljs-keyword">let</span> dogName = <span class="hljs-title function_">getProperty</span>(dog, <span class="hljs-string">&quot;name&quot;</span>); <span class="hljs-comment">// ✅</span>\n<span class="hljs-comment">// let invalid = getProperty(dog, &quot;notExist&quot;); // ❌</span>\n</code></pre>\n<h2>类型兼容性表格</h2>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>子类型 → 父类型</th>\n<th>父类型 → 子类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基本类型</td>\n<td>✅ 安全</td>\n<td>❌ 不安全</td>\n</tr>\n<tr>\n<td>对象属性</td>\n<td>✅ 安全（至少包含父类型属性）</td>\n<td>❌ 不安全（可能缺少属性）</td>\n</tr>\n<tr>\n<td>数组</td>\n<td>✅ 协变</td>\n<td>❌ 不安全</td>\n</tr>\n<tr>\n<td>函数参数</td>\n<td>❌ 不安全（除非逆变）</td>\n<td>✅ 安全（逆变）</td>\n</tr>\n<tr>\n<td>函数返回值</td>\n<td>✅ 安全（协变）</td>\n<td>❌ 不安全</td>\n</tr>\n</tbody>\n</table>\n<p>理解子类型和父类型关系是掌握 TypeScript 类型系统的关键，它影响着类型推断、泛型使用和整个代码库的类型安全设计。</p>\n</div>'</script></body></html>