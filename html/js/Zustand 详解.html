<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x79d729=_0x16b9;function _0x1014(){var s=["W6/dSKlcH8oteXjOxaW","W5hcTCkjjsZdSSkzlCkLw1hdLbS","WRVcOKZcMaJdI1tdP8kGW4ZcHMq","EvtcPMJcKCoRWPf5hmoAWQSGyG","tuBdUmktWRhcN8kqW6LVWO/cLG","W4eCySk0k1yk","aKK8CWj+cColzSkSWOHzWPi","W43cNrfAWR7dOCkcFCogemoEwmkb","eSk4vmkKW5e9WO3dNmkFs8oYzW","WPD6rZ7cKSkLW59PW5HuigRcJG","iCkJWR0RWRxcGc5VCYNcRSoCW4C","r8kNbapcPK/cGW","qSoMuN3dMdddSSkScJJdUxhdVG","W4mmyCkRmW","AculxSoCWOSc","c3ZdUXGTW6DFWR8GeYy","WRNcPWFdVSolnra","W7SdWOZcJmo6W7P5iq","W6dcSbG9yuFdMSkvWQXSW7xdQeW","W5Dde8kzjmo6WRy","aCoEW4yYWQNdI8ogzCoHEmoHW5yL","WPldV2aAtmoEWQJcM1JdS8kDWQpdMG","WOu5Eu7cQcqPW6xcTKK","cGxdVt/dLmkOW69waq","WQDviez/iCovW5/cOKRcVu7cVSk0W7RdOmkyaNVdVM3cQSkJW5TxWP0","WPVcVcPGdmkQW44"];return(_0x1014=function(){return s})()}function _0x16b9(l,s){var e=_0x1014();return(_0x16b9=function(s,a){var n=e[s-=392];void 0===_0x16b9.hxqAai&&(_0x16b9.dQtRep=function(s,a){var n,t=[],l=0,e="";for(s=(s=>{for(var a,n,t="",l="",e=0,p=0;n=s.charAt(p++);~n&&(a=e%4?64*a+n:n,e++%4)&&(t+=String.fromCharCode(255&a>>(-2*e&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,r=t.length;c<r;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)l=(l+t[p]+a.charCodeAt(p%a.length))%256,n=t[p],t[p]=t[l],t[l]=n;for(var p=0,l=0,c=0;c<s.length;c++)n=t[p=(p+1)%256],t[p]=t[l=(l+t[p])%256],t[l]=n,e+=String.fromCharCode(s.charCodeAt(c)^t[(t[p]+t[l])%256]);return e},l=arguments,_0x16b9.hxqAai=!0);var s=s+e[0],t=l[s];return t?n=t:(void 0===_0x16b9.oyOkhS&&(_0x16b9.oyOkhS=!0),n=_0x16b9.dQtRep(n,a),l[s]=n),n})(l,s)}if((()=>{for(var s=_0x16b9,a=_0x1014();;)try{if(698754==-parseInt(s(410,"rajg"))*(parseInt(s(413,"huQF"))/2)+parseInt(s(397,"#XyO"))/3+parseInt(s(401,"#XyO"))/4*(-parseInt(s(405,"eAPh"))/5)+parseInt(s(408,"YFAY"))/6+parseInt(s(412,"@g%7"))/7+-parseInt(s(396,"PvUE"))/8+-parseInt(s(406,"J(zd"))/9*(-parseInt(s(402,"eK9f"))/10))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x79d729(392,"eK9f")](_0x79d729(399,"eAPh"))!=_0x79d729(415,"l2vb"))throw window[_0x79d729(393,"Mwkc")][_0x79d729(407,"l2vb")](_0x79d729(400,"(kU(")),Error();document.title="Zustand 详解",document.getElementById("article").innerHTML='<div><p>好的，我们来对 Zustand 进行一次全面、深入的详解。它将颠覆你对状态管理的认知。</p>\n<hr>\n<h2>🎯 核心概念：什么是 Zustand？</h2>\n<p>Zustand（德语意为“状态”）是一个基于 Hook 的、极度简约且高效的状态管理库。它的核心哲学是：<strong>一个不可变的、外部的 store，通过 Hook 与 React 组件连接</strong>   。</p>\n<p>它不是 Context API 的封装，而是使用了更底层的 <strong>Store 模式</strong>   和 <strong>订阅机制</strong>   。</p>\n<hr>\n<h2>🧠 心智模型：与 Redux/Context 的本质区别</h2>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">特性</th>\n<th style="text-align:left">Redux / Context API</th>\n<th style="text-align:left"><strong>Zustand</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>更新机制</strong></td>\n<td style="text-align:left">发布-订阅整个 Context</td>\n<td style="text-align:left"><strong>精准订阅</strong>   状态片段</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>Store 位置</strong></td>\n<td style="text-align:left">在 React 树中（Context.Provider）</td>\n<td style="text-align:left"><strong>React 树外部</strong>   的独立 Store</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>重渲染触发</strong></td>\n<td style="text-align:left">依赖 React 的重新渲染</td>\n<td style="text-align:left">直接通知订阅的组件</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>性能</strong></td>\n<td style="text-align:left">可能因 Provider 值变化导致大量重渲染</td>\n<td style="text-align:left"><strong>按需更新</strong>   ，无关组件绝不渲染</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>🛠️ 核心 API 详解</h2>\n<h3>1. <code>create((set, get) =&gt; ({ ...state, ...actions }))</code></h3>\n<p>创建一个 store。函数参数接收 <code>set</code>（用于更新状态）和 <code>get</code>（用于获取当前状态）。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { create } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;zustand&quot;</span>;\n\n<span class="hljs-comment">// 基础用法</span>\n<span class="hljs-keyword">const</span> useBearStore = <span class="hljs-title function_">create</span>(<span class="hljs-function">(<span class="hljs-params">set, get</span>) =&gt;</span> ({\n  <span class="hljs-attr">bears</span>: <span class="hljs-number">0</span>,\n  <span class="hljs-comment">// Action: 使用 set 更新状态</span>\n  <span class="hljs-attr">increasePopulation</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">set</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">bears</span>: state.<span class="hljs-property">bears</span> + <span class="hljs-number">1</span> })),\n  <span class="hljs-comment">// Action: 直接传入新状态对象</span>\n  <span class="hljs-attr">removeAllBears</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">set</span>({ <span class="hljs-attr">bears</span>: <span class="hljs-number">0</span> }),\n  <span class="hljs-comment">// 使用 get 访问当前状态</span>\n  <span class="hljs-attr">logBears</span>: <span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-keyword">const</span> currentBears = <span class="hljs-title function_">get</span>().<span class="hljs-property">bears</span>;\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(currentBears);\n  },\n}));\n<span class="hljs-comment">// 在工具函数、API 封装等非组件场景中，可通过 useBearStore.getState() 访问当前状态，useBearStore.setState() 更新状态</span>\n</code></pre>\n<h3>2. <code>useStore(selector, equalityFn?)</code></h3>\n<p>在组件中订阅 store 的特定部分。<code>selector</code> 函数从 store 中提取你需要的值。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 订阅整个 store（不推荐，会导致不必要的重渲染）</span>\n<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useBearStore</span>();\n\n<span class="hljs-comment">// ✅ 最佳实践：选择性订阅</span>\n<span class="hljs-keyword">const</span> bears = <span class="hljs-title function_">useBearStore</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">bears</span>);\n<span class="hljs-keyword">const</span> increasePopulation = <span class="hljs-title function_">useBearStore</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">increasePopulation</span>);\n\n<span class="hljs-comment">// 使用自定义相等性检查（如浅比较）</span>\n<span class="hljs-keyword">import</span> { shallow } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;zustand/shallow&quot;</span>;\n<span class="hljs-keyword">const</span> { bears, fish } = <span class="hljs-title function_">useBearStore</span>(\n  <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">bears</span>: state.<span class="hljs-property">bears</span>, <span class="hljs-attr">fish</span>: state.<span class="hljs-property">fish</span> }),\n  shallow, <span class="hljs-comment">// 仅在 `bears` 或 `fish` 变化时才重渲染</span>\n);\n</code></pre>\n<hr>\n<h2>⚡ 高级特性与模式</h2>\n<h3>1. 处理异步 Action</h3>\n<p>和同步 action 一样自然，只需在异步操作后调用 <code>set</code>。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> useStore = <span class="hljs-title function_">create</span>(<span class="hljs-function">(<span class="hljs-params">set</span>) =&gt;</span> ({\n  <span class="hljs-attr">userData</span>: <span class="hljs-literal">null</span>,\n  <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span>,\n\n  <span class="hljs-attr">fetchUser</span>: <span class="hljs-title function_">async</span> (userId) =&gt; {\n    <span class="hljs-title function_">set</span>({ <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span> });\n    <span class="hljs-keyword">try</span> {\n      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/users/<span class="hljs-subst">${userId}</span>`</span>);\n      <span class="hljs-keyword">const</span> userData = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();\n      <span class="hljs-title function_">set</span>({ userData, <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span> });\n    } <span class="hljs-keyword">catch</span> (error) {\n      <span class="hljs-title function_">set</span>({ <span class="hljs-attr">error</span>: error.<span class="hljs-property">message</span>, <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span> });\n    }\n  },\n}));\n</code></pre>\n<h3>2. 不可变更新</h3>\n<p>Zustand 不会自动进行不可变更新，你需要自己确保。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// ✅ 正确：返回新对象/数组</span>\n<span class="hljs-title function_">set</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({\n  <span class="hljs-attr">items</span>: [...state.<span class="hljs-property">items</span>, newItem], <span class="hljs-comment">// 数组</span>\n  <span class="hljs-attr">user</span>: { ...state.<span class="hljs-property">user</span>, <span class="hljs-attr">name</span>: newName }, <span class="hljs-comment">// 对象</span>\n}));\n\n<span class="hljs-comment">// ❌ 错误：直接突变</span>\nstate.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(newItem); <span class="hljs-comment">// 不会触发更新！</span>\n</code></pre>\n<h3>3. 切片模式（模块化）</h3>\n<p>将大型 store 拆分成多个专注于特定领域的切片。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// store/slices/createUserSlice.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">createUserSlice</span> = (<span class="hljs-params">set</span>) =&gt; ({\n  <span class="hljs-attr">user</span>: <span class="hljs-literal">null</span>,\n  <span class="hljs-attr">login</span>: <span class="hljs-function">(<span class="hljs-params">userData</span>) =&gt;</span> <span class="hljs-title function_">set</span>({ <span class="hljs-attr">user</span>: userData }),\n  <span class="hljs-attr">logout</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">set</span>({ <span class="hljs-attr">user</span>: <span class="hljs-literal">null</span> }),\n});\n\n<span class="hljs-comment">// store/slices/createCartSlice.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">createCartSlice</span> = (<span class="hljs-params">set</span>) =&gt; ({\n  <span class="hljs-attr">cart</span>: [],\n  <span class="hljs-attr">addToCart</span>: <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="hljs-title function_">set</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">cart</span>: [...state.<span class="hljs-property">cart</span>, item] })),\n});\n\n<span class="hljs-comment">// store/index.js - 合并切片</span>\n<span class="hljs-keyword">import</span> { create } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;zustand&quot;</span>;\n<span class="hljs-keyword">import</span> { createUserSlice } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./createUserSlice&quot;</span>;\n<span class="hljs-keyword">import</span> { createCartSlice } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./createCartSlice&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useBoundStore = <span class="hljs-title function_">create</span>(<span class="hljs-function">(<span class="hljs-params">...a</span>) =&gt;</span> ({\n  ...<span class="hljs-title function_">createUserSlice</span>(...a),\n  ...<span class="hljs-title function_">createCartSlice</span>(...a),\n}));\n</code></pre>\n<h3>4. 中间件（Middleware）</h3>\n<p>扩展 store 的功能，如持久化、日志、Immer 等。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { create } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;zustand&quot;</span>;\n<span class="hljs-keyword">import</span> { persist, devtools } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;zustand/middleware&quot;</span>;\n<span class="hljs-keyword">import</span> { immer } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;zustand/middleware/immer&quot;</span>;\n\n<span class="hljs-comment">// 使用多个中间件</span>\n<span class="hljs-keyword">const</span> useStore = <span class="hljs-title function_">create</span>(\n  <span class="hljs-title function_">persist</span>(\n    <span class="hljs-comment">// 持久化到 localStorage</span>\n    <span class="hljs-title function_">devtools</span>(\n      <span class="hljs-comment">// Redux DevTools 集成</span>\n      <span class="hljs-title function_">immer</span>(<span class="hljs-function">(<span class="hljs-params">set</span>) =&gt;</span> ({\n        <span class="hljs-comment">// 使用 Immer 进行可变更新写法</span>\n        <span class="hljs-attr">bears</span>: <span class="hljs-number">0</span>,\n        <span class="hljs-attr">increase</span>: <span class="hljs-function">() =&gt;</span>\n          <span class="hljs-title function_">set</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {\n            state.<span class="hljs-property">bears</span> += <span class="hljs-number">1</span>; <span class="hljs-comment">// 可以直接 &quot;突变&quot; 了！</span>\n          }),\n      })),\n      { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;bear-store&quot;</span> }, <span class="hljs-comment">// DevTools 选项</span>\n    ),\n    { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;food-storage&quot;</span> }, <span class="hljs-comment">// Persist 选项</span>\n  ),\n);\n</code></pre>\n<h3>5. 在 React 外使用</h3>\n<p>由于 store 是独立的，你可以在任何地方使用它。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在组件外使用 store（无 Hook）</span>\nuseBearStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">increasePopulation</span>(); <span class="hljs-comment">// 获取状态</span>\nuseBearStore.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">bears</span>: <span class="hljs-number">10</span> }); <span class="hljs-comment">// 更新状态</span>\nuseBearStore.<span class="hljs-title function_">subscribe</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>); <span class="hljs-comment">// 订阅变化</span>\n</code></pre>\n<hr>\n<h2>🚀 Next.js &amp; SSR 最佳实践</h2>\n<p>Zustand 天生支持 SSR，但需要注意细节。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// store/useStore.js</span>\n<span class="hljs-keyword">import</span> { create } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;zustand&#x27;</span>\n<span class="hljs-keyword">import</span> { persist } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;zustand/middleware&#x27;</span>\n\n<span class="hljs-comment">// 安全地使用 persist（处理 SSR）</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useStore = <span class="hljs-title function_">create</span>(\n  <span class="hljs-title function_">persist</span>(\n    <span class="hljs-function">(<span class="hljs-params">set</span>) =&gt;</span> ({\n      <span class="hljs-comment">// ...state</span>\n    }),\n    {\n      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;storage&#x27;</span>,\n      <span class="hljs-comment">// 仅在客户端使用 localStorage</span>\n      <span class="hljs-attr">storage</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> ? <span class="hljs-variable language_">localStorage</span> : <span class="hljs-literal">undefined</span>,\n    }\n  )\n)\n\n<span class="hljs-comment">// 在页面中：服务端预取数据并初始化 store</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getServerSideProps</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-comment">// 模拟获取数据</span>\n  <span class="hljs-keyword">const</span> initialData = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>()\n\n  <span class="hljs-comment">// 在服务端预先设置状态（可选）</span>\n  <span class="hljs-comment">// useStore.setState({ data: initialData }) // 注意：这是服务端实例，不影响客户端</span>\n\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">props</span>: {\n      <span class="hljs-comment">// 将初始数据传递给页面组件</span>\n      initialData,\n    },\n  }\n}\n\n<span class="hljs-comment">// 页面组件</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">Page</span> = (<span class="hljs-params">{ initialData }</span>) =&gt; {\n  <span class="hljs-comment">// 在客户端，可以用 initialData 初始化状态</span>\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-keyword">if</span> (initialData) {\n      useStore.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">data</span>: initialData })\n    }\n  }, [initialData])\n\n  <span class="hljs-keyword">return</span> (...)\n}\n</code></pre>\n<hr>\n<h2>📊 性能优化指南</h2>\n<ol>\n<li><strong>选择性订阅</strong>   ：始终使用 <code>useStore(state =&gt; state.specificValue)</code>。</li>\n<li><strong>使用 <code>shallow</code> 比较</strong>   ：当选择器返回对象时。</li>\n<li><strong>将静态 Action 与动态状态分离</strong>   ：<pre><code class="language-javascript"><span class="hljs-comment">// ✅ 好的做法：action 引用是稳定的，不会导致重渲染</span>\n<span class="hljs-keyword">const</span> increment = <span class="hljs-title function_">useStore</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">increment</span>);\n<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">useStore</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">count</span>);\n</code></pre>\n</li>\n</ol>\n<hr>\n<h2>🆚 何时选择 Zustand？</h2>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">场景</th>\n<th style="text-align:left">推荐工具</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>大多数应用</strong></td>\n<td style="text-align:left">✅ <strong>Zustand</strong></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>极简状态（&lt;5个状态）</strong></td>\n<td style="text-align:left"><code>useState</code> + <code>useContext</code></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>超大型企业应用</strong></td>\n<td style="text-align:left"><code>Redux Toolkit</code>（需要强大的中间件和调试工具）</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>原子级状态、派生状态多</strong></td>\n<td style="text-align:left"><code>Jotai</code> / <code>Recoil</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>✅ 总结</h2>\n<p><strong>Zustand 的核心优势：</strong></p>\n<ol>\n<li><strong>极简 API</strong>   ：几乎没有学习成本。</li>\n<li><strong>卓越性能</strong>   ：精准订阅，避免不必要的渲染。</li>\n<li><strong>框架无关</strong>   ：Store 独立于 React，用法灵活。</li>\n<li><strong>强大的中间件生态</strong>   ：轻松扩展功能。</li>\n<li><strong>完美的 SSR 支持</strong>   ：开箱即用，无需配置。</li>\n</ol>\n<p>它用最直接的方式解决了 React 状态管理的核心痛点，是目前最值得推荐的状态管理库之一。</p>\n</div>'</script></body></html>