<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1071d8=_0x3ba8;function _0x5bff(){var s=["W7dcSxddICk+WQFdRLyiW6G","DmkFW6LTW4KYy187","zmoHve/dU8o+W6zXW77dTSk6","dConWRGXWOjXBv4mWQroW5u","cSo3WRpdRCkZWRGjW6m","W7X1W7uqW4RdKYmZWRb4WP0c","WONdP3NcPIRdUW3cOW","dvBdImkZdmkoWQO","W57cMWdcRCkvcZBdLq","ECkGW4tcTvr2WQTuWOjKWQFdOCks","l8o9WOtdJrCRW7i","suVcQqiepJBdHW","pmkNW7BdRCklW7u3W4nbW7PcW6K","W7v1W7qAW4hdLc06WOD9WPO4","tGpdVCkTkmkaWPRdJa","WO7dJ2JdTSoT","pmkKW7ZdRSkmWOu+W75mW7PN","ECkPW4xcTfv3WQOTWOjeWRpdRmk8dW","pL0Nz0H1WPD4qSkJ","WR7cKCkbW44gDSogWRhdRe7cN8k/","W5lcM23dVSowzHtdRLVdPSo7W7m","WRRcKmkmW48eDSk4WQJdHKRcKmk0WRm","rNBdGtfLW6xcKd4bBGPX","xmomWOpdTZ8iwxK","W7mIsCk5W6BcJfhdQCkoqwhcT2icyCoSW7/cTrRdNLbvwh9zfG","pfSIzbORW7ORtmkDeSoiW41+","aCk1vMtcMHqoda","kSoip15AW6GGW5H2WPqHFa"];return(_0x5bff=function(){return s})()}function _0x3ba8(l,s){var t=_0x5bff();return(_0x3ba8=function(s,n){var e=t[s-=265];void 0===_0x3ba8.jrLrKI&&(_0x3ba8.uifEPB=function(s,n){var e,a=[],l=0,t="";for(s=(s=>{for(var n,e,a="",l="",t=0,o=0;e=s.charAt(o++);~e&&(n=t%4?64*n+e:e,t++%4)&&(a+=String.fromCharCode(255&n>>(-2*t&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var c=0,d=a.length;c<d;c++)l+="%"+("00"+a.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),o=0;o<256;o++)a[o]=o;for(o=0;o<256;o++)l=(l+a[o]+n.charCodeAt(o%n.length))%256,e=a[o],a[o]=a[l],a[l]=e;for(var o=0,l=0,c=0;c<s.length;c++)e=a[o=(o+1)%256],a[o]=a[l=(l+a[o])%256],a[l]=e,t+=String.fromCharCode(s.charCodeAt(c)^a[(a[o]+a[l])%256]);return t},l=arguments,_0x3ba8.jrLrKI=!0);var s=s+t[0],a=l[s];return a?e=a:(void 0===_0x3ba8.JiIDNk&&(_0x3ba8.JiIDNk=!0),e=_0x3ba8.uifEPB(e,n),l[s]=e),e})(l,s)}if((()=>{for(var s=_0x3ba8,n=_0x5bff();;)try{if(701888==-parseInt(s(286,"uuIt"))+parseInt(s(292,"gfos"))/2*(parseInt(s(275,"L8u^"))/3)+parseInt(s(290,"DXhI"))/4*(-parseInt(s(267,"yeXp"))/5)+parseInt(s(273,"T8cM"))/6+-parseInt(s(281,"BzQW"))/7*(-parseInt(s(269,"S7Z]"))/8)+-parseInt(s(270,"DXhI"))/9+-parseInt(s(284,"I7b)"))/10*(-parseInt(s(287,"jL1y"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1071d8(291,"DXhI")](_0x1071d8(282,"I7b)"))!=_0x1071d8(268,"9RVY"))throw window[_0x1071d8(279,"HMkS")][_0x1071d8(288,"yeXp")](_0x1071d8(277,"YqaV")),Error();document.title="typescript declare module",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>declare module &quot;test&quot;</code> 和 <code>declare module Test</code> 的主要区别在于模块名称的引用方式和类型。</p>\n<h3><code>declare module &quot;test&quot;</code></h3>\n<ol>\n<li><strong>模块名称</strong>  ：\n<ul>\n<li>使用双引号 <code>&quot;</code> 包裹的模块名称 <code>&quot;test&quot;</code> 是一个字符串字面量，表示一个外部模块的名称。</li>\n<li>这种形式通常用于声明第三方库或特定文件的类型信息，尤其是当这些库或文件没有自带类型定义文件（<code>.d.ts</code>）时。</li>\n</ul>\n</li>\n<li><strong>用途</strong>  ：\n<ul>\n<li>通过 <code>declare module &quot;test&quot;</code>，你可以为名为 <code>&quot;test&quot;</code> 的外部模块定义类型信息，包括接口、类、函数等。</li>\n<li>这使得你可以在 TypeScript 项目中安全地使用这个模块，并获得类型检查和自动完成功能。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;test&quot;</span> {\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params"><span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span>;\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {\n    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>);\n    <span class="hljs-title function_">greet</span>(): <span class="hljs-built_in">void</span>;\n  }\n}\n</code></pre>\n</li>\n</ol>\n<h3><code>declare module Test</code></h3>\n<ol>\n<li><strong>模块名称</strong>  ：\n<ul>\n<li>不使用引号包裹的模块名称 <code>Test</code> 是一个标识符，通常用于声明一个内部模块或命名空间。</li>\n<li>在 TypeScript 中，命名空间（namespace）和模块（module）在某些情况下可以互换使用，但它们的用途和组织方式有所不同。</li>\n</ul>\n</li>\n<li><strong>用途</strong>  ：\n<ul>\n<li><code>declare module Test</code> 更多地用于声明一个逻辑上的命名空间，用于组织相关的类型、类、接口等。</li>\n<li>命名空间可以帮助避免全局变量的污染，并提供一种层次化的访问方式。</li>\n<li>这种形式通常用于组织内部代码，而不是为外部库提供类型声明。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-title class_">Test</span> {\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> {\n    <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;\n    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  }\n\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span>;\n}\n</code></pre>\n</li>\n</ol>\n<h3>主要区别</h3>\n<ul>\n<li><strong>模块名称类型</strong>  ：<code>declare module &quot;test&quot;</code> 使用字符串字面量作为模块名称，而 <code>declare module Test</code> 使用标识符作为模块名称。</li>\n<li><strong>用途</strong>  ：<code>declare module &quot;test&quot;</code> 主要用于声明外部模块的类型信息，而 <code>declare module Test</code> 主要用于声明内部命名空间。</li>\n<li><strong>组织方式</strong>  ：外部模块通常通过 <code>import</code> 和 <code>export</code> 语句进行导入和导出，而命名空间则通过点语法（如 <code>Test.MyInterface</code>）进行访问。</li>\n</ul>\n<h3>总结</h3>\n<ul>\n<li><strong><code>declare module &quot;test&quot;</code></strong>  ：用于声明外部模块的类型信息，模块名称是字符串字面量。</li>\n<li><strong><code>declare module Test</code></strong>  ：用于声明内部命名空间，模块名称是标识符。</li>\n</ul>\n<p>在选择使用哪种形式时，应根据你的具体需求来决定。如果你需要为第三方库或特定文件提供类型声明，应使用 <code>declare module &quot;test&quot;</code>；如果你需要组织内部代码并避免全局变量污染，应使用 <code>declare module Test</code>。</p>\n</div>'</script></body></html>