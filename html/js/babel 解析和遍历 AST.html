<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x56f0(r,s){var l=_0x5d8a();return(_0x56f0=function(s,a){var n=l[s-=201];void 0===_0x56f0.CsdRDB&&(_0x56f0.cbCHPo=function(s,a){var n,e=[],r=0,l="";for(s=(s=>{for(var a,n,e="",r="",l=0,c=0;n=s.charAt(c++);~n&&(a=l%4?64*a+n:n,l++%4)&&(e+=String.fromCharCode(255&a>>(-2*l&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var t=0,o=e.length;t<o;t++)r+="%"+("00"+e.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(r)})(s),c=0;c<256;c++)e[c]=c;for(c=0;c<256;c++)r=(r+e[c]+a.charCodeAt(c%a.length))%256,n=e[c],e[c]=e[r],e[r]=n;for(var c=0,r=0,t=0;t<s.length;t++)n=e[c=(c+1)%256],e[c]=e[r=(r+e[c])%256],e[r]=n,l+=String.fromCharCode(s.charCodeAt(t)^e[(e[c]+e[r])%256]);return l},r=arguments,_0x56f0.CsdRDB=!0);var s=s+l[0],e=r[s];return e?n=e:(void 0===_0x56f0.vjsUuU&&(_0x56f0.vjsUuU=!0),n=_0x56f0.cbCHPo(n,a),r[s]=n),n})(r,s)}function _0x5d8a(){var s=["WOlcTCk8isuoW7pcRG","AKjbgH8fW70rbLBdRhi9WQlcVIm1pmkdybTVAmouEmo8","t8oOW4iuWQFcGISp","kK3dTX8MW4T5","W73dSq/dKmkqWOtdOq","W784WORcGZ4mW7rhlNdcOZxdKW","Ara2kSkVduLkymkDW5FdHau","W6j+WR9eW5tdJCkXwCkEWRblWOPL","WOVdRxlcHfZdTu/dQSo6WOHhW6rn","W5tcUKKjW7JdJSk0W4a","W63cHKfUWQqjlXZdP3brFmok","brLri8kAjxq","W63dTHmsW59Ztq","WQX5WRpdLSolWOWKWOaEA3LG","W6dcNr3dMaSvW70","W5hcSHr8WR7cRmo0W7abWPhdS8kCW4e","W51PWQ/cMmoJymoclbldKmoJWQldRa","WOBcSSoPvgzLW7NcQSkGW54RW60","WRifALhcQmkcAmk3wLvLW7uI","rxlcRXpdSGel","dSk8W7JcJSoIcHldQq","W6hcNSk8i8okW44OWRldMG","W6tcI1NcHf4","taBdTKdcGLXFzCk3WRqbvCoX","smoPWOn1W6hdPx9BWOG4fYxdQuy","jmoJlgH5dZldTCohWOtcNrHW","WQNdMaddK8kLWOtdQH0","taxdUKJcHfTFgmkcWPWlAmoXzW"];return(_0x5d8a=function(){return s})()}var _0x13c8b3=_0x56f0;if((()=>{for(var s=_0x56f0,a=_0x5d8a();;)try{if(972543==-parseInt(s(208,"GAwD"))+parseInt(s(213,"8MNY"))/2+-parseInt(s(215,"8MNY"))/3*(-parseInt(s(210,"n1R%"))/4)+-parseInt(s(205,"Gg7I"))/5*(parseInt(s(216,"VvSO"))/6)+-parseInt(s(221,"eyLP"))/7*(parseInt(s(207,"Z@3O"))/8)+-parseInt(s(202,"*O])"))/9*(-parseInt(s(203,")$(g"))/10)+-parseInt(s(211,"rbtB"))/11)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x13c8b3(214,"EzQ(")](_0x13c8b3(224,"!W1@"))!=_0x13c8b3(225,"QrSa"))throw window[_0x13c8b3(201,"Z@3O")][_0x13c8b3(217,"KILs")](_0x13c8b3(204,"$b54")),Error();document.title="babel 解析和遍历 AST",document.getElementById("article").innerHTML='<div><p><a href="https://astexplorer.net/" target="_blank">AST 在线地址</a></p>\n<p>Babel 是一个强大的 JavaScript 编译器，主要用于将现代 JavaScript 代码转换为向后兼容的版本。其核心步骤就是解析代码为抽象语法树（AST），对 AST 进行转换，最后将转换后的 AST 生成新的代码。以下是使用 Babel 解析和转换 AST 的详细步骤：</p>\n<h3>1. 初始化项目</h3>\n<p>首先，创建一个新的项目目录，并初始化 <code>package.json</code> 文件：</p>\n<pre><code class="language-sh"><span class="hljs-built_in">mkdir</span> babel-ast-example\n<span class="hljs-built_in">cd</span> babel-ast-example\nnpm init -y\n</code></pre>\n<h3>2. 安装必要的依赖</h3>\n<p>安装 Babel 核心库、解析器和遍历器：</p>\n<pre><code class="language-sh">npm install --save-dev @babel/core @babel/parser @babel/traverse @babel/generator @babel/types\n</code></pre>\n<ul>\n<li><code>@babel/core</code>：Babel 的核心库，提供了编译的核心功能。</li>\n<li><code>@babel/parser</code>：用于将 JavaScript 代码解析为 AST。</li>\n<li><code>@babel/traverse</code>：用于遍历和修改 AST。</li>\n<li><code>@babel/generator</code>：用于将修改后的 AST 转换回 JavaScript 代码。</li>\n<li><code>@babel/types</code>：创建、检查以及修改抽象语法树（AST）节点。</li>\n</ul>\n<h3>3. 编写代码进行解析和转换</h3>\n<p>创建一个 JavaScript 文件，例如 <code>index.js</code>，并编写以下代码：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/parser&#x27;</span>);\n<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/traverse&#x27;</span>).<span class="hljs-property">default</span>;\n<span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/generator&#x27;</span>).<span class="hljs-property">default</span>;\n<span class="hljs-keyword">const</span>  t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/types&#x27;</span>);\n\n<span class="hljs-comment">// 示例代码</span>\n<span class="hljs-keyword">const</span> code = <span class="hljs-string">`\nfunction greet(name) {\n  return &#x27;Hello, &#x27; + name;\n}\n`</span>;\n\n<span class="hljs-comment">// 解析代码为 AST</span>\n<span class="hljs-keyword">const</span> ast = parser.<span class="hljs-title function_">parse</span>(code);\n\n<span class="hljs-comment">// 定义一个 visitor 对象来转换 AST</span>\n<span class="hljs-keyword">const</span> visitor = {\n    <span class="hljs-title class_">FunctionDeclaration</span>(path) {\n        <span class="hljs-comment">// 将函数声明转换为箭头函数</span>\n        <span class="hljs-keyword">const</span> { id, params, body } = path.<span class="hljs-property">node</span>;\n        <span class="hljs-keyword">const</span> arrowFunction = t.<span class="hljs-title function_">arrowFunctionExpression</span>(params, body);\n        <span class="hljs-keyword">const</span> variableDeclaration = t.<span class="hljs-title function_">variableDeclaration</span>(<span class="hljs-string">&#x27;const&#x27;</span>, [\n            t.<span class="hljs-title function_">variableDeclarator</span>(id, arrowFunction)\n        ]);\n        path.<span class="hljs-title function_">replaceWith</span>(variableDeclaration);\n    }\n};\n\n<span class="hljs-comment">// 遍历并转换 AST</span>\n<span class="hljs-title function_">traverse</span>(ast, visitor);\n\n<span class="hljs-comment">// 将转换后的 AST 生成新的代码</span>\n<span class="hljs-keyword">const</span> { <span class="hljs-attr">code</span>: newCode } = <span class="hljs-title function_">generator</span>(ast);\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newCode);\n</code></pre>\n<h3>代码解释</h3>\n<ul>\n<li><strong>解析代码</strong>  ：使用 <code>@babel/parser</code> 的 <code>parse</code> 方法将 JavaScript 代码解析为 AST。</li>\n<li><strong>定义 visitor 对象</strong>  ：<code>visitor</code> 对象包含了各种节点类型的访问器函数。在这个例子中，<code>FunctionDeclaration</code> 访问器函数会在遍历到函数声明节点时被调用，并将其转换为箭头函数。</li>\n<li><strong>遍历并转换 AST</strong>  ：使用 <code>@babel/traverse</code> 的 <code>traverse</code> 方法遍历 AST，并传入 <code>visitor</code> 对象进行转换。</li>\n<li><strong>生成新的代码</strong>  ：使用 <code>@babel/generator</code> 的 <code>generator</code> 方法将转换后的 AST 转换回 JavaScript 代码。</li>\n</ul>\n<h3>4. 运行代码</h3>\n<p>在终端中运行以下命令来执行 <code>index.js</code> 文件：</p>\n<pre><code class="language-sh">node index.js\n</code></pre>\n<p>你将看到输出的新代码，其中函数声明已经被转换为箭头函数。</p>\n<h3>总结</h3>\n<p>通过以上步骤，你可以使用 Babel 解析 JavaScript 代码为 AST，对 AST 进行转换，并将转换后的 AST 生成新的代码。你可以根据具体需求修改 <code>visitor</code> 对象中的访问器函数，实现各种复杂的代码转换逻辑。</p>\n</div>'</script></body></html>