<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x222e(e,s){var t=_0x7f4e();return(_0x222e=function(s,n){var a=t[s-=308];void 0===_0x222e.WZeVBB&&(_0x222e.IFHGYq=function(s,n){var a,l=[],e=0,t="";for(s=(s=>{for(var n,a,l="",e="",t=0,o=0;a=s.charAt(o++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,p=l.length;c<p;c++)e+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),o=0;o<256;o++)l[o]=o;for(o=0;o<256;o++)e=(e+l[o]+n.charCodeAt(o%n.length))%256,a=l[o],l[o]=l[e],l[e]=a;for(var o=0,e=0,c=0;c<s.length;c++)a=l[o=(o+1)%256],l[o]=l[e=(e+l[o])%256],l[e]=a,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[o]+l[e])%256]);return t},e=arguments,_0x222e.WZeVBB=!0);var s=s+t[0],l=e[s];return l?a=l:(void 0===_0x222e.TfplIq&&(_0x222e.TfplIq=!0),a=_0x222e.IFHGYq(a,n),e[s]=a),a})(e,s)}var _0x497eea=_0x222e;function _0x7f4e(){var s=["a8kHWPBcPae","EHNdLSoMAMlcHmoxWRxcSt4","WRSRf8oroeeoWRXwtmkVha","BmoMqxJdHCk6aW","qmopxxfkoduCkmo7W4RdRmo3","ixOjEra9heZdGG","W5ldT8k/W5xdNg9zvNJdU8kNa8omW6f9s3BcQSohWOVcSuTmWQKoWQm","WQSrW4/dK8kOqgTzW59dEG","W7VdTSk5WQxdHvVcUSkxW6qX","W7jlWPNcG8oUFKHv","xJ/dH8kjWOlcL319W7ldIXpdQG","WOfQW5NdVSktWRmTrWP5WRrD","fI7cKKVdLmkDWRlcM8kC","rmoNW5BdOuJcO8kke8koWPpcTKJcUa","nmkGW5CIWOrWW7OgW73dK3ONW5W","BJLgWODQjmkRqCoXWOhdHa","l8kUktdcPL3cKa","W5PIWP4YW63cM8ksW592q8kLW7/cNq","nCkVW5HwxqFdIthcP0m/WOddOa","W53dPSk/W6ZdMZaB","n2OzWQ9RW6RdI8oRlG","WQOCW47dKSo1B0vpW7zX","B8ofWRRdJYOMdSkCE0hcOCktWOi","WRHOW67cHLq4vSkeWP/dPbq","FCk9WP7cKCovWQ3cKG","aSo2qmovW5hdUCoaW7FcJSkeeCoJ"];return(_0x7f4e=function(){return s})()}if((()=>{for(var s=_0x222e,n=_0x7f4e();;)try{if(503817==-parseInt(s(312,"D!SM"))+-parseInt(s(321,"@8Cj"))/2+parseInt(s(328,"W8Y["))/3*(parseInt(s(326,"Jn7f"))/4)+parseInt(s(311,"Ygx6"))/5*(-parseInt(s(330,"NBG6"))/6)+-parseInt(s(314,"UsRg"))/7+-parseInt(s(327,"qe7w"))/8+parseInt(s(317,"sgAa"))/9*(parseInt(s(318,"B$na"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x497eea(329,"0m0e")](_0x497eea(315,"C[8q"))!=_0x497eea(310,"vgkw"))throw window[_0x497eea(319,"sgAa")][_0x497eea(313,"2yFm")](_0x497eea(316,"0m0e")),Error();document.title="React 类组件首次渲染（挂载阶段）的 超详细流程解析 和 生命周期函数执行时机",document.getElementById("article").innerHTML='<div><p>以下是 React 类组件首次渲染（挂载阶段）的 <strong>超详细流程解析</strong>   和 <strong>生命周期函数执行时机</strong>  ，结合关键节点图示和底层原理说明：</p>\n<hr>\n<h3>一、完整流程分阶段解析</h3>\n<h4><strong>阶段 1：实例初始化</strong></h4>\n<ol>\n<li><strong><code>constructor(props)</code></strong>\n<ul>\n<li><strong>调用时机</strong>  ：组件实例被 <code>new</code> 创建时。</li>\n<li><strong>核心操作</strong>  ：\n<ul>\n<li>初始化 <code>this.state</code>（直接赋值，非 <code>setState</code>）</li>\n<li>绑定事件方法（如 <code>this.handleClick = this.handleClick.bind(this)</code>）</li>\n</ul>\n</li>\n<li><strong>注意事项</strong>  ：\n<ul>\n<li>必须调用 <code>super(props)</code>，否则 <code>this.props</code> 为 <code>undefined</code></li>\n<li>避免在此调用 <code>setState</code>（此时组件尚未挂载）</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {\n  <span class="hljs-variable language_">super</span>(props);\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Constructor: state 初始化&#x27;</span>);\n}\n</code></pre>\n</li>\n</ol>\n<h4><strong>阶段 2：Props 派生 State（React 16.3+）</strong></h4>\n<ol start="2">\n<li><strong><code>static getDerivedStateFromProps(nextProps, prevState)</code></strong>\n<ul>\n<li><strong>调用时机</strong>  ：在 <code>constructor</code> 之后、<code>render</code> 之前。</li>\n<li><strong>核心作用</strong>  ：\n<ul>\n<li>根据 <code>props</code> 的变化计算派生状态（返回对象将合并到 <code>state</code>）</li>\n<li>首次渲染时 <code>nextProps</code> 为初始 <code>props</code>，<code>prevState</code> 为 <code>constructor</code> 中的 <code>state</code></li>\n</ul>\n</li>\n<li><strong>特殊限制</strong>  ：\n<ul>\n<li>必须是静态方法（无法访问 <code>this</code>）</li>\n<li>应尽量少用（易导致代码冗余，通常可用 <code>componentDidUpdate</code> 替代）</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params">props, state</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;getDerivedStateFromProps: props → state 转换&#x27;</span>);\n  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 不更新 state</span>\n}\n</code></pre>\n</li>\n</ol>\n<h4><strong>阶段 3：渲染虚拟 DOM</strong></h4>\n<ol start="3">\n<li><strong><code>render()</code></strong>\n<ul>\n<li><strong>调用时机</strong>  ：所有状态（<code>props</code>/<code>state</code>）准备就绪后。</li>\n<li><strong>核心职责</strong>  ：\n<ul>\n<li>返回 JSX 或 <code>React.createElement()</code> 生成的虚拟 DOM</li>\n<li>必须为纯函数（相同输入永远返回相同输出）</li>\n</ul>\n</li>\n<li><strong>禁止操作</strong>  ：\n<ul>\n<li>不能调用 <code>setState</code>（会导致无限循环）</li>\n<li>避免直接操作 DOM（此时真实 DOM 尚未创建）</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Render: 生成虚拟 DOM&#x27;</span>);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{this.state.count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ol>\n<h4><strong>阶段 4：DOM 挂载与副作用处理</strong></h4>\n<ol start="4">\n<li><strong><code>componentDidMount()</code></strong>\n<ul>\n<li><strong>调用时机</strong>  ：组件首次渲染完成，真实 DOM 已插入页面后。</li>\n<li><strong>核心用途</strong>  ：\n<ul>\n<li>发起网络请求（如 <code>fetch</code>）</li>\n<li>订阅事件（如 <code>window.addEventListener</code>）</li>\n<li>操作 DOM（如初始化第三方库）</li>\n</ul>\n</li>\n<li><strong>关键特性</strong>  ：\n<ul>\n<li><strong>仅执行一次</strong>  （区别于更新阶段的 <code>componentDidUpdate</code>）</li>\n<li>可安全调用 <code>setState</code>（但会触发二次渲染，需谨慎）</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;componentDidMount: DOM 已挂载&#x27;</span>);\n  <span class="hljs-comment">// 示例：异步数据获取</span>\n  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">data</span>: response.<span class="hljs-property">data</span> });\n  });\n}\n</code></pre>\n</li>\n</ol>\n<hr>\n<h3>二、生命周期执行顺序图示</h3>\n<pre><code class="language-mermaid">sequenceDiagram\n    participant JS\n    participant React\n    participant DOM\n\n    JS-&gt;&gt;React: new Example(props)\n    React-&gt;&gt;JS: constructor()\n    React-&gt;&gt;JS: getDerivedStateFromProps()\n    JS-&gt;&gt;React: render() 虚拟 DOM\n    React-&gt;&gt;DOM: 协调算法 → 创建真实 DOM\n    DOM--&gt;&gt;React: 挂载完成\n    React-&gt;&gt;JS: componentDidMount()\n</code></pre>\n<hr>\n<h3>三、关键原理深入</h3>\n<ol>\n<li><strong>为什么 <code>constructor</code> 最先执行？</strong>\n<ul>\n<li>React 通过 <code>new</code> 操作符创建组件实例，构造函数是 JavaScript 类的天然入口。</li>\n</ul>\n</li>\n<li><strong><code>getDerivedStateFromProps</code> 的设计意图</strong>\n<ul>\n<li>解决旧版 <code>componentWillReceiveProps</code> 的滥用问题，强制开发者使用更可控的派生状态逻辑。</li>\n</ul>\n</li>\n<li><strong><code>render</code> 与 DOM 更新的分离</strong>\n<ul>\n<li><code>render</code> 仅生成虚拟 DOM，React 的协调算法（Reconciliation）会对比新旧虚拟 DOM，最终批量更新真实 DOM。</li>\n</ul>\n</li>\n<li><strong><code>componentDidMount</code> 的异步特性</strong>\n<ul>\n<li>浏览器会在当前 JS 执行栈清空后才会完成 DOM 渲染，因此 <code>componentDidMount</code> 是确认 DOM 可操作的最早时机。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>四、常见误区与最佳实践</h3>\n<ol>\n<li><strong>避免在 <code>constructor</code> 中访问 DOM</strong><pre><code class="language-jsx"><span class="hljs-comment">// ❌ 错误！此时 DOM 不存在</span>\n<span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {\n  <span class="hljs-variable language_">super</span>(props);\n  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myDiv&#x27;</span>); <span class="hljs-comment">// null</span>\n}\n</code></pre>\n</li>\n<li><strong>慎用 <code>getDerivedStateFromProps</code></strong>\n<ul>\n<li>优先使用受控组件或 <code>componentDidUpdate</code> 替代复杂派生逻辑。</li>\n</ul>\n</li>\n<li><strong><code>componentDidMount</code> 中的 <code>setState</code></strong>\n<ul>\n<li>虽然可行，但会触发额外渲染。对于初始数据获取，推荐在构造函数中初始化加载状态：<pre><code class="language-jsx"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {\n  <span class="hljs-variable language_">super</span>(props);\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = { <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span> };\n}\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>五、完整示例代码</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LifecycleDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {\n    <span class="hljs-variable language_">super</span>(props);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;【1】constructor&#x27;</span>);\n  }\n\n  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params">props, state</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;【2】getDerivedStateFromProps&#x27;</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;\n  }\n\n  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;【4】componentDidMount&#x27;</span>);\n  }\n\n  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;【3】render&#x27;</span>);\n    <span class="hljs-keyword">return</span> (\n      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: {this.state.count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> this.setState({ count: this.state.count + 1 })}&gt;\n          Increment\n        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<p><strong>控制台输出顺序</strong>  ：</p>\n<pre><code>【1】constructor  \n【2】getDerivedStateFromProps  \n【3】render  \n【4】componentDidMount\n</code></pre>\n<hr>\n<h3>六、React 17+ 的变化</h3>\n<ul>\n<li>废弃了 <code>componentWillMount</code>、<code>componentWillReceiveProps</code> 等不安全生命周期。</li>\n<li>新增的 <code>getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code> 更适应异步渲染（Concurrent Mode）。</li>\n</ul>\n</div>'</script></body></html>