<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1f8c51=_0x4e7b;function _0x594a(){var s=["tc/cHCkRz1JdSmokWRuvWPaC","ySo7WRxcOa3cHqOIWQBcSa","WQRcIsXkgqyGpGxcQwldKSor","W6XBW64oW53dRCoq","sY3cJCkRyfNcVCoBWOiLWPSMWRy","iNxcNCkHDgDIjI7cUgtcHq","mSksWRdcUmofAGhcLCo1","W4zWWOVdNaPAfHTUW4TqW5G","ouNdOmkfWODmW6xdSSkoW4OveCoj","W7ntsCkyFmo3W4RcOZ/cQq","hNVdMI3dKxRcOmoUW59QiW","W6f3AaFcImkYW6CeW58kumos","W6NcNmkkWRzmwmkQWQCiW6m","W5HidCoUWRdcI0HE","zWVcOCofW4vaW7RcPCkHW5aPpSolWOqXwmksmSkxaSkyA391WRdcRW","WQXhW780W57dQSog","mmkrWRJdO8kBzYFcLCotWOz7","W6f/F8kUieZdO8keW6a","ssNcISkTzLhdI8ohWPW9WR0w","Amk8maBcLNPouu4","DYtdN8oFnZvU","W6lcPd4HW60tW5WXoXddJ8o/WPO","mCkqWR7dOmkCjcxcVSowWRvUW54","xtVcMwRcMa","W6lcOJ4NWRb0WQKMabu","WPFdRmkhDSkNhgy"];return(_0x594a=function(){return s})()}function _0x4e7b(a,s){var e=_0x594a();return(_0x4e7b=function(s,n){var t=e[s-=169];void 0===_0x4e7b.RQkIoC&&(_0x4e7b.mPVhXA=function(s,n){var t,o=[],a=0,e="";for(s=(s=>{for(var n,t,o="",a="",e=0,c=0;t=s.charAt(c++);~t&&(n=e%4?64*n+t:t,e++%4)&&(o+=String.fromCharCode(255&n>>(-2*e&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var l=0,d=o.length;l<d;l++)a+="%"+("00"+o.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(a)})(s),c=0;c<256;c++)o[c]=c;for(c=0;c<256;c++)a=(a+o[c]+n.charCodeAt(c%n.length))%256,t=o[c],o[c]=o[a],o[a]=t;for(var c=0,a=0,l=0;l<s.length;l++)t=o[c=(c+1)%256],o[c]=o[a=(a+o[c])%256],o[a]=t,e+=String.fromCharCode(s.charCodeAt(l)^o[(o[c]+o[a])%256]);return e},a=arguments,_0x4e7b.RQkIoC=!0);var s=s+e[0],o=a[s];return o?t=o:(void 0===_0x4e7b.kfhpSE&&(_0x4e7b.kfhpSE=!0),t=_0x4e7b.mPVhXA(t,n),a[s]=t),t})(a,s)}if((()=>{for(var s=_0x4e7b,n=_0x594a();;)try{if(260490==+parseInt(s(176,"Gvtc"))*(-parseInt(s(173,"CmsP"))/2)+parseInt(s(180,"eBDS"))/3+parseInt(s(184,"Gvtc"))/4+-parseInt(s(174,"eBDS"))/5*(parseInt(s(175,"B6^u"))/6)+-parseInt(s(185,"hH)$"))/7*(-parseInt(s(170,"zYNq"))/8)+-parseInt(s(188,"Gvtc"))/9+parseInt(s(192,"1^RA"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1f8c51(178,"tK4&")](_0x1f8c51(177,"yoP("))!=_0x1f8c51(181,"(y05"))throw window[_0x1f8c51(171,"@Ra4")][_0x1f8c51(187,"CmsP")](_0x1f8c51(172,"1^RA")),new Error;document.title="css position sticky",document.getElementById("article").innerHTML='<div><p><code>position: sticky</code> 是 CSS 中一种非常实用的定位方式，结合了 <strong>相对定位</strong>   （<code>relative</code>） 和 <strong>固定定位</strong>   （<code>fixed</code>） 的特性。它在现代网页布局中被广泛用于创建“滚动时粘住”的效果，比如固定表头、导航栏、侧边目录等。</p>\n<hr>\n<h2>一、基本定义</h2>\n<pre><code class="language-css"><span class="hljs-selector-class">.element</span> {\n  <span class="hljs-attribute">position</span>: sticky;\n  <span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>; <span class="hljs-comment">/* 必须指定至少一个偏移值 */</span>\n}\n</code></pre>\n<ul>\n<li>默认行为像 <code>position: relative</code>：元素仍在正常文档流中。</li>\n<li>当页面滚动到设定的阈值（如 <code>top: 20px</code>）时，元素会“粘”在视口或滚动容器的指定位置，表现得像 <code>position: fixed</code>。</li>\n<li>一旦滚动超出其<strong>包含块</strong>   （通常是父容器）的边界，粘性效果就会消失。</li>\n</ul>\n<hr>\n<h2>二、关键特性详解</h2>\n<h3>1. <strong>必须设置偏移量</strong></h3>\n<p><code>sticky</code> 不会自动生效，<strong>必须显式指定 <code>top</code>、<code>bottom</code>、<code>left</code> 或 <code>right</code> 中的至少一个值</strong>   ：</p>\n<p>✅ 正确：</p>\n<pre><code class="language-css"><span class="hljs-selector-class">.sticky</span> {\n  <span class="hljs-attribute">position</span>: sticky;\n  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;\n}\n</code></pre>\n<p>❌ 无效（等同于 <code>relative</code>）：</p>\n<pre><code class="language-css"><span class="hljs-selector-class">.sticky</span> {\n  <span class="hljs-attribute">position</span>: sticky;\n}\n</code></pre>\n<hr>\n<h3>2. <strong>相对于谁定位？</strong></h3>\n<blockquote>\n<p><code>sticky</code> 元素是相对于其<strong>最近的具有滚动机制的祖先容器</strong>   （scrolling ancestor）进行定位的。</p>\n</blockquote>\n<h4>情况分析：</h4>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>定位参考对象</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>所有祖先都没有 <code>overflow: hidden/scroll/auto</code></td>\n<td><strong>浏览器视口</strong>   （viewport）</td>\n</tr>\n<tr>\n<td>某个祖先设置了 <code>overflow: auto</code> 并可滚动</td>\n<td><strong>该祖先的 padding box</strong></td>\n</tr>\n<tr>\n<td>父容器高度不足无法滚动</td>\n<td>无粘性效果（因为没滚动发生）</td>\n</tr>\n</tbody>\n</table>\n<p>📌 <strong>注意</strong>   ：即使祖先没有显式设置 <code>overflow</code>，只要它是可滚动的上下文（比如整个页面），也会成为参考。</p>\n<hr>\n<h3>3. <strong>粘性范围受限于父容器</strong></h3>\n<p>这是最容易被误解的一点！</p>\n<blockquote>\n<p><strong><code>sticky</code> 元素不会脱离其父容器的边界</strong>   。</p>\n</blockquote>\n<ul>\n<li>即使你设置了 <code>top: 0</code>，当父容器整体滚出视口时，<code>sticky</code> 元素也会随之消失。</li>\n<li>它只在<strong>父容器可见区域内</strong>   “粘住”。</li>\n</ul>\n<h4>示例说明：</h4>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 200px; overflow: auto;&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sticky&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: sticky; top: 0;&quot;</span>&gt;</span>Sticky<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 500px;&quot;</span>&gt;</span>长内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n<ul>\n<li>在 <code>.parent</code> 内部滚动时，<code>.sticky</code> 会在顶部粘住。</li>\n<li>但如果整个 <code>.parent</code> 被页面滚动移出视口，<code>.sticky</code> 也会消失。</li>\n</ul>\n<hr>\n<h3>4. <strong>支持水平方向粘性</strong></h3>\n<p>除了 <code>top</code>/<code>bottom</code>，也可以用 <code>left</code>/<code>right</code> 实现横向粘性（常用于表格或横向滚动区域）：</p>\n<pre><code class="language-css"><span class="hljs-selector-class">.cell</span> {\n  <span class="hljs-attribute">position</span>: sticky;\n  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">background</span>: white;\n  <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>;\n}\n</code></pre>\n<blockquote>\n<p>⚠️ 注意：水平粘性在某些旧浏览器中支持较差，需测试兼容性。</p>\n</blockquote>\n<hr>\n<h2>三、与其他定位方式对比</h2>\n<table>\n<thead>\n<tr>\n<th>定位类型</th>\n<th>是否脱离文档流</th>\n<th>是否随滚动移动</th>\n<th>参考点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>static</code></td>\n<td>否</td>\n<td>是</td>\n<td>—</td>\n</tr>\n<tr>\n<td><code>relative</code></td>\n<td>否</td>\n<td>是</td>\n<td>自身原始位置</td>\n</tr>\n<tr>\n<td><code>absolute</code></td>\n<td>是</td>\n<td>否</td>\n<td>最近的非 <code>static</code> 定位祖先</td>\n</tr>\n<tr>\n<td><code>fixed</code></td>\n<td>是</td>\n<td>否</td>\n<td>视口</td>\n</tr>\n<tr>\n<td><code>sticky</code></td>\n<td><strong>否</strong></td>\n<td><strong>部分</strong>   （在阈值内随流，超过后固定）</td>\n<td><strong>最近的滚动祖先或视口</strong></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>四、使用场景</h2>\n<ol>\n<li><strong>固定表头</strong>   （在可滚动表格中）</li>\n<li><strong>文章侧边目录</strong>   （滚动到某章节时目录固定）</li>\n<li><strong>电商商品详情页的“加入购物车”按钮</strong></li>\n<li><strong>移动端导航栏</strong>   （向下滚动隐藏，向上滚动显示）</li>\n</ol>\n<hr>\n<h2>五、注意事项 &amp; 常见问题</h2>\n<h3>❗ 1. 父容器不能 <code>overflow: hidden</code>（除非你希望限制粘性范围）</h3>\n<p>如果父容器设置了 <code>overflow: hidden</code> 且不可滚动，<code>sticky</code> 将无法触发。</p>\n<h3>❗ 2. <code>z-index</code> 控制层级</h3>\n<p>粘性元素可能被其他内容覆盖，建议设置 <code>z-index</code>：</p>\n<pre><code class="language-css"><span class="hljs-selector-class">.sticky</span> {\n  <span class="hljs-attribute">position</span>: sticky;\n  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">z-index</span>: <span class="hljs-number">10</span>;\n}\n</code></pre>\n<h3>❗ 3. 浏览器兼容性</h3>\n<ul>\n<li>支持良好：Chrome ≥ 56, Firefox ≥ 32, Safari ≥ 6.1, Edge ≥ 16</li>\n<li>iOS Safari 需要 <code>-webkit-sticky</code>（但现代版本已不需要）</li>\n</ul>\n<p>为兼容旧版 Safari（&lt;13），可加前缀：</p>\n<pre><code class="language-css"><span class="hljs-selector-class">.sticky</span> {\n  <span class="hljs-attribute">position</span>: -webkit-sticky;\n  <span class="hljs-attribute">position</span>: sticky;\n  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;\n}\n</code></pre>\n<hr>\n<h2>六、总结</h2>\n<blockquote>\n<p><code>position: sticky</code> 是一种<strong>智能的、上下文感知的定位方式</strong>   ：</p>\n<ul>\n<li>默认按文档流排布；</li>\n<li>滚动到指定位置时“粘住”；</li>\n<li>粘性范围受父容器限制；</li>\n<li>相对于最近的滚动祖先或视口定位；</li>\n<li>必须配合 <code>top</code>/<code>bottom</code>/<code>left</code>/<code>right</code> 使用。</li>\n</ul>\n</blockquote>\n<p>它让开发者无需 JavaScript 就能实现常见的滚动交互效果，是现代 CSS 布局的重要工具。</p>\n<hr>\n<p>如果你有具体代码或布局问题，欢迎贴出来，我可以帮你分析 <code>sticky</code> 为何不生效或如何优化！</p>\n</div>'</script></body></html>