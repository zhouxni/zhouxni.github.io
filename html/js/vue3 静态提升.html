<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5ad3(){var n=["hHdcHhpcThxcJG","pmoEW6a/uahcNL/dGSo0W69hWRq","WOGsW54bW67dLXDeWOJdV8kQWRPr","WQOugCkTdmoAWQC","w3K3efpdUCoStctdUuiy","pCoPW70yrmkdpq","WOBcIwTPWRZcO8ofWQldLtL4W6CM","WQ4VrSo2smkZW4pdVSkrpmoPWQmW","WRuPoCk+iKJdVghdV05Ziq","yf/cSKrwW61wqsHeW4VdSa","amk/W4NdUCo3seC","taRcGfiICCoxW74zWPC/W5WAWOBcImkGW7ldHCoPx2znrGpdUmow","nmoFW64Zd0BdTftdHSot","rmorW7bAxmo3dJzT","ewNdHJlcOwZcVeSYWQq","W6JcMt3cHsLpW7RcLMddNI4","W7iAFSoQzCkIWQ3dMCoy","WOCxfseUW6Ggf8oZW4rVWRzN","W4hdUSodqdX3WR3dS8oHE04K","W4lcImkTWQJcIefeWQH3","gCk6pgelW43dMmk4qJ7dMSkaW4C","bSksWRjcta","nSobW57cLu4SAq","W755ECoOhepdMcWOW7uY","aCkdWPFdVcaMiq","W5BdLCk1BCoTWRzmW7e"];return(_0x5ad3=function(){return n})()}var _0xafdc95=_0x5ee3;function _0x5ee3(t,n){var e=_0x5ad3();return(_0x5ee3=function(n,s){var a=e[n-=236];void 0===_0x5ee3.XzutXS&&(_0x5ee3.kyNtbr=function(n,s){var a,l=[],t=0,e="";for(n=(n=>{for(var s,a,l="",t="",e=0,o=0;a=n.charAt(o++);~a&&(s=e%4?64*s+a:a,e++%4)&&(l+=String.fromCharCode(255&s>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,p=l.length;r<p;r++)t+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(t)})(n),o=0;o<256;o++)l[o]=o;for(o=0;o<256;o++)t=(t+l[o]+s.charCodeAt(o%s.length))%256,a=l[o],l[o]=l[t],l[t]=a;for(var o=0,t=0,r=0;r<n.length;r++)a=l[o=(o+1)%256],l[o]=l[t=(t+l[o])%256],l[t]=a,e+=String.fromCharCode(n.charCodeAt(r)^l[(l[o]+l[t])%256]);return e},t=arguments,_0x5ee3.XzutXS=!0);var n=n+e[0],l=t[n];return l?a=l:(void 0===_0x5ee3.grMCRg&&(_0x5ee3.grMCRg=!0),a=_0x5ee3.kyNtbr(a,s),t[n]=a),a})(t,n)}if((()=>{for(var n=_0x5ee3,s=_0x5ad3();;)try{if(147431==-parseInt(n(254,"eR7K"))*(-parseInt(n(241,"o1o2"))/2)+-parseInt(n(251,"zPQT"))/3*(-parseInt(n(246,"K0v!"))/4)+-parseInt(n(239,"8T)a"))/5+parseInt(n(256,"NoDs"))/6*(parseInt(n(255,"iKQL"))/7)+parseInt(n(259,"qf[d"))/8+-parseInt(n(249,"YrQ#"))/9+parseInt(n(240,"Ka9)"))/10)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0xafdc95(261,"SrlW")](_0xafdc95(248,"YQ[N"))!=_0xafdc95(253,"aeA)"))throw window[_0xafdc95(257,"ub2A")][_0xafdc95(237,"d4Ms")](_0xafdc95(243,"m[T1")),Error();document.title="vue3 静态提升",document.getElementById("article").innerHTML='<div><p><strong>Vue 3 静态提升</strong>  是 Vue 3 框架在编译阶段实施的一种重要优化技术，旨在减少运行时的开销，提高应用程序的渲染性能。以下是关于 Vue 3 静态提升的详细介绍：</p>\n<h3>一、静态提升的概念</h3>\n<p>静态提升是指在编译阶段将模板中的静态节点提升为常量，以避免在每次渲染时重新计算这些节点。静态节点是指在渲染过程中不会发生变化的部分，例如固定的文本、样式、属性等。通过静态提升，Vue 3 可以在渲染时直接复用这些静态节点，从而减少不必要的 DOM 操作和虚拟 DOM 的更新。</p>\n<h3>二、静态提升的工作原理</h3>\n<p>静态提升的实现主要分为两个阶段：</p>\n<ol>\n<li><strong>transform 阶段</strong>  ：\n<ul>\n<li>Vue 3 的编译器在编译过程中会遍历抽象语法树（AST），识别出模板中的静态节点。</li>\n<li>对这些静态节点进行标记和处理，并将它们添加到根节点的 <code>hoists</code> 数组中。</li>\n</ul>\n</li>\n<li><strong>generate 阶段</strong>  ：\n<ul>\n<li>遍历 <code>hoists</code> 数组，在渲染函数外生成存储静态节点虚拟 DOM 的 <code>_hoisted_x</code> 变量。</li>\n<li>在渲染函数中使用这些 <code>_hoisted_x</code> 变量来表示静态节点，从而避免在每次渲染时都重新生成这些节点的虚拟 DOM。</li>\n</ul>\n</li>\n</ol>\n<h3>三、静态提升的优势</h3>\n<ol>\n<li><strong>减少运行时开销</strong>  ：\n<ul>\n<li>通过静态提升，Vue 3 可以避免在每次渲染时都重新创建静态节点的虚拟 DOM，从而减少了运行时的计算和资源消耗。</li>\n</ul>\n</li>\n<li><strong>提高渲染性能</strong>  ：\n<ul>\n<li>静态节点在渲染时可以直接复用，减少了 DOM 操作和虚拟 DOM 的更新次数，从而提高了渲染性能。</li>\n</ul>\n</li>\n<li><strong>优化代码结构</strong>  ：\n<ul>\n<li>静态提升使得渲染函数更加简洁和高效，减少了不必要的代码重复和冗余。</li>\n</ul>\n</li>\n</ol>\n<h3>四、静态提升的示例</h3>\n<p>以下是一个简单的示例，展示了静态提升在实际应用中的效果：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>静态标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ 动态内容 }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;\n\n<span class="hljs-keyword">const</span> 动态内容 = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;这是动态内容&#x27;</span>);\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<p>在这个示例中，<code>&lt;h1&gt;静态标题&lt;/h1&gt;</code> 是一个静态节点，而 <code>&lt;p&gt;{{ 动态内容 }}&lt;/p&gt;</code> 是一个动态节点。在编译阶段，Vue 3 会将 <code>&lt;h1&gt;静态标题&lt;/h1&gt;</code> 提升为常量，并在渲染时直接复用。这样，在每次渲染时，Vue 3 只需要更新动态节点的内容，而无需重新创建静态节点的虚拟 DOM。</p>\n<h3>五、静态提升的注意事项</h3>\n<ol>\n<li><strong>静态节点的识别</strong>  ：\n<ul>\n<li>静态节点必须是在渲染过程中不会发生变化的部分。如果某个节点在渲染时可能会发生变化（例如通过 v-if、v-show 等指令控制其显示/隐藏），则它不能被视为静态节点。</li>\n</ul>\n</li>\n<li><strong>与动态节点的结合</strong>  ：\n<ul>\n<li>在实际应用中，静态节点和动态节点通常会结合在一起使用。Vue 3 的静态提升技术可以确保在渲染时只更新必要的部分，从而提高性能。</li>\n</ul>\n</li>\n<li><strong>编译选项</strong>  ：\n<ul>\n<li>静态提升是 Vue 3 编译器的一个默认优化选项。在大多数情况下，开发者无需手动配置即可享受其带来的性能提升。然而，在某些特殊情况下（例如需要调试或分析编译过程时），开发者可能需要关闭静态提升功能。</li>\n</ul>\n</li>\n</ol>\n</div>'</script></body></html>