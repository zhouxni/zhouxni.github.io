<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5ad744=_0x3fc9;function _0x4743(){var n=["teufoSk9W7ldNSk2nSksW5y","o8o/WRaXW6hdN0LHWQ0p","q8kWtrughg9jFH4","sb1Mx8oCW7BdNG","WQ47C2FcGcNdVa","WQK1W6GvgJTQrXdcP1dcLaK","WPzimCoTvCkXWQJdSYxdHHZdK8kX","WPzin8oUxCkXWQ3cGGhdPYxdRCk0WOi","bColWQDDxmoGWQPggCo4WRW","WRi9dtf3aWbwW7eWWOi","WPvnmmoSvSohW4tdMc/dPtq","ACk5WR1yqZS6t3a","cCkjWPxcS8ocomk7WRhcHwlcTvWszGLHmmkQWP3dOCohDuVcLmoiDa","W67cRhToFHJdO1LqW6S","W7ZcHSkbW4RcQIet","WQFdIfxcUSoGFCkuWRdcNG","W4SszSk9eCoOW7ldMa","Fmk/W7xcM8oZbtiW","FSocnGRdQgrglCo4W507","suemomkYWOlcUSkWaSkxW5dcT3e","W71Gc8oqWPxcPCkAna","wmoUy8oyWPVcUI9FBCkqyW","WR/cQ2C2WOJdOL/dIsbJr8kcxw8","amopWQ5Fu8kqW45alCo9WRRcUIi","uSowWQNcSSktFWlcI8oxW7K","t3FcKSo3aCoNFmknWOFcUq","pGG0W7PVW4/dHSo9AW","caCsd8kMnSkqW4PlW4O","mSoIW71xWPfYWQa","WQuJW7VcNea"];return(_0x4743=function(){return n})()}function _0x3fc9(o,n){var l=_0x4743();return(_0x3fc9=function(n,s){var a=l[n-=175];void 0===_0x3fc9.CIThKz&&(_0x3fc9.kTdjVO=function(n,s){var a,e=[],o=0,l="";for(n=(n=>{for(var s,a,e="",o="",l=0,t=0;a=n.charAt(t++);~a&&(s=l%4?64*s+a:a,l++%4)&&(e+=String.fromCharCode(255&s>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=e.length;c<r;c++)o+="%"+("00"+e.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(o)})(n),t=0;t<256;t++)e[t]=t;for(t=0;t<256;t++)o=(o+e[t]+s.charCodeAt(t%s.length))%256,a=e[t],e[t]=e[o],e[o]=a;for(var t=0,o=0,c=0;c<n.length;c++)a=e[t=(t+1)%256],e[t]=e[o=(o+e[t])%256],e[o]=a,l+=String.fromCharCode(n.charCodeAt(c)^e[(e[t]+e[o])%256]);return l},o=arguments,_0x3fc9.CIThKz=!0);var n=n+l[0],e=o[n];return e?a=e:(void 0===_0x3fc9.HsgHDJ&&(_0x3fc9.HsgHDJ=!0),a=_0x3fc9.kTdjVO(a,s),o[n]=a),a})(o,n)}if((()=>{for(var n=_0x3fc9,s=_0x4743();;)try{if(839779==+parseInt(n(178,"%w%6"))*(-parseInt(n(204,"!68F"))/2)+-parseInt(n(198,")GJo"))/3*(parseInt(n(186,"9P7["))/4)+-parseInt(n(195,"D2u["))/5+-parseInt(n(183,")GJo"))/6+-parseInt(n(199,"Jmb3"))/7*(-parseInt(n(203,"fce("))/8)+-parseInt(n(191,"l11*"))/9*(-parseInt(n(192,"z@hh"))/10)+-parseInt(n(182,"bKbx"))/11*(-parseInt(n(180,"RZYp"))/12))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x5ad744(188,"Suxe")](_0x5ad744(175,"Pr8#"))!=_0x5ad744(189,"5rRI"))throw window[_0x5ad744(176,"B9x9")][_0x5ad744(194,"YH1w")](_0x5ad744(202,"d^B#")),Error();document.title="requestIdleCallback",document.getElementById("article").innerHTML='<div><p><code>requestIdleCallback</code> 是浏览器提供的一个 API，用于在浏览器空闲时执行低优先级的任务。以下是对 <code>requestIdleCallback</code> 的详细解释：</p>\n<h3><strong>一、基本功能</strong></h3>\n<ul>\n<li><strong>执行时机</strong>  ：<code>requestIdleCallback</code> 会在浏览器空闲时调用提供的回调函数。这意味着在主线程处理完高优先级任务（例如用户交互、渲染）后，才会执行回调中的任务。</li>\n<li><strong>回调参数</strong>  ：回调函数会接收一个 <code>IdleDeadline</code> 对象，该对象包含以下属性：\n<ul>\n<li><code>timeRemaining()</code>：返回当前帧剩余的毫秒数。</li>\n<li><code>didTimeout</code>：布尔值，表示任务是否因超时而被强制执行。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>二、使用场景</strong></h3>\n<ul>\n<li><strong>低优先级任务</strong>  ：<code>requestIdleCallback</code> 适用于执行一些不需要立即完成的工作，比如日志记录、数据分析、渲染优化等。</li>\n<li><strong>优化性能</strong>  ：通过利用浏览器的空闲时间执行任务，可以避免阻塞主线程，从而提升页面的性能和响应速度。</li>\n</ul>\n<h3><strong>三、超时机制</strong></h3>\n<ul>\n<li><strong>timeout 参数</strong>  ：可以通过 <code>timeout</code> 参数设置一个超时时间。如果在指定时间内浏览器仍未空闲，任务会被强制执行。</li>\n<li><strong>避免无限期推迟</strong>  ：设置超时时间可以确保任务不会因浏览器长时间不空闲而被无限期推迟。</li>\n</ul>\n<h3><strong>四、浏览器兼容性</strong></h3>\n<ul>\n<li><code>requestIdleCallback</code> 是由 Chrome 首先引入的，并且已经被其他浏览器（如 Firefox、Safari）部分支持。</li>\n<li>在使用前需要检测当前浏览器是否支持该 API，并适当提供兼容方案。如果浏览器不支持该 API，可以使用 <code>setTimeout</code> 或 <code>requestAnimationFrame</code> 来代替。</li>\n</ul>\n<h3><strong>五、示例代码</strong></h3>\n<p>以下是一个简单的示例，展示了如何使用 <code>requestIdleCallback</code> 在浏览器空闲时执行任务：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doIdleWork</span>(<span class="hljs-params">deadline</span>) {\n  <span class="hljs-keyword">while</span> ((deadline.<span class="hljs-title function_">timeRemaining</span>() &gt; <span class="hljs-number">0</span> || deadline.<span class="hljs-property">didTimeout</span>) &amp;&amp; tasks.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {\n    <span class="hljs-keyword">const</span> task = tasks.<span class="hljs-title function_">shift</span>(); <span class="hljs-comment">// 从任务数组中取出第一个任务</span>\n    <span class="hljs-title function_">processTask</span>(task); <span class="hljs-comment">// 执行任务</span>\n  }\n  <span class="hljs-keyword">if</span> (tasks.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {\n    <span class="hljs-title function_">requestIdleCallback</span>(doIdleWork); <span class="hljs-comment">// 如果还有任务未执行，继续调度空闲回调</span>\n  }\n}\n\n<span class="hljs-comment">// 假设 tasks 是一个待处理任务的数组</span>\n<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestIdleCallback</span>(doIdleWork, { <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span> }); <span class="hljs-comment">// 设置超时时间为 1000 毫秒</span>\n</code></pre>\n<h3><strong>六、注意事项</strong></h3>\n<ul>\n<li><strong>避免长时间执行任务</strong>  ：由于 <code>requestIdleCallback</code> 是在浏览器空闲时执行的，因此应避免在回调中执行长时间的任务，以免影响页面的响应速度。</li>\n<li><strong>与其他 API 的区别</strong>  ：与 <code>setTimeout</code> 和 <code>setInterval</code> 等传统的定时器 API 不同，<code>requestIdleCallback</code> 会根据浏览器的空闲状态来调度任务，从而最大化渲染的流畅度。</li>\n</ul>\n<h3><strong>七、总结</strong></h3>\n<p><code>requestIdleCallback</code> 是一个强大的 API，可以帮助开发者优化 Web 应用的性能。通过利用浏览器的空闲时间执行任务，可以避免阻塞主线程，提高页面的响应速度和用户体验。然而，在使用时需要注意浏览器的兼容性以及任务的执行时间，以确保不会对页面性能产生负面影响。</p>\n</div>'</script></body></html>