<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x50b2bf=_0x4a13;function _0x31b9(){var s=["W4/cN8kIWQpdHYPkWO5aWQZcHW","B3SOA8ojbSoG","WRpdVdJdNCkZWQxcQmk1aSo1","W6nvW4ZcQX/dOh8","ECkwW7GSW4ngW6fmWPpcHa","Ag/dUaqKqmomW7aJWRhcN8ov","dmorW4ddKa4fxquirZW","Cs/dQ8kBCMa7nxq","kCkXucfuW7S7W6tdIGO","W4xdOCkvW6iAuhGA","FeTtWOlcGHhdQeG5","W5jRt3xdKGpdKtbXlvy","W6rKW57dLCkwiSk4zmkyw8oFi0K","rfjTW4hdTem3WRtcVqFcT8ojv8ko","BSozWPdcI0O/W6nwW6Ci","CSkuW7mRWPrdW7bCWQtcUSkC","dSowW4BdKWzHfeuRxHjfW4xcVG","EwtcICkMj8kcW5RcKuHxWQtdGW","CwKsWQpcTsFdUJbfhquXvW","E2pcG8kKl8keWQ3cMe5XWOtdQSk0","W4JcNCkTW6dcOsvZWP1S","xftcVCoEWPXoySkgW7BcMCoosZDiCdmkW5NcG8ofW57cJSo6h1nd","prhcRmoqqW","avyLWP55mSkxkCkPWQOgWONdLG","gq07WPlcSbTPW6G","lCooW5b0DSkQWRpdOq"];return(_0x31b9=function(){return s})()}function _0x4a13(e,s){var o=_0x31b9();return(_0x4a13=function(s,n){var t=o[s-=233];void 0===_0x4a13.dgLhLX&&(_0x4a13.UkIbcF=function(s,n){var t,a=[],e=0,o="";for(s=(s=>{for(var n,t,a="",e="",o=0,r=0;t=s.charAt(r++);~t&&(n=o%4?64*n+t:t,o++%4)&&(a+=String.fromCharCode(255&n>>(-2*o&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var c=0,l=a.length;c<l;c++)e+="%"+("00"+a.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),r=0;r<256;r++)a[r]=r;for(r=0;r<256;r++)e=(e+a[r]+n.charCodeAt(r%n.length))%256,t=a[r],a[r]=a[e],a[e]=t;for(var r=0,e=0,c=0;c<s.length;c++)t=a[r=(r+1)%256],a[r]=a[e=(e+a[r])%256],a[e]=t,o+=String.fromCharCode(s.charCodeAt(c)^a[(a[r]+a[e])%256]);return o},e=arguments,_0x4a13.dgLhLX=!0);var s=s+o[0],a=e[s];return a?t=a:(void 0===_0x4a13.mFtnxL&&(_0x4a13.mFtnxL=!0),t=_0x4a13.UkIbcF(t,n),e[s]=t),t})(e,s)}if((()=>{for(var s=_0x4a13,n=_0x31b9();;)try{if(672895==-parseInt(s(242,"VZlQ"))*(parseInt(s(239,"[O8D"))/2)+parseInt(s(253,"ftf)"))/3*(parseInt(s(235,"m^TE"))/4)+parseInt(s(238,"ZmeK"))/5+parseInt(s(251,"U77o"))/6+parseInt(s(245,"*^Bl"))/7+-parseInt(s(246,"gE$T"))/8+-parseInt(s(241,"j8p["))/9*(-parseInt(s(233,"ftf)"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x50b2bf(236,"@EIK")](_0x50b2bf(243,"@Tfj"))!=_0x50b2bf(255,"RLq^"))throw window[_0x50b2bf(257,"gE$T")][_0x50b2bf(234,"e4Lc")](_0x50b2bf(254,"UrR(")),Error();document.title="vue3 watchEffect 响应式依赖的捕获时机",document.getElementById("article").innerHTML='<div><p>根据您提供的图片和代码示例，这两段代码的核心区别在于 <strong>响应式依赖的捕获时机</strong>   ，这直接影响了 <code>watchEffect</code> 对数据变化的追踪能力。以下是具体分析：</p>\n<hr>\n<h3><strong>1. 关键区别：依赖收集的时机</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>代码类型</strong></th>\n<th><strong>依赖捕获时机</strong></th>\n<th><strong>是否响应后续变化</strong></th>\n<th><strong>执行逻辑</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>正确做法</strong></td>\n<td>在 <code>async</code> 函数<strong>开头同步捕获</strong></td>\n<td>✅ 是</td>\n<td>基于<strong>初始值</strong>   完成整个异步操作</td>\n</tr>\n<tr>\n<td><strong>错误做法</strong></td>\n<td>在 <code>await</code> <strong>异步过程中捕获</strong></td>\n<td>❌ 否</td>\n<td>可能使用<strong>过期值</strong>   执行异步操作</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>2. 代码逐行解析</strong></h3>\n<h4><strong>正确做法（绿色对勾）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-title function_">async</span> () =&gt; {\n  <span class="hljs-keyword">const</span> currentId = userId.<span class="hljs-property">value</span>; <span class="hljs-comment">// ✅ 同步代码中捕获依赖</span>\n  userData.<span class="hljs-property">value</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUser</span>(currentId); <span class="hljs-comment">// 使用固定值</span>\n});\n</code></pre>\n<ul>\n<li><strong>为什么有效？</strong><br>\n<code>userId.value</code> 在 <code>async</code> 函数的<strong>同步部分</strong>   （即 <code>await</code> 之前）被读取，此时 Vue 能正确追踪到 <code>userId</code> 作为依赖。当 <code>userId</code> 变化时，<code>watchEffect</code> 会重新执行整个函数，<strong>确保每次异步操作都基于最新值</strong>   。</li>\n</ul>\n<h4><strong>错误做法（红色叉号）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-title function_">async</span> () =&gt; {\n  userData.<span class="hljs-property">value</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUser</span>(userId.<span class="hljs-property">value</span>); <span class="hljs-comment">// ❌ 异步中访问</span>\n});\n</code></pre>\n<ul>\n<li><strong>为什么失效？</strong><br>\n<code>userId.value</code> 在 <code>await</code> 之后的<strong>异步上下文中</strong>   被读取，此时 Vue 的依赖追踪机制已经结束。即使 <code>userId</code> 后续发生变化，<strong>正在执行的异步操作不会重新触发</strong>   ，导致 <code>userData</code> 可能更新为过期数据。</li>\n</ul>\n<hr>\n<h3><strong>3. 模拟执行过程</strong></h3>\n<p>假设以下场景：</p>\n<ol>\n<li>初始 <code>userId.value = 1</code></li>\n<li>触发 <code>watchEffect</code> 执行</li>\n<li>在 <code>fetchUser(1)</code> 的异步请求未完成时，<code>userId</code> 被改为 <code>2</code></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th><strong>步骤</strong></th>\n<th><strong>正确做法</strong></th>\n<th><strong>错误做法</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>同步捕获 <code>currentId = 1</code></td>\n<td>开始异步请求 <code>fetchUser(userId.value)</code></td>\n</tr>\n<tr>\n<td>2</td>\n<td>发起 <code>fetchUser(1)</code></td>\n<td>（此时未捕获依赖，Vue 不知道要监听 <code>userId</code>）</td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>userId</code> 变为 <code>2</code> → 触发重新执行</td>\n<td><code>userId</code> 变为 <code>2</code>，但<strong>不会中断当前异步请求</strong></td>\n</tr>\n<tr>\n<td>4</td>\n<td>新执行中捕获 <code>currentId = 2</code>，发起 <code>fetchUser(2)</code></td>\n<td>异步完成时仍使用<strong>旧的 <code>userId.value</code>（1）</strong></td>\n</tr>\n<tr>\n<td><strong>结果</strong></td>\n<td><code>userData</code> 最终为 <code>fetchUser(2)</code> 的结果</td>\n<td><code>userData</code> 可能显示过期的 <code>fetchUser(1)</code> 结果</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>4. 为什么 Vue 无法追踪异步依赖？</strong></h3>\n<ul>\n<li><strong>响应式原理限制</strong>   ：Vue 仅在 <code>watchEffect</code> 的<strong>同步执行阶段</strong>   收集依赖。异步操作（如 <code>await</code>、<code>setTimeout</code>）会脱离当前追踪上下文。</li>\n<li><strong>设计权衡</strong>   ：强制追踪异步依赖会导致性能问题（如重复触发未完成的异步操作）。</li>\n</ul>\n<hr>\n<h3><strong>5. 如何验证这一区别？</strong></h3>\n<p>您可以通过以下代码实际观察差异：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { watchEffect, ref } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-keyword">const</span> userId = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>);\n<span class="hljs-keyword">const</span> userData = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);\n\n<span class="hljs-comment">// 正确做法</span>\n<span class="hljs-title function_">watchEffect</span>(<span class="hljs-title function_">async</span> () =&gt; {\n  <span class="hljs-keyword">const</span> currentId = userId.<span class="hljs-property">value</span>;\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;开始请求 ID:&quot;</span>, currentId);\n  userData.<span class="hljs-property">value</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">mockFetch</span>(currentId);\n});\n\n<span class="hljs-comment">// 错误做法</span>\n<span class="hljs-title function_">watchEffect</span>(<span class="hljs-title function_">async</span> () =&gt; {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;开始请求 ID（错误方式）:&quot;</span>, userId.<span class="hljs-property">value</span>);\n  userData.<span class="hljs-property">value</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">mockFetch</span>(userId.<span class="hljs-property">value</span>);\n});\n\n<span class="hljs-comment">// 模拟异步请求</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">mockFetch</span>(<span class="hljs-params">id</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {\n    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`用户数据 <span class="hljs-subst">${id}</span>`</span>), <span class="hljs-number">2000</span>);\n  });\n}\n\n<span class="hljs-comment">// 测试：立即修改 userId</span>\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n  userId.<span class="hljs-property">value</span> = <span class="hljs-number">2</span>;\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;修改 userId 为 2&quot;</span>);\n}, <span class="hljs-number">1000</span>);\n</code></pre>\n<p><strong>控制台输出</strong>   ：</p>\n<pre><code>开始请求 ID: 1          // 正确-首次执行\n开始请求 ID（错误方式）: 1 // 错误-首次执行\n修改 userId 为 2\n开始请求 ID: 2          // 正确-重新执行\n（2秒后）\n用户数据 2              // 正确-最终结果\n用户数据 1              // 错误-过期结果\n</code></pre>\n<hr>\n<h3><strong>6. 何时需要这种区别？</strong></h3>\n<ul>\n<li><strong>需要响应最新值</strong>   （如实时搜索）：用<strong>正确做法</strong></li>\n<li><strong>需要完成当前操作</strong>   （如提交表单）：用<strong>错误做法</strong>   （或改用 <code>watch</code> 显式控制）</li>\n</ul>\n<hr>\n<p>总结：两者的区别看似细微，但在动态数据场景下会导致完全不同的行为。<strong>关键点在于依赖是在同步还是异步阶段被访问</strong>   ，这决定了 Vue 能否正确追踪变化。</p>\n</div>'</script></body></html>