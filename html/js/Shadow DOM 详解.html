<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x9976de=_0xa04b;function _0x2552(){var s=["h8ktWQ7dLeddKJroma","iSoVnLZdIKxcQguCamozmmkD","dmo3bSoFo8kBW7GOhH8EWQFdJW","WR8mW5JdU8olj8kXWOebW6hcKG5P","CSk2W4u+W7pdJCk6lCk5k8o3C8oxbw5cW6JdG8kEW6pcTX4VW64yWOu","WOVcKvXlkIJdOSoZW4BcJs5CW6ddSa","cxyfW6etW6XE","WPFdTIBdHr7cOHhcPq","r8kbW4tdL8kBWRCo","W57dJGHLzSokWRNcM8kotH8yCc0","WRxcHKFdQcv0a8kazGXRW5JdMa","iSoQnvVdI0NdNe8ckmoOpW","lCo6WORcOHGdW79twCoBWQldQ8k7","jZKgW4nsW60+CSkX","WQbNBSkmgcFdLW/dLYRdRmoi","WONcM1vilINdP8kbW47cVZv6W6i","sIDbWRXbWRWddc8nWPBcJeK","jZGaWPqYWPe4tSkvWOlcH8oF","WO3cMfLnkYJcMSkpW7pcMtnf","A8ohW73cGGhcLKDYomkMsM1d","wMtdOHSX","bMHlg8oRW7qXWP57"];return(_0x2552=function(){return s})()}function _0xa04b(l,s){var e=_0x2552();return(_0xa04b=function(s,n){var a=e[s-=462];void 0===_0xa04b.Tissku&&(_0xa04b.gJYSjM=function(s,n){var a,t=[],l=0,e="";for(s=(s=>{for(var n,a,t="",l="",e=0,o=0;a=s.charAt(o++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,c=t.length;p<c;p++)l+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(l)})(s),o=0;o<256;o++)t[o]=o;for(o=0;o<256;o++)l=(l+t[o]+n.charCodeAt(o%n.length))%256,a=t[o],t[o]=t[l],t[l]=a;for(var o=0,l=0,p=0;p<s.length;p++)a=t[o=(o+1)%256],t[o]=t[l=(l+t[o])%256],t[l]=a,e+=String.fromCharCode(s.charCodeAt(p)^t[(t[o]+t[l])%256]);return e},l=arguments,_0xa04b.Tissku=!0);var s=s+e[0],t=l[s];return t?a=t:(void 0===_0xa04b.vXUtIG&&(_0xa04b.vXUtIG=!0),a=_0xa04b.gJYSjM(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0xa04b,n=_0x2552();;)try{if(647697==+parseInt(s(477,"ad1a"))+parseInt(s(464,"3HqO"))/2+parseInt(s(478,"[M1R"))/3+parseInt(s(480,"S)ju"))/4*(parseInt(s(462,"*S!g"))/5)+parseInt(s(475,"1bf7"))/6+-parseInt(s(482,"^e07"))/7+-parseInt(s(472,"#Kjg"))/8)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x9976de(471,"sqJM")](_0x9976de(463,"^e07"))!=_0x9976de(483,"kl8e"))throw window[_0x9976de(470,"M5@Y")][_0x9976de(469,"AG2s")](_0x9976de(467,"i$Qy")),Error();document.title="Shadow DOM 详解",document.getElementById("article").innerHTML='<div><p>好的，我们来彻底详解 <strong>Shadow DOM</strong>   。这是 Web Components 技术套件中最核心、最强大的特性，它解决了 Web 开发中的长期痛点：<strong>样式和 DOM 的封装与隔离</strong>   。</p>\n<hr>\n<h2><strong>一、什么是 Shadow DOM？</strong></h2>\n<p><strong>Shadow DOM（影子 DOM）</strong>   是一个<strong>附加到常规 DOM 元素的、独立的、隔离的 DOM 树</strong>   。你可以将其想象成一个“DOM 中的 DOM”，它拥有自己的样式作用域和 DOM 结构，与主文档分离开来。</p>\n<p><strong>关键比喻</strong>   ：</p>\n<ul>\n<li><strong>Light DOM（光明 DOM）</strong>   ： 用户编写的、在自定义标签内部的普通 DOM。这是组件的“内容”。<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">fancy-button</span>&gt;</span>\n  <span class="hljs-comment">&lt;!-- 这里的 &lt;span&gt; 就是 Light DOM --&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Click Me!<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">fancy-button</span>&gt;</span>\n</code></pre>\n</li>\n<li><strong>Shadow DOM</strong>   ： 组件作者编写的、实现组件内部结构的 DOM。这是组件的“实现”。<pre><code class="language-html">#shadow-root\n<span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>\n  <span class="hljs-comment">&lt;!-- Light DOM 的内容会在这里渲染 --&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n</code></pre>\n</li>\n<li><strong>Flattened DOM（扁平化 DOM）</strong>   ： 浏览器将 Light DOM 和 Shadow DOM 组合在一起后，最终渲染出来的结果。<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">fancy-button</span>&gt;</span>\n  #shadow-root\n  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>\n      ↳ <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Click Me!<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n      <span class="hljs-comment">&lt;!-- Slot 投射的内容 --&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Click Me!<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">fancy-button</span>&gt;</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h2><strong>二、核心特性与优势</strong></h2>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">特性</th>\n<th style="text-align:left">说明</th>\n<th style="text-align:left">解决的问题</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>样式封装（Scoped CSS）</strong></td>\n<td style="text-align:left">Shadow DOM 内部的样式不会泄漏到外部，外部的样式也不会渗透到内部（除继承属性）。</td>\n<td style="text-align:left">全局样式污染，CSS 命名冲突。</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>DOM 封装</strong></td>\n<td style="text-align:left">外部 JavaScript 无法通过 <code>document.querySelector</code> 直接访问到 Shadow DOM 内部的元素。</td>\n<td style="text-align:left">DOM 结构被意外修改或访问。</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>组件化</strong></td>\n<td style="text-align:left">将标记结构、样式和行为隐藏在一个独立的元素内，创建真正的可重用组件。</td>\n<td style="text-align:left">构建高内聚、低耦合的组件。</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>三、如何创建 Shadow DOM</strong></h2>\n<p>使用 <code>Element.attachShadow()</code> 方法将一个 Shadow Root 附加到任何元素上。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 1. 选择一个宿主元素（Host Element）</span>\n<span class="hljs-keyword">const</span> hostElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;host&quot;</span>);\n\n<span class="hljs-comment">// 2. 附加 Shadow Root</span>\n<span class="hljs-keyword">const</span> shadowRoot = hostElement.<span class="hljs-title function_">attachShadow</span>({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;open&quot;</span> }); <span class="hljs-comment">// 或 &#x27;closed&#x27;</span>\n\n<span class="hljs-comment">// 3. 向 Shadow Root 添加内容（就像操作普通 DOM 一样）</span>\nshadowRoot.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`\n  &lt;style&gt;\n    p { color: red; } /* 这个样式只在这个 Shadow DOM 内有效 */\n  &lt;/style&gt;\n  &lt;p&gt;我是封装在 Shadow DOM 里的内容！&lt;/p&gt;\n`</span>;\n</code></pre>\n<h3><strong><code>mode</code> 选项：<code>open</code> vs <code>closed</code></strong></h3>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">模式</th>\n<th style="text-align:left">访问方式</th>\n<th style="text-align:left">用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong><code>open</code></strong></td>\n<td style="text-align:left"><code>element.shadowRoot</code></td>\n<td style="text-align:left">允许外部 JS 通过 <code>hostElement.shadowRoot</code> 访问影子根。<strong>（常用）</strong></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong><code>closed</code></strong></td>\n<td style="text-align:left"><code>null</code></td>\n<td style="text-align:left">不允许外部访问，<code>hostElement.shadowRoot</code> 返回 <code>null</code>。只能在构造函数中保存的引用访问。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例：</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// open mode</span>\n<span class="hljs-keyword">const</span> openShadow = hostElement.<span class="hljs-title function_">attachShadow</span>({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;open&quot;</span> });\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hostElement.<span class="hljs-property">shadowRoot</span> === openShadow); <span class="hljs-comment">// true</span>\n\n<span class="hljs-comment">// closed mode</span>\n<span class="hljs-keyword">const</span> closedShadow = hostElement.<span class="hljs-title function_">attachShadow</span>({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;closed&quot;</span> });\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hostElement.<span class="hljs-property">shadowRoot</span>); <span class="hljs-comment">// null</span>\n<span class="hljs-comment">// 只能在类内部通过 saved reference 访问，例如 this._shadowRoot</span>\n</code></pre>\n<hr>\n<h2><strong>四、组合与插槽 (<code>&lt;slot&gt;</code>)</strong></h2>\n<p>Shadow DOM 使用 <strong><code>&lt;slot&gt;</code></strong>   元素来显示 Light DOM 的内容，实现内容分发。</p>\n<h3><strong>1. 默认插槽</strong></h3>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 组件实现 (Shadow DOM) --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">\n  class MyComponent extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: &quot;open&quot; }).innerHTML = `\n        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>\n          <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>组件标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>\n          <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span> <span class="hljs-comment">&lt;!-- 用户的内容将在这里显示 --&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n      `;\n    }\n  }\n  customElements.define(&quot;my-component&quot;, MyComponent);\n</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n\n<span class="hljs-comment">&lt;!-- 组件使用 (Light DOM) --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">my-component</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是用户提供的内容，它会投射到 slot 的位置。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span>\n</code></pre>\n<h3><strong>2. 命名插槽 (Named Slots)</strong></h3>\n<p>允许将不同的内容投射到不同的位置。</p>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- Shadow DOM 模板 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\n<span class="hljs-comment">&lt;!-- Light DOM 使用 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">my-component</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span>头部标题<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span>主体内容...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span>底部信息<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span>\n</code></pre>\n<hr>\n<h2><strong>五、样式封装详解</strong></h2>\n<h3><strong>1. 样式隔离</strong></h3>\n<ul>\n<li><strong>外部样式进不来</strong>   ：主文档的 CSS 选择器无法选择到 Shadow DOM 内部的元素（例如 <code>#host p { }</code> 无效）。</li>\n<li><strong>内部样式出不去</strong>   ：Shadow DOM 内定义的样式只会作用于其内部，不会影响外部元素。</li>\n<li><strong>可继承属性能进来</strong>   ：如 <code>color</code>, <code>font-family</code>, <code>line-height</code> 等属性会从宿主元素继承到 Shadow DOM 中。</li>\n</ul>\n<h3><strong>2. 特殊选择器</strong></h3>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">选择器</th>\n<th style="text-align:left">作用</th>\n<th style="text-align:left">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong><code>:host</code></strong></td>\n<td style="text-align:left">选择<strong>宿主元素</strong>   本身。</td>\n<td style="text-align:left"><code>:host { display: block; }</code></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong><code>:host(selector)</code></strong></td>\n<td style="text-align:left">选择宿主元素，但仅在它匹配 <code>selector</code> 时生效。</td>\n<td style="text-align:left"><code>:host(.active) { border: 1px solid blue; }</code></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong><code>:host-context(selector)</code></strong></td>\n<td style="text-align:left">选择宿主元素，但仅当其或其任意祖先元素匹配 <code>selector</code> 时生效。</td>\n<td style="text-align:left"><code>:host-context(.dark-theme) { background: black; }</code></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong><code>::slotted()</code></strong></td>\n<td style="text-align:left">选择<strong>已经被投射到插槽中的 Light DOM 元素</strong>   。</td>\n<td style="text-align:left"><code>::slotted(p) { color: green; }</code></td>\n</tr>\n</tbody>\n</table>\n<p><strong>示例：</strong></p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">\n  <span class="hljs-comment">/* 在 Shadow DOM 内部定义的样式 */</span>\n  <span class="hljs-selector-pseudo">:host</span> {\n    <span class="hljs-attribute">display</span>: block; <span class="hljs-comment">/* 设置宿主元素的默认显示方式 */</span>\n  }\n  <span class="hljs-selector-pseudo">:host</span>(<span class="hljs-selector-class">.highlight</span>) {\n    <span class="hljs-attribute">background-color</span>: yellow; <span class="hljs-comment">/* 当宿主有 .highlight 类时应用 */</span>\n  }\n  <span class="hljs-selector-pseudo">::slotted</span>(<span class="hljs-selector-tag">img</span>) {\n    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; <span class="hljs-comment">/* 对所有投射到任何插槽的 img 元素应用样式 */</span>\n  }\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>\n</code></pre>\n<hr>\n<h2><strong>六、JavaScript 与事件</strong></h2>\n<h3><strong>1. 事件重定向 (Event Retargeting)</strong></h3>\n<p>为了保持 Shadow DOM 的封装性，事件在穿过 Shadow DOM 的边界时，其 <code>event.target</code> 会被<strong>重定向</strong>   为宿主元素，而不是 Shadow DOM 内部的实际目标元素。</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;host&quot;</span>&gt;</span>\n  #shadow-root\n  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;internal-btn&quot;</span>&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;host&quot;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">target</span>); <span class="hljs-comment">// 输出 &lt;my-component&gt;，而不是 &lt;button&gt;</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-title function_">composedPath</span>()); <span class="hljs-comment">// 使用这个属性可以获取事件触发的真实路径</span>\n    <span class="hljs-comment">// [button#internal-btn, shadow-root, my-component#host, body, html, document, Window]</span>\n  });\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<h3><strong>2. <code>composed</code> 属性</strong></h3>\n<p>如果希望事件穿透 Shadow DOM 边界，在外部也能以真实目标被捕获，需要在初始化事件时设置 <code>composed: true</code>。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在 Shadow DOM 内部的元素上触发事件</span>\n<span class="hljs-keyword">const</span> internalEvent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomEvent</span>(<span class="hljs-string">&quot;myevent&quot;</span>, {\n  <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 事件冒泡</span>\n  <span class="hljs-attr">composed</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 允许事件穿过 Shadow DOM 边界</span>\n});\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">shadowRoot</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;internal-btn&quot;</span>).<span class="hljs-title function_">dispatchEvent</span>(internalEvent);\n</code></pre>\n<hr>\n<h2><strong>七、最佳实践与注意事项</strong></h2>\n<ol>\n<li>\n<p><strong>并非所有元素都支持附加 Shadow DOM</strong>   。例如，<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code> 等浏览器内置的可替换元素不支持，会抛出错误。通常附加到简单的容器元素如 <code>&lt;div&gt;</code>、<code>&lt;span&gt;</code> 或自定义元素上。</p>\n</li>\n<li>\n<p><strong>一个元素只能有一个 Shadow Root</strong>   。多次调用 <code>attachShadow()</code> 会报错。</p>\n</li>\n<li>\n<p><strong>谨慎使用 <code>closed</code> 模式</strong>   。它提供的“安全”是脆弱的，并且会使测试和调试变得困难。<code>open</code> 模式适用于大多数场景。</p>\n</li>\n<li>\n<p><strong>CSS 变量可以穿透</strong>   。利用 CSS 自定义属性（变量）可以从外部为 Shadow DOM 设置主题。</p>\n<pre><code class="language-css"><span class="hljs-comment">/* 主文档 */</span>\n<span class="hljs-selector-pseudo">:root</span> {\n  <span class="hljs-attr">--primary-color</span>: blue;\n}\n</code></pre>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- Shadow DOM --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">\n  <span class="hljs-selector-tag">button</span> {\n    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--primary-color, gray); <span class="hljs-comment">/* 使用外部变量 */</span>\n  }\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>\n</code></pre>\n</li>\n<li>\n<p><strong>Part 属性（实验性）</strong>   ： 使用 <code>::part()</code> 选择器允许从外部有选择地设置 Shadow DOM 内部元素的样式。</p>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- Shadow DOM 内部 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">part</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n\n<span class="hljs-comment">&lt;!-- 主文档 CSS --&gt;</span>\nmy-component::part(btn) { border: 2px solid black; }\n</code></pre>\n</li>\n</ol>\n<hr>\n<h2><strong>总结</strong></h2>\n<p><strong>Shadow DOM 是现代 Web 组件化的基石</strong>   。它通过原生的浏览器支持，提供了强大的样式和 DOM 封装能力，使你能够构建真正独立、可重用且不会相互干扰的组件。</p>\n<ul>\n<li><strong>用途</strong>   ：构建可重用的 Web Components、第三方小组件库、复杂应用的模块化。</li>\n<li><strong>核心</strong>   ：<code>attachShadow()</code>、<code>&lt;slot&gt;</code>、<code>:host</code>、样式封装。</li>\n<li><strong>目标</strong>   ：<strong>一次编写，随处运行</strong>   ，无需担心环境冲突。</li>\n</ul>\n</div>'</script></body></html>