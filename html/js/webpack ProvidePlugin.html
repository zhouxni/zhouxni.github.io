<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x327b58=_0x44cf;function _0x585d(){var s=["WPRdOb3cL8onWPb+dq","WOupiqqIBCkIW6VcKmkBWOuc","WOyoWRBcSCo3dhC","qdzEzSovWRSN","W6XZWQ/dJCouoSoKW5HOW4v7WPW","E8kpWPZcPmoNW7RdVYW","W5vzW7xcVmosk2/cH8oS","W6jMW41FWRNdKCkhsSo+gL7dGSk7","W5moowlcVWNcVru","bw/cVCk7WPFcGmkTCIy","cSoUWPTgWQpdSezZWR7dMCkmWQm","FWmRWQBdQmoVbvuqmtG2BG","WP7dOvVdRSkxWOv5b37dMCkE","p17cUvSUDZldLu3dOvKe","jSoqW43dTSkIWQxcQhiTW77cQSk6fcK","WQSIWOKBW7u","WRPGWPnfiCkFstBdLCo4W7/cUG","WPevqSo7WRFcNf3dH8kP","n17cUvKUDKxdKeddNfSdWRq","fcpdHHrrWQC4imk2wCkRW7W","WQWvbSodWRSLW5vyWQG6sftdKdNcRmkBzSo6nCozrqudhCoNFG","zSkMw8oxWOrxjqZdKmoRcCkGWONdJG","WRTIW5irqmoFAsK","W5ntW7FdJCk6wYJcP8oOW5VcGmkrW7O","wGNdH0BdTvazWPtdK2xdRG","zCkMg8kgW6ezA00"];return(_0x585d=function(){return s})()}function _0x44cf(l,s){var e=_0x585d();return(_0x44cf=function(s,n){var a=e[s-=281];void 0===_0x44cf.jjyezQ&&(_0x44cf.jPofng=function(s,n){var a,o=[],l=0,e="";for(s=(s=>{for(var n,a,o="",l="",e=0,r=0;a=s.charAt(r++);~a&&(n=e%4?64*n+a:a,e++%4)&&(o+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,t=o.length;c<t;c++)l+="%"+("00"+o.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),r=0;r<256;r++)o[r]=r;for(r=0;r<256;r++)l=(l+o[r]+n.charCodeAt(r%n.length))%256,a=o[r],o[r]=o[l],o[l]=a;for(var r=0,l=0,c=0;c<s.length;c++)a=o[r=(r+1)%256],o[r]=o[l=(l+o[r])%256],o[l]=a,e+=String.fromCharCode(s.charCodeAt(c)^o[(o[r]+o[l])%256]);return e},l=arguments,_0x44cf.jjyezQ=!0);var s=s+e[0],o=l[s];return o?a=o:(void 0===_0x44cf.wPZrPT&&(_0x44cf.wPZrPT=!0),a=_0x44cf.jPofng(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x44cf,n=_0x585d();;)try{if(524628==-parseInt(s(284,"t@%9"))+parseInt(s(305,"nMCg"))/2*(parseInt(s(281,"fHJG"))/3)+-parseInt(s(301,"FZa["))/4*(-parseInt(s(293,"JnmZ"))/5)+-parseInt(s(282,"BZJE"))/6+parseInt(s(288,"@]5e"))/7*(-parseInt(s(295,"aVg("))/8)+-parseInt(s(289,"t@%9"))/9+parseInt(s(285,"]cbX"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x327b58(299,"4ZWV")](_0x327b58(306,"lyVU"))!=_0x327b58(286,"afZ]"))throw window[_0x327b58(302,"]cbX")][_0x327b58(300,"%)os")](_0x327b58(291,"w&P*")),Error();document.title="webpack ProvidePlugin",document.getElementById("article").innerHTML='<div><p><code>webpack.ProvidePlugin</code> 是 Webpack 中的一个插件，用于在模块中自动注入某些全局变量或模块，而无需显式地通过 <code>import</code> 或 <code>require</code> 引入。这在处理一些非模块化的全局库（如 jQuery、lodash 等）时特别有用，可以简化代码，提高可读性。</p>\n<hr>\n<h3><strong>1. 基本原理</strong></h3>\n<p><code>ProvidePlugin</code> 的工作原理是：</p>\n<ul>\n<li><strong>自动注入</strong>  ：当 Webpack 打包时，它会自动在需要的模块中注入指定的全局变量或模块。</li>\n<li><strong>避免重复</strong>  ：如果某个模块已经通过 <code>import</code> 或 <code>require</code> 引入了指定的模块，<code>ProvidePlugin</code> 不会重复注入。</li>\n</ul>\n<hr>\n<h3><strong>2. 使用场景</strong></h3>\n<ul>\n<li><strong>全局库</strong>  ：如 jQuery、lodash 等，这些库通常通过全局变量暴露功能。</li>\n<li><strong>简化代码</strong>  ：避免在每个模块中重复 <code>import</code> 或 <code>require</code> 常用的库。</li>\n<li><strong>兼容性</strong>  ：处理一些老旧的代码库，这些代码库可能依赖于全局变量。</li>\n</ul>\n<hr>\n<h3><strong>3. 配置方法</strong></h3>\n<h4><strong>基本配置</strong></h4>\n<p>在 <code>webpack.config.js</code> 中配置 <code>ProvidePlugin</code>：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-comment">// ...其他配置</span>\n  <span class="hljs-attr">plugins</span>: [\n    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">ProvidePlugin</span>({\n      <span class="hljs-attr">$</span>: <span class="hljs-string">&#x27;jquery&#x27;</span>, <span class="hljs-comment">// 自动注入 $ 为 jquery</span>\n      <span class="hljs-attr">jQuery</span>: <span class="hljs-string">&#x27;jquery&#x27;</span>, <span class="hljs-comment">// 自动注入 jQuery 为 jquery</span>\n      <span class="hljs-attr">_</span>: <span class="hljs-string">&#x27;lodash&#x27;</span>, <span class="hljs-comment">// 自动注入 _ 为 lodash</span>\n    }),\n  ],\n};\n</code></pre>\n<h4><strong>解释</strong></h4>\n<ul>\n<li><strong>键</strong>  ：表示要在模块中注入的全局变量名。</li>\n<li><strong>值</strong>  ：表示要注入的模块名或路径。</li>\n</ul>\n<hr>\n<h3><strong>4. 示例</strong></h3>\n<h4><strong>项目结构</strong></h4>\n<pre><code>my-webpack-project/\n├── dist/\n│   └── bundle.js\n├── src/\n│   ├── index.js\n│   └── utils.js\n├── webpack.config.js\n└── package.json\n</code></pre>\n<h4><strong><code>webpack.config.js</code></strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);\n<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,\n  <span class="hljs-attr">output</span>: {\n    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,\n    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),\n  },\n  <span class="hljs-attr">plugins</span>: [\n    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">ProvidePlugin</span>({\n      <span class="hljs-attr">$</span>: <span class="hljs-string">&#x27;jquery&#x27;</span>,\n      <span class="hljs-attr">jQuery</span>: <span class="hljs-string">&#x27;jquery&#x27;</span>,\n      <span class="hljs-attr">_</span>: <span class="hljs-string">&#x27;lodash&#x27;</span>,\n    }),\n  ],\n};\n</code></pre>\n<h4><strong><code>src/index.js</code></strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 可以直接使用 $ 和 _，而无需 import</span>\n$(<span class="hljs-variable language_">document</span>).<span class="hljs-title function_">ready</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;jQuery is ready!&#x27;</span>);\n});\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_.<span class="hljs-title function_">join</span>([<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;webpack&#x27;</span>], <span class="hljs-string">&#x27; &#x27;</span>));\n</code></pre>\n<h4><strong><code>src/utils.js</code></strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 同样可以直接使用 $ 和 _</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($(<span class="hljs-string">&#x27;body&#x27;</span>).<span class="hljs-title function_">text</span>());\n}\n</code></pre>\n<hr>\n<h3><strong>5. 注意事项</strong></h3>\n<ul>\n<li><strong>模块可用性</strong>  ：确保在 <code>ProvidePlugin</code> 中指定的模块已经通过 <code>npm install</code> 或其他方式安装，并且可以在 Webpack 的解析路径中找到。</li>\n<li><strong>避免冲突</strong>  ：如果模块中已经通过 <code>import</code> 或 <code>require</code> 引入了相同的模块，<code>ProvidePlugin</code> 不会覆盖这些引入。</li>\n<li><strong>性能考虑</strong>  ：虽然 <code>ProvidePlugin</code> 可以简化代码，但过度使用可能导致不必要的模块被注入，增加打包体积。</li>\n</ul>\n<hr>\n<h3><strong>6. 与 <code>externals</code> 的区别</strong></h3>\n<ul>\n<li><strong><code>ProvidePlugin</code></strong>  ：用于在打包过程中自动注入模块，模块仍然会被打包到最终的 bundle 中。</li>\n<li><strong><code>externals</code></strong>  ：用于将模块标记为外部依赖，模块不会被打包到 bundle 中，而是期望在运行时通过 <code>&lt;script&gt;</code> 标签从外部引入。</li>\n</ul>\n<hr>\n<h3><strong>7. 实际应用中的建议</strong></h3>\n<ul>\n<li><strong>适度使用</strong>  ：<code>ProvidePlugin</code> 适合处理一些全局库或常用工具库，但不建议滥用。</li>\n<li><strong>明确依赖</strong>  ：对于核心模块或业务逻辑相关的依赖，建议显式地通过 <code>import</code> 或 <code>require</code> 引入，以提高代码的可读性和可维护性。</li>\n<li><strong>结合其他插件</strong>  ：<code>ProvidePlugin</code> 可以与其他 Webpack 插件结合使用，如 <code>DefinePlugin</code>、<code>HtmlWebpackPlugin</code> 等，以实现更复杂的打包需求。</li>\n</ul>\n<hr>\n<h3><strong>8. 总结</strong></h3>\n<ul>\n<li><strong><code>ProvidePlugin</code></strong>   是 Webpack 中用于自动注入全局变量或模块的插件。</li>\n<li><strong>简化代码</strong>  ：通过自动注入，避免在每个模块中重复引入常用库。</li>\n<li><strong>配置简单</strong>  ：在 <code>webpack.config.js</code> 中通过 <code>plugins</code> 数组配置。</li>\n<li><strong>适度使用</strong>  ：避免过度使用导致不必要的模块注入和打包体积增加。</li>\n</ul>\n<p>通过合理使用 <code>ProvidePlugin</code>，可以简化 Webpack 项目的代码结构，提高开发效率。</p>\n</div>'</script></body></html>