<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x36fe23=_0x2685;function _0x3b7e(){var s=["WRHCAGldPCkVrmkaWOiKrSoo","WRXrdK3cQCodDSkH","FSkCj8kmAq5IW5VcPCoswtlcUa","mSo7WP8Jw2XvWRiUB8ouya","j1fTWOCMWReVWO5ljt7dOW","pmouW7KGgmoSW7qb","suxcIvxcU8kroq","kNZdHLNcISk2hfLZe8kv","DeBdO0TLW4ldRCk6fq","tSocumkjjW","r0ldUCojWPCyr8ovW5btW5DBW7y","q0tdUCoaWPiFiCoCW6rpW7rM","WRu9W7uKlSk0WQlcMt4aCNpdQG","WOZdSHO1WOZcHKaSw8oqag3cVG","BwNcJ0NdJr1lef1v","u8kNWONcJGJcTtKpW4rCW4Oj","r0TxWPBdLsuqWOm","c8kNW6KgW6XvW5NdMxRcUCo9W6O","bhtdUeftW5NdLq","WPFdN0eYWRGiDwzZW4C","WQFcOsukW5uzW7O","W5SwWPZdGCktDYPhW5LkWRlcUq","WOTVWQ07ESo8WPZcMxxcUCkxWQBdIw7cImk1C1pdJCoSWPBcV8k1DSkbxW","W4ddV8kou8k4WRdcPby8WPVdItG","cmoLW6xdLX3cUmkz","W7xcSSo9WQH2W5hdTCkUpWua","rcRdICkkWRDyarG","cmkeW47dIbdcPmkHiW"];return(_0x3b7e=function(){return s})()}function _0x2685(p,s){var e=_0x3b7e();return(_0x2685=function(s,a){var n=e[s-=156];void 0===_0x2685.aFUuts&&(_0x2685.UzynJB=function(s,a){var n,l=[],p=0,e="";for(s=(s=>{for(var a,n,l="",p="",e=0,t=0;n=s.charAt(t++);~n&&(a=e%4?64*a+n:n,e++%4)&&(l+=String.fromCharCode(255&a>>(-2*e&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,r=l.length;c<r;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)p=(p+l[t]+a.charCodeAt(t%a.length))%256,n=l[t],l[t]=l[p],l[p]=n;for(var t=0,p=0,c=0;c<s.length;c++)n=l[t=(t+1)%256],l[t]=l[p=(p+l[t])%256],l[p]=n,e+=String.fromCharCode(s.charCodeAt(c)^l[(l[t]+l[p])%256]);return e},p=arguments,_0x2685.aFUuts=!0);var s=s+e[0],l=p[s];return l?n=l:(void 0===_0x2685.WvBTgm&&(_0x2685.WvBTgm=!0),n=_0x2685.UzynJB(n,a),p[s]=n),n})(p,s)}if((()=>{for(var s=_0x2685,a=_0x3b7e();;)try{if(494154==-parseInt(s(174,"M]V("))*(-parseInt(s(178,"Cr^&"))/2)+-parseInt(s(171,"!n(m"))/3*(parseInt(s(179,"Cr^&"))/4)+-parseInt(s(182,"pR)%"))/5+-parseInt(s(157,"[X6@"))/6*(-parseInt(s(164,"3%Tb"))/7)+-parseInt(s(180,"Vt&)"))/8+parseInt(s(163,"kS8e"))/9+-parseInt(s(177,"M]V("))/10*(-parseInt(s(173,"Haq^"))/11))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x36fe23(156,"*ynG")](_0x36fe23(158,"]YB*"))!=_0x36fe23(159,"B#]E"))throw window[_0x36fe23(176,"gxn^")][_0x36fe23(170,"IkPx")](_0x36fe23(172,"w!T2")),Error();document.title="强制 Webpack 动态调用依赖原项目 node_modules 的完整方案",document.getElementById("article").innerHTML='<div><p>当需要确保动态调用的 Webpack 配置中的 loader 和 plugin 强制使用原项目的 node_modules 时，可以采用以下综合解决方案：</p>\n<h2>核心强制方案</h2>\n<h3>1. 绝对路径解析（最可靠方案）</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);\n<span class="hljs-keyword">const</span> originalProjectRoot = <span class="hljs-string">&#x27;/absolute/path/to/original/project&#x27;</span>;\n\n<span class="hljs-comment">// 强制解析函数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveOriginal</span>(<span class="hljs-params">moduleName</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(moduleName, {\n    <span class="hljs-attr">paths</span>: [path.<span class="hljs-title function_">join</span>(originalProjectRoot, <span class="hljs-string">&#x27;node_modules&#x27;</span>)]\n  });\n}\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">module</span>: {\n    <span class="hljs-attr">rules</span>: [\n      {\n        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.js$/</span>,\n        <span class="hljs-attr">use</span>: {\n          <span class="hljs-attr">loader</span>: <span class="hljs-title function_">resolveOriginal</span>(<span class="hljs-string">&#x27;babel-loader&#x27;</span>), <span class="hljs-comment">// 强制使用原项目的 loader</span>\n          <span class="hljs-attr">options</span>: {\n            <span class="hljs-attr">presets</span>: [<span class="hljs-title function_">resolveOriginal</span>(<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>)]\n          }\n        }\n      }\n    ]\n  },\n  <span class="hljs-attr">plugins</span>: [\n    <span class="hljs-title function_">new</span> (<span class="hljs-built_in">require</span>(<span class="hljs-title function_">resolveOriginal</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)))() <span class="hljs-comment">// 强制使用原项目的 plugin</span>\n  ]\n};\n</code></pre>\n<h3>2. 模块解析劫持（强制锁定）</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);\n<span class="hljs-keyword">const</span> originalRequire = <span class="hljs-built_in">require</span>;\n\n<span class="hljs-comment">// 1. 锁定原项目 node_modules 路径</span>\n<span class="hljs-keyword">const</span> originalNodeModules = path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;/path/to/original/project&#x27;</span>, <span class="hljs-string">&#x27;node_modules&#x27;</span>);\n\n<span class="hljs-comment">// 2. 劫持 require 函数</span>\n<span class="hljs-variable language_">global</span>.<span class="hljs-property">require</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">moduleName</span>) {\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-comment">// 优先尝试从原项目 node_modules 加载</span>\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">originalRequire</span>(path.<span class="hljs-title function_">join</span>(originalNodeModules, moduleName));\n  } <span class="hljs-keyword">catch</span> (e) {\n    <span class="hljs-comment">// 回退到正常 require</span>\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">originalRequire</span>(moduleName);\n  }\n};\n\n<span class="hljs-comment">// 3. 确保 loader 也走这个逻辑</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">Module</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;module&#x27;</span>);\n<span class="hljs-keyword">const</span> originalLoader = <span class="hljs-title class_">Module</span>.<span class="hljs-property">_load</span>;\n<span class="hljs-title class_">Module</span>.<span class="hljs-property">_load</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">request, parent</span>) {\n  <span class="hljs-keyword">if</span> (request.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;babel-loader&#x27;</span>) || request.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;loader&#x27;</span>)) {\n    <span class="hljs-keyword">try</span> {\n      <span class="hljs-keyword">return</span> <span class="hljs-title function_">originalLoader</span>(path.<span class="hljs-title function_">join</span>(originalNodeModules, request), parent);\n    } <span class="hljs-keyword">catch</span> (e) {}\n  }\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">originalLoader</span>(request, parent);\n};\n</code></pre>\n<h2>环境级强制方案</h2>\n<h3>1. 修改 NODE_PATH 环境变量（最彻底）</h3>\n<pre><code class="language-javascript">process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_PATH</span> = path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;/path/to/original/project&#x27;</span>, <span class="hljs-string">&#x27;node_modules&#x27;</span>);\n<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;module&#x27;</span>).<span class="hljs-property">Module</span>.<span class="hljs-title function_">_initPaths</span>(); <span class="hljs-comment">// 重载模块解析路径</span>\n\n<span class="hljs-comment">// 后续所有 require 都会优先从指定路径查找</span>\n<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>); <span class="hljs-comment">// 现在强制使用原项目的 webpack</span>\n</code></pre>\n<h3>2. 使用 <code>--module-path</code> 参数启动</h3>\n<pre><code class="language-sh">node --module-path /path/to/original/project/node_modules your-script.js\n</code></pre>\n<h2>Webpack 配置级强制方案</h2>\n<h3>1. 双重锁定配置</h3>\n<pre><code class="language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">resolve</span>: {\n    <span class="hljs-attr">modules</span>: [\n      path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;/path/to/original/project&#x27;</span>, <span class="hljs-string">&#x27;node_modules&#x27;</span>), <span class="hljs-comment">// 主锁定</span>\n      <span class="hljs-string">&#x27;node_modules&#x27;</span> <span class="hljs-comment">// 后备</span>\n    ],\n    <span class="hljs-attr">alias</span>: {\n      <span class="hljs-comment">// 关键包强制锁定</span>\n      <span class="hljs-string">&#x27;babel-loader$&#x27;</span>: path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;/path/to/original/project&#x27;</span>, <span class="hljs-string">&#x27;node_modules/babel-loader&#x27;</span>),\n      <span class="hljs-string">&#x27;webpack$&#x27;</span>: path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;/path/to/original/project&#x27;</span>, <span class="hljs-string">&#x27;node_modules/webpack&#x27;</span>)\n    }\n  },\n  <span class="hljs-attr">resolveLoader</span>: {\n    <span class="hljs-attr">modules</span>: [\n      path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;/path/to/original/project&#x27;</span>, <span class="hljs-string">&#x27;node_modules&#x27;</span>), <span class="hljs-comment">// loader 专用锁定</span>\n      <span class="hljs-string">&#x27;node_modules&#x27;</span>\n    ]\n  }\n};\n</code></pre>\n<h3>2. 运行时验证机制</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>);\n\n<span class="hljs-comment">// 验证关键依赖是否来自原项目</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">verifyDependency</span> = (<span class="hljs-params">moduleName</span>) =&gt; {\n  <span class="hljs-keyword">const</span> resolvedPath = <span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(moduleName);\n  <span class="hljs-title function_">assert</span>(\n    resolvedPath.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;/original/project/node_modules/&#x27;</span>),\n    <span class="hljs-string">`依赖 <span class="hljs-subst">${moduleName}</span> 未从原项目 node_modules 加载！路径：<span class="hljs-subst">${resolvedPath}</span>`</span>\n  );\n};\n\n<span class="hljs-comment">// 验证关键包</span>\n[<span class="hljs-string">&#x27;webpack&#x27;</span>, <span class="hljs-string">&#x27;babel-loader&#x27;</span>, <span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>].<span class="hljs-title function_">forEach</span>(verifyDependency);\n</code></pre>\n<h2>综合解决方案（推荐）</h2>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);\n<span class="hljs-keyword">const</span> originalProjectRoot = path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;..&#x27;</span>); <span class="hljs-comment">// 根据实际情况调整</span>\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">DependencyLocker</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">projectRoot</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">projectRoot</span> = projectRoot;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">originalRequire</span> = <span class="hljs-built_in">require</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lockedModules</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();\n  }\n\n  <span class="hljs-title function_">lock</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-comment">// 1. 修改解析路径</span>\n    process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_PATH</span> = <span class="hljs-string">`<span class="hljs-subst">${process.env.NODE_PATH || <span class="hljs-string">&#x27;&#x27;</span>}</span>:<span class="hljs-subst">${path.join(<span class="hljs-variable language_">this</span>.projectRoot, <span class="hljs-string">&#x27;node_modules&#x27;</span>)}</span>`</span>;\n    <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;module&#x27;</span>).<span class="hljs-property">Module</span>.<span class="hljs-title function_">_initPaths</span>();\n\n    <span class="hljs-comment">// 2. 劫持 require</span>\n    <span class="hljs-variable language_">global</span>.<span class="hljs-property">require</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">wrappedRequire</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);\n\n    <span class="hljs-comment">// 3. 预验证关键包</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">verifyCoreDependencies</span>();\n  }\n\n  <span class="hljs-title function_">wrappedRequire</span>(<span class="hljs-params">moduleName</span>) {\n    <span class="hljs-keyword">try</span> {\n      <span class="hljs-comment">// 优先尝试从原项目加载</span>\n      <span class="hljs-keyword">const</span> resolvedPath = <span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(moduleName, {\n        <span class="hljs-attr">paths</span>: [path.<span class="hljs-title function_">join</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">projectRoot</span>, <span class="hljs-string">&#x27;node_modules&#x27;</span>)]\n      });\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">lockedModules</span>.<span class="hljs-title function_">add</span>(moduleName);\n      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">originalRequire</span>(resolvedPath);\n    } <span class="hljs-keyword">catch</span> (e) {\n      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">originalRequire</span>(moduleName);\n    }\n  }\n\n  <span class="hljs-title function_">verifyCoreDependencies</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> coreDeps = [<span class="hljs-string">&#x27;webpack&#x27;</span>, <span class="hljs-string">&#x27;babel-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>];\n    coreDeps.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">dep</span> =&gt;</span> {\n      <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">lockedModules</span>.<span class="hljs-title function_">has</span>(dep)) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">wrappedRequire</span>(dep); <span class="hljs-comment">// 强制加载并锁定</span>\n      }\n    });\n  }\n}\n\n<span class="hljs-comment">// 使用锁</span>\n<span class="hljs-keyword">new</span> <span class="hljs-title class_">DependencyLocker</span>(originalProjectRoot).<span class="hljs-title function_">lock</span>();\n\n<span class="hljs-comment">// 现在可以安全地动态调用 webpack 了</span>\n<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);\n<span class="hljs-keyword">const</span> config = {\n  <span class="hljs-attr">module</span>: {\n    <span class="hljs-attr">rules</span>: [\n      {\n        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.js$/</span>,\n        <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span> <span class="hljs-comment">// 会自动使用原项目的</span>\n      }\n    ]\n  }\n};\n</code></pre>\n<h2>验证方案有效性</h2>\n<ol>\n<li><strong>检查模块来源</strong>  ：<pre><code class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>));\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;babel-loader&#x27;</span>));\n</code></pre>\n</li>\n<li><strong>版本验证</strong>  ：<pre><code class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Webpack版本:&#x27;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack/package.json&#x27;</span>).<span class="hljs-property">version</span>);\n</code></pre>\n</li>\n<li><strong>路径断言</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>);\n<span class="hljs-title function_">assert</span>(\n  <span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>).<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;/original/project/node_modules/&#x27;</span>),\n  <span class="hljs-string">&#x27;Webpack 未从原项目加载！&#x27;</span>\n);\n</code></pre>\n</li>\n</ol>\n<h2>注意事项</h2>\n<ol>\n<li><strong>路径硬编码问题</strong>  ：建议使用 <code>path.resolve(__dirname, \'..\')</code> 等相对路径而非绝对路径</li>\n<li><strong>monorepo 场景</strong>  ：如果是 monorepo 项目，需要调整路径计算逻辑</li>\n<li><strong>清除缓存</strong>  ：修改 require 机制后可能需要清理缓存：<pre><code class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-built_in">require</span>.<span class="hljs-property">cache</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {\n  <span class="hljs-keyword">delete</span> <span class="hljs-built_in">require</span>.<span class="hljs-property">cache</span>[key];\n});\n</code></pre>\n</li>\n<li><strong>安全性</strong>  ：确保原项目的 node_modules 是可信的，因为这将完全控制依赖解析</li>\n</ol>\n<p>通过以上方法，你可以确保动态调用的 Webpack 配置中的所有 loader 和 plugin 都强制使用原项目的 node_modules，完全避免因模块解析路径问题导致的版本冲突或加载错误。</p>\n</div>'</script></body></html>