<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2be4(t,s){var p=_0x2879();return(_0x2be4=function(s,a){var n=p[s-=413];void 0===_0x2be4.xFoVyX&&(_0x2be4.QSyNZW=function(s,a){var n,l=[],t=0,p="";for(s=(s=>{for(var a,n,l="",t="",p=0,e=0;n=s.charAt(e++);~n&&(a=p%4?64*a+n:n,p++%4)&&(l+=String.fromCharCode(255&a>>(-2*p&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,o=l.length;c<o;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+a.charCodeAt(e%a.length))%256,n=l[e],l[e]=l[t],l[t]=n;for(var e=0,t=0,c=0;c<s.length;c++)n=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=n,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[t])%256]);return p},t=arguments,_0x2be4.xFoVyX=!0);var s=s+p[0],l=t[s];return l?n=l:(void 0===_0x2be4.bHqLhO&&(_0x2be4.bHqLhO=!0),n=_0x2be4.QSyNZW(n,a),t[s]=n),n})(t,s)}var _0x2c9faf=_0x2be4;if((()=>{for(var s=_0x2be4,a=_0x2879();;)try{if(536055==-parseInt(s(414,"IYXl"))+-parseInt(s(415,"Allb"))/2+-parseInt(s(434,"ZZ7u"))/3+-parseInt(s(421,"r^3*"))/4+-parseInt(s(431,"R18z"))/5+-parseInt(s(430,"ZZ7u"))/6*(parseInt(s(426,"G[1t"))/7)+-parseInt(s(417,"Nxc)"))/8*(-parseInt(s(436,"^31k"))/9))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x2c9faf(425,"hF&0")](_0x2c9faf(413,"C]QK"))!=_0x2c9faf(428,"hF&0"))throw window[_0x2c9faf(423,"r^3*")][_0x2c9faf(435,"eWnh")](_0x2c9faf(419,"SSq^")),Error();function _0x2879(){var s=["sqOzeLldTmkHW6pcLbhdKda","xeTnW6ddHJNdVmo2vmohW7qw","tmoRW7ddH8oxDCkh","zSofw8kCfgBcUNlcJ8k2WP4Tq2a","WQ0+W71UtCoBjmoCpG","is/cPSondmkaWQtcLhqWWPtdOG","W73cItVcSCkxBKfGWQJcPbZdNIm","qmkNW7S1WOVcOmkcE8kIgmoWvSklpa","W4rOW7tcNdWxWR9d","aSodAZVdLsHIva","sCoDWQ/dMKBcKY3dSgvPWR3cJZHkkcqnW7pdJSkOAqOCWO/cSsO","k2asvmk9WQVdKYxcG8oqWRZcSW","C05NW5mvucO+rSkWWR/dJW","W4hcJxnzW7hdVv0wWPhcKmoWW7VcHa","kXu2WODydYaI","o8oxWR89W7nkWRdcVG","FSkWr2JdUSk9rG","EaZcUCo2mZBdVXW","B8k0oCkhoHL2imoNWQlcJSkb","ACkGqfldTW","rGStg1BdTSk8W57cRJhdNHG","xKPjW6BdGd3dGSoTF8okW7eQ","kmkYeXlcHJC9zSoXW7rDffC","W7ddVLu9WR/cUvvTWOKJkmkXjW"];return(_0x2879=function(){return s})()}document.title="Web Components 详解",document.getElementById("article").innerHTML='<div><p>好的，我们来详细解析一下 <strong>Web Components</strong>   。这是一套现代浏览器原生支持的组件化技术，允许你创建可重用的、封装的自定义 HTML 元素。</p>\n<h3>一、什么是 Web Components？</h3>\n<p><strong>Web Components</strong>   是一系列浏览器原生标准的集合，它让开发者能够创建<strong>自定义的、可复用的、封装了样式与行为的 HTML 标签</strong>   ，并可以像使用原生 <code>&lt;div&gt;</code>、<code>&lt;button&gt;</code> 一样在项目中直接使用。</p>\n<p>它的核心思想是 <strong>“一次编写，随处运行”</strong>   。因为它是浏览器标准，所以无需任何外部框架（如 React, Vue, Angular）即可工作，并且可以与任何框架或无框架环境协同工作。</p>\n<h3>二、Web Components 的三大核心技术</h3>\n<p>Web Components 主要由三项核心技术构成：</p>\n<ol>\n<li><strong>Custom Elements（自定义元素）</strong>   ： 定义新 HTML 标签的 API。</li>\n<li><strong>Shadow DOM（影子 DOM）</strong>   ： 提供封装，将组件的结构、样式与主文档隔离。</li>\n<li><strong>HTML Templates（HTML 模板）</strong>   ： 使用 <code>&lt;template&gt;</code> 和 <code>&lt;slot&gt;</code> 定义组件的可复用标记结构。</li>\n</ol>\n<p>下面我们逐一详解。</p>\n<hr>\n<h3>1. Custom Elements（自定义元素）</h3>\n<p>允许你定义自己的 HTML 元素标签，并通过一个 JavaScript 类来控制它的行为。</p>\n<p><strong>生命周期回调函数</strong>   是自定义元素的核心，它们会在元素的特定阶段被自动调用：</p>\n<ul>\n<li><code>connectedCallback</code>: 当元素首次被插入到文档 DOM 时调用。常用于初始化设置，如获取属性、添加事件监听或渲染内容。</li>\n<li><code>disconnectedCallback</code>: 当元素从文档 DOM 中移除时调用。常用于清理工作，如移除事件监听、取消定时器等。</li>\n<li><code>attributeChangedCallback</code>: 当元素的被观察属性（在 <code>observedAttributes</code> 中定义）发生变化时调用。</li>\n<li><code>adoptedCallback</code>: 当元素被移动到另一个文档（如 <code>&lt;iframe&gt;</code>）时调用（较少使用）。</li>\n</ul>\n<p><strong>示例：定义一个简单的自定义元素</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 1. 定义一个类，继承自 HTMLElement</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> {\n  <span class="hljs-comment">// 2. 指定需要监听的属性</span>\n  <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> <span class="hljs-title function_">observedAttributes</span>() {\n    <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;disabled&quot;</span>];\n  }\n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">super</span>(); <span class="hljs-comment">// 必须首先调用 super()</span>\n    <span class="hljs-comment">// 初始化状态、影子DOM等（这里先不创建影子DOM）</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_clickCount</span> = <span class="hljs-number">0</span>;\n  }\n\n  <span class="hljs-comment">// 3. 生命周期：元素被添加到DOM时</span>\n  <span class="hljs-title function_">connectedCallback</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`&lt;button&gt;Click Me (<span class="hljs-subst">${<span class="hljs-variable language_">this</span>._clickCount}</span>)&lt;/button&gt;`</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_button</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);\n\n    <span class="hljs-comment">// 添加事件监听</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_button</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>));\n  }\n\n  <span class="hljs-comment">// 4. 生命周期：元素从DOM移除时</span>\n  <span class="hljs-title function_">disconnectedCallback</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-comment">// 移除事件监听以防止内存泄漏</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_button</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_handleClick</span>);\n  }\n\n  <span class="hljs-comment">// 5. 生命周期：监听属性变化</span>\n  <span class="hljs-title function_">attributeChangedCallback</span>(<span class="hljs-params">name, oldValue, newValue</span>) {\n    <span class="hljs-keyword">if</span> (name === <span class="hljs-string">&quot;disabled&quot;</span>) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_button</span>.<span class="hljs-property">disabled</span> = newValue !== <span class="hljs-literal">null</span>;\n    }\n  }\n\n  <span class="hljs-comment">// 自定义方法</span>\n  <span class="hljs-title function_">_handleClick</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_clickCount</span>++;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`&lt;button&gt;Click Me (<span class="hljs-subst">${<span class="hljs-variable language_">this</span>._clickCount}</span>)&lt;/button&gt;`</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_button</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);\n    <span class="hljs-comment">// 触发自定义事件</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">dispatchEvent</span>(\n      <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomEvent</span>(<span class="hljs-string">&quot;count-changed&quot;</span>, {\n        <span class="hljs-attr">detail</span>: { <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">_clickCount</span> },\n      }),\n    );\n  }\n}\n\n<span class="hljs-comment">// 6. 注册自定义元素</span>\n<span class="hljs-comment">// 参数1: 元素标签名（必须包含连字符 `-`）</span>\n<span class="hljs-comment">// 参数2: 控制该元素的类</span>\ncustomElements.<span class="hljs-title function_">define</span>(<span class="hljs-string">&quot;my-button&quot;</span>, <span class="hljs-title class_">MyButton</span>);\n</code></pre>\n<p><strong>在 HTML 中使用：</strong></p>\n<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n    <span class="hljs-comment">&lt;!-- 像使用原生标签一样使用 --&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">my-button</span> <span class="hljs-attr">disabled</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-button</span>&gt;</span>\n\n    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\n      <span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;my-button&quot;</span>);\n      <span class="hljs-comment">// 监听自定义事件</span>\n      button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;count-changed&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Count is now: <span class="hljs-subst">${e.detail.count}</span>`</span>);\n      });\n\n      <span class="hljs-comment">// 动态修改属性，会触发 attributeChangedCallback</span>\n      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n        button.<span class="hljs-title function_">removeAttribute</span>(<span class="hljs-string">&quot;disabled&quot;</span>);\n      }, <span class="hljs-number">3000</span>);\n    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n</code></pre>\n<hr>\n<h3>2. Shadow DOM（影子 DOM）</h3>\n<p>这是实现<strong>样式和行为封装</strong>   的关键。你可以将一个隐藏的、独立的 DOM 树附加到自定义元素上。这个树与主文档的 DOM 分离，确保了：</p>\n<ul>\n<li><strong>样式隔离</strong>   ：Shadow DOM 内部的样式不会影响到外部，外部的样式也不会影响到内部（除了一些继承的 CSS 属性，如 <code>color</code>, <code>font</code>）。</li>\n<li><strong>DOM 隔离</strong>   ：JavaScript 无法通过 <code>document.querySelector</code> 直接获取到 Shadow DOM 内部的元素。</li>\n</ul>\n<p><strong>示例：使用 Shadow DOM 封装样式和结构</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FancyCard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">super</span>();\n\n    <span class="hljs-comment">// 1. 创建并附加一个 Shadow Root（模式：open 或 closed）</span>\n    <span class="hljs-comment">// open: 允许外部通过 `element.shadowRoot` 访问</span>\n    <span class="hljs-comment">// closed: 不允许外部访问，`element.shadowRoot` 返回 null</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;open&quot;</span> });\n\n    <span class="hljs-comment">// 2. 定义组件的模板（结构和样式）</span>\n    <span class="hljs-keyword">const</span> template = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;template&quot;</span>);\n    template.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`\n      &lt;style&gt;\n        /* 这些样式只在这个 Shadow DOM 内生效 */\n        .card {\n          border: 1px solid #ccc;\n          border-radius: 8px;\n          padding: 16px;\n          margin: 10px;\n          background-color: #f9f9f9;\n          box-shadow: 2px 2px 5px rgba(0,0,0,0.1);\n        }\n        h3 {\n          color: #333;\n          margin-top: 0;\n        }\n        /* 外部定义的 h3 样式不会影响这里 */\n      &lt;/style&gt;\n      &lt;div class=&quot;card&quot;&gt;\n        &lt;h3&gt;&lt;slot name=&quot;title&quot;&gt;Default Title&lt;/slot&gt;&lt;/h3&gt;\n        &lt;p&gt;&lt;slot name=&quot;content&quot;&gt;Default content...&lt;/slot&gt;&lt;/p&gt;\n      &lt;/div&gt;\n    `</span>;\n\n    <span class="hljs-comment">// 3. 将模板内容克隆到 Shadow DOM 中</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">shadowRoot</span>.<span class="hljs-title function_">appendChild</span>(template.<span class="hljs-property">content</span>.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>));\n  }\n}\ncustomElements.<span class="hljs-title function_">define</span>(<span class="hljs-string">&quot;fancy-card&quot;</span>, <span class="hljs-title class_">FancyCard</span>);\n</code></pre>\n<p><strong>在 HTML 中使用插槽 (<code>&lt;slot&gt;</code>)：</strong></p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">fancy-card</span>&gt;</span>\n  <span class="hljs-comment">&lt;!-- 使用 `slot` 属性将内容分配到模板中的对应插槽 --&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>My Awesome Title<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>\n    This is some <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>amazing<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> content that goes inside the card!\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">fancy-card</span>&gt;</span>\n</code></pre>\n<hr>\n<h3>3. HTML Templates（HTML 模板）</h3>\n<p><code>&lt;template&gt;</code> 和 <code>&lt;slot&gt;</code> 标签用于定义可复用的标记结构。</p>\n<ul>\n<li><code>&lt;template&gt;</code>： 其内容在加载时不会被渲染，但可以通过 JavaScript 获取并激活（插入到 DOM 中）。</li>\n<li><code>&lt;slot&gt;</code>： 在 Web Components 中作为占位符，允许用户在使用自定义元素时插入自己的内容。</li>\n</ul>\n<p>上面的 <code>FancyCard</code> 示例已经展示了 <code>template</code> 和 <code>slot</code> 的用法。</p>\n<hr>\n<h3>三、完整示例：构建一个 Toast 提示组件</h3>\n<p>让我们结合以上所有技术，构建一个完整的 <code>my-toast</code> 组件。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyToast</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> {\n  <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> <span class="hljs-title function_">observedAttributes</span>() {\n    <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;duration&quot;</span>];\n  }\n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">super</span>();\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;open&quot;</span> });\n\n    <span class="hljs-keyword">const</span> template = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;template&quot;</span>);\n    template.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`\n      &lt;style&gt;\n        :host {\n          display: block;\n          box-sizing: border-box;\n        }\n        .toast {\n          padding: 12px 20px;\n          border-radius: 4px;\n          color: white;\n          margin-bottom: 10px;\n          opacity: 0;\n          transform: translateY(-20px);\n          transition: opacity 0.3s, transform 0.3s;\n        }\n        .toast.show {\n          opacity: 1;\n          transform: translateY(0);\n        }\n        .type-info { background-color: #2196F3; }\n        .type-success { background-color: #4CAF50; }\n        .type-warning { background-color: #FF9800; }\n        .type-error { background-color: #F44336; }\n      &lt;/style&gt;\n      &lt;div class=&quot;toast&quot;&gt;\n        &lt;slot&gt;&lt;/slot&gt;\n      &lt;/div&gt;\n    `</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">shadowRoot</span>.<span class="hljs-title function_">appendChild</span>(template.<span class="hljs-property">content</span>.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>));\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_toastEl</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">shadowRoot</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.toast&quot;</span>);\n  }\n\n  <span class="hljs-title function_">connectedCallback</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> type = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&quot;type&quot;</span>) || <span class="hljs-string">&quot;info&quot;</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_toastEl</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">`type-<span class="hljs-subst">${type}</span>`</span>, <span class="hljs-string">&quot;show&quot;</span>);\n\n    <span class="hljs-keyword">const</span> duration = <span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&quot;duration&quot;</span>)) || <span class="hljs-number">3000</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_autoHideTimer</span> = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hide</span>(), duration);\n  }\n\n  <span class="hljs-title function_">disconnectedCallback</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-built_in">clearTimeout</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_autoHideTimer</span>);\n  }\n\n  <span class="hljs-comment">// 公共方法：隐藏 Toast</span>\n  <span class="hljs-title function_">hide</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_toastEl</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&quot;show&quot;</span>);\n    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">parentNode</span>) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(<span class="hljs-variable language_">this</span>);\n      }\n    }, <span class="hljs-number">300</span>); <span class="hljs-comment">// 等待过渡动画结束</span>\n  }\n}\n\ncustomElements.<span class="hljs-title function_">define</span>(<span class="hljs-string">&quot;my-toast&quot;</span>, <span class="hljs-title class_">MyToast</span>);\n\n<span class="hljs-comment">// 提供一个便捷的全局函数来显示 Toast</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">showToast</span>(<span class="hljs-params">message, options = {}</span>) {\n  <span class="hljs-keyword">const</span> { type = <span class="hljs-string">&quot;info&quot;</span>, duration = <span class="hljs-number">3000</span> } = options;\n  <span class="hljs-keyword">const</span> toast = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;my-toast&quot;</span>);\n  toast.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;type&quot;</span>, type);\n  toast.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;duration&quot;</span>, duration);\n  toast.<span class="hljs-property">textContent</span> = message;\n  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(toast);\n  <span class="hljs-keyword">return</span> toast;\n}\n</code></pre>\n<p><strong>使用方法：</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 方法一：直接使用自定义元素</span>\n<span class="hljs-keyword">const</span> toast = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;my-toast&quot;</span>);\ntoast.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;success&quot;</span>);\ntoast.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;duration&quot;</span>, <span class="hljs-string">&quot;2000&quot;</span>);\ntoast.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;操作成功！&quot;</span>;\n<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(toast);\n\n<span class="hljs-comment">// 方法二：使用便捷函数</span>\n<span class="hljs-title function_">showToast</span>(<span class="hljs-string">&quot;这是一条警告信息&quot;</span>, { <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;warning&quot;</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">5000</span> });\n</code></pre>\n<h3>四、优点与缺点</h3>\n<p><strong>优点：</strong></p>\n<ol>\n<li><strong>原生支持</strong>   ：无需框架，浏览器直接运行，体积小，无依赖。</li>\n<li><strong>高度封装</strong>   ：Shadow DOM 提供了完美的样式和 DOM 隔离。</li>\n<li><strong>互操作性强</strong>   ：可以在 React、Vue、Angular 等任何框架中使用，也可以单独使用。</li>\n<li><strong>可维护性</strong>   ：将功能封装成标签，使代码更模块化、更清晰。</li>\n</ol>\n<p><strong>缺点/注意事项：</strong></p>\n<ol>\n<li><strong>SEO 问题</strong>   ：搜索引擎对 Shadow DOM 内部内容的爬取和索引支持可能不完善。</li>\n<li><strong>样式隔离的副作用</strong>   ：有时需要从外部有控制地影响内部样式会比较复杂（可通过 CSS Custom Properties / CSS 变量部分解决）。</li>\n<li>** SSR (服务端渲染) 支持较弱**   ：自定义元素是客户端组件，不利于首屏渲染和 SEO。</li>\n<li><strong>开发体验</strong>   ：相比成熟的框架（如 React、Vue），在状态管理、数据传递、开发工具链方面需要自己处理更多细节。</li>\n</ol>\n<h3>总结</h3>\n<p>Web Components 是现代 Web 开发中强大的底层原语，它为构建可复用的组件提供了标准化的浏览器原生方案。虽然它不像主流框架那样提供全面的开箱即用解决方案，但其<strong>无依赖、跨框架、高度封装</strong>   的特性使其在构建大型应用的基础组件库、微前端架构以及需要长期维护的项目中具有独特的价值。许多知名项目（如 YouTube、GitHub）和 UI 库（如 Shoelace、Spectrum Web Components）都已基于此技术构建。</p>\n</div>'</script></body></html>