<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4a97(){var s=["Ccy5w8kpWR9GW7/cICoBwCoKvq","lSk/A3aJvG12hHBdVmkGWRW","W4qMbCkzo1VdGSoab8k7j8kjW5f3WOxcRHFdHSkoW6fqaSobzu/dOG","pCoEWQPbdehcTCoO","W6pdMCk7zCkgvGGR","W6RdJSojyxldVmkZWRtcNKhcJrZdNG","m2z8eCoa","WRKrW7b5WR/dMhhcTG1nmN0","WPLqjI8lW4RcHc5DW7/cI1ZcVG","h1BdUxBdLmkOWOTMmCkfWQ8","BCk9BmkNcemswNFcTeyDaa","WQj2WQO7W6uABmkMWQRdT8oJj2G","rCkdqxCQW6z5","ECkfWR5TW5HYcSksya","d0nbFCoJjXS","WRTXWRFcJWJcG14OehJcM8oKWPxcIW","WONdOv8Uamo6WQNcGW","zsxcGwJcUutdTc4","WOZcN0C2l8o+WRy","WPfTlSoizSoiwa","ECo0uCoQW7LJoW","WRCgs8okWQ4itmkatCo6eSkada","W4VcKLKGtgCUlKNcUSoC","W7tdGf3dUGFdTSoEFmk7gSoupW","WQjjWO1aEmoAfIq","t01OWP/dImodWQm","qtNdMX/cJ8oBWQ/cHJVdVdOnySkw","WRL3WRdcJWFcGvnRdMhcS8owWOO"];return(_0x4a97=function(){return s})()}var _0x4cda4b=_0x633b;function _0x633b(l,s){var p=_0x4a97();return(_0x633b=function(s,n){var a=p[s-=271];void 0===_0x633b.waDJDo&&(_0x633b.gsGEnV=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,o=t.length;r<o;r++)l+="%"+("00"+t.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,r=0;r<s.length;r++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(r)^t[(t[e]+t[l])%256]);return p},l=arguments,_0x633b.waDJDo=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x633b.lEHDzl&&(_0x633b.lEHDzl=!0),a=_0x633b.gsGEnV(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x633b,n=_0x4a97();;)try{if(594012==+parseInt(s(288,"zSVq"))*(parseInt(s(286,"BhdG"))/2)+-parseInt(s(283,"9jAO"))/3*(-parseInt(s(287,"iy*N"))/4)+-parseInt(s(291,"MZ^s"))/5*(parseInt(s(284,"Lm8b"))/6)+parseInt(s(280,"#1R3"))/7*(parseInt(s(297,"jKH$"))/8)+-parseInt(s(293,"#7Gr"))/9+-parseInt(s(274,"o16W"))/10+parseInt(s(279,"MZ^s"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x4cda4b(278,"oPGl")](_0x4cda4b(277,"QLw3"))!=_0x4cda4b(298,"W3CS"))throw window[_0x4cda4b(296,"$w1p")][_0x4cda4b(289,"yzQR")](_0x4cda4b(294,"g3e%")),Error();document.title="微信小程序 页面通信",document.getElementById("article").innerHTML='<div><p>在微信小程序中，页面之间的通信是一个常见的需求，尤其是在构建复杂应用时。微信小程序提供了多种页面通信方式，以满足不同的场景需求。以下是几种主要的页面通信方式及其详细说明：</p>\n<hr>\n<h3><strong>1. URL 参数传递</strong></h3>\n<h4><strong>原理</strong></h4>\n<p>在页面跳转时，通过 URL 参数传递数据。目标页面可以通过 <code>onLoad</code> 或 <code>onShow</code> 方法的参数获取这些数据。</p>\n<h4><strong>适用场景</strong></h4>\n<ul>\n<li>传递简单的数据，如 ID、类型等。</li>\n<li>数据量小，且不需要在页面间频繁交互。</li>\n</ul>\n<h4><strong>实现方式</strong></h4>\n<p><strong>页面 A 跳转并传递参数</strong>  ：</p>\n<pre><code class="language-javascript">wx.<span class="hljs-title function_">navigateTo</span>({\n  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/pages/pageB/pageB?id=123&amp;name=test&#x27;</span>\n});\n</code></pre>\n<p><strong>页面 B 接收参数</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-title class_">Page</span>({\n  <span class="hljs-attr">onLoad</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(options.<span class="hljs-property">id</span>);   <span class="hljs-comment">// 输出：123</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(options.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出：test</span>\n  }\n});\n</code></pre>\n<h4><strong>优缺点</strong></h4>\n<ul>\n<li><strong>优点</strong>  ：简单易用，适合传递少量数据。</li>\n<li><strong>缺点</strong>  ：数据暴露在 URL 中，不适合传递敏感信息；数据量受限。</li>\n</ul>\n<hr>\n<h3><strong>2. 全局数据存储</strong></h3>\n<h4><strong>原理</strong></h4>\n<p>利用小程序的 <code>App</code> 实例或全局对象（如 <code>globalData</code>）存储数据，页面之间通过访问全局对象共享数据。</p>\n<h4><strong>适用场景</strong></h4>\n<ul>\n<li>需要在多个页面间共享数据。</li>\n<li>数据量较大，或需要频繁更新。</li>\n</ul>\n<h4><strong>实现方式</strong></h4>\n<p><strong>在 <code>app.js</code> 中定义全局数据</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-title class_">App</span>({\n  <span class="hljs-attr">globalData</span>: {\n    <span class="hljs-attr">userInfo</span>: <span class="hljs-literal">null</span>,\n    <span class="hljs-attr">sharedData</span>: {}\n  }\n});\n</code></pre>\n<p><strong>页面 A 设置全局数据</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">getApp</span>();\napp.<span class="hljs-property">globalData</span>.<span class="hljs-property">sharedData</span> = { <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> };\n</code></pre>\n<p><strong>页面 B 获取全局数据</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">getApp</span>();\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(app.<span class="hljs-property">globalData</span>.<span class="hljs-property">sharedData</span>.<span class="hljs-property">key</span>); <span class="hljs-comment">// 输出：value</span>\n</code></pre>\n<h4><strong>优缺点</strong></h4>\n<ul>\n<li><strong>优点</strong>  ：数据持久化在小程序生命周期内，适合共享大量数据。</li>\n<li><strong>缺点</strong>  ：全局数据的管理复杂，容易造成数据污染；需要手动同步数据更新。</li>\n</ul>\n<hr>\n<h3><strong>3. 本地存储</strong></h3>\n<h4><strong>原理</strong></h4>\n<p>使用微信提供的本地存储 API（如 <code>wx.setStorageSync</code>、<code>wx.getStorageSync</code>）在页面间传递数据。</p>\n<h4><strong>适用场景</strong></h4>\n<ul>\n<li>需要在页面间共享数据，且数据需要在小程序重启后仍然可用。</li>\n<li>数据量较大，不适合通过 URL 参数传递。</li>\n</ul>\n<h4><strong>实现方式</strong></h4>\n<p><strong>页面 A 存储数据</strong>  ：</p>\n<pre><code class="language-javascript">wx.<span class="hljs-title function_">setStorageSync</span>(<span class="hljs-string">&#x27;key&#x27;</span>, { <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;value&#x27;</span> });\n</code></pre>\n<p><strong>页面 B 读取数据</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> data = wx.<span class="hljs-title function_">getStorageSync</span>(<span class="hljs-string">&#x27;key&#x27;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">data</span>); <span class="hljs-comment">// 输出：value</span>\n</code></pre>\n<h4><strong>优缺点</strong></h4>\n<ul>\n<li><strong>优点</strong>  ：数据持久化，适合需要长期保存的数据。</li>\n<li><strong>缺点</strong>  ：读写操作相对耗时，不适合频繁读写；需要手动管理数据的清理。</li>\n</ul>\n<hr>\n<h3><strong>4. 事件总线（Event Bus）</strong></h3>\n<h4><strong>原理</strong></h4>\n<p>通过自定义事件机制，实现页面间的通信。可以创建一个事件总线对象，页面通过订阅和发布事件进行通信。</p>\n<h4><strong>适用场景</strong></h4>\n<ul>\n<li>页面间需要实时通信，且通信频率较高。</li>\n<li>需要解耦页面之间的依赖关系。</li>\n</ul>\n<h4><strong>实现方式</strong></h4>\n<p><strong>创建事件总线（可封装在单独的文件中）</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// eventBus.js</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBus</span> = {\n  <span class="hljs-attr">eventList</span>: {},\n  <span class="hljs-title function_">on</span>(<span class="hljs-params">event, listener</span>) {\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">eventList</span>[event]) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventList</span>[event] = [];\n    }\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventList</span>[event].<span class="hljs-title function_">push</span>(listener);\n  },\n  <span class="hljs-title function_">emit</span>(<span class="hljs-params">event, data</span>) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">eventList</span>[event]) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventList</span>[event].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">listener</span> =&gt;</span> <span class="hljs-title function_">listener</span>(data));\n    }\n  },\n  <span class="hljs-title function_">off</span>(<span class="hljs-params">event, listener</span>) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">eventList</span>[event]) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventList</span>[event] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventList</span>[event].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">l</span> =&gt;</span> l !== listener);\n    }\n  }\n};\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">EventBus</span>;\n</code></pre>\n<p><strong>页面 A 发送事件</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBus</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../../utils/eventBus.js&#x27;</span>);\n\n<span class="hljs-title class_">EventBus</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;updateData&#x27;</span>, { <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> });\n</code></pre>\n<p><strong>页面 B 接收事件</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBus</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../../utils/eventBus.js&#x27;</span>);\n\n<span class="hljs-title class_">Page</span>({\n  <span class="hljs-attr">onLoad</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-title class_">EventBus</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;updateData&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">key</span>); <span class="hljs-comment">// 输出：value</span>\n    });\n  }\n});\n</code></pre>\n<h4><strong>优缺点</strong></h4>\n<ul>\n<li><strong>优点</strong>  ：解耦页面之间的依赖，适合复杂的通信场景。</li>\n<li><strong>缺点</strong>  ：需要手动管理事件的订阅和取消订阅，避免内存泄漏。</li>\n</ul>\n<hr>\n<h3><strong>5. 页面栈通信</strong></h3>\n<h4><strong>原理</strong></h4>\n<p>利用小程序的页面栈，通过 <code>getCurrentPages</code> 获取页面实例，直接调用目标页面的方法或修改其数据。</p>\n<h4><strong>适用场景</strong></h4>\n<ul>\n<li>需要在页面栈中的相邻页面间通信。</li>\n<li>通信频率较低，且页面关系明确。</li>\n</ul>\n<h4><strong>实现方式</strong></h4>\n<p><strong>在页面 B 中定义方法</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-title class_">Page</span>({\n  <span class="hljs-attr">updateData</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>({ <span class="hljs-attr">sharedData</span>: data });\n  }\n});\n</code></pre>\n<p><strong>在页面 A 中调用页面 B 的方法</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> pages = <span class="hljs-title function_">getCurrentPages</span>();\n<span class="hljs-keyword">const</span> pageB = pages.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">page</span> =&gt;</span> page.<span class="hljs-property">route</span> === <span class="hljs-string">&#x27;pages/pageB/pageB&#x27;</span>);\n<span class="hljs-keyword">if</span> (pageB) {\n  pageB.<span class="hljs-title function_">updateData</span>({ <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> });\n}\n</code></pre>\n<h4><strong>优缺点</strong></h4>\n<ul>\n<li><strong>优点</strong>  ：直接调用目标页面的方法，通信效率高。</li>\n<li><strong>缺点</strong>  ：页面关系耦合度高，不适合跨页面或深层页面间的通信。</li>\n</ul>\n<hr>\n<h3><strong>6. 自定义组件通信</strong></h3>\n<h4><strong>原理</strong></h4>\n<p>如果页面间通信涉及到自定义组件，可以通过组件的事件和属性进行通信。</p>\n<h4><strong>适用场景</strong></h4>\n<ul>\n<li>页面与自定义组件之间的通信。</li>\n<li>组件之间的通信。</li>\n</ul>\n<h4><strong>实现方式</strong></h4>\n<p><strong>父组件向子组件传递数据</strong>  ：</p>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 父组件 wxml --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">child-component</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&quot;{{parentData}}&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-component</span>&gt;</span>\n</code></pre>\n<p><strong>子组件接收数据</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 子组件 js</span>\n<span class="hljs-title class_">Component</span>({\n  <span class="hljs-attr">properties</span>: {\n    <span class="hljs-attr">data</span>: {\n      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span>,\n      <span class="hljs-attr">value</span>: {}\n    }\n  }\n});\n</code></pre>\n<p><strong>子组件向父组件传递事件</strong>  ：</p>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 子组件 wxml --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">bindtap</span>=<span class="hljs-string">&quot;sendEvent&quot;</span>&gt;</span>Send Event<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-comment">// 子组件 js</span>\n<span class="hljs-title class_">Component</span>({\n  <span class="hljs-attr">methods</span>: {\n    <span class="hljs-title function_">sendEvent</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">triggerEvent</span>(<span class="hljs-string">&#x27;myevent&#x27;</span>,{ <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> } );\n    }\n  }\n});\n</code></pre>\n<p><strong>父组件监听事件</strong>  ：</p>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 父组件 wxml --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">child-component</span> <span class="hljs-attr">bindmyevent</span>=<span class="hljs-string">&quot;handleEvent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-component</span>&gt;</span>\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-comment">// 父组件 js</span>\n<span class="hljs-title class_">Page</span>({\n  <span class="hljs-title function_">handleEvent</span>(<span class="hljs-params">e</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">detail</span>.<span class="hljs-property">key</span>); <span class="hljs-comment">// 输出：value</span>\n  }\n});\n</code></pre>\n<h4><strong>优缺点</strong></h4>\n<ul>\n<li><strong>优点</strong>  ：组件化开发，代码复用性高。</li>\n<li><strong>缺点</strong>  ：组件间通信需要精心设计，避免过度耦合。</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>通信方式</strong></th>\n<th><strong>适用场景</strong></th>\n<th><strong>优点</strong></th>\n<th><strong>缺点</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>URL 参数传递</td>\n<td>传递简单数据</td>\n<td>简单易用</td>\n<td>数据量受限，不适合敏感信息</td>\n</tr>\n<tr>\n<td>全局数据存储</td>\n<td>多页面共享数据</td>\n<td>数据持久化，适合大量数据</td>\n<td>管理复杂，容易造成数据污染</td>\n</tr>\n<tr>\n<td>本地存储</td>\n<td>需要持久化的数据</td>\n<td>数据持久化，适合长期保存</td>\n<td>读写耗时，需要手动管理清理</td>\n</tr>\n<tr>\n<td>事件总线</td>\n<td>实时通信，解耦页面依赖</td>\n<td>解耦页面，适合复杂通信</td>\n<td>需要手动管理事件订阅和取消</td>\n</tr>\n<tr>\n<td>页面栈通信</td>\n<td>页面栈中的相邻页面通信</td>\n<td>通信效率高</td>\n<td>页面关系耦合度高</td>\n</tr>\n<tr>\n<td>自定义组件通信</td>\n<td>页面与组件、组件之间的通信</td>\n<td>组件化开发，代码复用性高</td>\n<td>需要精心设计，避免过度耦合</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>最佳实践</strong></h3>\n<ul>\n<li><strong>根据需求选择</strong>  ：根据通信的数据量、频率和页面关系，选择合适的通信方式。</li>\n<li><strong>保持简洁</strong>  ：避免过度使用全局数据或事件总线，保持代码的可维护性。</li>\n<li><strong>安全性</strong>  ：避免在 URL 中传递敏感信息，必要时对数据进行加密。</li>\n<li><strong>性能优化</strong>  ：对于频繁通信的场景，考虑使用事件总线或页面栈通信，减少不必要的读写操作。</li>\n</ul>\n<p>通过合理选择和使用页面通信方式，可以提升微信小程序的开发效率和用户体验。</p>\n</div>'</script></body></html>