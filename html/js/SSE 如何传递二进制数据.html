<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4ef3(){var s=["dYVdVCkOWPpcLKC","wMVcRtpdGYjnW7G","tSosixm+lSorgW","W4/dSe1PzSkRyZu","EG3dM8kfWRtcQMz2WOe","nfHpxZFcPshcRa","s3ZdJCo9WOXvBmo/jtRdTSo9W6S","WPtdJ8o8W4NcKg1hWQRcTeRdUG","amofDCogW6HuW7WjC2BdGCox","Cmo4W6RcTLedW61GnWFcPNe","W5SDztBcHKXy","W4pdReJcLSkYqmkMsWnNrbu","W5qmzq/cGrmAg2hcVCkrW57dG8k6DSk1WRToW7SagSo/dSk4WPeb","W4FdS2rCymkuxbO","WOLljeVdHH0mbK7cNSkyW6ldNCkT","tmooCIJcLNvTwZ1Ve3yega","thNcHCkgW5OOkCob","WOlcLxqXC8k6nwuFz8o6W68W","W5pcMdTTW48","zfhdUsWmBSoyxSo0Fd06","Ba8zbNVcTGNcO8o2WRWx","WO9KWOj1WOy7WR3dTG","smoCi2GJjColea","W4ZdTqWyo8ovxH4mWO8uFW","W7nrW71+WPZcL8k7","W4FdQ0lcL8k6rSkQuaTuybS","b8ohCSohW69qWOWxyM7dS8onja","yqv9schcVahcTq","iaqhW6ZdJSoyWPa","W4/dSaeynmoxiHSvWRqcA8oa"];return(_0x4ef3=function(){return s})()}var _0x23086a=_0x44c5;function _0x44c5(l,s){var p=_0x4ef3();return(_0x44c5=function(s,n){var a=p[s-=334];void 0===_0x44c5.GkbUQq&&(_0x44c5.zsDPoi=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=t.length;c<r;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,c=0;c<s.length;c++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(c)^t[(t[e]+t[l])%256]);return p},l=arguments,_0x44c5.GkbUQq=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x44c5.oXnJuB&&(_0x44c5.oXnJuB=!0),a=_0x44c5.zsDPoi(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x44c5,n=_0x4ef3();;)try{if(790812==+parseInt(s(346,"&[je"))*(-parseInt(s(362,"Qc@z"))/2)+parseInt(s(358,"xKpL"))/3*(-parseInt(s(351,"FUpG"))/4)+-parseInt(s(344,"yiLF"))/5+-parseInt(s(339,"y$9K"))/6*(parseInt(s(361,"FUpG"))/7)+parseInt(s(340,"tt7f"))/8*(-parseInt(s(334,"&[je"))/9)+-parseInt(s(357,"KqjH"))/10+parseInt(s(354,"yiLF"))/11*(parseInt(s(353,"j9[W"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x23086a(348,"x)BT")](_0x23086a(342,"JPv%"))!=_0x23086a(356,"mZWP"))throw window[_0x23086a(343,"xKpL")][_0x23086a(336,"QfSr")](_0x23086a(350,"x)BT")),Error();document.title="SSE 如何传递二进制数据",document.getElementById("article").innerHTML='<div><h3>核心答案：</h3>\n<p><strong>是的，SSE (Server-Sent Events) 协议本身设计上只能传递文本数据</strong>   。这是由 HTML5 标准规定的限制。</p>\n<p>但是，通过编码技术可以在 SSE 中<strong>间接传输二进制数据</strong>   。</p>\n<hr>\n<h3>一、SSE 的文本本质</h3>\n<h4>1. 协议规范限制</h4>\n<ul>\n<li><strong>SSE 协议标准</strong>   ：只支持 UTF-8 文本格式</li>\n<li><strong>数据格式要求</strong>   ：<pre><code class="language-http"><span class="hljs-attribute">data</span><span class="hljs-punctuation">: </span>这是一条文本消息\\n\\n\n</code></pre>\n</li>\n<li><strong>二进制数据直接传输会失败</strong>   ：<pre><code class="language-javascript"><span class="hljs-comment">// 错误示例：直接发送二进制</span>\nres.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;data: &quot;</span> + binaryBuffer + <span class="hljs-string">&quot;\\n\\n&quot;</span>); <span class="hljs-comment">// 会导致乱码或错误</span>\n</code></pre>\n</li>\n</ul>\n<h4>2. 浏览器 API 限制</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> eventSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">&quot;/stream&quot;</span>);\neventSource.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-comment">// event.data 永远是字符串类型</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> event.<span class="hljs-property">data</span>); <span class="hljs-comment">// &quot;string&quot;</span>\n};\n</code></pre>\n<hr>\n<h3>二、二进制数据的间接传输方案</h3>\n<h4>方案1：Base64 编码（最常用）</h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 服务端编码</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">sendBinaryViaSSE</span>(<span class="hljs-params">binaryData</span>) {\n  <span class="hljs-keyword">const</span> base64String = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(binaryData).<span class="hljs-title function_">toString</span>(<span class="hljs-string">&quot;base64&quot;</span>);\n  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">`event: binary\\n`</span>);\n  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">`data: <span class="hljs-subst">${base64String}</span>\\n\\n`</span>);\n}\n\n<span class="hljs-comment">// 客户端解码</span>\neventSource.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;binary&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> binaryData = <span class="hljs-title class_">Uint8Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title function_">atob</span>(event.<span class="hljs-property">data</span>), <span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> c.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>));\n  <span class="hljs-comment">// 使用 binaryData</span>\n});\n</code></pre>\n<h4>方案2：十六进制编码</h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 服务端</span>\n<span class="hljs-keyword">const</span> hexString = buffer.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&quot;hex&quot;</span>);\nres.<span class="hljs-title function_">write</span>(<span class="hljs-string">`data: <span class="hljs-subst">${hexString}</span>\\n\\n`</span>);\n\n<span class="hljs-comment">// 客户端</span>\n<span class="hljs-keyword">const</span> bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(event.<span class="hljs-property">data</span>.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>);\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; event.<span class="hljs-property">data</span>.<span class="hljs-property">length</span>; i += <span class="hljs-number">2</span>) {\n  bytes[i / <span class="hljs-number">2</span>] = <span class="hljs-built_in">parseInt</span>(event.<span class="hljs-property">data</span>.<span class="hljs-title function_">substr</span>(i, <span class="hljs-number">2</span>), <span class="hljs-number">16</span>);\n}\n</code></pre>\n<h4>方案3：自定义二进制格式（需要协议约定）</h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 定义简单二进制协议</span>\n<span class="hljs-comment">// 字节 0-3: 数据类型标识</span>\n<span class="hljs-comment">// 字节 4-7: 数据长度</span>\n<span class="hljs-comment">// 字节 8+: 实际数据（Base64编码）</span>\n</code></pre>\n<hr>\n<h3>三、性能影响分析</h3>\n<h4>编码开销对比</h4>\n<table>\n<thead>\n<tr>\n<th>编码方式</th>\n<th>数据膨胀率</th>\n<th>编解码性能</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Base64</strong></td>\n<td>+33%</td>\n<td>中等</td>\n<td>通用二进制数据</td>\n</tr>\n<tr>\n<td><strong>十六进制</strong></td>\n<td>+100%</td>\n<td>快</td>\n<td>调试和小数据</td>\n</tr>\n<tr>\n<td><strong>压缩+Base64</strong></td>\n<td>可变</td>\n<td>慢</td>\n<td>大文件传输</td>\n</tr>\n</tbody>\n</table>\n<h4>实测性能示例</h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 1MB 二进制数据传输测试</span>\n<span class="hljs-keyword">const</span> originalData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0xab</span>);\n\n<span class="hljs-comment">// Base64 编码后大小</span>\n<span class="hljs-keyword">const</span> base64Size = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>((originalData.<span class="hljs-property">length</span> * <span class="hljs-number">4</span>) / <span class="hljs-number">3</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(base64Size); <span class="hljs-comment">// ≈1.33MB</span>\n\n<span class="hljs-comment">// 编解码时间成本</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;base64&quot;</span>);\n<span class="hljs-keyword">const</span> encoded = <span class="hljs-title function_">btoa</span>(<span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>(...originalData));\n<span class="hljs-keyword">const</span> decoded = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>([...<span class="hljs-title function_">atob</span>(encoded)].<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> c.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>)));\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&quot;base64&quot;</span>); <span class="hljs-comment">// 约 50-100ms</span>\n</code></pre>\n<hr>\n<h3>四、完整实现示例</h3>\n<h4>服务端（Node.js）</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);\n<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();\n\napp.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/binary-stream&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/event-stream&quot;</span>);\n  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>);\n  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Connection&quot;</span>, <span class="hljs-string">&quot;keep-alive&quot;</span>);\n\n  <span class="hljs-comment">// 发送文本消息</span>\n  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;event: text\\n&quot;</span>);\n  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;data: 文本消息\\n\\n&quot;</span>);\n\n  <span class="hljs-comment">// 发送二进制消息（编码后）</span>\n  <span class="hljs-keyword">const</span> binaryData = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">0x48</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x6f</span>]); <span class="hljs-comment">// Hello</span>\n  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;event: binary\\n&quot;</span>);\n  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">`data: <span class="hljs-subst">${binaryData.toString(<span class="hljs-string">&quot;base64&quot;</span>)}</span>\\n\\n`</span>);\n\n  <span class="hljs-comment">// 发送JSON数据</span>\n  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;event: json\\n&quot;</span>);\n  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">`data: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify({ number: <span class="hljs-number">42</span>, text: <span class="hljs-string">&quot;value&quot;</span> })}</span>\\n\\n`</span>);\n});\n\napp.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);\n</code></pre>\n<h4>客户端（浏览器）</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> eventSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">&quot;/binary-stream&quot;</span>);\n\n<span class="hljs-comment">// 处理文本消息</span>\neventSource.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文本:&quot;</span>, event.<span class="hljs-property">data</span>);\n});\n\n<span class="hljs-comment">// 处理二进制消息</span>\neventSource.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;binary&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> binaryData = <span class="hljs-title class_">Uint8Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title function_">atob</span>(event.<span class="hljs-property">data</span>), <span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> c.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>));\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;二进制数据:&quot;</span>, binaryData);\n});\n\n<span class="hljs-comment">// 处理JSON消息</span>\neventSource.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;json&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(event.<span class="hljs-property">data</span>);\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;JSON数据:&quot;</span>, data);\n});\n</code></pre>\n<hr>\n<h3>五、SSE 与 WebSocket 的对比选择</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>SSE</th>\n<th>WebSocket</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>协议方向</strong></td>\n<td>单向（服务器→客户端）</td>\n<td>双向</td>\n</tr>\n<tr>\n<td><strong>数据格式</strong></td>\n<td>仅文本（可编码二进制）</td>\n<td>原生支持二进制</td>\n</tr>\n<tr>\n<td><strong>二进制性能</strong></td>\n<td>有编码开销（+33%）</td>\n<td>零开销</td>\n</tr>\n<tr>\n<td><strong>连接管理</strong></td>\n<td>自动重连</td>\n<td>需手动实现</td>\n</tr>\n<tr>\n<td><strong>浏览器支持</strong></td>\n<td>广泛</td>\n<td>广泛</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>六、适用场景建议</h3>\n<h4>适合 SSE 的场景：</h4>\n<ol>\n<li><strong>服务器推送通知</strong>   （文本为主）</li>\n<li><strong>实时日志监控</strong>   （文本数据）</li>\n<li><strong>小规模二进制数据</strong>   （如图标、小图片）</li>\n<li><strong>需要自动重连机制</strong>   的场景</li>\n</ol>\n<h4>不适合 SSE 的场景：</h4>\n<ol>\n<li><strong>大规模二进制传输</strong>   （视频流、大文件）</li>\n<li><strong>低延迟要求的二进制通信</strong></li>\n<li><strong>需要客户端向服务器发送二进制数据</strong></li>\n</ol>\n<hr>\n<h3>七、生产环境注意事项</h3>\n<ol>\n<li>\n<p><strong>连接数限制</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 浏览器对每个服务器的SSE连接数有限制（通常6个）</span>\n<span class="hljs-comment">// 需要合理的连接管理</span>\n</code></pre>\n</li>\n<li>\n<p><strong>错误处理</strong>   ：</p>\n<pre><code class="language-javascript">eventSource.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;SSE连接错误:&quot;</span>, error);\n  <span class="hljs-comment">// 实现重连逻辑</span>\n};\n</code></pre>\n</li>\n<li>\n<p><strong>安全性</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// Base64编码的数据需要验证</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">safeBase64Decode</span>(<span class="hljs-params">str</span>) {\n  <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^[A-Za-z0-9+/=]*$/</span>.<span class="hljs-title function_">test</span>(str)) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;无效的Base64数据&quot;</span>);\n  }\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">atob</span>(str);\n}\n</code></pre>\n</li>\n</ol>\n<h3>总结：</h3>\n<p><strong>SSE 本质上只能传输文本</strong>   ，但通过 Base64 等编码方式可以间接传输二进制数据。这种方案适合小到中等规模的二进制数据传输，对于大规模或高性能要求的二进制通信，WebSocket 是更好的选择。</p>\n<p>选择时需要权衡：</p>\n<ul>\n<li>开发复杂度（SSE更简单）</li>\n<li>性能要求（WebSocket更高效）</li>\n<li>数据特性（文本为主还是二进制为主）</li>\n</ul>\n</div>'</script></body></html>