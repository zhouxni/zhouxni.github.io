<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5890f0=_0x4881;function _0x4881(t,n){var o=_0x4012();return(_0x4881=function(n,s){var a=o[n-=354];void 0===_0x4881.MrrahA&&(_0x4881.OkmgZf=function(n,s){var a,l=[],t=0,o="";for(n=(n=>{for(var s,a,l="",t="",o=0,c=0;a=n.charAt(c++);~a&&(s=o%4?64*s+a:a,o++%4)&&(l+=String.fromCharCode(255&s>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,p=l.length;e<p;e++)t+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(n),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)t=(t+l[c]+s.charCodeAt(c%s.length))%256,a=l[c],l[c]=l[t],l[t]=a;for(var c=0,t=0,e=0;e<n.length;e++)a=l[c=(c+1)%256],l[c]=l[t=(t+l[c])%256],l[t]=a,o+=String.fromCharCode(n.charCodeAt(e)^l[(l[c]+l[t])%256]);return o},t=arguments,_0x4881.MrrahA=!0);var n=n+o[0],l=t[n];return l?a=l:(void 0===_0x4881.zkPxCf&&(_0x4881.zkPxCf=!0),a=_0x4881.OkmgZf(a,s),t[n]=a),a})(t,n)}function _0x4012(){var n=["WRzkCSobWRJcMmo9WONdJ0FdMwBcHG","WOOBm8kHWRnVfvqPW7ZdVG","W7RcNMpcImoMW7NcSSohWRpdLvHOya","v8kBW7TjW5JdTK7dGYn6WPv7W4a","WQb0WO4/o2ZdK8ko","W6DNzCkCnSoCWOG9","W53dPN4MESkMimkRW4/cHSkeBWS","W7JcVCkpWR4fWQPMWOJdOa","WQmMCCkIkq","W4nKrJfIb8kSW7HrW7lcMcHx","W7VdMCoZW4ZdJsxcIZNcH8ogkSkX","WPzKWQiuzmospwe","WRy+W7FdTSoyb8kWW59jxY9n","oe1xtmogWO5y","uSoOWO40WP/cRHC","hHlcKwTqW5XpWQ1gWP7dVCoCW4m","W4zQq0izDSoxW71s","WQqzWPtdSSoAurPAyvNcUhVcNq","W5pdHd/cOYpcJh07WPC","W77cMgNcGmoLW7RcT8oLWPJdHvXtua","W7ZcTSkiWOZcNexcTq","WRfrWOZcTSkjz8ko","xIOnjLaPWOC","W6b2m8kLDSk2Amon","tNJdQmojWOnbimkH","WOeXW6rvW4bCeSkbWPddGKe","WQdcPbVdQvpcMSkjWRHplSoaWOpdKCk8","sCopW5GvqYddOCoNW5NcVbVcLbrl","W5xcG8oUz0JdHGS","W7ldIWXtCmk1ba1LW6KFzXniFtaNhNuZWP0JW7NcVCkGWP8"];return(_0x4012=function(){return n})()}if((()=>{for(var n=_0x4881,s=_0x4012();;)try{if(824633==-parseInt(n(370,"N#X&"))*(parseInt(n(360,"tfh["))/2)+parseInt(n(382,"IGn]"))/3*(-parseInt(n(379,"n69K"))/4)+parseInt(n(354,"W^FE"))/5*(-parseInt(n(356,"uB51"))/6)+-parseInt(n(372,"NkUt"))/7*(-parseInt(n(377,"uB51"))/8)+parseInt(n(369,"mPbj"))/9*(parseInt(n(367,"W^FE"))/10)+parseInt(n(374,")q2j"))/11+parseInt(n(362,"[@O6"))/12)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x5890f0(378,"wPfT")](_0x5890f0(383,"KIB["))!=_0x5890f0(373,"N#X&"))throw window[_0x5890f0(359,"7z0z")][_0x5890f0(357,"@I*a")](_0x5890f0(364,"q8@r")),Error();document.title="vue3 响应式核心",document.getElementById("article").innerHTML='<div><p>以下是针对图中 Vue 3 API 的详细解析，包含 <strong>核心作用</strong>   、<strong>代码示例</strong>   、<strong>使用场景</strong>   和 <strong>关键细节</strong>   ，按响应式数据与副作用分类说明：</p>\n<hr>\n<h3><strong>一、响应式数据核心 API</strong></h3>\n<h4>1. <code>ref()</code></h4>\n<ul>\n<li>\n<p><strong>作用</strong>   ：创建响应式<strong>基本类型</strong>   或<strong>对象引用</strong>   ，通过 <code>.value</code> 访问/修改。</p>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 基本类型</span>\n<span class="hljs-keyword">const</span> user = <span class="hljs-title function_">ref</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> }); <span class="hljs-comment">// 对象</span>\n\ncount.<span class="hljs-property">value</span>++; <span class="hljs-comment">// 触发更新</span>\nuser.<span class="hljs-property">value</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Bob&quot;</span>; <span class="hljs-comment">// 自动深层响应</span>\n</code></pre>\n</li>\n<li>\n<p><strong>场景</strong>   ：</p>\n<ul>\n<li>基本类型数据（如数字、字符串）</li>\n<li>需要重新赋值的对象（替换整个对象时）</li>\n</ul>\n</li>\n<li>\n<p><strong>注意</strong>   ：</p>\n<ul>\n<li>模板中自动解包（无需 <code>.value</code>），但 JS 中必须用 <code>.value</code>。</li>\n</ul>\n</li>\n</ul>\n<h4>2. <code>computed()</code></h4>\n<ul>\n<li><strong>作用</strong>   ：创建<strong>计算属性</strong>   ，基于依赖自动缓存计算结果。</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> firstName = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;John&quot;</span>);\n<span class="hljs-keyword">const</span> lastName = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;Doe&quot;</span>);\n<span class="hljs-keyword">const</span> fullName = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${firstName.value}</span> <span class="hljs-subst">${lastName.value}</span>`</span>);\n</code></pre>\n</li>\n<li><strong>场景</strong>   ：\n<ul>\n<li>派生状态（如过滤列表、格式化数据）</li>\n<li>性能优化（避免重复计算）</li>\n</ul>\n</li>\n<li><strong>注意</strong>   ：\n<ul>\n<li>默认只读，需使用 <code>{ get, set }</code> 语法创建可写计算属性。</li>\n</ul>\n</li>\n</ul>\n<h4>3. <code>reactive()</code></h4>\n<ul>\n<li><strong>作用</strong>   ：创建<strong>深层响应式对象</strong>   ，所有嵌套属性自动响应。</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({\n  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,\n  <span class="hljs-attr">user</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> },\n});\nstate.<span class="hljs-property">user</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Bob&quot;</span>; <span class="hljs-comment">// 自动触发更新</span>\n</code></pre>\n</li>\n<li><strong>场景</strong>   ：\n<ul>\n<li>复杂对象或嵌套数据结构</li>\n<li>需要频繁修改嵌套属性的场景</li>\n</ul>\n</li>\n<li><strong>注意</strong>   ：\n<ul>\n<li>直接替换整个对象会失去响应性（应使用 <code>Object.assign</code> 或解构赋值）。</li>\n</ul>\n</li>\n</ul>\n<h4>4. <code>readonly()</code></h4>\n<ul>\n<li><strong>作用</strong>   ：创建<strong>只读代理对象</strong>   ，任何修改尝试都会触发警告。</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> original = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> });\n<span class="hljs-keyword">const</span> copy = <span class="hljs-title function_">readonly</span>(original);\ncopy.<span class="hljs-property">count</span>++; <span class="hljs-comment">// ❌ 控制台警告且修改无效</span>\n</code></pre>\n</li>\n<li><strong>场景</strong>   ：\n<ul>\n<li>保护全局配置或 props 数据不被意外修改</li>\n<li>安全传递响应式对象给子组件</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>二、副作用监听 API</strong></h3>\n<h4>5. <code>watchEffect()</code></h4>\n<ul>\n<li><strong>作用</strong>   ：<strong>立即执行</strong>   回调函数，并自动追踪其依赖的变化。</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n<span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Count is: <span class="hljs-subst">${count.value}</span>`</span>);\n});\n</code></pre>\n</li>\n<li><strong>场景</strong>   ：\n<ul>\n<li>依赖变化时执行副作用（如发送分析日志）</li>\n<li>不需要显式指定依赖的监听</li>\n</ul>\n</li>\n<li><strong>注意</strong>   ：\n<ul>\n<li>首次调用时立即执行</li>\n<li>无法获取旧值，适合执行操作而非比较。</li>\n</ul>\n</li>\n</ul>\n<h4>6. <code>watchPostEffect()</code></h4>\n<ul>\n<li><strong>作用</strong>   ：与 <code>watchEffect</code> 类似，但回调在 <strong>DOM 更新后</strong>   执行。</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-title function_">watchPostEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 访问更新后的 DOM</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;DOM updated:&quot;</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;app&quot;</span>).<span class="hljs-property">innerHTML</span>);\n});\n</code></pre>\n</li>\n<li><strong>场景</strong>   ：\n<ul>\n<li>需要操作更新后的 DOM（如测量元素尺寸）</li>\n<li>避免布局抖动（类似 Vue 2 的 <code>Vue.nextTick</code>）</li>\n</ul>\n</li>\n</ul>\n<h4>7. <code>watchSyncEffect()</code></h4>\n<ul>\n<li><strong>作用</strong>   ：与 <code>watchEffect</code> 类似，但回调在 <strong>依赖变化时同步执行</strong>   。</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n<span class="hljs-title function_">watchSyncEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 同步更新，适合需要即时反馈的场景</span>\n  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;count&quot;</span>, count.<span class="hljs-property">value</span>.<span class="hljs-title function_">toString</span>());\n});\n</code></pre>\n</li>\n<li><strong>场景</strong>   ：\n<ul>\n<li>需要同步响应的操作（如同步到 localStorage）</li>\n<li>避免异步导致的中间状态问题</li>\n</ul>\n</li>\n</ul>\n<h4>8. <code>watch()</code></h4>\n<ul>\n<li><strong>作用</strong>   ：<strong>显式监听</strong>   特定数据源，可获取旧值和新值。<a href="https://zhouxni.github.io/html/js/Vue%203%20%E4%B8%AD%EF%BC%8Cwatch%20%E5%87%BD%E6%95%B0%E7%9A%84%20options%20%E5%AF%B9%E8%B1%A1%20.html" target="_blank">options 对象详解</a></li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> });\n<span class="hljs-title function_">watch</span>(\n  <span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">count</span>, <span class="hljs-comment">// 数据源</span>\n  <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Count changed from <span class="hljs-subst">${oldVal}</span> to <span class="hljs-subst">${newVal}</span>`</span>);\n  },\n  { <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> }, <span class="hljs-comment">// 立即触发一次</span>\n);\n</code></pre>\n</li>\n<li><strong>场景</strong>   ：\n<ul>\n<li>需要对比旧值和新值（如撤销操作）</li>\n<li>监听特定属性而非整个对象</li>\n</ul>\n</li>\n<li><strong>注意</strong>   ：\n<ul>\n<li>支持监听多个数据源（数组形式），回调参数对应为数组。</li>\n</ul>\n</li>\n</ul>\n<h4>9. <code>onWatcherCleanup()</code></h4>\n<ul>\n<li><strong>作用</strong>   ：在副作用（如 <code>watch</code> 或 <code>watchEffect</code>）重新执行前，运行清理逻辑，与 <code>watch</code> 回调函数中第三个参数 <code>onCleanup</code> 没有本质区别。</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">(<span class="hljs-params">onCleanup</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Delayed log&quot;</span>);\n  }, <span class="hljs-number">1000</span>);\n  <span class="hljs-title function_">onWatcherCleanup</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearTimeout</span>(timer)); <span class="hljs-comment">// 清理上一次的定时器</span>\n});\n</code></pre>\n</li>\n<li><strong>场景</strong>   ：\n<ul>\n<li>取消未完成的异步操作（如 Axios 请求）</li>\n<li>清理事件监听或定时器</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>三、对比与选择指南</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>API</strong></th>\n<th><strong>特点</strong></th>\n<th><strong>何时使用？</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ref()</code></td>\n<td>适合基本类型或需要替换的引用</td>\n<td>数字、字符串、需要重新赋值的对象</td>\n</tr>\n<tr>\n<td><code>reactive()</code></td>\n<td>深层响应式对象</td>\n<td>复杂嵌套数据结构</td>\n</tr>\n<tr>\n<td><code>watchEffect()</code></td>\n<td>自动追踪依赖，立即执行</td>\n<td>不关心旧值，只需执行副作用</td>\n</tr>\n<tr>\n<td><code>watch()</code></td>\n<td>显式指定依赖，可获取旧值</td>\n<td>需要比较新旧值或监听特定属性</td>\n</tr>\n<tr>\n<td><code>watchPostEffect()</code></td>\n<td>DOM 更新后触发</td>\n<td>操作更新后的 DOM 元素</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>关键细节与陷阱</strong></h3>\n<ol>\n<li>\n<p><strong><code>ref</code> vs <code>reactive</code></strong>   ：</p>\n<ul>\n<li><code>ref</code> 更适合基本类型，<code>reactive</code> 适合对象。混合使用时，<code>reactive</code> 会自动解包 <code>ref</code> 的 <code>.value</code>。</li>\n</ul>\n</li>\n<li>\n<p><strong><code>watchEffect</code> 的依赖追踪</strong>   ：</p>\n<ul>\n<li>只在同步代码中追踪依赖，异步回调内的访问不会触发更新：<pre><code class="language-javascript"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-title function_">async</span> () =&gt; {\n  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>(); <span class="hljs-comment">// 这里的依赖不会被追踪！</span>\n});\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>内存泄漏</strong>   ：</p>\n<ul>\n<li>在组件卸载时手动清理 <code>watch</code> 或 <code>watchEffect</code>（或使用 <code>effectScope</code> 统一管理）。</li>\n</ul>\n</li>\n<li>\n<p><strong>性能优化</strong>   ：</p>\n<ul>\n<li>对大量数据使用 <code>shallowRef</code> 或 <code>shallowReactive</code> 减少响应式开销。</li>\n</ul>\n</li>\n</ol>\n<p>如果需要更具体的组合使用案例（如 <code>watch + customRef</code> 实现高级功能），欢迎进一步提问！</p>\n</div>'</script></body></html>