<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x398431=_0xa12b;function _0x1f6b(){var n=["tCkugcVcJdFcQmk+W63dMCoHW4q","WRikBtn8W5u1oW","W5FdPIFdL8oYxXW","W5xcLNZcM8k3pGJdNmkcW7KBW4C","WPjyW6PmBSovoSkwqqNcVWi","W5VcNSoWW5KmhXvoBa","W4hdN3DIvCk1WQ/cL0jfESoN","WRjrdmo2mmoNWONdUduHsCoE","W6ahlYKvW7fhhq","F8k5vcFcJq","eCotyuddQCkgtxm","W5pcN3VcKSkWohNdI8kbW7qkW4mi","WPZdJc3cImkjW5vurq","W6dcMgJdJSoEWPTXW4mMimohxa","WPJcIqzzWPpdP8k/WPrpi8okEG","sSoqFqpcMmkvtuZdL8oNWQeZ","W6tcKJ/cLmkZW6HpW74","yYRcGbvkW5qtheO/WQGrW4e","W7q7W7bVr3RcSG","cmkerI8OW4rd","WQddLSkZW5POWR7dOCkmWRNcGCo7dmoi","W5hdMaetm0NcU0HhWPxcIatdVG","WQ1VWR0Fzv44A8kuW64Uk3a8WR3dPhxdG1RcUSkgW4Kfuu1r","zvddMvKpWRfW","WOZdR8o2e21IWO9WW6GAhCo7"];return(_0x1f6b=function(){return n})()}function _0xa12b(e,n){var r=_0x1f6b();return(_0xa12b=function(n,l){var i=r[n-=115];void 0===_0xa12b.bmcxFM&&(_0xa12b.xvOcwb=function(n,l){var i,o=[],e=0,r="";for(n=(n=>{for(var l,i,o="",e="",r=0,t=0;i=n.charAt(t++);~i&&(l=r%4?64*l+i:i,r++%4)&&(o+=String.fromCharCode(255&l>>(-2*r&6))))i="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(i);for(var d=0,c=o.length;d<c;d++)e+="%"+("00"+o.charCodeAt(d).toString(16)).slice(-2);return decodeURIComponent(e)})(n),t=0;t<256;t++)o[t]=t;for(t=0;t<256;t++)e=(e+o[t]+l.charCodeAt(t%l.length))%256,i=o[t],o[t]=o[e],o[e]=i;for(var t=0,e=0,d=0;d<n.length;d++)i=o[t=(t+1)%256],o[t]=o[e=(e+o[t])%256],o[e]=i,r+=String.fromCharCode(n.charCodeAt(d)^o[(o[t]+o[e])%256]);return r},e=arguments,_0xa12b.bmcxFM=!0);var n=n+r[0],o=e[n];return o?i=o:(void 0===_0xa12b.gzgZIR&&(_0xa12b.gzgZIR=!0),i=_0xa12b.xvOcwb(i,l),e[n]=i),i})(e,n)}if((()=>{for(var n=_0xa12b,l=_0x1f6b();;)try{if(291838==-parseInt(n(129,"[SDR"))+parseInt(n(119,"vOaG"))/2+-parseInt(n(139,"%C5o"))/3*(parseInt(n(123,"%(&%"))/4)+-parseInt(n(128,"]2CO"))/5+-parseInt(n(126,"$0Nv"))/6*(-parseInt(n(117,"$0Nv"))/7)+parseInt(n(125,"3o)y"))/8*(parseInt(n(132,"arn9"))/9)+parseInt(n(121,"qyZP"))/10)break;l.push(l.shift())}catch(n){l.push(l.shift())}})(),localStorage[_0x398431(133,"ui3R")](_0x398431(120,"uUJa"))!=_0x398431(124,"cMxC"))throw window[_0x398431(116,"X2S^")][_0x398431(134,"5ik6")](_0x398431(137,"Y]L#")),Error();document.title="vite 钩子函数",document.getElementById("article").innerHTML="<div><p>Vite 提供了丰富的钩子函数，允许开发者在构建和开发过程中插入自定义逻辑。这些钩子函数大致可以分为通用钩子和 Vite 独有钩子两类。以下是 Vite 中常见的钩子函数及其简要说明：</p>\n<h3>通用钩子函数</h3>\n<ol>\n<li><strong><code>options</code></strong>  ：\n<ul>\n<li>在服务器启动时调用，用于配置 Vite 服务器的选项。</li>\n<li>主要用于获取和操纵 Rollup 的配置。</li>\n</ul>\n</li>\n<li><strong><code>buildStart</code></strong>  ：\n<ul>\n<li>在构建开始时触发，标志着构建过程的开始。</li>\n<li>可以在这里执行一些构建前的初始化操作。</li>\n</ul>\n</li>\n<li><strong><code>resolveId</code></strong>  ：\n<ul>\n<li>在每个传入模块请求时被调用，用于解析模块的 ID，找到对应的文件。</li>\n<li>可以用于自定义模块解析逻辑。</li>\n</ul>\n</li>\n<li><strong><code>load</code></strong>  ：\n<ul>\n<li>在每个传入模块请求时被调用，用于加载模块的源码。</li>\n<li>可以用于自定义模块加载逻辑，如替换模块内容。</li>\n</ul>\n</li>\n<li><strong><code>transform</code></strong>  ：\n<ul>\n<li>在每个传入模块请求时被调用，用于转换模块的源码。</li>\n<li>可以用于对模块代码进行自定义转换。</li>\n</ul>\n</li>\n<li><strong><code>buildEnd</code></strong>  ：\n<ul>\n<li>在构建结束时触发，标志着构建过程的结束。</li>\n<li>可以在这里执行一些构建后的清理或后处理操作。</li>\n</ul>\n</li>\n<li><strong><code>closeBundle</code></strong>  ：\n<ul>\n<li>在服务器关闭时调用，进行必要的清理工作。</li>\n<li>适用于在构建过程结束时执行一些资源释放或日志记录操作。</li>\n</ul>\n</li>\n</ol>\n<h3>Vite 独有钩子函数</h3>\n<ol>\n<li><strong><code>config</code></strong>  ：\n<ul>\n<li>在 Vite 配置被解析时触发。</li>\n<li>允许插件修改 Vite 的默认配置。</li>\n</ul>\n</li>\n<li><strong><code>configResolved</code></strong>  ：\n<ul>\n<li>在解析 Vite 配置之后调用。</li>\n<li>用于获取最终的配置信息，可以根据不同配置执行不同逻辑。</li>\n</ul>\n</li>\n<li><strong><code>configureServer</code></strong>  ：\n<ul>\n<li>用于配置开发服务器的钩子。</li>\n<li>通常在这里添加自定义的中间件或扩展开发服务器的功能。</li>\n</ul>\n</li>\n<li><strong><code>configurePreviewServer</code></strong>  ：\n<ul>\n<li>与 <code>configureServer</code> 类似，但用于预览服务器。</li>\n<li>通过 <code>vite preview</code> 命令启动时调用。</li>\n</ul>\n</li>\n<li><strong><code>transformIndexHtml</code></strong>  ：\n<ul>\n<li>用于修改或注入 HTML 文件的内容。</li>\n<li>可以在这里对入口的 HTML 文件进行自定义处理。</li>\n</ul>\n</li>\n<li><strong><code>handleHotUpdate</code></strong>  ：\n<ul>\n<li>用于自定义执行 HMR（热模块替换）的处理。</li>\n<li>可以在热更新过程中执行自定义逻辑。</li>\n</ul>\n</li>\n</ol>\n<h3>其他相关钩子</h3>\n<ul>\n<li><strong><code>renderStart</code></strong>  ：\n<ul>\n<li>每次 <code>bundle.generate</code> 和 <code>bundle.write</code> 调用时都会被触发。</li>\n<li>用于在渲染阶段开始前执行操作。</li>\n</ul>\n</li>\n<li><strong><code>augmentChunkHash</code></strong>  ：\n<ul>\n<li>用来给 chunk 增加 hash。</li>\n<li>可以自定义 chunk 的 hash 生成逻辑。</li>\n</ul>\n</li>\n<li><strong><code>renderChunk</code></strong>  ：\n<ul>\n<li>转译单个 chunk 时触发。</li>\n<li>可以在这里对单个 chunk 进行自定义处理。</li>\n</ul>\n</li>\n<li><strong><code>generateBundle</code></strong>  ：\n<ul>\n<li>在构建结束时调用，允许插件访问或修改最终生成的 bundle。</li>\n<li>可以用于自定义构建输出。</li>\n</ul>\n</li>\n<li><strong><code>writeBundle</code></strong>  ：\n<ul>\n<li>在构建过程中，当 bundle 准备写入磁盘时调用。</li>\n<li>可以用于在 bundle 写入磁盘前执行操作。</li>\n</ul>\n</li>\n<li><strong><code>optimizeDeps</code></strong>  ：\n<ul>\n<li>允许插件优化依赖，例如决定哪些依赖应该被包含在客户端。</li>\n<li>可以用于自定义依赖优化逻辑。</li>\n</ul>\n</li>\n</ul>\n<p>这些钩子函数为开发者提供了强大的扩展性，使得开发者能够在 Vite 的构建和开发过程中插入自定义逻辑，满足不同的开发需求。</p>\n</div>"</script></body></html>