<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4e2e(t,n){var l=_0x3e0c();return(_0x4e2e=function(n,s){var a=l[n-=176];void 0===_0x4e2e.oAKHys&&(_0x4e2e.FAhdVk=function(n,s){var a,e=[],t=0,l="";for(n=(n=>{for(var s,a,e="",t="",l=0,o=0;a=n.charAt(o++);~a&&(s=l%4?64*s+a:a,l++%4)&&(e+=String.fromCharCode(255&s>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,d=e.length;c<d;c++)t+="%"+("00"+e.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(n),o=0;o<256;o++)e[o]=o;for(o=0;o<256;o++)t=(t+e[o]+s.charCodeAt(o%s.length))%256,a=e[o],e[o]=e[t],e[t]=a;for(var o=0,t=0,c=0;c<n.length;c++)a=e[o=(o+1)%256],e[o]=e[t=(t+e[o])%256],e[t]=a,l+=String.fromCharCode(n.charCodeAt(c)^e[(e[o]+e[t])%256]);return l},t=arguments,_0x4e2e.oAKHys=!0);var n=n+l[0],e=t[n];return e?a=e:(void 0===_0x4e2e.iYJVVp&&(_0x4e2e.iYJVVp=!0),a=_0x4e2e.FAhdVk(a,s),t[n]=a),a})(t,n)}var _0x26dae7=_0x4e2e;function _0x3e0c(){var n=["CZ4Ylb0Fzq","wLFcU8owW6SyW4FdQL8LW4y2","WR3dRmodpCkdW5VdHG","W73dQw9yA8kfWRVcJCovW7P7W7W","W6f9W4CdW4fzbK4mcmoE","WRldJ8k1mcDzWOpdGmkf","CCoYWPJcQSkCW7ldO1JdKeFcQq","umk/WOFdNYxdVSounq","ruqrW6HPW4aZW7dcLSkeimkvmgnJWOddHMXJWOtdOComw8o8i8kj","ntq2eZ8Vwq","brldNCotWPFdIZnkWRFcOCoRBq","A8kaW7ykW4NcTCopW55GWOxcImo9","ASkgW7fXWOBdO8oHW5Lk","W6JdTmktcGuqc1tcKJfmW4O","Fxu7W6xcVKtcKmkH","W73dRg1En8orWR7cGSoyW7G","W7JdOMrDoCo5WPdcH8oEW7O","wSoAlSklWRyJW4/cPG8","c8oPW5tcJMNdMmoHpSkNrmkV","WRtdGmk0q3PEWPddICkVWQpdHq","pH3cVmoRkYjnW6ddUem","W7dcGSoYcdC","WRldH8owcYLHWRtdNa","k8osg8oYA8khkdFdGa","W7JcTsK+gmoHWOa","F8o8W5RdMqS9ahJdNW","W6rWW48eWQbhfKOOhG","mmkBWRJdRLWNc1ioW7q","Dmo2WP/cP8kyWRxdH3ddNgdcTcm","W6j8W44dWPTDfuq5nq"];return(_0x3e0c=function(){return n})()}if((()=>{for(var n=_0x4e2e,s=_0x3e0c();;)try{if(114184==+parseInt(n(199,"*FnT"))*(parseInt(n(202,")sbj"))/2)+parseInt(n(183,"eyYN"))/3*(parseInt(n(188,"0TOs"))/4)+parseInt(n(203,"*Ffq"))/5+parseInt(n(192,"M8f*"))/6*(parseInt(n(190,"VtTA"))/7)+-parseInt(n(194,"0OIF"))/8+parseInt(n(191,"*FnT"))/9*(-parseInt(n(185,"I@w["))/10)+-parseInt(n(205,"3@mk"))/11*(parseInt(n(197,"M8f*"))/12))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x26dae7(195,"Td2O")](_0x26dae7(180,"%X10"))!=_0x26dae7(184,"I@w["))throw window[_0x26dae7(200,"fjmc")][_0x26dae7(193,")sbj")](_0x26dae7(201,"@7U#")),Error();document.title="rollup  entryFileNames 和 file 优先级详解",document.getElementById("article").innerHTML='<div><p>在构建工具（如 Webpack、Rollup、Vite 等）中，<code>entryFileNames</code> 和 <code>file</code> 都是用于控制输出文件命名的配置选项，但它们的应用场景和优先级有所不同。</p>\n<h2>一、基本概念对比</h2>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>适用场景</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>entryFileNames</code></td>\n<td>入口文件(output.entryFileNames)</td>\n<td>控制入口 chunk 的输出文件名</td>\n</tr>\n<tr>\n<td><code>file</code></td>\n<td>单个输出(output.file)</td>\n<td>直接指定输出文件的完整路径</td>\n</tr>\n</tbody>\n</table>\n<h2>二、优先级规则</h2>\n<ol>\n<li><strong>Rollup/Vite 中的优先级</strong>  ：\n<ul>\n<li>当同时配置时，<code>file</code> 的优先级高于 <code>entryFileNames</code></li>\n<li>如果指定了 <code>file</code>，<code>entryFileNames</code> 对该文件的命名规则将被忽略</li>\n</ul>\n</li>\n<li><strong>Webpack 中的类似概念</strong>  ：\n<ul>\n<li>Webpack 使用 <code>filename</code> 和 <code>output.filename</code> 配置</li>\n<li>单个入口的 <code>output.filename</code> 会覆盖通用配置</li>\n</ul>\n</li>\n</ol>\n<h2>三、具体使用场景</h2>\n<h3>1. Rollup/Vite 配置示例</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// rollup.config.js / vite.config.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">output</span>: {\n    <span class="hljs-comment">// 入口文件的命名规则（适用于多个入口）</span>\n    <span class="hljs-attr">entryFileNames</span>: <span class="hljs-string">&#x27;[name]-[hash].js&#x27;</span>,\n    \n    <span class="hljs-comment">// 直接指定输出文件（会覆盖entryFileNames）</span>\n    <span class="hljs-attr">file</span>: <span class="hljs-string">&#x27;dist/main.js&#x27;</span>\n  }\n}\n</code></pre>\n<h3>2. 多入口场景下的行为</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">input</span>: {\n    <span class="hljs-attr">main</span>: <span class="hljs-string">&#x27;src/main.js&#x27;</span>,\n    <span class="hljs-attr">vendor</span>: <span class="hljs-string">&#x27;src/vendor.js&#x27;</span>\n  },\n  <span class="hljs-attr">output</span>: {\n    <span class="hljs-attr">dir</span>: <span class="hljs-string">&#x27;dist&#x27;</span>,\n    <span class="hljs-comment">// 以下配置会被应用</span>\n    <span class="hljs-attr">entryFileNames</span>: <span class="hljs-string">&#x27;[name]-[hash].js&#x27;</span>,\n    \n    <span class="hljs-comment">// 如果这里指定了file，则只会生成一个文件</span>\n    <span class="hljs-comment">// file: &#x27;dist/bundle.js&#x27; </span>\n  }\n}\n</code></pre>\n<h2>四、实际应用建议</h2>\n<ol>\n<li><strong>使用 <code>entryFileNames</code> 当</strong>  ：\n<ul>\n<li>有多个入口文件需要输出</li>\n<li>希望自动生成带 hash 的文件名</li>\n<li>需要动态命名规则</li>\n</ul>\n</li>\n<li><strong>使用 <code>file</code> 当</strong>  ：\n<ul>\n<li>只需要输出单个文件</li>\n<li>需要精确控制输出路径和文件名</li>\n<li>构建库时指定固定输出文件名</li>\n</ul>\n</li>\n<li><strong>最佳实践组合</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;src/index.js&#x27;</span>,\n  <span class="hljs-attr">output</span>: {\n    <span class="hljs-attr">dir</span>: <span class="hljs-string">&#x27;dist&#x27;</span>,\n    <span class="hljs-comment">// 入口文件命名规则</span>\n    <span class="hljs-attr">entryFileNames</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span>,\n    <span class="hljs-comment">// 非入口chunk命名规则</span>\n    <span class="hljs-attr">chunkFileNames</span>: <span class="hljs-string">&#x27;[name]-[hash].js&#x27;</span>,\n    <span class="hljs-comment">// 资源文件命名规则</span>\n    <span class="hljs-attr">assetFileNames</span>: <span class="hljs-string">&#x27;assets/[name]-[hash][extname]&#x27;</span>\n  }\n}\n</code></pre>\n</li>\n</ol>\n<h2>五、与 Webpack 的对比</h2>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>Rollup/Vite</th>\n<th>Webpack</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>入口文件命名</td>\n<td><code>entryFileNames</code></td>\n<td><code>output.filename</code></td>\n</tr>\n<tr>\n<td>单个输出指定</td>\n<td><code>file</code></td>\n<td><code>output.path</code> + <code>filename</code></td>\n</tr>\n<tr>\n<td>动态命名</td>\n<td><code>[name]-[hash].js</code></td>\n<td><code>[name].[contenthash].js</code></td>\n</tr>\n</tbody>\n</table>\n<h2>六、常见问题解决</h2>\n<p><strong>问题1</strong>  ：为什么设置了 <code>entryFileNames</code> 但文件名没有变化？</p>\n<p><strong>解决方案</strong>  ：</p>\n<ol>\n<li>检查是否同时设置了 <code>file</code> 配置</li>\n<li>确认是否在正确的 <code>output</code> 对象中配置</li>\n<li>确保输入配置是多个入口（多入口才会应用）</li>\n</ol>\n<p><strong>问题2</strong>  ：如何同时使用 hash 和固定文件名？</p>\n<p><strong>解决方案</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-attr">output</span>: {\n  <span class="hljs-attr">entryFileNames</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-string">`bundle-<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>.js`</span>\n}\n</code></pre>\n<p>理解这两个配置项的优先级和适用场景，可以帮助你更精确地控制构建输出结果，特别是在复杂的多入口打包场景中。</p>\n</div>'</script></body></html>