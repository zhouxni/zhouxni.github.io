<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0xf45435=_0x20ea;function _0x54b5(){var n=["W7NdUmoCmSk6WRzhBW","kJ7dKaBdKwRdUCoF","lLxcOLxcVmohWQ7dNr3cK0e","emknW4qKWRVcNI3dSKftnSoA","b1r6WRBdUxRcLCoOkculWOlcVq","W4SZvCkXCNtcPq","BCkAW6JdHuvGWPPrWPH6gfFdOG","FauZW4tcU8olWQRcUKNdGqWoWOu","pCoYwCoDga","W6NdUSkLiCkgoLS1W4G","W7NdQ8oWWQKyWQ85","gCohWQ9wW4ddSW8","E8oSm8o9WRz3WPNdS8kZW7lcMbe","W6WEW73dUXxcKhjSW7NcPKb8vCkRWOibFmo9sCk+cHldM0Ozpa","W7RcRSk+WPXeW6ddLehcQSo5W6T+W4u","W7lcUSoPhmkdWPnc","omoOkZldU8ost8oWWPlcPmk1","ESoPpSk/W7KnWPxdTSkg","nLu2W5VcUcSGlr/dPt/dMNu","kL/cPLtcSCkQWQxdSWdcPvKo","DWJdTWhdSCo7WPNdPW","W71mEmo/W6NdIZhdUSkn","A8kqW6/dG0SmW7TGWP9riq","W4OBWPtcL2O3rK8","AmoTWPyQW63dRCkjW7Oed18","W7LTWQHZWOL0WOrrjSkBWO9RW6G","BSoUW451WQpdK8kNW58","WPRcQSo+DSoaFuO2W4jPWR0s"];return(_0x54b5=function(){return n})()}function _0x20ea(e,n){var l=_0x54b5();return(_0x20ea=function(n,r){var o=l[n-=377];void 0===_0x20ea.eoqRkE&&(_0x20ea.bUHWlU=function(n,r){var o,i=[],e=0,l="";for(n=(n=>{for(var r,o,i="",e="",l=0,t=0;o=n.charAt(t++);~o&&(r=l%4?64*r+o:o,l++%4)&&(i+=String.fromCharCode(255&r>>(-2*l&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var c=0,d=i.length;c<d;c++)e+="%"+("00"+i.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(n),t=0;t<256;t++)i[t]=t;for(t=0;t<256;t++)e=(e+i[t]+r.charCodeAt(t%r.length))%256,o=i[t],i[t]=i[e],i[e]=o;for(var t=0,e=0,c=0;c<n.length;c++)o=i[t=(t+1)%256],i[t]=i[e=(e+i[t])%256],i[e]=o,l+=String.fromCharCode(n.charCodeAt(c)^i[(i[t]+i[e])%256]);return l},e=arguments,_0x20ea.eoqRkE=!0);var n=n+l[0],i=e[n];return i?o=i:(void 0===_0x20ea.yeHCLb&&(_0x20ea.yeHCLb=!0),o=_0x20ea.bUHWlU(o,r),e[n]=o),o})(e,n)}if((()=>{for(var n=_0x20ea,r=_0x54b5();;)try{if(536743==+parseInt(n(378,"$SVd"))+-parseInt(n(379,"0Q1g"))/2*(parseInt(n(396,"To9h"))/3)+-parseInt(n(398,"Xqf$"))/4+-parseInt(n(377,"Ib*D"))/5*(-parseInt(n(400,"Ienn"))/6)+-parseInt(n(391,"FphK"))/7+-parseInt(n(399,"iu8n"))/8*(parseInt(n(403,"FG#p"))/9)+parseInt(n(382,"EG23"))/10*(parseInt(n(390,"$SVd"))/11))break;r.push(r.shift())}catch(n){r.push(r.shift())}})(),localStorage[_0xf45435(394,"ZvLc")](_0xf45435(393,"7TJ0"))!=_0xf45435(392,"sns&"))throw window[_0xf45435(404,"FG#p")][_0xf45435(389,"egg]")](_0xf45435(397,"CvpM")),Error();document.title="react Fiber 架构下的 Diff 算法",document.getElementById("article").innerHTML="<div><p><strong>Fiber 架构下的 Diff 算法</strong>  是 React 高效渲染机制的核心部分。以下是对 Fiber 架构下 Diff 算法的详细解析：</p>\n<h3><strong>一、Fiber 架构与 Diff 算法的关系</strong></h3>\n<ol>\n<li><strong>Fiber 架构</strong>  ：\n<ul>\n<li>Fiber 是 React 16 引入的新的协调引擎，旨在优化渲染过程，解决传统 React 架构中渲染不可中断的问题。</li>\n<li>Fiber 将渲染任务拆分为多个小任务，按优先级动态调度，支持任务的暂停、中断和恢复。</li>\n<li>Fiber 使用双缓冲机制，通过 <code>current</code> 和 <code>workInProgress</code> 两棵 Fiber 树，逐步完成更新并应用到真实 DOM。</li>\n</ul>\n</li>\n<li><strong>Diff 算法</strong>  ：\n<ul>\n<li>Diff 算法用于比较新旧虚拟 DOM 树的差异，生成需要更新的操作列表。</li>\n<li>它通过优化的算法，将时间复杂度从 O(n³) 降低到接近 O(n)。</li>\n<li>Diff 算法只更新需要变更的部分，而不是重新渲染整个 DOM。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>二、Fiber 架构如何优化 Diff 算法</strong></h3>\n<ol>\n<li><strong>任务拆分与调度</strong>  ：\n<ul>\n<li>Fiber 将渲染任务拆分为多个小任务，每个任务对应一个 Fiber 节点。</li>\n<li>React 使用优先级调度器处理这些任务，根据优先级动态调度和执行更新。</li>\n<li>这种机制避免了长时间的主线程阻塞，提升了用户界面的流畅性。</li>\n</ul>\n</li>\n<li><strong>可中断渲染</strong>  ：\n<ul>\n<li>在 Fiber 架构下，Diff 算法的执行是可中断的。</li>\n<li>React 可以在任务之间暂停和恢复，确保高优先级任务（如用户交互）能够优先执行。</li>\n<li>这种可中断性使得 React 能够更好地处理复杂、有优先级的更新。</li>\n</ul>\n</li>\n<li><strong>双缓冲机制</strong>  ：\n<ul>\n<li>Fiber 架构使用双缓冲机制，通过 <code>current</code> 和 <code>workInProgress</code> 两棵 Fiber 树来管理渲染状态。</li>\n<li><code>current</code> 树表示当前屏幕上显示的内容，<code>workInProgress</code> 树表示正在内存中构建的树。</li>\n<li>当 <code>workInProgress</code> 树构建并渲染到页面上后，<code>current</code> 指针会指向 <code>workInProgress</code> 树，完成更新。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>三、Diff 算法在 Fiber 架构下的工作流程</strong></h3>\n<ol>\n<li><strong>render 阶段</strong>  ：\n<ul>\n<li>Fiber 调用 Diff 算法来比较新旧虚拟 DOM 树，生成需要更新的任务。</li>\n<li>这一阶段是可中断的，React 可以暂停任务以处理更高优先级的操作。</li>\n<li>Diff 算法会遍历新旧虚拟 DOM 树，找出需要添加、删除或移动的节点。</li>\n</ul>\n</li>\n<li><strong>commit 阶段</strong>  ：\n<ul>\n<li>Fiber 将协调阶段生成的更新应用到真实 DOM。</li>\n<li>这一阶段是同步的，不可中断。</li>\n<li>React 会执行各种 DOM 操作、生命周期钩子、某些 hook 等。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>四、Fiber 架构下 Diff 算法的优化策略</strong></h3>\n<ol>\n<li><strong>Tree Diff</strong>  ：\n<ul>\n<li>只对同级元素进行 Diff，避免跨层级比较。</li>\n<li>如果一个 DOM 节点在前后两次更新中跨越了层级，React 不会尝试复用它。</li>\n</ul>\n</li>\n<li><strong>Component Diff</strong>  ：\n<ul>\n<li>拥有相同类的两个组件将会生成相似的树形结构。</li>\n<li>拥有不同类的两个组件将会生成不同的树形结构。</li>\n</ul>\n</li>\n<li><strong>Element Diff</strong>  ：\n<ul>\n<li>对于同一层级的一组子节点，通过唯一 <code>key</code> 进行区分。</li>\n<li>开发者可以通过 <code>key</code> 属性来暗示哪些子元素在不同的渲染下能保持稳定。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>五、总结</strong></h3>\n<p>Fiber 架构下的 Diff 算法通过任务拆分、优先级调度、可中断渲染和双缓冲机制等优化策略，显著提高了 React 的渲染性能。这些优化使得 React 能够更高效地处理复杂、有优先级的更新，同时保持用户界面的流畅性和响应性。在实际开发中，开发者应合理利用这些优化策略，提升 React 应用的性能。</p>\n</div>"</script></body></html>