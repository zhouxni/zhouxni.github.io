<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3811(){var s=["sddcTmkMWOX0WR7dN8o/","DupdLmknfSokW7vhsIHXxc4","vCkyW50XrSkJW7W","W5ldGSkbWO7cOmoTW4/dJq","kZ5HWQGppCo8W5S","WRBdKvXZWQ4qDNO+EmkTW5q","s24MpmoIFSoUWPm","qtldVG7cJSkOWRpdJ8o0BtDLFG","ntlcMbJdQCkWWPNdJSkAFCkmW5RdRG","WR3cTqClW6pcQaKRd3tcKdtdPbfRW6tcRZWmxJhdGHpcSbvT","mSoYrmkroHVdMM4u","WPtcOHaEW6pdOw1Hda","eJn2BCkNj8oNWPddH8oiWOTR","WPvGWRldP3JcSGS","W6tcUgG+WPtcSgy","agRdHsG3","DwhdMKBcUmoHW4W","WR3dNZmwW4PvzNe","WPKlvSoJs8oqr1ddLSoCyKFcNq","vCouW6WhvCkOW6xcHG","lmoVWQDwzSk/WQ7dT8kjoCo1cG","C0pcTKrxW5T0jrddRrFdSCkO","WOJcPCo3damWfG","WRFdN1X8WQ4svwm/zCk6W4W","jCoQWQHsySooWP3dJSkGlCo2","W4hdJCoYv8khWQlcHmkwbqtdVL17","vColW7abW6XuW449mXKVWQS","aSkhCvxdGxetW50","WRrgWQxcHCkmc8k3iSk6BCkD","WOddN8kMW6RcOWO+v8oJtSoPxa","pHmHWQ1YW7ig","zry1uSklW5bUWQy"];return(_0x3811=function(){return s})()}function _0x7f0c(t,s){var e=_0x3811();return(_0x7f0c=function(s,a){var n=e[s-=446];void 0===_0x7f0c.goWsCt&&(_0x7f0c.OavAKr=function(s,a){var n,l=[],t=0,e="";for(s=(s=>{for(var a,n,l="",t="",e=0,c=0;n=s.charAt(c++);~n&&(a=e%4?64*a+n:n,e++%4)&&(l+=String.fromCharCode(255&a>>(-2*e&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var p=0,o=l.length;p<o;p++)t+="%"+("00"+l.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(t)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)t=(t+l[c]+a.charCodeAt(c%a.length))%256,n=l[c],l[c]=l[t],l[t]=n;for(var c=0,t=0,p=0;p<s.length;p++)n=l[c=(c+1)%256],l[c]=l[t=(t+l[c])%256],l[t]=n,e+=String.fromCharCode(s.charCodeAt(p)^l[(l[c]+l[t])%256]);return e},t=arguments,_0x7f0c.goWsCt=!0);var s=s+e[0],l=t[s];return l?n=l:(void 0===_0x7f0c.lJwNVv&&(_0x7f0c.lJwNVv=!0),n=_0x7f0c.OavAKr(n,a),t[s]=n),n})(t,s)}var _0xcbbd98=_0x7f0c;if((()=>{for(var s=_0x7f0c,a=_0x3811();;)try{if(315745==+parseInt(s(471,"P&2D"))*(parseInt(s(467,"mjlS"))/2)+-parseInt(s(465,"Kize"))/3*(-parseInt(s(451,"eUhB"))/4)+parseInt(s(449,"9UnH"))/5+parseInt(s(461,"Kize"))/6*(-parseInt(s(463,"d#eI"))/7)+parseInt(s(459,"cxzw"))/8*(-parseInt(s(460,"wZl("))/9)+parseInt(s(477,"vC31"))/10*(parseInt(s(474,"7X@r"))/11)+parseInt(s(464,"mfb%"))/12*(-parseInt(s(458,"mfb%"))/13))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0xcbbd98(454,"FHZG")](_0xcbbd98(452,"jc53"))!=_0xcbbd98(456,"[!fg"))throw window[_0xcbbd98(447,"!3KY")][_0xcbbd98(457,"9UnH")](_0xcbbd98(450,"jc53")),Error();document.title="react setState 在原生事件的表现",document.getElementById("article").innerHTML='<div><p>在 React 中，<code>setState</code> 的行为在 React 的事件系统和原生事件系统中表现不同。理解为什么 <code>setState</code> 在原生事件中是“同步”的（或更准确地说，表现得像同步），需要从 React 的批量更新机制和事件处理机制入手。</p>\n<hr>\n<h3><strong>一、React 的批量更新机制</strong></h3>\n<ol>\n<li><strong>React 事件系统中的批量更新</strong>  ：\n<ul>\n<li>在 React 的合成事件（Synthetic Event）系统中，<code>setState</code> 的调用是批量处理的。</li>\n<li>React 会将多次 <code>setState</code> 调用合并，并在事件回调执行完毕后，统一更新组件的状态。</li>\n<li>这种机制提高了性能，避免了不必要的重新渲染。</li>\n</ul>\n</li>\n<li><strong>原生事件中的行为</strong>  ：\n<ul>\n<li>在原生事件（如 <code>addEventListener</code> 注册的 DOM 事件）中，<code>setState</code> 的调用不会被 React 批量处理。</li>\n<li>每次调用 <code>setState</code> 都会立即触发状态更新和重新渲染（在异步更新的上下文中，表现为尽快更新）。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>二、为什么 <code>setState</code> 在原生事件中表现得像同步？</strong></h3>\n<ol>\n<li><strong>React 的更新队列</strong>  ：\n<ul>\n<li>React 使用一个更新队列来管理状态更新。</li>\n<li>在 React 的事件系统中，React 会将 <code>setState</code> 调用推入更新队列，并在事件回调执行完毕后，统一处理这些更新。</li>\n<li>在原生事件中，React 无法自动批量处理这些更新，因为原生事件不在 React 的控制范围内。</li>\n</ul>\n</li>\n<li><strong>原生事件的执行环境</strong>  ：\n<ul>\n<li>原生事件是在浏览器的事件循环中直接执行的，React 无法拦截和批量处理这些事件。</li>\n<li>因此，每次调用 <code>setState</code> 都会立即触发更新流程（尽管实际的 DOM 更新仍然是异步的，但状态更新和重新渲染的流程会尽快启动）。</li>\n</ul>\n</li>\n<li><strong>异步更新的本质</strong>  ：\n<ul>\n<li>即使在原生事件中，<code>setState</code> 仍然是异步的，但它的异步性体现在状态合并和 DOM 更新的时机上，而不是在调用 <code>setState</code> 后的立即执行上。</li>\n<li>在原生事件中，<code>setState</code> 调用后，React 会尽快安排重新渲染，但不会立即更新 DOM。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>三、示例说明</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {\n    <span class="hljs-variable language_">super</span>(props);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);\n  }\n\n  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-comment">// 注册原生事件</span>\n    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;nativeClick&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleNativeClick</span>);\n  }\n\n  <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-comment">// 移除原生事件</span>\n    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;nativeClick&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleNativeClick</span>);\n  }\n\n  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-comment">// React 事件系统中的 setState</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> });\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;React event count:&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>); <span class="hljs-comment">// 异步更新，可能还是旧值</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> });\n  }\n\n  handleNativeClick = <span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-comment">// 原生事件中的 setState</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> });\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Native event count:&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>); <span class="hljs-comment">// 异步更新，但表现得像同步</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> });\n  };\n\n  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> (\n      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span>&gt;</span>React Event<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> document.dispatchEvent(new Event(&#x27;nativeClick&#x27;))}&gt;Native Event<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: {this.state.count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<h4><strong>解释</strong>  ：</h4>\n<ul>\n<li><strong>React 事件</strong>  ：<code>handleClick</code> 中的 <code>setState</code> 调用被批量处理，<code>console.log</code> 可能打印旧值，因为状态更新尚未完成。</li>\n<li><strong>原生事件</strong>  ：<code>handleNativeClick</code> 中的 <code>setState</code> 调用不会被批量处理，<code>console.log</code> 会尽快反映状态更新（尽管 DOM 更新仍然是异步的）。</li>\n</ul>\n<hr>\n<h3><strong>四、总结</strong></h3>\n<ul>\n<li><strong>React 事件系统</strong>  ：<code>setState</code> 调用被批量处理，提高了性能。</li>\n<li><strong>原生事件</strong>  ：<code>setState</code> 调用不会被批量处理，表现得像同步，但实际的 DOM 更新仍然是异步的。</li>\n<li><strong>异步更新的本质</strong>  ：<code>setState</code> 的异步性体现在状态合并和 DOM 更新的时机上，而不是在调用 <code>setState</code> 后的立即执行上。</li>\n</ul>\n<p>理解这些机制有助于开发者更好地预测组件的行为，尤其是在处理复杂的事件和状态更新时。</p>\n</div>'</script></body></html>