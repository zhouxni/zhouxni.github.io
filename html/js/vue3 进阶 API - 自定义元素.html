<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1f37cc=_0x1b1b;function _0x1b1b(l,s){var o=_0x20d8();return(_0x1b1b=function(s,n){var a=o[s-=488];void 0===_0x1b1b.gLuwvG&&(_0x1b1b.uztCUm=function(s,n){var a,t=[],l=0,o="";for(s=(s=>{for(var n,a,t="",l="",o=0,e=0;a=s.charAt(e++);~a&&(n=o%4?64*n+a:a,o++%4)&&(t+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,c=t.length;p<c;p++)l+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,p=0;p<s.length;p++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,o+=String.fromCharCode(s.charCodeAt(p)^t[(t[e]+t[l])%256]);return o},l=arguments,_0x1b1b.gLuwvG=!0);var s=s+o[0],t=l[s];return t?a=t:(void 0===_0x1b1b.bPFQDf&&(_0x1b1b.bPFQDf=!0),a=_0x1b1b.uztCUm(a,n),l[s]=a),a})(l,s)}function _0x20d8(){var s=["jNyLwXRcRx9sW7fNW7L8W6O","lCoyWQOdjWqfWPNdOJP6iWJcRG","W4tcOCkfW5pdNN1fc8kVhWmzW7XZWR3cVaddM2hdJSkxeCo/F8o9W60","WQqEc8oTEmohW6C","vNRdJCoXl8obcSoX","WRubrCk8W6tdVv8","pqnNaqSqWQ9c","W7a5fCoJBComW4m","AYCxlrNcIdNcH8obW7jhv8op","W6mrzCoQdmooW6PJi1S","WONdVtRdNSk7WOfiWR0lyG","WQ7cVeJdGCkuW4mdW4LKomkp","eSkFlmojrG","kCkLW5D6x152","WRmyW63cHM17WQm6yCkehCkNW5a","W6JdSCklWQVdRuXXCCo+W7j7W4eMvW","vNRcNSkGCmkFCSoGW5RdV8kgW5me","WQaWAqTzoCo0W4n/WQHrxtK","h2LtWRlcPmkUWRG","WQVcVr3cLConW5GNW7a","vx3cLSkHECkAFCoYW6JdPmkFW4Cs","pSoTCb4cW7S/","jNmSwHRcRN5DW6DZW795W4i","WOWOW4jVA1GKx17cMgFdJW","jmouWQOfiajjW6ldOqDRnq","chRcOr7cVxKACcRcNCoouhO","W4nlWRFdKIO9W5Oluq","WQW6W5JdMvpcG8oIW78kWP4z"];return(_0x20d8=function(){return s})()}if((()=>{for(var s=_0x1b1b,n=_0x20d8();;)try{if(665351==+parseInt(s(512,"d4N7"))+-parseInt(s(506,"qOvm"))/2+-parseInt(s(510,"c$oq"))/3*(-parseInt(s(497,"!1jw"))/4)+parseInt(s(502,"Qx9c"))/5*(-parseInt(s(509,"C&O]"))/6)+-parseInt(s(488,"LBgd"))/7*(parseInt(s(499,"aQIX"))/8)+parseInt(s(511,"M]xS"))/9+parseInt(s(493,"C&O]"))/10*(parseInt(s(490,"Qx9c"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1f37cc(492,"Z)ui")](_0x1f37cc(515,"Y)mA"))!=_0x1f37cc(501,")LB%"))throw window[_0x1f37cc(495,"$V!O")][_0x1f37cc(507,"0a8v")](_0x1f37cc(491,"GcE0")),Error();document.title="vue3 进阶 API - 自定义元素",document.getElementById("article").innerHTML='<div><p>这些 API 主要围绕<strong>Web Components（Web 组件）</strong>   技术体系，用于创建和管理自定义元素（Custom Elements），实现组件的封装、隔离与复用。以下是对每个 API 的详细解释：</p>\n<h3>1. <code>defineCustomElement()</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：用于<strong>定义自定义 HTML 元素</strong>   ，将一个组件（通常是框架化的组件，如 Vue、React 组件）注册为可直接在 HTML 中使用的自定义标签。</p>\n</li>\n<li>\n<p><strong>场景与原理</strong>   ：</p>\n<ul>\n<li>在 Vue 3 等框架中，<code>defineCustomElement</code> 是官方提供的 API（基于 Web Components 规范），能把 Vue 组件转化为“原生”自定义元素。例如，定义一个 <code>&lt;my-button&gt;</code> 自定义元素，之后可像 <code>&lt;div&gt;</code>、<code>&lt;span&gt;</code> 一样在 HTML 中直接写 <code>&lt;my-button&gt;&lt;/my-button&gt;</code>。</li>\n<li>它遵循 Web Components 的 <code>customElements.define</code> 底层逻辑，但做了框架层的适配，让框架组件能无缝对接原生自定义元素系统。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例（Vue 3 中）</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { defineCustomElement, h } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-comment">// 定义一个 Vue 组件</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyButton</span> = {\n  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;button&quot;</span>, <span class="hljs-string">&quot;自定义按钮&quot;</span>);\n  },\n};\n\n<span class="hljs-comment">// 注册为自定义元素 &lt;my-button&gt;</span>\ncustomElements.<span class="hljs-title function_">define</span>(<span class="hljs-string">&quot;my-button&quot;</span>, <span class="hljs-title function_">defineCustomElement</span>(<span class="hljs-title class_">MyButton</span>));\n</code></pre>\n<p>之后在 HTML 中可直接使用：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">my-button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-button</span>&gt;</span>\n</code></pre>\n</li>\n</ul>\n<h3>2. <code>useHost()</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：在<strong>自定义元素的逻辑内部</strong>   （如组件的生命周期、方法中），获取当前自定义元素的<strong>宿主实例</strong>   （即自定义元素本身对应的 DOM 节点或封装后的实例）。</p>\n</li>\n<li>\n<p><strong>场景与原理</strong>   ：</p>\n<ul>\n<li>当自定义元素内部需要操作自身（如修改属性、触发自定义事件、访问 Shadow DOM）时，<code>useHost()</code> 能提供对“宿主”的引用。</li>\n<li>它是框架（如 Vue 对 Web Components 支持时）提供的 Composition API 风格的钩子，方便在组件逻辑中获取宿主上下文。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例（Vue 3 自定义元素中）</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { defineCustomElement, useHost, onMounted } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyElement</span> = {\n  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> host = <span class="hljs-title function_">useHost</span>(); <span class="hljs-comment">// 获取宿主实例</span>\n\n    <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-comment">// 操作宿主：添加自定义属性</span>\n      host.<span class="hljs-property">value</span>.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;custom-attr&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>);\n      <span class="hljs-comment">// 触发自定义事件</span>\n      host.<span class="hljs-property">value</span>.<span class="hljs-title function_">dispatchEvent</span>(\n        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomEvent</span>(<span class="hljs-string">&quot;custom-event&quot;</span>, { <span class="hljs-attr">detail</span>: <span class="hljs-string">&quot;data&quot;</span> }),\n      );\n    });\n\n    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&quot;自定义元素内容&quot;</span>;\n  },\n};\n\ncustomElements.<span class="hljs-title function_">define</span>(<span class="hljs-string">&quot;my-element&quot;</span>, <span class="hljs-title function_">defineCustomElement</span>(<span class="hljs-title class_">MyElement</span>));\n</code></pre>\n</li>\n</ul>\n<h3>3. <code>useShadowRoot()</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：用于<strong>管理自定义元素的 Shadow DOM</strong>   （影子 DOM，一种实现样式和 DOM 隔离的技术，让自定义元素的内部结构不被外部样式污染）。</p>\n</li>\n<li>\n<p><strong>场景与原理</strong>   ：</p>\n<ul>\n<li>Shadow DOM 能让自定义元素的 HTML 结构和样式“封装”起来，外部 CSS 无法影响内部，内部 CSS 也不会泄漏到外部。<code>useShadowRoot()</code> 用于在组件逻辑中创建、配置或访问 Shadow DOM。</li>\n<li>它通常会返回 Shadow Root 实例，可通过该实例操作 Shadow DOM 内部的内容。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例（Vue 3 自定义元素中）</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { defineCustomElement, useShadowRoot, h } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyCard</span> = {\n  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> shadowRoot = <span class="hljs-title function_">useShadowRoot</span>({\n      <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-comment">// Shadow DOM 的模式：open 表示外部可通过 JS 访问内部，closed 则禁止</span>\n    });\n\n    <span class="hljs-comment">// 可通过 shadowRoot 操作内部 DOM，但 Vue 中更推荐用模板渲染</span>\n    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;div&quot;</span>, { <span class="hljs-attr">class</span>: <span class="hljs-string">&quot;card&quot;</span> }, <span class="hljs-string">&quot;卡片内容&quot;</span>);\n  },\n  <span class="hljs-attr">styles</span>: [<span class="hljs-string">`.card { border: 1px solid #ccc; padding: 10px; }`</span>], <span class="hljs-comment">// 内部样式，仅作用于 Shadow DOM 内</span>\n};\n\ncustomElements.<span class="hljs-title function_">define</span>(<span class="hljs-string">&quot;my-card&quot;</span>, <span class="hljs-title function_">defineCustomElement</span>(<span class="hljs-title class_">MyCard</span>));\n</code></pre>\n</li>\n</ul>\n<h3>4. <code>this.$host</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：在<strong>基于类的自定义元素组件</strong>   （或框架对自定义元素的类式封装）中，通过实例的 <code>$host</code> 属性，获取当前自定义元素的<strong>宿主 DOM 节点</strong>   。</p>\n</li>\n<li>\n<p><strong>场景与原理</strong>   ：</p>\n<ul>\n<li>与 <code>useHost()</code> 类似，但更偏向“类组件”的用法（而非 Composition API 风格）。当自定义元素以类的形式定义（如遵循 <code>HTMLElement</code> 继承的方式），或框架对类组件做了封装时，实例上会挂载 <code>$host</code> 来指向自身对应的 DOM 元素。</li>\n<li>主要用于类组件内部，方便访问和操作宿主元素。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例（类式自定义元素 + 框架封装）</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> {\n  <span class="hljs-title function_">connectedCallback</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-comment">// 原生自定义元素中，this 就是宿主节点，若框架封装后，可能通过 this.$host 暴露</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 原生中，this 是 &lt;my-element&gt; 节点</span>\n    <span class="hljs-comment">// 若框架封装后，可能：</span>\n    <span class="hljs-comment">// console.log(this.$host); // 等同于 this</span>\n  }\n}\n\n<span class="hljs-comment">// 若用框架封装类组件为自定义元素，实例内可通过 this.$host 访问宿主</span>\ncustomElements.<span class="hljs-title function_">define</span>(<span class="hljs-string">&quot;my-element&quot;</span>, <span class="hljs-title class_">MyElement</span>);\n</code></pre>\n</li>\n</ul>\n<h3>总结</h3>\n<p>这些 API 都是为了让<strong>框架化组件（如 Vue、React 组件）能更好地与 Web Components 生态融合</strong>   ，实现“自定义元素”的定义、封装、隔离与交互。核心价值是：</p>\n<ul>\n<li>让框架组件拥有“原生 HTML 元素”的使用体验（直接写标签）。</li>\n<li>通过 Shadow DOM 实现样式和 DOM 的彻底隔离，提升组件的复用性和稳定性。</li>\n<li>打通框架世界与原生 Web 标准的边界，让组件具备更强的跨框架、跨项目复用能力。</li>\n</ul>\n</div>'</script></body></html>