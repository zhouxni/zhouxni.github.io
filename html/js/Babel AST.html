<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3e7a(l,s){var p=_0x1ad4();return(_0x3e7a=function(s,n){var a=p[s-=375];void 0===_0x3e7a.PFTMqK&&(_0x3e7a.SAECXm=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,o=0;a=s.charAt(o++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,e=t.length;c<e;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),o=0;o<256;o++)t[o]=o;for(o=0;o<256;o++)l=(l+t[o]+n.charCodeAt(o%n.length))%256,a=t[o],t[o]=t[l],t[l]=a;for(var o=0,l=0,c=0;c<s.length;c++)a=t[o=(o+1)%256],t[o]=t[l=(l+t[o])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(c)^t[(t[o]+t[l])%256]);return p},l=arguments,_0x3e7a.PFTMqK=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x3e7a.CipZns&&(_0x3e7a.CipZns=!0),a=_0x3e7a.SAECXm(a,n),l[s]=a),a})(l,s)}function _0x1ad4(){var s=["r2q3a2RdKSkk","x8kVmmo2WRfEb0VdQWy","h8k4WQ8TtuVdJmkoW7G6D0ddLmk/","qtyAW5ddQSkSW5zu","at/cHmovWOldJSo+WQyzfW","cthcJSoyW4xcLmkLW4a3pmowxSkkW6G","WQlcKrHwWQbDi8kSW7GitWldHq","WR0tqd/dPJeNhJNdNCoEWRu9","iaitmWNdNeVcTaJdG1m8","imoLv8kOW73dPSoIvwLaxCof","WOLloSoflx3dINXq","xmo+W61Mdq","W4D0WRVdUCoAhmog","Fx9/W57cVSkQn3/cVmkIWPVdG2K","t3xdG8kjnSoSu8kG","hCk8WQyHreddImkpW7yfwKBdTmkG","vMZdU0pdQsDI","wSk2W7/cTvpcV8on","vgJdLhldTrT8","W6ddUSoRW5rKW51rW5ddNspcOWtcPGW","sL4nW63dO8kOW4e","cSo5yCkUWRjvaNm","W6tdHvOiW7agFW","cSkLWO5FrCkilhldHG","W45qW6u5WOz1W4VdG8o1cLlcJSoQ","cJ7dHCk7WPtdQ8o1WPG","WR3cV2W6rgzpwhm","u8oNW4X7zmo4tH7dJZ7dSvDMhmkBeYlcJmoFW5RdRColWQlcMSoOCG","W4FdSCobWPpcHmojpee","hr3dQexcU8oSWR3dVeCSW7BdMtG","umoCrLJcKcVdMHxdI8o3WQtdIv8","kh/dOebcW7xcQa"];return(_0x1ad4=function(){return s})()}var _0x42906d=_0x3e7a;if((()=>{for(var s=_0x3e7a,n=_0x1ad4();;)try{if(955272==-parseInt(s(380,"AX^G"))*(-parseInt(s(402,"^&bj"))/2)+parseInt(s(385,"k##P"))/3*(-parseInt(s(391,"mfZt"))/4)+parseInt(s(377,"!V4%"))/5*(parseInt(s(395,"dw!)"))/6)+parseInt(s(404,"VrM3"))/7*(-parseInt(s(376,")@dn"))/8)+parseInt(s(379,"ks0B"))/9*(-parseInt(s(394,"*!!v"))/10)+-parseInt(s(387,"036Z"))/11*(-parseInt(s(393,"HtOu"))/12)+parseInt(s(398,"#geh"))/13)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x42906d(396,"3kM*")](_0x42906d(389,"#y%W"))!=_0x42906d(390,"*!!v"))throw window[_0x42906d(400,"AX^G")][_0x42906d(401,"k##P")](_0x42906d(406,"^&bj")),Error();document.title="Babel AST",document.getElementById("article").innerHTML='<div><h3><strong>Babel AST（抽象语法树）是什么？</strong></h3>\n<p><strong>Babel AST（Abstract Syntax Tree，抽象语法树）</strong>   是 Babel 在编译 JavaScript 代码时生成的一种树状数据结构，用于表示源代码的语法结构。它是 Babel 进行代码转换（如 ES6+ → ES5）、静态分析（如 linting）和优化（如 tree-shaking）的核心数据结构。</p>\n<hr>\n<h2><strong>1. AST 的基本概念</strong></h2>\n<h3><strong>(1) 什么是 AST？</strong></h3>\n<ul>\n<li><strong>AST（抽象语法树）</strong>   是源代码的<strong>结构化表示</strong>   ，它以树的形式描述代码的语法结构（如变量声明、函数调用、循环等），但不包含无关细节（如空格、分号、注释等）。</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;\n</code></pre>\n对应的 AST（简化版）：<pre><code class="language-json"><span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;VariableDeclaration&quot;</span><span class="hljs-punctuation">,</span>\n  <span class="hljs-attr">&quot;declarations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>\n    <span class="hljs-punctuation">{</span>\n      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;VariableDeclarator&quot;</span><span class="hljs-punctuation">,</span>\n      <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sum&quot;</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>\n      <span class="hljs-attr">&quot;init&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>\n        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ArrowFunctionExpression&quot;</span><span class="hljs-punctuation">,</span>\n        <span class="hljs-attr">&quot;params&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>\n          <span class="hljs-punctuation">{</span> <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a&quot;</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>\n          <span class="hljs-punctuation">{</span> <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;b&quot;</span> <span class="hljs-punctuation">}</span>\n        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>\n        <span class="hljs-attr">&quot;body&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>\n          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;BinaryExpression&quot;</span><span class="hljs-punctuation">,</span>\n          <span class="hljs-attr">&quot;operator&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;+&quot;</span><span class="hljs-punctuation">,</span>\n          <span class="hljs-attr">&quot;left&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a&quot;</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>\n          <span class="hljs-attr">&quot;right&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Identifier&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;b&quot;</span> <span class="hljs-punctuation">}</span>\n        <span class="hljs-punctuation">}</span>\n      <span class="hljs-punctuation">}</span>\n    <span class="hljs-punctuation">}</span>\n  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>\n  <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;const&quot;</span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n</li>\n</ul>\n<h3><strong>(2) AST 的作用</strong></h3>\n<ul>\n<li><strong>代码转换</strong>   ：Babel 通过修改 AST 将新语法（如 <code>const</code>、<code>箭头函数</code>）转换为旧语法（如 <code>var</code>、<code>function</code>）。</li>\n<li><strong>静态分析</strong>   ：ESLint、Prettier 等工具通过遍历 AST 检查代码风格或潜在错误。</li>\n<li><strong>代码生成</strong>   ：将修改后的 AST 转换回字符串形式的代码。</li>\n</ul>\n<hr>\n<h2><strong>2. Babel AST 的核心结构</strong></h2>\n<p>Babel 的 AST 遵循 <strong><a href="https://github.com/estree/estree" target="_blank">ESTree</a> 规范</strong>   ，并扩展了一些额外节点类型（如 <code>JSX</code>、<code>TypeScript</code> 支持）。<br>\n主要特点：</p>\n<ol>\n<li>\n<p><strong>节点类型（Node Types）</strong>   ：</p>\n<ul>\n<li>每个 AST 节点都有一个 <code>type</code> 字段，表示语法类型（如 <code>VariableDeclaration</code>、<code>FunctionExpression</code>）。</li>\n<li>常见类型：\n<ul>\n<li><code>Identifier</code>（标识符，如变量名 <code>sum</code>）</li>\n<li><code>Literal</code>（字面量，如 <code>&quot;hello&quot;</code>、<code>42</code>）</li>\n<li><code>BinaryExpression</code>（二元表达式，如 <code>a + b</code>）</li>\n<li><code>CallExpression</code>（函数调用，如 <code>console.log()</code>）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>遍历与修改</strong>   ：</p>\n<ul>\n<li>Babel 提供 <code>@babel/traverse</code> 工具遍历 AST，并支持<strong>增删改查节点</strong>   。</li>\n<li>示例：将 <code>const</code> 改为 <code>var</code>：<pre><code class="language-javascript"><span class="hljs-title function_">traverse</span>(ast, {\n  <span class="hljs-title class_">VariableDeclaration</span>(path) {\n    <span class="hljs-keyword">if</span> (path.<span class="hljs-property">node</span>.<span class="hljs-property">kind</span> === <span class="hljs-string">&quot;const&quot;</span>) {\n      path.<span class="hljs-property">node</span>.<span class="hljs-property">kind</span> = <span class="hljs-string">&quot;var&quot;</span>; <span class="hljs-comment">// 修改节点</span>\n    }\n  },\n});\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>代码生成</strong>   ：</p>\n<ul>\n<li>使用 <code>@babel/generator</code> 将 AST 转换回代码：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { code } = <span class="hljs-title function_">generate</span>(ast);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(code); <span class="hljs-comment">// 输出转换后的代码</span>\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2><strong>3. Babel 处理流程（AST 如何参与？）</strong></h2>\n<p>Babel 的工作流程分为三步，AST 是核心中间产物：</p>\n<ol>\n<li>\n<p><strong>解析（Parsing）</strong>   ：<br>\n使用 <code>@babel/parser</code> 将源代码字符串转换为 AST。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> ast = parser.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&quot;const a = 1;&quot;</span>, { <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;module&quot;</span> });\n</code></pre>\n</li>\n<li>\n<p><strong>转换（Transformation）</strong>   ：<br>\n通过插件（如 <code>@babel/plugin-transform-arrow-functions</code>）修改 AST。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 将箭头函数转为普通函数</span>\n<span class="hljs-title function_">traverse</span>(ast, {\n  <span class="hljs-title class_">ArrowFunctionExpression</span>(path) {\n    path.<span class="hljs-title function_">replaceWith</span>(<span class="hljs-comment">/* 新节点 */</span>);\n  },\n});\n</code></pre>\n</li>\n<li>\n<p><strong>生成（Generation）</strong>   ：<br>\n使用 <code>@babel/generator</code> 从 AST 生成目标代码。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { code } = <span class="hljs-title function_">generate</span>(ast);\n</code></pre>\n</li>\n</ol>\n<hr>\n<h2><strong>4. 如何查看代码的 AST？</strong></h2>\n<h3><strong>(1) 使用 AST Explorer</strong></h3>\n<p>访问 <a href="https://astexplorer.net/" target="_blank">https://astexplorer.net/</a>，选择 <code>@babel/parser</code>，输入代码即可实时查看 AST。</p>\n<h3><strong>(2) 通过 Babel 生成</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { parse } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);\n<span class="hljs-keyword">const</span> code = <span class="hljs-string">&quot;const sum = (a, b) =&gt; a + b;&quot;</span>;\n<span class="hljs-keyword">const</span> ast = <span class="hljs-title function_">parse</span>(code, { <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;module&quot;</span> });\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ast);\n</code></pre>\n<hr>\n<h2><strong>5. 实际应用场景</strong></h2>\n<ol>\n<li><strong>自定义 Babel 插件</strong>   ：<br>\n通过操作 AST 实现特殊转换（如自动注入日志代码）。</li>\n<li><strong>代码格式化工具</strong>   ：<br>\nPrettier 通过 AST 统一代码风格。</li>\n<li><strong>语法检查</strong>   ：<br>\nESLint 基于 AST 分析代码规范。</li>\n<li><strong>Tree-shaking</strong>   ：<br>\nWebpack 利用 AST 删除未使用的代码（如 <code>dead code elimination</code>）。</li>\n</ol>\n<hr>\n<h2><strong>总结</strong></h2>\n<ul>\n<li><strong>Babel AST</strong>   是 JavaScript 代码的<strong>结构化表示</strong>   ，Babel 通过它实现语法转换。</li>\n<li><strong>核心流程</strong>   ：源代码 → AST → 修改 AST → 生成新代码。</li>\n<li><strong>关键工具</strong>   ：<code>@babel/parser</code>（解析）、<code>@babel/traverse</code>（遍历）、<code>@babel/generator</code>（生成）。</li>\n<li><strong>应用场景</strong>   ：代码转换、静态分析、优化等。</li>\n</ul>\n<p>通过理解 AST，你可以更深入地掌握 Babel、ESLint 等工具的工作原理，甚至编写自己的代码处理工具！</p>\n</div>'</script></body></html>