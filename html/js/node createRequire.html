<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4e73(){var s=["cCodW7HbW6xcTG4a","s8kEzSkEW53dT8kZxCopW4JcVSklCa","oSobCcmcW6lcQZpdVSo0W5G","a8oxWRxcISo1WONcScBcI8kKF8kMgq","W4VdOSopoH9Hja","W4dcQ8kzzConcSkMo8o9aCo7W53dPa","dCkAW7xcNeFdId9NW6NcJxe","WQBcVCogBveRW4C","W6BdMehdOSkVW4jXBSo5zq","cCkqW7tcLuBcMLTjW7tcIvpcPMi","WO/dLmkUW7SuWRux","fmoag8o/DZxdG8orxmoJw0mXiSkqp8oGWO3cMhxdNsiCgwbv","WRDhuCoaWOG","rWrXsmkeWRDM","CJ9+bCkpW7m6jSoigbhdR8oJ","WQZdISoGsK4PW6JcOG","ggv7ESkjWPL/","WR5FW7DhW50fz8oyxq","rfaskCoYWPvCWOT7W6LD","W4NcJJWUW4OHW6G","WOCCwmoJWQddSZm6DHFcP1ft","FqNcKmkSwSkxW4BdHSkHoCol","umkyWQ0xW6pcTqWOWQGZ","zCknW59nW7ZcPKFcUCkmiSk2nrK","uIS2WR1ad8kD","W69sWQ7cKKH6WPpcRCkH","DSkBW5zMWRLWnL0","WPzYWQJcMvbfWPq","WPylbCodWOuXWRSnW6xcLSkTe1S","amowWRxdP8kvW5/dPr7cPW","W6mEomkbnSo/B8kMWPJdPJa"];return(_0x4e73=function(){return s})()}var _0x5c95c9=_0x39c2;function _0x39c2(l,s){var p=_0x4e73();return(_0x39c2=function(s,n){var a=p[s-=461];void 0===_0x39c2.nbgTep&&(_0x39c2.fDhHYz=function(s,n){var a,e=[],l=0,p="";for(s=(s=>{for(var n,a,e="",l="",p=0,c=0;a=s.charAt(c++);~a&&(n=p%4?64*n+a:a,p++%4)&&(e+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,r=e.length;t<r;t++)l+="%"+("00"+e.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(l)})(s),c=0;c<256;c++)e[c]=c;for(c=0;c<256;c++)l=(l+e[c]+n.charCodeAt(c%n.length))%256,a=e[c],e[c]=e[l],e[l]=a;for(var c=0,l=0,t=0;t<s.length;t++)a=e[c=(c+1)%256],e[c]=e[l=(l+e[c])%256],e[l]=a,p+=String.fromCharCode(s.charCodeAt(t)^e[(e[c]+e[l])%256]);return p},l=arguments,_0x39c2.nbgTep=!0);var s=s+p[0],e=l[s];return e?a=e:(void 0===_0x39c2.WQpbUs&&(_0x39c2.WQpbUs=!0),a=_0x39c2.fDhHYz(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x39c2,n=_0x4e73();;)try{if(581601==+parseInt(s(473,"Iff8"))*(parseInt(s(467,"9cS6"))/2)+parseInt(s(488,"aT%y"))/3*(parseInt(s(489,"D5y!"))/4)+-parseInt(s(468,"tU60"))/5+-parseInt(s(481,"fr^]"))/6*(-parseInt(s(474,"]q6u"))/7)+-parseInt(s(476,"PsbM"))/8*(parseInt(s(464,"ZBw4"))/9)+parseInt(s(461,"5%$J"))/10*(-parseInt(s(462,"^kgF"))/11)+parseInt(s(486,"8CPi"))/12*(parseInt(s(480,"i(dm"))/13))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5c95c9(490,"TKX5")](_0x5c95c9(465,"9cS6"))!=_0x5c95c9(483,"7)#I"))throw window[_0x5c95c9(471,"^kgF")][_0x5c95c9(487,"PsHo")](_0x5c95c9(482,"Zfr7")),Error();document.title="node createRequire",document.getElementById("article").innerHTML='<div><p><code>require(\'module\').createRequire()</code> 是 Node.js 提供的高级模块解析方法，用于创建具有自定义解析规则的 <code>require</code> 函数。下面从底层原理到应用场景的深度解析：</p>\n<hr>\n<h3>一、核心机制解析</h3>\n<h4>1. <strong>工作原理</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { createRequire } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;module&#x27;</span>);\n<span class="hljs-keyword">const</span> targetRequire = <span class="hljs-title function_">createRequire</span>(<span class="hljs-string">&#x27;/project/package.json&#x27;</span>);\n\n<span class="hljs-comment">// 等效于：</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">targetRequire</span> = (<span class="hljs-params">id</span>) =&gt; {\n  <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(id, {\n    <span class="hljs-attr">paths</span>: [path.<span class="hljs-title function_">dirname</span>(<span class="hljs-string">&#x27;/project/package.json&#x27;</span>)] <span class="hljs-comment">// 关键点</span>\n  }));\n};\n</code></pre>\n<h4>2. **路径解析规则</h4>\n<ul>\n<li><strong>优先从目标目录的 <code>node_modules</code> 查找</strong></li>\n<li><strong>遵循 Node.js 标准模块查找算法</strong>  （包括 <code>main</code>/<code>exports</code> 字段）</li>\n<li><strong>支持 <code>require.resolve</code> 的所有参数</strong></li>\n</ul>\n<hr>\n<h3>二、与常规 require 的差异对比</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>常规 require</th>\n<th>createRequire 创建的 require</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>查找起点</td>\n<td>当前文件所在目录</td>\n<td>指定 package.json 所在目录</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>当前项目依赖</td>\n<td>多项目/子项目依赖隔离</td>\n</tr>\n<tr>\n<td>性能影响</td>\n<td>无额外开销</td>\n<td>轻微性能损耗（需重建解析上下文）</td>\n</tr>\n<tr>\n<td>缓存机制</td>\n<td>共享全局缓存</td>\n<td>共享全局缓存</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>三、关键技术应用场景</h3>\n<h4>1. <strong>多项目构建隔离</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// builder.js</span>\n<span class="hljs-keyword">const</span> builder = {\n  <span class="hljs-title function_">build</span>(<span class="hljs-params">projectPath</span>) {\n    <span class="hljs-keyword">const</span> localRequire = <span class="hljs-title function_">createRequire</span>(<span class="hljs-string">`<span class="hljs-subst">${projectPath}</span>/package.json`</span>);\n    <span class="hljs-keyword">const</span> webpack = <span class="hljs-title function_">localRequire</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>); <span class="hljs-comment">// 确保使用项目自身的webpack</span>\n    <span class="hljs-comment">// ...构建逻辑</span>\n  }\n}\n</code></pre>\n<h4>2. <strong>动态加载器配置（Webpack）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 动态获取项目专属loader</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">getLoader</span> = (<span class="hljs-params">projectPath, loaderName</span>) =&gt; {\n  <span class="hljs-keyword">const</span> localRequire = <span class="hljs-title function_">createRequire</span>(<span class="hljs-string">`<span class="hljs-subst">${projectPath}</span>/package.json`</span>);\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">loader</span>: localRequire.<span class="hljs-title function_">resolve</span>(loaderName),\n    <span class="hljs-attr">options</span>: { <span class="hljs-comment">/* ... */</span> }\n  };\n};\n</code></pre>\n<h4>3. <strong>安全沙箱</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 创建隔离的require环境</span>\n<span class="hljs-keyword">const</span> safeRequire = <span class="hljs-title function_">createRequire</span>(<span class="hljs-string">&#x27;/sandbox/package.json&#x27;</span>);\n<span class="hljs-keyword">const</span> untrustedCode = <span class="hljs-title function_">safeRequire</span>(<span class="hljs-string">&#x27;./user-code.js&#x27;</span>); <span class="hljs-comment">// 限制访问范围</span>\n</code></pre>\n<hr>\n<h3>四、常见问题解决方案</h3>\n<h4>1. <strong>路径处理陷阱</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 错误示例（Windows路径问题）</span>\n<span class="hljs-title function_">createRequire</span>(<span class="hljs-string">&#x27;C:\\\\project\\\\package.json&#x27;</span>); \n\n<span class="hljs-comment">// 正确做法</span>\n<span class="hljs-title function_">createRequire</span>(path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;C:/project/package.json&#x27;</span>));\n</code></pre>\n<h4>2. <strong>缓存污染处理</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 强制刷新模块缓存</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">freshRequire</span>(<span class="hljs-params">modulePath</span>) {\n  <span class="hljs-keyword">delete</span> <span class="hljs-built_in">require</span>.<span class="hljs-property">cache</span>[<span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(modulePath)];\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">localRequire</span>(modulePath);\n}\n</code></pre>\n<h4>3. <strong>TypeScript 支持</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-comment">// 类型声明扩展</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;module&#x27;</span> {\n  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RequireFunction</span> {\n    <span class="hljs-title function_">resolve</span>(<span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;\n    (<span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">any</span>;\n  }\n  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRequire</span>(<span class="hljs-params"><span class="hljs-attr">filename</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">RequireFunction</span>;\n}\n</code></pre>\n<hr>\n<h3>五、性能优化方案</h3>\n<h4>1. <strong>持久化 Require 实例</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 避免重复创建</span>\n<span class="hljs-keyword">const</span> requireCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">getProjectRequire</span>(<span class="hljs-params">projectPath</span>) {\n  <span class="hljs-keyword">if</span> (!requireCache.<span class="hljs-title function_">has</span>(projectPath)) {\n    requireCache.<span class="hljs-title function_">set</span>(projectPath, <span class="hljs-title function_">createRequire</span>(<span class="hljs-string">`<span class="hljs-subst">${projectPath}</span>/package.json`</span>));\n  }\n  <span class="hljs-keyword">return</span> requireCache.<span class="hljs-title function_">get</span>(projectPath);\n}\n</code></pre>\n<h4>2. <strong>预解析路径</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 提前解析常用模块</span>\n<span class="hljs-keyword">const</span> preResolved = {\n  <span class="hljs-attr">react</span>: localRequire.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;react&#x27;</span>),\n  <span class="hljs-attr">lodash</span>: localRequire.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>)\n};\n</code></pre>\n<hr>\n<h3>六、底层原理深入</h3>\n<h4>1. **Node.js 模块查找流程</h4>\n<ol>\n<li>检查 <code>require.cache</code></li>\n<li>遍历 <code>module.paths</code>（由 <code>createRequire</code> 重写）</li>\n<li>解析 <code>package.json</code> 的 <code>exports/main</code> 字段</li>\n<li>尝试文件扩展名（.js/.json/.node）</li>\n</ol>\n<h4>2. **与 <code>NODE_PATH</code> 的关系</h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// createRequire 优先级更高</span>\nprocess.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_PATH</span> = <span class="hljs-string">&#x27;/global_modules&#x27;</span>;\n<span class="hljs-keyword">const</span> req = <span class="hljs-title function_">createRequire</span>(<span class="hljs-string">&#x27;/project/package.json&#x27;</span>);\n\n<span class="hljs-title function_">req</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>); <span class="hljs-comment">// 仍优先查找 /project/node_modules/lodash</span>\n</code></pre>\n<hr>\n<h3>七、实战案例</h3>\n<h4>1. <strong>Taro 多项目构建器</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaroBuilder</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">projectPath</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">require</span> = <span class="hljs-title function_">createRequire</span>(<span class="hljs-string">`<span class="hljs-subst">${projectPath}</span>/package.json`</span>);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">taroCli</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@tarojs/cli&#x27;</span>);\n  }\n\n  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-comment">// 使用项目本地的 Taro 版本</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">taroCli</span>.<span class="hljs-title function_">run</span>([<span class="hljs-string">&#x27;build&#x27;</span>, <span class="hljs-string">&#x27;--type&#x27;</span>, <span class="hljs-string">&#x27;weapp&#x27;</span>]);\n  }\n}\n</code></pre>\n<h4>2. <strong>微前端模块联邦</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 宿主应用加载子应用依赖</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">loadRemoteDep</span> = (<span class="hljs-params">appName, depName</span>) =&gt; {\n  <span class="hljs-keyword">const</span> appInfo = <span class="hljs-title function_">getAppConfig</span>(appName);\n  <span class="hljs-keyword">const</span> req = <span class="hljs-title function_">createRequire</span>(<span class="hljs-string">`<span class="hljs-subst">${appInfo.path}</span>/package.json`</span>);\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">req</span>(depName);\n};\n</code></pre>\n<hr>\n<h3>最佳实践建议：</h3>\n<ol>\n<li><strong>路径标准化</strong><br>\n始终使用 <code>path.resolve()</code> 处理输入路径<pre><code class="language-javascript"><span class="hljs-title function_">createRequire</span>(path.<span class="hljs-title function_">resolve</span>(process.<span class="hljs-title function_">cwd</span>(), <span class="hljs-string">&#x27;package.json&#x27;</span>))\n</code></pre>\n</li>\n<li><strong>错误处理增强</strong><pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">safeRequire</span>(<span class="hljs-params">id</span>) {\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">localRequire</span>(id);\n  } <span class="hljs-keyword">catch</span> (err) {\n    <span class="hljs-keyword">if</span> (err.<span class="hljs-property">code</span> === <span class="hljs-string">&#x27;MODULE_NOT_FOUND&#x27;</span>) {\n      <span class="hljs-comment">// 自定义处理逻辑</span>\n    }\n    <span class="hljs-keyword">throw</span> err;\n  }\n}\n</code></pre>\n</li>\n<li><strong>版本冲突防护</strong><pre><code class="language-javascript"><span class="hljs-keyword">const</span> requiredVersion = <span class="hljs-title function_">localRequire</span>(<span class="hljs-string">&#x27;webpack/package.json&#x27;</span>).<span class="hljs-property">version</span>;\n<span class="hljs-keyword">if</span> (semver.<span class="hljs-title function_">lt</span>(requiredVersion, <span class="hljs-string">&#x27;5.0.0&#x27;</span>)) {\n  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;需要Webpack 5+&#x27;</span>);\n}\n</code></pre>\n</li>\n</ol>\n<p>该方法相比 <code>NODE_PATH</code> 或 <code>module.paths</code> 修改更安全可靠，是 Node.js 官方推荐的依赖隔离方案。在 Webpack 插件开发、微前端架构等场景中尤为关键。</p>\n</div>'</script></body></html>