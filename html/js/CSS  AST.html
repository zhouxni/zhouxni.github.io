<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5f4cad=_0x3e49;function _0x3e49(c,s){var o=_0x4fac();return(_0x3e49=function(s,n){var a=o[s-=196];void 0===_0x3e49.AnEFcQ&&(_0x3e49.nIvNbm=function(s,n){var a,l=[],c=0,o="";for(s=(s=>{for(var n,a,l="",c="",o=0,p=0;a=s.charAt(p++);~a&&(n=o%4?64*n+a:a,o++%4)&&(l+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,t=l.length;e<t;e++)c+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(c)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)c=(c+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[c],l[c]=a;for(var p=0,c=0,e=0;e<s.length;e++)a=l[p=(p+1)%256],l[p]=l[c=(c+l[p])%256],l[c]=a,o+=String.fromCharCode(s.charCodeAt(e)^l[(l[p]+l[c])%256]);return o},c=arguments,_0x3e49.AnEFcQ=!0);var s=s+o[0],l=c[s];return l?a=l:(void 0===_0x3e49.dUTVMA&&(_0x3e49.dUTVMA=!0),a=_0x3e49.nIvNbm(a,n),c[s]=a),a})(c,s)}if((()=>{for(var s=_0x3e49,n=_0x4fac();;)try{if(309116==+parseInt(s(215,"[HEZ"))+-parseInt(s(201,"7H&@"))/2*(parseInt(s(214,"N4HR"))/3)+-parseInt(s(209,"fS5I"))/4+-parseInt(s(202,"(RvJ"))/5+-parseInt(s(206,"*vUY"))/6+-parseInt(s(205,"Z#[3"))/7+-parseInt(s(199,"4THr"))/8*(-parseInt(s(213,"aAli"))/9))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5f4cad(218,"m7Tx")](_0x5f4cad(210,"sSov"))!=_0x5f4cad(203,"jSJG"))throw window[_0x5f4cad(197,"4THr")][_0x5f4cad(198,"WbCr")](_0x5f4cad(212,"4*]b")),Error();function _0x4fac(){var s=["ESkmW6i+sYDWWPjubNrzW6e","W4tdN8kIg8kkW7eLW5xcHCkAFKm","W55dWO3dJfXgW64rlW","B8odySkRWR41zu3cOCkUlaq","tmkGW6nvW48cW6Lffq","E8kpW6W/scHWWPbzp1vWW58","mLf9aWLcfuZdHdbFWQ/cHq7dMCo2lqWBWOBdGq96WOtcJSkK","W5fwi3i3bCoXcq7dU0xcPrlcVq","W5dcLmkeWOHxW5JcHmk3WRqs","WR/cRmk+ab3cOsWeWRpdT8o3la","W5hdVSkppCkmcd4","DSo4mNddOCo4uSkeWQDM","W7GUWQNdM8oDlNC","W5VdQCoIffHRWQDkzmolqa4","WR8VWPeXaComW4DfW4eDW78xW49W","fNPsdSopW5xdIbC","W73cSSkAt8ohW7FcIa","qKn2dCoxW6tdIW","E8kub8kUk8kXD0bhtCkNW70t","Fmo8mWRdM8orESkbWRi","ss7dL20jW5Xogf9ji8k0DW","lSosz8okeW","W5RdLx4rt1dcQJHDWPVdRfxdTq","cSoRWQ4mhvlcKZRdNYpdMcZdGW"];return(_0x4fac=function(){return s})()}document.title="CSS  AST",document.getElementById("article").innerHTML='<div><p><code>PostCSS</code> 是一个功能强大的工具，用于转换和处理 CSS。它能够将 CSS 解析为抽象语法树（AST），并允许开发者通过插件对 AST 进行各种操作。以下是如何使用 <code>PostCSS</code> 将 CSS 转换为 AST 的详细步骤：</p>\n<h3>安装 PostCSS</h3>\n<p>首先，你需要安装 <code>PostCSS</code>。你可以通过 npm 来安装：</p>\n<pre><code class="language-sh">npm install postcss\n</code></pre>\n<h3>使用 PostCSS 将 CSS 转换为 AST</h3>\n<p><code>PostCSS</code> 本身并不直接提供一个方法来查看完整的 AST 结构，但它通过 <code>postcss.parse()</code> 方法解析 CSS，并返回一个 <code>Root</code> 节点，这个节点就是 AST 的根。你可以通过遍历这个根节点来访问整个 AST。</p>\n<h4>示例代码</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> postcss = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;postcss&#x27;</span>);\n\n<span class="hljs-comment">// CSS 字符串</span>\n<span class="hljs-keyword">const</span> cssString = <span class="hljs-string">`\nbody {\n  font-size: 12px;\n  color: #333;\n}\n`</span>;\n\n<span class="hljs-comment">// 使用 PostCSS 解析 CSS 为 AST</span>\n<span class="hljs-keyword">const</span> ast = postcss.<span class="hljs-title function_">parse</span>(cssString);\n\n<span class="hljs-comment">// 输出 AST 的根节点</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ast.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 这将输出格式化后的 CSS，但你可以直接操作 ast 对象</span>\n\n<span class="hljs-comment">// 遍历 AST 的根节点</span>\nast.<span class="hljs-title function_">walkRules</span>(<span class="hljs-function"><span class="hljs-params">rule</span> =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Rule:&#x27;</span>, rule.<span class="hljs-property">selector</span>);\n  rule.<span class="hljs-title function_">walkDecls</span>(<span class="hljs-function"><span class="hljs-params">decl</span> =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Declaration:&#x27;</span>, decl.<span class="hljs-property">prop</span>, <span class="hljs-string">&#x27;=&#x27;</span>, decl.<span class="hljs-property">value</span>);\n  });\n});\n</code></pre>\n<h3>解释</h3>\n<ol>\n<li><strong><code>postcss.parse()</code></strong>  :\n<ul>\n<li>这个方法解析 CSS 字符串并返回一个 <code>Root</code> 节点，它是 AST 的根。</li>\n<li>你可以直接操作这个 <code>Root</code> 节点来访问整个 AST。</li>\n</ul>\n</li>\n<li><strong><code>ast.walkRules()</code></strong>  :\n<ul>\n<li>这是一个遍历方法，用于遍历 AST 中的所有规则（<code>Rule</code> 节点）。</li>\n<li>你可以对每个规则执行特定的操作。</li>\n</ul>\n</li>\n<li><strong><code>rule.walkDecls()</code></strong>  :\n<ul>\n<li>这是一个遍历方法，用于遍历规则中的所有声明（<code>Declaration</code> 节点）。</li>\n<li>你可以对每个声明执行特定的操作。</li>\n</ul>\n</li>\n</ol>\n<h3>使用插件</h3>\n<p><code>PostCSS</code> 的强大之处在于它的插件系统。你可以编写或使用现有的插件来操作 AST。例如，你可以编写一个插件来修改 AST 中的某些节点，然后将其转换回 CSS。</p>\n<h4>示例插件</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> postcss = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;postcss&#x27;</span>);\n\n<span class="hljs-comment">// 自定义插件</span>\n<span class="hljs-keyword">const</span> myPlugin = postcss.<span class="hljs-title function_">plugin</span>(<span class="hljs-string">&#x27;my-plugin&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-function">(<span class="hljs-params">css</span>) =&gt;</span> {\n  css.<span class="hljs-title function_">walkDecls</span>(<span class="hljs-function"><span class="hljs-params">decl</span> =&gt;</span> {\n    <span class="hljs-keyword">if</span> (decl.<span class="hljs-property">prop</span> === <span class="hljs-string">&#x27;font-size&#x27;</span>) {\n      decl.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;14px&#x27;</span>; <span class="hljs-comment">// 修改 font-size 的值</span>\n    }\n  });\n});\n\n<span class="hljs-comment">// 使用插件</span>\n<span class="hljs-title function_">postcss</span>([myPlugin])\n  .<span class="hljs-title function_">process</span>(cssString, { <span class="hljs-attr">from</span>: <span class="hljs-literal">undefined</span> })\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">css</span>); <span class="hljs-comment">// 输出修改后的 CSS</span>\n  });\n</code></pre>\n<h3>总结</h3>\n<ul>\n<li><code>PostCSS</code> 能够将 CSS 解析为 AST，并允许你通过插件或手动遍历来操作这个 AST。</li>\n<li>你可以使用 <code>postcss.parse()</code> 方法来解析 CSS，并得到一个 <code>Root</code> 节点作为 AST 的根。</li>\n<li>通过遍历 <code>Root</code> 节点及其子节点，你可以访问和修改 CSS 的各个部分。</li>\n<li><code>PostCSS</code> 的插件系统使得对 AST 的操作更加灵活和强大。</li>\n</ul>\n</div>'</script></body></html>