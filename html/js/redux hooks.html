<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x269ffa=_0x2105;function _0x2105(a,s){var c=_0x293c();return(_0x2105=function(s,e){var n=c[s-=298];void 0===_0x2105.uubofV&&(_0x2105.vzYjwV=function(s,e){var n,o=[],a=0,c="";for(s=(s=>{for(var e,n,o="",a="",c=0,t=0;n=s.charAt(t++);~n&&(e=c%4?64*e+n:n,c++%4)&&(o+=String.fromCharCode(255&e>>(-2*c&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var r=0,d=o.length;r<d;r++)a+="%"+("00"+o.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(a)})(s),t=0;t<256;t++)o[t]=t;for(t=0;t<256;t++)a=(a+o[t]+e.charCodeAt(t%e.length))%256,n=o[t],o[t]=o[a],o[a]=n;for(var t=0,a=0,r=0;r<s.length;r++)n=o[t=(t+1)%256],o[t]=o[a=(a+o[t])%256],o[a]=n,c+=String.fromCharCode(s.charCodeAt(r)^o[(o[t]+o[a])%256]);return c},a=arguments,_0x2105.uubofV=!0);var s=s+c[0],o=a[s];return o?n=o:(void 0===_0x2105.BuBbHI&&(_0x2105.BuBbHI=!0),n=_0x2105.vzYjwV(n,e),a[s]=n),n})(a,s)}function _0x293c(){var s=["W6JdIJOjW7tdK1RdKMRdLGm","xZG5W57cV8kDBa","W6JcScH4fKqZBa","W4BdLcRcUIzkyKNdOCoa","W5dcU2xcQJjUW57dQSodW4a","W6JdHJanW7/dQ1ddOuJdPaa","ACkQW4VcOWaSW5pdLmkLWRddGSkts8oy","EGZcRxO3pqOPEKtcKq","WQNcNY7dVNJcVXZcV8o7eW","oJxdTSopW4C","pNdcN35/wcpcV8oZW5O","WRXbqCohEH3dM8kDyq","W7xcOCo6tSoWWRCxW4fqCIS","WRZcKmoHy1nvE8kDteW","WPpdOJJdRs0EW40","W6uScG3cQ8oCi8oUWQhdSSkL","WRJcLmoGzsbLDSkWDvy8","EZD7WOBcK2yTW6S","W77dUbRcH0iTgCkRk8owW4xdTSkJ","W7TkuxbyW43dU8kBWPNdIh9YW58","W4pdTYFcVt14W4nosZddVt3dKHdcR8kqBWVdGMVcP8oYlmktmSkI","gM5nqeOAew3dRG","A8oiWR/cHhyDWR7dHedcR8kCaCks","pxxcMNSOlfVcT8oxW5fHWQf4","W6/dNdxdPt8gWOhdHSkMW414WOaMjW","WRHhcCosyJhdKSkK","W7KAWOpdLMjaW5S","W4aQxLyzWPflmWa","ACkHW5JdOIv4W6W","WR7cK8oNyNrWCSkcC3W"];return(_0x293c=function(){return s})()}if((()=>{for(var s=_0x2105,e=_0x293c();;)try{if(821588==+parseInt(s(319,"Ke%r"))+-parseInt(s(314,"E7Au"))/2*(-parseInt(s(310,"E%TY"))/3)+parseInt(s(308,"zEz2"))/4*(parseInt(s(302,"Ke%r"))/5)+-parseInt(s(322,"[6#C"))/6*(parseInt(s(317,"v8yL"))/7)+parseInt(s(311,"Prg@"))/8*(-parseInt(s(307,"2z$("))/9)+parseInt(s(325,"sdxX"))/10+-parseInt(s(309,"qXIw"))/11*(parseInt(s(298,"E7Au"))/12))break;e.push(e.shift())}catch(s){e.push(e.shift())}})(),localStorage[_0x269ffa(304,"5Rj[")](_0x269ffa(324,"7zFh"))!=_0x269ffa(312,"C7tG"))throw window[_0x269ffa(305,"IJel")][_0x269ffa(299,"YvK*")](_0x269ffa(323,"O*LQ")),Error();document.title="redux hooks",document.getElementById("article").innerHTML='<div><p>Redux Hooks 是 Redux 7.1.0 版本引入的新特性，旨在简化在 React 函数式组件中与 Redux store 的交互。以下是 Redux Hooks 的详细解析：</p>\n<h3>1. <code>useSelector</code></h3>\n<ul>\n<li><strong>作用</strong>  ：<code>useSelector</code> 用于从 Redux store 中选择并订阅部分数据。它允许组件从 Redux store 中获取所需的状态，并在状态发生变化时自动重新渲染组件。</li>\n<li><strong>用法</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useSelector } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;\n\n<span class="hljs-keyword">const</span> selectedData = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">someData</span>);\n</code></pre>\n<ul>\n<li><code>state</code> 是整个 Redux store 的状态对象。</li>\n<li>回调函数返回的值会被用作 <code>useSelector</code> 的返回值，并在组件中使用。</li>\n</ul>\n</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li><strong>自动订阅</strong>  ：<code>useSelector</code> 会自动订阅 Redux store 中的状态变化，当与选择器函数相关的状态发生变化时，组件会重新渲染。</li>\n<li><strong>性能优化</strong>  ：默认使用严格引用比较（<code>===</code>）来决定是否需要重新渲染组件。如果需要更复杂的比较逻辑，可以传入自定义的比较函数作为第二个参数。</li>\n</ul>\n</li>\n</ul>\n<h3>2. <code>useDispatch</code></h3>\n<ul>\n<li><strong>作用</strong>  ：<code>useDispatch</code> 用于获取 Redux store 的 <code>dispatch</code> 函数。通过 <code>dispatch</code> 函数，可以分发 actions，从而触发 store 中的状态更新。</li>\n<li><strong>用法</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useDispatch } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;\n\n<span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;MY_ACTION&#x27;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-string">&#x27;somePayload&#x27;</span> });\n};\n</code></pre>\n</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li><strong>简化分发</strong>  ：<code>useDispatch</code> 使得在组件中分发 actions 变得更加简单，无需使用 <code>connect</code> 高阶组件。</li>\n<li><strong>直接访问</strong>  ：通过 <code>useDispatch</code> 获取的 <code>dispatch</code> 函数与 Redux store 的 <code>dispatch</code> 函数完全相同，可以直接使用。</li>\n</ul>\n</li>\n</ul>\n<h3>3. <code>useStore</code></h3>\n<ul>\n<li><strong>作用</strong>  ：<code>useStore</code> 用于获取整个 Redux store 的引用。虽然不常用，但在某些情况下（如需要直接访问 store 的方法或属性）可能会派上用场。</li>\n<li><strong>用法</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useStore } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;\n\n<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>();\n</code></pre>\n</li>\n<li><strong>注意</strong>  ：\n<ul>\n<li>优先使用 <code>useSelector</code> 来获取状态，因为 <code>useSelector</code> 更加高效且符合 Redux 的最佳实践。</li>\n<li>直接操作 store 的方法或属性可能会导致代码难以维护和调试，因此应谨慎使用。</li>\n</ul>\n</li>\n</ul>\n<h3>总结</h3>\n<p>Redux Hooks 提供了一种更简洁、更直观的方式来在 React 函数式组件中与 Redux store 交互。通过 <code>useSelector</code> 和 <code>useDispatch</code>，开发者可以轻松地访问和更新 Redux store 中的状态，而无需使用 <code>connect</code> 高阶组件。此外，<code>useStore</code> 虽然不常用，但在某些特定场景下可能会发挥作用。这些 hooks 的引入使得 Redux 在 React 项目中的使用变得更加灵活和高效。</p>\n</div>'</script></body></html>