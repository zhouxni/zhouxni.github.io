<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5f34e0=_0x5e6f;function _0x5e6f(l,s){var o=_0x37a6();return(_0x5e6f=function(s,n){var a=o[s-=289];void 0===_0x5e6f.TUAkzo&&(_0x5e6f.VRPSah=function(s,n){var a,t=[],l=0,o="";for(s=(s=>{for(var n,a,t="",l="",o=0,c=0;a=s.charAt(c++);~a&&(n=o%4?64*n+a:a,o++%4)&&(t+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,e=t.length;p<e;p++)l+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(l)})(s),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)l=(l+t[c]+n.charCodeAt(c%n.length))%256,a=t[c],t[c]=t[l],t[l]=a;for(var c=0,l=0,p=0;p<s.length;p++)a=t[c=(c+1)%256],t[c]=t[l=(l+t[c])%256],t[l]=a,o+=String.fromCharCode(s.charCodeAt(p)^t[(t[c]+t[l])%256]);return o},l=arguments,_0x5e6f.TUAkzo=!0);var s=s+o[0],t=l[s];return t?a=t:(void 0===_0x5e6f.pwtafd&&(_0x5e6f.pwtafd=!0),a=_0x5e6f.VRPSah(a,n),l[s]=a),a})(l,s)}function _0x37a6(){var s=["WPtcHqC3WQ7dUSocWPj+","WQtdHGBcUJ/cOmoCW47dUCoKW5tcKa","xKFcKahcKZJcL1NcPG","W6vzigtcLq3dOCkOWPu5AG","imkZkmoTWOeUWPW","WRSBW7mKWPr/WONdNCkQW5pcOGpcVKu3WQFdPSoRW5/cH8okW4pcQ8kgW6Xw","WRtdSmo+WOtdVmogmmkoW4NdTv/cKc8","WPeTqCoduSorW4KMW4JdVHjVuSoc","W4HrWQS2W5aTtq","ESkGW4WMlWNdN8oyWR0","ihCeBMFcPcWabSkmWQC","z8oUymk0WRekWQhcRmoUWQ8","WRtdRmk4vwfrW6udiq","FbJdOCkpWP7cTCo+AWq","W6zyigtcMN3cGmkKWQSawKKU","ueS0m2PIw8ooW4lcGSo3W7vL","rmkSWO06W4KFgCkDja","uKS0mgPSiCoQW6hcUmotW7K","lmkgBunmW4SKhai","WP4eW65pWPz7eGFcR3ddM8kRWQVdGa","WPOmW6DkW7upEhNcIgK","iw9RF8kit37cIYdcNCk+","WPWaW6TjWPfXgfxcVMtdPmkBWOK","EmozdgXsddD+","ee/dG8osmW","wCo7W5BcHLjko1JcIJpcVSoM","jCkhvJuwedDOW7Chea","gN/dHmkMlCk8mSkFjdPkW7a"];return(_0x37a6=function(){return s})()}if((()=>{for(var s=_0x5e6f,n=_0x37a6();;)try{if(932103==-parseInt(s(315,"K1I&"))+-parseInt(s(295,"JK%z"))/2+parseInt(s(314,"pSqm"))/3*(parseInt(s(302,"TEDB"))/4)+parseInt(s(289,"8yce"))/5*(parseInt(s(300,"07rA"))/6)+parseInt(s(301,"S$%h"))/7*(-parseInt(s(311,"Z#Is"))/8)+parseInt(s(292,"JK%z"))/9+-parseInt(s(299,"w6eu"))/10*(-parseInt(s(293,"JK%z"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5f34e0(309,"JK%z")](_0x5f34e0(303,"]9WQ"))!=_0x5f34e0(297,"0*VZ"))throw window[_0x5f34e0(296,"w6eu")][_0x5f34e0(305,"fs$x")](_0x5f34e0(306,"lg6Q")),Error();document.title="taro 事件冒泡",document.getElementById("article").innerHTML='<div><p>在 <strong>Taro 3</strong>   中处理事件冒泡（类似小程序的 <code>bindtap</code> 和 <code>catchtap</code>），可以通过 React 风格的事件处理机制实现。以下是具体方法：</p>\n<hr>\n<h3><strong>1. 默认行为（事件冒泡）</strong></h3>\n<p>Taro 3 默认使用 React 事件系统，所有事件（如 <code>onClick</code>）会自动冒泡。<br>\n<strong>示例：</strong></p>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleParentClick</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;父元素被点击&quot;</span>);\n  };\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleParentClick}</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> console.log(&quot;子元素被点击&quot;)}&gt;\n        点击我（会触发父元素事件）\n      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p><strong>编译后的小程序代码：</strong></p>\n<pre><code class="language-wxml">&lt;view bindtap=&quot;handleParentClick&quot;&gt;\n  &lt;button bindtap=&quot;handleChildClick&quot;&gt;点击我&lt;/button&gt;\n&lt;/view&gt;\n</code></pre>\n<hr>\n<h3><strong>2. 阻止事件冒泡</strong></h3>\n<h4><strong>方法 1：<code>e.stopPropagation()</code>（React 标准）</strong></h4>\n<p>在事件处理函数中调用 <code>e.stopPropagation()</code> 阻止冒泡：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChildClick</span> = (<span class="hljs-params">e</span>) =&gt; {\n    e.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 阻止冒泡</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;子元素被点击，父元素不会触发&quot;</span>);\n  };\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> console.log(&quot;父元素被点击&quot;)}&gt;\n      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleChildClick}</span>&gt;</span>\n        点击我（阻止冒泡）\n      <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p><strong>编译后的小程序代码：</strong></p>\n<pre><code class="language-wxml">&lt;view bindtap=&quot;handleParentClick&quot;&gt;\n  &lt;button catchtap=&quot;handleChildClick&quot;&gt;点击我&lt;/button&gt;\n&lt;/view&gt;\n</code></pre>\n<p>Taro 会自动将 <code>e.stopPropagation()</code> 编译为小程序的 <code>catchtap</code>。</p>\n<h4><strong>方法 2：<code>catchClick</code>（Taro 专用语法）</strong></h4>\n<p>Taro 提供了 <code>catchClick</code> 属性，直接阻止冒泡：</p>\n<pre><code class="language-jsx">&lt;<span class="hljs-title class_">View</span> onClick={<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;父元素被点击&quot;</span>)}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">catchClick</span>=<span class="hljs-string">{()</span> =&gt;</span> console.log(&quot;子元素被点击，父元素不会触发&quot;)}&gt;\n    点击我（阻止冒泡）\n  <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span>\n&lt;/<span class="hljs-title class_">View</span>&gt;\n</code></pre>\n<p><strong>效果等同于小程序的 <code>catchtap</code>。</strong></p>\n<hr>\n<h3><strong>3. 其他事件的冒泡控制</strong></h3>\n<p>除了点击事件，还可以通过以下方式阻止冒泡：</p>\n<ul>\n<li><strong>触摸事件</strong>  ：<code>catchTouchStart</code>、<code>catchTouchMove</code>、<code>catchTouchEnd</code></li>\n<li><strong>滚动事件</strong>  ：<code>catchScroll</code></li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code class="language-jsx">&lt;<span class="hljs-title class_">View</span> onTouchStart={<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;父元素触摸事件&quot;</span>)}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">catchTouchStart</span>=<span class="hljs-string">{()</span> =&gt;</span> console.log(&quot;子元素触摸事件，阻止冒泡&quot;)}&gt;\n    按住我（阻止冒泡）\n  <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span>\n&lt;/<span class="hljs-title class_">View</span>&gt;\n</code></pre>\n<hr>\n<h3><strong>4. 动态控制冒泡</strong></h3>\n<p>根据条件决定是否阻止冒泡：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">{ shouldStopBubble }</span>) {\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params">e</span>) =&gt; {\n    <span class="hljs-keyword">if</span> (shouldStopBubble) {\n      e.<span class="hljs-title function_">stopPropagation</span>();\n    }\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;子元素点击&quot;</span>);\n  };\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>点击我<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span>;\n}\n</code></pre>\n<hr>\n<h3><strong>5. 注意事项</strong></h3>\n<ol>\n<li><strong>跨平台兼容性</strong>  ：\n<ul>\n<li><code>e.stopPropagation()</code> 和 <code>catchClick</code> 在微信小程序中会编译为 <code>catchtap</code>，但在 H5 端仍使用 DOM 事件机制。</li>\n<li>如果需要跨端一致行为，建议统一使用 <code>e.stopPropagation()</code>。</li>\n</ul>\n</li>\n<li><strong>原生组件限制</strong>  ：\n<ul>\n<li>部分原生组件（如 <code>Canvas</code>）可能不支持冒泡控制，需单独处理。</li>\n</ul>\n</li>\n<li><strong>性能优化</strong>  ：\n<ul>\n<li>避免在深层嵌套的组件中频繁阻止冒泡，可能影响事件系统性能。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐方法</th>\n<th>编译后的小程序等效代码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>允许冒泡</strong></td>\n<td><code>onClick</code></td>\n<td><code>bindtap</code></td>\n</tr>\n<tr>\n<td><strong>阻止冒泡</strong></td>\n<td><code>e.stopPropagation()</code> 或 <code>catchClick</code></td>\n<td><code>catchtap</code></td>\n</tr>\n<tr>\n<td><strong>条件阻止冒泡</strong></td>\n<td><code>if (condition) e.stopPropagation()</code></td>\n<td>动态生成 <code>catchtap</code>/<code>bindtap</code></td>\n</tr>\n<tr>\n<td><strong>触摸事件阻止</strong></td>\n<td><code>catchTouchStart</code></td>\n<td><code>catchtouchstart</code></td>\n</tr>\n</tbody>\n</table>\n<p><strong>最佳实践：</strong></p>\n<ul>\n<li>优先使用 <code>e.stopPropagation()</code>（符合 React 规范）。</li>\n<li>明确阻止冒泡时可用 <code>catchClick</code>（代码更直观）。</li>\n<li>复杂场景结合条件判断动态控制。</li>\n</ul>\n</div>'</script></body></html>