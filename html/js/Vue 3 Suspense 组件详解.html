<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5d49(p,s){var t=_0x1ec0();return(_0x5d49=function(s,a){var n=t[s-=453];void 0===_0x5d49.Khcjwm&&(_0x5d49.qoAWtu=function(s,a){var n,l=[],p=0,t="";for(s=(s=>{for(var a,n,l="",p="",t=0,e=0;n=s.charAt(e++);~n&&(a=t%4?64*a+n:n,t++%4)&&(l+=String.fromCharCode(255&a>>(-2*t&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,h=l.length;c<h;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+a.charCodeAt(e%a.length))%256,n=l[e],l[e]=l[p],l[p]=n;for(var e=0,p=0,c=0;c<s.length;c++)n=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=n,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[p])%256]);return t},p=arguments,_0x5d49.Khcjwm=!0);var s=s+t[0],l=p[s];return l?n=l:(void 0===_0x5d49.DTPAIw&&(_0x5d49.DTPAIw=!0),n=_0x5d49.qoAWtu(n,a),p[s]=n),n})(p,s)}var _0x4d6125=_0x5d49;function _0x1ec0(){var s=["ECo6W5xcNSoLWOLvACkHvMrP","EsddUmkXW5ujWRz5FurSWQy","W43dLmkGWOKytSk5BG","WQ5VAMhcImk7kwaU","g8oyW4RcIxjphu3dGCkdE8k1WQa","kSoYjCk9uCo1WQy","lmkdrmoyWQBcSCkL","pCkPWP/dO2jbWQW","urTLnSotxahcGSo1DCoZbq","W53dTSkhqqJdGs0M","WRuOb8kyW4eHWO7dItK","W5zgW7ugW6VcSuXY","h8oxW4hcJhjdyv3dNmk4CSkt","vH9InmoCxxJdG8oqDSoFlb/cOG","EsNdT8kZW5ujW61XEhnNWRex","bvVdRSoaW4mgjKGIWQi/aa","W6WUW5ziW7OEW6hcQ8oH","FSoYWOxdGSkZWRxdU0e6umoJxSkzw8oDeCkNeLtcO8kegSk1C8o8fG","oSoaF8k/W6TMimkKjbhcKCo0WRy","WQnsBbJdPCkGW6DN","kSk5WPJdMw8","WQmLWRhcN2FdU8kwdG","W57dPXubW7n2xsvUW759mCoa","WQPHW7pcONRcUmkOW6K","xI3dPmkZW5mvdW","WQPIWR/dGJhdGSkdW5FdGmk0WOldGq","pmo1reH+WOVcVhNcO8oPW5ddHmok","W57dT8oijeZcTLHbWRtdVNiOaSo2","W6qPWPfXW4qqW7NcIG","W5/dRHSnW7f2wJzCW5Xzmmoh"];return(_0x1ec0=function(){return s})()}if((()=>{for(var s=_0x5d49,a=_0x1ec0();;)try{if(996414==+parseInt(s(476,"YTDy"))*(parseInt(s(466,"6L8O"))/2)+-parseInt(s(481,"kC*0"))/3*(-parseInt(s(455,"(smS"))/4)+parseInt(s(478,"zy7!"))/5*(-parseInt(s(463,"3#nE"))/6)+-parseInt(s(458,"]rKh"))/7+parseInt(s(454,"Lk0k"))/8*(parseInt(s(472,"dd23"))/9)+parseInt(s(456,"GSRC"))/10*(parseInt(s(465,"3#nE"))/11)+-parseInt(s(467,"tuEM"))/12)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x4d6125(477,"D%*B")](_0x4d6125(480,"5%5C"))!=_0x4d6125(460,"D%*B"))throw window[_0x4d6125(461,"zm$j")][_0x4d6125(475,"sZV1")](_0x4d6125(457,"SZS#")),Error();document.title="Vue 3 Suspense 组件详解",document.getElementById("article").innerHTML='<div><p>Suspense 是 Vue 3 中引入的一个内置组件，用于处理异步依赖的加载状态，提供更好的用户体验。</p>\n<h2>基本用法</h2>\n<p>Suspense 组件允许你在等待异步组件加载时显示一个后备内容：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span>\n    <span class="hljs-comment">&lt;!-- 异步组件 --&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">AsyncComponent</span> /&gt;</span>\n\n    <span class="hljs-comment">&lt;!-- 加载状态 --&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-keyword">import</span> { defineAsyncComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n  <span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComponent</span> = <span class="hljs-title function_">defineAsyncComponent</span>(\n    <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./AsyncComponent.vue&quot;</span>),\n  );\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<h2>工作原理</h2>\n<ol>\n<li>当 Suspense 内部的异步依赖（如异步组件或带有 async setup 的组件）还未解析时，显示 fallback 内容</li>\n<li>当所有异步依赖都解析完成后，显示默认插槽内容</li>\n<li>如果发生错误，可以配合 errorCaptured 或 onErrorCaptured 处理</li>\n</ol>\n<h2>异步 setup</h2>\n<p>Suspense 也可以处理带有异步 setup 的组件：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">ComponentWithAsyncSetup</span> /&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-keyword">const</span> <span class="hljs-title class_">ComponentWithAsyncSetup</span> = {\n    <span class="hljs-keyword">async</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();\n      <span class="hljs-keyword">return</span> { data };\n    },\n  };\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<h2>事件处理</h2>\n<p>Suspense 组件提供了两个事件：</p>\n<ul>\n<li><code>pending</code>: 进入挂起状态时触发</li>\n<li><code>resolve</code>: 所有异步依赖解析完成时触发</li>\n<li><code>fallback</code>: fallback 内容显示时触发</li>\n</ul>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> @<span class="hljs-attr">pending</span>=<span class="hljs-string">&quot;onPending&quot;</span> @<span class="hljs-attr">resolve</span>=<span class="hljs-string">&quot;onResolve&quot;</span> @<span class="hljs-attr">fallback</span>=<span class="hljs-string">&quot;onFallback&quot;</span>&gt;</span>\n    <span class="hljs-comment">&lt;!-- ... --&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n<h2>嵌套 Suspense</h2>\n<p>可以嵌套使用 Suspense 组件，每个 Suspense 会处理自己范围内的异步依赖：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">ParentComponent</span> /&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span>Loading parent...<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-comment">&lt;!-- ParentComponent.vue --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span>Loading child...<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n<h2>错误处理</h2>\n<p>可以通过 <code>onErrorCaptured</code> 捕获 Suspense 内部的错误：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-keyword">import</span> { onErrorCaptured } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n  <span class="hljs-title function_">onErrorCaptured</span>(<span class="hljs-function">(<span class="hljs-params">err, instance, info</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error caught by Suspense:&quot;</span>, err);\n    <span class="hljs-comment">// 可以在这里处理错误，如显示错误页面</span>\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 阻止错误继续向上传播</span>\n  });\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<h2>实际应用场景</h2>\n<ol>\n<li>代码分割加载时的加载状态</li>\n<li>数据获取期间的加载状态</li>\n<li>路由懒加载时的过渡效果</li>\n<li>任何需要等待异步操作的场景</li>\n</ol>\n<h2>注意事项</h2>\n<ul>\n<li>Suspense 是一个实验性功能，在 Vue 3 中稳定，但在未来版本中可能会有调整</li>\n<li>目前 Suspense 不支持服务器端渲染 (SSR)</li>\n<li>确保所有异步操作都在 Suspense 范围内完成</li>\n</ul>\n<p>Suspense 组件为 Vue 应用提供了更优雅的异步加载处理方式，可以显著提升用户体验。</p>\n</div>'</script></body></html>