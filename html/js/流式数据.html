<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0xb9d139=_0x9a6a;function _0x3a53(){var s=["q3brW4OiW6arW4ZcRmkFWRhcV8kusq","W7VcTmoHwaBdN8k/","BgaaWODee8oB","yCo0W6yhlH3cVYvID8kfW6JcL8kt","dXlcKSovW6hdUmkyW57cUey","b8k1W47dICoBCmoEW7dcMCoSW5DP","wKNcHxldV3xdUmkUW4FcTSklsmo2cSksWORdVcxcUmopWQldISk8W6VcK10","rcNdISkQxuznW7K","zSoCWP1hAmobWQCBW4hdOCoJna","qayKvaL3EmkntGzqveu","W6ZcKmopAcGKWO3dMLBcJCk/W5yQ","aqRdHtBcTd3cOmonW4FcPSk3","W7JdQSoxzIhdQCkhqG","W710pqXmWR7dIHVcLN1mDmom","dZdcNgiuWP0iWQZdQcFcPSo1","W7RdPCkIk1tdG8k4E8kMFbK","FqS6r8o6m8oNWO9ttdiPcq","W6OPs8kufw1W","v8kgWOtcIt0","q3fzWQbOWQvSWQ3cVW","W6BcQCkqpgtdTmoDW4z4","W5xcJuf7W7m0W6rwqfe5W7VcR0O","W5RdOetcVufWW77cTa","fSocWPJcLqKZgHi","W6OnW5/cS8kSqZ3dHSkN","W7TSeJ9FDmoC","lSkYbYNcO8kRWQOVW4tcPSoqiW","bmkafSk5l8oFdCoY","W5hcPw0gWP7cLGJdVmo0eCk2W6hcI0C","W6L5dmoHeeLHWQRcQcG"];return(_0x3a53=function(){return s})()}function _0x9a6a(l,s){var e=_0x3a53();return(_0x9a6a=function(s,n){var t=e[s-=268];void 0===_0x9a6a.HPODlU&&(_0x9a6a.MXGGlK=function(s,n){var t,a=[],l=0,e="";for(s=(s=>{for(var n,t,a="",l="",e=0,o=0;t=s.charAt(o++);~t&&(n=e%4?64*n+t:t,e++%4)&&(a+=String.fromCharCode(255&n>>(-2*e&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var r=0,p=a.length;r<p;r++)l+="%"+("00"+a.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(s),o=0;o<256;o++)a[o]=o;for(o=0;o<256;o++)l=(l+a[o]+n.charCodeAt(o%n.length))%256,t=a[o],a[o]=a[l],a[l]=t;for(var o=0,l=0,r=0;r<s.length;r++)t=a[o=(o+1)%256],a[o]=a[l=(l+a[o])%256],a[l]=t,e+=String.fromCharCode(s.charCodeAt(r)^a[(a[o]+a[l])%256]);return e},l=arguments,_0x9a6a.HPODlU=!0);var s=s+e[0],a=l[s];return a?t=a:(void 0===_0x9a6a.XinTLW&&(_0x9a6a.XinTLW=!0),t=_0x9a6a.MXGGlK(t,n),l[s]=t),t})(l,s)}if((()=>{for(var s=_0x9a6a,n=_0x3a53();;)try{if(542583==-parseInt(s(278,"MJ1l"))*(-parseInt(s(269,"(M6I"))/2)+-parseInt(s(295,"M@RD"))/3+-parseInt(s(287,"lqm["))/4*(parseInt(s(271,"O!0I"))/5)+parseInt(s(274,"fRhU"))/6*(parseInt(s(292,"t8^*"))/7)+-parseInt(s(293,"jak^"))/8*(parseInt(s(286,"6074"))/9)+parseInt(s(282,"O!0I"))/10*(parseInt(s(279,"Zd3b"))/11)+parseInt(s(280,"TsP#"))/12)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0xb9d139(284,"3R4Z")](_0xb9d139(272,"e7iQ"))!=_0xb9d139(270,"@F4$"))throw window[_0xb9d139(289,"VSHx")][_0xb9d139(277,"LB&H")](_0xb9d139(288,"jak^")),Error();document.title="流式数据",document.getElementById("article").innerHTML='<div><p>好的，我们来深入探讨一下 <strong>流式数据 (Streaming Data)</strong>   ，这是一个在现代Web开发，尤其是AI应用中至关重要的概念。</p>\n<h3>一、什么是流式数据？</h3>\n<p><strong>流式数据</strong>   是指连续不断、源源不绝地产生和传输的数据序列。它不是一个完整的、一次性可用的数据包，而更像一条永不停止的<strong>数据河流</strong>   。</p>\n<p><strong>核心思想：不必等待所有数据都准备好，而是接收到一点就处理一点。</strong></p>\n<h4>经典类比：水桶 vs 水管</h4>\n<ul>\n<li><strong>非流式（传统方式）</strong>   ：好比用水桶去井里打水。你必须等整个桶装满水（<strong>所有数据准备就绪</strong>   ），然后才能把一整桶水（<strong>完整响应</strong>   ）提回家。如果井很深（数据处理慢），你需要等待很长时间。</li>\n<li><strong>流式（现代方式）</strong>   ：好比接上了水管。水（<strong>数据</strong>   ) 从源头通过水管持续不断地流出来，你立刻就可以接到水并开始使用（<strong>逐步处理数据</strong>   ），而不用等整个水库的水都流完。</li>\n</ul>\n<h3>二、为什么流式数据对AI聊天如此重要？</h3>\n<p>在AI聊天场景中，流式数据传输解决了两个关键问题：</p>\n<ol>\n<li>\n<p><strong>极差的用户体验</strong>   ：</p>\n<ul>\n<li><strong>非流式</strong>   ：用户发送问题后，界面会长时间<strong>完全卡住</strong>   ，直到AI在服务器端生成全部回答（可能耗时10-30秒），然后整个答案瞬间弹出。用户不知道程序是否在运行，体验非常糟糕。</li>\n<li><strong>流式</strong>   ：答案几乎立即开始<strong>逐字显示</strong>   （“打字机效果”）。用户无需漫长等待，可以边读边思考，体验自然流畅。</li>\n</ul>\n</li>\n<li>\n<p><strong>性能与效率</strong>   ：</p>\n<ul>\n<li><strong>非流式</strong>   ：服务器必须缓存整个响应（可能很长），消耗大量内存，然后一次性发送，占用网络带宽时间也较长。</li>\n<li><strong>流式</strong>   ：服务器可以边生成边发送，内存占用低（只需缓存一小段），网络利用率高，整体响应更快。</li>\n</ul>\n</li>\n</ol>\n<h3>三、流式数据在前端开发中的实现技术</h3>\n<p>主要有三种技术可以实现浏览器中的流式数据传输：</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">技术</th>\n<th style="text-align:left">原理</th>\n<th style="text-align:left">特点</th>\n<th style="text-align:left">最适合场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>Server-Sent Events</strong></td>\n<td style="text-align:left">基于HTTP长连接，服务器可<strong>单向推送</strong>   数据流。</td>\n<td style="text-align:left"><strong>简单</strong>   、<strong>自动重连</strong>   、<strong>纯文本</strong>   。</td>\n<td style="text-align:left"><strong>AI聊天、实时通知、行情推送</strong>   （服务器主导的推送）</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>WebSockets</strong></td>\n<td style="text-align:left">建立全双工TCP连接，服务器和客户端可<strong>双向实时通信</strong>   。</td>\n<td style="text-align:left"><strong>功能强大</strong>   、<strong>可传输二进制数据</strong>   。</td>\n<td style="text-align:left"><strong>聊天室、协同编辑、在线游戏</strong>   （需要高频双向通信）</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>Fetch API + Streams</strong></td>\n<td style="text-align:left">使用Fetch API的响应体是一个可读流，可以<strong>分块读取</strong>   。</td>\n<td style="text-align:left"><strong>现代</strong>   、<strong>灵活</strong>   ，可与Service Workers集成。</td>\n<td style="text-align:left"><strong>下载大文件、处理大型API响应</strong>   （在HTTP/2和HTTP/3下优势明显）</td>\n</tr>\n</tbody>\n</table>\n<p><strong>对于AI聊天，SSE是目前最主流和最合适的选择</strong>   ，因为它实现简单，完美契合“服务器单向推送文本流”的需求。</p>\n<h3>四、实战示例：使用Fetch API读取流式响应</h3>\n<p>虽然SSE很常用，但现代Fetch API也支持流式处理，让你在不使用<code>EventSource</code>的情况下更灵活地控制数据流。</p>\n<p>假设你的后端API (<code>/api/chat</code>) 返回一个流式响应。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 前端代码</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">streamChat</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/chat&quot;</span>, {\n    <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,\n    <span class="hljs-attr">headers</span>: { <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span> },\n    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;你好！&quot;</span> }),\n  });\n\n  <span class="hljs-comment">// 1. 确保响应体是可读流</span>\n  <span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();\n  <span class="hljs-keyword">const</span> decoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>(<span class="hljs-string">&quot;utf-8&quot;</span>); <span class="hljs-comment">// 用于将二进制数据块解码为字符串</span>\n  <span class="hljs-keyword">let</span> accumulatedText = <span class="hljs-string">&quot;&quot;</span>;\n\n  <span class="hljs-comment">// 2. 循环读取数据流</span>\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n      <span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>(); <span class="hljs-comment">// 读取一个数据块</span>\n\n      <span class="hljs-keyword">if</span> (done) {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;流已结束&quot;</span>);\n        <span class="hljs-keyword">break</span>;\n      }\n\n      <span class="hljs-comment">// 3. 处理数据块</span>\n      <span class="hljs-keyword">const</span> textChunk = decoder.<span class="hljs-title function_">decode</span>(value, { <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span> });\n      accumulatedText += textChunk;\n\n      <span class="hljs-comment">// 4. 实时更新UI（实现打字机效果）</span>\n      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;ai-response&quot;</span>).<span class="hljs-property">innerText</span> = accumulatedText;\n    }\n  } <span class="hljs-keyword">finally</span> {\n    reader.<span class="hljs-title function_">releaseLock</span>(); <span class="hljs-comment">// 释放锁</span>\n  }\n}\n\n<span class="hljs-comment">// 调用函数开始接收流</span>\n<span class="hljs-title function_">streamChat</span>();\n</code></pre>\n<p><strong>后端（Node.js + Express）示例：</strong></p>\n<pre><code class="language-javascript">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/api/chat&quot;</span>, <span class="hljs-title function_">async</span> (req, res) =&gt; {\n  <span class="hljs-comment">// 设置SSE头部，或者至少不要一次性发送</span>\n  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/plain; charset=utf-8&quot;</span>);\n  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Transfer-Encoding&quot;</span>, <span class="hljs-string">&quot;chunked&quot;</span>);\n\n  <span class="hljs-comment">// 模拟从AI模型获取流式数据</span>\n  <span class="hljs-keyword">const</span> mockStream = [<span class="hljs-string">&quot;你&quot;</span>, <span class="hljs-string">&quot;好&quot;</span>, <span class="hljs-string">&quot;，&quot;</span>, <span class="hljs-string">&quot;我&quot;</span>, <span class="hljs-string">&quot;是&quot;</span>, <span class="hljs-string">&quot;AI&quot;</span>, <span class="hljs-string">&quot;。&quot;</span>];\n\n  <span class="hljs-comment">// 逐块发送数据</span>\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> mockStream) {\n    res.<span class="hljs-title function_">write</span>(chunk); <span class="hljs-comment">// 发送一个数据块</span>\n    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>)); <span class="hljs-comment">// 模拟延迟</span>\n  }\n\n  res.<span class="hljs-title function_">end</span>(); <span class="hljs-comment">// 结束流</span>\n});\n</code></pre>\n<h3>总结</h3>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">特性</th>\n<th style="text-align:left">流式数据</th>\n<th style="text-align:left">非流式数据</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>用户体验</strong></td>\n<td style="text-align:left"><strong>极佳</strong>   ，即时反馈，响应迅速</td>\n<td style="text-align:left"><strong>差</strong>   ，长时间等待，易卡顿</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>内存占用</strong></td>\n<td style="text-align:left"><strong>低</strong>   ，逐步处理，无需缓存全部数据</td>\n<td style="text-align:left"><strong>高</strong>   ，需缓存完整响应</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>网络效率</strong></td>\n<td style="text-align:left"><strong>高</strong>   ，低延迟，逐步传输</td>\n<td style="text-align:left"><strong>低</strong>   ，高延迟，一次性传输</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>适用场景</strong></td>\n<td style="text-align:left"><strong>AI聊天、实时监控、视频播放</strong></td>\n<td style="text-align:left"><strong>下载小文件、简单的表单提交</strong></td>\n</tr>\n</tbody>\n</table>\n<p><strong>流式数据是现代Web应用，特别是AI产品的基石。</strong>   它通过“逐步处理”的理念，极大地提升了用户体验和系统效率，是前端开发者必须掌握的核心技术之一。</p>\n</div>'</script></body></html>