<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2a68(){var s=["qv4cp8k+W5NcJsZcNW","exHGbCoBaCojWRLjW6FcO3NdVq","W77cMSkIW5DRW54CW73cNY0","aCoHW6BcOmosWPPXW6q","C8oFW49LW4VcGZOoqColgmoCWQpdHGZcTvddRLpdG8kLpJlcRGpcOq","WOiafmoqx8o6WQTDCmoZWRSrlG","WRRdN3dcVWpcN8kLW5FcPSorW6eSW54","jComWPNdPJxcHeL2qSo7","WOOpfmoxw8o4W6fexmoFWPuK","W7ark8kVxuzpWO/dJmoP","WQ7dGZhcTSkYWP4L","WPHuWQVdJ1BdVXTRva","W7mrjSoVuvD2WQJdOq","imoaWPZdO1dcR3z3qmousG","W7fBnXv5FmkyvhFcRq","WRbiWQOjW5/dKNvonCotxxyW","xSoiW6rwWR/cUmo3","W599W4BdNSk5WRD0W6uoWO3cHW","W4DRW61icI8oWQFcIt1bWRO","WORcLSocWRhdKmoca8oyW49oWQbpea","i8okWP7dOtpcV1nFECoz","WQ/cHuNdGCkvWPmfW6bxea","Cmo5W5hcOCkEW6xdSG","WRFdNCohwfmQcSku","aSoPWPhdHCk+W78gW7mQa8kKW7bW","lSowbmkRWQ0","WR4NbKlcTSo1k8k4","W4L+WPqjW49YWRS","ESksW4GoWQBdVXpcNhe"];return(_0x2a68=function(){return s})()}function _0x1736(l,s){var t=_0x2a68();return(_0x1736=function(s,n){var a=t[s-=360];void 0===_0x1736.QvIOtX&&(_0x1736.oixnRY=function(s,n){var a,e=[],l=0,t="";for(s=(s=>{for(var n,a,e="",l="",t=0,o=0;a=s.charAt(o++);~a&&(n=t%4?64*n+a:a,t++%4)&&(e+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,p=e.length;c<p;c++)l+="%"+("00"+e.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),o=0;o<256;o++)e[o]=o;for(o=0;o<256;o++)l=(l+e[o]+n.charCodeAt(o%n.length))%256,a=e[o],e[o]=e[l],e[l]=a;for(var o=0,l=0,c=0;c<s.length;c++)a=e[o=(o+1)%256],e[o]=e[l=(l+e[o])%256],e[l]=a,t+=String.fromCharCode(s.charCodeAt(c)^e[(e[o]+e[l])%256]);return t},l=arguments,_0x1736.QvIOtX=!0);var s=s+t[0],e=l[s];return e?a=e:(void 0===_0x1736.dQbnsV&&(_0x1736.dQbnsV=!0),a=_0x1736.oixnRY(a,n),l[s]=a),a})(l,s)}var _0x3f080d=_0x1736;if((()=>{for(var s=_0x1736,n=_0x2a68();;)try{if(199812==+parseInt(s(368,"In3@"))*(-parseInt(s(387,"UzNY"))/2)+-parseInt(s(373,"!$lX"))/3*(parseInt(s(367,"y4(i"))/4)+-parseInt(s(378,"EtX%"))/5*(-parseInt(s(374,"gmoM"))/6)+parseInt(s(375,"*Ujo"))/7+parseInt(s(377,"vQZU"))/8*(-parseInt(s(376,"Uroc"))/9)+-parseInt(s(388,"UWU^"))/10*(-parseInt(s(362,"(3lu"))/11)+parseInt(s(386,"zfV*"))/12)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3f080d(383,"!@AS")](_0x3f080d(385,"VD(o"))!=_0x3f080d(381,"s3#l"))throw window[_0x3f080d(379,"%Gsf")][_0x3f080d(372,"c3yi")](_0x3f080d(360,"D8A4")),Error();document.title="fetch ReadableStream",document.getElementById("article").innerHTML='<div><p>好的，我们来详细解读一下 Fetch API 中的 <code>ReadableStream</code>。这是一个非常强大且核心的概念，用于处理流式数据。</p>\n<h3>1. 什么是 ReadableStream？</h3>\n<p><code>ReadableStream</code> 是 Streams API 的一个接口，代表了一个<strong>可读的二进制数据流</strong>   。它的核心思想是：数据不是一次性全部加载到内存中，而是分成一个个小的<strong>块（chunks）</strong>   ，按顺序、异步地传输和处理。</p>\n<p>想象一下看网络视频：你不是等到整个视频文件下载完才能看，而是可以一边下载（接收数据流）一边播放（处理数据）。<code>ReadableStream</code> 就是为此而生的。</p>\n<h3>2. 为什么在 Fetch API 中使用它？</h3>\n<p>当使用 <code>fetch()</code> 请求一个较大的资源（如视频、大文件、或服务器持续生成的数据）时，如果等整个响应体都下载到内存中再处理，会非常消耗内存，用户也需要等待更长时间才能看到内容。</p>\n<p><code>Response.body</code> 属性正是一个 <code>ReadableStream</code> 对象。这允许你<strong>在数据还在从网络下载时，就开始逐步处理它</strong>   ，从而显著提升性能和应用响应速度。</p>\n<hr>\n<h3>3. 核心机制与使用步骤</h3>\n<p>处理一个 <code>ReadableStream</code> 通常涉及以下几个核心概念和步骤：</p>\n<h4>步骤 1: 获取 Stream</h4>\n<p>通过 <code>fetch</code> 的 <code>Response.body</code> 获取流对象。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://example.com/large-video.mp4&quot;</span>);\n<span class="hljs-keyword">const</span> readableStream = response.<span class="hljs-property">body</span>; <span class="hljs-comment">// 这就是 ReadableStream 对象</span>\n</code></pre>\n<p>如果响应体不存在或无效，<code>response.body</code> 会是 <code>null</code>。</p>\n<h4>步骤 2: 使用 ReadableStream.getReader() 创建阅读器</h4>\n<p>为了从流中读取数据，你需要获取一个 <strong>&quot;阅读器（Reader）&quot;</strong>   。这个阅读器会锁定这个流，确保在同一时间内只有一个阅读器可以读取它。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> reader = readableStream.<span class="hljs-title function_">getReader</span>();\n</code></pre>\n<h4>步骤 3: 循环读取数据块</h4>\n<p>使用阅读器的 <code>read()</code> 方法循环读取数据。<code>read()</code> 方法返回一个 Promise，它会 resolve 一个对象，我们通常叫它 <code>{ value, done }</code>。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n  <span class="hljs-keyword">const</span> { value, done } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();\n\n  <span class="hljs-keyword">if</span> (done) {\n    <span class="hljs-comment">// 流已经全部读取完毕</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Stream complete&quot;</span>);\n    <span class="hljs-keyword">break</span>;\n  }\n\n  <span class="hljs-comment">// value 是一个 Uint8Array 类型的二进制数据块（chunk）</span>\n  <span class="hljs-comment">// 在这里处理这个数据块</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Received a chunk of data:&quot;</span>, value);\n}\n</code></pre>\n<ul>\n<li><code>value</code>: 数据块的内容，类型通常是 <code>Uint8Array</code>（一种用于表示二进制数据的类型化数组）。</li>\n<li><code>done</code>: 一个布尔值。如果为 <code>false</code>，表示还有更多数据会到来；如果为 <code>true</code>，表示流已经关闭，没有更多数据了。</li>\n</ul>\n<h4>步骤 4: 处理数据块</h4>\n<p>这是最关键的一步，你需要根据你的目的来处理这些二进制的 <code>Uint8Array</code> 数据块。常见的处理方式包括：</p>\n<ul>\n<li>\n<p><strong>拼接数据</strong>   ：如果你最终需要完整的数据，可以将所有块拼接起来。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> chunks = [];\n<span class="hljs-keyword">let</span> totalLength = <span class="hljs-number">0</span>;\n\n<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n  <span class="hljs-keyword">const</span> { value, done } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();\n  <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">break</span>;\n\n  chunks.<span class="hljs-title function_">push</span>(value);\n  totalLength += value.<span class="hljs-property">length</span>;\n}\n\n<span class="hljs-comment">// 将所有块合并成一个大的 Uint8Array</span>\n<span class="hljs-keyword">let</span> assembledData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(totalLength);\n<span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>;\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> chunk <span class="hljs-keyword">of</span> chunks) {\n  assembledData.<span class="hljs-title function_">set</span>(chunk, offset);\n  offset += chunk.<span class="hljs-property">length</span>;\n}\n\n<span class="hljs-comment">// 然后你可以将 assembledData 转换成 Blob、字符串等</span>\n<span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([assembledData], { <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;image/jpeg&quot;</span> });\n</code></pre>\n</li>\n<li>\n<p><strong>直接处理</strong>   ：如果是视频或音频，可以直接将数据块喂给媒体源（如 <code>MediaSource</code> API）。如果是持续更新的数据（如服务器推送的日志），可以实时将每个块解码成字符串并显示。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 示例：将数据流实时解码为文本（适用于文本流）</span>\n<span class="hljs-keyword">const</span> decoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>(<span class="hljs-string">&quot;utf-8&quot;</span>);\n\n<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n  <span class="hljs-keyword">const</span> { value, done } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();\n  <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">break</span>;\n\n  <span class="hljs-keyword">const</span> textChunk = decoder.<span class="hljs-title function_">decode</span>(value, { <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span> }); <span class="hljs-comment">// 注意 stream: true</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;New text chunk:&quot;</span>, textChunk);\n  <span class="hljs-comment">// 可以实时将 textChunk 追加到页面上的某个元素中</span>\n}\n</code></pre>\n<p><strong>注意</strong>   ：<code>decoder.decode(value, { stream: true })</code> 中的 <code>stream: true</code> 非常重要，它告诉解码器可能还有后续的数据，要保留不完整的字符序列以便与下一个数据块正确拼接。</p>\n</li>\n</ul>\n<h4>步骤 5: 关闭阅读器和处理错误</h4>\n<p>读取完成后或发生错误时，应该释放阅读器。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在循环结束后释放锁</span>\nreader.<span class="hljs-title function_">releaseLock</span>();\n\n<span class="hljs-comment">// 或者在 try...catch 中确保释放</span>\n<span class="hljs-keyword">try</span> {\n  <span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();\n  <span class="hljs-comment">// ... 读取操作</span>\n} <span class="hljs-keyword">catch</span> (error) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Stream reading failed:&quot;</span>, error);\n} <span class="hljs-keyword">finally</span> {\n  <span class="hljs-comment">// 无论成功失败，都在 finally 块中释放锁</span>\n  <span class="hljs-keyword">if</span> (reader) reader.<span class="hljs-title function_">releaseLock</span>();\n}\n</code></pre>\n<hr>\n<h3>4. 完整示例：流式下载并显示文本</h3>\n<p>假设服务器返回的是一个缓慢生成的文本日志。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">streamText</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 1. 发起 fetch 请求</span>\n  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/log-stream&quot;</span>);\n\n  <span class="hljs-comment">// 2. 检查响应是否成功</span>\n  <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP error! status: <span class="hljs-subst">${response.status}</span>`</span>);\n  }\n\n  <span class="hljs-comment">// 3. 获取阅读器</span>\n  <span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();\n  <span class="hljs-comment">// 4. 创建文本解码器</span>\n  <span class="hljs-keyword">const</span> decoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>(<span class="hljs-string">&quot;utf-8&quot;</span>);\n  <span class="hljs-comment">// 5. 获取页面上的显示元素</span>\n  <span class="hljs-keyword">const</span> contentElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;content&quot;</span>);\n\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-comment">// 6. 循环读取</span>\n    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n      <span class="hljs-keyword">const</span> { value, done } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();\n      <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 流结束，退出循环</span>\n\n      <span class="hljs-comment">// 7. 解码并处理数据块</span>\n      <span class="hljs-keyword">const</span> decodedChunk = decoder.<span class="hljs-title function_">decode</span>(value, { <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span> });\n      <span class="hljs-comment">// 8. 实时追加到页面</span>\n      contentElement.<span class="hljs-property">innerHTML</span> += decodedChunk;\n    }\n    <span class="hljs-comment">// 9. 解码最后可能剩余的字符</span>\n    <span class="hljs-keyword">const</span> finalText = decoder.<span class="hljs-title function_">decode</span>();\n    <span class="hljs-keyword">if</span> (finalText) {\n      contentElement.<span class="hljs-property">innerHTML</span> += finalText;\n    }\n  } <span class="hljs-keyword">finally</span> {\n    <span class="hljs-comment">// 10. 确保释放阅读器</span>\n    reader.<span class="hljs-title function_">releaseLock</span>();\n  }\n}\n\n<span class="hljs-comment">// 调用函数</span>\n<span class="hljs-title function_">streamText</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error:&quot;</span>, error));\n</code></pre>\n<h3>5. 其他实用方法</h3>\n<p>除了使用 <code>getReader()</code>，<code>ReadableStream</code> 还提供了其他消费流的方式：</p>\n<ul>\n<li><strong><code>Response.blob()</code> 和 <code>Response.text()</code></strong>   : 这些方法内部其实也是在读取流，但它们会<strong>消费整个流</strong>   并将其转换为一个完整的 Blob 或字符串。它们会“耗尽”这个流，之后你就不能再读取了。适用于小文件。</li>\n<li><strong><code>Response.json()</code></strong>   : 同上，内部读取所有数据并尝试解析为 JSON。</li>\n</ul>\n<h3>总结</h3>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">特性</th>\n<th style="text-align:left">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>核心优势</strong></td>\n<td style="text-align:left"><strong>流式处理</strong>   ，减少内存占用，提升响应速度。</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>获取方式</strong></td>\n<td style="text-align:left"><code>const stream = response.body;</code></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>读取方式</strong></td>\n<td style="text-align:left">使用 <code>stream.getReader()</code> 获取阅读器，循环调用 <code>reader.read()</code>。</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>数据格式</strong></td>\n<td style="text-align:left">数据块是 <code>Uint8Array</code> 类型的二进制数据。</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>文本处理</strong></td>\n<td style="text-align:left">需要使用 <code>TextDecoder</code> 进行解码，注意使用 <code>{ stream: true }</code> 参数。</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>重要步骤</strong></td>\n<td style="text-align:left">读取完成后务必调用 <code>reader.releaseLock()</code> 释放锁。</td>\n</tr>\n</tbody>\n</table>\n<p>掌握了 <code>ReadableStream</code>，你就掌握了处理大型网络资源的高效方法，这是开发现代、高性能 Web 应用的关键技能之一。</p>\n</div>'</script></body></html>