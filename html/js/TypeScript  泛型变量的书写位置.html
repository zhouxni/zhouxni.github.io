<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x45bbb5=_0x3768;function _0x3768(l,s){var p=_0xa761();return(_0x3768=function(s,n){var a=p[s-=336];void 0===_0x3768.JoIBTH&&(_0x3768.tBAarK=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,r=0;a=s.charAt(r++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,e=t.length;c<e;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),r=0;r<256;r++)t[r]=r;for(r=0;r<256;r++)l=(l+t[r]+n.charCodeAt(r%n.length))%256,a=t[r],t[r]=t[l],t[l]=a;for(var r=0,l=0,c=0;c<s.length;c++)a=t[r=(r+1)%256],t[r]=t[l=(l+t[r])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(c)^t[(t[r]+t[l])%256]);return p},l=arguments,_0x3768.JoIBTH=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x3768.GKMyln&&(_0x3768.GKMyln=!0),a=_0x3768.tBAarK(a,n),l[s]=a),a})(l,s)}function _0xa761(){var s=["hmkJWR7dSGtcMrK","W5W/W5KSp8kPv2tcRWhdGwy","W63cPcNdM8k1WO17W5C","W7bKF2/dNLO+l8oLWRFdTH8","W7pcIG8dmspdVq","vSo+W4FcSmoaWRhdL8o5j8oZW798WR4","W4WBW4RdSJDGwCoRWRX0W7nE","t8kxWOtdRWpcRbG","WRFdKCoXBwldS8oCFmoiW5FdPG","W4dcKmkwqHTxFSk3imkzW5X6va","W7hcNmk6lYm","zevGW5nlFZdcIXNdNCoTomk7WOjwW4ldScT5W6b8W6msW6VdL8oE","W7qeWQtdOSoGhmkdlvmLkq","W6pcIc5lW60dWQVdLCkSc30A","W5VdPSo8W68bWPKE","l33dJ8ouW4r7gYtcRG","W4hdUaJcO8o9y8kiWOdcRmkEvW","A8oYWO9YWQVcJmo/vSoJWRRdLhi","W4RdNcddImksWQ0F","WRSImSk3WPO8WRyaWOKxW4Dz","oSo2hgP4xmo0wX0","W40zW4hdSJDGEmo9WO1MW7nc","xaLSWPnkWRZcLMG","mbtcNCk2aSkzqa","WPK0cKCFoCk3rLxdISkH","wmoUWRvyW47dJ8kTWRK","vSo5W4ldJ8kdW7NcSConha","WPu0duyFECkuxwxdS8kKma"];return(_0xa761=function(){return s})()}if((()=>{for(var s=_0x3768,n=_0xa761();;)try{if(155906==+parseInt(s(338,"5ecF"))+-parseInt(s(353,"Vns@"))/2*(parseInt(s(343,"HZWN"))/3)+parseInt(s(358,"du3t"))/4*(-parseInt(s(339,"NTot"))/5)+-parseInt(s(347,"yP6v"))/6+parseInt(s(359,"Ykjz"))/7+-parseInt(s(346,"%ypg"))/8*(-parseInt(s(356,"F)ox"))/9)+parseInt(s(352,"9Q&K"))/10*(parseInt(s(357,"WoXU"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x45bbb5(337,"du3t")](_0x45bbb5(350,"Bp7@"))!=_0x45bbb5(340,"5ecF"))throw window[_0x45bbb5(360,"bBt5")][_0x45bbb5(344,"hr8A")](_0x45bbb5(341,"Q%XQ")),Error();document.title="TypeScript  泛型变量的书写位置",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，泛型变量的书写位置取决于使用场景，以下是不同情况下泛型变量的常见位置：</p>\n<hr>\n<h3>1. <strong>函数声明中的泛型变量</strong></h3>\n<p><strong>位置</strong>  ：紧接在函数名之后，用尖括号 <code>&lt;&gt;</code> 包裹</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T {  <span class="hljs-comment">// &lt;T&gt; 在函数名后</span>\n  <span class="hljs-keyword">return</span> arg;\n}\n\n<span class="hljs-comment">// 箭头函数写法</span>\n<span class="hljs-keyword">const</span> identity = &lt;T&gt;(<span class="hljs-attr">arg</span>: T): <span class="hljs-function"><span class="hljs-params">T</span> =&gt;</span> arg;\n</code></pre>\n<hr>\n<h3>2. <strong>接口/类型别名中的泛型变量</strong></h3>\n<p><strong>位置</strong>  ：紧接在接口/类型名之后</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">KeyValuePair</span>&lt;K, V&gt; {  <span class="hljs-comment">// &lt;K, V&gt; 在接口名后</span>\n  <span class="hljs-attr">key</span>: K;\n  <span class="hljs-attr">value</span>: V;\n}\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Callback</span>&lt;T&gt; = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">data</span>: T</span>) =&gt;</span> <span class="hljs-built_in">void</span>;  <span class="hljs-comment">// &lt;T&gt; 在类型别名后</span>\n</code></pre>\n<hr>\n<h3>3. <strong>类声明中的泛型变量</strong></h3>\n<p><strong>位置</strong>  ：紧接在类名之后</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>&lt;T&gt; {  <span class="hljs-comment">// &lt;T&gt; 在类名后</span>\n  <span class="hljs-keyword">private</span> <span class="hljs-attr">item</span>: T;\n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">item</span>: T</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span> = item;\n  }\n}\n</code></pre>\n<hr>\n<h3>4. <strong>方法中的泛型变量（类内部）</strong></h3>\n<p><strong>位置</strong>  ：方法名之后（独立于类的泛型）</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiClient</span> {\n  fetch&lt;T&gt;(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; {  <span class="hljs-comment">// &lt;T&gt; 在方法名后</span>\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(url).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>());\n  }\n}\n</code></pre>\n<hr>\n<h3>5. <strong>调用时的显式泛型参数</strong></h3>\n<p><strong>位置</strong>  ：函数名/方法名之后（调用时指定）</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> result = identity&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">// &lt;string&gt; 在调用时指定</span>\n\n<span class="hljs-keyword">const</span> arr = <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 创建数字数组</span>\n</code></pre>\n<hr>\n<h3>6. <strong>高阶组件/高阶函数中的泛型</strong></h3>\n<p><strong>位置</strong>  ：多层嵌套时每层都可以有自己的泛型</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> withLogging&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>&gt;(<span class="hljs-attr">fn</span>: T): T {  <span class="hljs-comment">// 外层泛型</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Calling function&quot;</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(...args);\n  } <span class="hljs-keyword">as</span> <span class="hljs-built_in">unknown</span> <span class="hljs-keyword">as</span> T;\n}\n</code></pre>\n<hr>\n<h3>7. <strong>默认泛型参数</strong></h3>\n<p><strong>位置</strong>  ：泛型声明处可以设置默认值</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Pagination</span>&lt;T = <span class="hljs-built_in">string</span>&gt; {  <span class="hljs-comment">// 默认泛型类型</span>\n  <span class="hljs-attr">data</span>: T[];\n  <span class="hljs-attr">page</span>: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-comment">// 使用时可不指定泛型</span>\n<span class="hljs-keyword">const</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Pagination</span> = { <span class="hljs-attr">data</span>: [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>], <span class="hljs-attr">page</span>: <span class="hljs-number">1</span> }; \n</code></pre>\n<hr>\n<h3>8. <strong>约束泛型类型（extends）</strong></h3>\n<p><strong>位置</strong>  ：泛型声明处通过 extends 添加约束</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> longest&lt;T <span class="hljs-keyword">extends</span> { <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span> }&gt;(<span class="hljs-attr">a</span>: T, <span class="hljs-attr">b</span>: T): T {\n  <span class="hljs-keyword">return</span> a.<span class="hljs-property">length</span> &gt; b.<span class="hljs-property">length</span> ? a : b;\n}\n</code></pre>\n<hr>\n<h3>9. <strong>JSX/TSX 中的特殊写法</strong></h3>\n<p>在 <code>.tsx</code> 文件中，为避免与 JSX 标签冲突，需要这样写：</p>\n<pre><code class="language-tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>&gt;<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">props</span>: { data: T }</span>) =&gt;</span> (\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{JSON.stringify(props.data)}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n);\n<span class="hljs-comment">// 或者使用类型断言</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = &lt;T,&gt;<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">props</span>: { data: T }</span>) =&gt;</span> (\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{JSON.stringify(props.data)}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n);\n</code></pre>\n<hr>\n<h3>关键记忆点：</h3>\n<ol>\n<li><strong>声明位置</strong>  ：总是紧接在被修饰的 <strong>名称（函数/类/接口/类型）之后</strong></li>\n<li><strong>调用位置</strong>  ：在调用表达式名称之后</li>\n<li><strong>多层泛型</strong>  ：每层可以有自己的泛型参数</li>\n<li><strong>TSX 特殊情况</strong>  ：需要添加逗号或 extends 避免语法歧义</li>\n</ol>\n<p>通过这种统一的定位规则，TypeScript 能明确区分泛型参数和其他语法结构，保持代码的可读性和类型安全性。</p>\n</div>'</script></body></html>