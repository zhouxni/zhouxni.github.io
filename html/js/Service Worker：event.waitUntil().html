<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x43e5ec=_0x5092;function _0x1498(){var n=["WOzlmCoVgGCJWPeW","W6HcW7ldHCkHfri","nJhdRmkSh8oiW4JcM8k9F8kaxG","y8kMWPLXwmoqE8oRW4JdLSoKWQ7dOW","Fx/dOmofWP7cO8o6ga","W7yyySk9uefDWOyBo2WnDG","WO9kaSomwsJdRG","nmoTW7tcIdRcQCkrpsi7","DtlcVSoOa0Sk","WQpdNHRdKHm","WObBaSo1xNFcRdRcMelcLtKvmCk0WPDoW4tcLCkAW6CAumk8W6Sj","urBdHe3dSN7dRZhcHmkCW5f0yW","mCoPW7lcHKVcVmkEfIGgW48","W5OBrCk1hx7cS2xcQNdcMa8H","W7KmW7pdJCkiCcVcR2JcRa","nZ3cLmoKCCkEW7ZcRW","ictcU8kvW57dUSkSeCobWQ7cSCo+WQu","DJVcT0yWW7mecG","sbHGlCkyyCkD","W65NW4FcNrRcHKpdR0xcQ2RdUqe","WQFcVCkWymkPqKFdH1JdVCo1Fmka","WPP6WOhcHCk6CSoE","W6lcNL3cLfSrvmozzSoNtvWz","WQddPSoGg8oWpJS","WOldVN/cOLFcI8khlSo2WOvYWOG","WQu7nCoVW4vNWRJcPfzZea"];return(_0x1498=function(){return n})()}function _0x5092(t,n){var l=_0x1498();return(_0x5092=function(n,s){var a=l[n-=395];void 0===_0x5092.JuuXtB&&(_0x5092.kBYCpJ=function(n,s){var a,e=[],t=0,l="";for(n=(n=>{for(var s,a,e="",t="",l=0,c=0;a=n.charAt(c++);~a&&(s=l%4?64*s+a:a,l++%4)&&(e+=String.fromCharCode(255&s>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,i=e.length;o<i;o++)t+="%"+("00"+e.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(t)})(n),c=0;c<256;c++)e[c]=c;for(c=0;c<256;c++)t=(t+e[c]+s.charCodeAt(c%s.length))%256,a=e[c],e[c]=e[t],e[t]=a;for(var c=0,t=0,o=0;o<n.length;o++)a=e[c=(c+1)%256],e[c]=e[t=(t+e[c])%256],e[t]=a,l+=String.fromCharCode(n.charCodeAt(o)^e[(e[c]+e[t])%256]);return l},t=arguments,_0x5092.JuuXtB=!0);var n=n+l[0],e=t[n];return e?a=e:(void 0===_0x5092.lDOqeW&&(_0x5092.lDOqeW=!0),a=_0x5092.kBYCpJ(a,s),t[n]=a),a})(t,n)}if((()=>{for(var n=_0x5092,s=_0x1498();;)try{if(110454==+parseInt(n(395,"8JiM"))*(-parseInt(n(412,"RoPS"))/2)+-parseInt(n(417,"ihf4"))/3*(parseInt(n(407,"RoPS"))/4)+-parseInt(n(405,"l[yE"))/5*(parseInt(n(418,"#Y(E"))/6)+parseInt(n(403,"68DE"))/7+parseInt(n(398,"Oky["))/8+-parseInt(n(416,"#Lon"))/9+parseInt(n(413,"xBh&"))/10)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x43e5ec(406,"xBh&")](_0x43e5ec(400,"l[yE"))!=_0x43e5ec(409,"tlmz"))throw window[_0x43e5ec(404,"#Lon")][_0x43e5ec(408,"yo!b")](_0x43e5ec(410,"xBh&")),Error();document.title="Service Worker：event.waitUntil()",document.getElementById("article").innerHTML='<div><p><code>event.waitUntil()</code> 是 Service Worker 中的一个重要方法，用于延长事件的生命周期，确保在处理某些异步操作（如网络请求、缓存更新、显示通知等）时，Service Worker 不会因事件处理完成而过早关闭。</p>\n<h3><strong>作用</strong></h3>\n<p>在 Service Worker 中，许多事件（如 <code>fetch</code>、<code>push</code>、<code>sync</code> 等）的生命周期较短。默认情况下，事件处理函数执行完毕后，Service Worker 可能会立即终止。如果事件处理函数中包含了异步操作（如网络请求、数据库操作等），这些操作可能会因 Service Worker 的关闭而被中断。</p>\n<p><code>event.waitUntil()</code> 方法接收一个 Promise，并告诉浏览器等待这个 Promise 完成后再结束事件。这确保了异步操作有足够的时间完成。</p>\n<hr>\n<h3><strong>语法</strong></h3>\n<pre><code class="language-javascript">event.<span class="hljs-title function_">waitUntil</span>(promise);\n</code></pre>\n<ul>\n<li><strong>参数</strong>  ：\n<ul>\n<li><code>promise</code>：一个 Promise 对象，表示需要等待完成的异步操作。</li>\n</ul>\n</li>\n<li><strong>返回值</strong>  ：无返回值。</li>\n</ul>\n<hr>\n<h3><strong>使用场景</strong></h3>\n<ol>\n<li><strong>缓存资源</strong>  ：\n<ul>\n<li>在 <code>install</code> 事件中，使用 <code>event.waitUntil()</code> 确保所有资源都被成功缓存。</li>\n</ul>\n</li>\n<li><strong>处理推送通知</strong>  ：\n<ul>\n<li>在 <code>push</code> 事件中，使用 <code>event.waitUntil()</code> 确保通知被成功显示。</li>\n</ul>\n</li>\n<li><strong>同步数据</strong>  ：\n<ul>\n<li>在 <code>sync</code> 事件中，使用 <code>event.waitUntil()</code> 确保后台同步操作完成。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>示例</strong></h3>\n<h4><strong>1. 缓存资源</strong></h4>\n<p>在 Service Worker 的 <code>install</code> 事件中，使用 <code>event.waitUntil()</code> 缓存资源：</p>\n<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">waitUntil</span>(\n    caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;my-cache-v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">addAll</span>([\n        <span class="hljs-string">&#x27;/index.html&#x27;</span>,\n        <span class="hljs-string">&#x27;/styles.css&#x27;</span>,\n        <span class="hljs-string">&#x27;/script.js&#x27;</span>,\n        <span class="hljs-string">&#x27;/image.png&#x27;</span>\n      ]);\n    })\n  );\n});\n</code></pre>\n<ul>\n<li><strong>解释</strong>  ：\n<ul>\n<li><code>caches.open(\'my-cache-v1\')</code> 打开一个缓存。</li>\n<li><code>cache.addAll([...])</code> 将指定的资源添加到缓存中。</li>\n<li><code>event.waitUntil()</code> 确保缓存操作完成后再结束 <code>install</code> 事件。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4><strong>2. 处理推送通知</strong></h4>\n<p>在 <code>push</code> 事件中，使用 <code>event.waitUntil()</code> 显示通知：</p>\n<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;push&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  <span class="hljs-keyword">const</span> data = event.<span class="hljs-property">data</span> ? event.<span class="hljs-property">data</span>.<span class="hljs-title function_">json</span>() : {};\n  <span class="hljs-keyword">const</span> title = data.<span class="hljs-property">title</span> || <span class="hljs-string">&#x27;默认标题&#x27;</span>;\n  <span class="hljs-keyword">const</span> options = {\n    <span class="hljs-attr">body</span>: data.<span class="hljs-property">body</span> || <span class="hljs-string">&#x27;默认内容&#x27;</span>,\n    <span class="hljs-attr">icon</span>: data.<span class="hljs-property">icon</span> || <span class="hljs-string">&#x27;/icon.png&#x27;</span>\n  };\n\n  event.<span class="hljs-title function_">waitUntil</span>(\n    self.<span class="hljs-property">registration</span>.<span class="hljs-title function_">showNotification</span>(title, options)\n  );\n});\n</code></pre>\n<ul>\n<li><strong>解释</strong>  ：\n<ul>\n<li><code>self.registration.showNotification(title, options)</code> 显示通知。</li>\n<li><code>event.waitUntil()</code> 确保通知被成功显示后再结束 <code>push</code> 事件。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4><strong>3. 同步数据</strong></h4>\n<p>在 <code>sync</code> 事件中，使用 <code>event.waitUntil()</code> 执行后台同步操作：</p>\n<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;sync&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">tag</span> === <span class="hljs-string">&#x27;sync-data&#x27;</span>) {\n    event.<span class="hljs-title function_">waitUntil</span>(\n      <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://example.com/sync-data&#x27;</span>, {\n        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,\n        <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">some</span>: <span class="hljs-string">&#x27;data&#x27;</span> }),\n        <span class="hljs-attr">headers</span>: {\n          <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>\n        }\n      }).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {\n        <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {\n          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;同步失败&#x27;</span>);\n        }\n      })\n    );\n  }\n});\n</code></pre>\n<ul>\n<li><strong>解释</strong>  ：\n<ul>\n<li>检查 <code>event.tag</code> 是否匹配需要处理的同步任务。</li>\n<li>使用 <code>fetch()</code> 发送同步数据。</li>\n<li><code>event.waitUntil()</code> 确保同步操作完成后再结束 <code>sync</code> 事件。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>注意事项</strong></h3>\n<ol>\n<li><strong>Promise 必须被返回</strong>  ：\n<ul>\n<li><code>event.waitUntil()</code> 接收的必须是一个 Promise。如果传入的不是 Promise，或 Promise 永远不解决（pending 状态），事件可能会被无限期延长。</li>\n</ul>\n</li>\n<li><strong>避免长时间等待</strong>  ：\n<ul>\n<li>虽然 <code>event.waitUntil()</code> 可以延长事件的生命周期，但应避免执行过长时间的异步操作。如果操作需要很长时间，考虑使用后台任务或其他机制。</li>\n</ul>\n</li>\n<li><strong>错误处理</strong>  ：\n<ul>\n<li>在 <code>event.waitUntil()</code> 的 Promise 中添加错误处理逻辑，确保即使操作失败，事件也能正常结束。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>总结</strong></h3>\n<p><code>event.waitUntil()</code> 是 Service Worker 中处理异步操作的关键方法，它确保了事件在处理异步任务时有足够的时间完成。通过合理使用 <code>event.waitUntil()</code>，可以确保缓存、通知、同步等操作的可靠性和稳定性，提升用户体验。</p>\n</div>'</script></body></html>