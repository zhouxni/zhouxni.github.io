<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2771fe=_0x1e3e;function _0x1e3e(e,n){var a=_0x4770();return(_0x1e3e=function(n,s){var t=a[n-=153];void 0===_0x1e3e.HdvPro&&(_0x1e3e.sLYJSI=function(n,s){var t,o=[],e=0,a="";for(n=(n=>{for(var s,t,o="",e="",a=0,d=0;t=n.charAt(d++);~t&&(s=a%4?64*s+t:t,a++%4)&&(o+=String.fromCharCode(255&s>>(-2*a&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var c=0,l=o.length;c<l;c++)e+="%"+("00"+o.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(n),d=0;d<256;d++)o[d]=d;for(d=0;d<256;d++)e=(e+o[d]+s.charCodeAt(d%s.length))%256,t=o[d],o[d]=o[e],o[e]=t;for(var d=0,e=0,c=0;c<n.length;c++)t=o[d=(d+1)%256],o[d]=o[e=(e+o[d])%256],o[e]=t,a+=String.fromCharCode(n.charCodeAt(c)^o[(o[d]+o[e])%256]);return a},e=arguments,_0x1e3e.HdvPro=!0);var n=n+a[0],o=e[n];return o?t=o:(void 0===_0x1e3e.lHndMp&&(_0x1e3e.lHndMp=!0),t=_0x1e3e.sLYJSI(t,s),e[n]=t),t})(e,n)}if((()=>{for(var n=_0x1e3e,s=_0x4770();;)try{if(424061==+parseInt(n(164,"8%*6"))+-parseInt(n(171,"Tus5"))/2+parseInt(n(178,"U]Hb"))/3*(parseInt(n(173,"E4bP"))/4)+-parseInt(n(177,"8DSU"))/5*(parseInt(n(153,"9PrK"))/6)+parseInt(n(170,"a$F*"))/7+parseInt(n(157,"8%*6"))/8+-parseInt(n(156,"Oa9R"))/9*(parseInt(n(158,"bAOv"))/10))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x2771fe(165,"4]8i")](_0x2771fe(159,"s@[U"))!=_0x2771fe(176,"BS[9"))throw window[_0x2771fe(168,"aCKf")][_0x2771fe(160,"6De&")](_0x2771fe(163,"4]8i")),Error();function _0x4770(){var n=["lmo9W6HZE3CfW6zxW6eLmW","WOzCoCkKW6HsW5jfwrpdPCoy","Ex3dOdNcKSkEWPtcSG","kmk4AcRcGCoVDSoaWOZcUCkYbSkD","WPbmqHtdIMdcN8keW4uxW79ojG","tCo7suFdUsC3n8kk","WRLDWPNcSmoEW5JdRa","WPbjrHddIwlcNCkeW4SqW7blgW","WPJcSN0HlCkfEG","FmkPWPZdHumnnCowWORdVCo8kSoEW6yBE8o+W4bsW5tdUuXiuv3dGq","lSk/BIlcImoSpCoKWQdcI8knmG","C8k4WPZdVersDW","W7pcVSo5WO3dJmkOiKJcPmkgWQavEa","sSkbWPafWRBdVMZdHq","gu5IW6hcSmoiW5tdGa","WPtdUcboFmonoCkKgN9ZsCkA","WOX0eJpcMmoAWPrqh2ulrCkW","db3dTdeKW4OjW44JW7qdW58","aY47W67dOSo6W7/dGN3dMG/dNMW","W43cLmkjyuXpnCkLc1XujbO","WP9OW5/cJuRcQ2FdOIxcTSkzDq","aG3cTmoHWPddR2aY","q8k4bwjy","W7FdVcnJjCoSWQ1C","FcBdG1ddHrpcPa","iCkMWQdcL8kfWQ5MpCoTemkvtW"];return(_0x4770=function(){return n})()}document.title="JavaScript 的基本数据类型",document.getElementById("article").innerHTML='<div><p>JavaScript 的基本数据类型（<strong>Primitive Types</strong>   ）是语言中最基础的数据类型，它们直接存储在栈内存中，具有不可变性。以下是所有基本数据类型及其特性：</p>\n<hr>\n<h3><strong>1. 7 种基本数据类型（ES6+）</strong></h3>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>示例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong><code>Number</code></strong></td>\n<td><code>42</code>, <code>3.14</code>, <code>NaN</code></td>\n<td>所有数字（整数、浮点数、<code>NaN</code>），采用 64 位双精度浮点格式（IEEE 754）。</td>\n</tr>\n<tr>\n<td><strong><code>String</code></strong></td>\n<td><code>&quot;hello&quot;</code>, <code>\'世界\'</code></td>\n<td>文本数据，不可变（修改字符串会创建新值）。</td>\n</tr>\n<tr>\n<td><strong><code>Boolean</code></strong></td>\n<td><code>true</code>, <code>false</code></td>\n<td>逻辑值，仅有两个可能的值。</td>\n</tr>\n<tr>\n<td><strong><code>Undefined</code></strong></td>\n<td><code>undefined</code></td>\n<td>变量未初始化时的默认值（或访问对象不存在的属性）。</td>\n</tr>\n<tr>\n<td><strong><code>Null</code></strong></td>\n<td><code>null</code></td>\n<td>表示“空值”（通常用于显式清空变量）。</td>\n</tr>\n<tr>\n<td><strong><code>Symbol</code></strong></td>\n<td><code>Symbol(\'id\')</code></td>\n<td>ES6 新增，唯一且不可变的值（用于对象属性的唯一键）。</td>\n</tr>\n<tr>\n<td><strong><code>BigInt</code></strong></td>\n<td><code>9007199254740991n</code></td>\n<td>ES2020 新增，表示任意精度的整数（后缀加 <code>n</code>）。</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>2. 基本数据类型的特性</strong></h3>\n<h4><strong>(1) 不可变性（Immutable）</strong></h4>\n<ul>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abc&quot;</span>;\nstr[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;d&quot;</span>; <span class="hljs-comment">// 无效！字符串不可变</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str); <span class="hljs-comment">// 仍输出 &quot;abc&quot;</span>\n</code></pre>\n</li>\n<li><strong>原理</strong>   ：修改基本类型值会创建新值，而非修改原值。</li>\n</ul>\n<h4><strong>(2) 按值传递（Pass by Value）</strong></h4>\n<ul>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;\n<span class="hljs-keyword">let</span> b = a; <span class="hljs-comment">// b 是 a 的副本</span>\na = <span class="hljs-number">20</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 输出 10（b 不受 a 后续变化影响）</span>\n</code></pre>\n</li>\n</ul>\n<h4><strong>(3) 严格类型比较（<code>===</code>）</strong></h4>\n<ul>\n<li>基本类型直接比较值：<pre><code class="language-javascript"><span class="hljs-string">&quot;5&quot;</span> === <span class="hljs-number">5</span>; <span class="hljs-comment">// false（类型不同）</span>\n<span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// false</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>3. 特殊值说明</strong></h3>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>类型</th>\n<th>常见场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong><code>NaN</code></strong></td>\n<td><code>Number</code></td>\n<td>非数字结果（如 <code>0 / 0</code>），唯一不自等的值：<code>NaN !== NaN</code>。</td>\n</tr>\n<tr>\n<td><strong><code>Infinity</code></strong></td>\n<td><code>Number</code></td>\n<td>数值超出 <code>Number.MAX_VALUE</code> 时产生（如 <code>1 / 0</code>）。</td>\n</tr>\n<tr>\n<td><strong><code>null</code></strong></td>\n<td><code>Null</code></td>\n<td>开发者显式赋空值（<code>typeof null</code> 返回 <code>&quot;object&quot;</code>，这是历史遗留 bug）。</td>\n</tr>\n<tr>\n<td><strong><code>undefined</code></strong></td>\n<td><code>Undefined</code></td>\n<td>变量未赋值、函数无返回值时的默认值。</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>4. 如何判断数据类型？</strong></h3>\n<h4><strong>(1) <code>typeof</code> 运算符</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// &quot;number&quot;</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">// &quot;string&quot;</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// &quot;boolean&quot;</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// &quot;undefined&quot;</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// &quot;object&quot; （历史遗留问题！）</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span>(); <span class="hljs-comment">// &quot;symbol&quot;</span>\n<span class="hljs-keyword">typeof</span> <span class="hljs-number">10n</span>; <span class="hljs-comment">// &quot;bigint&quot;</span>\n</code></pre>\n<h4><strong>(2) <code>Object.prototype.toString.call()</code></strong></h4>\n<p>更精确的类型判断：</p>\n<pre><code class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// &quot;[object Null]&quot;</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>([]); <span class="hljs-comment">// &quot;[object Array]&quot;</span>\n</code></pre>\n<hr>\n<h3><strong>5. 基本类型 vs 引用类型</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>基本类型</strong></th>\n<th><strong>引用类型（如 Object、Array）</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>存储位置</td>\n<td>栈内存（直接存储值）</td>\n<td>堆内存（存储地址，栈中存指针）</td>\n</tr>\n<tr>\n<td>可变性</td>\n<td>不可变</td>\n<td>可变（可修改属性或元素）</td>\n</tr>\n<tr>\n<td>比较方式</td>\n<td>值比较 (<code>1 === 1</code>)</td>\n<td>引用比较 (<code>{} !== {}</code>)</td>\n</tr>\n<tr>\n<td>复制行为</td>\n<td>创建新副本</td>\n<td>复制指针（共享同一对象）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>6. 常见问题</strong></h3>\n<h4><strong>Q1: <code>null</code> 和 <code>undefined</code> 的区别？</strong></h4>\n<ul>\n<li><code>undefined</code> 是变量未赋值的默认状态。</li>\n<li><code>null</code> 是开发者主动赋值的“空”标记。</li>\n</ul>\n<h4><strong>Q2: 为什么 <code>typeof null</code> 返回 <code>&quot;object&quot;</code>？</strong></h4>\n<ul>\n<li>JavaScript 早期设计错误，已无法修复（影响现有代码）。</li>\n</ul>\n<h4><strong>Q3: 如何安全判断 <code>NaN</code>？</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// true（不推荐，会隐式转换类型）</span>\n<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// true（ES6 推荐）</span>\n</code></pre>\n<hr>\n<p>掌握基本数据类型是理解 JavaScript 的核心基础，后续学习引用类型（如 <code>Object</code>、<code>Array</code>）时需注意它们的本质区别！</p>\n</div>'</script></body></html>