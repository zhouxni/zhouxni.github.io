<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1059(){var s=["imkMomo1W4XUW7zbWQ8","W4FcRvysW6RcQrbyq8kLW58+","CHhdPCkGtSoJzCoXW7zzCmorW4m","WQ3dVqCJWPHOW5HOwq12Eq","BmkXWQCwWQVdJSogWRi","nw01kCoXW48+dGZdLW","WO3cIMBcOmoAW77cP2lcL1K","BColWQXWCCoNWP0","wmoJhsKoW53dRIddJSojW6tcK8kS","ENKMWP9fWRPlWPRcGxu","WO1gieFdKmocW6ddV8kmWQXGjG","xmoGeIunW5FcJYZdHCojW6BcVW","W5e+CvVcOmoDnsO","zCkFj8oQz8oqW6/dMG","WOxdUSkAW7OuW7lcQmkjEsldL2y","W5JcOIZdS8oOgcePx3W","W6XOAd7dNIhdI8kaW4/dGG","F1RdNHmLe2lcJSks","WO5fkKtdUSkWWPmGW5GQ","jtrHW59/W5qjW5lcVLhdHCo/W53cRCokWRfjdqVcRfyhW7FdPmkVWPS","bahdSLrG","D8kqbSoRW43cKCk4","iCkahe8TiLRdVwj3tKq","FhaGW5zaWRTuWP/cIW","xmkkFKRcOmkqzSkFwIypDG"];return(_0x1059=function(){return s})()}var _0x5adb41=_0x116d;function _0x116d(e,s){var t=_0x1059();return(_0x116d=function(s,n){var a=t[s-=362];void 0===_0x116d.DSuoUA&&(_0x116d.EayuJo=function(s,n){var a,l=[],e=0,t="";for(s=(s=>{for(var n,a,l="",e="",t=0,c=0;a=s.charAt(c++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,o=l.length;p<o;p++)e+="%"+("00"+l.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)e=(e+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[e],l[e]=a;for(var c=0,e=0,p=0;p<s.length;p++)a=l[c=(c+1)%256],l[c]=l[e=(e+l[c])%256],l[e]=a,t+=String.fromCharCode(s.charCodeAt(p)^l[(l[c]+l[e])%256]);return t},e=arguments,_0x116d.DSuoUA=!0);var s=s+t[0],l=e[s];return l?a=l:(void 0===_0x116d.ZKNcZK&&(_0x116d.ZKNcZK=!0),a=_0x116d.EayuJo(a,n),e[s]=a),a})(e,s)}if((()=>{for(var s=_0x116d,n=_0x1059();;)try{if(387284==-parseInt(s(379,"3)d1"))+-parseInt(s(386,"Ztnm"))/2+-parseInt(s(383,"MLn$"))/3+parseInt(s(377,"q%*G"))/4+parseInt(s(376,"!aVb"))/5*(parseInt(s(381,"uaUr"))/6)+-parseInt(s(363,"XZS5"))/7*(parseInt(s(366,"vRnz"))/8)+parseInt(s(369,"Y28j"))/9*(parseInt(s(371,"]41^"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5adb41(374,"i3bZ")](_0x5adb41(370,"udnt"))!=_0x5adb41(373,"P#X8"))throw window[_0x5adb41(365,"*p]9")][_0x5adb41(385,"y%xc")](_0x5adb41(372,"!aVb")),Error();document.title="typescript 索引签名和索引类型",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，索引类型和索引签名是与对象的键和值相关的两个重要概念。它们允许你以灵活和类型安全的方式处理对象。</p>\n<hr>\n<h3><strong>1. 索引签名（Index Signatures）</strong></h3>\n<p>索引签名用于定义对象类型，其中键是字符串或数字，值可以是任意类型。索引签名提供了一种方式来表示对象可以具有任意数量的属性，只要这些属性符合指定的键和值类型。</p>\n<h4><strong>语法</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyObject</span> {\n  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 字符串键，值必须是数字</span>\n}\n</code></pre>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">StringToNumber</span> {\n  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">StringToNumber</span> = {\n  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,\n  <span class="hljs-attr">height</span>: <span class="hljs-number">170</span>,\n  <span class="hljs-attr">weight</span>: <span class="hljs-number">70</span>\n};\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[<span class="hljs-string">&#x27;age&#x27;</span>]); <span class="hljs-comment">// 输出: 30</span>\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li><code>StringToNumber</code> 接口定义了一个索引签名，表示对象可以有任意数量的字符串键，每个键对应的值必须是数字。</li>\n<li><code>obj</code> 符合这个接口，因为它有字符串键，且每个键的值都是数字。</li>\n</ul>\n<h4><strong>数字索引签名</strong></h4>\n<p>虽然不常见，但你也可以使用数字作为索引签名：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NumberArray</span> {\n  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>: <span class="hljs-title class_">NumberArray</span> = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 输出: &#x27;b&#x27;</span>\n</code></pre>\n<p><strong>注意</strong>  ：</p>\n<ul>\n<li>数字索引签名通常用于数组或类数组对象。</li>\n<li>如果一个接口同时定义了字符串和数字索引签名，数字索引签名的值类型必须是字符串索引签名值类型的子类型（因为数字可以被视为字符串的一种特殊情况）。</li>\n</ul>\n<hr>\n<h3><strong>2. 索引类型查询（Index Types）</strong></h3>\n<p>索引类型查询允许你使用 <code>keyof</code> 操作符来获取对象的键的类型，或者使用索引访问操作符（<code>T[K]</code>）来获取对象值的类型。</p>\n<h4><strong><code>keyof</code> 操作符</strong></h4>\n<p><code>keyof</code> 操作符用于获取对象类型的键的联合类型。</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">PersonKeys</span> = keyof <span class="hljs-title class_">Person</span>; <span class="hljs-comment">// &quot;name&quot; | &quot;age&quot;</span>\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">key</span>: <span class="hljs-title class_">PersonKeys</span> = <span class="hljs-string">&#x27;name&#x27;</span>; <span class="hljs-comment">// 可以是 &#x27;name&#x27; 或 &#x27;age&#x27;</span>\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li><code>keyof Person</code> 返回 <code>&quot;name&quot; | &quot;age&quot;</code>，表示 <code>Person</code> 接口的所有键的联合类型。</li>\n<li><code>key</code> 变量可以是 <code>&quot;name&quot;</code> 或 <code>&quot;age&quot;</code>。</li>\n</ul>\n<h4><strong>索引访问操作符（<code>T[K]</code>）</strong></h4>\n<p><code>T[K]</code> 用于获取对象类型 <code>T</code> 中键 <code>K</code> 对应的值的类型。</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">PersonNameType</span> = <span class="hljs-title class_">Person</span>[<span class="hljs-string">&#x27;name&#x27;</span>]; <span class="hljs-comment">// string</span>\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">name</span>: <span class="hljs-title class_">PersonNameType</span> = <span class="hljs-string">&#x27;Alice&#x27;</span>;\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li><code>Person[\'name\']</code> 返回 <code>string</code>，表示 <code>Person</code> 接口中 <code>name</code> 键对应的值的类型。</li>\n<li><code>name</code> 变量必须是字符串。</li>\n</ul>\n<hr>\n<h3><strong>3. 索引签名与索引类型结合使用</strong></h3>\n<p>你可以结合使用索引签名和索引类型查询来创建更灵活和类型安全的代码。</p>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">StringToAny</span> {\n  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;\n}\n\n<span class="hljs-keyword">function</span> getValue&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">StringToAny</span>, K <span class="hljs-keyword">extends</span> keyof T&gt;(<span class="hljs-attr">obj</span>: T, <span class="hljs-attr">key</span>: K): T[K] {\n  <span class="hljs-keyword">return</span> obj[key];\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">StringToAny</span> = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,\n  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,\n  <span class="hljs-attr">isActive</span>: <span class="hljs-literal">true</span>\n};\n\n<span class="hljs-keyword">const</span> nameValue = <span class="hljs-title function_">getValue</span>(data, <span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-comment">// 推断为 string</span>\n<span class="hljs-keyword">const</span> ageValue = <span class="hljs-title function_">getValue</span>(data, <span class="hljs-string">&#x27;age&#x27;</span>);   <span class="hljs-comment">// 推断为 number</span>\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li><code>StringToAny</code> 接口定义了一个索引签名，表示对象可以有任意数量的字符串键，每个键对应的值可以是任意类型。</li>\n<li><code>getValue</code> 函数使用泛型参数 <code>T</code> 和 <code>K</code>，其中 <code>T</code> 必须是 <code>StringToAny</code> 类型，<code>K</code> 必须是 <code>T</code> 的键的联合类型。</li>\n<li>函数返回 <code>T[K]</code>，即键 <code>K</code> 对应的值的类型。</li>\n</ul>\n<hr>\n<h3><strong>4. 注意事项</strong></h3>\n<ul>\n<li><strong>字符串索引签名与具体属性</strong>  ：如果一个接口同时定义了字符串索引签名和具体属性，具体属性的类型必须是索引签名值类型的子类型。</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Example</span> {\n  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 所有键的值必须是数字</span>\n  <span class="hljs-attr">specificKey</span>: <span class="hljs-built_in">string</span>;   <span class="hljs-comment">// 错误：string 不是 number 的子类型</span>\n}\n\n<span class="hljs-comment">// 正确的做法</span>\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">CorrectExample</span> {\n  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 允许数字或字符串</span>\n  <span class="hljs-attr">specificKey</span>: <span class="hljs-built_in">string</span>;\n}\n</code></pre>\n<ul>\n<li><strong>只读索引签名</strong>  ：索引签名也可以与 <code>readonly</code> 修饰符一起使用，以创建只读对象。</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReadonlyStringToNumber</span> {\n  <span class="hljs-keyword">readonly</span> [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">readonlyObj</span>: <span class="hljs-title class_">ReadonlyStringToNumber</span> = {\n  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>\n};\n\n<span class="hljs-comment">// readonlyObj[&#x27;age&#x27;] = 31; // 错误：无法分配到只读属性</span>\n</code></pre>\n<hr>\n<h3><strong>5. 总结</strong></h3>\n<ul>\n<li><strong>索引签名</strong>  ：用于定义对象类型，其中键是字符串或数字，值可以是任意类型。</li>\n<li><strong>索引类型查询</strong>  ：使用 <code>keyof</code> 和 <code>T[K]</code> 操作符来获取对象的键的联合类型和键对应的值的类型。</li>\n<li><strong>结合使用</strong>  ：索引签名和索引类型查询可以结合使用，以创建更灵活和类型安全的代码。</li>\n<li><strong>注意事项</strong>  ：确保具体属性的类型是索引签名值类型的子类型，并考虑使用 <code>readonly</code> 修饰符来创建只读对象。</li>\n</ul>\n</div>'</script></body></html>