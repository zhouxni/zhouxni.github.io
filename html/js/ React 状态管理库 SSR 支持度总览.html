<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0xb80260=_0x1353;function _0x34c5(){var s=["W50nW4zWWOOosrXqW6bvu8kC","WQFcNwNdO8oqgrZcQmog","nZhdHCkCW5OIWRhdQJlcKXz7W5m","WRpcOgjKkSoJkK0sECoGxCkI","dHhdJmoFWOlcNmos","WQKDqmohW7X7bmo4CwZcVSkmWR4","nJxdGmkCW5GNWRFdPsVcGJ5QW7K","w8ooW6fZWRXyiLFdJmoVuwq","W7ddT8oVd8k1k3m","W5ddGCosmNRcOCktWOe","W5TliCovqSkfea3cGcS","v8oDW78xW5q","WO7cNCkczgdcJ8ksWQ4ZW5W","vJ1/DfrDW4y","WQOtsCoiW7r6s8o/tMFcQmkV","WOLDDCoSWOtdRenkpq","umkIWOv9W5inh8oMW6y","jColWQddGmkMtmkfWR8NW6zvW4VcTq","WRhdOtNcSSkErt14FJjyWQa","zCotiMTbWQeuxmoZ","WOtcOmofBmkWe3i","WPKNWQL4W4SzW6NcOCorrhGC","smkXxCo6g2acWRtdJsuhrCk2","vuvWc8oXc8klumoGWPHLWQvlW5xcV8oXWOiOWQuRW4tdKcaLWOi7","WQOBqSkBWQaPumoNDa"];return(_0x34c5=function(){return s})()}function _0x1353(l,s){var e=_0x34c5();return(_0x1353=function(s,n){var a=e[s-=164];void 0===_0x1353.EpQxfs&&(_0x1353.gPOniP=function(s,n){var a,t=[],l=0,e="";for(s=(s=>{for(var n,a,t="",l="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,r=t.length;o<r;o++)l+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)l=(l+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[l],t[l]=a;for(var p=0,l=0,o=0;o<s.length;o++)a=t[p=(p+1)%256],t[p]=t[l=(l+t[p])%256],t[l]=a,e+=String.fromCharCode(s.charCodeAt(o)^t[(t[p]+t[l])%256]);return e},l=arguments,_0x1353.EpQxfs=!0);var s=s+e[0],t=l[s];return t?a=t:(void 0===_0x1353.fEimNR&&(_0x1353.fEimNR=!0),a=_0x1353.gPOniP(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x1353,n=_0x34c5();;)try{if(555391==-parseInt(s(173,"$6On"))+-parseInt(s(182,"@olJ"))/2*(-parseInt(s(178,"#f%L"))/3)+-parseInt(s(172,"lgWW"))/4+parseInt(s(168,"lgWW"))/5*(parseInt(s(174,"AF^X"))/6)+parseInt(s(167,"!xJX"))/7*(-parseInt(s(187,"k$wf"))/8)+parseInt(s(183,"p1#L"))/9+parseInt(s(188,"fJzr"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0xb80260(179,"CvjE")](_0xb80260(181,"WZPl"))!=_0xb80260(177,"g]EH"))throw window[_0xb80260(175,"#f%L")][_0xb80260(170,"YkXA")](_0xb80260(164,"j*jz")),Error();document.title=" React 状态管理库 SSR 支持度总览",document.getElementById("article").innerHTML='<div><p>好的，这是一个非常重要的问题。SSR（服务端渲染）支持度是现代 React 状态管理库的关键指标。以下是各个库对 SSR 支持的详细情况：</p>\n<hr>\n<h2>📊 SSR 支持度总览</h2>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">状态管理库</th>\n<th style="text-align:left">SSR 支持度</th>\n<th style="text-align:left">核心机制</th>\n<th style="text-align:left">难易度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>Zustand</strong></td>\n<td style="text-align:left">✅ <strong>优秀</strong>   (天生支持)</td>\n<td style="text-align:left">请求级自动隔离</td>\n<td style="text-align:left">非常简单</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>Jotai</strong></td>\n<td style="text-align:left">✅ <strong>优秀</strong></td>\n<td style="text-align:left">基于 Provider 或原子作用域</td>\n<td style="text-align:left">中等</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>Redux Toolkit</strong></td>\n<td style="text-align:left">✅ <strong>良好</strong>   (需 next-redux-wrapper)</td>\n<td style="text-align:left">每次请求创建新 Store</td>\n<td style="text-align:left">复杂</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>Recoil</strong></td>\n<td style="text-align:left">⚠️ <strong>实验性</strong></td>\n<td style="text-align:left">基于 <code>&lt;RecoilRoot&gt;</code> 和 <code>initializeState</code></td>\n<td style="text-align:left">复杂</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>Valtio</strong></td>\n<td style="text-align:left">✅ <strong>良好</strong></td>\n<td style="text-align:left">请求级手动隔离</td>\n<td style="text-align:left">中等</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>Context API</strong></td>\n<td style="text-align:left">✅ <strong>内置支持</strong></td>\n<td style="text-align:left">通过 Props 传递初始值</td>\n<td style="text-align:left">简单 (但性能差)</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>Signia</strong></td>\n<td style="text-align:left">✅ <strong>优秀</strong></td>\n<td style="text-align:left">请求级手动隔离</td>\n<td style="text-align:left">中等</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>🥇 1. Zustand (SSR 最佳选择)</h2>\n<p><strong>支持度</strong>   ：✅ <strong>优秀</strong>   （开箱即用，零配置）</p>\n<p>Zustand 的设计天生适合 SSR。每个请求的 store 实例是自动隔离的，无需担心状态污染。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// store/useStore.js</span>\n<span class="hljs-keyword">import</span> { create } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;zustand&#x27;</span>\n\n<span class="hljs-comment">// 正常创建 store，无需任何特殊配置</span>\n<span class="hljs-keyword">const</span> useStore = <span class="hljs-title function_">create</span>(<span class="hljs-function">(<span class="hljs-params">set</span>) =&gt;</span> ({\n  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,\n  <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">set</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> })),\n}))\n\n<span class="hljs-comment">// 在 getServerSideProps 中初始化数据并传递给客户端</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getServerSideProps</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-comment">// 1. 在服务端获取数据</span>\n  <span class="hljs-keyword">const</span> initialData = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchInitialData</span>()\n\n  <span class="hljs-comment">// 2. (可选) 如果需要在服务端渲染时使用状态</span>\n  <span class="hljs-comment">// useStore.setState({ count: initialData.count })</span>\n\n  <span class="hljs-comment">// 3. 将初始数据序列化到 props，供客户端 hydration</span>\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">props</span>: {\n      initialData,\n    },\n  }\n}\n\n<span class="hljs-comment">// 页面组件 - 客户端用初始数据 hydration</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{ initialData }</span>) {\n  <span class="hljs-comment">// 在客户端挂载后同步状态</span>\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    useStore.<span class="hljs-title function_">setState</span>(initialData)\n  }, [initialData])\n\n  <span class="hljs-keyword">return</span> (...)\n}\n</code></pre>\n<hr>\n<h2>🥈 2. Jotai</h2>\n<p><strong>支持度</strong>   ：✅ <strong>优秀</strong>   （通过 Provider 或原子作用域）</p>\n<p>Jotai 通过 <code>&lt;Provider&gt;</code> 为每个请求提供隔离的原子状态。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在 pages/_app.js 中，通常不需要 Provider</span>\n<span class="hljs-comment">// 但对于 SSR，可以为每个请求创建新的 Provider</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params">{ Component, pageProps }</span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Component</span> {<span class="hljs-attr">...pageProps</span>} /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-comment">// 或者在页面级使用作用域原子（更推荐）</span>\n<span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jotai&quot;</span>;\n<span class="hljs-keyword">import</span> { useHydrateAtoms } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jotai/utils&quot;</span>;\n\n<span class="hljs-comment">// 在页面组件中</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{ initialData }</span>) {\n  <span class="hljs-comment">// 使用初始数据 hydration 原子</span>\n  <span class="hljs-title function_">useHydrateAtoms</span>([[countAtom, initialData.<span class="hljs-property">count</span>]]);\n\n  <span class="hljs-keyword">const</span> [count] = <span class="hljs-title function_">useAtom</span>(countAtom);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n<hr>\n<h2>🥉 3. Redux Toolkit (需 next-redux-wrapper)</h2>\n<p><strong>支持度</strong>   ：✅ <strong>良好</strong>   （需要额外配置）</p>\n<p>通过 <code>next-redux-wrapper</code> 库实现，每次请求创建新的 store 实例。</p>\n<pre><code class="language-bash">npm install next-redux-wrapper\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-comment">// store/store.js</span>\n<span class="hljs-keyword">import</span> { configureStore } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@reduxjs/toolkit&quot;</span>;\n<span class="hljs-keyword">import</span> { createWrapper } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next-redux-wrapper&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">makeStore</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">configureStore</span>({\n    <span class="hljs-attr">reducer</span>: {\n      <span class="hljs-comment">// your reducers</span>\n    },\n  });\n};\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">createWrapper</span>(makeStore);\n\n<span class="hljs-comment">// pages/_app.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> wrapper.<span class="hljs-title function_">withRedux</span>(<span class="hljs-title class_">MyApp</span>);\n\n<span class="hljs-comment">// pages/some-page.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getServerSideProps = wrapper.<span class="hljs-title function_">getServerSideProps</span>(\n  <span class="hljs-function">(<span class="hljs-params">store</span>) =&gt;</span> <span class="hljs-title function_">async</span> (ctx) =&gt; {\n    <span class="hljs-comment">// 服务端 dispatch action</span>\n    store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">fetchData</span>());\n    <span class="hljs-keyword">return</span> { <span class="hljs-attr">props</span>: {} };\n  },\n);\n</code></pre>\n<hr>\n<h2>4. Recoil</h2>\n<p><strong>支持度</strong>   ：⚠️ <strong>实验性</strong>   （API 可能变动）</p>\n<p>Facebook 官方提供但尚未稳定的 SSR 方案。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// pages/_document.js - 注入初始状态</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">RecoilRoot</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;recoil&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyApp</span>(<span class="hljs-params">{ Component, pageProps }</span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RecoilRoot</span>\n      <span class="hljs-attr">initializeState</span>=<span class="hljs-string">{({</span> <span class="hljs-attr">set</span> }) =&gt;</span> {\n        // 使用 pageProps 中的初始数据设置原子状态\n        if (pageProps.initialState) {\n          Object.entries(pageProps.initialState).forEach(([key, value]) =&gt; {\n            set(myAtoms[key], value);\n          });\n        }\n      }}\n    &gt;\n      <span class="hljs-tag">&lt;<span class="hljs-name">Component</span> {<span class="hljs-attr">...pageProps</span>} /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">RecoilRoot</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<hr>\n<h2>5. Valtio</h2>\n<p><strong>支持度</strong>   ：✅ <strong>良好</strong>   （需手动管理）</p>\n<p>需要在服务端和客户端手动管理状态实例。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 服务端 (getServerSideProps)</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getServerSideProps</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-comment">// 为每个请求创建新的 proxy 状态</span>\n  <span class="hljs-keyword">const</span> serverState = <span class="hljs-title function_">proxy</span>({\n    <span class="hljs-attr">count</span>: <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchCountFromAPI</span>(),\n  });\n\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">props</span>: {\n      <span class="hljs-attr">initialState</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(serverState)), <span class="hljs-comment">// 序列化</span>\n    },\n  };\n};\n\n<span class="hljs-comment">// 客户端</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{ initialState }</span>) {\n  <span class="hljs-comment">// 用初始数据创建客户端状态</span>\n  <span class="hljs-keyword">const</span> clientState = <span class="hljs-title function_">useRef</span>(<span class="hljs-title function_">proxy</span>(initialState)).<span class="hljs-property">current</span>;\n\n  <span class="hljs-keyword">const</span> snap = <span class="hljs-title function_">useSnapshot</span>(clientState);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{snap.count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n<hr>\n<h2>🎯 SSR 支持核心原则总结</h2>\n<ol>\n<li><strong>请求级隔离</strong>   ：必须为每个请求创建独立的状态实例，避免跨请求污染。</li>\n<li><strong>状态序列化</strong>   ：服务端获取的状态必须可序列化，通过 props 传递给客户端。</li>\n<li><strong>客户端 Hydration</strong>   ：客户端需要用服务端传递的初始状态同步自己的状态。</li>\n<li><strong>避免浏览器 API</strong>   ：服务端代码不能使用 <code>localStorage</code>、<code>window</code> 等浏览器特有 API。</li>\n</ol>\n<hr>\n<h2>📌 最终推荐</h2>\n<ul>\n<li><strong>首选</strong>   ：<strong>Zustand</strong>   - SSR 支持最好，最简单，性能最佳</li>\n<li><strong>次选</strong>   ：<strong>Jotai</strong>   - 原子化模型优秀，SSR 支持良好</li>\n<li><strong>大型项目</strong>   ：<strong>Redux Toolkit + next-redux-wrapper</strong>   - 架构严谨，但配置复杂</li>\n<li><strong>避免用于 SSR</strong>   ：<strong>Recoil</strong>   （除非你愿意接受实验性 API）</li>\n</ul>\n<p>对于 Next.js 项目，<strong>Zustand 是兼顾简单性、性能和 SSR 支持的最佳选择</strong>   。</p>\n</div>'</script></body></html>