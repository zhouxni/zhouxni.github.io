<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x476146=_0x5acc;function _0x5420(){var s=["WOhdQGBcObaTmSkZ","r8osWOC0v2RcQgDil1DN","fmknW45PEXZdHmonwmo8xSkZ","zKBcTwuZmCkevW","ELjHWOFdRflcUq","WOHbWRxdJ3NcLCoYEmkbWQdcSre","WOD5WRfIv2Pj","F0nDW4BdISomWQyzW67dVWBdHhy","kSkNr1BcONxdUSk+","gxbEW4JdP1NcJLHCfa8","imolWPitW6Cuf3LCidq","hNy8WQNcT1hcO1G","WPxcUX9yjutcRviBkGSs","WRrnfNFdNmoRr0DeFcddSe4","uSkrm8oGW4ldVNxcGJ/cLSo4WPml","otyQW4njFmoKWOJcUrpdN8otW7W","vSkxm8oSW4pcNXdcVadcOmoY","WRBcMmkfW4SjWPlcRq","WQVcSSo+W5frW6iOWPxdMLpdJSocmG","WPpcUNeWDItcTgm","ASoyWRJdM8kQfCkAW4ldJq","W7e5W5rEemolC8kMwSkpEmkfxq","a8oLWQRcJvyzWOCKWQddKSkW","kCkQW5lcOmkIpt8","xMiNCSosg8osavFcO8oeWOdcJmoiWQ3dGx/cN0ddMNlcGsaCWPpdSq","rMmGCCoy"];return(_0x5420=function(){return s})()}function _0x5acc(t,s){var p=_0x5420();return(_0x5acc=function(s,n){var a=p[s-=266];void 0===_0x5acc.YyPXaI&&(_0x5acc.YJksaa=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,r=0;a=s.charAt(r++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,e=l.length;c<e;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),r=0;r<256;r++)l[r]=r;for(r=0;r<256;r++)t=(t+l[r]+n.charCodeAt(r%n.length))%256,a=l[r],l[r]=l[t],l[t]=a;for(var r=0,t=0,c=0;c<s.length;c++)a=l[r=(r+1)%256],l[r]=l[t=(t+l[r])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[r]+l[t])%256]);return p},t=arguments,_0x5acc.YyPXaI=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x5acc.wYUgSO&&(_0x5acc.wYUgSO=!0),a=_0x5acc.YJksaa(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x5acc,n=_0x5420();;)try{if(635365==+parseInt(s(277,"Fq1E"))*(-parseInt(s(272,"x0*s"))/2)+parseInt(s(273,"&y6I"))/3+parseInt(s(266,"[imE"))/4*(parseInt(s(290,"&LNe"))/5)+parseInt(s(284,"(t!!"))/6*(-parseInt(s(275,"Fq1E"))/7)+parseInt(s(268,"t*KF"))/8+parseInt(s(270,"x0*s"))/9+-parseInt(s(282,"IIeW"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x476146(267,"F9e]")](_0x476146(281,"ErlC"))!=_0x476146(286,"X!R#"))throw window[_0x476146(287,"eA@m")][_0x476146(278,"N1Q]")](_0x476146(285,"X!R#")),Error();document.title="react Transaction 详解",document.getElementById("article").innerHTML='<div><p>在React早期版本（16.x之前）中，<code>Transaction</code>是一个核心机制，用于管理组件更新的执行上下文。虽然React 16.x之后引入了Fiber架构，Transaction的实现方式有所变化，但理解其设计思想对掌握React的工作原理仍有帮助。</p>\n<h3><strong>一、Transaction的核心概念</strong></h3>\n<h4>1. <strong>定义</strong></h4>\n<p>Transaction是一种封装了<strong>前置操作（wrapper）</strong>  和<strong>后置操作</strong>  的执行单元，确保在执行前后执行特定逻辑。其核心思想来源于数据库事务的<strong>ACID</strong>  特性（原子性、一致性、隔离性、持久性），但在React中主要用于保证状态更新的一致性。</p>\n<h4>2. <strong>工作流程</strong></h4>\n<pre><code class="language-plaintext">前置操作（wrapper.initialize） → 执行核心逻辑 → 后置操作（wrapper.close）\n</code></pre>\n<ul>\n<li><strong>前置操作</strong>  ：例如开启批量更新、保存当前状态。</li>\n<li><strong>核心逻辑</strong>  ：例如组件渲染、状态更新。</li>\n<li><strong>后置操作</strong>  ：例如结束批量更新、恢复状态。</li>\n</ul>\n<h3><strong>二、React中的Transaction应用</strong></h3>\n<h4>1. <strong>批量更新机制</strong></h4>\n<p>React利用Transaction实现了<strong>批量更新</strong>  ，确保多个 setState 合并为一次渲染：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 简化版伪代码</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">wrappers</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">wrappers</span> = wrappers;\n  }\n  \n  <span class="hljs-title function_">perform</span>(<span class="hljs-params">operation</span>) {\n    <span class="hljs-comment">// 执行所有wrapper的initialize</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">wrappers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">wrapper</span> =&gt;</span> wrapper.<span class="hljs-title function_">initialize</span>());\n    \n    <span class="hljs-keyword">try</span> {\n      <span class="hljs-comment">// 执行核心操作（如组件更新）</span>\n      <span class="hljs-title function_">operation</span>();\n    } <span class="hljs-keyword">finally</span> {\n      <span class="hljs-comment">// 执行所有wrapper的close（无论是否出错）</span>\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">wrappers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">wrapper</span> =&gt;</span> wrapper.<span class="hljs-title function_">close</span>());\n    }\n  }\n}\n\n<span class="hljs-comment">// React使用Transaction包裹setState</span>\n<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, container, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 在Transaction中执行多个setState</span>\n  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> }); <span class="hljs-comment">// 不会立即更新</span>\n  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">2</span> }); <span class="hljs-comment">// 不会立即更新</span>\n  <span class="hljs-comment">// 事务结束后合并为一次更新</span>\n});\n</code></pre>\n<h4>2. <strong>典型Wrapper示例</strong></h4>\n<ul>\n<li><strong>RESET_BATCHED_UPDATES</strong>  ：重置批量更新标记。</li>\n<li><strong>FLUSH_BATCHED_UPDATES</strong>  ：批量处理所有待更新的组件。</li>\n</ul>\n<h3><strong>三、Transaction的实现原理</strong></h3>\n<h4>1. <strong>Wrapper结构</strong></h4>\n<p>每个Wrapper包含两个方法：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> wrapper = {\n  <span class="hljs-attr">initialize</span>: <span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-comment">// 前置操作：例如记录开始时间</span>\n  },\n  <span class="hljs-attr">close</span>: <span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-comment">// 后置操作：例如计算耗时</span>\n  }\n};\n</code></pre>\n<h4>2. <strong>嵌套事务</strong></h4>\n<p>Transaction支持嵌套，每个事务维护一个<strong>栈结构</strong>  ，确保前置和后置操作按正确顺序执行：</p>\n<pre><code class="language-plaintext">外层Transaction开始 → 内层Transaction开始 → 执行核心逻辑 → 内层Transaction结束 → 外层Transaction结束\n</code></pre>\n<h3><strong>四、Transaction与Fiber的关系</strong></h3>\n<p>React 16.x引入的Fiber架构重构了更新流程，但Transaction的思想仍被保留：</p>\n<ul>\n<li><strong>Fiber的任务调度</strong>  ：替代了Transaction的部分功能，实现更灵活的异步更新。</li>\n<li><strong>Lane优先级模型</strong>  ：实现了更细粒度的批量更新控制。</li>\n</ul>\n<p>虽然Fiber不再直接使用Transaction类，但状态更新的<strong>原子性</strong>  和<strong>上下文管理</strong>  思想仍然存在。</p>\n<h3><strong>五、手写简化版Transaction</strong></h3>\n<p>以下是一个简化的Transaction实现，演示其核心原理：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">wrappers = []</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">wrappers</span> = wrappers;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">transactionWrappers</span> = []; <span class="hljs-comment">// 存储当前事务的wrapper状态</span>\n  }\n\n  <span class="hljs-title function_">perform</span>(<span class="hljs-params">operation, scope, ...args</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initializeAll</span>();\n    <span class="hljs-keyword">try</span> {\n      <span class="hljs-keyword">return</span> operation.<span class="hljs-title function_">apply</span>(scope, args);\n    } <span class="hljs-keyword">finally</span> {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">closeAll</span>();\n    }\n  }\n\n  <span class="hljs-title function_">initializeAll</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">wrappers</span>.<span class="hljs-property">length</span>; i++) {\n      <span class="hljs-keyword">const</span> wrapper = <span class="hljs-variable language_">this</span>.<span class="hljs-property">wrappers</span>[i];\n      <span class="hljs-keyword">try</span> {\n        <span class="hljs-comment">// 执行前置操作并保存状态</span>\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">transactionWrappers</span>[i] = wrapper.<span class="hljs-title function_">initialize</span>();\n      } <span class="hljs-keyword">catch</span> (err) {\n        <span class="hljs-comment">// 出错时回滚已执行的initialize</span>\n        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">closeAll</span>(i);\n        <span class="hljs-keyword">throw</span> err;\n      }\n    }\n  }\n\n  <span class="hljs-title function_">closeAll</span>(<span class="hljs-params">startIndex = <span class="hljs-number">0</span></span>) {\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = startIndex; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">wrappers</span>.<span class="hljs-property">length</span>; i++) {\n      <span class="hljs-keyword">const</span> wrapper = <span class="hljs-variable language_">this</span>.<span class="hljs-property">wrappers</span>[i];\n      <span class="hljs-keyword">try</span> {\n        <span class="hljs-comment">// 执行后置操作</span>\n        wrapper.<span class="hljs-title function_">close</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">transactionWrappers</span>[i]);\n      } <span class="hljs-keyword">catch</span> (err) {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Transaction close error:&#x27;</span>, err);\n      }\n    }\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">transactionWrappers</span> = [];\n  }\n}\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-keyword">const</span> loggingWrapper = {\n  <span class="hljs-attr">initialize</span>: <span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;开始事务&#x27;</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 返回初始状态</span>\n  },\n  <span class="hljs-attr">close</span>: <span class="hljs-function">(<span class="hljs-params">startTime</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> duration = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - startTime;\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`结束事务，耗时: <span class="hljs-subst">${duration}</span>ms`</span>);\n  }\n};\n\n<span class="hljs-keyword">const</span> transaction = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transaction</span>([loggingWrapper]);\ntransaction.<span class="hljs-title function_">perform</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行核心操作...&#x27;</span>);\n});\n\n<span class="hljs-comment">// 输出:</span>\n<span class="hljs-comment">// 开始事务</span>\n<span class="hljs-comment">// 执行核心操作...</span>\n<span class="hljs-comment">// 结束事务，耗时: Xms</span>\n</code></pre>\n<h3><strong>六、Transaction的现实意义</strong></h3>\n<p>虽然现代React已不再直接暴露Transaction API，但理解其设计思想有助于：</p>\n<ol>\n<li><strong>理解React的状态管理</strong>  ：为什么 setState 有时是异步的。</li>\n<li><strong>调试复杂更新问题</strong>  ：例如多个 setState 合并的时机。</li>\n<li><strong>设计健壮的前端架构</strong>  ：借鉴事务思想处理复杂操作的原子性。</li>\n</ol>\n<h3><strong>七、总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>核心思想</strong></td>\n<td>封装前置和后置操作，确保执行上下文的一致性。</td>\n</tr>\n<tr>\n<td><strong>典型应用</strong></td>\n<td>批量更新、事件处理、状态恢复。</td>\n</tr>\n<tr>\n<td><strong>Fiber中的演变</strong></td>\n<td>被更灵活的异步调度机制替代，但原子性和上下文管理的思想仍被保留。</td>\n</tr>\n<tr>\n<td><strong>手写关键点</strong></td>\n<td>栈结构管理嵌套事务、错误处理、状态恢复。</td>\n</tr>\n</tbody>\n</table>\n<p>Transaction是React早期架构的重要组成部分，虽然其具体实现已被取代，但其设计理念仍是理解React工作原理的关键。</p>\n</div>'</script></body></html>