<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x222828=_0x2fbd;function _0x2fbd(p,s){var t=_0xe82e();return(_0x2fbd=function(s,n){var a=t[s-=410];void 0===_0x2fbd.RGhaMq&&(_0x2fbd.uUDNEn=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,c=0;a=s.charAt(c++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,o=l.length;e<o;e++)p+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(p)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)p=(p+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[p],l[p]=a;for(var c=0,p=0,e=0;e<s.length;e++)a=l[c=(c+1)%256],l[c]=l[p=(p+l[c])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(e)^l[(l[c]+l[p])%256]);return t},p=arguments,_0x2fbd.RGhaMq=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x2fbd.PHCCBl&&(_0x2fbd.PHCCBl=!0),a=_0x2fbd.uUDNEn(a,n),p[s]=a),a})(p,s)}function _0xe82e(){var s=["W6JcMConW5v3cSkOW7RcLa","W4K6WOTfE2ZcQq","WRldL3pdIb4quwfUW5TF","mqLWo8k3dSkOWO4Veq","AHNcNJ7dRmkWvLe","oXNdG8ozWOHUWOL7WP/dJeWKra","W5tdGCkfWObldhS","W6msW7BdSmk4W4GaEW","WRhdOSkuBdxdTmoJ","WPZdHwvCW6FdVqjaza","WR3dJSkFWPScWOZcRXWjECoOWRWJjq","WPykmXfjAtZcG8oJDa","z3uGtSoNWOtdUmoSeHNcUM0tq2FcKmoecNxdLNHgWPKWAZm","W6VdJCoBWP18s8k0W4FdNuNdHmkSaq","WR7dJSkCW6fbW7RdIN8+","b8ohW4PaWPlcVrtdKhzEWORcLZq","WR3dICkFWPieW7NdSKSRESo8","F3qNtCoT","zenJW6SSW51MWQCDEGFdQqW","W5NcVXiKBWZcQei","yHVdTMlcV8oZkMNdICo8W5r4CG","bCkGqmoaWRtcNvq","WR/dH8kKr3CDs21ifKakW4u","bJGIf8kRW7FcTav2WRdcS1JdLW","yHddVwlcTSo1k27dSSoZW7nRsq","nbzjWQeYs8kUWRuSdGBcQxuW"];return(_0xe82e=function(){return s})()}if((()=>{for(var s=_0x2fbd,n=_0xe82e();;)try{if(401669==+parseInt(s(424,"ye52"))*(-parseInt(s(435,"silt"))/2)+-parseInt(s(434,"5uwr"))/3+-parseInt(s(419,"4$3t"))/4+-parseInt(s(423,"3ohy"))/5*(parseInt(s(428,"(Abu"))/6)+-parseInt(s(415,"4$3t"))/7+-parseInt(s(429,"^$iP"))/8*(parseInt(s(410,"WVs]"))/9)+parseInt(s(431,"silt"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x222828(416,"hA]j")](_0x222828(430,"yVG1"))!=_0x222828(412,"4IEa"))throw window[_0x222828(414,"hyeo")][_0x222828(422,"]a9F")](_0x222828(433,"4IEa")),Error();document.title="Taro 组件生命周期书写指南",document.getElementById("article").innerHTML='<div><p>Taro 支持使用 React/Vue 的生命周期写法，同时也支持小程序原生生命周期写法。以下是详细的组件生命周期书写方法：</p>\n<h2>一、类组件生命周期写法</h2>\n<h3>1. 使用 React 风格生命周期（推荐）</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tarojs/taro&#x27;</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">View</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tarojs/components&#x27;</span>\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {\n  <span class="hljs-comment">// 1. 组件初始化阶段</span>\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {\n    <span class="hljs-variable language_">super</span>(props)\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> }\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;constructor&#x27;</span>)\n  }\n\n  <span class="hljs-comment">// 2. 组件挂载前（对应小程序 attached）</span>\n  <span class="hljs-title function_">componentWillMount</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;componentWillMount&#x27;</span>)\n  }\n\n  <span class="hljs-comment">// 3. 组件挂载完成（对应小程序 ready）</span>\n  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;componentDidMount&#x27;</span>)\n  }\n\n  <span class="hljs-comment">// 4. 组件显示（对应小程序 show）</span>\n  <span class="hljs-title function_">componentDidShow</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;componentDidShow&#x27;</span>)\n  }\n\n  <span class="hljs-comment">// 5. 组件隐藏（对应小程序 hide）</span>\n  <span class="hljs-title function_">componentDidHide</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;componentDidHide&#x27;</span>)\n  }\n\n  <span class="hljs-comment">// 6. 组件更新前</span>\n  <span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">nextProps, nextState</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;shouldComponentUpdate&#x27;</span>)\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>\n  }\n\n  <span class="hljs-comment">// 7. 组件更新完成</span>\n  <span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;componentDidUpdate&#x27;</span>)\n  }\n\n  <span class="hljs-comment">// 8. 组件卸载前（对应小程序 detached）</span>\n  <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;componentWillUnmount&#x27;</span>)\n  }\n\n  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span>&gt;</span>生命周期示例<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>\n  }\n}\n</code></pre>\n<h3>2. 使用小程序原生生命周期</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tarojs/taro&#x27;</span>\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {\n  <span class="hljs-comment">// 小程序原生生命周期</span>\n  <span class="hljs-title function_">attached</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;attached - 组件实例进入页面节点树&#x27;</span>)\n  }\n\n  <span class="hljs-title function_">ready</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ready - 组件布局完成&#x27;</span>)\n  }\n\n  <span class="hljs-title function_">moved</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;moved - 组件实例被移动到节点树另一个位置&#x27;</span>)\n  }\n\n  <span class="hljs-title function_">detached</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;detached - 组件实例从页面节点树移除&#x27;</span>)\n  }\n\n  <span class="hljs-comment">// 页面显示时触发</span>\n  pageLifetimes = {\n    <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;page show - 页面显示&#x27;</span>)\n    },\n    <span class="hljs-title function_">hide</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;page hide - 页面隐藏&#x27;</span>)\n    }\n  }\n}\n</code></pre>\n<h2>二、函数组件生命周期写法</h2>\n<h3>1. 使用 Hooks 实现生命周期</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>\n<span class="hljs-keyword">import</span> { useReady, useDidShow, useDidHide } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tarojs/taro&#x27;</span>\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyFunctionalComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)\n\n  <span class="hljs-comment">// 相当于 componentDidMount 和 componentWillUnmount</span>\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;组件挂载完成&#x27;</span>)\n    \n    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;组件即将卸载&#x27;</span>)\n    }\n  }, [])\n\n  <span class="hljs-comment">// 相当于 componentDidUpdate</span>\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;count 发生变化:&#x27;</span>, count)\n  }, [count])\n\n  <span class="hljs-comment">// Taro 特有 Hooks</span>\n  <span class="hljs-title function_">useReady</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;组件首次渲染完成 - 对应 ready&#x27;</span>)\n  })\n\n  <span class="hljs-title function_">useDidShow</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;组件显示 - 对应 onShow&#x27;</span>)\n  })\n\n  <span class="hljs-title function_">useDidHide</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;组件隐藏 - 对应 onHide&#x27;</span>)\n  })\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span>&gt;</span>函数组件生命周期示例<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>\n}\n</code></pre>\n<h2>三、页面组件生命周期写法</h2>\n<h3>1. 页面特有生命周期</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Taro</span>, { useDidShow, useDidHide } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tarojs/taro&#x27;</span>\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {\n  <span class="hljs-comment">// 页面加载时触发</span>\n  <span class="hljs-title function_">onLoad</span>(<span class="hljs-params">options</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面加载&#x27;</span>, options)\n  }\n\n  <span class="hljs-comment">// 页面显示时触发</span>\n  <span class="hljs-title function_">onShow</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面显示&#x27;</span>)\n  }\n\n  <span class="hljs-comment">// 页面初次渲染完成时触发</span>\n  <span class="hljs-title function_">onReady</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面初次渲染完成&#x27;</span>)\n  }\n\n  <span class="hljs-comment">// 页面隐藏时触发</span>\n  <span class="hljs-title function_">onHide</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面隐藏&#x27;</span>)\n  }\n\n  <span class="hljs-comment">// 页面卸载时触发</span>\n  <span class="hljs-title function_">onUnload</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面卸载&#x27;</span>)\n  }\n\n  <span class="hljs-comment">// 下拉刷新</span>\n  <span class="hljs-title function_">onPullDownRefresh</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;下拉刷新&#x27;</span>)\n    <span class="hljs-title class_">Taro</span>.<span class="hljs-title function_">stopPullDownRefresh</span>()\n  }\n\n  <span class="hljs-comment">// 上拉触底</span>\n  <span class="hljs-title function_">onReachBottom</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;上拉触底&#x27;</span>)\n  }\n\n  <span class="hljs-comment">// 页面滚动</span>\n  <span class="hljs-title function_">onPageScroll</span>(<span class="hljs-params">e</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面滚动&#x27;</span>, e)\n  }\n}\n</code></pre>\n<h2>四、最佳实践建议</h2>\n<ol>\n<li><strong>跨平台开发</strong>  ：优先使用 React/Vue 标准生命周期，保证代码可移植性</li>\n<li><strong>小程序特有功能</strong>  ：需要调用小程序原生能力时，使用 Taro 特有生命周期</li>\n<li><strong>性能优化</strong>  ：\n<ul>\n<li>避免在 <code>render</code> 或频繁触发的生命周期中执行重操作</li>\n<li>使用 <code>shouldComponentUpdate</code> 进行性能优化</li>\n</ul>\n</li>\n<li><strong>代码组织</strong>  ：\n<ul>\n<li>将不同生命周期的逻辑分块注释</li>\n<li>复杂逻辑抽离为独立方法</li>\n</ul>\n</li>\n</ol>\n<h2>五、生命周期执行顺序示例</h2>\n<h3>1. 页面加载时</h3>\n<pre><code>页面 onLoad → 组件 constructor → 组件 componentWillMount → 页面 onShow → \n组件 componentDidMount → 组件 useReady → 页面 onReady\n</code></pre>\n<h3>2. 页面切换时</h3>\n<pre><code>当前页面 onHide → 新页面 onLoad → 新页面 onShow → 新页面组件挂载流程\n</code></pre>\n<h2>六、常见问题解决</h2>\n<ol>\n<li><strong>生命周期不触发</strong>  ：\n<ul>\n<li>检查组件是否被正确引入和使用</li>\n<li>确认是否使用了正确的生命周期名称</li>\n</ul>\n</li>\n<li><strong>执行顺序问题</strong>  ：\n<ul>\n<li>注意页面和组件生命周期的先后关系</li>\n<li>使用 <code>useEffect</code> 的依赖数组控制执行时机</li>\n</ul>\n</li>\n<li><strong>异步数据加载</strong>  ：<pre><code class="language-jsx"><span class="hljs-title function_">useReady</span>(<span class="hljs-title function_">async</span> () =&gt; {\n  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>()\n  <span class="hljs-title function_">setData</span>(data)\n})\n</code></pre>\n</li>\n</ol>\n<p>通过以上方法，你可以根据项目需求灵活选择最适合的生命周期书写方式，在 Taro 中实现各种复杂的组件逻辑。</p>\n</div>'</script></body></html>