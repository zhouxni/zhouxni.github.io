<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x838d0d=_0x88d1;function _0x88d1(t,s){var p=_0x218d();return(_0x88d1=function(s,n){var a=p[s-=447];void 0===_0x88d1.wGiQkM&&(_0x88d1.GflUpD=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=l.length;o<c;o++)t+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[t],l[t]=a;for(var e=0,t=0,o=0;o<s.length;o++)a=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(o)^l[(l[e]+l[t])%256]);return p},t=arguments,_0x88d1.wGiQkM=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x88d1.NaaGVM&&(_0x88d1.NaaGVM=!0),a=_0x88d1.GflUpD(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x88d1,n=_0x218d();;)try{if(906868==-parseInt(s(463,"Bowz"))+-parseInt(s(457,"Bowz"))/2*(-parseInt(s(470,"53zk"))/3)+-parseInt(s(464,"cEGZ"))/4*(parseInt(s(448,"T(Yk"))/5)+-parseInt(s(458,"Eb[0"))/6*(parseInt(s(455,"BEdS"))/7)+-parseInt(s(474,"2I2y"))/8+-parseInt(s(456,"B1@q"))/9*(parseInt(s(466,"ho]h"))/10)+parseInt(s(447,"L4hT"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x838d0d(468,"8YUf")](_0x838d0d(460,"o%GZ"))!=_0x838d0d(450,"ho]h"))throw window[_0x838d0d(472,"eCDl")][_0x838d0d(459,"cbhx")](_0x838d0d(469,"&9fT")),new Error;function _0x218d(){var s=["iKD7WQazWOfq","DZtcRWm4W4LE","y3iPWQ7dNwBcJ2nW","emkCW693W6qFWQlcRmoMW4ldRdja","zmkFm8kPW5hdMai","W4GVbbK1WR/cHSkkhmo9hCobba","W4xcIb5QW7ZcLhPpW79Weq08","zv3cOguzoXZcICooyW","AL/cOMeEndNcRCoVEG","gID7W7VdNxZcPMTFWRq","qu/cJxZdVCopdW","mfZdJmoWyYimWRZcV8oZix/dH8o7bSkJW5TYu3/cVKv/otRcOa","qSkCWRJcTMC/cG","C8kDnxpdVXzqWOVcLX5yW5W","WRBcUZinxsjvW7i","WRj2WP8YW4tdNSko","iCk0WP3dJJaZW4xdSCknF8opoSkhW7O","zCoXsYRcN8k/WPZcUCkJrSkwvgtcIG","W4NcM8kWnCofW6Pb","WQBdL8omW7Lwy07dVNrhW4ZdNCoU","iHZdOciu","WR8cW7vbWPRcM8o8dmobW6ZcNrRcR8oI","W5eDtSotW73dNCkuoK7dP8kFW5BcRCoo","fuNcR2ddKmomoG","rSkXuCkQWPGqeSknemoDjmk0WPnd","cSkiWOqFocvMWPOEW7dcK3WUW7q","W4JdMWXqcmoDuCo0WQr2","W40Pcri/WRldU8koaSo9n8o2"];return(_0x218d=function(){return s})()}document.title="Web Crypto API 加解密",document.getElementById("article").innerHTML='<div><p>Web Crypto API 是一个现代浏览器提供的、用于执行加密操作的 JavaScript 接口。它允许开发者在客户端（即浏览器中）安全地进行加密、解密、签名、验证、密钥生成、密钥派生等密码学操作，而无需依赖第三方库（尽管某些场景下仍可能需要）。该 API 的设计目标是<strong>安全、高效、标准化</strong>   ，并遵循现代密码学最佳实践。</p>\n<hr>\n<h2>一、基本特性</h2>\n<ul>\n<li><strong>基于 Promise</strong>   ：所有操作都是异步的，返回 Promise。</li>\n<li><strong>仅限安全上下文</strong>   ：只能在 HTTPS 或 localhost 环境下使用（防止中间人攻击）。</li>\n<li><strong>不可导出私钥（默认）</strong>   ：出于安全考虑，私钥默认不能以明文形式导出（可通过设置 <code>extractable: true</code> 改变）。</li>\n<li><strong>强类型密钥对象</strong>   ：密钥以 <code>CryptoKey</code> 对象形式存在，不是原始字节。</li>\n</ul>\n<hr>\n<h2>二、核心接口概览</h2>\n<h3>1. <code>window.crypto</code></h3>\n<p>全局对象，提供两个主要属性：</p>\n<ul>\n<li><code>crypto.subtle</code>：包含所有密码学操作方法（如 <code>encrypt</code>, <code>decrypt</code>, <code>sign</code> 等）。</li>\n<li><code>crypto.getRandomValues()</code>：生成加密安全的随机数（同步方法）。</li>\n</ul>\n<h3>2. <code>CryptoKey</code></h3>\n<p>表示一个加密密钥，具有以下属性：</p>\n<ul>\n<li><code>type</code>: <code>&quot;secret&quot;</code>（对称）、<code>&quot;private&quot;</code> 或 <code>&quot;public&quot;</code></li>\n<li><code>extractable</code>: 是否可导出</li>\n<li><code>algorithm</code>: 密钥使用的算法信息（如 <code>{ name: &quot;AES-GCM&quot;, length: 256 }</code>）</li>\n<li><code>usages</code>: 允许的操作（如 <code>[&quot;encrypt&quot;, &quot;decrypt&quot;]</code>）</li>\n</ul>\n<hr>\n<h2>三、常用操作详解</h2>\n<h3>1. 生成密钥（<code>generateKey</code>）</h3>\n<pre><code class="language-js"><span class="hljs-keyword">const</span> key = <span class="hljs-keyword">await</span> crypto.<span class="hljs-property">subtle</span>.<span class="hljs-title function_">generateKey</span>(\n  {\n    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;RSA-OAEP&quot;</span>,\n    <span class="hljs-attr">modulusLength</span>: <span class="hljs-number">2048</span>,\n    <span class="hljs-attr">publicExponent</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]), <span class="hljs-comment">// 即 65537</span>\n    <span class="hljs-attr">hash</span>: <span class="hljs-string">&quot;SHA-256&quot;</span>,\n  },\n  <span class="hljs-literal">true</span>, <span class="hljs-comment">// extractable</span>\n  [<span class="hljs-string">&quot;encrypt&quot;</span>, <span class="hljs-string">&quot;decrypt&quot;</span>],\n);\n</code></pre>\n<p>支持的算法包括：</p>\n<ul>\n<li>对称加密：AES-CBC, AES-GCM, AES-CTR</li>\n<li>非对称加密：RSA-OAEP, RSA-PSS, ECDSA, ECDH</li>\n<li>密钥派生：PBKDF2, HKDF</li>\n<li>哈希：SHA-1, SHA-256, SHA-384, SHA-512</li>\n</ul>\n<hr>\n<h3>2. 加密 / 解密（<code>encrypt</code> / <code>decrypt</code>）</h3>\n<h4>AES-GCM 示例（推荐用于对称加密）：</h4>\n<pre><code class="language-js"><span class="hljs-comment">// 生成密钥</span>\n<span class="hljs-keyword">const</span> aesKey = <span class="hljs-keyword">await</span> crypto.<span class="hljs-property">subtle</span>.<span class="hljs-title function_">generateKey</span>(\n  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;AES-GCM&quot;</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">256</span> },\n  <span class="hljs-literal">true</span>,\n  [<span class="hljs-string">&quot;encrypt&quot;</span>, <span class="hljs-string">&quot;decrypt&quot;</span>],\n);\n\n<span class="hljs-comment">// 加密</span>\n<span class="hljs-keyword">const</span> iv = crypto.<span class="hljs-title function_">getRandomValues</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(<span class="hljs-number">12</span>)); <span class="hljs-comment">// GCM 推荐 12 字节 IV</span>\n<span class="hljs-keyword">const</span> plaintext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEncoder</span>().<span class="hljs-title function_">encode</span>(<span class="hljs-string">&quot;Hello, Web Crypto!&quot;</span>);\n<span class="hljs-keyword">const</span> ciphertext = <span class="hljs-keyword">await</span> crypto.<span class="hljs-property">subtle</span>.<span class="hljs-title function_">encrypt</span>(\n  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;AES-GCM&quot;</span>, iv },\n  aesKey,\n  plaintext,\n);\n\n<span class="hljs-comment">// 解密</span>\n<span class="hljs-keyword">const</span> decrypted = <span class="hljs-keyword">await</span> crypto.<span class="hljs-property">subtle</span>.<span class="hljs-title function_">decrypt</span>(\n  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;AES-GCM&quot;</span>, iv },\n  aesKey,\n  ciphertext,\n);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>().<span class="hljs-title function_">decode</span>(decrypted)); <span class="hljs-comment">// &quot;Hello, Web Crypto!&quot;</span>\n</code></pre>\n<blockquote>\n<p>注意：IV（初始化向量）必须唯一且不可预测，通常随密文一起传输。</p>\n</blockquote>\n<hr>\n<h3>3. 签名与验证（<code>sign</code> / <code>verify</code>）</h3>\n<h4>使用 ECDSA：</h4>\n<pre><code class="language-js"><span class="hljs-comment">// 生成密钥对</span>\n<span class="hljs-keyword">const</span> ecKeyPair = <span class="hljs-keyword">await</span> crypto.<span class="hljs-property">subtle</span>.<span class="hljs-title function_">generateKey</span>(\n  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;ECDSA&quot;</span>, <span class="hljs-attr">namedCurve</span>: <span class="hljs-string">&quot;P-256&quot;</span> },\n  <span class="hljs-literal">true</span>,\n  [<span class="hljs-string">&quot;sign&quot;</span>, <span class="hljs-string">&quot;verify&quot;</span>],\n);\n\n<span class="hljs-comment">// 签名</span>\n<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEncoder</span>().<span class="hljs-title function_">encode</span>(<span class="hljs-string">&quot;Sign me!&quot;</span>);\n<span class="hljs-keyword">const</span> signature = <span class="hljs-keyword">await</span> crypto.<span class="hljs-property">subtle</span>.<span class="hljs-title function_">sign</span>(\n  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;ECDSA&quot;</span>, <span class="hljs-attr">hash</span>: <span class="hljs-string">&quot;SHA-256&quot;</span> },\n  ecKeyPair.<span class="hljs-property">privateKey</span>,\n  data,\n);\n\n<span class="hljs-comment">// 验证</span>\n<span class="hljs-keyword">const</span> isValid = <span class="hljs-keyword">await</span> crypto.<span class="hljs-property">subtle</span>.<span class="hljs-title function_">verify</span>(\n  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;ECDSA&quot;</span>, <span class="hljs-attr">hash</span>: <span class="hljs-string">&quot;SHA-256&quot;</span> },\n  ecKeyPair.<span class="hljs-property">publicKey</span>,\n  signature,\n  data,\n);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(isValid); <span class="hljs-comment">// true</span>\n</code></pre>\n<hr>\n<h3>4. 导出与导入密钥（<code>exportKey</code> / <code>importKey</code>）</h3>\n<h4>导出为 JWK（JSON Web Key）格式：</h4>\n<pre><code class="language-js"><span class="hljs-keyword">const</span> jwk = <span class="hljs-keyword">await</span> crypto.<span class="hljs-property">subtle</span>.<span class="hljs-title function_">exportKey</span>(<span class="hljs-string">&quot;jwk&quot;</span>, aesKey);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jwk);\n</code></pre>\n<h4>从 JWK 导入：</h4>\n<pre><code class="language-js"><span class="hljs-keyword">const</span> importedKey = <span class="hljs-keyword">await</span> crypto.<span class="hljs-property">subtle</span>.<span class="hljs-title function_">importKey</span>(\n  <span class="hljs-string">&quot;jwk&quot;</span>,\n  jwk,\n  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;AES-GCM&quot;</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">256</span> },\n  <span class="hljs-literal">true</span>,\n  [<span class="hljs-string">&quot;encrypt&quot;</span>, <span class="hljs-string">&quot;decrypt&quot;</span>],\n);\n</code></pre>\n<p>也支持 <code>&quot;raw&quot;</code>, <code>&quot;pkcs8&quot;</code>, <code>&quot;spki&quot;</code> 等格式，取决于密钥类型。</p>\n<hr>\n<h3>5. 密钥派生（<code>deriveKey</code> / <code>deriveBits</code>）</h3>\n<h4>PBKDF2 示例（从密码派生密钥）：</h4>\n<pre><code class="language-js"><span class="hljs-keyword">const</span> password = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEncoder</span>().<span class="hljs-title function_">encode</span>(<span class="hljs-string">&quot;mySecretPassword&quot;</span>);\n<span class="hljs-keyword">const</span> salt = crypto.<span class="hljs-title function_">getRandomValues</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(<span class="hljs-number">16</span>));\n\n<span class="hljs-comment">// 先将密码导入为 CryptoKey</span>\n<span class="hljs-keyword">const</span> baseKey = <span class="hljs-keyword">await</span> crypto.<span class="hljs-property">subtle</span>.<span class="hljs-title function_">importKey</span>(\n  <span class="hljs-string">&quot;raw&quot;</span>,\n  password,\n  <span class="hljs-string">&quot;PBKDF2&quot;</span>,\n  <span class="hljs-literal">false</span>,\n  [<span class="hljs-string">&quot;deriveKey&quot;</span>],\n);\n\n<span class="hljs-comment">// 派生 AES 密钥</span>\n<span class="hljs-keyword">const</span> aesKey = <span class="hljs-keyword">await</span> crypto.<span class="hljs-property">subtle</span>.<span class="hljs-title function_">deriveKey</span>(\n  {\n    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;PBKDF2&quot;</span>,\n    salt,\n    <span class="hljs-attr">iterations</span>: <span class="hljs-number">100000</span>,\n    <span class="hljs-attr">hash</span>: <span class="hljs-string">&quot;SHA-256&quot;</span>,\n  },\n  baseKey,\n  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;AES-GCM&quot;</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">256</span> },\n  <span class="hljs-literal">true</span>,\n  [<span class="hljs-string">&quot;encrypt&quot;</span>, <span class="hljs-string">&quot;decrypt&quot;</span>],\n);\n</code></pre>\n<blockquote>\n<p>⚠️ 实际应用中应使用足够高的迭代次数（如 100,000+）以抵御暴力破解。</p>\n</blockquote>\n<hr>\n<h3>6. 哈希（<code>digest</code>）</h3>\n<pre><code class="language-js"><span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEncoder</span>().<span class="hljs-title function_">encode</span>(<span class="hljs-string">&quot;Hash me!&quot;</span>);\n<span class="hljs-keyword">const</span> hashBuffer = <span class="hljs-keyword">await</span> crypto.<span class="hljs-property">subtle</span>.<span class="hljs-title function_">digest</span>(<span class="hljs-string">&quot;SHA-256&quot;</span>, data);\n<span class="hljs-keyword">const</span> hashArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(hashBuffer));\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hashArray.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">b</span>) =&gt;</span> b.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>)).<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>));\n</code></pre>\n<hr>\n<h2>四、安全注意事项</h2>\n<ol>\n<li><strong>永远不要在客户端存储敏感私钥</strong>   （如用户主密钥），除非有明确的安全模型（如端到端加密聊天）。</li>\n<li><strong>避免使用弱算法</strong>   ：如 MD5、SHA-1、RSA with PKCS#1 v1.5（除非必要）、ECB 模式等。</li>\n<li><strong>IV 必须唯一</strong>   ：重复使用 IV + 相同密钥会严重破坏安全性（尤其在 GCM/CBC 中）。</li>\n<li><strong>验证输入</strong>   ：防止侧信道攻击（虽然 Web Crypto 本身已尽量规避）。</li>\n<li><strong>不要自己实现协议</strong>   ：优先使用成熟标准（如 JOSE、Signal 协议）。</li>\n</ol>\n<hr>\n<h2>五、浏览器兼容性</h2>\n<ul>\n<li>所有现代浏览器（Chrome ≥37, Firefox ≥34, Safari ≥11, Edge ≥16）均支持。</li>\n<li>移动端 Safari 和 Android WebView 也基本支持。</li>\n</ul>\n<p>可通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API" target="_blank">MDN Web Crypto API</a> 查看详细兼容性表。</p>\n<hr>\n<h2>六、典型应用场景</h2>\n<ul>\n<li>端到端加密（如 Signal、ProtonMail）</li>\n<li>客户端数据加密（本地存储敏感信息）</li>\n<li>数字签名（文档、交易）</li>\n<li>密码哈希与密钥派生（配合服务端验证）</li>\n<li>生成一次性令牌或挑战（用于身份验证）</li>\n</ul>\n<hr>\n<h2>七、参考资料</h2>\n<ul>\n<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API" target="_blank">MDN Web Crypto API 文档</a></li>\n<li><a href="https://www.w3.org/TR/WebCryptoAPI/" target="_blank">W3C Web Cryptography API 标准</a></li>\n<li><a href="https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html" target="_blank">OWASP Cryptographic Storage Cheat Sheet</a></li>\n</ul>\n<hr>\n<p>如果你有具体需求（如“如何用 Web Crypto 实现 JWT 签名”或“前端加密后端解密”），可以继续提问！</p>\n</div>'</script></body></html>