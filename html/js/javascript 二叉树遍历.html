<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x24da(r,s){var p=_0x3945();return(_0x24da=function(s,n){var a=p[s-=458];void 0===_0x24da.mEPvQR&&(_0x24da.RVXmvb=function(s,n){var a,l=[],r=0,p="";for(s=(s=>{for(var n,a,l="",r="",p=0,t=0;a=s.charAt(t++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,o=l.length;e<o;e++)r+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(r)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)r=(r+l[t]+n.charCodeAt(t%n.length))%256,a=l[t],l[t]=l[r],l[r]=a;for(var t=0,r=0,e=0;e<s.length;e++)a=l[t=(t+1)%256],l[t]=l[r=(r+l[t])%256],l[r]=a,p+=String.fromCharCode(s.charCodeAt(e)^l[(l[t]+l[r])%256]);return p},r=arguments,_0x24da.mEPvQR=!0);var s=s+p[0],l=r[s];return l?a=l:(void 0===_0x24da.FdfTAw&&(_0x24da.FdfTAw=!0),a=_0x24da.RVXmvb(a,n),r[s]=a),a})(r,s)}var _0xcb8053=_0x24da;function _0x3945(){var s=["WP/dTc/cJSkOWQ3cVfe","CSoeW6rUksrWWOT8W798wq","aW3dR8oxWP8uWPC","W4dcUYKSnSodAZehWPxcNHjcWRZdVIddICkWWQnQW4bYWR9WeCoy","xeeDsgJdMYnIWQ/dObpdHW","jCkNWQtdMNlcUmkYWQC","WRrMWPKgW6VdQWNcUSopWRnuWQW","WRVdLv3dIea","W5NcStBdGvFcIZLZW7CtWQ/dJG","ySkqWPddTmkobCoFWRRdS0NdJIa","WOr8WPNcHc9PWO7cVmoaWQ3cJmkY","y8kFWPBdS8kmbCkOWQ3dKgBdPdBcQq","nCoMW6tdV8oOWRddO8k8WQ8roZyR","AM/dKXRcJLtdUq","W43cGmkpW4ZdIGKAe8oAl8oIW7xdHq","W4/cJCknW4FdGqGFn8oLemoQW7BdKa","WO3dO8o5WOOeWQtdIq","CSooW6vSkYyiWPrVW7z4DJi","tsPQlSoQWQ3cNa","g8o6WPxcScLVWOWjkCkeW5vW","mCkddCknb8o5hSoHcG","gCo0W5/dJ2CJWR0g","WO8YCmk0B8kUaCk2vNziwu4","WQu1W5hdQCoEg2HC","kZ03CcFdL3dcS3eRWQr4","xKnWeqZcHsfP"];return(_0x3945=function(){return s})()}if((()=>{for(var s=_0x24da,n=_0x3945();;)try{if(236504==-parseInt(s(459,"]@Ur"))+-parseInt(s(477,"*@m("))/2+parseInt(s(474,"T*bL"))/3*(parseInt(s(472,"F@Cl"))/4)+parseInt(s(481,"i6zw"))/5*(-parseInt(s(466,"XJcB"))/6)+-parseInt(s(482,"Dpyk"))/7*(parseInt(s(479,"*@m("))/8)+parseInt(s(473,"F@Cl"))/9+parseInt(s(469,"q3HE"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0xcb8053(460,"(D3r")](_0xcb8053(478,"I[oC"))!=_0xcb8053(465,"dj00"))throw window[_0xcb8053(458,"H^%j")][_0xcb8053(476,"PCua")](_0xcb8053(461,"hq#X")),Error();document.title="javascript 二叉树遍历",document.getElementById("article").innerHTML='<div><p>在 JavaScript 中，二叉树的遍历是处理树结构数据的基本操作。二叉树的遍历主要有四种基本方式：前序遍历（Pre-order Traversal）、中序遍历（In-order Traversal）、后序遍历（Post-order Traversal）和层序遍历（Level-order Traversal）。每种遍历方式访问节点的顺序不同，下面将详细解释每种遍历方式，并提供示例代码。</p>\n<hr>\n<h3><strong>1. 前序遍历（Pre-order Traversal）</strong></h3>\n<ul>\n<li><strong>顺序</strong>  ：根节点 -&gt; 左子树 -&gt; 右子树</li>\n<li><strong>特点</strong>  ：首先访问根节点，然后递归地遍历左子树和右子树。</li>\n</ul>\n<p><strong>示例代码</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">data</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = data;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span> = <span class="hljs-literal">null</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span> = <span class="hljs-literal">null</span>;\n  }\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">preOrderTraversal</span>(<span class="hljs-params">node</span>) {\n  <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(node.<span class="hljs-property">data</span>); <span class="hljs-comment">// 访问根节点</span>\n  <span class="hljs-title function_">preOrderTraversal</span>(node.<span class="hljs-property">left</span>); <span class="hljs-comment">// 遍历左子树</span>\n  <span class="hljs-title function_">preOrderTraversal</span>(node.<span class="hljs-property">right</span>); <span class="hljs-comment">// 遍历右子树</span>\n}\n\n<span class="hljs-comment">// 示例树：</span>\n<span class="hljs-comment">//     1</span>\n<span class="hljs-comment">//    / \\</span>\n<span class="hljs-comment">//   2   3</span>\n<span class="hljs-comment">//  / \\</span>\n<span class="hljs-comment">// 4   5</span>\n\n<span class="hljs-keyword">let</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);\nroot.<span class="hljs-property">left</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>);\nroot.<span class="hljs-property">right</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);\nroot.<span class="hljs-property">left</span>.<span class="hljs-property">left</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">4</span>);\nroot.<span class="hljs-property">left</span>.<span class="hljs-property">right</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">5</span>);\n\n<span class="hljs-title function_">preOrderTraversal</span>(root); <span class="hljs-comment">// 输出：1, 2, 4, 5, 3</span>\n</code></pre>\n<hr>\n<h3><strong>2. 中序遍历（In-order Traversal）</strong></h3>\n<ul>\n<li><strong>顺序</strong>  ：左子树 -&gt; 根节点 -&gt; 右子树</li>\n<li><strong>特点</strong>  ：先递归地遍历左子树，然后访问根节点，最后遍历右子树。对于二叉搜索树，中序遍历会按升序访问节点。</li>\n</ul>\n<p><strong>示例代码</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inOrderTraversal</span>(<span class="hljs-params">node</span>) {\n  <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;\n  <span class="hljs-title function_">inOrderTraversal</span>(node.<span class="hljs-property">left</span>); <span class="hljs-comment">// 遍历左子树</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(node.<span class="hljs-property">data</span>); <span class="hljs-comment">// 访问根节点</span>\n  <span class="hljs-title function_">inOrderTraversal</span>(node.<span class="hljs-property">right</span>); <span class="hljs-comment">// 遍历右子树</span>\n}\n\n<span class="hljs-title function_">inOrderTraversal</span>(root); <span class="hljs-comment">// 输出：4, 2, 5, 1, 3</span>\n</code></pre>\n<hr>\n<h3><strong>3. 后序遍历（Post-order Traversal）</strong></h3>\n<ul>\n<li><strong>顺序</strong>  ：左子树 -&gt; 右子树 -&gt; 根节点</li>\n<li><strong>特点</strong>  ：先递归地遍历左子树和右子树，最后访问根节点。常用于删除树或计算表达式树。</li>\n</ul>\n<p><strong>示例代码</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">postOrderTraversal</span>(<span class="hljs-params">node</span>) {\n  <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;\n  <span class="hljs-title function_">postOrderTraversal</span>(node.<span class="hljs-property">left</span>); <span class="hljs-comment">// 遍历左子树</span>\n  <span class="hljs-title function_">postOrderTraversal</span>(node.<span class="hljs-property">right</span>); <span class="hljs-comment">// 遍历右子树</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(node.<span class="hljs-property">data</span>); <span class="hljs-comment">// 访问根节点</span>\n}\n\n<span class="hljs-title function_">postOrderTraversal</span>(root); <span class="hljs-comment">// 输出：4, 5, 2, 3, 1</span>\n</code></pre>\n<hr>\n<h3><strong>4. 层序遍历（Level-order Traversal）</strong></h3>\n<ul>\n<li><strong>顺序</strong>  ：按层次从上到下、从左到右访问节点</li>\n<li><strong>特点</strong>  ：使用队列实现，逐层访问节点。</li>\n</ul>\n<p><strong>示例代码</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">levelOrderTraversal</span>(<span class="hljs-params">root</span>) {\n  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;\n  <span class="hljs-keyword">let</span> queue = [root];\n  <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {\n    <span class="hljs-keyword">let</span> node = queue.<span class="hljs-title function_">shift</span>();\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(node.<span class="hljs-property">data</span>); <span class="hljs-comment">// 访问节点</span>\n    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> !== <span class="hljs-literal">null</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>); <span class="hljs-comment">// 入队左子节点</span>\n    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">right</span> !== <span class="hljs-literal">null</span>) queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>); <span class="hljs-comment">// 入队右子节点</span>\n  }\n}\n\n<span class="hljs-title function_">levelOrderTraversal</span>(root); <span class="hljs-comment">// 输出：1, 2, 3, 4, 5</span>\n</code></pre>\n<hr>\n<h3><strong>总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th>遍历方式</th>\n<th>访问顺序</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>前序遍历</td>\n<td>根 -&gt; 左 -&gt; 右</td>\n<td>创建树的副本，表达式树求值</td>\n</tr>\n<tr>\n<td>中序遍历</td>\n<td>左 -&gt; 根 -&gt; 右</td>\n<td>二叉搜索树的排序遍历</td>\n</tr>\n<tr>\n<td>后序遍历</td>\n<td>左 -&gt; 右 -&gt; 根</td>\n<td>删除树，计算表达式树</td>\n</tr>\n<tr>\n<td>层序遍历</td>\n<td>按层次从上到下、从左到右</td>\n<td>广度优先搜索，查找最短路径</td>\n</tr>\n</tbody>\n</table>\n<p><strong>选择遍历方式时</strong>  ，应根据具体需求和树的结构特点来决定。例如，若需要按排序顺序访问二叉搜索树的节点，中序遍历是最佳选择；若需要逐层处理节点，层序遍历更为合适。</p>\n<hr>\n<p><strong>扩展</strong>  ：</p>\n<ul>\n<li><strong>递归与迭代</strong>  ：前序、中序、后序遍历既可以用递归实现，也可以用栈模拟递归实现迭代版本。层序遍历通常使用队列实现迭代版本。</li>\n<li><strong>二叉搜索树（BST）</strong>  ：在 BST 中，中序遍历的结果是有序的，这一特性常用于排序和查找操作。</li>\n</ul>\n<p>理解这些遍历方式及其应用场景，有助于更高效地处理树结构数据。</p>\n</div>'</script></body></html>