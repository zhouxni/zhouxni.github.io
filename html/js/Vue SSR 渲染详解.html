<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0xf866(t,s){var e=_0x119b();return(_0xf866=function(s,n){var a=e[s-=205];void 0===_0xf866.ZmJRQn&&(_0xf866.xkotKI=function(s,n){var a,l=[],t=0,e="";for(s=(s=>{for(var n,a,l="",t="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,c=l.length;r<c;r++)t+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(t)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)t=(t+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[t],l[t]=a;for(var p=0,t=0,r=0;r<s.length;r++)a=l[p=(p+1)%256],l[p]=l[t=(t+l[p])%256],l[t]=a,e+=String.fromCharCode(s.charCodeAt(r)^l[(l[p]+l[t])%256]);return e},t=arguments,_0xf866.ZmJRQn=!0);var s=s+e[0],l=t[s];return l?a=l:(void 0===_0xf866.RrRDHw&&(_0xf866.RrRDHw=!0),a=_0xf866.xkotKI(a,n),t[s]=a),a})(t,s)}function _0x119b(){var s=["W7zLuSoqsCklW51YWR7cRCk5","ecKbWOGNWPddHKFdV8o4W4j7","z8o/WRNcHcmaWRFdLmo3WObuW44N","wu4wESosjCkOra","W7VdIJODz8kFWQbCwfqpW6m","px5lWRBdNSo4W6yhWRijE8oD","FufBWPTqawvR","W5FdMSk8W6RdG8kTWQLu","bCklhbRdTmobWRrSDLW","W6tdOSobmLtdN0FcQmo6ydJcKSklWQu","W6OJDxNcSfNcUG","hZNdVCkWWRJcUdfC","WPzDWPa3WPfkwmkmWQyTWRRcT14","WPZdUmk8WPyvWPJcQ1VdICksWPjpra","i8oLDSkhWRWqWQBcRZ9J","W6FcGCkCxY3cTaS","jSk+FmoKW4qdgCkjWR9oWQ3cGW","W6qlW4rMW5Coi8kJWOu","WOpcJmkmW5ddG8knWP4","W6G9j8ocWPNcOCkOWPZcTZ7dRa","gCo+WPhdLmok","W4RcVhlcGSkoW6lcM2G","wLqTW6HAW6K/pgybxmoMW4WYW6jtkK47qSkdWRH2wrjB","WQHTB8kEW4VcTCkN","hmkaWR5PW4VdOCoFrHhdMeNcSa","W6lcTcpdVZSeASkYWPDEWQJcJJm","iSk9FmoVW4igk8ktWP9JWQNcRa","W6VcG8k4xxy0tCoLxLFdGSowicO"];return(_0x119b=function(){return s})()}var _0x1e56a2=_0xf866;if((()=>{for(var s=_0xf866,n=_0x119b();;)try{if(587360==-parseInt(s(213,"kZA^"))*(-parseInt(s(223,"dU8B"))/2)+parseInt(s(215,"#RUJ"))/3*(parseInt(s(232,"pD9*"))/4)+parseInt(s(205,"WHh5"))/5*(parseInt(s(211,"[mNu"))/6)+parseInt(s(212,"C*e#"))/7+-parseInt(s(216,"fR3A"))/8*(parseInt(s(208,"&9ZO"))/9)+parseInt(s(221,"qNE9"))/10+-parseInt(s(207,"9Pzy"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1e56a2(226,"#RUJ")](_0x1e56a2(225,"!tDd"))!=_0x1e56a2(228,"vO[@"))throw window[_0x1e56a2(229,"(b9j")][_0x1e56a2(231,"Tjv*")](_0x1e56a2(230,"B3^L")),Error();document.title="Vue SSR 渲染详解",document.getElementById("article").innerHTML='<div><p>Vue SSR (Server-Side Rendering) 是指将 Vue 应用在服务器端渲染成 HTML 字符串，然后发送给客户端的技术。以下是 Vue SSR 的核心概念和工作原理：</p>\n<p>一、SSR 核心优势</p>\n<ol>\n<li>更好的 SEO：搜索引擎可以直接抓取服务器渲染的完整 HTML</li>\n<li>更快的首屏加载：用户无需等待所有 JavaScript 下载执行就能看到内容</li>\n<li>更好的用户体验：特别适合慢速网络环境下的用户</li>\n</ol>\n<p>二、SSR 基本工作原理</p>\n<pre><code>客户端请求 → Node.js 服务器 → 执行 Vue 应用 → 渲染为 HTML → 发送给客户端 → 客户端&quot;激活&quot;(hydration)\n</code></pre>\n<p>三、Vue SSR 实现方案</p>\n<ol>\n<li>手动配置 SSR (底层实现)</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// server.js</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">Vue</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vue&#x27;</span>)\n<span class="hljs-keyword">const</span> server = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)()\n\n<span class="hljs-keyword">const</span> renderer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vue-server-renderer&#x27;</span>).<span class="hljs-title function_">createRenderer</span>()\n\nserver.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({\n    <span class="hljs-attr">data</span>: { <span class="hljs-attr">url</span>: req.<span class="hljs-property">url</span> },\n    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;访问的 URL 是: {{ url }}&lt;/div&gt;`</span>\n  })\n\n  renderer.<span class="hljs-title function_">renderToString</span>(app, <span class="hljs-function">(<span class="hljs-params">err, html</span>) =&gt;</span> {\n    <span class="hljs-keyword">if</span> (err) {\n      res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;Internal Server Error&#x27;</span>)\n      <span class="hljs-keyword">return</span>\n    }\n    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">`\n      &lt;!DOCTYPE html&gt;\n      &lt;html lang=&quot;en&quot;&gt;\n        &lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;\n        &lt;body&gt;<span class="hljs-subst">${html}</span>&lt;/body&gt;\n      &lt;/html&gt;\n    `</span>)\n  })\n})\n\nserver.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>)\n</code></pre>\n<ol start="2">\n<li>使用 Nuxt.js (推荐方案)</li>\n</ol>\n<p>Nuxt.js 提供了开箱即用的 SSR 支持，简化了配置过程。</p>\n<p>四、SSR 关键概念</p>\n<ol>\n<li>通用代码要求</li>\n</ol>\n<ul>\n<li>\n<p>避免单例状态：因为每个请求应该都是全新的应用实例</p>\n</li>\n<li>\n<p>生命周期钩子：只有 <code>beforeCreate</code> 和 <code>created</code> 会在服务端执行</p>\n</li>\n<li>\n<p>访问平台特定 API：如 <code>window</code> 或 <code>document</code> 需要特殊处理</p>\n</li>\n</ul>\n<ol start="2">\n<li>数据预取</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在路由组件中使用 asyncData</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-keyword">async</span> <span class="hljs-title function_">asyncData</span> ({ params }) {\n    <span class="hljs-keyword">const</span> { data } = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/api/user/<span class="hljs-subst">${params.id}</span>`</span>)\n    <span class="hljs-keyword">return</span> { <span class="hljs-attr">user</span>: data }\n  }\n}\n</code></pre>\n<ol start="3">\n<li>客户端激活 (Hydration)</li>\n</ol>\n<p>客户端 Vue 会接管服务器渲染的静态 HTML，使其变为动态应用。</p>\n<p>五、SSR 常见问题解决方案</p>\n<ol>\n<li>跨请求状态污染</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// 错误示例 - 共享状态</span>\n<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>({ <span class="hljs-comment">/* ... */</span> })\n\n<span class="hljs-comment">// 正确做法 - 每个请求创建新实例</span>\n<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>({ <span class="hljs-comment">/* ... */</span> })\n</code></pre>\n<ol start="2">\n<li>处理浏览器特定 API</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在 mounted 钩子中使用浏览器 API</span>\n<span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleResize</span>)\n}\n</code></pre>\n<ol start="3">\n<li>处理异步组件</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// 使用 Vue 的 &lt;client-only&gt; 组件</span>\n&lt;client-only&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">some-client-side-only-component</span> /&gt;</span></span>\n&lt;/client-only&gt;\n</code></pre>\n<p>六、SSR 性能优化</p>\n<ol>\n<li>组件缓存：使用 <code>vue-server-renderer</code> 的缓存功能</li>\n<li>页面缓存：对静态页面使用 HTTP 缓存</li>\n<li>代码分割：利用 webpack 的代码分割功能</li>\n<li>流式渲染：使用 <code>renderToStream</code> 替代 <code>renderToString</code></li>\n</ol>\n<p>七、SSR 与 CSR 对比</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>SSR</th>\n<th>CSR (Client-Side Rendering)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>首次加载速度</td>\n<td>快 (直接显示HTML)</td>\n<td>慢 (需等待JS加载执行)</td>\n</tr>\n<tr>\n<td>SEO</td>\n<td>友好</td>\n<td>需要额外处理</td>\n</tr>\n<tr>\n<td>服务器负载</td>\n<td>高</td>\n<td>低</td>\n</tr>\n<tr>\n<td>开发复杂度</td>\n<td>较高</td>\n<td>较低</td>\n</tr>\n<tr>\n<td>用户交互体验</td>\n<td>需要激活过程</td>\n<td>直接响应</td>\n</tr>\n</tbody>\n</table>\n<p>八、何时使用 SSR</p>\n<ol>\n<li>SEO 是关键需求的项目</li>\n<li>首屏加载速度至关重要的应用</li>\n<li>内容为主的网站 (如新闻、博客等)</li>\n<li>需要支持慢速网络或旧设备的场景</li>\n</ol>\n<p>通过合理使用 Vue SSR，可以显著提升应用的可访问性和用户体验。</p>\n</div>'</script></body></html>