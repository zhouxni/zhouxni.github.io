<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3f5cc2=_0xe6b0;function _0xe6b0(r,s){var p=_0x2182();return(_0xe6b0=function(s,a){var n=p[s-=202];void 0===_0xe6b0.NwqKhh&&(_0xe6b0.lGXULg=function(s,a){var n,e=[],r=0,p="";for(s=(s=>{for(var a,n,e="",r="",p=0,l=0;n=s.charAt(l++);~n&&(a=p%4?64*a+n:n,p++%4)&&(e+=String.fromCharCode(255&a>>(-2*p&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var t=0,o=e.length;t<o;t++)r+="%"+("00"+e.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(r)})(s),l=0;l<256;l++)e[l]=l;for(l=0;l<256;l++)r=(r+e[l]+a.charCodeAt(l%a.length))%256,n=e[l],e[l]=e[r],e[r]=n;for(var l=0,r=0,t=0;t<s.length;t++)n=e[l=(l+1)%256],e[l]=e[r=(r+e[l])%256],e[r]=n,p+=String.fromCharCode(s.charCodeAt(t)^e[(e[l]+e[r])%256]);return p},r=arguments,_0xe6b0.NwqKhh=!0);var s=s+p[0],e=r[s];return e?n=e:(void 0===_0xe6b0.KsTfZq&&(_0xe6b0.KsTfZq=!0),n=_0xe6b0.lGXULg(n,a),r[s]=n),n})(r,s)}function _0x2182(){var s=["lfTwfmklWQez","WRCJW5NcRfrAW4VdNNnIzt40","WQldISoPW5rfxWjEp1xdUxy","bHDlW7FcU8k8D0XkW7RcQq","rCkHW7ZdMtH5W7H7W7W","FmknW7RcG13dUSoyDq","WRpdNJ0Igb8pW4JcSmo5WPHdWOO","xclcTXHjW6aNiLhcJr0","W7OHi8kZjqKyb8ooemooWQy","D8ohW5RcM8o6tae3W7JcNmozW7hdUYL2zCoHwgb2mrJdKWzqeq","WRvOEmo7tmkJWR8QnLfBWRbb","W4FcJaerWPdcMmkcW4mj","yfpdGw3dSNKGW50","gSkMW6qTbmohW6rxW5e","W5KPW4JdOaZcJSo1","WRzQCCo9r8kIWRSypuPiWPj8","WRJdNmougfayemobWPe","WRxdMdqGfbmjW7RcUSocWQ5wWQe","f8k3W7JdPmo4WOWhW6JdPq","WRtdNfDWyh91W6G","WQ7cLmkUWOlcPSkZwq","AxvFm8kMWOCz","afVdTtTOsZf9","ysZcICoyo0/dQ8kEW4ldNwC","qthdKIm4kWZdPatcNW/cIa","W7lcRmoJW7u5W4P4W7ZcNZzD","BhxdOJP+iSkuatXFzJS","WRRdNSovBHLkzCoqWORcRuRdTSkO","s00Zl8o1hCossa","WOtdJ0OJWPm"];return(_0x2182=function(){return s})()}if((()=>{for(var s=_0xe6b0,a=_0x2182();;)try{if(519946==+parseInt(s(216,"km#W"))*(parseInt(s(205,"Z(4m"))/2)+parseInt(s(203,"VJYs"))/3+-parseInt(s(212,"8*L3"))/4*(parseInt(s(231,"Y6]2"))/5)+-parseInt(s(229,"8*L3"))/6*(-parseInt(s(213,"$jg^"))/7)+-parseInt(s(209,"F!AX"))/8*(-parseInt(s(218,"@&&E"))/9)+-parseInt(s(208,"VJYs"))/10+-parseInt(s(217,"UhTQ"))/11*(parseInt(s(227,"HfqU"))/12))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x3f5cc2(207,"U7J3")](_0x3f5cc2(211,"ODdd"))!=_0x3f5cc2(222,"n*s#"))throw window[_0x3f5cc2(215,"SzR^")][_0x3f5cc2(214,"tg53")](_0x3f5cc2(202,"n2Pt")),Error();document.title="redux-promise 详解",document.getElementById("article").innerHTML='<div><p><strong>redux-promise 配置详解</strong></p>\n<p>redux-promise 是一个用于处理 Redux 中异步操作的中间件，它允许 action 的 payload 是一个 Promise 对象，并自动处理 Promise 的解析和拒绝。以下是关于 redux-promise 配置的详细解析：</p>\n<h3>一、安装</h3>\n<p>首先，你需要在项目中安装 redux-promise。你可以使用 npm 或 yarn 进行安装：</p>\n<pre><code class="language-sh">npm install redux-promise --save\n<span class="hljs-comment"># 或者</span>\nyarn add redux-promise\n</code></pre>\n<h3>二、配置 Redux Store</h3>\n<p>在创建 Redux store 时，你需要将 redux-promise 中间件应用到 store 中。通常，你可以使用 <code>applyMiddleware</code> 函数来实现这一点。以下是一个简单的配置示例：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createStore, applyMiddleware } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;\n<span class="hljs-keyword">import</span> promiseMiddleware <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-promise&#x27;</span>;\n<span class="hljs-keyword">import</span> rootReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducers&#x27;</span>;\n\n<span class="hljs-comment">// 创建 store 并应用 redux-promise 中间件</span>\n<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(rootReducer, <span class="hljs-title function_">applyMiddleware</span>(promiseMiddleware));\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;\n</code></pre>\n<h3>三、创建异步 Action Creator</h3>\n<p>使用 redux-promise 时，你可以创建返回 Promise 的异步 action creator。这些 action creator 在被 <code>dispatch</code> 时，redux-promise 会自动处理它们返回的 Promise。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;\n\n<span class="hljs-comment">// 异步 action creator</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_DATA&#x27;</span>,\n    <span class="hljs-attr">payload</span>: axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>) <span class="hljs-comment">// 返回一个 Promise</span>\n  };\n};\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> fetchData;\n</code></pre>\n<h3>四、处理异步 Action</h3>\n<p>在你的 reducer 中，你需要处理由 redux-promise 分发的成功和失败 action。通常，你会为每种 action 类型定义相应的处理逻辑。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> initialState = {\n  <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">data</span>: [],\n  <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span>\n};\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">dataReducer</span> = (<span class="hljs-params">state = initialState, action</span>) =&gt; {\n  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_DATA_PENDING&#x27;</span>: <span class="hljs-comment">// 当 Promise 正在处理时</span>\n      <span class="hljs-keyword">return</span> {\n        ...state,\n        <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span>\n      };\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_DATA_FULFILLED&#x27;</span>: <span class="hljs-comment">// 当 Promise 成功解析时</span>\n      <span class="hljs-keyword">return</span> {\n        ...state,\n        <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,\n        <span class="hljs-attr">data</span>: action.<span class="hljs-property">payload</span>.<span class="hljs-property">data</span> <span class="hljs-comment">// 假设 API 返回的数据在 data 属性中</span>\n      };\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_DATA_REJECTED&#x27;</span>: <span class="hljs-comment">// 当 Promise 被拒绝时</span>\n      <span class="hljs-keyword">return</span> {\n        ...state,\n        <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,\n        <span class="hljs-attr">error</span>: action.<span class="hljs-property">payload</span> <span class="hljs-comment">// 错误信息</span>\n      };\n    <span class="hljs-attr">default</span>:\n      <span class="hljs-keyword">return</span> state;\n  }\n};\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> dataReducer;\n</code></pre>\n<h3>五、高级配置</h3>\n<p>redux-promise 提供了一些高级配置选项，允许你自定义其行为。例如，你可以通过传递选项对象给 <code>promiseMiddleware</code> 函数来配置中间件。以下是一些常用的选项：</p>\n<ol>\n<li><strong>predicate</strong>  ：一个函数，用于过滤哪些 action 应该被 redux-promise 处理。函数接收 <code>action</code> 和 <code>store</code> 的 <code>getState</code> 方法作为参数，返回 <code>true</code> 则处理该 action，否则跳过。</li>\n<li><strong>transformError</strong>  ：一个函数，用于自定义错误处理逻辑。函数接收错误对象、被拒绝的 value 和原始的 action 作为参数，返回一个新的错误对象或原始错误对象。</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> promiseMiddleware <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-promise&#x27;</span>;\n\n<span class="hljs-keyword">const</span> customPromiseMiddleware = <span class="hljs-title function_">promiseMiddleware</span>({\n  <span class="hljs-attr">predicate</span>: <span class="hljs-function">(<span class="hljs-params">action</span>) =&gt;</span> action.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;FETCH_DATA&#x27;</span>, <span class="hljs-comment">// 只处理 FETCH_DATA 类型的 action</span>\n  <span class="hljs-attr">transformError</span>: <span class="hljs-function">(<span class="hljs-params">error, rejectedValue, action</span>) =&gt;</span> {\n    <span class="hljs-comment">// 自定义错误处理逻辑</span>\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Custom error: <span class="hljs-subst">${error.message}</span>`</span>);\n  }\n});\n\n<span class="hljs-comment">// 在创建 store 时应用自定义的 promiseMiddleware</span>\n<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(rootReducer, <span class="hljs-title function_">applyMiddleware</span>(customPromiseMiddleware));\n</code></pre>\n<h3>六、注意事项</h3>\n<ol>\n<li><strong>Promise 的处理</strong>  ：redux-promise 只处理 action 的 payload 是 Promise 的情况。如果 action 的 payload 不是 Promise，或者 action 本身是一个函数（如 redux-thunk 的情况），redux-promise 将不会处理它。</li>\n<li><strong>中间件顺序</strong>  ：在配置中间件时，需要注意中间件的顺序。通常，redux-promise 应该放在其他可能依赖于异步 action 的中间件之前。</li>\n<li><strong>错误处理</strong>  ：确保在你的 reducer 中处理异步 action 的失败情况，以便在用户界面中显示错误信息或采取其他适当的措施。</li>\n</ol>\n</div>'</script></body></html>