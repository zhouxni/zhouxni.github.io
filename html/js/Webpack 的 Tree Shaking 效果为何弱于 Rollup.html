<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4b47(t,s){var l=_0x4f5d();return(_0x4b47=function(s,n){var a=l[s-=450];void 0===_0x4b47.iBYOaM&&(_0x4b47.pavQtV=function(s,n){var a,o=[],t=0,l="";for(s=(s=>{for(var n,a,o="",t="",l=0,p=0;a=s.charAt(p++);~a&&(n=l%4?64*n+a:a,l++%4)&&(o+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,e=o.length;r<e;r++)t+="%"+("00"+o.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(t)})(s),p=0;p<256;p++)o[p]=p;for(p=0;p<256;p++)t=(t+o[p]+n.charCodeAt(p%n.length))%256,a=o[p],o[p]=o[t],o[t]=a;for(var p=0,t=0,r=0;r<s.length;r++)a=o[p=(p+1)%256],o[p]=o[t=(t+o[p])%256],o[t]=a,l+=String.fromCharCode(s.charCodeAt(r)^o[(o[p]+o[t])%256]);return l},t=arguments,_0x4b47.iBYOaM=!0);var s=s+l[0],o=t[s];return o?a=o:(void 0===_0x4b47.TxEfVU&&(_0x4b47.TxEfVU=!0),a=_0x4b47.pavQtV(a,n),t[s]=a),a})(t,s)}function _0x4f5d(){var s=["vCoKW5VdP8oxtSo2yLXHhCom","nCk3fw7cTCk/b8oPW4e","WPXIWOZcGc5rfq","xSkRy8kFWOtcNdhdO1i","kmk2AZpdT0DAWRxdH8krq8o7W6mjoCkfddtdNY9dvmk0sxVcLa","lSoDagOCyuPOWRjkWOen","zXbKeSo+WP/cRsjVW5NcQ8o6","dIxdQq3dLrVcLxqmW5nTuc0","w8k/fmkHWPLTla","WPZdUmkvl8oBWP84EL7dKG","WQ4eW5rdW5ZcRJ0","lCo+m8opW4xdMrFdOv3dQ8kEW4u","cwNcSCozWRTYqa","WQFdOaJcNmosofSPwfldVuO","jZtcNLpdU8okCLvBra","f8kNWPVcOCkC","W60HW4ddM8o/W6xdVu8xWQu","vCoIBCoKWQ9gjhvybW","WP4WW7ZdUKyPuCk6W4KuWPldVmk2","EwxdKYRdU8omuq","q0uqCSkXWRBcRmot","ddxdJSkJW5apDXjCcSo0W4a","W5u0WRxdKSoWW4/dO8oIWPy1ysq","W6qkW6PDW6NcTZy","qmoCuCoGWRW2vCojW5a","k1e6WPytrMZdG3NdVq","W5O3kSohogFdU2vpaq"];return(_0x4f5d=function(){return s})()}var _0x44674c=_0x4b47;if((()=>{for(var s=_0x4b47,n=_0x4f5d();;)try{if(216697==+parseInt(s(450,"ufuk"))+-parseInt(s(455,"Y^3Y"))/2*(parseInt(s(462,"(crt"))/3)+-parseInt(s(463,"eviW"))/4+-parseInt(s(468,"H0gN"))/5+parseInt(s(451,"g%b9"))/6*(-parseInt(s(459,"C*SX"))/7)+parseInt(s(473,"r548"))/8*(parseInt(s(456,"nZF5"))/9)+parseInt(s(464,"!M%f"))/10*(parseInt(s(467,"tBNL"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x44674c(469,"!M%f")](_0x44674c(453,"s@h1"))!=_0x44674c(465,"ufuk"))throw window[_0x44674c(470,"]w%v")][_0x44674c(460,"r548")](_0x44674c(454,"$V@*")),Error();document.title="Webpack 的 Tree Shaking 效果为何弱于 Rollup",document.getElementById("article").innerHTML='<div><p>Webpack 的 Tree Shaking 效果确实在多数场景下弱于 Rollup，这种差异主要源于两者不同的设计理念和实现机制。以下是关键原因分析：</p>\n<hr>\n<h3>一、架构设计差异</h3>\n<table>\n<thead>\n<tr>\n<th><strong>维度</strong></th>\n<th><strong>Webpack</strong></th>\n<th><strong>Rollup</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>设计目标</strong></td>\n<td>应用打包（支持复杂场景）</td>\n<td>库打包（追求纯净输出）</td>\n</tr>\n<tr>\n<td><strong>模块系统</strong></td>\n<td>支持 CommonJS/AMD/ESM 混合</td>\n<td>原生 ESM 优先</td>\n</tr>\n<tr>\n<td><strong>打包策略</strong></td>\n<td>分块/运行时加载</td>\n<td>静态分析/单文件输出</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>二、技术实现短板</h3>\n<ol>\n<li>\n<p><strong>CommonJS 兼容性代价</strong></p>\n<ul>\n<li>Webpack 必须处理动态<code>require</code>和<code>module.exports</code>，导致：<pre><code class="language-javascript"><span class="hljs-comment">// Webpack 无法确定哪些导出被使用</span>\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = dynamicCondition ? { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> } : { <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> };\n</code></pre>\n</li>\n<li>Rollup 默认仅处理 ESM，静态分析更彻底</li>\n</ul>\n</li>\n<li>\n<p><strong>作用域提升限制</strong></p>\n<ul>\n<li>Webpack 的 Scope Hoisting 需处理代码分割等复杂场景，导致：<pre><code class="language-javascript"><span class="hljs-comment">// 可能保留未使用的导出以防动态加载</span>\n<span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./module&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">m</span>) =&gt;</span> m.<span class="hljs-property">unusedExport</span>);\n</code></pre>\n</li>\n<li>Rollup 的静态提升可完全内联模块</li>\n</ul>\n</li>\n<li>\n<p><strong>副作用分析保守性</strong></p>\n<ul>\n<li>Webpack 对未知代码默认视作有副作用（安全优先）</li>\n<li>Rollup 采用激进标记（需手动<code>/*#__PURE__*/</code>标注）</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>三、典型场景对比</h3>\n<h4>场景1：第三方库导入</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { compact } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash-es&quot;</span>;\n</code></pre>\n<ul>\n<li><strong>Webpack</strong>   ：可能保留整个<code>lodash-es</code>（除非库明确声明<code>sideEffects: false</code>）</li>\n<li><strong>Rollup</strong>   ：默认只打包<code>compact</code>相关代码</li>\n</ul>\n<h4>场景2：重新导出(Re-export)</h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// a.js</span>\n<span class="hljs-keyword">export</span> { foo } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./b&quot;</span>;\n\n<span class="hljs-comment">// b.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-number">1</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> unused = <span class="hljs-number">2</span>;\n</code></pre>\n<ul>\n<li><strong>Webpack 5</strong>   ：能删除<code>unused</code> ✅</li>\n<li><strong>Rollup</strong>   ：还能优化掉<code>b.js</code>的独立存在（直接内联<code>foo</code>值）</li>\n</ul>\n<hr>\n<h3>四、优化建议（提升Webpack效果）</h3>\n<ol>\n<li>\n<p><strong>强制ESM规范</strong></p>\n<pre><code class="language-javascript"><span class="hljs-attr">resolve</span>: {\n  <span class="hljs-attr">mainFields</span>: [<span class="hljs-string">&quot;module&quot;</span>, <span class="hljs-string">&quot;main&quot;</span>]; <span class="hljs-comment">// 优先加载ESM版本</span>\n}\n</code></pre>\n</li>\n<li>\n<p><strong>精确副作用标记</strong></p>\n<pre><code class="language-json"><span class="hljs-comment">// package.json</span>\n<span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;sideEffects&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;*.css&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;*.global.js&quot;</span><span class="hljs-punctuation">]</span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n</li>\n<li>\n<p><strong>使用<code>/*#__PURE__*/</code>标记</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-comment">/*#__PURE__*/</span> <span class="hljs-title function_">createUnusedObject</span>();\n</code></pre>\n</li>\n<li>\n<p><strong>生产环境配置</strong></p>\n<pre><code class="language-javascript"><span class="hljs-attr">optimization</span>: {\n  <span class="hljs-attr">usedExports</span>: <span class="hljs-literal">true</span>,\n  <span class="hljs-attr">concatenateModules</span>: <span class="hljs-literal">true</span>,\n  <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 需配合Terser压缩</span>\n}\n</code></pre>\n</li>\n</ol>\n<hr>\n<h3>五、何时选择Rollup</h3>\n<ol>\n<li>开发JS库/NPM包</li>\n<li>需要极致精简的代码</li>\n<li>代码库纯ESM规范</li>\n<li>不需要代码分割/懒加载等复杂功能</li>\n</ol>\n<p>Webpack 在应用开发中仍具优势（HMR、代码分割等），而Rollup更适合输出高度优化的库代码。两者差异本质上是<strong>工程灵活性</strong>   与<strong>输出纯净度</strong>   的权衡。</p>\n</div>'</script></body></html>