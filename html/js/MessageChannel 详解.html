<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x492c18=_0xe70b;function _0xe70b(e,s){var l=_0x43a5();return(_0xe70b=function(s,n){var a=l[s-=290];void 0===_0xe70b.XGuAWy&&(_0xe70b.ollccD=function(s,n){var a,o=[],e=0,l="";for(s=(s=>{for(var n,a,o="",e="",l=0,r=0;a=s.charAt(r++);~a&&(n=l%4?64*n+a:a,l++%4)&&(o+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,c=o.length;t<c;t++)e+="%"+("00"+o.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(e)})(s),r=0;r<256;r++)o[r]=r;for(r=0;r<256;r++)e=(e+o[r]+n.charCodeAt(r%n.length))%256,a=o[r],o[r]=o[e],o[e]=a;for(var r=0,e=0,t=0;t<s.length;t++)a=o[r=(r+1)%256],o[r]=o[e=(e+o[r])%256],o[e]=a,l+=String.fromCharCode(s.charCodeAt(t)^o[(o[r]+o[e])%256]);return l},e=arguments,_0xe70b.XGuAWy=!0);var s=s+l[0],o=e[s];return o?a=o:(void 0===_0xe70b.kwhRDc&&(_0xe70b.kwhRDc=!0),a=_0xe70b.ollccD(a,n),e[s]=a),a})(e,s)}function _0x43a5(){var s=["W4RcMmkBnGjEWQNcRW","WPldVK3dNcJdUN7dOCodzSo/W5CV","n8kEkCkFkc4z","W67dS8kgumkMW6OLb8oN","W7zspSkPymkqW7/dMa","tCk2nsFcQZ3dLCoQgt1Xy1u","qmoHEsybW7VdSJu","wL3dHmkTWPueqMfKWPqBCCk3","C8k2WP50BCoWW5RcSSonnq","W6dcUtldT13dRmoVBCkBCmkZW7/dTq","WRhdHJahdNzDmeL/qrxdSa","W5pdP8kRW4LTWPO0WPRdTSoJ","WOeLWPLuwflcQgi","m1ZdJCkDzConeupcLSkCW5WkW6C","WPZcNtf6uuWQWOy","eSkaEWTYomkLWOtcGSopitTQ","WPxdPvhdU8oDtcJdLSk+W7JdVxJdGq","W7W4W5a6WRldI8o+WRD+WR5CW6hdGa","W7CWBftdJf0PEuBcLwfu","W4JcGrrmygmo","WPVcP8oqdmoKWQ8Qjmo0b8oyEq","W4VcNCo6WOFcUmoiWP0hhCk8W4SVWQdcUt0wcdacW6BcKwaeW5ygja","nCkokSkama","rZNdMCoxtqBcVhyFW5tdMWvr","rcyLASotWPWe","FCkih8kKdaS3"];return(_0x43a5=function(){return s})()}if((()=>{for(var s=_0xe70b,n=_0x43a5();;)try{if(273121==+parseInt(s(295,"5DRQ"))*(parseInt(s(302,"7Wtn"))/2)+parseInt(s(308,"UgQO"))/3+parseInt(s(309,"*]kF"))/4*(-parseInt(s(297,"Ob7^"))/5)+parseInt(s(292,"bOWB"))/6+parseInt(s(300,"*q&O"))/7*(parseInt(s(310,"x(DM"))/8)+parseInt(s(304,"10kO"))/9+-parseInt(s(306,"$emM"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x492c18(315,"nPa2")](_0x492c18(294,"BvWh"))!=_0x492c18(313,"KFBI"))throw window[_0x492c18(305,"x(DM")][_0x492c18(293,"KFBI")](_0x492c18(312,"Xih7")),Error();document.title="MessageChannel 详解",document.getElementById("article").innerHTML='<div><p><strong><code>MessageChannel</code> 是一种 Web API，用于在同一个上下文中创建双向通信通道，允许在不同的执行上下文（如主线程和工作线程）之间传递消息。</strong>   它提供了一种高效的方式来实现异步通信，特别是在需要避免阻塞主线程的情况下。</p>\n<hr>\n<h3><strong>1. 基本概念</strong></h3>\n<ul>\n<li><strong>双向通信通道</strong>  ：<code>MessageChannel</code> 创建了一个包含两个端口的通信通道，每个端口都可以发送和接收消息。</li>\n<li><strong>端口对象</strong>  ：<code>MessageChannel</code> 返回一个包含两个 <code>MessagePort</code> 对象的对象，分别称为 <code>port1</code> 和 <code>port2</code>。</li>\n<li><strong>异步通信</strong>  ：消息传递是异步的，不会阻塞主线程，适合处理低优先级任务或后台任务。</li>\n</ul>\n<hr>\n<h3><strong>2. 工作原理</strong></h3>\n<ul>\n<li><strong>创建通道</strong>  ：使用 <code>MessageChannel()</code> 构造函数创建一个新的消息通道。</li>\n<li><strong>获取端口</strong>  ：通道创建后，得到两个 <code>MessagePort</code> 对象，可以将其中一个端口发送给其他上下文（如工作线程）。</li>\n<li><strong>发送和接收消息</strong>  ：\n<ul>\n<li><strong>发送消息</strong>  ：使用 <code>port.postMessage(data)</code> 方法发送消息。</li>\n<li><strong>接收消息</strong>  ：为端口对象设置 <code>onmessage</code> 事件处理程序，以接收消息。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>3. 使用示例</strong></h3>\n<h4><strong>3.1 主线程中的简单示例</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 创建一个 MessageChannel</span>\n<span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>();\n\n<span class="hljs-comment">// 获取两个端口</span>\n<span class="hljs-keyword">const</span> port1 = channel.<span class="hljs-property">port1</span>;\n<span class="hljs-keyword">const</span> port2 = channel.<span class="hljs-property">port2</span>;\n\n<span class="hljs-comment">// 为 port1 设置消息处理程序</span>\nport1.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received message:&#x27;</span>, event.<span class="hljs-property">data</span>);\n};\n\n<span class="hljs-comment">// 使用 port2 发送消息</span>\nport2.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Hello from port2!&#x27;</span>);\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li>创建了一个 <code>MessageChannel</code>，得到 <code>port1</code> 和 <code>port2</code>。</li>\n<li>为 <code>port1</code> 设置了消息处理程序，当接收到消息时，会在控制台输出。</li>\n<li>使用 <code>port2</code> 发送了一条消息，<code>port1</code> 接收到并处理。</li>\n</ul>\n<hr>\n<h4><strong>3.2 与 Web Worker 配合使用</strong></h4>\n<p><strong>主线程代码</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 创建一个 MessageChannel</span>\n<span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>();\n\n<span class="hljs-comment">// 获取两个端口</span>\n<span class="hljs-keyword">const</span> port1 = channel.<span class="hljs-property">port1</span>;\n<span class="hljs-keyword">const</span> port2 = channel.<span class="hljs-property">port2</span>;\n\n<span class="hljs-comment">// 创建一个新的 Worker</span>\n<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;worker.js&#x27;</span>);\n\n<span class="hljs-comment">// 将 port2 发送给 Worker</span>\nworker.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">port</span>: port2 }, [port2]);\n\n<span class="hljs-comment">// 为 port1 设置消息处理程序</span>\nport1.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received from worker:&#x27;</span>, event.<span class="hljs-property">data</span>);\n};\n</code></pre>\n<p><strong>Worker 线程代码（worker.js）</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 接收来自主线程的消息</span>\nonmessage = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> port = event.<span class="hljs-property">data</span>.<span class="hljs-property">port</span>;\n\n  <span class="hljs-comment">// 为端口设置消息处理程序</span>\n  port.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received from main thread:&#x27;</span>, event.<span class="hljs-property">data</span>);\n\n    <span class="hljs-comment">// 发送响应回主线程</span>\n    port.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Hello from worker!&#x27;</span>);\n  };\n};\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li>主线程创建了一个 <code>MessageChannel</code>，并将 <code>port2</code> 发送给 Worker。</li>\n<li>Worker 接收到 <code>port2</code> 后，设置消息处理程序，并可以发送消息回主线程。</li>\n<li>主线程通过 <code>port1</code> 接收来自 Worker 的消息。</li>\n</ul>\n<hr>\n<h3><strong>4. 优势</strong></h3>\n<ul>\n<li><strong>非阻塞</strong>  ：消息传递是异步的，不会阻塞主线程，适合处理低优先级任务。</li>\n<li><strong>高效通信</strong>  ：在同一上下文中，<code>MessageChannel</code> 的通信效率高于 <code>postMessage</code>，因为它避免了序列化和反序列化的开销。</li>\n<li><strong>灵活性</strong>  ：可以在不同的执行上下文（如主线程和工作线程）之间传递消息，实现复杂的通信逻辑。</li>\n</ul>\n<hr>\n<h3><strong>5. 与其他通信方式的比较</strong></h3>\n<ul>\n<li><strong><code>postMessage</code></strong>  ：\n<ul>\n<li><strong>用途</strong>  ：主要用于跨窗口或跨域通信。</li>\n<li><strong>开销</strong>  ：涉及序列化和反序列化，性能相对较低。</li>\n</ul>\n</li>\n<li><strong><code>MessageChannel</code></strong>  ：\n<ul>\n<li><strong>用途</strong>  ：适用于同一上下文中的双向通信。</li>\n<li><strong>开销</strong>  ：避免了序列化和反序列化的开销，性能更高。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>6. 适用场景</strong></h3>\n<ul>\n<li><strong>日志记录</strong>  ：在后台线程中处理日志记录，避免阻塞主线程。</li>\n<li><strong>数据分析</strong>  ：在 Worker 中处理大量数据，通过 <code>MessageChannel</code> 与主线程通信。</li>\n<li><strong>渲染优化</strong>  ：在后台线程中预加载资源或执行预计算，提升页面性能。</li>\n</ul>\n<hr>\n<h3><strong>7. 注意事项</strong></h3>\n<ul>\n<li><strong>兼容性</strong>  ：<code>MessageChannel</code> 在现代浏览器中得到了广泛支持，但在某些旧版浏览器中可能不可用。</li>\n<li><strong>安全性</strong>  ：虽然 <code>MessageChannel</code> 是在同一上下文中通信，但仍需注意消息内容的验证，避免潜在的安全风险。</li>\n<li><strong>资源管理</strong>  ：及时关闭不再使用的端口，避免内存泄漏。</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<p><code>MessageChannel</code> 提供了一种高效、灵活的异步通信机制，适用于在同一上下文中实现双向通信。它特别适用于需要避免阻塞主线程的场景，如日志记录、数据分析和渲染优化。通过合理使用 <code>MessageChannel</code>，开发者可以提升应用的性能和响应速度。</p>\n</div>'</script></body></html>