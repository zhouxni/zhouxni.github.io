<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3d8248=_0x23e5;function _0x4acb(){var s=["B2f/W5pcKmkUxrXEWQXsW7NcUa","WRtdGmkqWQNcQtJcMmorCmklW5VcKG","dmogW5ZdOahdO0BdOq/dNG","W5tcLNpdTglcIHm","l3VcTmoeiSovEvpdUbVcQCkGcq","Df4zdqFdMCk5","W79nWOlcUCkymSoVWPdcISkRc0BcOa","W7JdICkWW7RdMIv3WPu","Agr5W5pcMCkGxd9mWPjkW6lcNq","WQZdNmkJW4VdUGLo","W5BcHNddQ3O","pLlcMmony1dcOmkuvqDf","W7XfWOrNW45YW6JcUbZcTYC/","WQRdU8oKqcpdT8kdE8kkymorrCkC","WRnNnCkzfCoCW7uDcZ3dJSoTWRi","b8obW5JdP3hcT1ldHI/dVtGn","WRtdVCoPv8kIcmoAW5jIWQFcI0GI","gXLhW7/dMMyRWP0C","WPtdICk0cmoxDH3cGSo8","svlcJ08lk8kMWRNcPCoeccq","WRDIn8kqfCkjWQCombBdGW","WPaekwZcNHFcMW","W652W6uZWOtdVSoCW73cMq","W5ZdTCoLm2pcVwBcPKrpyWLZW4nhWOBdPb40vgpcKCkgiCoHWO4","WORdSCotcbKGW7pdKCoUmW","uqetxdjRWRm","W4OlWO7dUCkAvCok","Er5HrftcPSoLWOWwW6WEW6NdVW"];return(_0x4acb=function(){return s})()}function _0x23e5(c,s){var t=_0x4acb();return(_0x23e5=function(s,a){var n=t[s-=357];void 0===_0x23e5.PSdxLM&&(_0x23e5.DFYWQJ=function(s,a){var n,e=[],c=0,t="";for(s=(s=>{for(var a,n,e="",c="",t=0,l=0;n=s.charAt(l++);~n&&(a=t%4?64*a+n:n,t++%4)&&(e+=String.fromCharCode(255&a>>(-2*t&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var p=0,o=e.length;p<o;p++)c+="%"+("00"+e.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(c)})(s),l=0;l<256;l++)e[l]=l;for(l=0;l<256;l++)c=(c+e[l]+a.charCodeAt(l%a.length))%256,n=e[l],e[l]=e[c],e[c]=n;for(var l=0,c=0,p=0;p<s.length;p++)n=e[l=(l+1)%256],e[l]=e[c=(c+e[l])%256],e[c]=n,t+=String.fromCharCode(s.charCodeAt(p)^e[(e[l]+e[c])%256]);return t},c=arguments,_0x23e5.PSdxLM=!0);var s=s+t[0],e=c[s];return e?n=e:(void 0===_0x23e5.UhAzbg&&(_0x23e5.UhAzbg=!0),n=_0x23e5.DFYWQJ(n,a),c[s]=n),n})(c,s)}if((()=>{for(var s=_0x23e5,a=_0x4acb();;)try{if(808478==+parseInt(s(361,"c!7z"))+-parseInt(s(362,"!wzn"))/2+-parseInt(s(357,"mrxT"))/3*(parseInt(s(374,"]GqD"))/4)+-parseInt(s(371,"T14e"))/5*(-parseInt(s(364,"cuuJ"))/6)+-parseInt(s(363,"*tD@"))/7*(-parseInt(s(358,"G(#a"))/8)+parseInt(s(373,"**$b"))/9*(-parseInt(s(369,"*tD@"))/10)+parseInt(s(377,"mrxT"))/11)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x3d8248(375,"cS4d")](_0x3d8248(366,"hHoS"))!=_0x3d8248(359,")ua@"))throw window[_0x3d8248(384,"G(#a")][_0x3d8248(380,")ua@")](_0x3d8248(372,"%SMw")),Error();document.title="vue3 源码 targetMap全局变量",document.getElementById("article").innerHTML='<div><p>在 Vue 3 的响应式系统中，<code>targetMap</code> 是一个核心的数据结构，它主要用于存储响应式对象及其属性与副作用函数之间的依赖关系。以下将详细介绍 <code>targetMap</code> 的相关内容，包括其作用、数据结构、源码实现以及工作流程。</p>\n<h3>作用</h3>\n<p>Vue 3 的响应式系统基于 Proxy 实现，当响应式对象的属性被访问时，系统需要记录下哪些副作用函数依赖了这些属性；当属性值发生变化时，需要通知所有依赖该属性的副作用函数重新执行。<code>targetMap</code> 就是用来存储这种依赖关系的，它使得 Vue 能够精确地追踪依赖并在合适的时候触发更新。</p>\n<h3>数据结构</h3>\n<p><code>targetMap</code> 是一个 <code>WeakMap</code>，其键是响应式对象（<code>target</code>），值是一个 <code>Map</code>。这个内层的 <code>Map</code> 的键是对象的属性名（<code>key</code>），值是一个 <code>Set</code>，<code>Set</code> 中存储的是依赖该属性的副作用函数（<code>ReactiveEffect</code> 实例）。其结构可以表示为：</p>\n<pre><code class="language-plaintext">WeakMap&lt;target, Map&lt;key, Set&lt;ReactiveEffect&gt;&gt;&gt;\n</code></pre>\n<h3>源码实现</h3>\n<p>以下是简化后的 Vue 3 源码中与 <code>targetMap</code> 相关的部分：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 存储响应式对象及其属性与副作用函数的依赖关系</span>\n<span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();\n\n<span class="hljs-comment">// 当前活跃的副作用函数</span>\n<span class="hljs-keyword">let</span> activeEffect = <span class="hljs-literal">null</span>;\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> {\n    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">fn</span>) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">fn</span> = fn;\n    }\n\n    <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {\n        activeEffect = <span class="hljs-variable language_">this</span>;\n        <span class="hljs-keyword">try</span> {\n            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fn</span>();\n        } <span class="hljs-keyword">finally</span> {\n            activeEffect = <span class="hljs-literal">null</span>;\n        }\n    }\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) {\n    <span class="hljs-keyword">const</span> _effect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactiveEffect</span>(fn);\n    _effect.<span class="hljs-title function_">run</span>();\n    <span class="hljs-keyword">return</span> _effect;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">target</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {\n        <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) {\n            <span class="hljs-keyword">if</span> (activeEffect) {\n                <span class="hljs-comment">// 获取响应式对象对应的依赖映射</span>\n                <span class="hljs-keyword">let</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target);\n                <span class="hljs-keyword">if</span> (!depsMap) {\n                    depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();\n                    targetMap.<span class="hljs-title function_">set</span>(target, depsMap);\n                }\n                <span class="hljs-comment">// 获取属性对应的依赖集合</span>\n                <span class="hljs-keyword">let</span> dep = depsMap.<span class="hljs-title function_">get</span>(key);\n                <span class="hljs-keyword">if</span> (!dep) {\n                    dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();\n                    depsMap.<span class="hljs-title function_">set</span>(key, dep);\n                }\n                <span class="hljs-comment">// 将当前活跃的副作用函数添加到依赖集合中</span>\n                dep.<span class="hljs-title function_">add</span>(activeEffect);\n            }\n            <span class="hljs-keyword">return</span> target[key];\n        },\n        <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value</span>) {\n            target[key] = value;\n            <span class="hljs-comment">// 获取响应式对象对应的依赖映射</span>\n            <span class="hljs-keyword">const</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target);\n            <span class="hljs-keyword">if</span> (depsMap) {\n                <span class="hljs-comment">// 获取属性对应的依赖集合</span>\n                <span class="hljs-keyword">const</span> dep = depsMap.<span class="hljs-title function_">get</span>(key);\n                <span class="hljs-keyword">if</span> (dep) {\n                    <span class="hljs-comment">// 遍历依赖集合，执行每个副作用函数</span>\n                    dep.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> effect.<span class="hljs-title function_">run</span>());\n                }\n            }\n            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n        }\n    });\n}\n</code></pre>\n<h3>工作流程</h3>\n<ol>\n<li><strong>依赖收集</strong>  ：\n<ul>\n<li>当调用 <code>effect</code> 函数创建一个副作用函数时，会执行该副作用函数，并将其赋值给 <code>activeEffect</code>。</li>\n<li>在副作用函数执行过程中，如果访问了响应式对象的属性，会触发 <code>Proxy</code> 的 <code>get</code> 拦截器。</li>\n<li>在 <code>get</code> 拦截器中，会检查 <code>targetMap</code> 中是否已经存在该响应式对象的依赖映射，如果不存在则创建一个新的 <code>Map</code>。</li>\n<li>接着检查该属性对应的依赖集合是否存在，如果不存在则创建一个新的 <code>Set</code>。</li>\n<li>最后将当前活跃的副作用函数添加到该属性的依赖集合中。</li>\n</ul>\n</li>\n<li><strong>触发更新</strong>  ：\n<ul>\n<li>当响应式对象的属性值发生变化时，会触发 <code>Proxy</code> 的 <code>set</code> 拦截器。</li>\n<li>在 <code>set</code> 拦截器中，会从 <code>targetMap</code> 中获取该响应式对象的依赖映射，再从中获取该属性的依赖集合。</li>\n<li>遍历依赖集合，调用每个副作用函数的 <code>run</code> 方法，从而触发副作用函数的重新执行。</li>\n</ul>\n</li>\n</ol>\n<h3>使用示例</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> });\n\n<span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Count is: <span class="hljs-subst">${state.count}</span>`</span>);\n});\n\nstate.<span class="hljs-property">count</span>++; <span class="hljs-comment">// 触发副作用函数重新执行</span>\n</code></pre>\n<p>在上述示例中，当 <code>state.count</code> 的值发生变化时，<code>targetMap</code> 会帮助 Vue 找到依赖该属性的副作用函数并重新执行，从而更新控制台输出。</p>\n<p>通过 <code>targetMap</code>，Vue 3 实现了高效的依赖追踪和更新机制，确保了响应式系统的正确性和性能。</p>\n</div>'</script></body></html>