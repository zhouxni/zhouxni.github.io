<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2bf6fc=_0x2fe0;function _0x16ed(){var n=["ztHuW5NdL8k/v8ob","FSkBnLRcNCklFGNdOSoYWR16","rIDSWRldTavoWRNdKCoOWPC","W592F8kaWQ1kitZcQXpdIMNdMa","e0/cO8kWWOddSvNdUWi","q8k8WO4rWQjfW5K","g0JcQmotW6FcIcVdVtX6d8kOWOi","wCkTWOOnWRaCWPpcVSo0dXZdHN7cOSoyWOvvpCk4p8kBWRZcVbqVW74","W5LYF8kcWQPejrhcGcpdUNBdJW","WRGyW7yiAvf2a1P9","o8o7o8oYcfBdNcSHabZdHW","W7JdM8krnh9rkCkzWPq","ymkuf8k9BYJcMCojW4xdRW","ecWtlCoYW71cWQ7cRHJcUq","oMCdWONcKmoGdmoRcsDcWPRcPq","sCkYbmkif2FdKhVcJmklhIxdSa","W5GZBYaM","sfvgW5tdTMiUW4rwW64","FdhdTSkTbSkiuKVcHmkUW73cI07cTa","W7RcSIZdM8kLcCoHWOf6W5GhW5iApW","tghcRwlcPSkcumoQzSoB","W58Yg8oFW40GyG","lcRdOSocfMGvbCo2","rv7cULrljdi","e2X3CmksW6zl","FdRcNSkgW59GW5JcVmohWRHKW5NcSa"];return(_0x16ed=function(){return n})()}function _0x2fe0(d,n){var r=_0x16ed();return(_0x2fe0=function(n,t){var e=r[n-=181];void 0===_0x2fe0.hpbDoR&&(_0x2fe0.LdhiIO=function(n,t){var e,o=[],d=0,r="";for(n=(n=>{for(var t,e,o="",d="",r=0,c=0;e=n.charAt(c++);~e&&(t=r%4?64*t+e:e,r++%4)&&(o+=String.fromCharCode(255&t>>(-2*r&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var a=0,s=o.length;a<s;a++)d+="%"+("00"+o.charCodeAt(a).toString(16)).slice(-2);return decodeURIComponent(d)})(n),c=0;c<256;c++)o[c]=c;for(c=0;c<256;c++)d=(d+o[c]+t.charCodeAt(c%t.length))%256,e=o[c],o[c]=o[d],o[d]=e;for(var c=0,d=0,a=0;a<n.length;a++)e=o[c=(c+1)%256],o[c]=o[d=(d+o[c])%256],o[d]=e,r+=String.fromCharCode(n.charCodeAt(a)^o[(o[c]+o[d])%256]);return r},d=arguments,_0x2fe0.hpbDoR=!0);var n=n+r[0],o=d[n];return o?e=o:(void 0===_0x2fe0.IMGtdj&&(_0x2fe0.IMGtdj=!0),e=_0x2fe0.LdhiIO(e,t),d[n]=e),e})(d,n)}if((()=>{for(var n=_0x2fe0,t=_0x16ed();;)try{if(728392==-parseInt(n(187,"O6KJ"))*(parseInt(n(190,"(&zO"))/2)+-parseInt(n(192,"Vhj("))/3+parseInt(n(203,"v^]C"))/4+parseInt(n(199,"Ui5o"))/5*(-parseInt(n(206,"LvQv"))/6)+parseInt(n(205,"FCJo"))/7*(parseInt(n(182,"JV!x"))/8)+-parseInt(n(184,"JV!x"))/9+parseInt(n(196,"lzJm"))/10)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x2bf6fc(201,"Q#qD")](_0x2bf6fc(200,"qcRN"))!=_0x2bf6fc(194,"]Fvj"))throw window[_0x2bf6fc(204,"Vhj(")][_0x2bf6fc(183,"Pk6r")](_0x2bf6fc(185,"Pk6r")),Error();document.title="babel 常用插件",document.getElementById("article").innerHTML='<div><p>Babel 的插件（Plugins）主要用于 <strong>语法转换</strong>   （将新语法转为旧语法）和 <strong>代码优化</strong>   。以下是一些常用的 Babel 插件，按功能分类：</p>\n<hr>\n<h3><strong>1. 语法转换插件（ES6+ → ES5）</strong></h3>\n<p>这些插件用于将现代 JavaScript 语法转换为兼容旧浏览器的代码：</p>\n<table>\n<thead>\n<tr>\n<th>插件名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>@babel/plugin-transform-arrow-functions</code></td>\n<td>转换箭头函数 <code>() =&gt; {}</code> → <code>function() {}</code></td>\n</tr>\n<tr>\n<td><code>@babel/plugin-transform-template-literals</code></td>\n<td>转换模板字符串 <code>`Hello ${name}`</code> → <code>&quot;Hello &quot; + name</code></td>\n</tr>\n<tr>\n<td><code>@babel/plugin-transform-destructuring</code></td>\n<td>转换解构赋值 <code>const { a } = obj</code> → <code>const a = obj.a</code></td>\n</tr>\n<tr>\n<td><code>@babel/plugin-transform-spread</code></td>\n<td>转换展开运算符 <code>[...arr]</code> → <code>arr.concat()</code></td>\n</tr>\n<tr>\n<td><code>@babel/plugin-transform-classes</code></td>\n<td>转换 <code>class</code> 语法 → ES5 构造函数</td>\n</tr>\n<tr>\n<td><code>@babel/plugin-transform-modules-commonjs</code></td>\n<td>将 ES6 <code>import/export</code> → CommonJS <code>require/module.exports</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>2. React 相关插件</strong></h3>\n<table>\n<thead>\n<tr>\n<th>插件名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>@babel/plugin-transform-react-jsx</code></td>\n<td>转换 JSX → <code>React.createElement()</code></td>\n</tr>\n<tr>\n<td><code>@babel/plugin-syntax-jsx</code></td>\n<td>允许解析 JSX（不转换，仅支持语法）</td>\n</tr>\n<tr>\n<td><code>@babel/plugin-transform-react-display-name</code></td>\n<td>自动添加 React 组件的 <code>displayName</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>3. 实验性语法支持</strong></h3>\n<p>Babel 允许使用尚未正式进入 JavaScript 标准的语法：</p>\n<table>\n<thead>\n<tr>\n<th>插件名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>@babel/plugin-proposal-decorators</code></td>\n<td>支持装饰器语法 <code>@decorator</code></td>\n</tr>\n<tr>\n<td><code>@babel/plugin-proposal-class-properties</code></td>\n<td>支持类属性 <code>class A { prop = 1 }</code></td>\n</tr>\n<tr>\n<td><code>@babel/plugin-proposal-nullish-coalescing-operator</code></td>\n<td>支持 <code>??</code> 运算符</td>\n</tr>\n<tr>\n<td><code>@babel/plugin-proposal-optional-chaining</code></td>\n<td>支持 <code>?.</code> 可选链</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>4. 代码优化 &amp; 工具类插件</strong></h3>\n<table>\n<thead>\n<tr>\n<th>插件名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>@babel/plugin-transform-runtime</code></td>\n<td>复用 Babel 的 helper 代码，减少打包体积</td>\n</tr>\n<tr>\n<td><code>babel-plugin-lodash</code></td>\n<td>按需引入 Lodash 函数（优化体积）</td>\n</tr>\n<tr>\n<td><code>babel-plugin-import</code></td>\n<td>按需引入组件库（如 Ant Design）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>5. 其他实用插件</strong></h3>\n<table>\n<thead>\n<tr>\n<th>插件名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>babel-plugin-styled-components</code></td>\n<td>优化 <code>styled-components</code> 的 SSR 和调试</td>\n</tr>\n<tr>\n<td><code>babel-plugin-module-resolver</code></td>\n<td>自定义模块路径别名（类似 Webpack 的 <code>resolve.alias</code>）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>如何配置插件？</strong></h3>\n<p>在 <code>babel.config.js</code> 或 <code>.babelrc</code> 中：</p>\n<pre><code class="language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">plugins</span>: [\n    <span class="hljs-string">&quot;@babel/plugin-transform-arrow-functions&quot;</span>, <span class="hljs-comment">// 转换箭头函数</span>\n    <span class="hljs-string">&quot;@babel/plugin-proposal-class-properties&quot;</span>, <span class="hljs-comment">// 支持类属性</span>\n  ],\n  <span class="hljs-attr">presets</span>: [<span class="hljs-string">&quot;@babel/preset-env&quot;</span>], <span class="hljs-comment">// 预设（包含一组插件）</span>\n};\n</code></pre>\n<hr>\n<h3><strong>插件 vs. 预设（Preset）</strong></h3>\n<ul>\n<li><strong>插件（Plugin）</strong>   ：单个功能（如转换箭头函数）。</li>\n<li><strong>预设（Preset）</strong>   ：一组插件的集合（如 <code>@babel/preset-env</code> 包含所有 ES6+ 转换插件）。</li>\n</ul>\n<p><strong>推荐</strong>   ：优先使用预设（如 <code>@babel/preset-env</code>），再按需添加插件。</p>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>语法转换</strong>   ：<code>@babel/plugin-transform-*</code></li>\n<li><strong>React</strong>   ：<code>@babel/plugin-transform-react-*</code></li>\n<li><strong>实验性语法</strong>   ：<code>@babel/plugin-proposal-*</code></li>\n<li><strong>优化</strong>   ：<code>@babel/plugin-transform-runtime</code></li>\n</ul>\n<p>新项目建议直接使用 <code>@babel/preset-env</code> + <code>@babel/preset-react</code>，再按需扩展插件。</p>\n</div>'</script></body></html>