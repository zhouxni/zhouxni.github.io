<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x454c72=_0x2fd3;function _0x2fd3(t,n){var e=_0x2631();return(_0x2fd3=function(n,s){var a=e[n-=280];void 0===_0x2fd3.GuknAI&&(_0x2fd3.ADRTKx=function(n,s){var a,l=[],t=0,e="";for(n=(n=>{for(var s,a,l="",t="",e=0,o=0;a=n.charAt(o++);~a&&(s=e%4?64*s+a:a,e++%4)&&(l+=String.fromCharCode(255&s>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,c=l.length;r<c;r++)t+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(t)})(n),o=0;o<256;o++)l[o]=o;for(o=0;o<256;o++)t=(t+l[o]+s.charCodeAt(o%s.length))%256,a=l[o],l[o]=l[t],l[t]=a;for(var o=0,t=0,r=0;r<n.length;r++)a=l[o=(o+1)%256],l[o]=l[t=(t+l[o])%256],l[t]=a,e+=String.fromCharCode(n.charCodeAt(r)^l[(l[o]+l[t])%256]);return e},t=arguments,_0x2fd3.GuknAI=!0);var n=n+e[0],l=t[n];return l?a=l:(void 0===_0x2fd3.Uebkls&&(_0x2fd3.Uebkls=!0),a=_0x2fd3.ADRTKx(a,s),t[n]=a),a})(t,n)}function _0x2631(){var n=["W6VcO8oaW5mkWQvr","WRJcJhZcTc9SW6/cOa","cmoAkSkXWRxcRmodWPRdLCoLW7xdJSoZ","WObUbKZdS8oas8k7WOb+WQVdOmo2hYfWW5pcNKzJWOFdNwfWnHe","W6hdTNDBrCoKAmklWOZdM8oQW7i","W4vBlhepWOtdG8kwgCkQtuC","W49uWRzyfIlcIuiN","W6/dG8kAgSkrWODqm3BdVmkuWRW4","i8ohcslcOCoKW5VdSq","W5ZcVWRcL8keW6De","smkvW6/cLKjDwKDuW5/dHSkWW6S","W5NdVW3cSSkQW61+W74","W7JcILKjrCopla","cCodWQNdIruidW","BZBdHmk3pq","cCoAWOPvWPxdQCkNrmoiWPpdLf8","j8kmcdFcPmkSW7XFWRZcOSkAbgG","lmkICCoDy8odWOq","W4GQi8k6WOpdTrKPW7ddUSo4W77dLa","bCoeWRhcLXaQWQq","dSowBCk7puldNIqYWOKhWRZdUG","smkwW6/cNuzAwK5IW5xdKSkFW7q","W4nwkxamWOJcVmkhgmkTqv7dMG","lhdcGCo3CLtdMSoAW67dPLFcI1a","WPLwkrtcOLafW4yAz8oAcW","W7lcGSkXpCkTWQiMWPNdK8k4cJr2"];return(_0x2631=function(){return n})()}if((()=>{for(var n=_0x2fd3,s=_0x2631();;)try{if(332259==+parseInt(n(284,"]Po1"))*(parseInt(n(296,"wm0P"))/2)+-parseInt(n(290,"##uV"))/3+-parseInt(n(282,"lr*i"))/4*(-parseInt(n(283,"(8eB"))/5)+-parseInt(n(288,"nWr]"))/6+-parseInt(n(298,"czLS"))/7+parseInt(n(280,"$LVo"))/8+-parseInt(n(302,"2mg5"))/9*(-parseInt(n(286,")iVU"))/10))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x454c72(303,"LN1[")](_0x454c72(297,"bJ&z"))!=_0x454c72(305,"nWr]"))throw window[_0x454c72(299,"d]Bc")][_0x454c72(304,")iVU")](_0x454c72(294,"M77m")),Error();document.title="微信小程序 EventChannel",document.getElementById("article").innerHTML='<div><p><strong>微信小程序中的 EventChannel 是一种用于页面间通信的机制，尤其适用于数据量较大时的场景。</strong></p>\n<h3><strong>EventChannel 的特点</strong></h3>\n<ol>\n<li><strong>高效通信</strong>  ：EventChannel 允许在两个页面之间建立一个直接的数据通道，避免了通过全局变量或本地存储等方式进行通信的性能开销。</li>\n<li><strong>双向通信</strong>  ：EventChannel 支持页面之间的双向通信，即父页面可以向子页面发送消息，子页面也可以向父页面发送消息。</li>\n<li><strong>事件驱动</strong>  ：通过 &quot;派发事件&quot; 及 &quot;注册这些事件的监听器&quot; 来实现基于事件的页面通信。</li>\n</ol>\n<h3><strong>EventChannel 的使用方法</strong></h3>\n<ol>\n<li><strong>创建数据通道</strong>  ：当一个页面通过 <code>wx.navigateTo</code> 方法打开另一个页面时，这两个页面之间就会建立一条 EventChannel 数据通道。</li>\n<li><strong>获取 EventChannel 对象</strong>  ：\n<ul>\n<li>被打开的页面可以通过 <code>this.getOpenerEventChannel()</code> 方法获得一个 EventChannel 对象。</li>\n<li>在 <code>wx.navigateTo</code> 的 <code>success</code> 回调中也包含一个 EventChannel 对象。</li>\n</ul>\n</li>\n<li><strong>发送和监听事件</strong>  ：\n<ul>\n<li>使用 <code>emit</code> 方法发送事件，并可以携带数据。</li>\n<li>使用 <code>on</code> 方法监听事件，并在事件触发时执行相应的处理函数。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>示例代码</strong></h3>\n<p><strong>父页面（A 页面）</strong>  ：</p>\n<pre><code class="language-javascript">wx.<span class="hljs-title function_">navigateTo</span>({\n  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/pages/child/child&#x27;</span>,\n  <span class="hljs-attr">events</span>: {\n    <span class="hljs-comment">// 监听子页面发送过来的事件</span>\n    <span class="hljs-attr">messageFromChild</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;收到子页面的消息:&#x27;</span>, data);\n    }\n  },\n  <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) {\n    <span class="hljs-comment">// 保存 EventChannel 对象</span>\n    <span class="hljs-keyword">var</span> channel = res.<span class="hljs-property">eventChannel</span>;\n    <span class="hljs-comment">// 向子页面发送事件和数据</span>\n    channel.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;messageFromParent&#x27;</span>, { <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;这是父页面的消息&#x27;</span> });\n  }\n});\n</code></pre>\n<p><strong>子页面（B 页面）</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-title class_">Page</span>({\n  <span class="hljs-attr">onLoad</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) {\n    <span class="hljs-keyword">const</span> eventChannel = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getOpenerEventChannel</span>();\n    <span class="hljs-comment">// 向父页面发送事件和数据</span>\n    eventChannel.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;messageFromChild&#x27;</span>, { <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;这是子页面的消息&#x27;</span> });\n    <span class="hljs-comment">// 监听父页面发送过来的事件</span>\n    eventChannel.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;messageFromParent&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;收到父页面的消息:&#x27;</span>, data);\n    });\n  }\n});\n</code></pre>\n<h3><strong>EventChannel 的优势</strong></h3>\n<ul>\n<li><strong>支持复杂数据类型</strong>  ：可以直接传递对象、数组等复杂数据类型，无需担心 URL 长度限制或特殊字符的编码问题。</li>\n<li><strong>代码简洁</strong>  ：通过事件机制实现页面通信，代码逻辑清晰，易于维护。</li>\n<li><strong>实时通信</strong>  ：适合需要频繁交互或实时更新数据的场景。</li>\n</ul>\n<h3><strong>注意事项</strong></h3>\n<ul>\n<li><strong>事件名称唯一性</strong>  ：为了避免事件冲突，应确保事件名称在页面间是唯一的。</li>\n<li><strong>生命周期管理</strong>  ：EventChannel 的生命周期与页面绑定，当页面销毁时，EventChannel 也会自动关闭。因此，无需手动管理其生命周期。</li>\n<li><strong>性能优化</strong>  ：虽然 EventChannel 适用于大数据量传输，但在实际使用中仍需注意性能优化，避免频繁创建和销毁 EventChannel 对象。</li>\n</ul>\n</div>'</script></body></html>