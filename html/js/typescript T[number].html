<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1c05(){var n=["WPqYlmkIhW","ssjgC3fbC23dRWCzp8oMgKZcMSkPE8kPWQBcS8kDc07dMJq","iwNcNmoocX3cVmowWPmvA3pdOSoY","A03cI8kDWQZdK8ksaaddVCoBWOxcVq","W4vUW6r0W5FdMCobaW","W5/dJmoKCaNdM8owW7ZdQG8VWPC","W6FcGCkjx8kVCdxdLSksW5yAhcG","zGtcIq8VW7pcTmkD","x24LlXJcOrlcJmkUimkQWOqr","D0RdRmk+mmkoW5q","W6pcHSkixCkKCddcHSkKW642ctRdRa","WOesW5yhbK7dJSoL","utRdH8kyqf3dGSkbWQ0","WOddRfTCscDoW7HGp8kvsq","W6z/fNddTCoNWRPHsNhcHCos","W53dJCoUCqNdKSkgW6pdTY8WWO3dHa","WOmMW7ZcJmonW5/dVCkPgmoZamoWWOm","vglcV8kGpmoTWPVcIWBcKCkJW5i","pXddH8oGW6RcJSoh","pSohr8k7iHXnW6CBv2pcTGW","iwdcLSoibbVcU8kGWRikDwldJa","c8oBW7hdHcKtzd7cGmkJW6DXWOu"];return(_0x1c05=function(){return n})()}var _0x43f52b=_0x2c08;function _0x2c08(a,n){var c=_0x1c05();return(_0x2c08=function(n,s){var e=c[n-=349];void 0===_0x2c08.hyDKBD&&(_0x2c08.ANMhvj=function(n,s){var e,l=[],a=0,c="";for(n=(n=>{for(var s,e,l="",a="",c=0,o=0;e=n.charAt(o++);~e&&(s=c%4?64*s+e:e,c++%4)&&(l+=String.fromCharCode(255&s>>(-2*c&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var r=0,t=l.length;r<t;r++)a+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(a)})(n),o=0;o<256;o++)l[o]=o;for(o=0;o<256;o++)a=(a+l[o]+s.charCodeAt(o%s.length))%256,e=l[o],l[o]=l[a],l[a]=e;for(var o=0,a=0,r=0;r<n.length;r++)e=l[o=(o+1)%256],l[o]=l[a=(a+l[o])%256],l[a]=e,c+=String.fromCharCode(n.charCodeAt(r)^l[(l[o]+l[a])%256]);return c},a=arguments,_0x2c08.hyDKBD=!0);var n=n+c[0],l=a[n];return l?e=l:(void 0===_0x2c08.EInZEw&&(_0x2c08.EInZEw=!0),e=_0x2c08.ANMhvj(e,s),a[n]=e),e})(a,n)}if((()=>{for(var n=_0x2c08,s=_0x1c05();;)try{if(981735==-parseInt(n(357,"QRcU"))+parseInt(n(355,"W3e^"))/2+parseInt(n(369,"(8fY"))/3+parseInt(n(351,"gp28"))/4+-parseInt(n(368,"SY!*"))/5+parseInt(n(362,"#ldr"))/6+parseInt(n(356,"rJuI"))/7*(-parseInt(n(349,"uWJi"))/8))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x43f52b(370,"W3e^")](_0x43f52b(364,"tdVr"))!=_0x43f52b(352,"9qW^"))throw window[_0x43f52b(363,"hy#F")][_0x43f52b(361,"P88E")](_0x43f52b(353,"iJxu")),Error();document.title="typescript T[number]",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>T[number]</code> 是一种索引类型查询，用于获取数组或元组类型 <code>T</code> 中所有元素的联合类型。这在处理数组或元组时非常有用，尤其是在类型编程中，当你需要操作或转换数组/元组中的元素类型时。</p>\n<h3>解释</h3>\n<ul>\n<li><strong><code>T[number]</code></strong>  :\n<ul>\n<li>假设 <code>T</code> 是一个数组或元组类型，例如 <code>string[]</code> 或 <code>[string, number, boolean]</code>。</li>\n<li><code>T[number]</code> 将返回 <code>T</code> 中所有元素的联合类型。</li>\n<li>对于 <code>string[]</code>，<code>T[number]</code> 是 <code>string</code>。</li>\n<li>对于 <code>[string, number, boolean]</code>，<code>T[number]</code> 是 <code>string | number | boolean</code>。</li>\n</ul>\n</li>\n</ul>\n<h3>示例</h3>\n<pre><code class="language-typescript"><span class="hljs-comment">// 示例 1: 数组类型</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">StringArray</span> = <span class="hljs-built_in">string</span>[];\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">StringArrayElement</span> = <span class="hljs-title class_">StringArray</span>[<span class="hljs-built_in">number</span>]; <span class="hljs-comment">// StringArrayElement 是 string</span>\n\n<span class="hljs-comment">// 示例 2: 元组类型</span>\n<span class="hljs-keyword">const</span> tuple = [<span class="hljs-string">&quot;tesla&quot;</span>, <span class="hljs-number">42</span>, <span class="hljs-literal">true</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// 使用 as const 将元组变为只读元组</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Tuple</span> = <span class="hljs-keyword">typeof</span> tuple;\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">TupleElement</span> = <span class="hljs-title class_">Tuple</span>[<span class="hljs-built_in">number</span>]; <span class="hljs-comment">// TupleElement 是 &quot;tesla&quot; | 42 | true</span>\n\n<span class="hljs-comment">// 示例 3: 在泛型中使用</span>\n<span class="hljs-keyword">function</span> getFirstElement&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[]&gt;(<span class="hljs-attr">arr</span>: T): T[<span class="hljs-built_in">number</span>] | <span class="hljs-literal">undefined</span> {\n  <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 返回数组的第一个元素，其类型是 T[number] 或 undefined（如果数组为空）</span>\n}\n\n<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];\n<span class="hljs-keyword">const</span> first = <span class="hljs-title function_">getFirstElement</span>(arr); <span class="hljs-comment">// first 的类型是 number | undefined</span>\n</code></pre>\n<h3>使用场景</h3>\n<ol>\n<li><strong>类型约束</strong>  ：\n<ul>\n<li>当你需要确保某个函数的参数或返回值与数组/元组中的元素类型一致时，可以使用 <code>T[number]</code>。</li>\n</ul>\n</li>\n<li><strong>类型映射</strong>  ：\n<ul>\n<li>在类型编程中，经常需要将数组/元组中的元素类型映射到其他类型。<code>T[number]</code> 可以帮助你获取元素类型，以便进行进一步的类型操作。</li>\n</ul>\n</li>\n<li><strong>泛型编程</strong>  ：\n<ul>\n<li>在泛型函数中，使用 <code>T[number]</code> 可以使函数更加灵活，能够处理不同类型的数组/元组。</li>\n</ul>\n</li>\n</ol>\n<h3>注意事项</h3>\n<ul>\n<li><strong><code>as const</code></strong>  :\n<ul>\n<li>当处理元组时，通常使用 <code>as const</code> 将元组断言为只读元组，这样元组中的每个元素都会被视为字面量类型，而不是宽泛的类型（如 <code>string</code> 或 <code>number</code>）。</li>\n</ul>\n</li>\n<li><strong>数组与元组的区别</strong>  :\n<ul>\n<li>数组通常表示同类型元素的集合（如 <code>string[]</code>），而元组表示固定数量和类型的元素的集合（如 <code>[string, number]</code>）。</li>\n<li><code>T[number]</code> 对于数组和元组都适用，但结果可能不同（数组通常返回单一类型，元组返回联合类型）。</li>\n</ul>\n</li>\n<li><strong>空数组/元组</strong>  :\n<ul>\n<li>对于空数组或元组类型（如 <code>never[]</code> 或 <code>[]</code>），<code>T[number]</code> 的结果是 <code>never</code>，因为没有元素可以形成联合类型。</li>\n</ul>\n</li>\n</ul>\n</div>'</script></body></html>