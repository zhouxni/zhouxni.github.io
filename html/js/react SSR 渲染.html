<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x38b108=_0x131a;function _0x131a(l,s){var p=_0x2d1e();return(_0x131a=function(s,n){var a=p[s-=472];void 0===_0x131a.MERuDS&&(_0x131a.hYtQkk=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=t.length;c<r;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,c=0;c<s.length;c++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(c)^t[(t[e]+t[l])%256]);return p},l=arguments,_0x131a.MERuDS=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x131a.BahWYC&&(_0x131a.BahWYC=!0),a=_0x131a.hYtQkk(a,n),l[s]=a),a})(l,s)}function _0x2d1e(){var s=["WOySWPWijmo9W7C","WQiIfCkYAmoLwH3dSsVdOGKd","AvRdNKBcT8oWW4xcIYxcHa","ouuzvSoSW5FdTSo8WPVdQSoXWRtcKW","gb/dKSkGW4Pfm8kiWP8","WOVcR8oxA8ocWQtdNCoCwCkJqa","dhRcMCo8otS4W58","xmoyW4n/wZv7W5xdP8klAMBcJqhcPCk2FSkiWO4hAY5RW5hdHa4","WRdcHCkDemoLCfhdMbnqwSkMW6u","pKSDmCkBWO3cImo3WPq","ymkEoY9YW6WKW7BcMCofWOy","W54VydVdTCkNWQdcHW","WRpcKwxcGCo4W6hdQ8kEWP/dUCo2","W6TIq0/cOHRcVmkV","qNRdN8ooCCkxWPpdO8o+zwxcHMu","W6hcM3ldMbDfWOm1W60W","WQddPCkIg1hcTsNcTCoVWRRdTXpcSaW","WRy5k3CJq37cNmouumk2W4JcOa","W59RW4HgBgztW6OiW5RdRgDTW6a","yghdGCk0WRCLFSkJA1VdSMGa","W7ldGmozvmkO","W4H2ASoRtCo1W44","WPKWru3cMIpcOmk7yG","W6TKerVdMZhcVCkTsv0d"];return(_0x2d1e=function(){return s})()}if((()=>{for(var s=_0x131a,n=_0x2d1e();;)try{if(694805==+parseInt(s(473,"6kKw"))*(parseInt(s(494,"YXyO"))/2)+-parseInt(s(485,"KtCM"))/3+-parseInt(s(483,"6kKw"))/4*(-parseInt(s(493,"JsDW"))/5)+-parseInt(s(479,"Ak9)"))/6+-parseInt(s(477,"8lk["))/7+parseInt(s(486,"y[d9"))/8+parseInt(s(478,"drp("))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x38b108(481,"5MUP")](_0x38b108(482,"6kKw"))!=_0x38b108(480,")Ink"))throw window[_0x38b108(495,"$@Q$")][_0x38b108(484,"f]2h")](_0x38b108(491,"ZO9L")),Error();document.title="react SSR 渲染",document.getElementById("article").innerHTML='<div><p>React SSR (Server-Side Rendering) 渲染详解</p>\n<p>React SSR 是在服务器端将 React 组件渲染为 HTML 字符串，然后发送给客户端的技术。与客户端渲染(CSR)相比，SSR 提供了更好的首屏性能和 SEO 支持。</p>\n<p>一、React SSR 核心优势</p>\n<ol>\n<li>SEO 友好：搜索引擎可以直接抓取完整的 HTML 内容</li>\n<li>更快的首屏渲染：用户无需等待所有 JavaScript 加载就能看到内容</li>\n<li>更好的用户体验：特别适合慢速网络环境</li>\n<li>社交分享优化：社交媒体爬虫能正确获取页面元信息</li>\n</ol>\n<p>二、React SSR 工作原理</p>\n<pre><code>客户端请求 → Node.js 服务器 → 执行 React 应用 → renderToString() → 发送 HTML → 客户端&quot;注水&quot;(Hydration)\n</code></pre>\n<p>三、React SSR 实现方案</p>\n<ol>\n<li>手动配置基础 SSR</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// server.js</span>\n<span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n<span class="hljs-keyword">import</span> { renderToString } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/server&#x27;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span>;\n\n<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();\n\napp.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> html = <span class="hljs-title function_">renderToString</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);\n  \n  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n      &lt;head&gt;\n        &lt;title&gt;React SSR&lt;/title&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;div id=&quot;root&quot;&gt;<span class="hljs-subst">${html}</span>&lt;/div&gt;\n        &lt;script src=&quot;/client.bundle.js&quot;&gt;&lt;/script&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  `</span>);\n});\n\napp.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);\n</code></pre>\n<ol start="2">\n<li>使用 Next.js (推荐方案)</li>\n</ol>\n<p>Next.js 提供了开箱即用的 SSR 支持，简化了配置过程。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// pages/index.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">HomePage</span>(<span class="hljs-params">{ data }</span>) {\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{data}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getServerSideProps</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>);\n  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();\n\n  <span class="hljs-keyword">return</span> { <span class="hljs-attr">props</span>: { data } };\n}\n</code></pre>\n<p>四、React SSR 关键概念</p>\n<ol>\n<li>数据获取方法</li>\n</ol>\n<ul>\n<li>\n<p><code>getServerSideProps</code> (Next.js 特有)：在每次请求时运行</p>\n</li>\n<li>\n<p><code>getStaticProps</code> (Next.js 特有)：在构建时运行</p>\n</li>\n<li>\n<p>手动数据获取：在组件渲染前获取数据</p>\n</li>\n</ul>\n<ol start="2">\n<li>客户端注水(Hydration)</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// client.js</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n<span class="hljs-keyword">import</span> { hydrateRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span>;\n\n<span class="hljs-title function_">hydrateRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>), <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);\n</code></pre>\n<ol start="3">\n<li>路由处理</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// 使用 React Router 的 SSR 配置</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">StaticRouter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom/server&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params">{ serverLocation }</span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">StaticRouter</span> <span class="hljs-attr">location</span>=<span class="hljs-string">{serverLocation}</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Home</span> /&gt;</span>} /&gt;\n      <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">StaticRouter</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p>五、React SSR 常见问题解决方案</p>\n<ol>\n<li>窗口(Window)对象问题</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// 检查是否在浏览器环境</span>\n<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) {\n  <span class="hljs-comment">// 使用 window 对象</span>\n}\n</code></pre>\n<ol start="2">\n<li>样式处理</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// 使用 CSS-in-JS 库的 SSR 支持</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ServerStyleSheet</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;styled-components&#x27;</span>;\n\n<span class="hljs-keyword">const</span> sheet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerStyleSheet</span>();\n<span class="hljs-keyword">const</span> html = <span class="hljs-title function_">renderToString</span>(sheet.<span class="hljs-title function_">collectStyles</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>));\n<span class="hljs-keyword">const</span> styleTags = sheet.<span class="hljs-title function_">getStyleTags</span>();\n</code></pre>\n<ol start="3">\n<li>状态管理(Redux)的 SSR</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// 创建每个请求独立的 store 实例</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">createStore</span> = (<span class="hljs-params">preloadedState</span>) =&gt; {\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">configureStore</span>({\n    <span class="hljs-attr">reducer</span>: rootReducer,\n    preloadedState\n  });\n};\n\n<span class="hljs-comment">// 服务器端</span>\n<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>();\n<span class="hljs-keyword">const</span> html = <span class="hljs-title function_">renderToString</span>(\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>\n);\n<span class="hljs-keyword">const</span> preloadedState = store.<span class="hljs-title function_">getState</span>();\n</code></pre>\n<p>六、React SSR 性能优化</p>\n<ol>\n<li>组件缓存：使用 <code>react-ssr-prepass</code> 预取数据</li>\n<li>流式渲染：使用 <code>renderToNodeStream</code> 替代 <code>renderToString</code></li>\n<li>代码分割：配合 <code>React.lazy</code> 和 <code>Suspense</code> 使用</li>\n<li>静态生成：对不常变化的内容使用静态生成(SSG)</li>\n</ol>\n<p>七、React SSR vs CSR vs SSG</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>SSR</th>\n<th>CSR</th>\n<th>SSG (Static Site Generation)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>渲染时机</td>\n<td>每次请求时</td>\n<td>客户端</td>\n<td>构建时</td>\n</tr>\n<tr>\n<td>SEO</td>\n<td>优秀</td>\n<td>需要额外处理</td>\n<td>优秀</td>\n</tr>\n<tr>\n<td>首屏性能</td>\n<td>快</td>\n<td>慢</td>\n<td>极快</td>\n</tr>\n<tr>\n<td>数据实时性</td>\n<td>高</td>\n<td>高</td>\n<td>低</td>\n</tr>\n<tr>\n<td>服务器负载</td>\n<td>高</td>\n<td>低</td>\n<td>低</td>\n</tr>\n</tbody>\n</table>\n<p>八、React SSR 最佳实践</p>\n<ol>\n<li>按需使用 SSR：仅为需要 SEO 或快速首屏的页面启用 SSR</li>\n<li>渐进增强：先提供静态内容，再增强为动态应用</li>\n<li>避免全局状态：每个请求创建新的 Redux store 等实例</li>\n<li>错误边界：使用 React 错误边界处理渲染错误</li>\n<li>性能监控：监控 SSR 的 TTFB (Time To First Byte)</li>\n</ol>\n<p>九、完整示例项目结构</p>\n<pre><code>project/\n├── client/\n│   ├── index.js       # 客户端入口\n│   └── App.js         # 根组件\n├── server/\n│   ├── index.js       # 服务器入口\n│   └── render.js      # SSR 渲染逻辑\n├── shared/\n│   ├── components/    # 通用组件\n│   └── routes.js      # 通用路由配置\n└── package.json\n</code></pre>\n<p>React SSR 虽然增加了开发复杂度，但能为特定场景带来显著优势。根据项目需求选择合适的渲染策略，可以平衡开发效率与用户体验。</p>\n</div>'</script></body></html>