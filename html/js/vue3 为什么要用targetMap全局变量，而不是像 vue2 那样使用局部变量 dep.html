<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3cc9(){var n=["w8kaW6P5WO9/W6G+WQ49W5vLkmkdWPmvW7xdH8oFiIFcQCouWQddJJG","k3XNamoCcCkSWR0Ya8k2k2u","b3VcVSkIWRKbWPS2WRi","schdSmksWPNdHWVcLSkYWO7cSCoN","WO1kWO7dHhZdTteY","kCkxcCoJW4NcJHdcUCoMDSoMWO49","W7OWdCoqWQNcM8okW4q6","WRdcRf3cGcXdxa","WOJcPmorjSoaaCoR","WRmIESoFWR1yB1bnhuNcSSkM","W4BdKNdcKGtcJZSetw7cR8kUWRO","lxxdGmoBDSo9WOBdSCkQldi1","k3PIdSouc8oSWR4QfSktpa","W5fcrdNdIIWlvq","f3/dOxtdOLxcMLbiWPhdGczL","ccldMYWoWPqyW74","W782bmktWO3cTSoTW4aGoG","Ef7cIXhdN8klASkDWRnUWOfHyG","WO0FWPBdLKxdIZW","W7PAz8o9WQL1WPZcNxO","kCkrDmk4WPtdL0lcVW","W5JdTSkfW5tcIW","WOpcQK7cIt5tCH3dUq","ECoFW4GviJZcJt/dTmonW5NdGq","W4BdMxBdH1ZdSxantq","W7OYaSkqW7RdHCk8WOC6m8kvv8kGda","W7hcVKmtW4RdLh1AW4xdPW","W4JcPs7cJuinka","W4ZcKCoybmoZWRBcOSo6WOdcUCo4WOidW6K","ex/cGaFcPYVdOfa"];return(_0x3cc9=function(){return n})()}var _0x1d4079=_0x5a5e;function _0x5a5e(t,n){var c=_0x3cc9();return(_0x5a5e=function(n,s){var e=c[n-=183];void 0===_0x5a5e.ungMgy&&(_0x5a5e.kQvpjh=function(n,s){var e,a=[],t=0,c="";for(n=(n=>{for(var s,e,a="",t="",c=0,o=0;e=n.charAt(o++);~e&&(s=c%4?64*s+e:e,c++%4)&&(a+=String.fromCharCode(255&s>>(-2*c&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var l=0,d=a.length;l<d;l++)t+="%"+("00"+a.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(t)})(n),o=0;o<256;o++)a[o]=o;for(o=0;o<256;o++)t=(t+a[o]+s.charCodeAt(o%s.length))%256,e=a[o],a[o]=a[t],a[t]=e;for(var o=0,t=0,l=0;l<n.length;l++)e=a[o=(o+1)%256],a[o]=a[t=(t+a[o])%256],a[t]=e,c+=String.fromCharCode(n.charCodeAt(l)^a[(a[o]+a[t])%256]);return c},t=arguments,_0x5a5e.ungMgy=!0);var n=n+c[0],a=t[n];return a?e=a:(void 0===_0x5a5e.BrOSOl&&(_0x5a5e.BrOSOl=!0),e=_0x5a5e.kQvpjh(e,s),t[n]=e),e})(t,n)}if((()=>{for(var n=_0x5a5e,s=_0x3cc9();;)try{if(425561==+parseInt(n(189,"EX3$"))*(-parseInt(n(197,"uyAu"))/2)+-parseInt(n(204,"b$4q"))/3+-parseInt(n(187,"#%TF"))/4*(-parseInt(n(193,"yHNf"))/5)+-parseInt(n(212,"tJjB"))/6*(parseInt(n(191,"BZCN"))/7)+-parseInt(n(207,"BZCN"))/8*(parseInt(n(206,")5B^"))/9)+parseInt(n(185,"b$4q"))/10*(parseInt(n(192,"Oa9*"))/11)+parseInt(n(198,"EX3$"))/12)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x1d4079(200,"EymX")](_0x1d4079(195,"tBXk"))!=_0x1d4079(194,"Debw"))throw window[_0x1d4079(188,"KEC3")][_0x1d4079(210,"tBXk")](_0x1d4079(203,"km6z")),Error();document.title="vue3 为什么要用targetMap全局变量，而不是像 vue2 那样使用局部变量 dep",document.getElementById("article").innerHTML='<div><p>在 Vue 2 和 Vue 3 的响应式系统中，依赖管理（Dependency Tracking）的设计有显著不同。Vue 2 使用<strong>局部变量 <code>dep</code></strong>  （每个属性一个 <code>Dep</code> 实例），而 Vue 3 改用<strong>全局 <code>targetMap</code></strong>  （<code>WeakMap</code> 结构）。这种变化的根本原因是为了解决 Vue 2 响应式系统的局限性，并适应 Vue 3 的 Proxy-based 响应式设计。以下是详细对比和原因分析：</p>\n<hr>\n<h2>1. <strong>Vue 2 的依赖管理：局部 <code>dep</code></strong></h2>\n<p>在 Vue 2 中，每个响应式对象的属性都会关联一个独立的 <code>Dep</code>（Dependency）实例，用于收集依赖（Watcher）。<br>\n<strong>实现方式</strong>  ：</p>\n<ul>\n<li>通过 <code>Object.defineProperty</code> 劫持属性，在 <code>getter</code> 中收集依赖（<code>dep.depend()</code>），在 <code>setter</code> 中触发更新（<code>dep.notify()</code>）。</li>\n<li><strong>每个属性一个 <code>dep</code></strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = [] <span class="hljs-comment">// 存储 Watcher 实例</span>\n  }\n  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) { <span class="hljs-comment">/* 收集 Watcher */</span> }\n  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) { <span class="hljs-comment">/* 触发更新 */</span> }\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">obj, key</span>) {\n  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>() <span class="hljs-comment">// 每个属性都有自己的 dep</span>\n  <span class="hljs-keyword">let</span> val = obj[key]\n  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, {\n    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) { <span class="hljs-comment">// 当前 Watcher（全局变量）</span>\n        dep.<span class="hljs-title function_">depend</span>() <span class="hljs-comment">// 将 Watcher 添加到 dep.subs</span>\n      }\n      <span class="hljs-keyword">return</span> val\n    },\n    <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) {\n      val = newVal\n      dep.<span class="hljs-title function_">notify</span>() <span class="hljs-comment">// 通知所有 Watcher 更新</span>\n    }\n  })\n}\n</code></pre>\n</li>\n</ul>\n<h3><strong>Vue 2 局部 <code>dep</code> 的问题</strong></h3>\n<ol>\n<li><strong>嵌套对象需递归劫持</strong>  ：\n<ul>\n<li>对于嵌套对象（如 <code>obj.a.b</code>），Vue 2 需要递归调用 <code>defineReactive</code>，为每一层属性创建 <code>dep</code>，性能较差。</li>\n</ul>\n</li>\n<li><strong>动态属性无法追踪</strong>  ：\n<ul>\n<li>通过 <code>obj.newKey = value</code> 添加的属性无法自动响应（需手动调用 <code>Vue.set</code>）。</li>\n</ul>\n</li>\n<li><strong>内存开销较大</strong>  ：\n<ul>\n<li>每个属性都需创建一个 <code>Dep</code> 实例，对于大型对象（如数组、深层次结构）内存占用高。</li>\n</ul>\n</li>\n<li><strong>依赖关系分散</strong>  ：\n<ul>\n<li>依赖存储在各自属性的 <code>dep</code> 中，缺乏统一管理，调试和维护复杂。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2>2. <strong>Vue 3 的依赖管理：全局 <code>targetMap</code></strong></h2>\n<p>Vue 3 使用 Proxy 重构响应式系统，依赖关系通过全局的 <code>targetMap</code>（<code>WeakMap</code>）集中管理。<br>\n<strong>实现方式</strong>  ：</p>\n<ul>\n<li><code>targetMap</code> 的结构：<pre><code class="language-typescript"><span class="hljs-attr">targetMap</span>: <span class="hljs-title class_">WeakMap</span>&lt;target, <span class="hljs-title class_">Map</span>&lt;key, <span class="hljs-title class_">Set</span>&lt;effect&gt;&gt;&gt;\n</code></pre>\n<ul>\n<li><code>target</code>: 响应式对象（Proxy 代理的对象）。</li>\n<li><code>key</code>: 对象的属性名。</li>\n<li><code>effect</code>: 副作用函数（如组件的渲染函数、<code>watch</code>、<code>computed</code>）。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>核心代码逻辑</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>() <span class="hljs-comment">// 全局依赖存储</span>\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">target, key</span>) {\n  <span class="hljs-keyword">let</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target)\n  <span class="hljs-keyword">if</span> (!depsMap) {\n    targetMap.<span class="hljs-title function_">set</span>(target, (depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()))\n  }\n  <span class="hljs-keyword">let</span> dep = depsMap.<span class="hljs-title function_">get</span>(key)\n  <span class="hljs-keyword">if</span> (!dep) {\n    depsMap.<span class="hljs-title function_">set</span>(key, (dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()))\n  }\n  dep.<span class="hljs-title function_">add</span>(activeEffect) <span class="hljs-comment">// 当前运行的 effect</span>\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key</span>) {\n  <span class="hljs-keyword">const</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target)\n  <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span>\n  <span class="hljs-keyword">const</span> effects = depsMap.<span class="hljs-title function_">get</span>(key)\n  effects?.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> <span class="hljs-title function_">effect</span>())\n}\n</code></pre>\n<h3><strong>Vue 3 全局 <code>targetMap</code> 的优势</strong></h3>\n<ol>\n<li><strong>精准依赖追踪</strong>  ：\n<ul>\n<li>Proxy 可以拦截所有属性的访问（<code>get</code>）和修改（<code>set</code>），无需递归劫持，动态属性（如 <code>obj.newKey</code>）也能自动追踪。</li>\n</ul>\n</li>\n<li><strong>内存高效</strong>  ：\n<ul>\n<li><code>WeakMap</code> 对 <code>target</code> 是弱引用，当对象销毁时，其依赖关系会自动被垃圾回收，避免内存泄漏。</li>\n<li>依赖按需存储（只有被访问的属性才会创建 <code>Set&lt;effect&gt;</code>），减少无用内存占用。</li>\n</ul>\n</li>\n<li><strong>统一管理依赖</strong>  ：\n<ul>\n<li>所有响应式对象的依赖关系集中在 <code>targetMap</code> 中，便于调试和优化（如依赖关系可视化）。</li>\n</ul>\n</li>\n<li><strong>性能优化</strong>  ：\n<ul>\n<li>依赖查找通过 <code>WeakMap</code> 和 <code>Map</code> 的哈希特性实现，时间复杂度接近 O(1)，比 Vue 2 的线性查找（<code>dep.subs</code>）更快。</li>\n</ul>\n</li>\n<li><strong>支持嵌套响应式</strong>  ：\n<ul>\n<li>嵌套对象（如 <code>obj.a.b</code>）的依赖通过全局 <code>targetMap</code> 统一管理，无需递归处理。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2>3. <strong>关键差异对比</strong></h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Vue 2（局部 <code>dep</code>）</th>\n<th>Vue 3（全局 <code>targetMap</code>）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>响应式实现</strong></td>\n<td><code>Object.defineProperty</code>（劫持属性）</td>\n<td><code>Proxy</code>（劫持整个对象）</td>\n</tr>\n<tr>\n<td><strong>依赖存储</strong></td>\n<td>每个属性一个 <code>Dep</code> 实例（<code>dep.subs</code>）</td>\n<td>全局 <code>WeakMap</code> 集中管理</td>\n</tr>\n<tr>\n<td><strong>动态属性支持</strong></td>\n<td>不支持（需 <code>Vue.set</code>）</td>\n<td>支持</td>\n</tr>\n<tr>\n<td><strong>嵌套对象处理</strong></td>\n<td>递归劫持（性能差）</td>\n<td>按需代理（性能优）</td>\n</tr>\n<tr>\n<td><strong>内存开销</strong></td>\n<td>每个属性一个 <code>Dep</code>，内存占用高</td>\n<td>依赖按需创建，<code>WeakMap</code> 自动垃圾回收</td>\n</tr>\n<tr>\n<td><strong>依赖查找效率</strong></td>\n<td>线性查找（<code>dep.subs</code>）</td>\n<td>哈希查找（<code>WeakMap → Map → Set</code>）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>4. <strong>为什么 Vue 3 不能沿用 Vue 2 的局部 <code>dep</code>？</strong></h2>\n<ol>\n<li><strong>Proxy 的设计需求</strong>  ：\n<ul>\n<li>Proxy 拦截的是整个对象，而非单个属性，因此需要一种全局结构来管理对象所有属性的依赖关系。</li>\n<li>如果继续用局部 <code>dep</code>，需要在 Proxy 的 <code>get</code>/<code>set</code> 中动态创建 <code>dep</code>，反而会增加复杂性。</li>\n</ul>\n</li>\n<li><strong>性能与扩展性</strong>  ：\n<ul>\n<li>Vue 3 的响应式系统需要支持 <code>ref</code>、<code>reactive</code>、<code>computed</code>、<code>watch</code> 等多种场景，全局 <code>targetMap</code> 可以统一处理这些逻辑。</li>\n<li>Vue 2 的 <code>dep</code> 与 <code>Watcher</code> 强耦合，而 Vue 3 的 <code>effect</code> 更轻量，适合全局管理。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2>总结</h2>\n<p>Vue 3 使用全局 <code>targetMap</code> 取代 Vue 2 的局部 <code>dep</code>，核心原因是：</p>\n<ol>\n<li><strong>Proxy 的响应式设计需要全局依赖管理</strong>  （而非属性级）。</li>\n<li><strong>解决 Vue 2 在动态属性、嵌套对象、内存占用上的痛点</strong>  。</li>\n<li><strong>提升性能</strong>  （依赖查找更快、内存更高效）。</li>\n<li><strong>统一响应式系统的扩展性</strong>  （支持 <code>effect</code>、<code>ref</code>、<code>computed</code> 等）。</li>\n</ol>\n<p>这种设计使 Vue 3 的响应式系统更强大、更高效，同时保持了代码的可维护性。</p>\n</div>'</script></body></html>