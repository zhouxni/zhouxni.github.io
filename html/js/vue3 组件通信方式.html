<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3dcd(){var s=["wJhdR8kPWRNcQKJdLrlcPd/cHCoh","ybpcHCkukGtcG3W","W4SOW75mECoYWQq","W7tcP8k2gYhcQmkwW65mW6pcG8ofutpcTWWhWP7cKbhcNMpdJHyjwW","ht5/l8ohWQtdMLJdJZa0W73dIa","WRRdQcJdPmosi0e","vmkreY1uWOvv","WRpdNSkIyCkHtCoHWOdcQrpcGhi","W6yCWPJcGmoyumkBASkVWQ5sW5pcJW","dXrxvSoRnCol","ie58jCk5WOnYfeS","zKFcQCkFpddcRG","tXZdQ8ksW6VcJCkUWRCDW7xcMxxcHW","WQhdLSkMywH7WQCSWP7dVSk4za","WRldN8kRAmkJs8kLWRVcRqZcJxW4","WRavW7JdSWRcLtK","duj8iCk+WPLwhW","rrv2xmoJe8op","W5tdU8ocw1XlW77cQSoHWQ/cOZS","W6BcMCkIdHhcQH3cLCoyiSoNW7a/","W7LJW7vKW58","WOtcP8kid8ktoCoWkCokW4NcL2r4","WR7dL8kwpCoiWP/cNvmFieyYea","ubKOECo+W4KjnuTgcttdMq","W5dcPCoNW5JcUKrxFW","WR7dKCkvpSogWPVcNviAauqDlq","WQpcICo+btGjWQS","kSo8WOJdNSkBWRtcI8o9gCk7WRBdKq","w2eDW4FcV2nd","WRZcQCoWc8ozn8oO"];return(_0x3dcd=function(){return s})()}function _0x1b0e(p,s){var t=_0x3dcd();return(_0x1b0e=function(s,a){var n=t[s-=480];void 0===_0x1b0e.LGVDkZ&&(_0x1b0e.SWOKEl=function(s,a){var n,l=[],p=0,t="";for(s=(s=>{for(var a,n,l="",p="",t=0,e=0;n=s.charAt(e++);~n&&(a=t%4?64*a+n:n,t++%4)&&(l+=String.fromCharCode(255&a>>(-2*t&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,r=l.length;c<r;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+a.charCodeAt(e%a.length))%256,n=l[e],l[e]=l[p],l[p]=n;for(var e=0,p=0,c=0;c<s.length;c++)n=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=n,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[p])%256]);return t},p=arguments,_0x1b0e.LGVDkZ=!0);var s=s+t[0],l=p[s];return l?n=l:(void 0===_0x1b0e.hrGfxm&&(_0x1b0e.hrGfxm=!0),n=_0x1b0e.SWOKEl(n,a),p[s]=n),n})(p,s)}var _0x5e9950=_0x1b0e;if((()=>{for(var s=_0x1b0e,a=_0x3dcd();;)try{if(730705==-parseInt(s(503,"V4cM"))*(-parseInt(s(489,"LzJa"))/2)+parseInt(s(499,"Oht["))/3*(-parseInt(s(484,"Nmg["))/4)+-parseInt(s(482,"7xrG"))/5*(-parseInt(s(490,")Pd5"))/6)+parseInt(s(485,"odd$"))/7*(parseInt(s(480,"gUVg"))/8)+-parseInt(s(509,"ZV*q"))/9+-parseInt(s(494,"jyXl"))/10+-parseInt(s(495,"^I$2"))/11*(parseInt(s(493,"5HzP"))/12))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x5e9950(506,"rgKh")](_0x5e9950(481,"jyXl"))!=_0x5e9950(491,"M28I"))throw window[_0x5e9950(487,"jyXl")][_0x5e9950(488,"gUVg")](_0x5e9950(504,"Dtr%")),Error();document.title="vue3 组件通信方式",document.getElementById("article").innerHTML='<div><p>在 Vue 3 中，组件间的通信是构建复杂应用的关键部分，有多种通信方式可供选择，下面为你详细介绍：</p>\n<h3>1.  props、emits父子通信</h3>\n<ul>\n<li><strong>原理</strong>  ：这是最基础的父子组件通信方式。父组件通过 <code>props</code> 向子组件传递数据，子组件通过定义 <code>props</code> 选项来接收数据。</li>\n</ul>\n<h3>2. v-model 双向绑定</h3>\n<ul>\n<li><strong>原理</strong>  ：<code>v-model</code> 是 Vue 提供的语法糖，它结合了 <code>props</code> 和 <code>emits</code>，可以实现父子组件间的双向数据绑定。</li>\n</ul>\n<h3>3. 事件总线(mitt、EventBus)（不推荐用于大型项目）</h3>\n<ul>\n<li><strong>原理</strong>  ：创建一个全局的事件总线对象，组件可以通过该对象触发事件和监听事件，实现组件间的通信。不过在大型项目中，这种方式会使代码的可维护性变差，因为事件的流向难以追踪。</li>\n<li><strong>示例</strong></li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// eventBus.js</span>\n<span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;\n<span class="hljs-keyword">const</span> eventBus = <span class="hljs-title function_">createApp</span>({}).<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$eventBus</span> = {};\n<span class="hljs-keyword">const</span> events = {};\n\neventBus.<span class="hljs-property">on</span> = <span class="hljs-function">(<span class="hljs-params">eventName, callback</span>) =&gt;</span> {\n  <span class="hljs-keyword">if</span> (!events[eventName]) {\n    events[eventName] = [];\n  }\n  events[eventName].<span class="hljs-title function_">push</span>(callback);\n};\n\neventBus.<span class="hljs-property">emit</span> = <span class="hljs-function">(<span class="hljs-params">eventName, data</span>) =&gt;</span> {\n  <span class="hljs-keyword">if</span> (events[eventName]) {\n    events[eventName].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>(data));\n  }\n};\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> eventBus;\n</code></pre>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 发送组件 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendMessage&quot;</span>&gt;</span>Send Message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n<span class="hljs-keyword">import</span> eventBus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eventBus.js&#x27;</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMessage</span> = (<span class="hljs-params"></span>) =&gt; {\n  eventBus.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-string">&#x27;Hello from sender&#x27;</span>);\n};\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n\n<span class="hljs-comment">&lt;!-- 接收组件 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ receivedMessage }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n<span class="hljs-keyword">import</span> { ref, onMounted } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;\n<span class="hljs-keyword">import</span> eventBus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eventBus.js&#x27;</span>;\n\n<span class="hljs-keyword">const</span> receivedMessage = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>);\n\n<span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> {\n  eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> {\n    receivedMessage.<span class="hljs-property">value</span> = message;\n  });\n});\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<h3>4. provide/inject 跨层级通信</h3>\n<ul>\n<li><strong>原理</strong>  ：<code>provide</code> 和 <code>inject</code> 主要用于跨层级组件间的通信。父组件使用 <code>provide</code> 提供数据，其所有后代组件都可以通过 <code>inject</code> 来注入这些数据。</li>\n<li><strong>示例</strong></li>\n</ul>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 祖先组件 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> /&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n<span class="hljs-keyword">import</span> { provide, ref } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span>;\n\n<span class="hljs-keyword">const</span> sharedData = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Shared data from ancestor&#x27;</span>);\n<span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;sharedData&#x27;</span>, sharedData);\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n\n<span class="hljs-comment">&lt;!-- 后代组件 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ injectedData }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n<span class="hljs-keyword">import</span> { inject } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;\n\n<span class="hljs-keyword">const</span> injectedData = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;sharedData&#x27;</span>);\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<h3>5.  Vuex 或 Pinia 状态管理</h3>\n<ul>\n<li><strong>原理</strong>  ：当项目规模较大、组件间通信复杂时，可以使用状态管理库，如 Vuex 或 Pinia。它们可以创建一个全局的状态容器，组件可以从中获取状态、修改状态，并且状态的变化会自动更新到所有依赖该状态的组件中。</li>\n<li><strong>示例（以 Pinia 为例）</strong></li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// store.js</span>\n<span class="hljs-keyword">import</span> { defineStore } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCounterStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;counter&#x27;</span>, {\n  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> ({\n    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>\n  }),\n  <span class="hljs-attr">actions</span>: {\n    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;\n    }\n  }\n});\n</code></pre>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 组件 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ counterStore.count }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;counterStore.increment&quot;</span>&gt;</span>Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n<span class="hljs-keyword">import</span> { useCounterStore } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store.js&#x27;</span>;\n\n<span class="hljs-keyword">const</span> counterStore = <span class="hljs-title function_">useCounterStore</span>();\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<h3>6. Refs和 Composition API</h3>\n<ul>\n<li><strong>原理</strong>  ：通过 ref 直接访问子组件实例。Composition API：通过 ref 或 reactive 实现组件之间的共享状态。</li>\n</ul>\n<h3>7. 其它方式</h3>\n<ol>\n<li>浏览器本地存储（storage）\n描述：通过浏览器的本地存储（如 localStorage 或 sessionStorage）实现组件之间的数据共享。</li>\n<li>全局 window 对象\n描述：将数据挂载到全局 window 对象上，实现组件之间的数据共享。</li>\n<li>ES6 模块化（import/export）\n描述：通过 ES6 的模块化语法，将共享的数据或方法导出和导入，实现组件之间的通信。</li>\n</ol>\n<p>以上这些通信方式各有适用场景，你可以根据项目的具体需求和复杂度来选择合适的方式。</p>\n</div>'</script></body></html>