<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x53193e=_0xdb19;function _0x469f(){var s=["ACoAsCkqW5WaW5iRCSkm","kCkFCSkRW6SMW5vrza","r8oOWQBdLreCW7HiWRrh","WP3dKSkhW7RcGW","l3jZuCkjWQmCBgS","qCoXkcxdON3cKq","jYzeW4emyMyqnmkNu8os","taFcNhVcT8owa8k0WQddIq","xYGGa8odW6HJqfxdJCoQWRDM","vIXkoxhdMKW8WPugWRuu","FaBcJx0xfg0","v8oEWRHSWRdcNXC","WQldQdXgW6hdRJhdIq","W4tdNSozW4rkW5C+A8k2WRpdPwnW","e2pcHSkdWRVdL1WAW4T7vW","rSoQWQxcSZ8bW4TCWPG","W6FcSmk5smkAA8o3","WRDpfColDNaIfIZdGW","W44wqwJcIXvpkSkQWP7cSmoO","jJKCumkJDCk9WOG","WP7cGmo3W7JdSYFcQ8o/WPvXW5VdLJy","tSoGkbZdPsldKZ49cx5Gk8kydtdcTSoIWQVdSxxcJZtcGr4o","sZxdKmoBW7/dMKO5","q8oOWQJdKdCrW6TfWO9y","i15VWP8NW7xdI07cINP6","WRxcShX8W6BcLSk0vSkeWP/dKmoC","vcXlox7dKbmEWRSrWR0ADq","WOxdMqNcISkcWQ8hcCkpW78"];return(_0x469f=function(){return s})()}function _0xdb19(l,s){var e=_0x469f();return(_0xdb19=function(s,n){var a=e[s-=303];void 0===_0xdb19.pFDJnF&&(_0xdb19.xGecgV=function(s,n){var a,t=[],l=0,e="";for(s=(s=>{for(var n,a,t="",l="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=t.length;c<r;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)l=(l+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[l],t[l]=a;for(var p=0,l=0,c=0;c<s.length;c++)a=t[p=(p+1)%256],t[p]=t[l=(l+t[p])%256],t[l]=a,e+=String.fromCharCode(s.charCodeAt(c)^t[(t[p]+t[l])%256]);return e},l=arguments,_0xdb19.pFDJnF=!0);var s=s+e[0],t=l[s];return t?a=t:(void 0===_0xdb19.ijvbnl&&(_0xdb19.ijvbnl=!0),a=_0xdb19.xGecgV(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0xdb19,n=_0x469f();;)try{if(271495==-parseInt(s(320,"1lo6"))+parseInt(s(324,")Fhf"))/2+parseInt(s(312,"JAXI"))/3+-parseInt(s(305,"qt1s"))/4*(parseInt(s(313,"0K2F"))/5)+parseInt(s(321,"CChQ"))/6*(parseInt(s(329,"CChQ"))/7)+parseInt(s(314,"d9hw"))/8*(-parseInt(s(322,"th*f"))/9)+parseInt(s(325,"R[K5"))/10*(parseInt(s(319,"wtzh"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x53193e(311,"Cx9)")](_0x53193e(310,"d9hw"))!=_0x53193e(309,"[4SA"))throw window[_0x53193e(328,"1lo6")][_0x53193e(316,"5pTV")](_0x53193e(327,"Cx9)")),Error();document.title="Vue createElement 函数",document.getElementById("article").innerHTML='<div><p><code>createElement</code> 是 Vue 中 <strong>“虚拟 DOM 描述对象”</strong>   的工厂函数，也是 <strong>Render 函数</strong>   的第一个形参。它把<strong>模板语法抽象成纯 JavaScript</strong>   ，让你可以完全用 JS 描述组件的结构、样式、行为。<br>\n（注：Vue3 中 <code>createElement</code> 改名为 <code>h</code>，但参数、语义几乎一致；下文以 Vue2 为主，同时点出 Vue3 差异。）</p>\n<hr>\n<p>一、函数签名</p>\n<pre><code class="language-ts"><span class="hljs-title function_">createElement</span>(\n  tag, <span class="hljs-comment">// String | Object | Function</span>\n  data, <span class="hljs-comment">// Object（可选）描述属性、事件、样式、指令等</span>\n  children, <span class="hljs-comment">// String | Array（可选）子节点</span>\n);\n</code></pre>\n<hr>\n<p>二、各参数详解</p>\n<ol>\n<li>tag（必填）</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>示例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>String</td>\n<td><code>\'div\'</code> <code>\'my-component\'</code></td>\n<td>HTML 标签名或已注册组件名</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>组件选项对象</td>\n<td>局部注册的组件</td>\n</tr>\n<tr>\n<td>Function</td>\n<td>返回上述两种的函数</td>\n<td>动态组件 / 函数式组件</td>\n</tr>\n</tbody>\n</table>\n<ol start="2">\n<li>data（可选）</li>\n</ol>\n<p>一个包含<strong>所有模板层面信息</strong>   的普通对象，常用字段如下：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>类型</th>\n<th>模板等价写法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>class</td>\n<td>Object / Array</td>\n<td><code>class=&quot;{ active: isActive }&quot;</code></td>\n</tr>\n<tr>\n<td>style</td>\n<td>Object / Array</td>\n<td><code>style=&quot;{ color: red }&quot;</code></td>\n</tr>\n<tr>\n<td>attrs</td>\n<td>Object</td>\n<td>非 prop 特性：<code>title</code>, <code>id</code>…</td>\n</tr>\n<tr>\n<td>props</td>\n<td>Object</td>\n<td>组件的 <code>props</code></td>\n</tr>\n<tr>\n<td>domProps</td>\n<td>Object</td>\n<td>直接操作原生 DOM 属性：innerHTML</td>\n</tr>\n<tr>\n<td>on</td>\n<td>Object</td>\n<td>v-on 事件监听器</td>\n</tr>\n<tr>\n<td>nativeOn</td>\n<td>Object</td>\n<td>组件根元素的原生事件（Vue2）</td>\n</tr>\n<tr>\n<td>directives</td>\n<td>Array</td>\n<td>自定义指令</td>\n</tr>\n<tr>\n<td>scopedSlots</td>\n<td>Object</td>\n<td>作用域插槽</td>\n</tr>\n<tr>\n<td>key/ref</td>\n<td>String/Symbol</td>\n<td>同模板</td>\n</tr>\n</tbody>\n</table>\n<ol start="3">\n<li>children（可选）</li>\n</ol>\n<ul>\n<li>文本节点：<code>\'hello\'</code></li>\n<li>数组：子 VNode 列表 <code>[h(\'span\'), h(\'span\')]</code></li>\n<li>插槽对象：<code>this.$slots.default</code></li>\n</ul>\n<hr>\n<p>三、完整示例</p>\n<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">props</span>: [<span class="hljs-string">&quot;level&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>],\n  <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>) {\n    <span class="hljs-comment">// h 就是 createElement</span>\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(\n      <span class="hljs-string">&quot;h&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">level</span>, <span class="hljs-comment">// tag</span>\n      {\n        <span class="hljs-comment">// data</span>\n        <span class="hljs-attr">class</span>: { <span class="hljs-attr">primary</span>: <span class="hljs-literal">true</span> },\n        <span class="hljs-attr">style</span>: { <span class="hljs-attr">margin</span>: <span class="hljs-number">0</span> },\n        <span class="hljs-attr">attrs</span>: { <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;标题&quot;</span> },\n        <span class="hljs-attr">on</span>: { <span class="hljs-attr">click</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">clickHandler</span> },\n      },\n      [\n        <span class="hljs-comment">// children</span>\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">content</span>,\n        <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;span&quot;</span>, <span class="hljs-string">&quot;副标题&quot;</span>),\n      ],\n    );\n  },\n  <span class="hljs-attr">methods</span>: {\n    <span class="hljs-title function_">clickHandler</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-comment">/* ... */</span>\n    },\n  },\n};\n</code></pre>\n<p>模板等价写法：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin:0&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;标题&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;clickHandler&quot;</span>&gt;</span>\n  {{ content }}<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>副标题<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n</code></pre>\n<hr>\n<p>四、动态组件 &amp; 函数式组件</p>\n<ol>\n<li>动态组件</li>\n</ol>\n<pre><code class="language-js"><span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">someFlag</span> ? <span class="hljs-string">&#x27;input&#x27;</span> : <span class="hljs-string">&#x27;textarea&#x27;</span>,\n    { <span class="hljs-attr">domProps</span>: { <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> } }\n  )\n}\n</code></pre>\n<ol start="2">\n<li>函数式组件（无状态、无实例）</li>\n</ol>\n<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">functional</span>: <span class="hljs-literal">true</span>,\n  <span class="hljs-attr">props</span>: [<span class="hljs-string">&quot;msg&quot;</span>],\n  <span class="hljs-title function_">render</span>(<span class="hljs-params">h, ctx</span>) {\n    <span class="hljs-comment">// 第二个参数是 context</span>\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;p&quot;</span>, ctx.<span class="hljs-property">props</span>.<span class="hljs-property">msg</span>);\n  },\n};\n</code></pre>\n<hr>\n<p>五、Vue3 的变化（<code>h</code>）</p>\n<ul>\n<li>函数名：<code>createElement</code> → <code>h</code>（import { h } from \'vue\'）</li>\n<li>data 结构扁平化：\n<ul>\n<li><code>onClick</code> 代替 <code>on: { click }</code></li>\n<li><code>class</code> / <code>style</code> 保持原样</li>\n</ul>\n</li>\n<li>事件修饰符：使用字符串拼接 <code>onClickCapture</code> / <code>onKeyupOnce</code></li>\n</ul>\n<pre><code class="language-js"><span class="hljs-keyword">import</span> { h } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span>\n      <span class="hljs-title function_">h</span>(\n        <span class="hljs-string">&quot;button&quot;</span>,\n        {\n          <span class="hljs-attr">class</span>: [<span class="hljs-string">&quot;btn&quot;</span>, { <span class="hljs-attr">primary</span>: props.<span class="hljs-property">type</span> === <span class="hljs-string">&quot;primary&quot;</span> }],\n          <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;click&quot;</span>),\n        },\n        <span class="hljs-string">&quot;Vue3 Button&quot;</span>,\n      );\n  },\n};\n</code></pre>\n<hr>\n<p>六、常见坑 &amp; 提示</p>\n<ul>\n<li><strong>必须返回单一根节点</strong>   （Vue2），Vue3 支持 Fragment。</li>\n<li>避免在 <code>render</code> 里直接操作真实 DOM，用 <code>ref</code>。</li>\n<li>使用 <code>this.$slots</code> / <code>this.$scopedSlots</code> 读取插槽内容。</li>\n<li>性能：复杂模板 → 模板编译器优化；手动 <code>render</code> 适合高度动态场景。</li>\n</ul>\n<p>至此，你已掌握 <code>createElement</code> 的全部细节。把它与 JSX、模板对比，可更深刻理解 Vue 的渲染机制。</p>\n</div>'</script></body></html>