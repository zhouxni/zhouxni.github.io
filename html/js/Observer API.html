<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x151924=_0x247c;function _0x4292(){var s=["WQ1uW6ngvaipsq","tG7cQ1LdW75bi1dcGfe","d8kqpw7dV8oUW6C","rmouW4ZcRZ5Tj8oIhG","b8kxo39lE3mZWQpdKL1q","uJddGIzKrCkEimo6fSkrW5i","BbZdRW5vWP4nmsJdHmofcW","W6u8W48fxSoOWRaDiW1D","m2ZcUSkoW4LfWPi","m8kkWOhcKSomdmoTxdlcLhBcRa","WR7dQCkCWQOgWR3dHba","gshdUSkeBGVcVmoowL7dVfpcTq","sGxcQLDeWR0cfNVcLwWPtG","B8odgmkBsI0pgNe","cSoBaCk7uSoKdCog","W6/dNCkHWPVcV8kHWRODASkXWRSbkJNcUmoIWQJcPSoiW6ClBGOvWO9p","WP4LAGddLSk6qmoPWROQWQfp","ztRdUCo3WOqyW4CtWQGOivW+","bG3cG1hdHq","d8kuqNNdNSorW7dcVCkcW54DW4y","WR3cKSktWOeMWOBdLa","iCoJcfVcMwhdRW","W7ZdKmorWOjgoY3cIq","q8orW4hdQw0jdmoDlSkWWP1+","W7iYWOTdW6tcMePY","qSkytYSUk8o5FcX+aN4","W7yYW7a1WOpdIbbygCo0tmkZeG","A8kvWRldIxmSWQtdGqW"];return(_0x4292=function(){return s})()}function _0x247c(e,s){var t=_0x4292();return(_0x247c=function(s,n){var a=t[s-=231];void 0===_0x247c.GcVZLe&&(_0x247c.fNFzts=function(s,n){var a,l=[],e=0,t="";for(s=(s=>{for(var n,a,l="",e="",t=0,r=0;a=s.charAt(r++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,o=l.length;p<o;p++)e+="%"+("00"+l.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(s),r=0;r<256;r++)l[r]=r;for(r=0;r<256;r++)e=(e+l[r]+n.charCodeAt(r%n.length))%256,a=l[r],l[r]=l[e],l[e]=a;for(var r=0,e=0,p=0;p<s.length;p++)a=l[r=(r+1)%256],l[r]=l[e=(e+l[r])%256],l[e]=a,t+=String.fromCharCode(s.charCodeAt(p)^l[(l[r]+l[e])%256]);return t},e=arguments,_0x247c.GcVZLe=!0);var s=s+t[0],l=e[s];return l?a=l:(void 0===_0x247c.nRhaRn&&(_0x247c.nRhaRn=!0),a=_0x247c.fNFzts(a,n),e[s]=a),a})(e,s)}if((()=>{for(var s=_0x247c,n=_0x4292();;)try{if(168832==-parseInt(s(243,"[8nz"))*(-parseInt(s(245,"s[HM"))/2)+-parseInt(s(238,"0V9D"))/3+-parseInt(s(242,"ODyy"))/4*(-parseInt(s(254,"VXk1"))/5)+-parseInt(s(251,"y9B%"))/6*(-parseInt(s(257,"01m0"))/7)+-parseInt(s(246,"HIiT"))/8+-parseInt(s(252,"I8wV"))/9*(-parseInt(s(235,"IfDg"))/10)+-parseInt(s(239,"wv5w"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x151924(249,"WogL")](_0x151924(240,"#t7T"))!=_0x151924(231,"JN#)"))throw window[_0x151924(255,"!v*F")][_0x151924(234,"6Aon")](_0x151924(256,"2hYi")),Error();document.title="Observer API",document.getElementById("article").innerHTML='<div><p>在前端开发中，Observer API 是一类用于监听和响应 DOM 或其他对象变化的接口。这些 API 允许开发者在特定事件发生时执行回调函数，从而实现更动态和响应式的应用。以下是一些常见的前端 Observer API：</p>\n<hr>\n<h3><strong>1. MutationObserver</strong></h3>\n<ul>\n<li><strong>用途</strong>  ：监听 DOM 树的变化。</li>\n<li><strong>功能</strong>  ：\n<ul>\n<li>监听子节点的增删改。</li>\n<li>监听属性的变化。</li>\n<li>监听文本内容的变化。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> targetNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;someElement&#x27;</span>);\n<span class="hljs-keyword">const</span> config = { <span class="hljs-attr">attributes</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">childList</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">subtree</span>: <span class="hljs-literal">true</span> };\n\n<span class="hljs-keyword">const</span> callback = <span class="hljs-keyword">function</span>(<span class="hljs-params">mutationsList, observer</span>) {\n    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> mutation <span class="hljs-keyword">of</span> mutationsList) {\n        <span class="hljs-keyword">if</span> (mutation.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;childList&#x27;</span>) {\n            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;A child node has been added or removed.&#x27;</span>);\n        }\n        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mutation.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;attributes&#x27;</span>) {\n            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The &#x27;</span> + mutation.<span class="hljs-property">attributeName</span> + <span class="hljs-string">&#x27; attribute was modified.&#x27;</span>);\n        }\n    }\n};\n\n<span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(callback);\nobserver.<span class="hljs-title function_">observe</span>(targetNode, config);\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>2. ResizeObserver</strong></h3>\n<ul>\n<li><strong>用途</strong>  ：监听元素尺寸的变化。</li>\n<li><strong>功能</strong>  ：\n<ul>\n<li>当元素的尺寸（宽度或高度）发生变化时触发回调。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> resizeObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResizeObserver</span>(<span class="hljs-function"><span class="hljs-params">entries</span> =&gt;</span> {\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> entries) {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Element:&#x27;</span>, entry.<span class="hljs-property">target</span>);\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;New dimensions:&#x27;</span>, entry.<span class="hljs-property">contentRect</span>.<span class="hljs-property">width</span>, <span class="hljs-string">&#x27;x&#x27;</span>, entry.<span class="hljs-property">contentRect</span>.<span class="hljs-property">height</span>);\n    }\n});\n\n<span class="hljs-keyword">const</span> someElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;someElement&#x27;</span>);\nresizeObserver.<span class="hljs-title function_">observe</span>(someElement);\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>3. IntersectionObserver</strong></h3>\n<ul>\n<li><strong>用途</strong>  ：检测元素与其祖先元素或视口（viewport）的交叉状态。</li>\n<li><strong>功能</strong>  ：\n<ul>\n<li>实现懒加载图片或无限滚动。</li>\n<li>检测元素是否进入视口。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> intersectionObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries, observer</span>) =&gt;</span> {\n    entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {\n        <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {\n            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Element has entered the viewport:&#x27;</span>, entry.<span class="hljs-property">target</span>);\n            observer.<span class="hljs-title function_">unobserve</span>(entry.<span class="hljs-property">target</span>); <span class="hljs-comment">// 停止观察该元素</span>\n        }\n    });\n});\n\n<span class="hljs-keyword">const</span> someElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;someElement&#x27;</span>);\nintersectionObserver.<span class="hljs-title function_">observe</span>(someElement);\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>4. PerformanceObserver</strong></h3>\n<ul>\n<li><strong>用途</strong>  ：监听性能相关的数据，如资源加载、长任务等。</li>\n<li><strong>功能</strong>  ：\n<ul>\n<li>收集性能条目（如 <code>measure</code>、<code>mark</code>、<code>navigation</code> 等）。</li>\n<li>分析页面加载性能。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> performanceObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> {\n    list.<span class="hljs-title function_">getEntries</span>().<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Performance entry:&#x27;</span>, entry);\n    });\n});\n\nperformanceObserver.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">&#x27;measure&#x27;</span>, <span class="hljs-string">&#x27;mark&#x27;</span>] });\n\nperformance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&#x27;start&#x27;</span>);\n<span class="hljs-comment">// 一些代码执行</span>\nperformance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&#x27;end&#x27;</span>);\nperformance.<span class="hljs-title function_">measure</span>(<span class="hljs-string">&#x27;Code execution time&#x27;</span>, <span class="hljs-string">&#x27;start&#x27;</span>, <span class="hljs-string">&#x27;end&#x27;</span>);\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>5. ReportingObserver</strong></h3>\n<ul>\n<li><strong>用途</strong>  ：收集浏览器报告的弃用、干扰或崩溃信息。</li>\n<li><strong>功能</strong>  ：\n<ul>\n<li>帮助开发者了解页面中的问题，如过时的 API 使用。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> reportingObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReportingObserver</span>(<span class="hljs-function">(<span class="hljs-params">reports, observer</span>) =&gt;</span> {\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> report <span class="hljs-keyword">of</span> reports) {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Report type:&#x27;</span>, report.<span class="hljs-property">type</span>);\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Message:&#x27;</span>, report.<span class="hljs-property">message</span>);\n    }\n}, { <span class="hljs-attr">types</span>: [<span class="hljs-string">&#x27;deprecation&#x27;</span>] });\n\nreportingObserver.<span class="hljs-title function_">observe</span>();\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>6. Battery Status API（已废弃，但部分浏览器仍支持）</strong></h3>\n<ul>\n<li><strong>用途</strong>  ：获取设备电池状态。</li>\n<li><strong>注意</strong>  ：由于隐私和安全问题，该 API 在许多浏览器中已被废弃或限制使用。</li>\n<li><strong>示例（仅供参考）</strong>  ：<pre><code class="language-javascript">navigator.<span class="hljs-title function_">getBattery</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">battery</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Battery level:&#x27;</span>, battery.<span class="hljs-property">level</span> * <span class="hljs-number">100</span> + <span class="hljs-string">&#x27;%&#x27;</span>);\n    battery.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;levelchange&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Battery level changed:&#x27;</span>, battery.<span class="hljs-property">level</span> * <span class="hljs-number">100</span> + <span class="hljs-string">&#x27;%&#x27;</span>);\n    });\n});\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>7. Custom Observers（基于 Proxy 或其他机制）</strong></h3>\n<ul>\n<li><strong>用途</strong>  ：自定义观察对象属性的变化。</li>\n<li><strong>功能</strong>  ：\n<ul>\n<li>使用 <code>Proxy</code> 对象监听和拦截对对象属性的操作。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> targetObj = { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> };\n<span class="hljs-keyword">const</span> handler = {\n    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">obj, prop, value</span>) {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Property <span class="hljs-subst">${prop}</span> changed from <span class="hljs-subst">${obj[prop]}</span> to <span class="hljs-subst">${value}</span>`</span>);\n        obj[prop] = value;\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n    }\n};\n\n<span class="hljs-keyword">const</span> proxyObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(targetObj, handler);\nproxyObj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Bob&#x27;</span>; <span class="hljs-comment">// 输出：Property name changed from Alice to Bob</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>MutationObserver</strong>  ：监听 DOM 变化。</li>\n<li><strong>ResizeObserver</strong>  ：监听元素尺寸变化。</li>\n<li><strong>IntersectionObserver</strong>  ：检测元素与视口的交叉状态。</li>\n<li><strong>PerformanceObserver</strong>  ：收集性能数据。</li>\n<li><strong>ReportingObserver</strong>  ：收集浏览器报告的问题。</li>\n<li><strong>Battery Status API</strong>  ：获取设备电池状态（已废弃，部分浏览器仍支持）。</li>\n<li><strong>Custom Observers</strong>  ：基于 <code>Proxy</code> 实现自定义观察。</li>\n</ul>\n<p>这些 Observer API 为开发者提供了强大的工具，用于创建更动态、响应式和高效的前端应用。选择合适的 API 取决于具体的应用场景和需求。</p>\n</div>'</script></body></html>