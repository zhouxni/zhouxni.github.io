<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x431e(d,n){var s=_0x233b();return(_0x431e=function(n,o){var c=s[n-=498];void 0===_0x431e.YSKEya&&(_0x431e.ZXACEs=function(n,o){var c,e=[],d=0,s="";for(n=(n=>{for(var o,c,e="",d="",s=0,l=0;c=n.charAt(l++);~c&&(o=s%4?64*o+c:c,s++%4)&&(e+=String.fromCharCode(255&o>>(-2*s&6))))c="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(c);for(var a=0,t=e.length;a<t;a++)d+="%"+("00"+e.charCodeAt(a).toString(16)).slice(-2);return decodeURIComponent(d)})(n),l=0;l<256;l++)e[l]=l;for(l=0;l<256;l++)d=(d+e[l]+o.charCodeAt(l%o.length))%256,c=e[l],e[l]=e[d],e[d]=c;for(var l=0,d=0,a=0;a<n.length;a++)c=e[l=(l+1)%256],e[l]=e[d=(d+e[l])%256],e[d]=c,s+=String.fromCharCode(n.charCodeAt(a)^e[(e[l]+e[d])%256]);return s},d=arguments,_0x431e.YSKEya=!0);var n=n+s[0],e=d[n];return e?c=e:(void 0===_0x431e.SpXNAe&&(_0x431e.SpXNAe=!0),c=_0x431e.ZXACEs(c,o),d[n]=c),c})(d,n)}var _0x4ac0c8=_0x431e;function _0x233b(){var n=["usySW6LBtSomWRtcTa","W63dQSokW48Yf2LwW5BdLIZdPfJcMCkEWQedW57dUmkxfW3cO8kaW7dcVW","E8koWOhcGelcPmoFnbiHW7C","WRtcR8oZW5S1qqew","W5ydW4dcOv3cQbu","uConW5/dRCovWQip","eqZdGXdcJInlW5m","WOBdRSkzW5lcR8oJW6FcKSo3v8kE","W6C7v3ZdKSkiW45yWQjjWQJcTa","W7pcM3pdRr7dGNn/","WPr5WRldIH0LWPKv","WPFdHGhcNSojbcpcR3GQ","WQmGW5KVDqmd","iCops8orertcRqr+dSoOtaC","WQZdH3BdIZldVgv7","WRtcP8kpWOT1g34ZW5NdIXFdLNO","WPnvp0xcIu5y","ucP+WO/cMsBdLLhcPmoCrW","W7FdSNpdPCktW6BdNNDmyCooW4VcNG","WP3dHGBcL8kazY3cJvOMW7ZcSG","bCkkW6/dLmo8t8oQthipx2O","bCkgW6RdKSo3r8kgvhixBLm8","uY8YW5RdLWFdL0y","pCopW4RdGqS","a8kaWQJcGSk5dSovEa","mZnFWOFdKmkqpbDLo8kK","A8kzwSoxlSk7W7m","WQqYWR5fWPupW6xdP8kAiZ5y","kWutwmk0Fmk3","W7TFiCovFuHbxZmc"];return(_0x233b=function(){return n})()}if((()=>{for(var n=_0x431e,o=_0x233b();;)try{if(163970==+parseInt(n(509,"4PtN"))+-parseInt(n(505,"atrG"))/2*(-parseInt(n(520,"kFE]"))/3)+parseInt(n(504,"fCoj"))/4*(-parseInt(n(512,"BAL@"))/5)+parseInt(n(523,"df]O"))/6*(parseInt(n(522,"vG6["))/7)+-parseInt(n(498,"*Y13"))/8*(parseInt(n(526,"Wjp^"))/9)+parseInt(n(500,"fCoj"))/10*(parseInt(n(516,"O0I3"))/11)+-parseInt(n(499,"zCU8"))/12)break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x4ac0c8(514,"vdvm")](_0x4ac0c8(510,"^cNa"))!=_0x4ac0c8(503,"BAL@"))throw window[_0x4ac0c8(519,"V**c")][_0x4ac0c8(515,"kEii")](_0x4ac0c8(511,"MMw9")),Error();document.title="npm run",document.getElementById("article").innerHTML='<div><p><code>npm run</code> 在执行时，会按照一定的顺序和机制去寻找并执行指定的命令，其中包括在 <code>node_modules/.bin</code> 目录下查找可执行文件。以下是 <code>npm run</code> 寻找并执行 <code>bin</code> 命令的详细原理：</p>\n<h3>1. 查找 <code>package.json</code> 文件</h3>\n<ul>\n<li><code>npm run</code> 命令首先会在当前目录下查找 <code>package.json</code> 文件。</li>\n<li>如果找不到 <code>package.json</code> 文件，命令会失败并提示错误。</li>\n</ul>\n<h3>2. 读取 <code>scripts</code> 字段</h3>\n<ul>\n<li><code>npm run</code> 会读取 <code>package.json</code> 文件中的 <code>scripts</code> 字段，找到指定脚本名称对应的命令。</li>\n</ul>\n<h3>3. 寻找可执行文件</h3>\n<ul>\n<li>当执行 <code>npm run &lt;script-name&gt;</code> 时，npm 会尝试解析命令中涉及的可执行文件。</li>\n<li>npm 会按照以下顺序查找可执行文件：\n<ol>\n<li><strong>当前项目的 <code>node_modules/.bin</code> 目录</strong>  ：\n<ul>\n<li>当我们安装某些 npm 包时，如果这些包在它们的 <code>package.json</code> 文件中定义了 <code>bin</code> 字段，npm 会在安装过程中将这些可执行文件软链接到当前项目的 <code>node_modules/.bin</code> 目录下。</li>\n<li>因此，<code>npm run</code> 会首先在这个目录下查找命令中涉及的可执行文件。</li>\n</ul>\n</li>\n<li><strong>全局的 <code>node_modules/.bin</code> 目录</strong>  ：\n<ul>\n<li>如果在当前项目的 <code>node_modules/.bin</code> 目录中找不到可执行文件，npm 会尝试在全局的 <code>node_modules/.bin</code> 目录中查找。</li>\n<li>全局安装的 npm 包的可执行文件通常位于这个目录中。</li>\n</ul>\n</li>\n<li><strong>系统的环境变量（<code>PATH</code>）</strong>  ：\n<ul>\n<li>如果在全局的 <code>node_modules/.bin</code> 目录中也找不到可执行文件，npm 会继续在系统的环境变量中查找。</li>\n<li>这意味着，如果某个可执行文件已经添加到系统的 <code>PATH</code> 中，npm 也可以找到并执行它。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3>4. 执行命令</h3>\n<ul>\n<li>一旦找到可执行文件，<code>npm run</code> 会使用 Node.js 的子进程模块（如 <code>child_process.spawn</code>）来执行该命令。</li>\n<li>在执行过程中，<code>npm run</code> 会将当前环境变量传递给子进程，并确保脚本的执行环境与当前 shell 隔离。</li>\n</ul>\n<h3>5. 示例</h3>\n<p>假设有一个 <code>package.json</code> 文件如下：</p>\n<pre><code class="language-json"><span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-project&quot;</span><span class="hljs-punctuation">,</span>\n  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span>\n  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>\n    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-cli serve&quot;</span>\n  <span class="hljs-punctuation">}</span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n<ul>\n<li>如果我们运行 <code>npm run start</code>，npm 会尝试执行 <code>my-cli serve</code> 命令。</li>\n<li>npm 会首先在当前项目的 <code>node_modules/.bin</code> 目录中查找 <code>my-cli</code> 可执行文件。</li>\n<li>如果找到了 <code>my-cli</code>，npm 会执行它，并将 <code>serve</code> 作为参数传递给它。</li>\n<li>如果在当前项目的 <code>node_modules/.bin</code> 目录中找不到 <code>my-cli</code>，npm 会继续在全局的 <code>node_modules/.bin</code> 目录中查找。</li>\n<li>如果在全局的 <code>node_modules/.bin</code> 目录中也找不到 <code>my-cli</code>，npm 会检查系统的环境变量中是否有 <code>my-cli</code> 可执行文件。</li>\n</ul>\n<h3>6. 注意事项</h3>\n<ul>\n<li><strong><code>bin</code> 字段</strong>  ：只有那些在其 <code>package.json</code> 文件中定义了 <code>bin</code> 字段的 npm 包，才会在安装过程中将可执行文件软链接到 <code>node_modules/.bin</code> 目录下。</li>\n<li><strong>全局安装</strong>  ：如果某个 npm 包是全局安装的，它的可执行文件通常会位于全局的 <code>node_modules/.bin</code> 目录中，并且可以通过系统的环境变量直接调用。</li>\n<li><strong>路径问题</strong>  ：如果在 <code>npm run</code> 中执行的命令涉及相对路径或绝对路径，需要确保这些路径是正确的，并且 npm 能够找到它们。</li>\n</ul>\n</div>'</script></body></html>