<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3924(t,n){var o=_0x35a9();return(_0x3924=function(n,s){var l=o[n-=305];void 0===_0x3924.keTsXw&&(_0x3924.lMCyol=function(n,s){var l,a=[],t=0,o="";for(n=(n=>{for(var s,l,a="",t="",o=0,e=0;l=n.charAt(e++);~l&&(s=o%4?64*s+l:l,o++%4)&&(a+=String.fromCharCode(255&s>>(-2*o&6))))l="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(l);for(var r=0,c=a.length;r<c;r++)t+="%"+("00"+a.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(t)})(n),e=0;e<256;e++)a[e]=e;for(e=0;e<256;e++)t=(t+a[e]+s.charCodeAt(e%s.length))%256,l=a[e],a[e]=a[t],a[t]=l;for(var e=0,t=0,r=0;r<n.length;r++)l=a[e=(e+1)%256],a[e]=a[t=(t+a[e])%256],a[t]=l,o+=String.fromCharCode(n.charCodeAt(r)^a[(a[e]+a[t])%256]);return o},t=arguments,_0x3924.keTsXw=!0);var n=n+o[0],a=t[n];return a?l=a:(void 0===_0x3924.hcxHrL&&(_0x3924.hcxHrL=!0),l=_0x3924.lMCyol(l,s),t[n]=l),l})(t,n)}function _0x35a9(){var n=["yCkwW5RcQaNdMmkZhGdcG8ohkCoj","DYhcLIDyW58xDmk5lLRdI8ok","ySkXWRddOcOsW78hwa","cCoIBrFcI8kmW47dQ0jDpcVcOq","WPxcRCkbW60jqHVdTW","WPKPW48NC8kutsBcVZ3dUqdcPW","lWdcQ3byW4fZuSkx","W5HVWOrTpq","W7TxWQNcGmkRW5/cTqVcNmowtbK","F3hcImkdomoJW5dcNKi","WQhdLWRdSCoYWQ/dT8o6EmohWOK","AYRcSv3dPvCY","W5yjWO41lSoCe8kEySk0WQpdVa","vMBcN8kwomkQWRtdLef3WRNdUCk2W4fklSo7lmoYWOtdTs0kWPaREa","yvhcR2tdJcddTGO9uLxdSbe","pW1KW7RcQhL8pt3cGfZdGva","W4HYwa/cVq4pv07dQSkBW4JdJG","WOBcHHm9A8k5W45mWO7cKxtdKZi","B1hcR2ldHM/cTci4Efu","WPaOW44QFmkEsrdcUsRdOahcTG","kGzJWRJdICouW5C"];return(_0x35a9=function(){return n})()}var _0x1f811a=_0x3924;if((()=>{for(var n=_0x3924,s=_0x35a9();;)try{if(817122==+parseInt(n(305,"7M4#"))+parseInt(n(319,"d%e%"))/2+-parseInt(n(314,"Poif"))/3+parseInt(n(309,"0r4c"))/4+-parseInt(n(320,"ntm5"))/5*(-parseInt(n(311,"tKdt"))/6)+-parseInt(n(315,"6GvJ"))/7+-parseInt(n(307,"tKdt"))/8)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x1f811a(325,"QQjk")](_0x1f811a(323,")#E#"))!=_0x1f811a(321,"d%e%"))throw window[_0x1f811a(318,"#2Mw")][_0x1f811a(313,"t5K3")](_0x1f811a(306,")#E#")),Error();document.title="jest 快照测试",document.getElementById("article").innerHTML='<div><h3>Jest 快照测试详解</h3>\n<h4>一、什么是 Jest 快照测试？</h4>\n<p>Jest 快照测试是一种用于捕获和比较代码输出（如组件渲染结果）的测试方法。它主要用于 React 组件测试，但也可以用于其他需要验证输出一致性的场景。快照测试通过保存代码输出的“快照”，并在后续测试中与新的输出进行比较，来确保代码输出没有意外变化。</p>\n<h4>二、快照测试的工作原理</h4>\n<ol>\n<li><strong>生成快照</strong>  ：\n<ul>\n<li>首次运行测试时，Jest 会将组件的渲染结果（或其他需要测试的输出）序列化为一个快照文件（通常位于 <code>__snapshots__</code> 目录下）。</li>\n<li>快照文件以 <code>.snap</code> 为扩展名，并包含测试名称和对应的输出数据。</li>\n</ul>\n</li>\n<li><strong>比较快照</strong>  ：\n<ul>\n<li>在后续测试中，Jest 会重新渲染组件（或执行其他测试逻辑），并将新的输出与快照文件中的数据进行比较。</li>\n<li>如果输出与快照不匹配，测试将失败，并显示差异。</li>\n</ul>\n</li>\n<li><strong>更新快照</strong>  ：\n<ul>\n<li>如果输出变化是预期的（例如，组件的样式或结构发生了有意修改），开发者可以使用 Jest 提供的命令来更新快照文件。</li>\n</ul>\n</li>\n</ol>\n<h4>三、快照测试的优点</h4>\n<ol>\n<li><strong>快速反馈</strong>  ：\n<ul>\n<li>快照测试可以迅速发现组件输出是否发生变化，帮助开发者及时识别潜在问题。</li>\n</ul>\n</li>\n<li><strong>易于使用</strong>  ：\n<ul>\n<li>Jest 的快照测试 API 非常简洁，开发者只需在测试用例中调用 <code>toMatchSnapshot()</code> 方法即可。</li>\n</ul>\n</li>\n<li><strong>提高代码质量</strong>  ：\n<ul>\n<li>通过确保组件输出的一致性，快照测试有助于维护代码的稳定性和可靠性。</li>\n</ul>\n</li>\n</ol>\n<h4>四、快照测试的局限性</h4>\n<ol>\n<li><strong>误报</strong>  ：\n<ul>\n<li>如果组件输出发生变化，但变化是预期的（例如，样式调整或文本修改），快照测试将失败，需要手动更新快照。</li>\n</ul>\n</li>\n<li><strong>难以调试</strong>  ：\n<ul>\n<li>当快照测试失败时，开发者需要仔细比较差异，以确定变化是否预期。对于复杂的组件输出，这可能比较困难。</li>\n</ul>\n</li>\n<li><strong>不适用于所有场景</strong>  ：\n<ul>\n<li>快照测试主要适用于验证组件的渲染结果或类似场景。对于逻辑复杂或涉及外部依赖的测试，快照测试可能不够灵活。</li>\n</ul>\n</li>\n</ol>\n<h4>五、如何编写 Jest 快照测试</h4>\n<p>以下是一个简单的 React 组件快照测试示例：</p>\n<pre><code class="language-jsx"><span class="hljs-comment">// MyComponent.js</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">MyComponent</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, World!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n};\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">MyComponent</span>;\n\n<span class="hljs-comment">// MyComponent.test.js</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n<span class="hljs-keyword">import</span> renderer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-test-renderer&#x27;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./MyComponent&#x27;</span>;\n\n<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;MyComponent renders correctly&#x27;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> tree = renderer.<span class="hljs-title function_">create</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>).<span class="hljs-title function_">toJSON</span>();\n  <span class="hljs-title function_">expect</span>(tree).<span class="hljs-title function_">toMatchSnapshot</span>();\n});\n</code></pre>\n<pre><code>// HelloWorld.spec.js\nimport { mount } from \'@vue/test-utils\';\nimport HelloWorld from \'@/components/HelloWorld.vue\';\n\ndescribe(\'HelloWorld.vue\', () =&gt; {\n  it(\'renders correctly\', () =&gt; {\n    const wrapper = mount(HelloWorld);\n    expect(wrapper.html()).toMatchSnapshot();\n  });\n});\n</code></pre>\n<p><strong>步骤说明</strong>  ：</p>\n<ol>\n<li><strong>渲染组件</strong>  ：\n<ul>\n<li>使用 <code>react-test-renderer</code> 的 <code>create</code> 方法渲染组件。</li>\n</ul>\n</li>\n<li><strong>生成快照</strong>  ：\n<ul>\n<li>调用 <code>toJSON()</code> 方法将渲染结果转换为 JSON 格式。</li>\n<li>使用 <code>expect(tree).toMatchSnapshot()</code> 方法将 JSON 结果与快照文件进行比较。</li>\n</ul>\n</li>\n</ol>\n<h4>六、最佳实践</h4>\n<ol>\n<li><strong>谨慎使用</strong>  ：\n<ul>\n<li>快照测试适用于验证组件的渲染结果等场景，但不应过度依赖。对于逻辑复杂的测试，应使用其他测试方法。</li>\n</ul>\n</li>\n<li><strong>定期审查快照</strong>  ：\n<ul>\n<li>定期审查快照文件，确保它们仍然反映组件的预期输出。</li>\n</ul>\n</li>\n<li><strong>结合其他测试方法</strong>  ：\n<ul>\n<li>快照测试应与其他测试方法（如单元测试、集成测试）结合使用，以全面验证代码的正确性。</li>\n</ul>\n</li>\n<li><strong>处理快照更新</strong>  ：\n<ul>\n<li>当快照测试失败时，仔细分析差异，确定变化是否预期。如果是预期变化，及时更新快照文件。</li>\n</ul>\n</li>\n</ol>\n<h4>七、总结</h4>\n<p>Jest 快照测试是一种强大的工具，用于验证组件输出的一致性。它易于使用、快速反馈，但也有一些局限性。通过谨慎使用、定期审查快照和结合其他测试方法，开发者可以充分利用快照测试的优势，提高代码质量和稳定性。</p>\n</div>'</script></body></html>