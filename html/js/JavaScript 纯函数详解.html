<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x478a(){var s=["WRO6lCkiWRSkWRddPq","W6ZdSCkqWQ5wWQ/cKSo4W5hcPbH4uq","txRdOI9IW4ORy8kq","lmo9m8kbkCkoWRRdMZ8","kdNdTJjb","ybbBW6RdO8kBWP/cPSk4WQlcV8km","t3VdPfqWW4amwCkEk8kq","W4VdLGNcHN7dKZnPW5i","zL/dOgGLW5tcPInR","sSkRrCoJWRuPWQbj","W67dSSkCWQrDWQJdP8ojW4hcKWjM","vmomumk3hmkXwbhcMSoEzba","W4m2WQBcKuDGW5xdRvGAW7VdPHK","rSobWR3dNSoxW53dL8kYjCkpiq","F8ouWONdQaFcRgddUa0","F8otWO3cKKVdJd3dPXrHcCkfrG","xSoOW4ddHSkoqqq","zrXDWPBcG8otWRxcPCk0","WPGXt8kdgre/W47cVxqbWR0","W79jgCkCDKxdQs3cLa","Fmk0WPBcPCoodcrrWQHIW4ldMW","WRNcHf3cJg7dMJXBW4y","aXFdOZRcM8oCW57dHsBdRHay","zfRdOM02W4/cOHzD","srrKyNvwW6T3WP1SwqLJW5GaW5GIW5VdSCokC8kGohK9WO0","W5nHWQhdMZ3dMSoTnG","W7NcL0tcGCkfW7ZdPG","fCoKW67cUCoMWQVdLSoPW6X5W6BcO8oP"];return(_0x478a=function(){return s})()}var _0x427d32=_0x3635;function _0x3635(p,s){var c=_0x478a();return(_0x3635=function(s,n){var a=c[s-=326];void 0===_0x3635.ctkPnG&&(_0x3635.MuZzQg=function(s,n){var a,l=[],p=0,c="";for(s=(s=>{for(var n,a,l="",p="",c=0,t=0;a=s.charAt(t++);~a&&(n=c%4?64*n+a:a,c++%4)&&(l+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,r=l.length;e<r;e++)p+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(p)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)p=(p+l[t]+n.charCodeAt(t%n.length))%256,a=l[t],l[t]=l[p],l[p]=a;for(var t=0,p=0,e=0;e<s.length;e++)a=l[t=(t+1)%256],l[t]=l[p=(p+l[t])%256],l[p]=a,c+=String.fromCharCode(s.charCodeAt(e)^l[(l[t]+l[p])%256]);return c},p=arguments,_0x3635.ctkPnG=!0);var s=s+c[0],l=p[s];return l?a=l:(void 0===_0x3635.rCKrZB&&(_0x3635.rCKrZB=!0),a=_0x3635.MuZzQg(a,n),p[s]=a),a})(p,s)}if((()=>{for(var s=_0x3635,n=_0x478a();;)try{if(189817==+parseInt(s(336,")AbJ"))*(-parseInt(s(335,"8QXl"))/2)+-parseInt(s(348,"6b9("))/3+parseInt(s(339,"8QXl"))/4*(-parseInt(s(350,"Otu]"))/5)+-parseInt(s(343,"ZJy#"))/6+-parseInt(s(332,"orWu"))/7+-parseInt(s(338,"Otu]"))/8*(-parseInt(s(342,"FtQc"))/9)+-parseInt(s(347,"6b9("))/10*(-parseInt(s(351,"lHAg"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x427d32(331,"yjcv")](_0x427d32(340,"^ATn"))!=_0x427d32(337,"V]AQ"))throw window[_0x427d32(333,"UfkD")][_0x427d32(349,"dVtL")](_0x427d32(329,"!$t4")),Error();document.title="JavaScript 纯函数详解",document.getElementById("article").innerHTML='<div><p>纯函数是函数式编程中的核心概念，理解纯函数对于编写可维护、可测试的代码至关重要。以下是关于 JavaScript 纯函数的全面解析：</p>\n<h2>一、纯函数的定义</h2>\n<p>纯函数必须满足两个基本条件：</p>\n<ol>\n<li><strong>相同输入总是产生相同输出</strong></li>\n<li><strong>不产生副作用</strong></li>\n</ol>\n<h3>纯函数示例</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 纯函数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) {\n  <span class="hljs-keyword">return</span> a + b;\n}\n\n<span class="hljs-comment">// 非纯函数</span>\n<span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> ++counter; <span class="hljs-comment">// 依赖外部状态且修改了它</span>\n}\n</code></pre>\n<h2>二、纯函数的特征</h2>\n<h3>1. 无状态性</h3>\n<p>纯函数不依赖也不改变函数外部的任何状态</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 不纯 - 依赖外部变量</span>\n<span class="hljs-keyword">const</span> minAge = <span class="hljs-number">18</span>;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">isEligible</span>(<span class="hljs-params">age</span>) {\n  <span class="hljs-keyword">return</span> age &gt;= minAge;\n}\n\n<span class="hljs-comment">// 纯化版本</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">isEligible</span>(<span class="hljs-params">age, minAge</span>) {\n  <span class="hljs-keyword">return</span> age &gt;= minAge;\n}\n</code></pre>\n<h3>2. 无副作用</h3>\n<p>不会修改任何外部变量、对象或执行I/O操作</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 不纯 - 修改了输入参数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateUser</span>(<span class="hljs-params">user</span>) {\n  user.<span class="hljs-property">lastUpdated</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();\n  <span class="hljs-keyword">return</span> user;\n}\n\n<span class="hljs-comment">// 纯化版本</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateUser</span>(<span class="hljs-params">user</span>) {\n  <span class="hljs-keyword">return</span> {\n    ...user,\n    <span class="hljs-attr">lastUpdated</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()\n  };\n}\n</code></pre>\n<h3>3. 引用透明性</h3>\n<p>函数调用可以被其返回值替代而不影响程序行为</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 5</span>\n<span class="hljs-comment">// 程序中所有add(2,3)都可以直接替换为5</span>\n</code></pre>\n<h2>三、纯函数的优势</h2>\n<h3>1. 可预测性</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 无论调用多少次，结果都相同</span>\n<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 永远是5</span>\n</code></pre>\n<h3>2. 易于测试</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 不需要mock或setup</span>\n<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;add function&#x27;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">5</span>);\n});\n</code></pre>\n<h3>3. 可缓存性</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 简单缓存实现</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">memoize</span>(<span class="hljs-params">fn</span>) {\n  <span class="hljs-keyword">const</span> cache = {};\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) {\n    <span class="hljs-keyword">const</span> key = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(args);\n    <span class="hljs-keyword">return</span> cache[key] || (cache[key] = fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args));\n  };\n}\n\n<span class="hljs-keyword">const</span> memoizedAdd = <span class="hljs-title function_">memoize</span>(add);\n<span class="hljs-title function_">memoizedAdd</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 计算并缓存</span>\n<span class="hljs-title function_">memoizedAdd</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 直接从缓存返回</span>\n</code></pre>\n<h3>4. 并行安全</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 可以安全地在不同线程/worker中运行</span>\n<span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([\n  <span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>),\n  <span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>),\n  <span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) \n]); <span class="hljs-comment">// [5, 5, 5]</span>\n</code></pre>\n<h2>四、常见的非纯函数操作</h2>\n<h3>1. 修改外部变量</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">addToTotal</span>(<span class="hljs-params">amount</span>) {\n  total += amount; <span class="hljs-comment">// 副作用</span>\n}\n</code></pre>\n<h3>2. 修改输入参数</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateConfig</span>(<span class="hljs-params">config</span>) {\n  config.<span class="hljs-property">lastUpdated</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(); <span class="hljs-comment">// 副作用</span>\n}\n</code></pre>\n<h3>3. I/O 操作</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">saveUser</span>(<span class="hljs-params">user</span>) {\n  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(user)); <span class="hljs-comment">// 副作用</span>\n}\n</code></pre>\n<h3>4. 随机数/时间</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getRandom</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(); <span class="hljs-comment">// 不同输出</span>\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">getTimestamp</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 不同输出</span>\n}\n</code></pre>\n<h2>五、如何编写纯函数</h2>\n<h3>1. 依赖注入</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 不纯</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">getUrl</span>(<span class="hljs-params">path</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">window</span>.location.origin}</span><span class="hljs-subst">${path}</span>`</span>;\n}\n\n<span class="hljs-comment">// 纯化</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">getUrl</span>(<span class="hljs-params">baseUrl, path</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${baseUrl}</span><span class="hljs-subst">${path}</span>`</span>;\n}\n</code></pre>\n<h3>2. 拷贝而非修改</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 不纯</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">addItemToCart</span>(<span class="hljs-params">cart, item</span>) {\n  cart.<span class="hljs-title function_">push</span>(item);\n  <span class="hljs-keyword">return</span> cart;\n}\n\n<span class="hljs-comment">// 纯化</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">addItemToCart</span>(<span class="hljs-params">cart, item</span>) {\n  <span class="hljs-keyword">return</span> [...cart, item];\n}\n</code></pre>\n<h3>3. 隔离副作用</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 将纯逻辑与非纯操作分离</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">processUser</span>(<span class="hljs-params">user</span>) {\n  <span class="hljs-comment">// 纯函数部分</span>\n  <span class="hljs-keyword">const</span> validated = <span class="hljs-title function_">validateUser</span>(user);\n  <span class="hljs-keyword">const</span> normalized = <span class="hljs-title function_">normalizeUser</span>(validated);\n  \n  <span class="hljs-comment">// 副作用集中处理</span>\n  <span class="hljs-title function_">saveUser</span>(normalized);\n  \n  <span class="hljs-keyword">return</span> normalized;\n}\n</code></pre>\n<h2>六、实际应用示例</h2>\n<h3>1. Redux Reducer</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 必须是纯函数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">todoReducer</span>(<span class="hljs-params">state = [], action</span>) {\n  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>:\n      <span class="hljs-keyword">return</span> [...state, action.<span class="hljs-property">payload</span>];\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;REMOVE_TODO&#x27;</span>:\n      <span class="hljs-keyword">return</span> state.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.<span class="hljs-property">id</span> !== action.<span class="hljs-property">payload</span>);\n    <span class="hljs-attr">default</span>:\n      <span class="hljs-keyword">return</span> state;\n  }\n}\n</code></pre>\n<h3>2. React 组件</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 纯函数组件</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params">{ user }</span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Joined: {formatDate(user.joinDate)}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h3>3. 数据处理管道</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 纯函数组合</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">processOrders</span>(<span class="hljs-params">orders</span>) {\n  <span class="hljs-keyword">return</span> orders\n    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;completed&#x27;</span>)\n    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> ({\n      ...o,\n      <span class="hljs-attr">total</span>: <span class="hljs-title function_">calculateTotal</span>(o.<span class="hljs-property">items</span>)\n    }))\n    .<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.<span class="hljs-property">total</span> - a.<span class="hljs-property">total</span>);\n}\n</code></pre>\n<h2>七、纯函数的局限性</h2>\n<ol>\n<li><strong>不能完全避免副作用</strong>  ：程序最终需要与外界交互</li>\n<li><strong>性能考虑</strong>  ：大量数据拷贝可能影响性能</li>\n<li><strong>学习曲线</strong>  ：需要改变传统编程思维</li>\n</ol>\n<h2>八、最佳实践</h2>\n<ol>\n<li><strong>尽量隔离副作用</strong>  ：将纯逻辑与非纯操作分开</li>\n<li><strong>使用不可变数据</strong>  ：避免意外修改</li>\n<li><strong>函数尽量小</strong>  ：单一职责原则</li>\n<li><strong>合理组合</strong>  ：通过组合小纯函数构建复杂逻辑</li>\n</ol>\n<p>纯函数是构建可靠软件的重要工具，虽然不能也不应该在所有场景中使用，但在适合的场景下能显著提高代码质量。</p>\n</div>'</script></body></html>