<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x596df3=_0x22e7;if((()=>{for(var s=_0x22e7,n=_0x3a29();;)try{if(803550==+parseInt(s(186,"C&Qv"))*(parseInt(s(195,"Otb*"))/2)+-parseInt(s(190,"i8t)"))/3*(-parseInt(s(189,"oD]V"))/4)+parseInt(s(205,"VrmQ"))/5*(parseInt(s(185,"uBvp"))/6)+parseInt(s(193,"[nkP"))/7+-parseInt(s(197,"Otb*"))/8+-parseInt(s(178,"KVf)"))/9*(-parseInt(s(200,"uBvp"))/10)+-parseInt(s(182,"Dd8g"))/11*(parseInt(s(194,"imap"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x596df3(179,"9d*V")](_0x596df3(198,"GF&i"))!=_0x596df3(177,"C&Qv"))throw window[_0x596df3(181,"KVf)")][_0x596df3(183,"*All")](_0x596df3(199,"3GM(")),Error();function _0x22e7(l,s){var e=_0x3a29();return(_0x22e7=function(s,n){var a=e[s-=177];void 0===_0x22e7.dslXrj&&(_0x22e7.tKbzCC=function(s,n){var a,t=[],l=0,e="";for(s=(s=>{for(var n,a,t="",l="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=t.length;c<o;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)l=(l+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[l],t[l]=a;for(var p=0,l=0,c=0;c<s.length;c++)a=t[p=(p+1)%256],t[p]=t[l=(l+t[p])%256],t[l]=a,e+=String.fromCharCode(s.charCodeAt(c)^t[(t[p]+t[l])%256]);return e},l=arguments,_0x22e7.dslXrj=!0);var s=s+e[0],t=l[s];return t?a=t:(void 0===_0x22e7.sXaYdz&&(_0x22e7.sXaYdz=!0),a=_0x22e7.tKbzCC(a,n),l[s]=a),a})(l,s)}function _0x3a29(){var s=["W6aOW4Gyfw7cHYBcQCkzCZC","zhGTW5GOqdNcRv0vCq","dmk3WONdSSkbW608WQCLCSopWQi","x8kfmKBdMCo6WQhcRW0","eSork8oJWQpdU8kCWP9uimonW48B","istcHYJcGCorW7vxWRbB","FKdcThbIW48jy0FdRG","WRZcUhJdLSoqbrbqBannCJy","WOrsWQFdLmoKW5RcKCk4WOhdHW","W512WOHbBcNdLmo5CmkuWOpcJCoI","WOnBW6RcMSoBW4JcSmkB","W6L8WO9Ag0vuWP0","WRFcO8oxW5WIrSkMuG","W6f3W5qcsJSjWOtdPKjLDcu","k2/dImoHWPyPpCkCxG","yCkQqdnWtf11fbKzWPZcKuKjeZjwiCound8UBJpcQa","yN8QW5yRjbRcM3eNCCk8","ociElSo2W4/dRhOu","W5BdN8oxqmkqvCktn8o+W5zejW","t8o0yCo4z0tdLWO","WPRcSgiBD8kbhN3dI8oh","c8oPvL52vmoSEci","tSoWW4ZcSmom","WRlcUN/cLCkIq0viBq","rmkFn8kHWReXW4W","W5RdRZtcILSujCo5omkGsG","W6JdPs/cHCkuwuzO","W5FdPSo9WOFcImotq27cLeRcN8kmWQjC","WRBdOCoHW6ysfqC"];return(_0x3a29=function(){return s})()}document.title="redux 原理详解",document.getElementById("article").innerHTML='<div><p>Redux 是一个用于 JavaScript 应用的可预测状态管理库，其核心设计基于 单向数据流 和 不可变状态，适用于 React、Vue 等前端框架。下面从 核心概念、数据流、源码实现 等方面深入解析 Redux 的工作原理。</p>\n<hr>\n<p><strong>1. Redux 三大核心原则</strong><br>\n<strong>(1) 单一数据源（Single Source of Truth）</strong></p>\n<ul>\n<li>\n<p>整个应用的状态存储在一个 Store（JavaScript 对象）中。</p>\n</li>\n<li>\n<p>便于调试（如 Redux DevTools 时间旅行）、状态持久化、服务端渲染。</p>\n</li>\n</ul>\n<p><strong>(2) 状态是只读的（State is Read-Only）</strong></p>\n<ul>\n<li>\n<p>唯一修改状态的方式是派发 Action（<code>dispatch(action)</code>）。</p>\n</li>\n<li>\n<p>禁止直接修改 <code>store.getState()</code>，确保状态变化的可预测性。</p>\n</li>\n</ul>\n<p><strong>(3) 使用纯函数修改状态（Changes via Pure Functions）</strong></p>\n<ul>\n<li>\n<p>Reducer 是一个纯函数，接收 <code>(state, action)</code>，返回新状态。</p>\n</li>\n<li>\n<p>纯函数特性：</p>\n<ul>\n<li>\n<p>无副作用（不修改外部变量、不调用 API）。</p>\n</li>\n<li>\n<p>相同输入 → 相同输出（可预测）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>2. Redux 核心组成</strong><br>\n<strong>(1) Action</strong></p>\n<ul>\n<li>\n<p>一个普通 JavaScript 对象，描述“发生了什么”。</p>\n</li>\n<li>\n<p>必须包含 <code>type</code> 字段（字符串常量），其他字段可自定义（如 <code>payload</code>）。</p>\n</li>\n<li>\n<p>示例：</p>\n</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> incrementAction = { <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-number">1</span> };\n</code></pre>\n<p><strong>(2) Reducer</strong></p>\n<ul>\n<li>\n<p>纯函数，接收 <code>(state, action)</code>，返回新状态。</p>\n</li>\n<li>\n<p>必须返回新对象（不可直接修改 <code>state</code>）。</p>\n</li>\n<li>\n<p>示例：</p>\n</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">counterReducer</span>(<span class="hljs-params">state = <span class="hljs-number">0</span>, action</span>) {\n  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;INCREMENT&#x27;</span>:\n      <span class="hljs-keyword">return</span> state + action.<span class="hljs-property">payload</span>; <span class="hljs-comment">// 返回新值，而非修改原 state</span>\n    <span class="hljs-attr">default</span>:\n      <span class="hljs-keyword">return</span> state; <span class="hljs-comment">// 默认返回原 state</span>\n  }\n}\n</code></pre>\n<p><strong>(3) Store</strong></p>\n<ul>\n<li>\n<p>通过 <code>createStore(reducer)</code> 创建，核心方法：</p>\n<ul>\n<li>\n<p><code>store.getState()</code>：获取当前状态。</p>\n</li>\n<li>\n<p><code>store.dispatch(action)</code>：派发 Action，触发 Reducer。</p>\n</li>\n<li>\n<p><code>store.subscribe(listener)</code>：订阅状态变化（如 UI 更新）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>3. Redux 数据流（单向数据流）</strong></p>\n<ol>\n<li>用户触发 Action（如点击按钮）：<pre><code class="language-javascript">store.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-number">1</span> });\n</code></pre>\n</li>\n<li>Redux 调用 Reducer：</li>\n</ol>\n<ul>\n<li>Store 调用 <code>counterReducer(state, action)</code>，计算新状态。</li>\n</ul>\n<ol start="3">\n<li>更新 Store：</li>\n</ol>\n<ul>\n<li>Store 保存新状态，并通知所有订阅者（如 React 组件）。</li>\n</ul>\n<ol start="4">\n<li>UI 更新：</li>\n</ol>\n<ul>\n<li>订阅者（如 <code>useSelector</code>）获取新状态，重新渲染。</li>\n</ul>\n<p>流程图：</p>\n<pre><code>Action → Dispatch → Reducer → Store → UI\n</code></pre>\n<hr>\n<p><strong>4. Redux 源码实现（简化版）</strong><br>\n<strong>(1) <code>createStore</code> 核心逻辑</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createStore</span>(<span class="hljs-params">reducer</span>) {\n  <span class="hljs-keyword">let</span> state; <span class="hljs-comment">// 当前状态</span>\n  <span class="hljs-keyword">const</span> listeners = []; <span class="hljs-comment">// 订阅者列表</span>\n\n  <span class="hljs-comment">// 获取当前状态</span>\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">getState</span> = (<span class="hljs-params"></span>) =&gt; state;\n\n  <span class="hljs-comment">// 派发 Action</span>\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">dispatch</span> = (<span class="hljs-params">action</span>) =&gt; {\n    state = <span class="hljs-title function_">reducer</span>(state, action); <span class="hljs-comment">// 调用 Reducer 计算新状态</span>\n    listeners.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">listener</span> =&gt;</span> <span class="hljs-title function_">listener</span>()); <span class="hljs-comment">// 通知所有订阅者</span>\n  };\n\n  <span class="hljs-comment">// 订阅状态变化</span>\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">subscribe</span> = (<span class="hljs-params">listener</span>) =&gt; {\n    listeners.<span class="hljs-title function_">push</span>(listener);\n    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> listeners.<span class="hljs-title function_">splice</span>(listeners.<span class="hljs-title function_">indexOf</span>(listener), <span class="hljs-number">1</span>); <span class="hljs-comment">// 取消订阅</span>\n  };\n\n  <span class="hljs-comment">// 初始化状态（调用一次 Reducer）</span>\n  <span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;@@INIT&#x27;</span> });\n\n  <span class="hljs-keyword">return</span> { getState, dispatch, subscribe };\n}\n</code></pre>\n<p><strong>(2) <code>combineReducers</code>（合并多个 Reducer）</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">combineReducers</span>(<span class="hljs-params">reducers</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">state = {}, action</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> newState = {};\n    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(reducers).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {\n      newState[key] = reducers[key](state[key], action);\n    });\n    <span class="hljs-keyword">return</span> newState;\n  };\n}\n</code></pre>\n<hr>\n<p><strong>5. Redux 中间件（Middleware）</strong><br>\n<strong>(1) 中间件的作用</strong></p>\n<ul>\n<li>\n<p>扩展 <code>dispatch</code> 能力，如：</p>\n<ul>\n<li>\n<p>异步 Action（<code>redux-thunk</code>、<code>redux-saga</code>）。</p>\n</li>\n<li>\n<p>日志记录（<code>redux-logger</code>）。</p>\n</li>\n<li>\n<p>错误处理。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>(2) 中间件原理（洋葱模型）</strong></p>\n<ul>\n<li>\n<p>拦截 <code>dispatch</code>，在 Action 到达 Reducer 前执行额外逻辑。</p>\n</li>\n<li>\n<p>示例：<code>redux-thunk</code> 实现：</p>\n</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">thunkMiddleware</span> = (<span class="hljs-params">{ dispatch, getState }</span>) =&gt; <span class="hljs-function"><span class="hljs-params">next</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">action</span> =&gt;</span> {\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> action === <span class="hljs-string">&#x27;function&#x27;</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">action</span>(dispatch, getState); <span class="hljs-comment">// 处理函数式 Action（如异步操作）</span>\n  }\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>(action); <span class="hljs-comment">// 普通 Action 直接传递</span>\n};\n</code></pre>\n<p><strong>(3) <code>applyMiddleware</code> 实现</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">applyMiddleware</span>(<span class="hljs-params">...middlewares</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">createStore</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">reducer</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer);\n    <span class="hljs-keyword">let</span> dispatch = store.<span class="hljs-property">dispatch</span>;\n\n    <span class="hljs-comment">// 增强 dispatch</span>\n    middlewares.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">middleware</span> =&gt;</span> {\n      dispatch = <span class="hljs-title function_">middleware</span>(store)(dispatch);\n    });\n\n    <span class="hljs-keyword">return</span> { ...store, dispatch }; <span class="hljs-comment">// 返回增强后的 store</span>\n  };\n}\n</code></pre>\n<hr>\n<p><strong>6. React-Redux 连接原理</strong><br>\n<strong>(1) <code>Provider</code>（通过 Context 传递 Store）</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ReduxContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Provider</span>(<span class="hljs-params">{ store, children }</span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ReduxContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{store}</span>&gt;</span>\n      {children}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">ReduxContext.Provider</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p><strong>(2) <code>useSelector</code> 和 <code>useDispatch</code>（Hooks 方式）</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useSelector</span>(<span class="hljs-params">selector</span>) {\n  <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ReduxContext</span>);\n  <span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(<span class="hljs-title function_">selector</span>(store.<span class="hljs-title function_">getState</span>()));\n\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-keyword">return</span> store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-title function_">setState</span>(<span class="hljs-title function_">selector</span>(store.<span class="hljs-title function_">getState</span>()));\n    });\n  }, [store]);\n\n  <span class="hljs-keyword">return</span> state;\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">useDispatch</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ReduxContext</span>);\n  <span class="hljs-keyword">return</span> store.<span class="hljs-property">dispatch</span>;\n};\n</code></pre>\n<hr>\n<p><strong>7. Redux 的不可变性（Immutability）</strong><br>\n<strong>(1) 为什么需要不可变？</strong></p>\n<ul>\n<li>\n<p>性能优化：浅比较即可判断状态是否变化（如 <code>React.memo</code>）。</p>\n</li>\n<li>\n<p>调试友好：Redux DevTools 可追溯状态变化历史。</p>\n</li>\n</ul>\n<p><strong>(2) 如何实现不可变？</strong></p>\n<ul>\n<li>手动方式（展开运算符）：</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">key</span>: newValue };\n</code></pre>\n<ul>\n<li>使用 <code>immer</code>（简化不可变更新）：</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> produce <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;immer&#x27;</span>;\n<span class="hljs-keyword">const</span> newState = <span class="hljs-title function_">produce</span>(state, <span class="hljs-function"><span class="hljs-params">draft</span> =&gt;</span> {\n  draft.<span class="hljs-property">key</span> = newValue; <span class="hljs-comment">// 直接修改 draft，但返回的是新对象</span>\n});\n</code></pre>\n<hr>\n<p><strong>8. Redux 异步处理方案</strong><br>\n<strong>(1) <code>redux-thunk</code>（函数式 Action）</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">async</span> (dispatch, getState) =&gt; {\n  <span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_START&#x27;</span> });\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/data&#x27;</span>);\n    <span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: res.<span class="hljs-property">data</span> });\n  } <span class="hljs-keyword">catch</span> (err) {\n    <span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_ERROR&#x27;</span>, <span class="hljs-attr">error</span>: err });\n  }\n};\n</code></pre>\n<p><strong>(2) <code>redux-saga</code>（基于 Generator）</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { call, put, takeEvery } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga/effects&#x27;</span>;\n\n<span class="hljs-keyword">function</span>* <span class="hljs-title function_">fetchDataSaga</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">call</span>(api.<span class="hljs-property">get</span>, <span class="hljs-string">&#x27;/data&#x27;</span>);\n    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">put</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: res.<span class="hljs-property">data</span> });\n  } <span class="hljs-keyword">catch</span> (err) {\n    <span class="hljs-keyword">yield</span> <span class="hljs-title function_">put</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_ERROR&#x27;</span>, <span class="hljs-attr">error</span>: err });\n  }\n}\n\n<span class="hljs-keyword">function</span>* <span class="hljs-title function_">rootSaga</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">yield</span> <span class="hljs-title function_">takeEvery</span>(<span class="hljs-string">&#x27;FETCH_REQUEST&#x27;</span>, fetchDataSaga);\n}\n</code></pre>\n<hr>\n<p><strong>9. Redux 的优缺点</strong><br>\n<strong>✅ 优点</strong></p>\n<ul>\n<li>\n<p>可预测性：单向数据流 + 纯函数 Reducer。</p>\n</li>\n<li>\n<p>调试友好：Redux DevTools 时间旅行。</p>\n</li>\n<li>\n<p>生态强大：中间件支持（如 <code>redux-thunk</code>、<code>redux-saga</code>）。</p>\n</li>\n</ul>\n<p><strong>❌ 缺点</strong></p>\n<ul>\n<li>\n<p>模板代码多：Action、Reducer、Store 分离。</p>\n</li>\n<li>\n<p>学习曲线陡峭：适用于复杂应用，小型项目可能过度设计。</p>\n</li>\n</ul>\n<p><strong>替代方案</strong></p>\n<ul>\n<li>\n<p>轻量级：<code>Zustand</code>、<code>Jotai</code>、<code>Recoil</code>。</p>\n</li>\n<li>\n<p>React 原生：<code>useReducer + Context</code>。</p>\n</li>\n</ul>\n<hr>\n<p><strong>总结</strong><br>\nRedux 的核心原理：</p>\n<ol>\n<li>单向数据流：<code>Action → Reducer → Store → UI</code>。</li>\n<li>不可变状态：Reducer 必须返回新对象。</li>\n<li>中间件机制：扩展 <code>dispatch</code> 能力（如异步处理）。</li>\n<li>React 集成：<code>Provider</code> + <code>useSelector/useDispatch</code>。</li>\n</ol>\n<p>掌握 Redux 的关键是理解 纯函数 Reducer 和 单向数据流，适用于中大型复杂应用的状态管理。</p>\n</div>'</script></body></html>