<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4db9(){var s=["u8kktSoPWQlcNCkL","DSkJCcXvgSkaCIBcGSovdSk4","wCoRuSkZW5tcUmkAW6iEW7JcGCoNW6m","DSkTCISOtmomCqhcOW","WRrIEueD","W7uueCkpW5mhjmoNWPZdQmkrW6VdUa","m8kWtvuaW6G9WRKAaqjpWP0BW47dKv1TrJ7cUfJdK8kAWOtcRa","fCo9DG/cM8oJdmouf24FlJ0","W6vpW6ZdPaqpaei","WRGxWRNcVuGSpgdcSb9E","WRtdLH/cJSkQW4OUEIRcM2q","pc3cJCo5WOvZFSkdqmkwF8ocfa","fSo1DG7cNCoHdComkM4coXe","B8oWW7LHWQddP8kTlCohW51CvZtcJa","EuqDW45nfSkvxSoNz8o2W6i","WQngW4/cNSoFW63dH8oACW","d0yzkKJcOCkyWOxdNYpdVW","FhJdICkHW5uHlG","W7CxeCkhW5fevmoUWRddS8kB","jSo5W4tdRW8gWRtdHSkpwrj4","WOrVWRKtCtVdLsKnrq","WRZdLmomW4agW7mKnezIWQzIA8kd"];return(_0x4db9=function(){return s})()}var _0x320830=_0x3854;function _0x3854(e,s){var p=_0x4db9();return(_0x3854=function(s,n){var a=p[s-=229];void 0===_0x3854.GBFxoy&&(_0x3854.bnhMiR=function(s,n){var a,l=[],e=0,p="";for(s=(s=>{for(var n,a,l="",e="",p=0,t=0;a=s.charAt(t++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=l.length;c<o;c++)e+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)e=(e+l[t]+n.charCodeAt(t%n.length))%256,a=l[t],l[t]=l[e],l[e]=a;for(var t=0,e=0,c=0;c<s.length;c++)a=l[t=(t+1)%256],l[t]=l[e=(e+l[t])%256],l[e]=a,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[t]+l[e])%256]);return p},e=arguments,_0x3854.GBFxoy=!0);var s=s+p[0],l=e[s];return l?a=l:(void 0===_0x3854.dZFApA&&(_0x3854.dZFApA=!0),a=_0x3854.bnhMiR(a,n),e[s]=a),a})(e,s)}if((()=>{for(var s=_0x3854,n=_0x4db9();;)try{if(755463==-parseInt(s(239,"ekY8"))+-parseInt(s(243,"2lP&"))/2+parseInt(s(244,"iZAA"))/3+-parseInt(s(236,"j3*y"))/4+-parseInt(s(232,"][Iq"))/5+-parseInt(s(240,"lA#$"))/6*(parseInt(s(238,"3c8f"))/7)+parseInt(s(233,"Jvn$"))/8)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x320830(242,"b1zB")](_0x320830(235,"*AX5"))!=_0x320830(246,"S1p6"))throw window[_0x320830(250,"@oVI")][_0x320830(237,"]@H*")](_0x320830(248,"pGy^")),Error();document.title="React 19 引入的 use 钩子是一个强大的新特性",document.getElementById("article").innerHTML='<div><p>React 19 引入的 <code>use</code> 钩子是一个强大的新特性，主要用于<strong>在组件中处理异步数据</strong>   （如 Promise），解决了以往在组件渲染过程中处理异步操作的痛点。它的设计简洁但功能灵活，尤其在结合服务器组件、数据获取等场景时非常实用。</p>\n<h3>核心作用</h3>\n<p><code>use</code> 钩子允许你在组件的渲染逻辑中直接“消费”一个 Promise，等待其 resolve 后再继续渲染，无需像 <code>useEffect</code> 那样通过状态间接处理异步结果。</p>\n<p>简单说：<strong><code>use</code> 能让你在组件中像写同步代码一样处理异步操作</strong>   。</p>\n<h3>基本用法</h3>\n<pre><code class="language-jsx"><span class="hljs-comment">// 示例：获取用户数据</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUser</span>(<span class="hljs-params">userId</span>) {\n  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/users/<span class="hljs-subst">${userId}</span>`</span>);\n  <span class="hljs-keyword">if</span> (!res.<span class="hljs-property">ok</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Failed to fetch user&quot;</span>);\n  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();\n}\n\n<span class="hljs-comment">// 组件中使用 use 处理异步</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params">{ userId }</span>) {\n  <span class="hljs-comment">// 直接在渲染过程中使用 use 等待 Promise 结果</span>\n  <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">use</span>(<span class="hljs-title function_">fetchUser</span>(userId));\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Email: {user.email}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h3>关键特性</h3>\n<ol>\n<li>\n<p><strong>处理 Promise 等待</strong><br>\n<code>use</code> 会暂停组件渲染，直到传入的 Promise 被 resolve，然后使用结果继续渲染。如果 Promise 被 reject，会抛出错误，可被 <code>ErrorBoundary</code> 捕获。</p>\n</li>\n<li>\n<p><strong>与 Suspense 配合</strong><br>\n可以结合 <code>React.Suspense</code> 为异步操作提供加载状态：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserPage</span>(<span class="hljs-params">{ userId }</span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">p</span>&gt;</span>Loading user...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>}&gt;\n      <span class="hljs-tag">&lt;<span class="hljs-name">UserProfile</span> <span class="hljs-attr">userId</span>=<span class="hljs-string">{userId}</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span>\n  );\n}\n</code></pre>\n</li>\n<li>\n<p><strong>支持上下文（Context）读取</strong><br>\n<code>use</code> 还可以直接读取 Context 的值（替代 <code>useContext</code>），并且能处理 Context 提供者可能异步加载的情况：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title function_">createContext</span>();\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemedButton</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 替代 useContext(ThemeContext)</span>\n  <span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">use</span>(<span class="hljs-title class_">ThemeContext</span>);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">background:</span> <span class="hljs-attr">theme.color</span> }}&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n</code></pre>\n</li>\n<li>\n<p><strong>避免重复请求</strong><br>\n当组件重渲染时，<code>use</code> 会自动复用之前的 Promise 结果（如果依赖未变），避免不必要的重复请求。</p>\n</li>\n</ol>\n<h3>与传统方式的对比</h3>\n<p>以往处理异步数据通常需要 <code>useState + useEffect</code>：</p>\n<pre><code class="language-jsx"><span class="hljs-comment">// 传统方式</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params">{ userId }</span>) {\n  <span class="hljs-keyword">const</span> [user, setUser] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);\n  <span class="hljs-keyword">const</span> [error, setError] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);\n\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-title function_">fetchUser</span>(userId)\n      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-title function_">setUser</span>(data))\n      .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-title function_">setError</span>(err));\n  }, [userId]);\n\n  <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Error: {error.message}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;\n  <span class="hljs-keyword">if</span> (!user) <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n<p>使用 <code>use</code> 后，代码更简洁，异步逻辑与渲染逻辑直接关联，无需手动管理加载/错误状态（可交给 <code>Suspense</code> 和 <code>ErrorBoundary</code>）。</p>\n<h3>注意事项</h3>\n<ol>\n<li>\n<p><strong>只能在组件顶层或自定义钩子中使用</strong>   ，不能在条件语句、循环或事件处理函数中调用（类似其他 React 钩子的规则）。</p>\n</li>\n<li>\n<p><strong>主要用于渲染阶段的异步依赖</strong>   ，事件处理中的异步操作（如点击后提交表单）仍需用 <code>async/await</code>，不适合用 <code>use</code>。</p>\n</li>\n<li>\n<p><strong>错误处理需配合 ErrorBoundary</strong>   ，<code>use</code> 不会捕获 Promise 的 reject，需要通过 React 的错误边界机制处理错误。</p>\n</li>\n<li>\n<p><strong>与服务器组件兼容</strong>   ，在服务器组件中使用 <code>use</code> 处理异步数据获取（如数据库查询）非常高效。</p>\n</li>\n</ol>\n<h3>适用场景</h3>\n<ul>\n<li>组件渲染依赖异步数据（如从 API 或数据库获取数据）</li>\n<li>处理需要等待的上下文（Context）</li>\n<li>简化与 <code>Suspense</code> 配合的异步加载逻辑</li>\n<li>服务器组件中的数据预取</li>\n</ul>\n<p><code>use</code> 钩子的引入，进一步强化了 React 对异步场景的支持，尤其是在服务器组件和全栈应用中，能大幅简化代码并提升开发效率。它不是要替代 <code>useEffect</code> 或 <code>async/await</code>，而是在“渲染阶段处理异步依赖”这一特定场景下提供了更优的解决方案。</p>\n</div>'</script></body></html>