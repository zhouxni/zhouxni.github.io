<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x111a(l,s){var p=_0x21d6();return(_0x111a=function(s,n){var a=p[s-=341];void 0===_0x111a.PGsMVx&&(_0x111a.BvYVou=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=t.length;o<c;o++)l+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,o=0;o<s.length;o++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(o)^t[(t[e]+t[l])%256]);return p},l=arguments,_0x111a.PGsMVx=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x111a.XcSmhM&&(_0x111a.XcSmhM=!0),a=_0x111a.BvYVou(a,n),l[s]=a),a})(l,s)}var _0x1e11dd=_0x111a;function _0x21d6(){var s=["qSkGWQ7dK8oSoCo0aCo1WPddNwq","o8oYWQ5iyYhdSehdVmozumk7WQG","CmkyD3/dTmkazZu","jZZdTvNcMhDdWOdcLvZcPGG","AbZdUSkWnmkrW6O","rCkRWOZcQCoQW6/dOWieFqLB","tCkgW5ddRCoOWOBcTmoVlmkmnZ4","o8kiWQSiW5RcNmoBWQ/dNmkhhbK","r8oSW7GhWQfeW7VdTa","ndXqWRxcT2iuAW","pCkiWQ4pW5NcMCo0WORdKCk8jb0","W7dcUSo1W5SQW7qjv3b3cq","WPtdP8oNaSk2WPjEASo9W5tdHSos","W7r/W7DDAmk5W5NcLCkqWPHXwG","z8olWODommk8t8ovk0D9sW","xmodWRJdPNhcPajd","WOu3lvyBlXWt","WQeUWRyMk8oOW4e","W4OiF8kqqWrMW4NdIdBcJCkh","WPFcHNfYW5rgWPlcOG","BcpdGSohW47cPmoXs34","xYxdKCooW5ZcTmoF","WPdcKI5ZWQxdLr58pmkcW6zyyW","smoaW7dcH8k5ymop","ECojW61jWPq","FN3cTXJdM3K9W4FcPvdcSdpcOSkvhNZcPConz8kEWR/cOIRdPNC7","s8klWPtcV8kpW7tcP8oo","W7bYW7jwASobW4RcK8kUWR9k"];return(_0x21d6=function(){return s})()}if((()=>{for(var s=_0x111a,n=_0x21d6();;)try{if(134958==+parseInt(s(349,"PlP%"))+-parseInt(s(365,"b@ae"))/2*(-parseInt(s(352,"PlP%"))/3)+-parseInt(s(342,"b@ae"))/4+parseInt(s(353,"F^@n"))/5*(parseInt(s(368,"pJ6&"))/6)+parseInt(s(361,"ITVq"))/7*(-parseInt(s(345,"Pggo"))/8)+parseInt(s(364,"cb1N"))/9+-parseInt(s(356,"Tyt&"))/10*(parseInt(s(344,"amCL"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1e11dd(359,"fbBK")](_0x1e11dd(362,"Z(w)"))!=_0x1e11dd(366,"PlP%"))throw window[_0x1e11dd(357,"Ustr")][_0x1e11dd(363,"Z(w)")](_0x1e11dd(367,"Pggo")),Error();document.title="vue3 响应式辅助",document.getElementById("article").innerHTML='<div><p>以下是针对图中五个 Vue 3 组合式 API 的详细解析，包含 <strong>核心作用</strong>   、<strong>代码示例</strong>   、<strong>使用场景</strong>   和 <strong>关键细节</strong>   ：</p>\n<hr>\n<h3>1. <code>useAttrs()</code></h3>\n<h4>作用</h4>\n<p>获取组件上未被 <code>props</code> 接收的所有属性（包括 <code>class</code>、<code>style</code> 和自定义属性）。</p>\n<h4>代码示例</h4>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;attrs&quot;</span>&gt;</span>透传所有未声明属性到子元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-keyword">import</span> { useAttrs } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n  <span class="hljs-keyword">const</span> attrs = <span class="hljs-title function_">useAttrs</span>();\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(attrs); <span class="hljs-comment">// { id: &#x27;foo&#x27;, &#x27;data-test&#x27;: &#x27;bar&#x27;, ... }</span>\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<h4>使用场景</h4>\n<ul>\n<li><strong>属性透传</strong>   ：将未知属性传递给子组件或 DOM 元素</li>\n<li><strong>高阶组件</strong>   ：包装组件时需要保留原始属性</li>\n</ul>\n<h4>注意细节</h4>\n<ul>\n<li><strong>优先级</strong>   ：<code>props</code> &gt; <code>attrs</code>（同名属性以 <code>props</code> 为准）</li>\n<li><strong>响应性</strong>   ：<code>attrs</code> 是响应式对象，但<strong>不应直接解构</strong>   （会失去响应性）</li>\n<li><strong>性能</strong>   ：避免在模板中过度使用 <code>v-bind=&quot;attrs&quot;</code>（可能造成不必要的 DOM 更新）</li>\n</ul>\n<hr>\n<h3>2. <code>useSlots()</code></h3>\n<h4>作用</h4>\n<p>访问组件的插槽内容，支持检查插槽是否存在或操作插槽节点。</p>\n<h4>代码示例</h4>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span> /&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;logSlotContent&quot;</span>&gt;</span>打印默认插槽内容<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-keyword">import</span> { useSlots } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n  <span class="hljs-keyword">const</span> slots = <span class="hljs-title function_">useSlots</span>();\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">logSlotContent</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-keyword">if</span> (slots.<span class="hljs-property">default</span>) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;默认插槽内容:&quot;</span>, slots.<span class="hljs-title function_">default</span>());\n    }\n  };\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<h4>使用场景</h4>\n<ul>\n<li><strong>动态插槽</strong>   ：根据条件渲染不同插槽内容</li>\n<li><strong>插槽检测</strong>   ：判断某个插槽是否被提供内容</li>\n<li><strong>渲染控制</strong>   ：在 JS 中操作插槽节点（如添加样式类）</li>\n</ul>\n<h4>注意细节</h4>\n<ul>\n<li><strong>作用域问题</strong>   ：插槽内容继承父组件作用域，非当前组件</li>\n<li><strong>渲染时机</strong>   ：<code>slots</code> 在 <code>beforeMount</code> 后才可用</li>\n<li><strong>性能</strong>   ：频繁调用插槽函数（如 <code>slots.default()</code>）可能影响性能</li>\n</ul>\n<hr>\n<h3>3. <code>useModel()</code></h3>\n<h4>作用</h4>\n<p>实现自定义组件的 <strong>双向绑定</strong>   （兼容 <code>v-model</code> 语法糖）。</p>\n<h4>代码示例</h4>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">CustomInput</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;searchText&quot;</span> /&gt;</span>\n\n<span class="hljs-comment">&lt;!-- 子组件 CustomInput.vue --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">input</span>\n    <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;modelValue&quot;</span>\n    @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span>\n  /&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-keyword">import</span> { useModel } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n  <span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>({\n    <span class="hljs-attr">count</span>: { <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>, <span class="hljs-attr">default</span>: <span class="hljs-number">0</span> }, <span class="hljs-comment">// 使用非默认 prop 名 &#x27;count&#x27;</span>\n  });\n  <span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&quot;update:count&quot;</span>]);\n\n  <span class="hljs-comment">// ✅ 正确用法 1：基础模式（自动关联 emit）</span>\n  <span class="hljs-keyword">const</span> autoModel = <span class="hljs-title function_">useModel</span>(props, <span class="hljs-string">&quot;count&quot;</span>);\n\n  <span class="hljs-comment">// ✅ 正确用法 2：自定义 setter 中手动 emit</span>\n  <span class="hljs-keyword">const</span> formattedModel = <span class="hljs-title function_">useModel</span>(props, <span class="hljs-string">&quot;count&quot;</span>, {\n    <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-string">`Count: <span class="hljs-subst">${value}</span>`</span>,\n    <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {\n      <span class="hljs-keyword">const</span> num = <span class="hljs-title class_">Number</span>(value.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;Count: &quot;</span>, <span class="hljs-string">&quot;&quot;</span>));\n      <span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;update:count&quot;</span>, num); <span class="hljs-comment">// 手动触发更新</span>\n      <span class="hljs-keyword">return</span> num;\n    },\n  });\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<h4>使用场景</h4>\n<ul>\n<li><strong>表单组件</strong>   ：自定义输入控件（如带验证的输入框）</li>\n<li><strong>状态同步</strong>   ：需要与父组件保持双向数据流</li>\n</ul>\n<h4>注意细节</h4>\n<ul>\n<li><strong>参数名</strong>   ：默认使用 <code>modelValue</code>，可通过第二参数修改（如 <code>useModel(props, \'count\', emit)</code>）</li>\n<li><strong>修饰符</strong>   ：需手动处理 <code>.trim</code> 等修饰符（通过 <code>props.modelModifiers</code>）</li>\n<li><strong>替代方案</strong>   ：简单场景可直接用 <code>computed</code> + <code>watch</code> 实现</li>\n</ul>\n<hr>\n<h3>4. <code>useTemplateRef()</code></h3>\n<h4>作用</h4>\n<p>安全地获取模板引用（<code>ref</code>），避免在生命周期中可能为 <code>null</code> 的问题。</p>\n<h4>代码示例</h4>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;inputRef&quot;</span> /&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-keyword">import</span> { useTemplateRef } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useTemplateRef</span>(<span class="hljs-string">&quot;inputRef&quot;</span>);\n  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> {\n    inputRef.<span class="hljs-property">value</span>?.<span class="hljs-title function_">focus</span>(); <span class="hljs-comment">// 自动处理 null 情况</span>\n  });\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<h4>使用场景</h4>\n<ul>\n<li><strong>DOM 操作</strong>   ：输入框聚焦、测量元素尺寸</li>\n<li><strong>子组件访问</strong>   ：调用子组件暴露的方法</li>\n</ul>\n<h4>注意细节</h4>\n<ul>\n<li><strong>来源</strong>   ：原生 Vue 3 未内置此 API，需通过 https://vueuse.org/ 库引入</li>\n<li><strong>生命周期</strong>   ：模板引用在 <code>beforeMount</code> 前为 <code>null</code></li>\n<li><strong>类型安全</strong>   ：配合 TypeScript 时需明确泛型类型（如 <code>useTemplateRef&lt;HTMLInputElement&gt;()</code>）</li>\n</ul>\n<hr>\n<h3>5. <code>useId()</code></h3>\n<h4>作用</h4>\n<p>生成唯一的静态 ID，常用于表单元素的关联。</p>\n<h4>代码示例</h4>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">:for</span>=<span class="hljs-string">&quot;inputId&quot;</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;inputId&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-keyword">import</span> { useId } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n  <span class="hljs-keyword">const</span> inputId = <span class="hljs-title function_">useId</span>(); <span class="hljs-comment">// 生成类似 &#x27;vue-uid-1&#x27; 的 ID</span>\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<h4>使用场景</h4>\n<ul>\n<li><strong>表单关联</strong>   ：<code>&lt;label&gt;</code> 与 <code>&lt;input&gt;</code> 的 <code>for</code>/<code>id</code> 绑定</li>\n<li><strong>SSR 兼容</strong>   ：确保服务端和客户端生成的 ID 一致</li>\n<li><strong>无障碍</strong>   ：为无文本内容元素添加可访问的 ID（如图标按钮）</li>\n</ul>\n<h4>注意细节</h4>\n<ul>\n<li><strong>稳定性</strong>   ：同一组件实例中 ID 保持不变</li>\n<li><strong>前缀</strong>   ：可通过 <code>useId(\'my-prefix-\')</code> 自定义前缀</li>\n<li><strong>冲突风险</strong>   ：避免在全局状态中使用（如多个根组件可能重复）</li>\n</ul>\n<hr>\n<h3>总结对比表</h3>\n<table>\n<thead>\n<tr>\n<th>API</th>\n<th>典型场景</th>\n<th>关键注意事项</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>useAttrs()</code></td>\n<td>属性透传、高阶组件</td>\n<td>避免解构，注意属性冲突</td>\n</tr>\n<tr>\n<td><code>useSlots()</code></td>\n<td>动态插槽、插槽检测</td>\n<td>作用域问题，渲染时机</td>\n</tr>\n<tr>\n<td><code>useModel()</code></td>\n<td>自定义表单组件双向绑定</td>\n<td>修饰符处理，多 <code>v-model</code> 支持</td>\n</tr>\n<tr>\n<td><code>useTemplateRef()</code></td>\n<td>DOM 操作、子组件方法调用</td>\n<td>需从 VueUse 引入，处理 null 情况</td>\n</tr>\n<tr>\n<td><code>useId()</code></td>\n<td>表单 ID 关联、SSR 兼容</td>\n<td>避免全局使用，前缀自定义</td>\n</tr>\n</tbody>\n</table>\n<p>如果需要更深入的组合使用案例（如 <code>useModel + useAttrs</code> 实现复杂表单组件），可以进一步探讨！</p>\n</div>'</script></body></html>