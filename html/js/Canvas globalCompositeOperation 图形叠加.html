<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1e5a03=_0x3efb;function _0x3efb(e,n){var a=_0x3668();return(_0x3efb=function(n,t){var s=a[n-=373];void 0===_0x3efb.HvwYnH&&(_0x3efb.WKLoxJ=function(n,t){var s,o=[],e=0,a="";for(n=(n=>{for(var t,s,o="",e="",a=0,r=0;s=n.charAt(r++);~s&&(t=a%4?64*t+s:s,a++%4)&&(o+=String.fromCharCode(255&t>>(-2*a&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var c=0,d=o.length;c<d;c++)e+="%"+("00"+o.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(n),r=0;r<256;r++)o[r]=r;for(r=0;r<256;r++)e=(e+o[r]+t.charCodeAt(r%t.length))%256,s=o[r],o[r]=o[e],o[e]=s;for(var r=0,e=0,c=0;c<n.length;c++)s=o[r=(r+1)%256],o[r]=o[e=(e+o[r])%256],o[e]=s,a+=String.fromCharCode(n.charCodeAt(c)^o[(o[r]+o[e])%256]);return a},e=arguments,_0x3efb.HvwYnH=!0);var n=n+a[0],o=e[n];return o?s=o:(void 0===_0x3efb.qstUIr&&(_0x3efb.qstUIr=!0),s=_0x3efb.WKLoxJ(s,t),e[n]=s),s})(e,n)}if((()=>{for(var n=_0x3efb,t=_0x3668();;)try{if(171704==+parseInt(n(378,"!9yJ"))+parseInt(n(393,"C4Kk"))/2+parseInt(n(384,"[McX"))/3+-parseInt(n(395,"CFgx"))/4*(parseInt(n(391,"U#cm"))/5)+-parseInt(n(375,"3b$*"))/6+-parseInt(n(381,"mVXd"))/7*(parseInt(n(392,"9]r5"))/8)+parseInt(n(388,"HH8e"))/9)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x1e5a03(382,"J&!c")](_0x1e5a03(374,"m9a9"))!=_0x1e5a03(380,"Tb!$"))throw window[_0x1e5a03(386,"eEE@")][_0x1e5a03(383,"3b$*")](_0x1e5a03(389,"NpSq")),new Error;function _0x3668(){var n=["nv9ZWR/dO8oCwCoQ","WRqtW5/cRCotW5CGwmkxWOJcS8kX","WRxcT8oJWRX9WRtdOSkbWPrQW63cKG","p8kLW4zyW7JcIehdKd/dU3ZcIKZdULT7W4ZcG8ogWPXmuCk6gbLw","WOi5bmo3W7WmWQ3cPCkjW6K","WPCegmokWQddHSomoX/dUCk7","W6hdUSotlmoXt1ZdM2POeW","hCkJESodCSk0emkjqrj/iW","WQ99wh07W67cSNa","cdDiWRxcUv3cSmo5","WRusW5hcOmorWOa2FCkgWRNcKq","s2jsnqpcGIeaW4yaW5fz","W5OSqw0lW5RcTLRdVq","WRxcSdaTcenNWOtdRmkVade","W7FcVdf6W5ukBYGeW68gW4u","W4a/W4mMgwKMWQxdJX1V","WQxcLgTBr1XdWPDgW60","WR/cVCkfW5GoW5VdHCkK","jSooWOBcVSk/","mcxcJmo2W653WO/dQa","WOHTW7j0W5KFWPS","W7pdPND1xrHB","WPCFww1cWPxcI8o+maddTmk9","gvDpWRZcH1RcVCkCvSo6w8kF"];return(_0x3668=function(){return n})()}document.title="Canvas globalCompositeOperation 图形叠加",document.getElementById("article").innerHTML='<div><p>这个问题问到了Canvas绘图的核心进阶技巧，理解它能让你的图形叠加效果更灵活！<strong>globalCompositeOperation</strong>   本质是定义新绘制图形（源）与Canvas上已存在图形（目标）的像素混合规则，共包含29种预定义模式。</p>\n<h3>一、核心概念：源与目标</h3>\n<p>在理解模式前，必须先明确两个关键角色：</p>\n<ul>\n<li><strong>源图形（Source）</strong>   ：你当前正要绘制的图形，比如刚调用的<code>fillRect()</code>或<code>drawImage()</code>。</li>\n<li><strong>目标图形（Destination）</strong>   ：已经绘制在Canvas上的图形，是源图形即将“作用”的对象。</li>\n</ul>\n<h3>二、常用模式分类与效果</h3>\n<p>29种模式可按功能分为5大类，日常开发中以下10种最常用，其余模式多为特殊场景或重复效果。</p>\n<table>\n<thead>\n<tr>\n<th>模式分类</th>\n<th>常用模式值</th>\n<th>效果说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>正常叠加</strong></td>\n<td><code>source-over</code>（默认）</td>\n<td>源图形覆盖在目标图形上方，源图形透明区域会显示目标图形。</td>\n</tr>\n<tr>\n<td><strong>反向叠加</strong></td>\n<td><code>destination-over</code></td>\n<td>目标图形覆盖在源图形上方，目标图形透明区域会显示源图形（与默认相反）。</td>\n</tr>\n<tr>\n<td><strong>仅保留区域</strong></td>\n<td><code>source-in</code></td>\n<td>只保留源图形与目标图形重叠的部分，非重叠区域（源和目标）均透明。</td>\n</tr>\n<tr>\n<td></td>\n<td><code>destination-in</code></td>\n<td>只保留目标图形与源图形重叠的部分，非重叠区域（源和目标）均透明。</td>\n</tr>\n<tr>\n<td></td>\n<td><code>source-out</code></td>\n<td>只保留源图形与目标图形<strong>不重叠</strong>   的部分，重叠区域透明。</td>\n</tr>\n<tr>\n<td></td>\n<td><code>destination-out</code></td>\n<td>只保留目标图形与源图形<strong>不重叠</strong>   的部分，重叠区域透明（可用于“擦除”）。</td>\n</tr>\n<tr>\n<td><strong>混合显示</strong></td>\n<td><code>lighter</code></td>\n<td>源图形与目标图形重叠区域的像素亮度相加，整体更亮（类似“发光”效果）。</td>\n</tr>\n<tr>\n<td></td>\n<td><code>multiply</code></td>\n<td>源图形与目标图形像素颜色相乘，结果更暗（类似“阴影叠加”效果）。</td>\n</tr>\n<tr>\n<td></td>\n<td><code>screen</code></td>\n<td>源图形与目标图形像素颜色反向相乘后再反向，结果更亮（类似“投影”效果）。</td>\n</tr>\n<tr>\n<td><strong>裁剪效果</strong></td>\n<td><code>xor</code></td>\n<td>源图形与目标图形重叠区域透明，非重叠区域正常显示（可用于“选区高亮”）。</td>\n</tr>\n</tbody>\n</table>\n<h3>三、使用步骤（附示例代码）</h3>\n<p>使用<code>globalCompositeOperation</code>只需3步，核心是<strong>在绘制“源图形”前设置模式</strong>   。</p>\n<ol>\n<li>获取Canvas上下文</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myCanvas&quot;</span>);\n<span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>);\n</code></pre>\n<ol start="2">\n<li>先绘制“目标图形”（已存在的图形）</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// 目标图形：红色矩形</span>\nctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;red&quot;</span>;\nctx.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);\n</code></pre>\n<ol start="3">\n<li>设置混合模式，再绘制“源图形”</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// 设置模式：仅保留重叠部分（source-in）</span>\nctx.<span class="hljs-property">globalCompositeOperation</span> = <span class="hljs-string">&quot;source-in&quot;</span>;\n\n<span class="hljs-comment">// 源图形：蓝色圆形</span>\nctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;blue&quot;</span>;\nctx.<span class="hljs-title function_">beginPath</span>();\nctx.<span class="hljs-title function_">arc</span>(<span class="hljs-number">150</span>, <span class="hljs-number">150</span>, <span class="hljs-number">60</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>);\nctx.<span class="hljs-title function_">fill</span>();\n</code></pre>\n<p><strong>效果</strong>   ：最终只会显示红矩形与蓝圆形重叠的“蓝色半圆”（非重叠区域透明）。</p>\n<h3>四、关键注意事项</h3>\n<ol>\n<li><strong>模式仅对“后续绘制”生效</strong>   ：设置<code>globalCompositeOperation</code>后，只影响之后调用的绘图API（如<code>fill()</code>、<code>stroke()</code>），对之前绘制的图形无影响。</li>\n<li><strong>透明像素会参与计算</strong>   ：若源/目标图形有透明通道（如<code>rgba(255,0,0,0.5)</code>），混合时会按透明度比例计算，而非直接忽略。</li>\n<li><strong>可重置为默认模式</strong>   ：完成特殊混合后，若需恢复正常绘图，可将模式设回<code>source-over</code>。</li>\n</ol>\n<h3>五、特殊场景应用</h3>\n<ul>\n<li><strong>擦除图形</strong>   ：用<code>destination-out</code>模式，绘制一个“源图形”，即可擦除目标图形中与源重叠的部分（替代<code>clearRect()</code>的灵活擦除）。</li>\n<li><strong>生成遮罩</strong>   ：用<code>source-in</code>或<code>destination-in</code>模式，快速生成两个图形的“交集遮罩”（如圆形头像裁剪）。</li>\n<li><strong>特效叠加</strong>   ：用<code>multiply</code>（变暗）或<code>screen</code>（变亮）模式，模拟照片滤镜或UI组件的叠加效果。</li>\n</ul>\n</div>'</script></body></html>