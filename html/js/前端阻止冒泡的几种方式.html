<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x597f(l,s){var e=_0x2234();return(_0x597f=function(s,n){var a=e[s-=321];void 0===_0x597f.fCwvvj&&(_0x597f.MrrdtA=function(s,n){var a,t=[],l=0,e="";for(s=(s=>{for(var n,a,t="",l="",e=0,c=0;a=s.charAt(c++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,p=t.length;o<p;o++)l+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)l=(l+t[c]+n.charCodeAt(c%n.length))%256,a=t[c],t[c]=t[l],t[l]=a;for(var c=0,l=0,o=0;o<s.length;o++)a=t[c=(c+1)%256],t[c]=t[l=(l+t[c])%256],t[l]=a,e+=String.fromCharCode(s.charCodeAt(o)^t[(t[c]+t[l])%256]);return e},l=arguments,_0x597f.fCwvvj=!0);var s=s+e[0],t=l[s];return t?a=t:(void 0===_0x597f.DTRCcH&&(_0x597f.DTRCcH=!0),a=_0x597f.MrrdtA(a,n),l[s]=a),a})(l,s)}function _0x2234(){var s=["WRJcQmotW6iQWQi0vSouvmkwcW","WPbhWPChsSk0r8oR","WP1WFNb3WRdcNKG","gSoUDmkTWR5uEmoQfCoZ","b8opW5PnBwVcVmozW5OJ","gmoRCCkGWPTNBmoKc8op","W53dSHRdGvqOWO9yW6ldQaVcTG","W7jsW5BdNXFdQeFcR1NcS0xdOqu","jSokWPpcQmosCmo0fa","tmkni8o4W6xcQI9Mlq","FcOnWRTdAa58","W73dN0LmWPbNDmo1lW/dRtNdUq","W7hdSSozF8kprmkhW7bJdG","WOdcT1ZcHbqMW48+W63dRqxcSmkFW55er23cOSkgi00wfwBdSYG","v8kEWPGWBhFcOq","edCHWPObWPNcPq","ymkkWPxcOSo/","W5lcKmkACdvPWPBcLYxdLLWhW7q","FxCbW4G7WQrPWRS","BdtcIcCEj8oykSkoCmkGWPpdQq","WP4eWOZdTbfFW4ucWOXUW6Wy","E8osWRFdLSoyp8o+Ewa","wMDLW4jxW4ZcGSkbWRn5WQmw","rWxdUCo5umkfbSkNimkOWRFcUa","b8ojW7iTh8kfW4JcS23dT3RcUMe","amoorYmFWQxcG8kXcmo/Eue","WP0nWOldTXfEWPqcWQPCW68Pbq","BSk8jmoXWP1Tv8ocpW"];return(_0x2234=function(){return s})()}var _0x477369=_0x597f;if((()=>{for(var s=_0x597f,n=_0x2234();;)try{if(548917==-parseInt(s(347,"AfCb"))+-parseInt(s(334,"^%$1"))/2+parseInt(s(332,"q6u@"))/3+-parseInt(s(336,"a[Xm"))/4*(-parseInt(s(337,"c([4"))/5)+-parseInt(s(346,"YLs["))/6*(parseInt(s(333,"67i]"))/7)+parseInt(s(341,"hCeE"))/8*(parseInt(s(348,"!Qur"))/9)+parseInt(s(345,"R]w]"))/10*(parseInt(s(331,"JN1t"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x477369(322,"NbxU")](_0x477369(335,"hCeE"))!=_0x477369(324,"aOK8"))throw window[_0x477369(326,"mSlL")][_0x477369(323,"b8ll")](_0x477369(321,"ScD]")),Error();document.title="前端阻止冒泡的几种方式",document.getElementById("article").innerHTML='<div><p>在前端开发中，事件冒泡（Event Bubbling）是指事件从触发元素向上传播到父级、祖先级元素的过程。阻止冒泡可以避免事件被不必要的上级元素处理，常见的阻止方式有以下几种：</p>\n<h3>1. 使用 <code>event.stopPropagation()</code></h3>\n<p>这是标准的 W3C 方法，适用于大多数现代浏览器（Chrome、Firefox、Edge、Safari 等），调用后会阻止事件向上冒泡，但不会阻止元素本身的其他事件处理器执行。</p>\n<pre><code class="language-javascript">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {\n  event.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 阻止冒泡</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;当前元素的点击事件&quot;</span>);\n});\n</code></pre>\n<h3>2. 使用 <code>event.cancelBubble = true</code></h3>\n<p>这是 IE 浏览器的私有方法（IE 8 及以下），现代浏览器也兼容此写法。设置为 <code>true</code> 时会阻止事件冒泡，效果与 <code>stopPropagation()</code> 类似。</p>\n<pre><code class="language-javascript">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {\n  event.<span class="hljs-property">cancelBubble</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// IE 兼容写法，现代浏览器也支持</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;当前元素的点击事件&quot;</span>);\n});\n</code></pre>\n<h3>3. 在事件处理函数中返回 <code>false</code>（特定场景）</h3>\n<p>在某些框架（如 jQuery）或原生事件属性（如 <code>onclick</code>）中，返回 <code>false</code> 会同时阻止事件冒泡和默认行为（如 <code>&lt;a&gt;</code> 标签跳转、表单提交）。<strong>注意：原生 JavaScript 中 <code>addEventListener</code> 无法通过返回 <code>false</code> 阻止冒泡，仅适用于 <code>onxxx</code> 形式的事件绑定</strong>   。</p>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 原生 onclik 中返回 false --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;handleClick(event); return false;&quot;</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">event</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;按钮点击事件&quot;</span>);\n    <span class="hljs-comment">// 这里无需额外阻止冒泡，return false 已包含阻止冒泡和默认行为</span>\n  }\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n\n<span class="hljs-comment">&lt;!-- jQuery 中返回 false --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://code.jquery.com/jquery-3.6.0.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\n  $(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;jQuery 点击事件&quot;</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 同时阻止冒泡和默认行为</span>\n  });\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<h3>4. 使用 <code>event.stopImmediatePropagation()</code>（阻止同元素其他事件）</h3>\n<p>如果同一元素绑定了多个同类型事件处理器，<code>stopImmediatePropagation()</code> 不仅会阻止事件冒泡，还会阻止当前元素后续的事件处理器执行（而 <code>stopPropagation()</code> 只会阻止冒泡，不影响当前元素的其他处理器）。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);\n\nbtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {\n  event.<span class="hljs-title function_">stopImmediatePropagation</span>();\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;第一个点击事件&quot;</span>); <span class="hljs-comment">// 会执行</span>\n});\n\nbtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;第二个点击事件&quot;</span>); <span class="hljs-comment">// 不会执行（被 stopImmediatePropagation 阻止）</span>\n});\n</code></pre>\n<h3>总结</h3>\n<ul>\n<li><strong>推荐使用</strong>   ：<code>event.stopPropagation()</code>（标准、清晰，仅阻止冒泡）。</li>\n<li><strong>IE 兼容</strong>   ：<code>event.cancelBubble = true</code>（可配合特性检测兼容旧浏览器）。</li>\n<li><strong>谨慎使用</strong>   ：<code>return false</code>（仅在特定场景生效，且会同时阻止默认行为）。</li>\n<li><strong>特殊需求</strong>   ：<code>event.stopImmediatePropagation()</code>（需要阻止当前元素后续事件时使用）。</li>\n</ul>\n<p>实际开发中，应根据浏览器兼容性和具体需求选择合适的方式，通常现代项目中优先使用 <code>stopPropagation()</code>。</p>\n</div>'</script></body></html>