<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x281c1d=_0x2a05;if((()=>{for(var s=_0x2a05,n=_0x4e0f();;)try{if(410859==-parseInt(s(157,"T@Pl"))*(parseInt(s(155,"1812"))/2)+parseInt(s(167,"iGio"))/3*(parseInt(s(171,"UIi@"))/4)+parseInt(s(165,"SgEf"))/5*(-parseInt(s(172,"9upU"))/6)+parseInt(s(163,"kC0p"))/7*(parseInt(s(149,"T@Pl"))/8)+-parseInt(s(166,"7TG["))/9*(parseInt(s(158,"3XqM"))/10)+-parseInt(s(145,"1812"))/11*(parseInt(s(174,"p]9y"))/12)+parseInt(s(150,"Rh@Z"))/13)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x281c1d(147,"U^e9")](_0x281c1d(169,"T@Pl"))!=_0x281c1d(159,"IsL!"))throw window[_0x281c1d(176,"2ix^")][_0x281c1d(161,"*A4!")](_0x281c1d(156,"kC0p")),Error();function _0x2a05(p,s){var r=_0x4e0f();return(_0x2a05=function(s,n){var a=r[s-=145];void 0===_0x2a05.SFxOgq&&(_0x2a05.lkQuKa=function(s,n){var a,l=[],p=0,r="";for(s=(s=>{for(var n,a,l="",p="",r=0,e=0;a=s.charAt(e++);~a&&(n=r%4?64*n+a:a,r++%4)&&(l+=String.fromCharCode(255&n>>(-2*r&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,c=l.length;t<c;t++)p+="%"+("00"+l.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[p],l[p]=a;for(var e=0,p=0,t=0;t<s.length;t++)a=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=a,r+=String.fromCharCode(s.charCodeAt(t)^l[(l[e]+l[p])%256]);return r},p=arguments,_0x2a05.SFxOgq=!0);var s=s+r[0],l=p[s];return l?a=l:(void 0===_0x2a05.VEbyRL&&(_0x2a05.VEbyRL=!0),a=_0x2a05.lkQuKa(a,n),p[s]=a),a})(p,s)}function _0x4e0f(){var s=["WROyWPJdOJXkW6pdK8kWk1VcNCk6","W5iSzdfiybNdTmk3zmoqc8kq","WOr6iu8knei","srSximo+dmoM","D8kyW4jiWRDSlSo9W5XbEJJdIq","BmkmBSoyirBdUwpdNsy+WO5NWR4","W4RdHvldL8oOyCk6eq","b8keWPGRtaRcMMi","mmkLWOJdU8oWdmo4WPep","lCkQjtNdL2RdJ37cJ8kqnCkDxa","WR4wW6xcK2awWPtdPW","WPRdKt9gWR0fWRLCWPuprL5sCwr0WRWGWR3cGN87lSo7W6/cOG","DmkFW4DkW5q0tmoEW4zH","WO4jAJNdQCo3WRFdUv9rW55hW7a","WO1oz8ohW4a","W7lcTH/cPI/cNc7cTbhdOSkCitm","W4P/u8okW4L8xq","WQrPe3C5W4z5WOC","W4dcNtLNWPDXW5Kv","WQaHW4qaamkSfwZdK3rAtmofya","w3nTW6JcLtBcOCo4WRqJW4O","jSklyCkgWO7cTLO","W6HGWQv6W7NcIwNcHG","W57dO1JdNCkosCo7W5W","b8oiWPaAW7iUu8o6W5i","Bmknz8oFiHdcRXddOHWNWO8","p8oFbqLUe8kqWR7cM8k2qgq","wZvkWPBdTmk7W4uThq","dmojvmkPWORcJheDnMq","W6e2ure7aXJdIa","W6u/fuvjeHRdNIrujW","WPxcMxNdLCoKA8kMgq"];return(_0x4e0f=function(){return s})()}document.title="javascript 排序",document.getElementById("article").innerHTML='<div><p>JavaScript 中常见的排序算法有多种，每种算法都有其特点和适用场景。以下是常见的排序算法及其示例代码：</p>\n<hr>\n<h3>1. <strong>冒泡排序（Bubble Sort）</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就交换它们。</li>\n<li><strong>时间复杂度</strong>  ：O(n²)</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">arr</span>) {\n  <span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>;\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) {\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++) {\n      <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) {\n        [arr[j], arr[j + <span class="hljs-number">1</span>]] = [arr[j + <span class="hljs-number">1</span>], arr[j]]; <span class="hljs-comment">// 交换</span>\n      }\n    }\n  }\n  <span class="hljs-keyword">return</span> arr;\n}\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">bubbleSort</span>([<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>])); <span class="hljs-comment">// [2, 3, 4, 5, 8]</span>\n</code></pre>\n<hr>\n<h3>2. <strong>选择排序（Selection Sort）</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：每次从未排序部分选择最小的元素，放到已排序部分的末尾。</li>\n<li><strong>时间复杂度</strong>  ：O(n²)</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">selectionSort</span>(<span class="hljs-params">arr</span>) {\n  <span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>;\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) {\n    <span class="hljs-keyword">let</span> minIndex = i;\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) {\n      <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) {\n        minIndex = j;\n      }\n    }\n    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; <span class="hljs-comment">// 交换</span>\n  }\n  <span class="hljs-keyword">return</span> arr;\n}\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">selectionSort</span>([<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>])); <span class="hljs-comment">// [2, 3, 4, 5, 8]</span>\n</code></pre>\n<hr>\n<h3>3. <strong>插入排序（Insertion Sort）</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：将未排序元素插入到已排序部分的正确位置。</li>\n<li><strong>时间复杂度</strong>  ：O(n²)</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertionSort</span>(<span class="hljs-params">arr</span>) {\n  <span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>;\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) {\n    <span class="hljs-keyword">let</span> key = arr[i];\n    <span class="hljs-keyword">let</span> j = i - <span class="hljs-number">1</span>;\n    <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key) {\n      arr[j + <span class="hljs-number">1</span>] = arr[j];\n      j--;\n    }\n    arr[j + <span class="hljs-number">1</span>] = key;\n  }\n  <span class="hljs-keyword">return</span> arr;\n}\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">insertionSort</span>([<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>])); <span class="hljs-comment">// [2, 3, 4, 5, 8]</span>\n</code></pre>\n<hr>\n<h3>4. <strong>归并排序（Merge Sort）</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：采用分治法，将数组分成两半，分别排序，然后合并。</li>\n<li><strong>时间复杂度</strong>  ：O(n log n)</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">arr</span>) {\n  <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr;\n  <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>);\n  <span class="hljs-keyword">let</span> left = <span class="hljs-title function_">mergeSort</span>(arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, mid));\n  <span class="hljs-keyword">let</span> right = <span class="hljs-title function_">mergeSort</span>(arr.<span class="hljs-title function_">slice</span>(mid));\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(left, right);\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left, right</span>) {\n  <span class="hljs-keyword">let</span> result = [];\n  <span class="hljs-keyword">while</span> (left.<span class="hljs-property">length</span> &amp;&amp; right.<span class="hljs-property">length</span>) {\n    <span class="hljs-keyword">if</span> (left[<span class="hljs-number">0</span>] &lt;= right[<span class="hljs-number">0</span>]) {\n      result.<span class="hljs-title function_">push</span>(left.<span class="hljs-title function_">shift</span>());\n    } <span class="hljs-keyword">else</span> {\n      result.<span class="hljs-title function_">push</span>(right.<span class="hljs-title function_">shift</span>());\n    }\n  }\n  <span class="hljs-keyword">return</span> result.<span class="hljs-title function_">concat</span>(left, right);\n}\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">mergeSort</span>([<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>])); <span class="hljs-comment">// [2, 3, 4, 5, 8]</span>\n</code></pre>\n<hr>\n<h3>5. <strong>快速排序（Quick Sort）</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：选择一个基准元素，将数组分成小于和大于基准的两部分，递归排序。</li>\n<li><strong>时间复杂度</strong>  ：O(n log n)（平均），O(n²)（最坏）</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr</span>) {\n  <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr;\n  <span class="hljs-keyword">let</span> pivot = arr[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>)];\n  <span class="hljs-keyword">let</span> left = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &lt; pivot);\n  <span class="hljs-keyword">let</span> middle = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x === pivot);\n  <span class="hljs-keyword">let</span> right = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; pivot);\n  <span class="hljs-keyword">return</span> [...<span class="hljs-title function_">quickSort</span>(left), ...middle, ...<span class="hljs-title function_">quickSort</span>(right)];\n}\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">quickSort</span>([<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>])); <span class="hljs-comment">// [2, 3, 4, 5, 8]</span>\n</code></pre>\n<hr>\n<h3>6. <strong>堆排序（Heap Sort）</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：将数组视为完全二叉树，构建最大堆，然后依次取出堆顶元素。</li>\n<li><strong>时间复杂度</strong>  ：O(n log n)</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">heapSort</span>(<span class="hljs-params">arr</span>) {\n  <span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>;\n\n  <span class="hljs-comment">// 建立大顶堆</span>\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(len / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {\n    <span class="hljs-title function_">heapify</span>(arr, len, i);\n  }\n\n  <span class="hljs-comment">// 一个个交换元素</span>\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {\n    [arr[<span class="hljs-number">0</span>], arr[i]] = [arr[i], arr[<span class="hljs-number">0</span>]]; <span class="hljs-comment">// 交换</span>\n    <span class="hljs-title function_">heapify</span>(arr, i, <span class="hljs-number">0</span>);\n  }\n  <span class="hljs-keyword">return</span> arr;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">arr, len, i</span>) {\n  <span class="hljs-keyword">let</span> largest = i;\n  <span class="hljs-keyword">let</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;\n  <span class="hljs-keyword">let</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;\n\n  <span class="hljs-keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) largest = left;\n  <span class="hljs-keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) largest = right;\n\n  <span class="hljs-keyword">if</span> (largest !== i) {\n    [arr[i], arr[largest]] = [arr[largest], arr[i]];\n    <span class="hljs-title function_">heapify</span>(arr, len, largest);\n  }\n}\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">heapSort</span>([<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>])); <span class="hljs-comment">// [2, 3, 4, 5, 8]</span>\n</code></pre>\n<hr>\n<h3>7. <strong>计数排序（Counting Sort）</strong>  （非比较排序）</h3>\n<ul>\n<li><strong>原理</strong>  ：适用于一定范围内的整数排序，通过计数每个元素出现的次数来确定位置。</li>\n<li><strong>时间复杂度</strong>  ：O(n + k)，其中 k 是数值范围</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">countingSort</span>(<span class="hljs-params">arr</span>) {\n  <span class="hljs-keyword">let</span> max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...arr);\n  <span class="hljs-keyword">let</span> min = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(...arr);\n  <span class="hljs-keyword">let</span> count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(max - min + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);\n  <span class="hljs-keyword">let</span> result = [];\n\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> arr) {\n    count[num - min]++;\n  }\n\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count.<span class="hljs-property">length</span>; i++) {\n    <span class="hljs-keyword">while</span> (count[i] &gt; <span class="hljs-number">0</span>) {\n      result.<span class="hljs-title function_">push</span>(i + min);\n      count[i]--;\n    }\n  }\n\n  <span class="hljs-keyword">return</span> result;\n}\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">countingSort</span>([<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>])); <span class="hljs-comment">// [2, 3, 4, 5, 8]</span>\n</code></pre>\n<hr>\n<h3>8. <strong>桶排序（Bucket Sort）</strong>  （非比较排序）</h3>\n<ul>\n<li><strong>原理</strong>  ：将元素分到不同的桶中，分别排序，然后合并。</li>\n<li><strong>时间复杂度</strong>  ：O(n + k)，适用于均匀分布的数据</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bucketSort</span>(<span class="hljs-params">arr, bucketSize = <span class="hljs-number">5</span></span>) {\n  <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> arr;\n\n  <span class="hljs-keyword">let</span> minValue = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(...arr);\n  <span class="hljs-keyword">let</span> maxValue = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...arr);\n  <span class="hljs-keyword">let</span> bucketCount = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((maxValue - minValue) / bucketSize) + <span class="hljs-number">1</span>;\n  <span class="hljs-keyword">let</span> buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(bucketCount);\n\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; buckets.<span class="hljs-property">length</span>; i++) {\n    buckets[i] = [];\n  }\n\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {\n    <span class="hljs-keyword">let</span> bucketIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((arr[i] - minValue) / bucketSize);\n    buckets[bucketIndex].<span class="hljs-title function_">push</span>(arr[i]);\n  }\n\n  arr.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; buckets.<span class="hljs-property">length</span>; i++) {\n    <span class="hljs-keyword">if</span> (buckets[i].<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {\n      <span class="hljs-title function_">insertionSort</span>(buckets[i]); <span class="hljs-comment">// 使用插入排序对每个桶排序</span>\n      arr.<span class="hljs-title function_">push</span>(...buckets[i]);\n    }\n  }\n\n  <span class="hljs-keyword">return</span> arr;\n}\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">bucketSort</span>([<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>])); <span class="hljs-comment">// [2, 3, 4, 5, 8]</span>\n</code></pre>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>比较排序</strong>  ：冒泡排序、选择排序、插入排序、归并排序、快速排序、堆排序。</li>\n<li><strong>非比较排序</strong>  ：计数排序、桶排序（适用于特定场景）。</li>\n</ul>\n<p>在实际应用中，<strong>快速排序</strong>  和<strong>归并排序</strong>  是最常用的，因为它们的时间复杂度为 O(n log n)，适用于大多数情况。对于特定场景，如整数排序，可以考虑使用<strong>计数排序</strong>  或<strong>桶排序</strong>  。</p>\n</div>'</script></body></html>