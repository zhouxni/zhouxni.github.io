<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1e3d(){var s=["W6tcNeNdPmk7WRP6ESkqW5aZ","vCofmK0aW5fXW57cN8olWRxcQ8kMoq","mSogjCk5cs/dJ8obW6jo","WPeEWRxcVtq+cSowWRVdUSoQuCo6","sK7cHdfWjCotrG","qLpdNSkwhrBcQG","WPyCWRpcSvndySoOWQZdGG","zmkpzf3cIgb7W6ixWO8+AG","CZldJSoywZ7cJqSpWOmdWO1qW4lcIsJdTCkyC28EWQ3cR1xdSmol","WQFdUYldQGeBWOK","WQpdRw3dKHlcPMvzDCotwWXE","a8ksCZbbWOmK","W6tcRwpcSIiuWPKAW6zn","mmohiCk4ExpcNmk1W55ZnXtcLui","W68Yp8kiua3dLmkqz8ov","rh3dVNJcGmo5kHJdR14","W7jxb3jBoXu","WR7dGSkUW6qxW6Ovy8kRWOlcIG","WRRcRmk0WP7cQG","WRtdJmkSWQHlW5mdBSku","A20/WPy+WQBcUmkplG","v8ohzbfLWO0kWPG","jHDzevHEW5/dG8o+","wfddSwzHWOKvWQVdHqddPCkj","xSoQBvZdGt/cT8oOW6RdPmou","qXtcR8kdu8olcbGcW58","W58EWPBdGmoFW5zmW44","W4uRWOHMWPJcRSkTW4D3ohC"];return(_0x1e3d=function(){return s})()}function _0x537f(t,s){var p=_0x1e3d();return(_0x537f=function(s,n){var a=p[s-=306];void 0===_0x537f.wEuCmK&&(_0x537f.iExqbi=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=l.length;c<r;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[t],l[t]=a;for(var e=0,t=0,c=0;c<s.length;c++)a=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[t])%256]);return p},t=arguments,_0x537f.wEuCmK=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x537f.kXHifL&&(_0x537f.kXHifL=!0),a=_0x537f.iExqbi(a,n),t[s]=a),a})(t,s)}var _0x5dad8d=_0x537f;if((()=>{for(var s=_0x537f,n=_0x1e3d();;)try{if(338160==+parseInt(s(317,"VA1P"))*(-parseInt(s(331,"@9pc"))/2)+-parseInt(s(315,"rtog"))/3+parseInt(s(306,"LiWH"))/4*(parseInt(s(321,"q]Zd"))/5)+parseInt(s(313,")wkY"))/6*(parseInt(s(322,"CTr$"))/7)+parseInt(s(332,"LiWH"))/8*(parseInt(s(330,"jkQi"))/9)+parseInt(s(318,"q]Zd"))/10+-parseInt(s(316,"8El("))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5dad8d(326,"8El(")](_0x5dad8d(309,"E0so"))!=_0x5dad8d(333,"Ntc%"))throw window[_0x5dad8d(319,"cTua")][_0x5dad8d(324,"f5Jn")](_0x5dad8d(323,"#CLg")),Error();document.title="Service Worker 的监听事件",document.getElementById("article").innerHTML='<div><p>Service Worker 是一种运行在浏览器后台的脚本，它独立于网页，能够拦截和处理网络请求，从而实现离线缓存、推送通知、后台同步等高级功能。以下是 Service Worker 中常见的监听事件及其用途的详细介绍：</p>\n<hr>\n<h3><strong>1. <code>install</code> 事件</strong></h3>\n<ul>\n<li><strong>触发时机</strong>  ：当 Service Worker 被首次安装时触发。</li>\n<li><strong>用途</strong>  ：\n<ul>\n<li><strong>缓存资源</strong>  ：在 <code>install</code> 事件中，可以预缓存应用程序所需的静态资源（如 HTML、CSS、JavaScript、图片等），以便在离线或网络不稳定时能够快速加载。</li>\n<li><strong>版本控制</strong>  ：通过缓存版本号，确保在更新 Service Worker 时能够清理旧缓存，避免缓存冲突。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">waitUntil</span>(\n    caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;my-cache-v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">addAll</span>([\n        <span class="hljs-string">&#x27;/&#x27;</span>,\n        <span class="hljs-string">&#x27;/index.html&#x27;</span>,\n        <span class="hljs-string">&#x27;/styles.css&#x27;</span>,\n        <span class="hljs-string">&#x27;/script.js&#x27;</span>,\n        <span class="hljs-string">&#x27;/image.jpg&#x27;</span>\n      ]);\n    })\n  );\n});\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>2. <code>activate</code> 事件</strong></h3>\n<ul>\n<li><strong>触发时机</strong>  ：当 Service Worker 安装完成后并被激活时触发。</li>\n<li><strong>用途</strong>  ：\n<ul>\n<li><strong>清理旧缓存</strong>  ：在 <code>activate</code> 事件中，可以删除不再需要的旧缓存，释放存储空间。</li>\n<li><strong>更新 Service Worker</strong>  ：确保新版本的 Service Worker 能够接管旧版本，处理缓存更新。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">waitUntil</span>(\n    caches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cacheNames</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(\n        cacheNames.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">cacheName</span> =&gt;</span> {\n          <span class="hljs-keyword">if</span> (cacheName !== <span class="hljs-string">&#x27;my-cache-v1&#x27;</span>) {\n            <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">delete</span>(cacheName);\n          }\n        })\n      );\n    })\n  );\n});\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>3. <code>fetch</code> 事件</strong></h3>\n<ul>\n<li><strong>触发时机</strong>  ：当浏览器发起网络请求时触发。</li>\n<li><strong>用途</strong>  ：\n<ul>\n<li><strong>拦截请求</strong>  ：可以拦截浏览器发出的网络请求，并根据缓存策略返回缓存的响应或发起新的网络请求。</li>\n<li><strong>实现离线功能</strong>  ：通过缓存响应，使得应用程序在离线状态下仍然可用。</li>\n<li><strong>优化性能</strong>  ：减少网络请求，加快页面加载速度。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">respondWith</span>(\n    caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cachedResponse</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> cachedResponse || <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">networkResponse</span> =&gt;</span> {\n        <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;my-cache-v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n          cache.<span class="hljs-title function_">put</span>(event.<span class="hljs-property">request</span>, networkResponse.<span class="hljs-title function_">clone</span>());\n          <span class="hljs-keyword">return</span> networkResponse;\n        });\n      });\n    })\n  );\n});\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>4. <code>push</code> 事件</strong></h3>\n<ul>\n<li><strong>触发时机</strong>  ：当服务器向客户端发送推送通知时触发。</li>\n<li><strong>用途</strong>  ：\n<ul>\n<li><strong>处理推送通知</strong>  ：在 <code>push</code> 事件中，可以处理服务器推送的消息，并决定是否向用户展示通知。</li>\n<li><strong>自定义通知内容</strong>  ：根据推送消息的内容，自定义通知的标题、正文、图标等。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;push&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  <span class="hljs-keyword">const</span> options = {\n    <span class="hljs-attr">body</span>: event.<span class="hljs-property">data</span>.<span class="hljs-title function_">text</span>(),\n    <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;/icon.png&#x27;</span>\n  };\n  event.<span class="hljs-title function_">waitUntil</span>(\n    self.<span class="hljs-property">registration</span>.<span class="hljs-title function_">showNotification</span>(<span class="hljs-string">&#x27;通知标题&#x27;</span>, options)\n  );\n});\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>5. <code>notificationclick</code> 事件</strong></h3>\n<ul>\n<li><strong>触发时机</strong>  ：当用户点击推送通知时触发。</li>\n<li><strong>用途</strong>  ：\n<ul>\n<li><strong>处理通知点击</strong>  ：在 <code>notificationclick</code> 事件中，可以处理用户点击通知后的逻辑，如打开特定的网页或执行特定的操作。</li>\n<li><strong>导航到特定页面</strong>  ：根据通知的内容，导航用户到相关的页面。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 显示带操作按钮的通知</span>\nself.<span class="hljs-property">registration</span>.<span class="hljs-title function_">showNotification</span>(<span class="hljs-string">&#x27;新消息&#x27;</span>, {\n  <span class="hljs-attr">body</span>: <span class="hljs-string">&#x27;您有3条未读消息&#x27;</span>,\n  <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;/images/message-icon.png&#x27;</span>,\n  <span class="hljs-attr">actions</span>: [\n    { <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;view&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;查看&#x27;</span> },\n    { <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;dismiss&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;忽略&#x27;</span> }\n  ],\n  <span class="hljs-attr">data</span>: {\n    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/messages&#x27;</span>\n  }\n});\n\n<span class="hljs-comment">// 处理不同操作</span>\nself.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;notificationclick&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-property">notification</span>.<span class="hljs-title function_">close</span>();\n  \n  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">action</span> === <span class="hljs-string">&#x27;view&#x27;</span>) {\n    <span class="hljs-comment">// 处理&quot;查看&quot;操作</span>\n    event.<span class="hljs-title function_">waitUntil</span>(\n      clients.<span class="hljs-title function_">openWindow</span>(event.<span class="hljs-property">notification</span>.<span class="hljs-property">data</span>.<span class="hljs-property">url</span>)\n    );\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.<span class="hljs-property">action</span> === <span class="hljs-string">&#x27;dismiss&#x27;</span>) {\n    <span class="hljs-comment">// 处理&quot;忽略&quot;操作</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;通知被忽略&#x27;</span>);\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 默认点击行为</span>\n    event.<span class="hljs-title function_">waitUntil</span>(\n      clients.<span class="hljs-title function_">openWindow</span>(<span class="hljs-string">&#x27;/&#x27;</span>)\n    );\n  }\n});\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>6. <code>sync</code> 事件</strong></h3>\n<ul>\n<li><strong>触发时机</strong>  ：当客户端触发了后台同步事件后触发。</li>\n<li><strong>用途</strong>  ：\n<ul>\n<li><strong>执行后台同步任务</strong>  ：在网络恢复时，自动执行未完成的同步任务，如发送未发送的数据。</li>\n<li><strong>确保数据一致性</strong>  ：在网络不稳定或离线时，暂存数据并在网络可用时同步。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 在页面中注册同步</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">registerBackgroundSync</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;serviceWorker&#x27;</span> <span class="hljs-keyword">in</span> navigator &amp;&amp; <span class="hljs-string">&#x27;SyncManager&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>) {\n    navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-property">ready</span>\n      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">registration</span> =&gt;</span> {\n        <span class="hljs-keyword">return</span> registration.<span class="hljs-property">sync</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;sync-messages&#x27;</span>);\n      })\n      .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;后台同步已注册&#x27;</span>);\n      })\n      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;后台同步注册失败:&#x27;</span>, err);\n      });\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;浏览器不支持后台同步&#x27;</span>);\n  }\n}\n\n<span class="hljs-comment">// 例如在表单提交时调用</span>\n<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;submit-form&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 注册后台同步</span>\n  <span class="hljs-title function_">registerBackgroundSync</span>();\n});\n\n\n\n\n<span class="hljs-comment">// 在sw.js中监听sync事件</span>\nself.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;sync&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;同步事件触发:&#x27;</span>, event.<span class="hljs-property">tag</span>);\n  \n  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">tag</span> === <span class="hljs-string">&#x27;sync-messages&#x27;</span>) {\n    event.<span class="hljs-title function_">waitUntil</span>(\n      <span class="hljs-comment">// 执行同步操作</span>\n      <span class="hljs-title function_">syncMessages</span>()\n        .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {\n          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;同步成功&#x27;</span>);\n          <span class="hljs-comment">// 可选：显示通知</span>\n          <span class="hljs-keyword">return</span> self.<span class="hljs-property">registration</span>.<span class="hljs-title function_">showNotification</span>(<span class="hljs-string">&#x27;同步完成&#x27;</span>, {\n            <span class="hljs-attr">body</span>: <span class="hljs-string">&#x27;您的数据已成功同步&#x27;</span>,\n            <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;/images/success-icon.png&#x27;</span>\n          });\n        })\n        .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {\n          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;同步失败:&#x27;</span>, err);\n          <span class="hljs-comment">// 失败后会自动重试</span>\n        })\n    );\n  }\n});\n\n\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>7. <code>message</code> 事件</strong></h3>\n<ul>\n<li><strong>触发时机</strong>  ：当客户端（如网页）向 Service Worker 发送消息时触发。</li>\n<li><strong>用途</strong>  ：\n<ul>\n<li><strong>通信机制</strong>  ：实现客户端与 Service Worker 之间的双向通信。</li>\n<li><strong>执行特定任务</strong>  ：根据接收到的消息，执行特定的逻辑或返回数据。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 获取Service Worker注册对象</span>\nnavigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-property">ready</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">registration</span> =&gt;</span> {\n  <span class="hljs-comment">// 向Service Worker发送消息</span>\n  registration.<span class="hljs-property">active</span>.<span class="hljs-title function_">postMessage</span>({\n    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;COMMAND&#x27;</span>,\n    <span class="hljs-attr">data</span>: { <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;update_cache&#x27;</span> }\n  });\n});\n\n<span class="hljs-comment">// 或者通过controller</span>\n<span class="hljs-keyword">if</span> (navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-property">controller</span>) {\n  navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-property">controller</span>.<span class="hljs-title function_">postMessage</span>({\n    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;GREETING&#x27;</span>,\n    <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;Hello from the page!&#x27;</span>\n  });\n}\n\n\n<span class="hljs-comment">////</span>\nself.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;收到消息:&#x27;</span>, event.<span class="hljs-property">data</span>);\n  \n  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span>.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;COMMAND&#x27;</span>) {\n    <span class="hljs-comment">// 处理特定类型的消息</span>\n    <span class="hljs-title function_">handleCommand</span>(event.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>);\n  }\n});\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>8. <code>periodicsync</code> 事件</strong>  （实验性）</h3>\n<ul>\n<li><strong>触发时机</strong>  ：按照预定义的时间间隔触发。</li>\n<li><strong>用途</strong>  ：\n<ul>\n<li><strong>定期同步数据</strong>  ：定期执行后台同步任务，如检查更新或同步数据。</li>\n</ul>\n</li>\n<li><strong>注意</strong>  ：该事件目前仍处于实验阶段，并非所有浏览器都支持。</li>\n</ul>\n<hr>\n<h3><strong>9. <code>canmakepayment</code> 事件</strong>  （已废弃）</h3>\n<ul>\n<li><strong>触发时机</strong>  ：曾用于检测用户是否可以进行支付操作。</li>\n<li><strong>用途</strong>  ：已被废弃，建议使用 Payment Request API 替代。</li>\n</ul>\n<hr>\n<h3><strong>10. <code>paymentrequest</code> 事件</strong>  （已废弃）</h3>\n<ul>\n<li><strong>触发时机</strong>  ：曾用于处理支付请求。</li>\n<li><strong>用途</strong>  ：已被废弃，建议使用 Payment Request API 替代。</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>Service Worker 的监听事件为开发者提供了强大的功能，使得 Web 应用能够实现离线访问、推送通知、后台同步等高级特性。通过合理利用这些事件，开发者可以显著提升应用的性能和用户体验。以下是 Service Worker 监听事件的主要用途总结：</p>\n<table>\n<thead>\n<tr>\n<th><strong>事件名称</strong></th>\n<th><strong>主要用途</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>install</code></td>\n<td>缓存资源，版本控制</td>\n</tr>\n<tr>\n<td><code>activate</code></td>\n<td>清理旧缓存，更新 Service Worker</td>\n</tr>\n<tr>\n<td><code>fetch</code></td>\n<td>拦截请求，实现离线功能和性能优化</td>\n</tr>\n<tr>\n<td><code>push</code></td>\n<td>处理推送通知</td>\n</tr>\n<tr>\n<td><code>notificationclick</code></td>\n<td>处理通知点击事件</td>\n</tr>\n<tr>\n<td><code>sync</code></td>\n<td>执行后台同步任务</td>\n</tr>\n<tr>\n<td><code>message</code></td>\n<td>实现客户端与 Service Worker 之间的通信</td>\n</tr>\n<tr>\n<td><code>periodicsync</code></td>\n<td>定期同步数据（实验性）</td>\n</tr>\n</tbody>\n</table>\n<p>通过深入理解和合理使用这些事件，开发者可以构建出功能强大、性能卓越的 Web 应用。</p>\n</div>'</script></body></html>