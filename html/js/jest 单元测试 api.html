<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4d44(e,n){var t=_0x1ce6();return(_0x4d44=function(n,s){var a=t[n-=127];void 0===_0x4d44.cJslGl&&(_0x4d44.fRaqpC=function(n,s){var a,l=[],e=0,t="";for(n=(n=>{for(var s,a,l="",e="",t=0,c=0;a=n.charAt(c++);~a&&(s=t%4?64*s+a:a,t++%4)&&(l+=String.fromCharCode(255&s>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,p=l.length;o<p;o++)e+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(e)})(n),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)e=(e+l[c]+s.charCodeAt(c%s.length))%256,a=l[c],l[c]=l[e],l[e]=a;for(var c=0,e=0,o=0;o<n.length;o++)a=l[c=(c+1)%256],l[c]=l[e=(e+l[c])%256],l[e]=a,t+=String.fromCharCode(n.charCodeAt(o)^l[(l[c]+l[e])%256]);return t},e=arguments,_0x4d44.cJslGl=!0);var n=n+t[0],l=e[n];return l?a=l:(void 0===_0x4d44.fgaFgq&&(_0x4d44.fgaFgq=!0),a=_0x4d44.fRaqpC(a,s),e[n]=a),a})(e,n)}var _0x5983bc=_0x4d44;if((()=>{for(var n=_0x4d44,s=_0x1ce6();;)try{if(726204==+parseInt(n(142,"pV2^"))*(parseInt(n(129,"b^1N"))/2)+-parseInt(n(140,"pV2^"))/3*(parseInt(n(131,"((U%"))/4)+parseInt(n(143,"wygD"))/5+parseInt(n(127,"b^1N"))/6*(parseInt(n(130,"8(8X"))/7)+-parseInt(n(145,"0WTZ"))/8+-parseInt(n(147,"aX%r"))/9+parseInt(n(144,"b[Kx"))/10)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x5983bc(149,"8(8X")](_0x5983bc(132,"CfID"))!=_0x5983bc(152,"fq7s"))throw window[_0x5983bc(136,"vEne")][_0x5983bc(146,"ah%2")](_0x5983bc(137,"y#f$")),Error();function _0x1ce6(){var n=["WQHSBmobjWnpWQJcIXriu0CRymoFhmoDW7pcSmkZW5ZcImkEDue","A3rsW5VdH13cOSoS","tIVcImoXlSoeWOm+fmoNW63cJJe","W5pdUSoDrmojr8oHW5eJW5OTpq","W6BcKmkeW6NdMrpdKHFcUW","W5ldU8otg8kqgmoAW4C1","x37dOXRcTCo/WPtdTY7dPSk+lum","WRxcHmksBYpdJSkEWPbFWOtdKCo+W4vp","WRKoASo3W4m/u0tdN8klW6tcMmkgW60","WQ97WOOEW4f+aG","umkkW7HChtyuuNBcLmopW4BdKa","W512bCkTgSoLqCoFBSoFq8kfWPFdRG","W78CsI18W7WP","WRatWPb0qwTWW4lcJCo9WPmi","WOb9WPtcMaW+W4fqDG","WPBcH2fOuq","oCkmWOuTWRlcKrRcTSkIW7zbFa","WRxdNmoSBxviW4VdKCoAeK5sWRa","nCkcWOv/W5BdQcNcHSkm","WQXlrcPGW6axWQS","xCkbWRehjmoEnxy","W6/cHSkKa8oKW5CLW5yV","W5FdUSkWhSkBkSoSW6O","tYJcICo5kmoeW6KWomoMW6dcQa","WOJdK8kTWQSSW6ZdIcTjCt3cTmkqWOO","WOnjW5FdQ8o3WPOQDW"];return(_0x1ce6=function(){return n})()}document.title="jest 单元测试 api",document.getElementById("article").innerHTML='<div><p>Jest 是一个功能强大的 JavaScript 测试框架，提供了丰富的 API 来帮助开发者编写和运行单元测试。以下是 Jest 中一些常用的 API：</p>\n<h3>一、核心 API</h3>\n<h4>1. <code>describe</code></h4>\n<ul>\n<li><strong>作用</strong>  ：用于分组相关的测试用例，帮助组织测试代码。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;Math operations&#x27;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 测试用例</span>\n});\n</code></pre>\n</li>\n</ul>\n<h4>2. <code>test</code> 或 <code>it</code></h4>\n<ul>\n<li><strong>作用</strong>  ：定义一个测试用例。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;adds 1 + 2 to equal 3&#x27;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">expect</span>(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">3</span>);\n});\n</code></pre>\n</li>\n</ul>\n<h4>3. <code>expect</code></h4>\n<ul>\n<li><strong>作用</strong>  ：用于断言测试结果。</li>\n<li><strong>常用匹配器</strong>  ：\n<ul>\n<li><code>toBe(value)</code>：判断值是否相等。</li>\n<li><code>toEqual(value)</code>：判断对象是否相等。</li>\n<li><code>toContain(item)</code>：判断数组或字符串是否包含某个元素。</li>\n<li><code>toMatch(regex)</code>：判断字符串是否匹配正则表达式。</li>\n<li><code>toBeTruthy()</code>：判断值是否为真。</li>\n<li><code>toBeFalsy()</code>：判断值是否为假。</li>\n<li><code>toBeNull()</code>：判断值是否为 <code>null</code>。</li>\n<li><code>toBeUndefined()</code>：判断值是否为 <code>undefined</code>。</li>\n<li><code>toHaveBeenCalled()</code>：判断函数是否被调用。</li>\n<li><code>toHaveBeenCalledWith(arg1, arg2, ...)</code>：判断函数是否以特定参数被调用。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-title function_">expect</span>(result).<span class="hljs-title function_">toBe</span>(expectedValue);\n</code></pre>\n</li>\n</ul>\n<h3>二、钩子函数</h3>\n<h4>1. <code>beforeAll</code></h4>\n<ul>\n<li><strong>作用</strong>  ：在所有测试用例运行之前执行一次。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-title function_">beforeAll</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 初始化代码</span>\n});\n</code></pre>\n</li>\n</ul>\n<h4>2. <code>afterAll</code></h4>\n<ul>\n<li><strong>作用</strong>  ：在所有测试用例运行之后执行一次。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-title function_">afterAll</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 清理代码</span>\n});\n</code></pre>\n</li>\n</ul>\n<h4>3. <code>beforeEach</code></h4>\n<ul>\n<li><strong>作用</strong>  ：在每个测试用例运行之前执行。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 初始化代码</span>\n});\n</code></pre>\n</li>\n</ul>\n<h4>4. <code>afterEach</code></h4>\n<ul>\n<li><strong>作用</strong>  ：在每个测试用例运行之后执行。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-title function_">afterEach</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 清理代码</span>\n});\n</code></pre>\n</li>\n</ul>\n<h3>三、模拟函数</h3>\n<h4>1. <code>jest.fn()</code></h4>\n<ul>\n<li><strong>作用</strong>  ：创建一个模拟函数，用于替代实际的方法或回调。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> mockFunction = jest.<span class="hljs-title function_">fn</span>();\n<span class="hljs-title function_">mockFunction</span>();\n<span class="hljs-title function_">expect</span>(mockFunction).<span class="hljs-title function_">toHaveBeenCalled</span>();\n</code></pre>\n</li>\n</ul>\n<h4>2. <code>jest.mock()</code></h4>\n<ul>\n<li><strong>作用</strong>  ：模拟模块或文件。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript">jest.<span class="hljs-title function_">mock</span>(<span class="hljs-string">&#x27;./myModule&#x27;</span>);\n<span class="hljs-keyword">import</span> myModule <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./myModule&#x27;</span>;\nmyModule.<span class="hljs-property">someMethod</span>.<span class="hljs-title function_">mockReturnValue</span>(<span class="hljs-string">&#x27;mockedValue&#x27;</span>);\n</code></pre>\n</li>\n</ul>\n<h3>四、异步测试</h3>\n<h4>1. <code>done</code> 回调</h4>\n<ul>\n<li><strong>作用</strong>  ：用于处理异步测试，通过调用 <code>done</code> 回调来通知 Jest 测试已完成。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;async test with done&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">done</span>) =&gt;</span> {\n  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-title function_">expect</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">1</span>);\n    <span class="hljs-title function_">done</span>();\n  }, <span class="hljs-number">1000</span>);\n});\n</code></pre>\n</li>\n</ul>\n<h4>2. <code>async/await</code></h4>\n<ul>\n<li><strong>作用</strong>  ：处理异步操作，如 API 调用或定时器。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;async test with async/await&#x27;</span>, <span class="hljs-title function_">async</span> () =&gt; {\n  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">someAsyncFunction</span>();\n  <span class="hljs-title function_">expect</span>(result).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;expectedValue&#x27;</span>);\n});\n</code></pre>\n</li>\n</ul>\n<h4>3. <code>returns</code> 和 <code>resolves</code> / <code>rejects</code></h4>\n<ul>\n<li><strong>作用</strong>  ：用于模拟异步函数的返回值。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> mockAsyncFunction = jest.<span class="hljs-title function_">fn</span>().<span class="hljs-title function_">mockResolvedValue</span>(<span class="hljs-string">&#x27;resolvedValue&#x27;</span>);\n</code></pre>\n</li>\n</ul>\n<h3>五、快照测试</h3>\n<h4>1. <code>toMatchSnapshot()</code></h4>\n<ul>\n<li><strong>作用</strong>  ：用于快照测试，确保组件或函数的输出没有意外变化。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-title function_">expect</span>(<span class="hljs-title function_">someFunction</span>()).<span class="hljs-title function_">toMatchSnapshot</span>();\n</code></pre>\n</li>\n</ul>\n<h3>六、其他实用 API</h3>\n<h4>1. <code>jest.clearAllMocks()</code></h4>\n<ul>\n<li><strong>作用</strong>  ：清除所有模拟函数的调用记录。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript">jest.<span class="hljs-title function_">clearAllMocks</span>();\n</code></pre>\n</li>\n</ul>\n<h4>2. <code>jest.useFakeTimers()</code></h4>\n<ul>\n<li><strong>作用</strong>  ：使用虚拟定时器，控制 <code>setTimeout</code>、<code>setInterval</code> 等。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript">jest.<span class="hljs-title function_">useFakeTimers</span>();\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 代码</span>\n}, <span class="hljs-number">1000</span>);\njest.<span class="hljs-title function_">runAllTimers</span>();\n</code></pre>\n</li>\n</ul>\n<h4>3. <code>jest.spyOn()</code></h4>\n<ul>\n<li><strong>作用</strong>  ：监视对象的方法调用。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> spy = jest.<span class="hljs-title function_">spyOn</span>(obj, <span class="hljs-string">&#x27;methodName&#x27;</span>);\n<span class="hljs-title function_">expect</span>(spy).<span class="hljs-title function_">toHaveBeenCalled</span>();\n</code></pre>\n</li>\n</ul>\n<h3>总结</h3>\n<p>Jest 提供了丰富的 API 来支持单元测试的各种需求，从基本的测试用例定义到复杂的异步和快照测试。通过合理使用这些 API，开发者可以编写出高效、可靠的测试代码，确保代码的质量和稳定性。</p>\n</div>'</script></body></html>