<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5696a7=_0x19e0;function _0x2d34(){var n=["aSkoWRtdISo5tmkWW6RcICkqESkPWO0","dmoRWPvsW6pcUSkGzxu","W7tcRCojWPuNbmoy","WRTWq8koWOm","hw1RW4ldMSo8WOyvWQq/W4bxtSk2","WQdcNc/cVmoEWPtcHW","imkYbqpcSmkwW6/cTcG","sCktqCkzW6DaW5HfW7xdKGzqW4S","Dmo1W6y3e8kGWO1QWPPvFCoe","sCkGqSogeSk1CCkTDCogfqNdRq","CfddICk9kmooAhT3","iZjpvSoUW5dcICkgrCkSW49bWRbt","pxWrWPbJwZlcVCk8","uSkfxCoZW7xdP8kMWRtdRCoZWQnro8kECCo7gM3cHKvVWOldMa/cGu4","iSkVf8kDW47dOHiKDsq","l8kQrSk3rGakWP1IWRBcV3a","FulcI8kaW79laSoFW5ehD8od","wCoHW7tdN8oDwcZcNmoLW7pcKLVdNa","u8kfWPpcQCk8eNK","cmoehSkXW4pcRSodW5RdGSo6","cCoghCk7WRBdRSk7W4RdSCoAWOPsbq","FM4EaSkOWOZdLmoy","WRldRCowWPawh8k+emoCwqtcK8kx","hmoebCoOWQmDWOu","WPmFW4NdOSkQwSklW6yw","dSodhCk2WRtdPmogW4VdKSoqWOfm"];return(_0x2d34=function(){return n})()}function _0x19e0(c,n){var t=_0x2d34();return(_0x19e0=function(n,s){var e=t[n-=245];void 0===_0x19e0.dSTAKJ&&(_0x19e0.QKJnZE=function(n,s){var e,o=[],c=0,t="";for(n=(n=>{for(var s,e,o="",c="",t=0,a=0;e=n.charAt(a++);~e&&(s=t%4?64*s+e:e,t++%4)&&(o+=String.fromCharCode(255&s>>(-2*t&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var p=0,l=o.length;p<l;p++)c+="%"+("00"+o.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(c)})(n),a=0;a<256;a++)o[a]=a;for(a=0;a<256;a++)c=(c+o[a]+s.charCodeAt(a%s.length))%256,e=o[a],o[a]=o[c],o[c]=e;for(var a=0,c=0,p=0;p<n.length;p++)e=o[a=(a+1)%256],o[a]=o[c=(c+o[a])%256],o[c]=e,t+=String.fromCharCode(n.charCodeAt(p)^o[(o[a]+o[c])%256]);return t},c=arguments,_0x19e0.dSTAKJ=!0);var n=n+t[0],o=c[n];return o?e=o:(void 0===_0x19e0.SoLoqs&&(_0x19e0.SoLoqs=!0),e=_0x19e0.QKJnZE(e,s),c[n]=e),e})(c,n)}if((()=>{for(var n=_0x19e0,s=_0x2d34();;)try{if(587939==+parseInt(n(252,"Tevh"))*(parseInt(n(259,"w)r1"))/2)+parseInt(n(248,"*ZNB"))/3+parseInt(n(260,"w)r1"))/4+parseInt(n(266,"e4S)"))/5+-parseInt(n(264,"oB(1"))/6*(-parseInt(n(265,"w)r1"))/7)+-parseInt(n(249,"B2Xd"))/8+parseInt(n(268,"(SE1"))/9*(-parseInt(n(251,"6^qQ"))/10))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x5696a7(263,"7i(p")](_0x5696a7(250,"tqv3"))!=_0x5696a7(269,"thBJ"))throw window[_0x5696a7(261,"6^qQ")][_0x5696a7(245,"#x%a")](_0x5696a7(253,"w)r1")),Error();document.title="Vue 3 中 setup 函数的实现原理",document.getElementById("article").innerHTML='<div><p>Vue 3 中 <code>setup</code> 函数的实现原理涉及 Vue 组件初始化的底层机制，核心围绕<strong>组件实例创建流程</strong>   和<strong>Composition API 与 Options API 的桥接</strong>   展开。以下从源码实现细节层面解析：</p>\n<h3>1. 组件初始化流程中的 <code>setup</code> 调用时机</h3>\n<p>在 Vue 3 的组件初始化（<code>createComponentInstance</code>）过程中，<code>setup</code> 的执行处于<strong>早期阶段</strong>   ，具体位置在：</p>\n<ul>\n<li>组件实例（<code>ComponentInternalInstance</code>）被创建后</li>\n<li>初始化 <code>props</code> 和 <code>attrs</code> 之后</li>\n<li>执行 <code>beforeCreate</code> 生命周期钩子之前</li>\n</ul>\n<p>源码层面简化逻辑如下（伪代码）：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setupComponent</span>(<span class="hljs-params">instance</span>) {\n  <span class="hljs-comment">// 1. 初始化 props（从父组件接收的属性）</span>\n  <span class="hljs-title function_">initProps</span>(instance, propsOptions);\n\n  <span class="hljs-comment">// 2. 初始化 attrs（非 props 的属性）</span>\n  <span class="hljs-title function_">initAttrs</span>(instance, attrs);\n\n  <span class="hljs-comment">// 3. 执行 setup 函数</span>\n  <span class="hljs-keyword">const</span> setupResult = <span class="hljs-title function_">callSetup</span>(instance);\n\n  <span class="hljs-comment">// 4. 处理 setup 返回值（桥接至组件上下文）</span>\n  <span class="hljs-title function_">handleSetupResult</span>(instance, setupResult);\n\n  <span class="hljs-comment">// 5. 执行 beforeCreate 等生命周期</span>\n  <span class="hljs-title function_">callLifecycleHooks</span>(instance, <span class="hljs-string">&quot;beforeCreate&quot;</span>);\n}\n</code></pre>\n<p><code>setup</code> 执行时，组件实例尚未完全初始化，因此无法访问 <code>this</code>（此时 <code>this</code> 指向 <code>undefined</code>）。</p>\n<h3>2. <code>setup</code> 参数的生成机制</h3>\n<p><code>setup</code> 接收的 <code>props</code> 和 <code>context</code> 参数并非直接传递，而是由 Vue 内部动态生成：</p>\n<ul>\n<li>\n<p><strong><code>props</code> 参数</strong>   ：</p>\n<ul>\n<li>基于组件定义的 <code>props</code> 选项，通过 <code>initProps</code> 处理后生成<strong>响应式对象</strong></li>\n<li>底层通过 <code>reactive</code> 包装，确保 <code>props</code> 变化能被追踪</li>\n<li>为防止直接修改 <code>props</code>，Vue 会对 <code>props</code> 的 setter 进行拦截（警告但不阻断）</li>\n</ul>\n</li>\n<li>\n<p><strong><code>context</code> 参数</strong>   ：</p>\n<ul>\n<li>是一个普通对象（非响应式），包含 <code>attrs</code>、<code>slots</code>、<code>emit</code> 等属性</li>\n<li><code>attrs</code> 和 <code>slots</code> 是<strong>动态更新的引用</strong>   （当父组件传递的值变化时，会自动同步）</li>\n<li><code>emit</code> 函数内部通过 <code>instance.emit</code> 实现，本质是调用组件实例的事件触发逻辑</li>\n</ul>\n</li>\n</ul>\n<h3>3. <code>setup</code> 与响应式系统的关联</h3>\n<p><code>setup</code> 是 Composition API 的入口，其核心能力依赖 Vue 3 的响应式系统（<code>Proxy</code> 实现）：</p>\n<ul>\n<li>当在 <code>setup</code> 中使用 <code>ref</code>、<code>reactive</code> 等 API 时，会创建<strong>响应式数据对象</strong></li>\n<li>Vue 会在 <code>setup</code> 执行期间启动<strong>依赖收集</strong>   （通过 <code>effect</code> 机制）</li>\n<li>当响应式数据变化时，Vue 会触发关联的<strong>副作用函数</strong>   （如组件渲染函数）</li>\n</ul>\n<p>源码中通过 <code>createSetupContext</code> 为 <code>setup</code> 提供独立的上下文环境，确保响应式数据的作用域隔离。</p>\n<h3>4. <code>setup</code> 返回值的处理逻辑</h3>\n<p><code>setup</code> 的返回值会被 <code>handleSetupResult</code> 函数处理，最终桥接至组件的渲染上下文：</p>\n<ul>\n<li>\n<p><strong>返回对象</strong>   ：</p>\n<ul>\n<li>对象的属性会被合并到组件实例的 <code>ctx</code>（上下文）中</li>\n<li>模板渲染时，会从 <code>ctx</code> 中读取这些属性（类似 Options API 中的 <code>data</code>）</li>\n<li>若返回的属性与 <code>props</code> 或 Options API 中的属性重名，<code>setup</code> 返回的属性会<strong>覆盖前者</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>返回函数</strong>   ：</p>\n<ul>\n<li>该函数会被作为组件的<strong>渲染函数</strong>   （替代 <code>&lt;template&gt;</code> 或 <code>render</code> 选项）</li>\n<li>函数内部可直接使用 <code>setup</code> 中定义的响应式数据</li>\n</ul>\n</li>\n</ul>\n<p>示例逻辑（伪代码）：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleSetupResult</span>(<span class="hljs-params">instance, result</span>) {\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span>) {\n    <span class="hljs-comment">// 将 setup 返回的对象挂载到组件上下文</span>\n    instance.<span class="hljs-property">ctx</span> = { ...instance.<span class="hljs-property">ctx</span>, ...result };\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;function&quot;</span>) {\n    <span class="hljs-comment">// 将返回的函数作为渲染函数</span>\n    instance.<span class="hljs-property">render</span> = result;\n  }\n}\n</code></pre>\n<h3>5. 生命周期钩子的注册原理</h3>\n<p><code>setup</code> 中通过 <code>onMounted</code>、<code>onUpdated</code> 等函数注册的生命周期钩子，其实现原理是：</p>\n<ul>\n<li>这些函数内部会调用 <code>injectHook</code> 方法，将钩子函数<strong>存储到组件实例</strong>   的 <code>hooks</code> 数组中</li>\n<li>当组件生命周期推进到对应阶段时（如挂载完成），Vue 会遍历 <code>hooks</code> 数组并执行所有注册的钩子</li>\n</ul>\n<p>伪代码示意：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">onMounted</span>(<span class="hljs-params">hook</span>) {\n  <span class="hljs-comment">// 将钩子函数关联到当前组件实例</span>\n  <span class="hljs-title function_">injectHook</span>(<span class="hljs-string">&quot;mounted&quot;</span>, hook);\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">injectHook</span>(<span class="hljs-params">lifecycle, hook</span>) {\n  <span class="hljs-keyword">const</span> instance = currentInstance; <span class="hljs-comment">// 当前活跃的组件实例（通过全局变量追踪）</span>\n  <span class="hljs-keyword">if</span> (instance) {\n    instance.<span class="hljs-property">hooks</span>[lifecycle] = [...(instance.<span class="hljs-property">hooks</span>[lifecycle] || []), hook];\n  }\n}\n</code></pre>\n<h3>6. 与 Options API 的融合机制</h3>\n<p><code>setup</code> 并非完全替代 Options API，而是通过<strong>优先级合并</strong>   实现两者共存：</p>\n<ul>\n<li><code>setup</code> 的执行早于 Options API 的初始化（如 <code>data</code>、<code>methods</code>）</li>\n<li><code>setup</code> 返回的属性会被合并到组件上下文，且优先级高于 <code>data</code> 和 <code>methods</code></li>\n<li>若 <code>setup</code> 中定义的函数与 <code>methods</code> 中的函数重名，<code>setup</code> 的函数会被优先使用</li>\n</ul>\n<h3>核心结论</h3>\n<p><code>setup</code> 函数的本质是 Vue 3 为 Composition API 设计的<strong>逻辑入口和隔离容器</strong>   ，其实现依赖：</p>\n<ol>\n<li>组件实例初始化流程中的精准时机控制</li>\n<li>响应式系统的依赖收集与触发机制</li>\n<li>与组件上下文、生命周期的底层桥接</li>\n</ol>\n<p>通过 <code>setup</code>，Vue 3 实现了逻辑的<strong>模块化拆分</strong>   和<strong>更细粒度的响应式控制</strong>   ，同时保持了与 Options API 的兼容性。</p>\n</div>'</script></body></html>