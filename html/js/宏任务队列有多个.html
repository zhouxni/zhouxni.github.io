<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2acc(a,t){var o=_0x1d2a();return(_0x2acc=function(t,n){var s=o[t-=210];void 0===_0x2acc.bIKAwq&&(_0x2acc.NHUzrp=function(t,n){var s,e=[],a=0,o="";for(t=(t=>{for(var n,s,e="",a="",o=0,l=0;s=t.charAt(l++);~s&&(n=o%4?64*n+s:s,o++%4)&&(e+=String.fromCharCode(255&n>>(-2*o&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var r=0,c=e.length;r<c;r++)a+="%"+("00"+e.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(a)})(t),l=0;l<256;l++)e[l]=l;for(l=0;l<256;l++)a=(a+e[l]+n.charCodeAt(l%n.length))%256,s=e[l],e[l]=e[a],e[a]=s;for(var l=0,a=0,r=0;r<t.length;r++)s=e[l=(l+1)%256],e[l]=e[a=(a+e[l])%256],e[a]=s,o+=String.fromCharCode(t.charCodeAt(r)^e[(e[l]+e[a])%256]);return o},a=arguments,_0x2acc.bIKAwq=!0);var t=t+o[0],e=a[t];return e?s=e:(void 0===_0x2acc.fqctEX&&(_0x2acc.fqctEX=!0),s=_0x2acc.NHUzrp(s,n),a[t]=s),s})(a,t)}var _0x26a291=_0x2acc;function _0x1d2a(){var t=["umkPzSongd98wCkV","AWCcWOmpW6XIW5dcGajDx2i","WOnQWRBcNuu","aSoFWOldICobWQxcOCk4qSkBWPLB","W5SktCkkr8kWdq","kSkMDs9CEsT4ECo3vwa","W7pdLsiPWQq4WPa","zSoCwSkIWQ0BW4jXmSoSWOD8","m8ooW7maASoUWOT0W4VcJwRcIW","xMhcRgldMHfnyCocdHSyWOK","sLbZESkYWQ9Bx8olW5HzyN8","uLpcNCoFre0s","W5tdVmout8oRpYxcKa3cPCo5","WRtdVCoCt2ZcTSo/","WOJdUhBcSCoHxZJcPmk6iLldHa","r8oLW64HstpdKCoE","xtddOSoTfSoXWRRcV1S","W5eTCSkvqmk5jG","WO3cUCksdSkVA2pdLc/cG8oEn8oDW5juWP/cOejsWQtcLSojW781WRxcNG","pCoarSoWyHnFwKrfiq","jtNdVmk6lsmoW7hdGSohW61V","W7CjWOfjCY3dTq","WO8eWQtdHSo6o8oPWP3cUrNdKfm","zLjhmSkhoSkWnLtdJGVdLSkd","Cq/dKCkLWQRdJhxcImoo","a8oBWOxdJConWQ3cGCktzCknWRv2"];return(_0x1d2a=function(){return t})()}if((()=>{for(var t=_0x2acc,n=_0x1d2a();;)try{if(210053==+parseInt(t(211,"IV)B"))*(parseInt(t(232,"xbhm"))/2)+parseInt(t(210,"!UnG"))/3*(parseInt(t(222,"@3a4"))/4)+-parseInt(t(234,"r[mk"))/5+parseInt(t(220,"E5Oq"))/6+-parseInt(t(229,"RC[9"))/7+parseInt(t(218,"fNUc"))/8*(-parseInt(t(215,"DAYj"))/9)+-parseInt(t(221,"2ao2"))/10)break;n.push(n.shift())}catch(t){n.push(n.shift())}})(),localStorage[_0x26a291(230,"lKmH")](_0x26a291(214,"]&!e"))!=_0x26a291(226,"teRN"))throw window[_0x26a291(213,"^iV(")][_0x26a291(235,"E5r3")](_0x26a291(216,"!UnG")),Error();document.title="宏任务队列有多个",document.getElementById("article").innerHTML='<div><h3><strong>核心答案：是的，宏任务队列有多个</strong></h3>\n<p>你的理解是正确的。<strong>浏览器环境中并不只有一个宏任务队列，而是根据任务来源（task source）划分了多个宏任务队列</strong>   。这是 W3C 规范中明确规定的设计。</p>\n<hr>\n<h3><strong>1. 为什么需要多个宏任务队列？</strong></h3>\n<p>为了给不同类型的任务分配不同的<strong>优先级</strong>   ，并确保<strong>同一来源的任务按序执行</strong>   ，避免某些任务“饿死”（永远得不到执行）。</p>\n<h4><strong>常见的宏任务队列（按优先级从高到低）</strong></h4>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">队列类型</th>\n<th style="text-align:left">任务来源</th>\n<th style="text-align:left">描述</th>\n<th style="text-align:left">优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>用户交互队列</strong></td>\n<td style="text-align:left"><code>click</code>, <code>input</code>, <code>keydown</code> 等事件回调</td>\n<td style="text-align:left">用户直接触发的交互任务</td>\n<td style="text-align:left"><strong>最高</strong></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>网络事件队列</strong></td>\n<td style="text-align:left"><code>XHR</code>, <code>Fetch</code> 的回调</td>\n<td style="text-align:left">网络请求返回后的处理任务</td>\n<td style="text-align:left">高</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>DOM操作队列</strong></td>\n<td style="text-align:left"><code>MutationObserver</code> 回调</td>\n<td style="text-align:left">DOM 变化相关的任务</td>\n<td style="text-align:left">中</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>定时器队列</strong></td>\n<td style="text-align:left"><code>setTimeout</code>, <code>setInterval</code> 回调</td>\n<td style="text-align:left">延迟执行的任务</td>\n<td style="text-align:left">低</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>I/O 队列</strong></td>\n<td style="text-align:left"><code>FileReader</code> 等</td>\n<td style="text-align:left">文件读取等 I/O 操作回调</td>\n<td style="text-align:left">低</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>2. 工作原理：事件循环如何处理多个队列</strong></h3>\n<p>浏览器的事件循环（Event Loop）会按<strong>固定的顺序和优先级</strong>   从这些队列中选取任务执行。一个简化的流程如下：</p>\n<ol>\n<li><strong>执行最早的宏任务</strong>   ：从<strong>所有非空宏任务队列</strong>   中选出<strong>最老</strong>   的一个任务来执行。\n<ul>\n<li><em>注意：浏览器实现可能会优先检查高优先级队列。</em></li>\n</ul>\n</li>\n<li><strong>执行所有微任务</strong>   ：执行完一个宏任务后，清空整个微任务队列（<code>Promise</code>, <code>MutationObserver</code>）。</li>\n<li><strong>是否需要渲染</strong>   ：根据屏幕刷新率（如 60Hz，约16.7ms一次）决定是否进行页面重绘（UI Render）。</li>\n<li><strong>重复</strong>   ：循环回到第1步。</li>\n</ol>\n<hr>\n<h3><strong>3. 代码示例：验证多个队列的存在</strong></h3>\n<p>以下代码可以证明不同来源的任务进入了不同的队列，并且<strong>用户交互任务优先级更高</strong>   。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 1. 添加一个低优先级的定时器任务</span>\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Timeout Task 1&quot;</span>);\n}, <span class="hljs-number">0</span>);\n\n<span class="hljs-comment">// 2. 添加一个微任务</span>\n<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Microtask&quot;</span>);\n});\n\n<span class="hljs-comment">// 3. 模拟一个高优先级的用户交互任务</span>\n<span class="hljs-comment">// 假设你有一个按钮，点击后会触发下面的回调</span>\nbutton.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;User Click Task&quot;</span>);\n});\n\n<span class="hljs-comment">// 4. 再添加一个定时器任务</span>\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Timeout Task 2&quot;</span>);\n}, <span class="hljs-number">0</span>);\n\n<span class="hljs-comment">// 执行顺序：</span>\n<span class="hljs-comment">// 1. 如果直接运行脚本：&#x27;Timeout Task 1&#x27; -&gt; &#x27;Microtask&#x27; -&gt; &#x27;Timeout Task 2&#x27;</span>\n<span class="hljs-comment">// 2. 如果在脚本执行后**立即点击按钮**    ：</span>\n<span class="hljs-comment">//    - 可能输出：&#x27;Timeout Task 1&#x27; -&gt; &#x27;Microtask&#x27; -&gt; &#x27;User Click Task&#x27; -&gt; &#x27;Timeout Task 2&#x27;</span>\n<span class="hljs-comment">//    - 因为用户交互队列优先级高，即使定时器任务先排队，也可能被优先执行。</span>\n</code></pre>\n<p><strong>注意</strong>   ：具体的执行顺序可能会因浏览器实现和当时的运行环境而有细微差别，但<strong>多队列的架构原则</strong>   是不变的。</p>\n<hr>\n<h3><strong>4. 与 Node.js 的区别</strong></h3>\n<p>值得注意的是，Node.js 中的事件循环与浏览器不同。它使用 <strong>Libuv 库</strong>   实现，拥有一个更复杂的<strong>多阶段模型（Phases）</strong>   ，每个阶段都有自己的任务队列（如 <code>timers</code>, <code>poll</code>, <code>check</code> 等），但原理同样是多个队列。</p>\n<hr>\n<h3><strong>总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">特性</th>\n<th style="text-align:left">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>队列数量</strong></td>\n<td style="text-align:left"><strong>多个</strong>   ，按任务来源划分（如交互、网络、定时器）。</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>设计目的</strong></td>\n<td style="text-align:left">保证高优先级任务（如用户点击）能及时响应。</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>执行顺序</strong></td>\n<td style="text-align:left">事件循环按<strong>规则和优先级</strong>   从各个队列中选取<strong>最老</strong>   的任务执行。</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>关键点</strong></td>\n<td style="text-align:left">执行完<strong>一个</strong>   宏任务，就会清空<strong>整个</strong>   微任务队列。</td>\n</tr>\n</tbody>\n</table>\n<p>所以，你的认知是完全正确的。理解“多宏任务队列”是深入理解 JavaScript 异步编程和浏览器行为的关键。</p>\n</div>'</script></body></html>