<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x337a(){var s=["gudcIMuuWQm7F8kJ","WO7dS3pcSmoIW5FdKCkEWRxdSgn+fG","WP0bW7RcMtxdNCo6W4Cw","xxtdUCoDaGZdKbC","DmkQku94yHVdTmotWPyBgt0","W5DqW47cOmoA","WP90W5z2emomhmovFCoxzSkkWPa","lSkSWP87WPZcN8k+","BhVcIa8MW47dGq","WP84fg42WOVcGW","W7q7C8o2W70YW5zTWQFdUwm2WR8","WP0GWPejECkouW","yItdTx4ii8oNW4xdR8kQFM4","acJcRCkmr1dcJGJdL8oGWOOXWP8","W4eOfLuCW4hdM8kkW4DQuc/cPuDYWOrGq8knm8kGcNtcHCogWRC","WP1SuXfFW4NdJmotW49OrqNcMG","WOTXW6VdTuNcPtCLW642W7hdVfG","l8kkvaCmW7FcHhLaDNbdWQu","oI3dI3zJWP7cNCkWiJVcR17dRG","wIrkmxBcIYXqWOuFt8o3","WPxcGZJcRSkiWR3dR8o6WPy","WPPVubDDW43dJCoFW6rNEG/cTa","W4JdLsRdI8kEymkuW61VaCkPfmkc","yc7dTh8pl8k/W7FdL8kozLm8"];return(_0x337a=function(){return s})()}function _0x4b50(c,s){var l=_0x337a();return(_0x4b50=function(s,n){var a=l[s-=380];void 0===_0x4b50.LkpjaS&&(_0x4b50.XyUCIA=function(s,n){var a,e=[],c=0,l="";for(s=(s=>{for(var n,a,e="",c="",l=0,t=0;a=s.charAt(t++);~a&&(n=l%4?64*n+a:a,l++%4)&&(e+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,o=e.length;p<o;p++)c+="%"+("00"+e.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(c)})(s),t=0;t<256;t++)e[t]=t;for(t=0;t<256;t++)c=(c+e[t]+n.charCodeAt(t%n.length))%256,a=e[t],e[t]=e[c],e[c]=a;for(var t=0,c=0,p=0;p<s.length;p++)a=e[t=(t+1)%256],e[t]=e[c=(c+e[t])%256],e[c]=a,l+=String.fromCharCode(s.charCodeAt(p)^e[(e[t]+e[c])%256]);return l},c=arguments,_0x4b50.LkpjaS=!0);var s=s+l[0],e=c[s];return e?a=e:(void 0===_0x4b50.BbfYVD&&(_0x4b50.BbfYVD=!0),a=_0x4b50.XyUCIA(a,n),c[s]=a),a})(c,s)}var _0x66332c=_0x4b50;if((()=>{for(var s=_0x4b50,n=_0x337a();;)try{if(571638==-parseInt(s(383,"@S!a"))+-parseInt(s(381,"*GV5"))/2+-parseInt(s(385,"i)[B"))/3+-parseInt(s(403,"i)[B"))/4+-parseInt(s(386,"s#BV"))/5+parseInt(s(397,"i)[B"))/6*(-parseInt(s(398,"x3d5"))/7)+-parseInt(s(388,"*uW#"))/8*(-parseInt(s(382,"4@]x"))/9))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x66332c(396,"4@]x")](_0x66332c(390,"kNvW"))!=_0x66332c(393,"0SLB"))throw window[_0x66332c(391,"wr!)")][_0x66332c(395,"ss$H")](_0x66332c(402,"i)[B")),Error();document.title="vue3 源码 ReactiveEffect",document.getElementById("article").innerHTML='<div><p>在 Vue 3 中，<code>ReactiveEffect</code> 是响应式系统的核心底层实现之一，它在幕后负责跟踪依赖关系并在响应式数据发生变化时触发副作用函数的重新执行。下面将从原理、实现细节、使用场景等方面为你详细介绍 <code>ReactiveEffect</code>。</p>\n<h3>原理概述</h3>\n<p>Vue 3 的响应式系统基于 Proxy 实现，当一个响应式对象的属性被访问时，会触发 <code>get</code> 拦截器，此时会记录下访问该属性的副作用函数（即依赖）。当这个属性的值发生变化时，会触发 <code>set</code> 拦截器，进而通知所有依赖该属性的副作用函数重新执行。<code>ReactiveEffect</code> 就是用来封装这些副作用函数，并管理它们的依赖收集和触发更新的。</p>\n<h3>实现细节</h3>\n<h4>创建 <code>ReactiveEffect</code> 实例</h4>\n<p><code>ReactiveEffect</code> 是一个类，在创建实例时需要传入一个副作用函数。以下是一个简化的 <code>ReactiveEffect</code> 类的实现示例：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> activeEffect = <span class="hljs-literal">null</span>;\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> {\n    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">fn</span>) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">fn</span> = fn;\n    }\n\n    <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {\n        activeEffect = <span class="hljs-variable language_">this</span>;\n        <span class="hljs-keyword">try</span> {\n            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fn</span>();\n        } <span class="hljs-keyword">finally</span> {\n            activeEffect = <span class="hljs-literal">null</span>;\n        }\n    }\n}\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) {\n    <span class="hljs-keyword">const</span> _effect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactiveEffect</span>(fn);\n    _effect.<span class="hljs-title function_">run</span>();\n    <span class="hljs-keyword">return</span> _effect;\n}\n</code></pre>\n<p>在上述代码中，<code>ReactiveEffect</code> 类有一个 <code>run</code> 方法，用于执行传入的副作用函数。在执行副作用函数之前，会将当前的 <code>ReactiveEffect</code> 实例赋值给 <code>activeEffect</code>，这样在响应式对象的 <code>get</code> 拦截器中就可以获取到当前正在执行的副作用函数，从而进行依赖收集。</p>\n<h4>依赖收集与触发更新</h4>\n<p>结合响应式对象的实现，当响应式对象的属性被访问时，会进行依赖收集；当属性值发生变化时，会触发依赖更新。以下是一个完整的示例：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> activeEffect = <span class="hljs-literal">null</span>;\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> {\n    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">fn</span>) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">fn</span> = fn;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span> = [];\n    }\n\n    <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {\n        activeEffect = <span class="hljs-variable language_">this</span>;\n        <span class="hljs-keyword">try</span> {\n            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fn</span>();\n        } <span class="hljs-keyword">finally</span> {\n            activeEffect = <span class="hljs-literal">null</span>;\n        }\n    }\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) {\n    <span class="hljs-keyword">const</span> _effect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactiveEffect</span>(fn);\n    _effect.<span class="hljs-title function_">run</span>();\n    <span class="hljs-keyword">return</span> _effect;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">target</span>) {\n    <span class="hljs-keyword">const</span> depMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();\n\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {\n        <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) {\n            <span class="hljs-keyword">if</span> (activeEffect) {\n                <span class="hljs-keyword">let</span> deps = depMap.<span class="hljs-title function_">get</span>(key);\n                <span class="hljs-keyword">if</span> (!deps) {\n                    deps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();\n                    depMap.<span class="hljs-title function_">set</span>(key, deps);\n                }\n                deps.<span class="hljs-title function_">add</span>(activeEffect);\n                activeEffect.<span class="hljs-property">deps</span>.<span class="hljs-title function_">push</span>(deps);\n            }\n            <span class="hljs-keyword">return</span> target[key];\n        },\n        <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value</span>) {\n            target[key] = value;\n            <span class="hljs-keyword">const</span> deps = depMap.<span class="hljs-title function_">get</span>(key);\n            <span class="hljs-keyword">if</span> (deps) {\n                deps.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> effect.<span class="hljs-title function_">run</span>());\n            }\n            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n        }\n    });\n}\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> });\n\n<span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Count is: <span class="hljs-subst">${state.count}</span>`</span>);\n});\n\nstate.<span class="hljs-property">count</span>++; <span class="hljs-comment">// 触发副作用函数重新执行</span>\n</code></pre>\n<p>在上述代码中，<code>reactive</code> 函数用于创建一个响应式对象，在 <code>get</code> 拦截器中进行依赖收集，将当前的 <code>activeEffect</code> 添加到对应的依赖集合中；在 <code>set</code> 拦截器中，当属性值发生变化时，会遍历该属性的依赖集合，调用每个 <code>ReactiveEffect</code> 实例的 <code>run</code> 方法，从而触发副作用函数的重新执行。</p>\n<h3>使用场景</h3>\n<ul>\n<li><strong>计算属性</strong>  ：计算属性的实现依赖于 <code>ReactiveEffect</code> 来跟踪依赖关系，并在相关响应式数据发生变化时重新计算结果。</li>\n<li><strong>监听器</strong>  ：监听器也是基于 <code>ReactiveEffect</code> 实现的，当监听的响应式数据发生变化时，会触发相应的回调函数。</li>\n</ul>\n<h3>注意事项</h3>\n<ul>\n<li><strong>手动停止副作用</strong>  ：在某些情况下，可能需要手动停止一个副作用函数的执行。可以在 <code>ReactiveEffect</code> 类中添加一个 <code>stop</code> 方法，用于清除该副作用函数的所有依赖。</li>\n<li><strong>嵌套副作用</strong>  ：当存在嵌套的副作用函数时，需要注意 <code>activeEffect</code> 的管理，确保依赖收集和触发更新的正确性。</li>\n</ul>\n<p>总之，<code>ReactiveEffect</code> 是 Vue 3 响应式系统的重要组成部分，深入理解它的原理和实现细节有助于更好地掌握 Vue 3 的响应式机制。</p>\n</div>'</script></body></html>