<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4696(e,s){var o=_0x6792();return(_0x4696=function(s,t){var n=o[s-=356];void 0===_0x4696.MFZLBs&&(_0x4696.DjqTFg=function(s,t){var n,a=[],e=0,o="";for(s=(s=>{for(var t,n,a="",e="",o=0,r=0;n=s.charAt(r++);~n&&(t=o%4?64*t+n:n,o++%4)&&(a+=String.fromCharCode(255&t>>(-2*o&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var l=0,d=a.length;l<d;l++)e+="%"+("00"+a.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(e)})(s),r=0;r<256;r++)a[r]=r;for(r=0;r<256;r++)e=(e+a[r]+t.charCodeAt(r%t.length))%256,n=a[r],a[r]=a[e],a[e]=n;for(var r=0,e=0,l=0;l<s.length;l++)n=a[r=(r+1)%256],a[r]=a[e=(e+a[r])%256],a[e]=n,o+=String.fromCharCode(s.charCodeAt(l)^a[(a[r]+a[e])%256]);return o},e=arguments,_0x4696.MFZLBs=!0);var s=s+o[0],a=e[s];return a?n=a:(void 0===_0x4696.mwHwsl&&(_0x4696.mwHwsl=!0),n=_0x4696.DjqTFg(n,t),e[s]=n),n})(e,s)}var _0xd86683=_0x4696;function _0x6792(){var s=["eCkDWQvkbCoNW5BcM2ddJGiOWQK","kuBdMvFdHNjtBG","W4pcR8oxr8oIW4ucWQBdGSokvmk6W4VdUW","qmkSq2BdHxaIW7xcRI7dV8k3WPZcJG","i2KnhCoVumoOWQzPaSkNFSovW5q","sZxdUwieFtRcNWKdW7LDWQ8","kNRdTSkPWQLYbCkZlLuquW","WOHEW7y+iCoyaY1kD2OMW4ddVW","WR5gkmkyW58","v8kZaXRdJxFcGa","xde4h2ddTmop","n2TEWRfBW6WyA0lcKCoBWOddTW","eIRcJf4duq7cMmo1E3tcTa","bCkgW5HAbWNdOCkkW7PMW5hcVqZcPCkLW5RdNtVdT8oCWQdcKSoLWOFdQSoE","cmoUWQLdWP/dKCoSW6m","gwJcVrnhk2i","lmohWORcUHNdRmkxW7RcUW","W48QefVcSCoDW5VcOcXRdwFcHq","kxNdV8kNWQL2tmk9aKm5sLO","gSkFW4dcJ8oeW4Oy","uCoPvKlcLcNdSXNcJSkzmmkbda","W71pW6rJW7vHcKLtWOz0twy","rd3cGSoymmkHcColv35KW6hdVa","tdNcKdLrgwJcQa","W5aMi8kyWRVcImkG","W7OObYb1W7Lg"];return(_0x6792=function(){return s})()}if((()=>{for(var s=_0x4696,t=_0x6792();;)try{if(991278==-parseInt(s(367,"dPPT"))*(-parseInt(s(365,"*&2u"))/2)+parseInt(s(375,"yMLn"))/3*(parseInt(s(364,"yMLn"))/4)+parseInt(s(377,"cx8W"))/5+-parseInt(s(378,"E5ly"))/6*(-parseInt(s(373,"xclm"))/7)+parseInt(s(381,"3Ph!"))/8+-parseInt(s(358,"9x&S"))/9+-parseInt(s(359,"sRmj"))/10)break;t.push(t.shift())}catch(s){t.push(t.shift())}})(),localStorage[_0xd86683(370,"E5ly")](_0xd86683(371,"][Ir"))!=_0xd86683(363,"VD)T"))throw window[_0xd86683(369,"@SQj")][_0xd86683(374,"^(!^")](_0xd86683(368,"SthN")),Error();document.title="vue、react SSR 渲染  hydrate 概念",document.getElementById("article").innerHTML='<div><p>下面把「<strong>Vue SSR 渲染 &amp; hydrate</strong>   」与「<strong>React SSR 渲染 &amp; hydrate</strong>   」放在一张对照表里，再逐条拆开讲。看完就能一眼看清两者的异同点以及常见“踩坑点”。</p>\n<hr>\n<ol>\n<li>概念速查表</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>阶段 / 概念</th>\n<th>Vue (Nuxt 2/3)</th>\n<th>React (Next.js / 原生)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>服务端产出 HTML</td>\n<td><code>@vue/server-renderer</code> 把组件渲染成 <strong>静态 HTML</strong></td>\n<td><code>react-dom/server</code> 的 <code>renderToString</code> / <code>renderToNodeStream</code></td>\n</tr>\n<tr>\n<td>客户端“激活”函数</td>\n<td><code>createSSRApp().mount(\'#app\', true)</code></td>\n<td><code>ReactDOM.hydrateRoot(domNode, reactNode)</code> 或 <code>hydrate</code></td>\n</tr>\n<tr>\n<td>激活目标</td>\n<td><strong>整个根节点</strong></td>\n<td><strong>整个根节点</strong></td>\n</tr>\n<tr>\n<td>激活检查</td>\n<td>节点结构 + 文本内容 + key 必须完全一致</td>\n<td>同 Vue</td>\n</tr>\n<tr>\n<td>失配警告</td>\n<td><code>[Vue warn]: Hydration node mismatch</code></td>\n<td><code>Warning: Text content does not match</code></td>\n</tr>\n<tr>\n<td>失配后回退</td>\n<td>强制 <strong>重新客户端渲染</strong>   （销毁 SSR DOM）</td>\n<td>同 Vue</td>\n</tr>\n<tr>\n<td>数据预取</td>\n<td><code>asyncData</code> / <code>useFetch</code> (Nuxt)</td>\n<td><code>getServerSideProps</code> / <code>getStaticProps</code> (Next)</td>\n</tr>\n<tr>\n<td>注水对象</td>\n<td><code>window.__NUXT__</code></td>\n<td><code>window.__NEXT_DATA__</code></td>\n</tr>\n<tr>\n<td>Suspense SSR</td>\n<td>Vue3 原生 <code>&lt;Suspense&gt;</code></td>\n<td>React18 的 <code>pipeToNodeStream</code> + <code>&lt;Suspense&gt;</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<ol start="2">\n<li>一条请求的生命周期（对照版）</li>\n</ol>\n<p>Vue（Nuxt2 简化版）</p>\n<pre><code>1. Node 收到请求\n2. asyncData → store 填数据\n3. renderToString(vm) → HTML + __NUXT__\n4. 浏览器收到 HTML → 立即有首屏\n5. 加载 JS → createSSRApp() → hydrate()\n6. 页面可交互\n</code></pre>\n<p>React（Next.js 简化版）</p>\n<pre><code>1. Node 收到请求\n2. getServerSideProps → props 注入页面\n3. renderToString(&lt;App props&gt;) → HTML + __NEXT_DATA__\n4. 浏览器收到 HTML → 立即有首屏\n5. 加载 JS → ReactDOM.hydrateRoot()\n6. 页面可交互\n</code></pre>\n<hr>\n<ol start="3">\n<li>\n<p>hydrate 时必须满足的三条铁律</p>\n</li>\n<li>\n<p><strong>HTML 结构必须一模一样</strong><br>\n多一个空格、少一个换行都会触发 mismatch。</p>\n</li>\n<li>\n<p><strong>首屏数据必须一致</strong><br>\n服务端注入的数据和客户端初次渲染的数据必须相同，否则 React/Vue 都会整棵树回退到客户端渲染。</p>\n</li>\n<li>\n<p><strong>key 必须稳定</strong><br>\n列表渲染时如果服务端和客户端 key 不同，会直接整段 DOM 重建。</p>\n</li>\n</ol>\n<hr>\n<ol start="4">\n<li>常见“踩坑”场景</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>Vue 表现</th>\n<th>React 表现</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>服务端与客户端时间不一致</td>\n<td><code>new Date()</code> 每次 render 都不同 → 失配</td>\n<td>同 Vue</td>\n</tr>\n<tr>\n<td>浏览器 API（window、localStorage）</td>\n<td>服务端拿不到 → 必须在 <code>mounted</code> / <code>useEffect</code> 里再执行</td>\n<td>同 Vue</td>\n</tr>\n<tr>\n<td>第三方库只在浏览器跑</td>\n<td>用 <code>&lt;ClientOnly&gt;</code>（Nuxt）包裹</td>\n<td>用 <code>next/dynamic</code> + <code>{ ssr: false }</code></td>\n</tr>\n<tr>\n<td>样式闪烁（FOUC）</td>\n<td>可能是 CSS 没提取到外链，Nuxt 有 <code>@nuxtjs/tailwindcss</code> 自动处理</td>\n<td>Next.js 用 <code>styled-components</code> 需 <code>babel-plugin-styled-components</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<ol start="5">\n<li>完整最小代码示例</li>\n</ol>\n<p>Vue3（原生，无框架）</p>\n<pre><code class="language-js"><span class="hljs-comment">// server.js</span>\n<span class="hljs-keyword">import</span> { renderToString } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@vue/server-renderer&quot;</span>;\n<span class="hljs-keyword">import</span> { createSSRApp } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.vue&quot;</span>;\n\n<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createSSRApp</span>(<span class="hljs-title class_">App</span>);\n<span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> <span class="hljs-title function_">renderToString</span>(app);\nres.<span class="hljs-title function_">send</span>(<span class="hljs-string">`\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;body&gt;&lt;div id=&quot;app&quot;&gt;<span class="hljs-subst">${html}</span>&lt;/div&gt;&lt;/body&gt;\n  &lt;script type=&quot;module&quot; src=&quot;/client.js&quot;&gt;&lt;/script&gt;\n&lt;/html&gt;\n`</span>);\n\n<span class="hljs-comment">// client.js</span>\n<span class="hljs-keyword">import</span> { createSSRApp } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.vue&quot;</span>;\n<span class="hljs-title function_">createSSRApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 第二个参数 true = hydrate</span>\n</code></pre>\n<p>React18（原生，无框架）</p>\n<pre><code class="language-js"><span class="hljs-comment">// server.js</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App&quot;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOMServer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/server&quot;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">const</span> html = <span class="hljs-title class_">ReactDOMServer</span>.<span class="hljs-title function_">renderToString</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);\nres.<span class="hljs-title function_">send</span>(<span class="hljs-string">`\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;body&gt;&lt;div id=&quot;root&quot;&gt;<span class="hljs-subst">${html}</span>&lt;/div&gt;&lt;/body&gt;\n  &lt;script type=&quot;module&quot; src=&quot;/client.js&quot;&gt;&lt;/script&gt;\n&lt;/html&gt;\n`</span>);\n\n<span class="hljs-comment">// client.js</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/client&quot;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App&quot;</span>;\n\n<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">hydrateRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>), <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);\n</code></pre>\n<hr>\n<ol start="6">\n<li>一句话总结</li>\n</ol>\n<ul>\n<li><strong>服务端渲染</strong>   ：Vue 用 <code>@vue/server-renderer</code>，React 用 <code>react-dom/server</code>。</li>\n<li><strong>客户端注水</strong>   ：Vue 调用 <code>app.mount(dom, true)</code>，React 调用 <code>hydrateRoot</code>/<code>hydrate</code>。</li>\n<li><strong>核心原则</strong>   ：首屏 HTML 必须“一模一样”，数据必须“同步一致”，否则整棵树回退到客户端渲染。</li>\n</ul>\n</div>'</script></body></html>