<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x38fc(e,n){var r=_0x4442();return(_0x38fc=function(n,a){var s=r[n-=402];void 0===_0x38fc.JwMFUr&&(_0x38fc.AYvvZZ=function(n,a){var s,l=[],e=0,r="";for(n=(n=>{for(var a,s,l="",e="",r=0,c=0;s=n.charAt(c++);~s&&(a=r%4?64*a+s:s,r++%4)&&(l+=String.fromCharCode(255&a>>(-2*r&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var t=0,i=l.length;t<i;t++)e+="%"+("00"+l.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(e)})(n),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)e=(e+l[c]+a.charCodeAt(c%a.length))%256,s=l[c],l[c]=l[e],l[e]=s;for(var c=0,e=0,t=0;t<n.length;t++)s=l[c=(c+1)%256],l[c]=l[e=(e+l[c])%256],l[e]=s,r+=String.fromCharCode(n.charCodeAt(t)^l[(l[c]+l[e])%256]);return r},e=arguments,_0x38fc.JwMFUr=!0);var n=n+r[0],l=e[n];return l?s=l:(void 0===_0x38fc.iSDguH&&(_0x38fc.iSDguH=!0),s=_0x38fc.AYvvZZ(s,a),e[n]=s),s})(e,n)}var _0x85753a=_0x38fc;function _0x4442(){var n=["CCkmfd7cHCkuW7C","WRC/oNHoW6ddH8oSW7OhWRe","qSkHjrtdGCo+W5m3l1PK","echcRxSh","WOS4uCkGW5zbW5zVyW","xg4viW3dSSoD","umkNW4lcJ27dUGekW4VcTmo9iG","EYJdMmkgW4ldMLhcSa","WOdcVCokW4dcQSkJWOTnWQxcJW","cCoWssKPW5C3dXmLWPtcThO","W6RcIfXbWPtcHmkPWPrj","E0BdR05xWQJcOeDzWPeWqCk5","W6RcIIrJWQlcJ0vTW5f+WRFcKW","WOaTWRZdPCkxzde","WOPXW7FcQSoDxSk2W4a0W5iX","W6HFumoDW5NcVX7cUSkfW6znEW","W6GieCkZWPJdSWO","WReZph4iW5NdLSoAW5KY","W4VcQSk5WQ/cO300fW","xZ9uhdldI8oAW4ny","uSkKW4lcJM/cKdOAW7NcOSo6","v8kHW4pcJHhcRYOeW5dcVW","nCkspwJdUquShmke","W4VcQmkIWQLJW4FcGZSZmu4U","g8oTzfFcH8kiWRrcl3DFxfaCW6FcLmo6WQfrrmoxnCoeq8k0eG","W47cR8oEW43dSWq4gmkUFSoyiG","WOXTW6VcKCoDW7/cKgVdQhZdRa4","WPOlW6WFWOLMi8oD","dXBcVXKqW6NdK3ft","WPufWQfYW7pcNLrhACo2"];return(_0x4442=function(){return n})()}if((()=>{for(var n=_0x38fc,a=_0x4442();;)try{if(525317==+parseInt(n(427,"GGpS"))*(parseInt(n(406,"t0RD"))/2)+-parseInt(n(426,"GGpS"))/3+-parseInt(n(415,"blOw"))/4*(parseInt(n(428,"Qms8"))/5)+-parseInt(n(422,"7vhr"))/6+-parseInt(n(418,"n%f8"))/7*(-parseInt(n(407,"Ae)q"))/8)+-parseInt(n(402,"KkYF"))/9*(-parseInt(n(431,"KkYF"))/10)+-parseInt(n(413,"6OUS"))/11*(parseInt(n(421,"fqu8"))/12))break;a.push(a.shift())}catch(n){a.push(a.shift())}})(),localStorage[_0x85753a(411,"oJnI")](_0x85753a(409,"7vhr"))!=_0x85753a(414,"I4Ud"))throw window[_0x85753a(408,"7]e1")][_0x85753a(424,"e&Zi")](_0x85753a(405,"6OUS")),Error();document.title="js 标记清理",document.getElementById("article").innerHTML='<div><p>在 JavaScript 中，标记清理（Mark-and-Sweep）是一种常用的垃圾回收算法，用于自动管理内存。这种算法主要用于识别并回收不再需要的内存空间，从而防止内存泄漏。虽然 JavaScript 引擎（如 V8、SpiderMonkey 等）会自动执行垃圾回收，但理解其工作原理有助于编写更高效的代码。</p>\n<h3>标记清理算法的基本步骤</h3>\n<ol>\n<li><strong>标记阶段（Mark Phase）</strong>  ：\n<ul>\n<li>垃圾回收器从一组根对象（通常是全局对象）开始，遍历所有可以通过引用访问的对象。</li>\n<li>所有从根对象可达的对象都会被标记为“活跃”或“不可回收”。</li>\n</ul>\n</li>\n<li><strong>清理阶段（Sweep Phase）</strong>  ：\n<ul>\n<li>遍历堆中的所有对象，回收那些没有被标记为“活跃”的对象。</li>\n<li>这些未标记的对象占用的内存空间被释放，可以供将来分配使用。</li>\n</ul>\n</li>\n</ol>\n<h3>常见的根对象</h3>\n<ul>\n<li>全局对象（如 <code>window</code> 在浏览器环境中）</li>\n<li>当前执行的函数调用栈</li>\n<li>活动的定时器</li>\n<li>事件监听器回调等</li>\n</ul>\n<h3>编写高效代码的建议</h3>\n<p>虽然垃圾回收是自动的，但编写代码时仍可以考虑以下几点以提高内存管理的效率：</p>\n<ol>\n<li><strong>避免全局变量</strong>  ：\n<ul>\n<li>全局变量会一直存在于内存中，直到页面关闭。尽量使用局部变量或块级作用域。</li>\n</ul>\n</li>\n<li><strong>解除不必要的引用</strong>  ：\n<ul>\n<li>如果不再需要某个对象，确保没有引用指向它，以便垃圾回收器可以回收。</li>\n</ul>\n</li>\n<li><strong>小心闭包</strong>  ：\n<ul>\n<li>闭包会捕获并保留其环境中的变量，可能导致内存泄漏。确保闭包只捕获需要的数据。</li>\n</ul>\n</li>\n<li><strong>及时清理事件监听器</strong>  ：\n<ul>\n<li>在不再需要时移除事件监听器，以防止它们持有对对象的引用。</li>\n</ul>\n</li>\n<li><strong>使用 WeakMap 和 WeakSet</strong>  ：\n<ul>\n<li>这些数据结构允许你存储对象引用，但不会阻止垃圾回收器回收这些对象。</li>\n</ul>\n</li>\n</ol>\n<h3>示例</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createLeak</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> leakedObject = { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;I will leak&#x27;</span> };\n  <span class="hljs-comment">// 如果这个引用被意外保留，leakedObject 将无法被回收</span>\n  <span class="hljs-variable language_">window</span>.<span class="hljs-property">unintendedReference</span> = leakedObject;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">avoidLeak</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">let</span> largeData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;data&#x27;</span>);\n  <span class="hljs-comment">// 使用完 largeData 后，确保没有引用指向它</span>\n  <span class="hljs-title function_">doSomethingWith</span>(largeData);\n  largeData = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 显式解除引用</span>\n}\n</code></pre>\n<p>通过理解标记清理算法和内存管理的基本原则，你可以编写出更高效、更可靠的 JavaScript 代码。</p>\n</div>'</script></body></html>