<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x15bfd5=_0x3f0f;function _0x3f0f(l,s){var e=_0x2a9d();return(_0x3f0f=function(s,n){var a=e[s-=257];void 0===_0x3f0f.wPCMpB&&(_0x3f0f.DLPBWO=function(s,n){var a,t=[],l=0,e="";for(s=(s=>{for(var n,a,t="",l="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=t.length;o<c;o++)l+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)l=(l+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[l],t[l]=a;for(var p=0,l=0,o=0;o<s.length;o++)a=t[p=(p+1)%256],t[p]=t[l=(l+t[p])%256],t[l]=a,e+=String.fromCharCode(s.charCodeAt(o)^t[(t[p]+t[l])%256]);return e},l=arguments,_0x3f0f.wPCMpB=!0);var s=s+e[0],t=l[s];return t?a=t:(void 0===_0x3f0f.dbYrFB&&(_0x3f0f.dbYrFB=!0),a=_0x3f0f.DLPBWO(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x3f0f,n=_0x2a9d();;)try{if(865352==+parseInt(s(278,"GhXb"))*(parseInt(s(271,"Yg[m"))/2)+-parseInt(s(270,"GP9p"))/3*(-parseInt(s(272,"fh&i"))/4)+-parseInt(s(268,"gMdX"))/5+parseInt(s(280,"C0(M"))/6+-parseInt(s(265,"CKl@"))/7+parseInt(s(275,"GP9p"))/8+-parseInt(s(266,"goeL"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x15bfd5(264,"hxw2")](_0x15bfd5(257,"gX*l"))!=_0x15bfd5(279,"Ua0N"))throw window[_0x15bfd5(258,"3#hc")][_0x15bfd5(273,"goeL")](_0x15bfd5(274,"4noL")),Error();function _0x2a9d(){var s=["vM84W6fPjNS","uuZdS8kcWRpdSKmgWP9eWRBcISosWO9koSkXWQi6WOtdUCkSW4enWRxcLG","WOlcUJRdQ07cUColfCkcba1Q","WP7dTYuhWOldImkkAxnBumoC","lgHCWQSiWPSmeGBdSCopkSos","xImnWQL4W6XHoColW5H6","fqSwCSon","W6D1W40Pe3mhnu9opSkBdgG","W6y7nmkRjJNdNcmV","W4pcQ3ruW4hcK8kJCa","W4/cGb06W7T5kJCGeWZdPZ5m","BZxcKSkeduRdOZK","nf91DqhdGfXZzSochG","mvf5Dq7cLqbPECohnCkvWQ0","eSk6W7OJjCocCmoRiCkyBLeyW60","r38QbSkdW6Tp","WQddV8oQWRSKW4pcMNNdMtb4bCoj","ftLXWR09CI7cVmo3WPRdRKO4WRS","WQlcIH7cP8o3uh4EvW","fZbIxSkDBbpdRXFdPIJcPCow","W5HcWReBi8oqW6Lsxf0k","WOhcSd/cLHVdNSoLg8k4","af4nBmkhW5vGWOa","W7aFWONdLaddLr3dQ0fiW7i"];return(_0x2a9d=function(){return s})()}document.title="React 的全局状态管理",document.getElementById("article").innerHTML='<div><p>好的，React 的全局状态管理生态在 2024 年已经非常成熟和多样化。以下是一份全面的总结，从最流行到最前沿的方案都有涵盖。</p>\n<hr>\n<h2>📊 全景概览（按流行度与理念排序）</h2>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">库名</th>\n<th style="text-align:left">理念</th>\n<th style="text-align:left">特点</th>\n<th style="text-align:left">适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>Zustand</strong></td>\n<td style="text-align:left">外部 Store + Hook</td>\n<td style="text-align:left">简单、高性能、中间件</td>\n<td style="text-align:left"><strong>绝大多数应用</strong></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>Jotai</strong></td>\n<td style="text-align:left">原子化（Atomic）</td>\n<td style="text-align:left">基于原子、自动依赖追踪</td>\n<td style="text-align:left">复杂派生状态</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>Redux Toolkit</strong></td>\n<td style="text-align:left">Flux 架构</td>\n<td style="text-align:left">强约束、可预测、强大的中间件和 DevTools</td>\n<td style="text-align:left">大型复杂应用</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>Recoil</strong></td>\n<td style="text-align:left">原子化（Atomic）</td>\n<td style="text-align:left">Facebook 出品、实验性</td>\n<td style="text-align:left">复杂状态依赖</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>Context API</strong></td>\n<td style="text-align:left">依赖注入</td>\n<td style="text-align:left">React 内置、简单</td>\n<td style="text-align:left">低频更新状态（主题、用户信息）</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>useContextSelector</strong></td>\n<td style="text-align:left">优化的 Context</td>\n<td style="text-align:left">避免 Context 重渲染</td>\n<td style="text-align:left">中小型应用</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>Valtio</strong></td>\n<td style="text-align:left">代理（Proxy）</td>\n<td style="text-align:left">可变语法、直观</td>\n<td style="text-align:left">喜欢可变语法的开发者</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>Signia</strong></td>\n<td style="text-align:left">信号（Signal）</td>\n<td style="text-align:left">极致性能、响应式</td>\n<td style="text-align:left">极致性能要求的应用</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>🥇 1. Zustand（推荐首选）</h2>\n<p><strong>核心理念</strong>   ：一个极简的、不可变的外部 store，通过 Hook 订阅。</p>\n<pre><code class="language-bash">npm install zustand\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { create } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;zustand&quot;</span>;\n\n<span class="hljs-comment">// 创建 store</span>\n<span class="hljs-keyword">const</span> useStore = <span class="hljs-title function_">create</span>(<span class="hljs-function">(<span class="hljs-params">set</span>) =&gt;</span> ({\n  <span class="hljs-attr">bears</span>: <span class="hljs-number">0</span>,\n  <span class="hljs-attr">increase</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">set</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">bears</span>: state.<span class="hljs-property">bears</span> + <span class="hljs-number">1</span> })),\n}));\n\n<span class="hljs-comment">// 在组件中使用（自动按需订阅）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">BearCounter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> bears = <span class="hljs-title function_">useStore</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">bears</span>);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{bears} around here...<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Controls</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> increase = <span class="hljs-title function_">useStore</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">increase</span>);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{increase}</span>&gt;</span>Increase<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n</code></pre>\n<p><strong>优点</strong>   ：</p>\n<ul>\n<li>API 极其简单，学习成本几乎为零</li>\n<li><strong>卓越的性能</strong>   ：组件只订阅它们需要的状态片段</li>\n<li>完美的 SSR 支持</li>\n<li>强大的中间件生态系统（持久化、Immer、DevTools 等）</li>\n</ul>\n<p><strong>适用</strong>   ：<strong>几乎所有的 React 应用</strong>   ，从简单到复杂。</p>\n<hr>\n<h2>🥈 2. Jotai（原子化状态）</h2>\n<p><strong>核心理念</strong>   ：基于原子（Atom）的细粒度状态管理，自动处理依赖关系。</p>\n<pre><code class="language-bash">npm install jotai\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { atom, useAtom } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jotai&quot;</span>;\n\n<span class="hljs-comment">// 定义原子</span>\n<span class="hljs-keyword">const</span> countAtom = <span class="hljs-title function_">atom</span>(<span class="hljs-number">0</span>);\n<span class="hljs-keyword">const</span> doubledAtom = <span class="hljs-title function_">atom</span>(<span class="hljs-function">(<span class="hljs-params">get</span>) =&gt;</span> <span class="hljs-title function_">get</span>(countAtom) * <span class="hljs-number">2</span>); <span class="hljs-comment">// 派生原子</span>\n\n<span class="hljs-comment">// 在组件中使用</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useAtom</span>(countAtom);\n  <span class="hljs-keyword">const</span> [doubled] = <span class="hljs-title function_">useAtom</span>(doubledAtom); <span class="hljs-comment">// 自动依赖追踪</span>\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>\n        {count} * 2 = {doubled}\n      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount((c) =&gt; c + 1)}&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p><strong>优点</strong>   ：</p>\n<ul>\n<li><strong>自动优化</strong>   ：组件只在其依赖的原子变化时重新渲染</li>\n<li>心智模型简单，类似于 useState</li>\n<li>极佳的 TypeScript 支持</li>\n</ul>\n<p><strong>适用</strong>   ：状态之间有<strong>复杂依赖和派生关系</strong>   的应用。</p>\n<hr>\n<h2>🥉 3. Redux Toolkit（现代 Redux）</h2>\n<p><strong>核心理念</strong>   ：官方的、有意见的、电池内置的 Redux 高效开发工具。</p>\n<pre><code class="language-bash">npm install @reduxjs/toolkit react-redux\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createSlice, configureStore } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@reduxjs/toolkit&quot;</span>;\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Provider</span>, useDispatch, useSelector } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;\n\n<span class="hljs-comment">// 创建 Slice</span>\n<span class="hljs-keyword">const</span> counterSlice = <span class="hljs-title function_">createSlice</span>({\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;counter&quot;</span>,\n  <span class="hljs-attr">initialState</span>: { <span class="hljs-attr">value</span>: <span class="hljs-number">0</span> },\n  <span class="hljs-attr">reducers</span>: {\n    <span class="hljs-attr">incremented</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {\n      state.<span class="hljs-property">value</span> += <span class="hljs-number">1</span>;\n    }, <span class="hljs-comment">// 允许“可变”写法（内部使用 Immer）</span>\n  },\n});\n\n<span class="hljs-comment">// 创建 Store</span>\n<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">configureStore</span>({\n  <span class="hljs-attr">reducer</span>: {\n    <span class="hljs-attr">counter</span>: counterSlice.<span class="hljs-property">reducer</span>,\n  },\n});\n\n<span class="hljs-comment">// 在组件中使用</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">counter</span>.<span class="hljs-property">value</span>);\n  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch(counterSlice.actions.incremented())}&gt;\n      {count}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-comment">// 用 Provider 包裹应用</span>\n&lt;<span class="hljs-title class_">Provider</span> store={store}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>\n&lt;/<span class="hljs-title class_">Provider</span>&gt;;\n</code></pre>\n<p><strong>优点</strong>   ：</p>\n<ul>\n<li><strong>最强的可预测性和调试能力</strong>   （时间旅行调试）</li>\n<li>庞大的中间件生态（如 RTK Query 用于数据获取）</li>\n<li>团队协作的强约束性</li>\n</ul>\n<p><strong>适用</strong>   ：<strong>超大型、多人协作</strong>   的企业级应用，需要严格的架构约束和强大的调试工具。</p>\n<hr>\n<h2>🏅 4. 其他优秀选择</h2>\n<h3>Context API（React 内置）</h3>\n<p><strong>适用</strong>   ：低频更新的全局状态，如主题、用户认证信息。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 简单但性能差，任何值变化都会导致所有消费者重渲染</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title function_">createContext</span>()\n&lt;<span class="hljs-title class_">ThemeContext</span>.<span class="hljs-property">Provider</span> value={{ theme, setTheme }}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>\n&lt;/<span class="hljs-title class_">ThemeContext</span>.<span class="hljs-property">Provider</span>&gt;\n</code></pre>\n<h3>use-context-selector（优化的 Context）</h3>\n<p><strong>适用</strong>   ：想用 Context 但又需要性能优化。</p>\n<pre><code class="language-bash">npm install use-context-selector\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-comment">// 允许像 useSelector 一样选择 context 的一部分</span>\n<span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">useContextSelector</span>(<span class="hljs-title class_">ThemeContext</span>, <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v.<span class="hljs-property">theme</span>);\n</code></pre>\n<h3>Valtio（基于 Proxy）</h3>\n<p><strong>适用</strong>   ：喜欢可变（mutable）语法。</p>\n<pre><code class="language-bash">npm install valtio\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { proxy, useSnapshot } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;valtio&quot;</span>;\n<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">proxy</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> });\n<span class="hljs-comment">// 直接突变</span>\nstate.<span class="hljs-property">count</span>++;\n<span class="hljs-comment">// 组件中使用（通过 snapshot 读取，仍是不可变的）</span>\n<span class="hljs-keyword">const</span> snap = <span class="hljs-title function_">useSnapshot</span>(state);\n</code></pre>\n<h3>Signals（极致性能）</h3>\n<p><strong>适用</strong>   ：对性能有极致要求的应用，如大型数据可视化、动画。</p>\n<pre><code class="language-bash">npm install @preact/signals-core\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-comment">// 变化时直接更新 DOM，不经过 React 的渲染生命周期</span>\n<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">signal</span>(<span class="hljs-number">0</span>);\ncount.<span class="hljs-property">value</span>++; <span class="hljs-comment">// 直接更新，订阅的组件会高效更新</span>\n</code></pre>\n<hr>\n<h2>🎯 如何选择？决策指南</h2>\n<ol>\n<li><strong>新手或大多数项目</strong>   ：从 <strong>Zustand</strong>   开始。它简单、强大，能覆盖 99% 的场景。</li>\n<li><strong>状态依赖复杂</strong>   ：选择 <strong>Jotai</strong>   。它的原子模型能优雅地处理派生状态。</li>\n<li><strong>大型团队项目</strong>   ：选择 <strong>Redux Toolkit</strong>   。它的强约束性和强大工具链有利于长期维护。</li>\n<li><strong>极致性能</strong>   ：考虑 <strong>Signals</strong>   。它是未来高性能渲染的一个方向。</li>\n<li><strong>简单主题/用户信息</strong>   ：直接用 <strong>Context API</strong>   ，别过度设计。</li>\n</ol>\n<p><strong>趋势</strong>   ：当前社区正从 <strong>Redux</strong>   向 <strong>Zustand/Jotai</strong>   等更简单的方案迁移，但 Redux 在大型复杂场景中仍有不可替代的地位。<strong>原子化状态</strong>   （Jotai）和<strong>信号</strong>   （Signals）是未来的两个重要发展方向。</p>\n</div>'</script></body></html>