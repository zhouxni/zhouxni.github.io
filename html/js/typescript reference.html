<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1064(s,e){var c=_0x38a0();return(_0x1064=function(e,n){var o=c[e-=221];void 0===_0x1064.xXOqAa&&(_0x1064.jOsMvg=function(e,n){var o,t=[],s=0,c="";for(e=(e=>{for(var n,o,t="",s="",c=0,r=0;o=e.charAt(r++);~o&&(n=c%4?64*n+o:o,c++%4)&&(t+=String.fromCharCode(255&n>>(-2*c&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var d=0,a=t.length;d<a;d++)s+="%"+("00"+t.charCodeAt(d).toString(16)).slice(-2);return decodeURIComponent(s)})(e),r=0;r<256;r++)t[r]=r;for(r=0;r<256;r++)s=(s+t[r]+n.charCodeAt(r%n.length))%256,o=t[r],t[r]=t[s],t[s]=o;for(var r=0,s=0,d=0;d<e.length;d++)o=t[r=(r+1)%256],t[r]=t[s=(s+t[r])%256],t[s]=o,c+=String.fromCharCode(e.charCodeAt(d)^t[(t[r]+t[s])%256]);return c},s=arguments,_0x1064.xXOqAa=!0);var e=e+c[0],t=s[e];return t?o=t:(void 0===_0x1064.ZYBjHa&&(_0x1064.ZYBjHa=!0),o=_0x1064.jOsMvg(o,n),s[e]=o),o})(s,e)}function _0x38a0(){var e=["vbOSbWNdGqBcV8kIWP14u38","W7qfBCoAWQtdG8kkWP/cJCoOW6uJW4K","uCoWWQ8Acq","ncDVFbSAW6u6WQ90WPtdPmoMWQjxcH1hFCokWPNcQmkxp8kphG","W699nGPGA8kbWRP3eMBcNZ8","WORdN8oCmmk6esriW4pdRSkAWRa","W4P0oKRdS8oyWPdcJvldVmokWRD1","W6T2mq1JBCo2WRvQo1NcSq","WP0zy2G4aJldPG","WPqyatPMEJddOZbgeSoh","cCkgWPRdQsRcK8kZ","tZrpW5JcOchdICkHWPldO8k1WPGZBa","W7FdO2ddHSkWW793t2ZcI2RcKG","WOpdNSk+ySoKAszn","W6OwWRKnWQCGD8kkW68","W4P8nuhdTSoAWPRcGLBdO8ocWQPL","W4WbWPvOB8oPW5pdMmk3W6CHfq","W5XWqMWCWQNcPcrLWQ7dOIKc","WP9oCmkCwCofv8ouW41dzINcQIW","WO8tpMZdGeSE","p1VdHSkNWRuknW","r27dNw5fgHxdPa","qWvWWRRdIXJcQXCcmfOH","DGeKWPlcPmovsq"];return(_0x38a0=function(){return e})()}var _0x2a8d1e=_0x1064;if((()=>{for(var e=_0x1064,n=_0x38a0();;)try{if(896788==+parseInt(e(228,"P3rU"))+-parseInt(e(240,"]buW"))/2*(-parseInt(e(237,"D0e2"))/3)+-parseInt(e(221,"GVP%"))/4+parseInt(e(226,"nVA9"))/5*(-parseInt(e(234,"nVA9"))/6)+parseInt(e(222,"@rcw"))/7+-parseInt(e(225,"P3rU"))/8+parseInt(e(232,"*kWU"))/9)break;n.push(n.shift())}catch(e){n.push(n.shift())}})(),localStorage[_0x2a8d1e(231,"De1H")](_0x2a8d1e(235,"W2EN"))!=_0x2a8d1e(223,"3tT$"))throw window[_0x2a8d1e(242,"OKkY")][_0x2a8d1e(244,"@g%*")](_0x2a8d1e(224,"cmx0")),Error();document.title="typescript reference",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>&lt;reference&gt;</code> 指令是一种用于管理类型声明文件（<code>.d.ts</code> 文件）之间依赖关系的机制。它允许你显式地告诉 TypeScript 编译器，一个文件依赖于另一个文件中的类型声明。这在处理大型代码库或复杂类型依赖时特别有用。</p>\n<h3><code>&lt;reference&gt;</code> 指令的语法</h3>\n<p><code>&lt;reference&gt;</code> 指令使用三斜线语法（<code>///</code>），后面跟着 <code>&lt;reference path=&quot;...&quot; /&gt;</code> 或 <code>&lt;reference types=&quot;...&quot; /&gt;</code>。</p>\n<h4>1. <code>&lt;reference path=&quot;...&quot; /&gt;</code></h4>\n<ul>\n<li>\n<p><strong>用途</strong>  ：用于引用同一项目中的其他 <code>.d.ts</code> 文件。</p>\n</li>\n<li>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// file1.d.ts</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;my-module&quot;</span> {\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span>;\n}\n\n<span class="hljs-comment">// file2.ts</span>\n<span class="hljs-comment">/// &lt;reference path=&quot;./file1.d.ts&quot; /&gt;</span>\n<span class="hljs-keyword">import</span> { myFunction } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;my-module&quot;</span>;\n\n<span class="hljs-title function_">myFunction</span>();\n</code></pre>\n<p>在这个例子中，<code>file2.ts</code> 通过 <code>&lt;reference path=&quot;./file1.d.ts&quot; /&gt;</code> 引用了 <code>file1.d.ts</code>，从而可以使用 <code>my-module</code> 中声明的 <code>myFunction</code>。</p>\n</li>\n</ul>\n<h4>2. <code>&lt;reference types=&quot;...&quot; /&gt;</code></h4>\n<ul>\n<li>\n<p><strong>用途</strong>  ：用于引用已发布的类型声明包（通常通过 npm 安装）。</p>\n</li>\n<li>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-typescript"><span class="hljs-comment">/// &lt;reference types=&quot;node&quot; /&gt;</span>\n\n<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;\n\nfs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;file.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>);\n</code></pre>\n<p>在这个例子中，<code>&lt;reference types=&quot;node&quot; /&gt;</code> 告诉 TypeScript 编译器，这个文件依赖于 Node.js 的类型声明。这通常用于在 TypeScript 项目中使用 Node.js 的 API。</p>\n</li>\n</ul>\n<h3>使用场景</h3>\n<ul>\n<li><strong>大型项目</strong>  ：在大型项目中，类型声明可能分散在多个文件中。使用 <code>&lt;reference&gt;</code> 指令可以显式地管理这些文件之间的依赖关系。</li>\n<li><strong>第三方库</strong>  ：当你使用第三方库时，可能需要引用该库的类型声明文件。如果库是通过 npm 安装的，并且包含了类型声明，通常不需要手动使用 <code>&lt;reference types=&quot;...&quot; /&gt;</code>，因为 TypeScript 会自动查找 <code>node_modules/@types</code> 目录下的类型声明。但在某些情况下，你可能需要显式地引用。</li>\n<li><strong>全局类型声明</strong>  ：如果你有一些全局类型声明（例如，为浏览器环境声明的全局变量或函数），可以使用 <code>&lt;reference&gt;</code> 指令来确保这些声明在其他文件中可用。</li>\n</ul>\n<h3>注意事项</h3>\n<ul>\n<li><strong>模块系统</strong>  ：随着 ES 模块和 CommonJS 模块的普及，<code>&lt;reference&gt;</code> 指令的使用场景已经减少。在大多数情况下，TypeScript 编译器能够自动解析模块之间的依赖关系，而无需显式地使用 <code>&lt;reference&gt;</code>。</li>\n<li><strong>类型查找</strong>  ：TypeScript 编译器会自动查找 <code>node_modules/@types</code> 目录下的类型声明文件，以及项目中包含的 <code>.d.ts</code> 文件。因此，在大多数情况下，你不需要手动使用 <code>&lt;reference&gt;</code> 指令来引用这些文件。</li>\n<li><strong>避免循环依赖</strong>  ：使用 <code>&lt;reference&gt;</code> 指令时，要避免创建循环依赖，这可能会导致编译错误或意外的行为。</li>\n</ul>\n<h3>替代方案</h3>\n<ul>\n<li><strong>使用 <code>tsconfig.json</code></strong>  ：通过配置 <code>tsconfig.json</code> 文件中的 <code>include</code> 和 <code>typeRoots</code> 选项，可以指定 TypeScript 编译器应该包含哪些文件和类型声明目录。</li>\n<li><strong>模块导入</strong>  ：对于大多数模块化的 TypeScript 项目，使用 <code>import</code> 和 <code>export</code> 关键字来管理模块之间的依赖关系更为推荐。</li>\n</ul>\n<h3>总结</h3>\n<p><code>&lt;reference&gt;</code> 指令在 TypeScript 中用于管理类型声明文件之间的依赖关系。然而，随着模块系统的普及和 TypeScript 编译器的改进，其使用场景已经减少。在大多数情况下，更推荐使用模块导入和 <code>tsconfig.json</code> 配置来管理依赖关系。</p>\n</div>'</script></body></html>