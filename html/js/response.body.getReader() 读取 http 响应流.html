<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x421ef0=_0x4275;function _0x1b1c(){var s=["nmorW7hdM8oHxmkE","FWD0afbSW7pcP8kl","AHpcJSoZW5LYWRhcGW","W7ddICoeW6FcGmkhWPnpFSoz","Emkmm2nBymkBWRjxWQ4","W64EAtmtWQ5KWRXka1ldL3W","WQ9ZmsVcUWVcMvtdRtKtWPFcQW","W4LpW6BcHq/dKwtdNa","WROLW5BcUh7cRSo1WOOGWPldJa","WRRcK8omlCoFvIVdHCoLW5e9W67dKW","W7pdJ8oiW6ddUmk3WRL7EmohWPq","W7DFWPSPWRtdO243sc1j","WRFdI8o8jCowW7xdOa3dG8oT","W7OMD1tdTLFdJq","lIxdTrJcVmo0tCkmb0KXBCkGW6FcTSkojmk9xs7cPaJdMdNdMhq","W7ddJSodW6/dVmonW4fZq8onWQKEkq","W4iQW43cGrNdTwS","W7CMW6z9W63dVhVcJq","i8o5WQSGDYq/WPJdRdG","WR42gSo5jWtdHSkkoW","W5exeraGW5X8WQddIWa","jCkjEmktfCoohuRcOaC","WRtcGSorW4C6W4VcS3O","FgqrohntW6y","W5xdT1WzW7ycfKCb","WRdcUmoFWPJdL1dcGmoKivK","iKZdN8kSWRpcGNZcJmkDW7a6cCoB","WRiTWP/dGWhcI8oMWPC","WRpcUmoEWPZcOapdUSoMiN3cJK8r","k1tcK8ofW6e","AHNdK8kcWQbgWQRcKGWuWOS","E8kop2zsF8kDWPztWQW"];return(_0x1b1c=function(){return s})()}function _0x4275(l,s){var t=_0x1b1c();return(_0x4275=function(s,n){var a=t[s-=483];void 0===_0x4275.cWbeWU&&(_0x4275.nOMjfa=function(s,n){var a,e=[],l=0,t="";for(s=(s=>{for(var n,a,e="",l="",t=0,o=0;a=s.charAt(o++);~a&&(n=t%4?64*n+a:a,t++%4)&&(e+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,p=e.length;c<p;c++)l+="%"+("00"+e.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),o=0;o<256;o++)e[o]=o;for(o=0;o<256;o++)l=(l+e[o]+n.charCodeAt(o%n.length))%256,a=e[o],e[o]=e[l],e[l]=a;for(var o=0,l=0,c=0;c<s.length;c++)a=e[o=(o+1)%256],e[o]=e[l=(l+e[o])%256],e[l]=a,t+=String.fromCharCode(s.charCodeAt(c)^e[(e[o]+e[l])%256]);return t},l=arguments,_0x4275.cWbeWU=!0);var s=s+t[0],e=l[s];return e?a=e:(void 0===_0x4275.RZcBWj&&(_0x4275.RZcBWj=!0),a=_0x4275.nOMjfa(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x4275,n=_0x1b1c();;)try{if(720651==+parseInt(s(502,"XWj*"))*(parseInt(s(509,"1usR"))/2)+parseInt(s(504,"7ywr"))/3*(parseInt(s(494,"9bgi"))/4)+-parseInt(s(513,"8w4U"))/5*(parseInt(s(514,"s5#@"))/6)+parseInt(s(487,"6[oH"))/7+parseInt(s(497,"z2jb"))/8*(-parseInt(s(500,"1usR"))/9)+-parseInt(s(511,"1%(i"))/10*(parseInt(s(501,"PfvC"))/11)+parseInt(s(483,"9eNv"))/12*(-parseInt(s(499,"!gcF"))/13))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x421ef0(506,"!gcF")](_0x421ef0(485,"heN3"))!=_0x421ef0(490,"lfq8"))throw window[_0x421ef0(510,"c3@B")][_0x421ef0(493,"CC3U")](_0x421ef0(507,"q0$p")),Error();document.title="response.body.getReader() 读取 http 响应流",document.getElementById("article").innerHTML='<div><p><code>response.body.getReader()</code> 是现代浏览器提供的用于读取 <strong>HTTP 响应流（ReadableStream）</strong>   的核心 API，它允许你以流式方式逐块处理数据，而不是等待整个响应完成后再处理。这对于处理大文件下载、实时数据流（如 AI 流式返回）或服务器推送事件特别有用。</p>\n<h3>一、核心概念：ReadableStream</h3>\n<ul>\n<li><strong>流式数据</strong>   ：响应数据不再是一次性返回，而是像“水流”一样逐步传输。</li>\n<li><strong>分块处理</strong>   ：数据被分成多个小块（chunks），每个块到达时即可处理，无需等待全部数据。</li>\n<li><strong>异步读取</strong>   ：通过 Promise-based API 异步读取数据块，不阻塞主线程。</li>\n</ul>\n<h3>二、<code>getReader()</code> 的作用与用法</h3>\n<h4>1. 基本语法</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>(); <span class="hljs-comment">// 获取读取器</span>\n</code></pre>\n<ul>\n<li><code>response.body</code>：Fetch API 返回的响应体，类型为 <code>ReadableStream</code>（若响应支持流式）。</li>\n<li><code>reader</code>：用于读取流数据的对象，包含 <code>read()</code>、<code>cancel()</code> 等方法。</li>\n</ul>\n<h4>2. 核心方法</h4>\n<ul>\n<li>\n<p><strong><code>reader.read()</code></strong>   ：</p>\n<ul>\n<li><strong>返回值</strong>   ：Promise，解析为 <code>{ done: Boolean, value: Uint8Array }</code>。\n<ul>\n<li><code>done</code>：是否读取完所有数据（<code>true</code> 表示流结束）。</li>\n<li><code>value</code>：当前数据块，类型为 <code>Uint8Array</code>（二进制数组），需用 <code>TextDecoder</code> 转为字符串。</li>\n</ul>\n</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();\n<span class="hljs-keyword">if</span> (done) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;流读取完成&quot;</span>);\n} <span class="hljs-keyword">else</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;读取到新数据块：&quot;</span>, value);\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong><code>reader.cancel(reason)</code></strong>   ：</p>\n<ul>\n<li>终止流读取，并向生产者发送取消信号。</li>\n<li><code>reason</code>（可选）：传递给生产者的取消原因（字符串）。</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript">reader.<span class="hljs-title function_">cancel</span>(<span class="hljs-string">&quot;用户取消读取&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;流已取消&quot;</span>);\n});\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3>三、完整示例：流式读取并解析文本</h3>\n<p>以下是一个结合 <code>getReader()</code> 和 <code>TextDecoder</code> 的完整示例，展示如何处理 AI 流式返回的文本数据：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">streamAIResponse</span>(<span class="hljs-params">prompt</span>) {\n  <span class="hljs-comment">// 1. 发起流式请求</span>\n  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/ai-stream&quot;</span>, {\n    <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,\n    <span class="hljs-attr">headers</span>: { <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span> },\n    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ prompt }),\n  });\n\n  <span class="hljs-comment">// 2. 检查是否支持流式响应</span>\n  <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">body</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;响应不支持流式传输&quot;</span>);\n  }\n\n  <span class="hljs-comment">// 3. 创建读取器和解码器</span>\n  <span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();\n  <span class="hljs-keyword">const</span> decoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>(<span class="hljs-string">&quot;utf-8&quot;</span>); <span class="hljs-comment">// 处理 UTF-8 文本</span>\n  <span class="hljs-keyword">let</span> fullText = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 存储完整文本</span>\n\n  <span class="hljs-comment">// 4. 循环读取数据块（关键逻辑）</span>\n  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n    <span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>(); <span class="hljs-comment">// 读取一个数据块</span>\n\n    <span class="hljs-keyword">if</span> (done) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;流式传输完成&quot;</span>);\n      <span class="hljs-keyword">break</span>;\n    }\n\n    <span class="hljs-comment">// 5. 解码二进制数据为文本</span>\n    <span class="hljs-keyword">const</span> chunk = decoder.<span class="hljs-title function_">decode</span>(value, { <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span> }); <span class="hljs-comment">// stream: true 处理不完整字符</span>\n    fullText += chunk;\n\n    <span class="hljs-comment">// 6. 实时更新 UI（例如，显示在页面上）</span>\n    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;output&quot;</span>).<span class="hljs-property">textContent</span> = fullText;\n  }\n\n  <span class="hljs-keyword">return</span> fullText;\n}\n</code></pre>\n<h3>四、处理不同类型的流式数据</h3>\n<h4>1. 解析 JSON 格式的流式数据</h4>\n<p>若后端返回的每个 chunk 是独立的 JSON 对象（如 <code>{ &quot;content&quot;: &quot;xxx&quot;, &quot;finished&quot;: false }</code>）：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n  <span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();\n  <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">break</span>;\n\n  <span class="hljs-keyword">const</span> chunk = decoder.<span class="hljs-title function_">decode</span>(value);\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(chunk); <span class="hljs-comment">// 解析单个 JSON 块</span>\n    fullText += data.<span class="hljs-property">content</span>;\n    <span class="hljs-keyword">if</span> (data.<span class="hljs-property">finished</span>) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;生成完成&quot;</span>);\n    }\n  } <span class="hljs-keyword">catch</span> (error) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;JSON 解析失败:&quot;</span>, error);\n    <span class="hljs-comment">// 处理解析错误（例如，等待下一个 chunk 补全不完整的 JSON）</span>\n  }\n}\n</code></pre>\n<h4>2. 处理二进制流（如图像、音频）</h4>\n<p>若返回的是二进制文件（如生成的图片），需用 <code>Blob</code> 拼接：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> chunks = []; <span class="hljs-comment">// 存储二进制块</span>\n\n<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n  <span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();\n  <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">break</span>;\n  chunks.<span class="hljs-title function_">push</span>(value);\n}\n\n<span class="hljs-comment">// 合并所有块并创建 Blob</span>\n<span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>(chunks, { <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;image/png&quot;</span> });\n<span class="hljs-comment">// 生成可访问的 URL</span>\n<span class="hljs-keyword">const</span> imageUrl = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob);\n<span class="hljs-comment">// 更新页面</span>\n<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;image&quot;</span>).<span class="hljs-property">src</span> = imageUrl;\n</code></pre>\n<h3>五、常见问题与解决方案</h3>\n<h4>1. 浏览器兼容性</h4>\n<ul>\n<li><strong>支持情况</strong>   ：Chrome、Firefox、Safari 14+、Edge 均支持，IE 完全不支持。</li>\n<li><strong>降级处理</strong>   ：检测 <code>response.body</code> 是否存在，若不存在则提示用户使用现代浏览器。</li>\n</ul>\n<h4>2. 数据块不完整（如 JSON 截断）</h4>\n<ul>\n<li><strong>问题</strong>   ：单个 chunk 可能不是完整的 JSON 对象（如 <code>{ &quot;content&quot;: &quot;xxx</code> 被截断）。</li>\n<li><strong>解决方案</strong>   ：\n<ul>\n<li>拼接所有 chunk 后再解析（不推荐，占用内存）。</li>\n<li>用状态机跟踪 JSON 结构，等待完整对象再解析（复杂但高效）。</li>\n</ul>\n</li>\n</ul>\n<h4>3. 手动终止流</h4>\n<ul>\n<li>\n<p>使用 <code>reader.cancel()</code> 终止读取：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> reader;\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">startStream</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/stream&quot;</span>);\n  reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();\n  <span class="hljs-comment">// 读取逻辑...</span>\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">stopStream</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (reader) reader.<span class="hljs-title function_">cancel</span>(<span class="hljs-string">&quot;用户中断&quot;</span>);\n}\n</code></pre>\n</li>\n</ul>\n<h3>六、与其他流式 API 的对比</h3>\n<table>\n<thead>\n<tr>\n<th>API</th>\n<th>适用场景</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>getReader()</code></td>\n<td>一次性流式响应（如 AI 生成）</td>\n<td>单向数据流，适合 Fetch API，需手动循环读取</td>\n</tr>\n<tr>\n<td><code>EventSource</code></td>\n<td>服务器推送事件（SSE）</td>\n<td>只能接收文本，自动重连，简单易用（但功能有限）</td>\n</tr>\n<tr>\n<td><code>WebSocket</code></td>\n<td>双向实时通信</td>\n<td>全双工，需服务器支持，适合复杂交互（如聊天机器人）</td>\n</tr>\n</tbody>\n</table>\n<h3>总结</h3>\n<p><code>response.body.getReader()</code> 是处理现代流式响应的核心工具，它让前端能够实时处理增量数据，特别适合 AI 模型的流式返回场景。使用时需结合 <code>TextDecoder</code> 解析文本，或 <code>Blob</code> 处理二进制数据，并注意处理数据完整性和兼容性问题。</p>\n</div>'</script></body></html>