<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0xb741f8=_0x7739;function _0x7739(p,s){var t=_0xab2f();return(_0x7739=function(s,n){var a=t[s-=171];void 0===_0x7739.XTBzSA&&(_0x7739.ntpDtu=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,c=0;a=s.charAt(c++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,r=l.length;e<r;e++)p+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(p)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)p=(p+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[p],l[p]=a;for(var c=0,p=0,e=0;e<s.length;e++)a=l[c=(c+1)%256],l[c]=l[p=(p+l[c])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(e)^l[(l[c]+l[p])%256]);return t},p=arguments,_0x7739.XTBzSA=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x7739.buVWNb&&(_0x7739.buVWNb=!0),a=_0x7739.ntpDtu(a,n),p[s]=a),a})(p,s)}function _0xab2f(){var s=["bY/dMmo+nf4XW5FdIwxdVmkG","d8k9WQvRASoaFmoZW47cMdldNmoT","CxhcPN1wefCdWQ/dIxZdHG","WQLyWQWDWRNdLCotsq","W4NdSeHdzSkKlSo1","CCkSWOeqWOaDW5i","jrpdI8krW4/cUe/dIw3dGv5ZAW","W51nW74bFZFdQCoX","DNlcP31tfWOoWQ7dNhZdI14","tfBcUCocW61hseuWmg/cGZ0","E8oKiwRcOrG2WR0","WP3cRrLJocfwW4C","rCoHemoBWPa","t8k5qSojW6HQaLtcSmo9","zepcK8kDWOFcUCkl","nCkmBcpdQSoPWRa+y8oUW7G","lCkYW5pcJmkvW7BcHCkdcM7dIHyy","W5KyW4C1W7JdQXLa","o8kfW7ZdUh7dMXi","CNlcOh5vsfGmWOxdOh8","bYZdN8o9nIS+W5ZdSvJdGW","WQbJteddV1ldSue","WQvSgW7cNwVdGfPajL4","W74uAIJcIGDfuCkr","W40sEshcMbDR","x8oyW7xdJsxcPmovWQJdPmkvW6HewqxcHce1WRVcLSkYwgFcVSkjW73cTa","WPFcRr4wimkLcCopWOmMW6e","FttdGreXth8","dexcM2uqW6hdImk6W51Q","WQdcJCo3mGD+frJcUuGromoJ","WO0giCkqWRhdTCosW6FcHmktWPq","WRu7F8k7gSkWla"];return(_0xab2f=function(){return s})()}if((()=>{for(var s=_0x7739,n=_0xab2f();;)try{if(379038==+parseInt(s(181,"Z!XM"))*(parseInt(s(193,"LmRE"))/2)+-parseInt(s(195,"!z5G"))/3+parseInt(s(179,"tN9Q"))/4*(parseInt(s(182,"k2XO"))/5)+parseInt(s(188,"a5kM"))/6*(-parseInt(s(190,"s2(@"))/7)+parseInt(s(171,")X1#"))/8*(-parseInt(s(199,"h0^E"))/9)+-parseInt(s(201,"L!6L"))/10*(-parseInt(s(194,"k2XO"))/11)+-parseInt(s(178,"7PIQ"))/12*(-parseInt(s(183,"76gE"))/13))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0xb741f8(180,"Ufs]")](_0xb741f8(185,"nAG)"))!=_0xb741f8(174,"@GPb"))throw window[_0xb741f8(198,"a5kM")][_0xb741f8(186,"nAG)")](_0xb741f8(187,"5PxN")),Error();document.title="Service Worker 中动态修改 CACHE_NAME",document.getElementById("article").innerHTML='<div><p>在 Service Worker 中动态修改 <code>CACHE_NAME</code> 可以通过以下几种方式实现，确保缓存版本可控且能自动更新：</p>\n<hr>\n<h3><strong>1. 使用环境变量或版本号动态生成</strong></h3>\n<p>在注册 Service Worker 时，通过变量动态传递 <code>CACHE_NAME</code>：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 主线程（如 index.js）</span>\n<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_VERSION</span> = <span class="hljs-string">&#x27;v2&#x27;</span>; <span class="hljs-comment">// 可替换为环境变量、日期或 Git Hash</span>\n<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_NAME</span> = <span class="hljs-string">`my-app-cache-<span class="hljs-subst">${CACHE_VERSION}</span>`</span>;\n\nnavigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;/sw.js&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">registration</span> =&gt;</span> {\n  <span class="hljs-comment">// 将 CACHE_NAME 传递给 Service Worker</span>\n  registration.<span class="hljs-property">active</span>.<span class="hljs-title function_">postMessage</span>({ \n    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_CACHE_NAME&#x27;</span>, \n    <span class="hljs-attr">cacheName</span>: <span class="hljs-variable constant_">CACHE_NAME</span> \n  });\n});\n</code></pre>\n<hr>\n<h3><strong>2. Service Worker 中接收动态名称</strong></h3>\n<p>在 <code>sw.js</code> 中监听消息并更新缓存名称：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// sw.js</span>\n<span class="hljs-keyword">let</span> dynamicCacheName = <span class="hljs-string">&#x27;my-app-cache-v1&#x27;</span>; <span class="hljs-comment">// 默认值</span>\n\nself.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span>.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;SET_CACHE_NAME&#x27;</span>) {\n    dynamicCacheName = event.<span class="hljs-property">data</span>.<span class="hljs-property">cacheName</span>;\n  }\n});\n\nself.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  event.<span class="hljs-title function_">waitUntil</span>(\n    caches.<span class="hljs-title function_">open</span>(dynamicCacheName).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">addAll</span>([<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;/index.html&#x27;</span>, <span class="hljs-string">&#x27;/main.js&#x27;</span>]);\n    })\n  );\n});\n</code></pre>\n<hr>\n<h3><strong>3. 基于时间戳或版本号的自动化更新</strong></h3>\n<p>结合 <code>package.json</code> 版本号或构建时间戳生成唯一缓存名：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 构建时生成版本号（如通过 Webpack/Vite 插件）</span>\n<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_NAME</span> = <span class="hljs-string">`my-app-<span class="hljs-subst">${process.env.REACT_APP_VERSION || <span class="hljs-built_in">Date</span>.now()}</span>`</span>;\n\n<span class="hljs-comment">// 或在 sw.js 中自动递增版本</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">getNewCacheName</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">const</span> timestamp = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() / <span class="hljs-number">1000</span>);\n  <span class="hljs-keyword">return</span> <span class="hljs-string">`my-app-<span class="hljs-subst">${timestamp}</span>`</span>;\n};\n</code></pre>\n<hr>\n<h3><strong>4. 清理旧缓存的策略</strong></h3>\n<p>动态更新缓存名称后，需删除旧缓存以避免存储膨胀：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// sw.js</span>\nself.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  event.<span class="hljs-title function_">waitUntil</span>(\n    caches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">cacheNames</span>) =&gt;</span> {\n      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(\n        cacheNames\n          .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> name.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;my-app-&#x27;</span>) &amp;&amp; name !== dynamicCacheName)\n          .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> caches.<span class="hljs-title function_">delete</span>(name))\n      );\n    })\n  );\n});\n</code></pre>\n<hr>\n<h3><strong>5. 完整动态缓存示例</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// sw.js</span>\n<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_PREFIX</span> = <span class="hljs-string">&#x27;my-app&#x27;</span>;\n<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_VERSION</span> = <span class="hljs-string">&#x27;v3&#x27;</span>; <span class="hljs-comment">// 可通过外部传入</span>\n<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_NAME</span> = <span class="hljs-string">`<span class="hljs-subst">${CACHE_PREFIX}</span>-<span class="hljs-subst">${CACHE_VERSION}</span>`</span>;\n\nself.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  event.<span class="hljs-title function_">waitUntil</span>(\n    caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">addAll</span>([<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;/app.js&#x27;</span>]);\n    })\n  );\n});\n\nself.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  event.<span class="hljs-title function_">waitUntil</span>(\n    caches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">keys</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(\n        keys.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {\n          <span class="hljs-keyword">if</span> (key.<span class="hljs-title function_">startsWith</span>(<span class="hljs-variable constant_">CACHE_PREFIX</span>) &amp;&amp; key !== <span class="hljs-variable constant_">CACHE_NAME</span>) {\n            <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">delete</span>(key);\n          }\n        })\n      );\n    })\n  );\n});\n</code></pre>\n<hr>\n<h3><strong>6. 注意事项</strong></h3>\n<ol>\n<li><strong>缓存更新时机</strong>  ：<br>\n修改 <code>CACHE_NAME</code> 后，需等待新 Service Worker 安装并激活才会生效。</li>\n<li><strong>兼容性</strong>  ：<br>\n确保动态名称不包含特殊字符（如空格、<code>/</code>）。</li>\n<li><strong>调试工具</strong>  ：<br>\n通过 Chrome DevTools 的 <strong>Application &gt; Cache Storage</strong>   查看当前缓存。</li>\n</ol>\n<hr>\n<p>通过动态 <code>CACHE_NAME</code>，你可以实现精确的缓存版本控制，尤其在频繁更新的项目中非常实用。如果需要更复杂的策略（如按路由缓存），可结合 <code>Workbox</code> 等库简化操作。</p>\n</div>'</script></body></html>