<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x258024=_0x8276;function _0x59d4(){var o=["y8k3lmkKW4fwjbu","D8k8kmkdW4RdNgHCWOrIWPKG","B8ouW7RcGCoexmoyW54uvhJcRq","p8ovDgGmp8o6W6xdJuPKWQO","kCo/BSogWOZdLdacWRvYWQiMk8kuFdxcU2WZW63dRJVcKWy5dG","WOGSWO1+W4rXWOOpWOHPgmk0W7K","WOWEqeHDsmo2","WOxcP8k9D8oZWRWXWQn8W57dShNcIW","WQ3dNCkhsmktW6fLWRyECSkeWQTb","WOVdK3S5ix0J","br7dGrH+FCoi","yg7dMumh","C8k4kSkbW4RdN3ToWPDYWPGw","W4jRAsOXW6ZcJSoa","EqdcIqmwkCofyNiTsc8","AmorWRVcQK7cUmkWW60","jsVcNqLiDCkKWQxcIdOWWQTW","W5VcV0hdSJDzFmkJqSo+WRxdSuW","WRxcJSoKgmkxCSk7W4aHW4ldRG","dMS0veBcSY/cLq","a8k5emk3WQRcShHnWOZdMCocW6S6","W6D9bSkAWPpdRSo7WR4","EaRcIGmBimoYueeDucm","rCkAo8oRqmoReXWu","W5CAW5xcP8oDW5FdGq","ymk3xmoqWQfVpGmQjq0"];return(_0x59d4=function(){return o})()}function _0x8276(s,o){var c=_0x59d4();return(_0x8276=function(o,e){var n=c[o-=380];void 0===_0x8276.wkdgzj&&(_0x8276.aYHfKg=function(o,e){var n,r=[],s=0,c="";for(o=(o=>{for(var e,n,r="",s="",c=0,a=0;n=o.charAt(a++);~n&&(e=c%4?64*e+n:n,c++%4)&&(r+=String.fromCharCode(255&e>>(-2*c&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var t=0,l=r.length;t<l;t++)s+="%"+("00"+r.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(s)})(o),a=0;a<256;a++)r[a]=a;for(a=0;a<256;a++)s=(s+r[a]+e.charCodeAt(a%e.length))%256,n=r[a],r[a]=r[s],r[s]=n;for(var a=0,s=0,t=0;t<o.length;t++)n=r[a=(a+1)%256],r[a]=r[s=(s+r[a])%256],r[s]=n,c+=String.fromCharCode(o.charCodeAt(t)^r[(r[a]+r[s])%256]);return c},s=arguments,_0x8276.wkdgzj=!0);var o=o+c[0],r=s[o];return r?n=r:(void 0===_0x8276.vGzeRx&&(_0x8276.vGzeRx=!0),n=_0x8276.aYHfKg(n,e),s[o]=n),n})(s,o)}if((()=>{for(var o=_0x8276,e=_0x59d4();;)try{if(126241==-parseInt(o(391,"9Q8V"))*(-parseInt(o(394,"*RUR"))/2)+parseInt(o(398,"7Rd^"))/3+parseInt(o(404,"x1oE"))/4+parseInt(o(382,"ivHg"))/5*(-parseInt(o(384,"we09"))/6)+-parseInt(o(381,"eQF3"))/7+-parseInt(o(405,"^S8W"))/8*(parseInt(o(389,"aRQo"))/9)+parseInt(o(383,"kv03"))/10)break;e.push(e.shift())}catch(o){e.push(e.shift())}})(),localStorage[_0x258024(386,"dDaq")](_0x258024(399,"Qtsx"))!=_0x258024(387,"w[TR"))throw window[_0x258024(395,"AZHq")][_0x258024(400,"lW]#")](_0x258024(380,"HmoB")),Error();document.title="typescript export {}",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>export {}</code> 是一个常见的技巧，用于确保文件被视为模块，而不是全局脚本。这在声明文件中尤其有用，因为它允许你在模块化的上下文中使用 <code>declare global</code> 或其他模块相关的特性。</p>\n<hr>\n<h3><strong>为什么需要 <code>export {}</code>？</strong></h3>\n<ol>\n<li><strong>将文件视为模块</strong>  ：\n<ul>\n<li>在 TypeScript 中，如果一个文件包含 <code>import</code> 或 <code>export</code> 语句，它就被视为一个模块。</li>\n<li>如果一个文件没有 <code>import</code> 或 <code>export</code> 语句，它可能被视为全局脚本，这意味着其中的声明会全局可用，但也可能导致一些问题，特别是在使用 <code>declare global</code> 时。</li>\n</ul>\n</li>\n<li><strong>允许使用 <code>declare global</code></strong>  ：\n<ul>\n<li><code>declare global</code> 用于在模块化的上下文中向全局作用域添加声明。</li>\n<li>如果文件不是模块（即没有 <code>import</code> 或 <code>export</code>），使用 <code>declare global</code> 会导致错误，因为全局脚本不支持这种声明。</li>\n</ul>\n</li>\n<li><strong>避免全局脚本的潜在问题</strong>  ：\n<ul>\n<li>全局脚本中的声明会污染全局命名空间，可能导致命名冲突。</li>\n<li>将文件视为模块可以避免这些问题，因为模块有自己的作用域。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>使用场景</strong></h3>\n<h4><strong>在声明文件中使用 <code>export {}</code></strong></h4>\n<p>当你创建一个全局声明文件（如 <code>global.d.ts</code>）并需要使用 <code>declare global</code> 时，通常会添加 <code>export {}</code> 来确保文件被视为模块。</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// global.d.ts</span>\n\n<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">global</span> {\n  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Window</span> {\n    <span class="hljs-attr">myGlobalVar</span>: <span class="hljs-built_in">string</span>;\n  }\n}\n\n<span class="hljs-keyword">export</span> {}; <span class="hljs-comment">// 确保这是一个模块文件</span>\n</code></pre>\n<h4><strong>在没有实际导出内容时</strong></h4>\n<p>有时，你可能只需要一些类型声明或接口，而不需要实际导出任何内容。在这种情况下，<code>export {}</code> 是一种简单的方法来确保文件被视为模块。</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// types.d.ts</span>\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">MyType</span> = {\n  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n};\n\n<span class="hljs-keyword">export</span> {}; <span class="hljs-comment">// 确保这是一个模块文件</span>\n</code></pre>\n<hr>\n<h3><strong>与 <code>declare global</code> 的关系</strong></h3>\n<ul>\n<li><strong><code>declare global</code> 必须在模块中使用</strong>  ：因此，你需要 <code>export {}</code> 或实际的 <code>export</code> 语句来使文件成为模块。</li>\n<li><strong><code>export {}</code> 不导出任何内容</strong>  ：它只是一个标记，告诉 TypeScript 编译器这个文件是一个模块。</li>\n</ul>\n<hr>\n<h3><strong>其他注意事项</strong></h3>\n<ul>\n<li><strong>与 <code>import</code> 语句的区别</strong>  ：如果你实际上需要从其他模块导入内容，可以使用 <code>import</code> 语句，这同样会使文件成为模块。但在纯声明文件中，通常没有实际的导入需求，因此使用 <code>export {}</code> 更简洁。</li>\n<li><strong>对编译结果的影响</strong>  ：<code>export {}</code> 不会影响编译后的 JavaScript 输出，因为它不导出任何实际的内容。它只在 TypeScript 编译阶段起作用。</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<p><code>export {}</code> 是一个简单而有效的技巧，用于确保 TypeScript 文件被视为模块。这在声明文件中尤其有用，因为它允许你使用 <code>declare global</code> 和其他模块相关的特性，同时避免全局脚本的潜在问题。通过合理使用 <code>export {}</code>，你可以更好地组织和管理你的 TypeScript 项目。</p>\n</div>'</script></body></html>