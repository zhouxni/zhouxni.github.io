<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1fd813=_0x5137;function _0x4d40(){var n=["W53cV0LzWOFcNNno","kqddR8kpu8oRW7zhWOJcQ2ZcKX0","EmoSp8ktENZcKXS","W4lcKCkWW4pdPSkyBYS","WPedW4JcSLmTW63dVWhdO8o6g8kcWR4","W4e7x3VcPCkQx3JcJmo4WQ7dPa","lCkFm8kKW5jrW6anW6hdGCkM","DCkvmqO4DCkOW6BcRmk3BSo1WRm","W4a6w37cPmocwuFcLCo/WQ0","W78ToCoGeSokg3VcSZXyAfq","W7GUWQ7cVqH/BG","WRpcQMLeWQi","W4C6uhhcOCkJbHtcOCokWPBdNr0v","rHCiWOyeW4ZdHq","DgaOfSkHW7tcQa","C8oADCoIWPq6WQHjW4JdN8kOW6b2WRjTW5jfWP40q8kNcCopBSkBhG","W6n3W6v2W6lcISo6WRe","bgCbWQW4W4BcUCki","CIpdHCojWQldG8k2tmkvtHCkWRWP","W79uW4/dHvy+iXKhWOVdJG/cOhW","nWxdOZeWxCkghmoo","W7OpWR/dSsGKcG","uuDPWPBdHuTXnCoDWQNdUSk3WP8","u1ZdGmkhcSkEx1TuwbZdPq","BwtdSSk3W6hcNSkxjSoLtSosemop","W4aYwN7cOmkIdLRcOCoRWR/dVqK"];return(_0x4d40=function(){return n})()}function _0x5137(r,n){var e=_0x4d40();return(_0x5137=function(n,o){var t=e[n-=117];void 0===_0x5137.yxLkMV&&(_0x5137.YjekGj=function(n,o){var t,l=[],r=0,e="";for(n=(n=>{for(var o,t,l="",r="",e=0,i=0;t=n.charAt(i++);~t&&(o=e%4?64*o+t:t,e++%4)&&(l+=String.fromCharCode(255&o>>(-2*e&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var s=0,d=l.length;s<d;s++)r+="%"+("00"+l.charCodeAt(s).toString(16)).slice(-2);return decodeURIComponent(r)})(n),i=0;i<256;i++)l[i]=i;for(i=0;i<256;i++)r=(r+l[i]+o.charCodeAt(i%o.length))%256,t=l[i],l[i]=l[r],l[r]=t;for(var i=0,r=0,s=0;s<n.length;s++)t=l[i=(i+1)%256],l[i]=l[r=(r+l[i])%256],l[r]=t,e+=String.fromCharCode(n.charCodeAt(s)^l[(l[i]+l[r])%256]);return e},r=arguments,_0x5137.yxLkMV=!0);var n=n+e[0],l=r[n];return l?t=l:(void 0===_0x5137.KFsRfS&&(_0x5137.KFsRfS=!0),t=_0x5137.YjekGj(t,o),r[n]=t),t})(r,n)}if((()=>{for(var n=_0x5137,o=_0x4d40();;)try{if(954141==-parseInt(n(133,"e!aZ"))*(-parseInt(n(142,"qSBR"))/2)+-parseInt(n(120,"wTfw"))/3*(parseInt(n(123,"D7Qx"))/4)+parseInt(n(134,"TK20"))/5+-parseInt(n(118,"#uQ3"))/6+parseInt(n(130,"e!aZ"))/7*(-parseInt(n(125,"x(B2"))/8)+parseInt(n(137,"e!aZ"))/9+parseInt(n(124,"e!aZ"))/10)break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x1fd813(139,"QdJv")](_0x1fd813(119,"Hp)B"))!=_0x1fd813(136,"1(lU"))throw window[_0x1fd813(128,"MnhJ")][_0x1fd813(138,"3kjz")](_0x1fd813(140,"XBy!")),Error();document.title="nuxt2 生命周期",document.getElementById("article").innerHTML="<div><p><strong>Nuxt 2 页面生命周期</strong></p>\n<p>Nuxt.js 是一个基于 Vue.js 的通用应用框架，它简化了服务器端渲染（SSR）的开发流程。在 Nuxt 2 中，页面的生命周期涉及多个阶段，包括服务端和客户端的执行过程。以下是 Nuxt 2 页面生命周期的详细解析：</p>\n<h3>一、服务端生命周期</h3>\n<ol>\n<li><strong>nuxtServerInit</strong>\n<ul>\n<li><strong>触发时机</strong>  ：服务器初始化时触发。</li>\n<li><strong>用途</strong>  ：用于在服务端渲染页面之前存储数据到 Vuex 中。</li>\n<li><strong>位置</strong>  ：通常写在 <code>store/index.js</code> 文件中。</li>\n<li><strong>参数</strong>  ：接收两个参数，分别是 <code>store</code>（Vuex 上下文）和 <code>context</code>（Nuxt 上下文）。</li>\n</ul>\n</li>\n<li><strong>middleware</strong>\n<ul>\n<li><strong>触发时机</strong>  ：在请求发出后，页面初始化之前执行。</li>\n<li><strong>用途</strong>  ：用于处理一些预定义的中间件逻辑，如用户认证、路由守卫等。</li>\n<li><strong>配置</strong>  ：可以在 <code>nuxt.config.js</code> 中进行全局配置，也可以在 <code>layouts</code> 或 <code>pages</code> 中进行局部配置。</li>\n<li><strong>参数</strong>  ：接收一个包含服务端上下文信息的参数 <code>context</code>。</li>\n</ul>\n</li>\n<li><strong>validate</strong>\n<ul>\n<li><strong>触发时机</strong>  ：在请求发出后，页面初始化之前执行。</li>\n<li><strong>用途</strong>  ：用于校验客户端请求所携带的参数是否符合要求。</li>\n<li><strong>位置</strong>  ：通常写在页面组件中。</li>\n<li><strong>返回值</strong>  ：必须返回一个布尔值或包装了布尔值的 Promise。如果为 <code>false</code>，会跳转到错误页面。</li>\n</ul>\n</li>\n<li><strong>asyncData</strong>\n<ul>\n<li><strong>触发时机</strong>  ：在组件（限于页面组件）每次加载之前被调用。</li>\n<li><strong>用途</strong>  ：用于在服务端或路由更新之前异步获取数据。</li>\n<li><strong>参数</strong>  ：接收一个当前页面的上下文对象作为参数。</li>\n<li><strong>注意</strong>  ：由于 <code>asyncData</code> 方法是在组件初始化前被调用的，因此无法通过 <code>this</code> 来引用组件的实例对象。</li>\n</ul>\n</li>\n<li><strong>fetch</strong>\n<ul>\n<li><strong>触发时机</strong>  ：在组件（页面或组件）每次加载之前被调用。</li>\n<li><strong>用途</strong>  ：用于在渲染页面前填充应用的状态树（store）数据。</li>\n<li><strong>参数</strong>  ：接收一个页面组件的上下文对象 <code>context</code> 作为参数。</li>\n<li><strong>注意</strong>  ：与 <code>asyncData</code> 不同，<code>fetch</code> 不会设置组件的数据，而是直接操作 Vuex 的状态。</li>\n</ul>\n</li>\n</ol>\n<h3>二、服务端和客户端共有的生命周期</h3>\n<ol>\n<li><strong>beforeCreate</strong>\n<ul>\n<li>在实例初始化之后，数据观测和事件配置之前被调用。</li>\n<li>在服务端和客户端都会执行。</li>\n</ul>\n</li>\n<li><strong>created</strong>\n<ul>\n<li>在实例创建完成后被立即调用。</li>\n<li>在这一阶段，实例已完成以下的配置：数据观测、属性和方法的运算、watch/event 事件回调。</li>\n<li>同样在服务端和客户端都会执行。</li>\n</ul>\n</li>\n</ol>\n<h3>三、客户端生命周期</h3>\n<ol>\n<li><strong>beforeMount</strong>\n<ul>\n<li>在挂载开始之前被调用。</li>\n<li>相关的 <code>render</code> 函数首次被调用。</li>\n</ul>\n</li>\n<li><strong>mounted</strong>\n<ul>\n<li>在 <code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。</li>\n<li>如果根实例挂载到了一个文档内的元素上，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</li>\n</ul>\n</li>\n<li><strong>beforeUpdate</strong>\n<ul>\n<li>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</li>\n<li>可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</li>\n</ul>\n</li>\n<li><strong>updated</strong>\n<ul>\n<li>由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。</li>\n<li>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。</li>\n</ul>\n</li>\n<li><strong>beforeDestroy</strong>\n<ul>\n<li>实例销毁之前调用。在这一步，实例仍然完全可用。</li>\n</ul>\n</li>\n<li><strong>destroyed</strong>\n<ul>\n<li>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>\n</ul>\n</li>\n</ol>\n<h3>四、总结</h3>\n<p>Nuxt 2 的页面生命周期涵盖了服务端和客户端的多个阶段，每个阶段都有其特定的用途和触发时机。通过理解这些生命周期钩子，开发者可以更好地控制页面的渲染流程、数据获取和状态管理，从而提高应用的性能和用户体验。</p>\n</div>"</script></body></html>