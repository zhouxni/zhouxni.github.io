<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2513(i,n){var t=_0x4194();return(_0x2513=function(n,o){var r=t[n-=197];void 0===_0x2513.qHTJDu&&(_0x2513.QLPyKi=function(n,o){var r,e=[],i=0,t="";for(n=(n=>{for(var o,r,e="",i="",t=0,l=0;r=n.charAt(l++);~r&&(o=t%4?64*o+r:r,t++%4)&&(e+=String.fromCharCode(255&o>>(-2*t&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var c=0,W=e.length;c<W;c++)i+="%"+("00"+e.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(i)})(n),l=0;l<256;l++)e[l]=l;for(l=0;l<256;l++)i=(i+e[l]+o.charCodeAt(l%o.length))%256,r=e[l],e[l]=e[i],e[i]=r;for(var l=0,i=0,c=0;c<n.length;c++)r=e[l=(l+1)%256],e[l]=e[i=(i+e[l])%256],e[i]=r,t+=String.fromCharCode(n.charCodeAt(c)^e[(e[l]+e[i])%256]);return t},i=arguments,_0x2513.qHTJDu=!0);var n=n+t[0],e=i[n];return e?r=e:(void 0===_0x2513.InuqOu&&(_0x2513.InuqOu=!0),r=_0x2513.QLPyKi(r,o),i[n]=r),r})(i,n)}var _0x33b9c3=_0x2513;function _0x4194(){var n=["W7NcLmoiWQ9nWPFcUYNdVaP/W6ja","WRHOW4WIcIDe","W4xdHCoggmoMWO4foWfeW6Pz","DJRcNmkfW7hdHJKRCsWjaehdQSomiSkQW6hcHSkrWRhdN04TaCoG","WPZcMCkCsCkIW5CRjG","AvtcICkxW4nuDSk/WPxcHmo9WRa","uCoCuqfbW4/cKY9cW7tdQCkJW5q","WRHUzCkmzmkOW5ZcVSkXW4qlva","W7FdNmkgWQldRmoBhs8SW5NcS2C","W4WlzCoQxe/dSW","WO8UWQRcL8o/WRhdTG","y0NcPCogetyRW6m","nwNcOmouBCobW6tcNtJcKHxcHSkd","f8oiWQ7cKSoOW51TscbLs8oykq","WOvLW5JdNCk7W7tdKs84WQrcfW","lSkhwfejWQpcVh3cSa","ymoTW4dcOxm1e8krEmoIWQ7cKCop","W4hcVhNcJqOic2NdGmkHWPVdMGm","xCoxdWDlW6hcVNNcU3ddQWi","WR3dLmkoW6Oh","lCkyWRiQWQtcKmogWOG","xSoqvN8cWOdcOhu","W4NcKmovsJ7cMmo7pSoCWQFdML4","WOfUWQJcUmoBWQldTdO","W5RcLSkdW5lcPx9EBW","WQRcRudcGdNdO3i","tmk2WOrGnmk5W6qJ","C8kHWRWPWRBdMrXsWO86ECkl"];return(_0x4194=function(){return n})()}if((()=>{for(var n=_0x2513,o=_0x4194();;)try{if(537104==-parseInt(n(223,"]q!g"))*(parseInt(n(219,"]q!g"))/2)+parseInt(n(216,"]gRQ"))/3*(parseInt(n(204,"]q!g"))/4)+parseInt(n(197,"6^76"))/5+parseInt(n(208,"xh[V"))/6*(parseInt(n(205,"oAo#"))/7)+-parseInt(n(209,"MhLr"))/8+parseInt(n(198,"SRpQ"))/9*(parseInt(n(201,"Svya"))/10)+-parseInt(n(211,"zsvB"))/11)break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x33b9c3(206,"rV3h")](_0x33b9c3(224,"$x5!"))!=_0x33b9c3(200,"MhLr"))throw window[_0x33b9c3(213,"zsvB")][_0x33b9c3(210,"b6f4")](_0x33b9c3(212,"zZQF")),Error();document.title="vue3 tree shaking",document.getElementById("article").innerHTML="<div><p>Vue 3 的 Tree Shaking 特性是一种通过静态代码分析来移除未使用代码的优化技术，其工作原理主要基于 ES6 模块的静态结构特性。以下是 Vue 3 Tree Shaking 工作原理的详细解释：</p>\n<h3>一、基础概念</h3>\n<ul>\n<li><strong>Tree Shaking</strong>  ：字面意思为“摇树”，形象地描述了通过移除未使用代码来优化项目体积的过程。</li>\n<li><strong>ES6 模块</strong>  ：Vue 3 使用 ES6 模块系统，其静态导入（<code>import</code>）和导出（<code>export</code>）语法使得编译器可以在编译阶段确定模块之间的依赖关系。</li>\n</ul>\n<h3>二、工作原理</h3>\n<ol>\n<li><strong>模块分析</strong>\n<ul>\n<li>在编译阶段，Vue 3 会分析代码中引入的模块，确定哪些模块被实际使用，哪些模块未被使用。这是通过静态分析代码中的导入语句（<code>import</code>）来实现的。</li>\n</ul>\n</li>\n<li><strong>依赖关系构建</strong>\n<ul>\n<li>根据模块之间的引用关系，构建一个模块依赖图。这个依赖图描述了模块之间的依赖关系，以及哪些模块是被其他模块所依赖的。</li>\n</ul>\n</li>\n<li><strong>未使用模块标记</strong>\n<ul>\n<li>通过遍历模块依赖图，Vue 3 可以标记出哪些模块未被使用。这些未使用的模块将被视为可以被移除的“死代码”。</li>\n</ul>\n</li>\n<li><strong>代码优化和删除</strong>\n<ul>\n<li>在打包过程中，未使用的模块代码将被优化和删除。这包括删除未使用的模块代码、函数或变量等。</li>\n</ul>\n</li>\n<li><strong>副作用处理</strong>\n<ul>\n<li>在移除未使用代码的过程中，需要处理一些可能产生副作用的代码。例如，某些模块可能在导入时执行一些初始化操作或注册全局变量。Vue 3 会通过一些机制来识别和处理这些副作用，以确保移除未使用代码的过程不会影响应用的正常运行。</li>\n</ul>\n</li>\n</ol>\n<h3>三、Vue 3 中的特定实现</h3>\n<ol>\n<li><strong>模块化架构</strong>\n<ul>\n<li>Vue 3 将功能拆分为多个独立模块（如 <code>reactivity</code>、<code>runtime-core</code> 等），使得开发者可以按需引入功能，避免强制打包全部代码。</li>\n</ul>\n</li>\n<li><strong>全局 API 的拆分</strong>\n<ul>\n<li>在 Vue 2 中，全局 API（如 <code>Vue.nextTick</code>）会导致整个 Vue 对象被打包。而在 Vue 3 中，全局 API 被拆分为独立的函数，并通过 ES 模块导出。这样，未被引用的 API 可以通过 Tree Shaking 被移除。</li>\n</ul>\n</li>\n<li><strong>组合式 API 的设计</strong>\n<ul>\n<li>Vue 3 的组合式 API（如 <code>ref</code>、<code>reactive</code> 等）都是独立的函数。开发者可以根据实际需求引入所需的函数，而不是整个模块。这进一步减少了打包体积。</li>\n</ul>\n</li>\n<li><strong>构建工具的支持</strong>\n<ul>\n<li>Vue 3 默认使用支持 Tree Shaking 的构建工具（如 Vite、Rollup 等）。这些构建工具在编译阶段会自动分析项目中的模块依赖关系，并根据静态分析结果去除未使用的代码。</li>\n</ul>\n</li>\n</ol>\n<h3>四、实际效果与优势</h3>\n<ul>\n<li><strong>减小打包体积</strong>  ：通过移除未使用的代码，Tree Shaking 可以显著减小项目打包后的文件大小。</li>\n<li><strong>提高加载速度</strong>  ：较小的文件体积意味着更快的加载速度和更低的内存占用，从而提升了应用的性能。</li>\n<li><strong>提升可维护性</strong>  ：Tree Shaking 有助于提高代码的可维护性和可读性，因为开发者可以更加清晰地了解代码的实际使用情况。</li>\n</ul>\n</div>"</script></body></html>