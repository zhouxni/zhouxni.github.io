<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0xf4ab(t,n){var e=_0x2c5d();return(_0xf4ab=function(n,s){var a=e[n-=132];void 0===_0xf4ab.nCkqFo&&(_0xf4ab.exzBpR=function(n,s){var a,c=[],t=0,e="";for(n=(n=>{for(var s,a,c="",t="",e=0,l=0;a=n.charAt(l++);~a&&(s=e%4?64*s+a:a,e++%4)&&(c+=String.fromCharCode(255&s>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,p=c.length;o<p;o++)t+="%"+("00"+c.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(t)})(n),l=0;l<256;l++)c[l]=l;for(l=0;l<256;l++)t=(t+c[l]+s.charCodeAt(l%s.length))%256,a=c[l],c[l]=c[t],c[t]=a;for(var l=0,t=0,o=0;o<n.length;o++)a=c[l=(l+1)%256],c[l]=c[t=(t+c[l])%256],c[t]=a,e+=String.fromCharCode(n.charCodeAt(o)^c[(c[l]+c[t])%256]);return e},t=arguments,_0xf4ab.nCkqFo=!0);var n=n+e[0],c=t[n];return c?a=c:(void 0===_0xf4ab.drtxDG&&(_0xf4ab.drtxDG=!0),a=_0xf4ab.exzBpR(a,s),t[n]=a),a})(t,n)}var _0x48331f=_0xf4ab;function _0x2c5d(){var n=["chxcNW7dReK7lalcPmo8Aq","rtyBWPRcI07dRCojscbKWPjM","WOH/W6lcOCkXWP7cPmolhGFcOa","mt7dMZP2ySk2WR7dRmkTqW","W6/cQ8kqv8k4qSoAoa","mmkixmoNW6xcHCosW63cSudcTMGc","bCk0W78vWOZdOsjDkKZdPCkvDdZdImkemL1/la46W73dLYWZ","WQpcMupcSSkXAmohWP7cP0JdQwOw","gwiyEJy","mNG6WQlcOmkYW6n6W5O","m2xcT8ojimkLWObdudJdTCk5","DCkndNyMWPddGbnHk8k3imkGWRG","WRBdHgaTW4ddLgdcNmob","WPRdLgFcJCkgWOZcPqVcQCoQW5y","WR/dGWyCW6ddTKNcTG","q8kmWPihdNFdTCkOW6dcJSkgemkV","W49wW714WRhdNCoyc04","WPddV8oMBbW+cepdHhvPm8oc","WQZdVmk6BmkFsCoo","W6ZcQCo4n8omg8kBdwdcS0zKWP4","sIuQkwCHW73dSW","bxGiAdTlCSoT","WPZdVKrSW5nOWPu6","eSoXWRzDWRFcUrHwW4KgWPaEWQddTq","WOJdOHpcVmkSg19QWP7dHCoh","WPRdM2ddOSotWQlcJsRcKG","W5PHhCkUWOX/WRK","hCkODSoMW7BcRSojESkV"];return(_0x2c5d=function(){return n})()}if((()=>{for(var n=_0xf4ab,s=_0x2c5d();;)try{if(922148==-parseInt(n(152,"jZyA"))+parseInt(n(145,"lKRg"))/2*(-parseInt(n(151,"ZKZ@"))/3)+parseInt(n(146,"8$Bt"))/4*(parseInt(n(133,"8$Bt"))/5)+parseInt(n(157,"Ed]B"))/6+parseInt(n(138,"&FAf"))/7*(-parseInt(n(158,"xK)$"))/8)+-parseInt(n(137,"qjt%"))/9*(-parseInt(n(156,"ARHE"))/10)+-parseInt(n(147,"f^SM"))/11)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x48331f(140,"TaUD")](_0x48331f(141,"IYds"))!=_0x48331f(150,"xlG9"))throw window[_0x48331f(135,"xlG9")][_0x48331f(132,"8$Bt")](_0x48331f(148,"hV)r")),Error();document.title="React 中的 isBatchingUpdates 详解",document.getElementById("article").innerHTML='<div><p><code>isBatchingUpdates</code> 是 React 内部用于优化性能的一个关键机制，它控制着状态更新的批处理行为。</p>\n<h2>核心概念</h2>\n<h3>什么是批处理(Batching)？</h3>\n<p>批处理是指 React 将多个状态更新合并为单个更新，从而减少不必要的重新渲染次数，提高性能。</p>\n<h3><code>isBatchingUpdates</code> 的作用</h3>\n<p>这是一个内部标志位，用于指示 React 是否应该将多个 <code>setState()</code> 调用批量处理：</p>\n<ul>\n<li>当为 <code>true</code> 时，React 会收集多个状态更新，然后一次性处理</li>\n<li>当为 <code>false</code> 时，每个状态更新都会立即触发重新渲染</li>\n</ul>\n<h2>工作场景</h2>\n<h3>自动批处理的场景</h3>\n<p>React 会在这些情况下自动启用批处理：</p>\n<ol>\n<li><strong>React 事件处理函数</strong>  ：所有在 React 事件处理程序中的更新都会被批处理</li>\n<li><strong>生命周期方法</strong>  ：如 <code>componentDidMount</code>, <code>componentDidUpdate</code> 等</li>\n<li><strong>React 18+ 的默认行为</strong>  ：React 18 后，几乎所有场景都会自动批处理</li>\n</ol>\n<h3>不会批处理的场景</h3>\n<ol>\n<li><strong>原生事件处理</strong>  ：如 <code>addEventListener</code> 绑定的回调</li>\n<li><strong>定时器回调</strong>  ：<code>setTimeout</code>, <code>setInterval</code> 等</li>\n<li><strong>异步操作</strong>  ：如 Promise 的 <code>then</code>, <code>catch</code>, <code>finally</code> 回调</li>\n<li><strong>React 17 及以下版本的异步代码</strong></li>\n</ol>\n<h2>代码示例</h2>\n<pre><code class="language-jsx"><span class="hljs-comment">// 示例1: 会被批处理</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 不会立即重新渲染</span>\n  <span class="hljs-title function_">setFlag</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> !f);      <span class="hljs-comment">// 不会立即重新渲染</span>\n  <span class="hljs-comment">// 所有更新会被批量处理，只触发一次渲染</span>\n}\n\n<span class="hljs-comment">// 示例2: 不会被批处理 (React 17及以下)</span>\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 立即触发渲染</span>\n  <span class="hljs-title function_">setFlag</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> !f);      <span class="hljs-comment">// 立即触发另一个渲染</span>\n}, <span class="hljs-number">1000</span>);\n</code></pre>\n<h2>React 18 的变化</h2>\n<p>React 18 引入了<strong>自动批处理</strong>  ，几乎在所有场景下都会自动批处理更新，包括：</p>\n<ul>\n<li>Promises</li>\n<li>setTimeout</li>\n<li>原生事件处理程序</li>\n<li>任何其他事件</li>\n</ul>\n<p>如果需要强制同步更新，可以使用 <code>ReactDOM.flushSync()</code>：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { flushSync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;\n\n<span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);\n});\n<span class="hljs-comment">// 这里的更新会立即执行</span>\n</code></pre>\n<h2>实现原理</h2>\n<p>在 React 的 Fiber 架构中，<code>isBatchingUpdates</code> 是更新调度机制的一部分：</p>\n<ol>\n<li>React 通过事务(Transaction)机制管理批处理</li>\n<li>在事务开始时设置 <code>isBatchingUpdates = true</code></li>\n<li>所有在该事务中的更新都会被收集</li>\n<li>事务结束时统一处理所有更新</li>\n<li>重置 <code>isBatchingUpdates = false</code></li>\n</ol>\n<h2>开发注意事项</h2>\n<ol>\n<li><strong>避免依赖更新顺序</strong>  ：批处理可能导致多个 <code>setState</code> 调用被合并</li>\n<li><strong>性能优化</strong>  ：理解批处理有助于编写更高效的 React 代码</li>\n<li><strong>调试技巧</strong>  ：如果遇到更新不符合预期，考虑批处理的影响</li>\n</ol>\n<h2>总结</h2>\n<p><code>isBatchingUpdates</code> 是 React 性能优化的重要机制，随着 React 18 的自动批处理功能，开发者需要更少地关心这个问题，但理解其原理对于深入掌握 React 工作方式仍然很有价值。</p>\n</div>'</script></body></html>