<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x31fa(e,r){var a=_0x3049();return(_0x31fa=function(r,n){var o=a[r-=280];void 0===_0x31fa.hxHFFB&&(_0x31fa.ayTdxA=function(r,n){var o,t=[],e=0,a="";for(r=(r=>{for(var n,o,t="",e="",a=0,d=0;o=r.charAt(d++);~o&&(n=a%4?64*n+o:o,a++%4)&&(t+=String.fromCharCode(255&n>>(-2*a&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var i=0,c=t.length;i<c;i++)e+="%"+("00"+t.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(e)})(r),d=0;d<256;d++)t[d]=d;for(d=0;d<256;d++)e=(e+t[d]+n.charCodeAt(d%n.length))%256,o=t[d],t[d]=t[e],t[e]=o;for(var d=0,e=0,i=0;i<r.length;i++)o=t[d=(d+1)%256],t[d]=t[e=(e+t[d])%256],t[e]=o,a+=String.fromCharCode(r.charCodeAt(i)^t[(t[d]+t[e])%256]);return a},e=arguments,_0x31fa.hxHFFB=!0);var r=r+a[0],t=e[r];return t?o=t:(void 0===_0x31fa.HnBhdo&&(_0x31fa.HnBhdo=!0),o=_0x31fa.ayTdxA(o,n),e[r]=o),o})(e,r)}var _0x39da93=_0x31fa;function _0x3049(){var r=["W4/dIW3dNwVdReGSWRC","W6tdV1vyamoMWPJdJCohp2tcRs8","eIpdLmkDW43cGcDzW6G","aq55W4mxWR7cVmktW5KjW6FdLCk3","W6HLWRugfCkpoCkZW5e","ecRdKSoRWOhdHffkW4DemYFdVq","W6NdGgvpnfnBla/cJCkSAa","WP/dUmkdWQ8FW6NdOcpdN8o5WQdcSq","W61UW6hcMY09C8owx8oBWR5lla","W7qBW4BdGHFcJCkdBW","mCklDWLEW5dcI2hcOb8vDqe","mHPMW6NdSaZdN8ogiSkMWRThW5C","iwbCdSk0WQ7dQ29bWRDabCkn","sZRcPuZdSSkEWQG","W6hdUfDybmoKW47dU8oIdu/cOa","BCoksCkRiSoqzComuqCSWQK","oJ4iW5PICmk/W4ypbCk8wmktd1T9W64xW7ycWOP9W7RdN8kDW7q","W4H1xCkPC8oTW6jtWQVdImkYBG","ySo9B8kzW6VcShRdKKFcSs7dHqG","bNKvWPRcNv4c","W5tcNrJdMaW","BSkcs8oVWQWSg8o/WQVdOqb+"];return(_0x3049=function(){return r})()}if((()=>{for(var r=_0x31fa,n=_0x3049();;)try{if(990006==+parseInt(r(289,"qzMi"))+-parseInt(r(290,"wzJg"))/2+parseInt(r(300,"^*Ww"))/3+-parseInt(r(294,"%L1o"))/4+-parseInt(r(281,"yi[t"))/5+-parseInt(r(287,")(7T"))/6+-parseInt(r(286,"hiu$"))/7*(-parseInt(r(299,"pSKo"))/8))break;n.push(n.shift())}catch(r){n.push(n.shift())}})(),localStorage[_0x39da93(295,"AKX7")](_0x39da93(282,"7hwv"))!=_0x39da93(280,")bL#"))throw window[_0x39da93(291,"v5g)")][_0x39da93(301,"FXul")](_0x39da93(298,"irw$")),Error();document.title="react  Fiber 架构中断渲染",document.getElementById("article").innerHTML="<div><p>Fiber 架构下的中断渲染原理主要涉及任务拆分、优先级调度和可中断的渲染循环。以下是详细的原理解析：</p>\n<h3>一、任务拆分</h3>\n<ol>\n<li><strong>Fiber 节点</strong>  ：在 Fiber 架构中，每个 React 组件对应一个 Fiber 节点，这些节点形成链表树结构。每个 Fiber 节点包含组件类型、状态和属性等关键信息，以及指向子节点、兄弟节点和父节点的指针。</li>\n<li><strong>工作单元</strong>  ：渲染任务被拆分为多个工作单元（Unit of Work），每个工作单元对应一个 Fiber 节点的处理。这种拆分使得渲染任务可以被细粒度地管理和调度。</li>\n</ol>\n<h3>二、优先级调度</h3>\n<ol>\n<li><strong>优先级分配</strong>  ：React 根据更新来源为任务分配不同的优先级。例如，用户输入事件通常被分配为高优先级，而后台数据更新则可能被视为低优先级任务。</li>\n<li><strong>动态调度</strong>  ：在渲染过程中，React 会根据任务的优先级动态调度任务。高优先级任务会优先执行，而低优先级任务则可以在浏览器空闲时处理。</li>\n</ol>\n<h3>三、可中断的渲染循环</h3>\n<ol>\n<li><strong>渲染循环</strong>  ：Fiber 架构使用循环遍历（while）替代传统的递归调用，以处理 Fiber 节点。这种循环遍历方式支持任务的暂停和恢复。</li>\n<li><strong>中断检查</strong>  ：在渲染循环中，React 会定期检查是否有剩余时间（通过 <code>requestIdleCallback</code> 或 React 自研的 Scheduler 实现）。如果剩余时间不足，React 会保存当前遍历位置（currentFiber），并暂停当前任务。</li>\n<li><strong>恢复渲染</strong>  ：当浏览器空闲时，React 会继续从之前保存的位置恢复渲染任务。这种机制确保了高优先级任务能够及时得到处理，同时避免了长时间阻塞主线程。</li>\n</ol>\n<h3>四、双缓冲与副作用收集</h3>\n<ol>\n<li><strong>双缓冲技术</strong>  ：Fiber 架构使用双缓冲技术，维护两棵 Fiber 树：<code>Current Tree</code>（当前已渲染的树）和 <code>WorkInProgress Tree</code>（正在构建的新树）。这种技术使得 React 可以在不影响当前显示的情况下构建新的树。</li>\n<li><strong>副作用收集</strong>  ：在遍历过程中，React 会收集需要更新的节点（通过 <code>effectTag</code> 标记），形成副作用链表。在提交阶段，React 会根据副作用链表一次性处理所有需要更新的节点。</li>\n</ol>\n<h3>五、中断渲染的优势</h3>\n<ol>\n<li><strong>提升用户体验</strong>  ：中断渲染确保高优先级任务（如用户输入）能够及时得到处理，避免了长时间阻塞主线程导致的卡顿现象。</li>\n<li><strong>提高渲染性能</strong>  ：通过任务拆分和优先级调度，React 能够更高效地利用浏览器的空闲时间，提高了渲染性能。</li>\n<li><strong>增强应用的响应性</strong>  ：中断渲染使得 React 能够更灵活地处理各种任务，增强了应用的响应性和流畅性。</li>\n</ol>\n</div>"</script></body></html>