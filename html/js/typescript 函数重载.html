<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x458a51=_0x4057;function _0x4357(){var s=["WPXDkCkReZPk","dLRdQ8o/tCokW489WOdcPSoqt8oF","kGnDW7nhFIBcMuahC1ag","WRZcPxeZbvVdQJ7dTxjZwte","taZcGYRdSmo2styhW4NcR2KX","hqyWDM1slmkX","d1ldQ8o7tmooW4OvWOFcQ8oyACoF","eGldVZflj8oZqwPJwCkt","W6tdOSo1WPRcN8k4WO/cT8kEW7tdRrldOW","WPtcV8oZWQdcH2OXW7VcN8oNW7f7ccxdJCo/wmo+jKyCWOmdWQBdI8k2","W482s2VcPSkqW7iJA8kzbslcVq","vmoHWPLVWPvhW57dQ8khpaZdHIS","lK52W5lcT0ZdNG","W7/dImkLWPZdRmkuW53dQKNdH8oLWQa","WPVcMX3cGZ9LhSkM","W4XaW6VcHb4","sGxcGI3dU8oWqW0dW5NcQN4y","l8onk2RdTx/dP8oRsG","nCkvWQdcMb50W5RcIqjBWQ8JWRi","n8omWP/cJxpcS8oUWRa","W47cHCoLjmocpazOWPvFhCkEuG","WRm0DCk5WRpcQbZdGMhcUmoPW64n"];return(_0x4357=function(){return s})()}function _0x4057(t,s){var p=_0x4357();return(_0x4057=function(s,n){var a=p[s-=423];void 0===_0x4057.oFZQqB&&(_0x4057.QZCkMA=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,r=0;a=s.charAt(r++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,e=l.length;c<e;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),r=0;r<256;r++)l[r]=r;for(r=0;r<256;r++)t=(t+l[r]+n.charCodeAt(r%n.length))%256,a=l[r],l[r]=l[t],l[t]=a;for(var r=0,t=0,c=0;c<s.length;c++)a=l[r=(r+1)%256],l[r]=l[t=(t+l[r])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[r]+l[t])%256]);return p},t=arguments,_0x4057.oFZQqB=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x4057.oyjYwT&&(_0x4057.oyjYwT=!0),a=_0x4057.QZCkMA(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x4057,n=_0x4357();;)try{if(646909==-parseInt(s(428,"V#mj"))+-parseInt(s(431,"K56u"))/2+parseInt(s(442,"xiE&"))/3+-parseInt(s(441,"(8L0"))/4+parseInt(s(439,"[KNz"))/5*(parseInt(s(440,"kgVW"))/6)+parseInt(s(423,"NuG#"))/7+parseInt(s(424,"Nt&T"))/8)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x458a51(443,"o2B9")](_0x458a51(438,"YC7I"))!=_0x458a51(436,"BJSz"))throw window[_0x458a51(426,"9KnT")][_0x458a51(433,"i)gv")](_0x458a51(430,"Yd%5")),Error();document.title="typescript 函数重载",document.getElementById("article").innerHTML='<div><p>TypeScript 的函数重载允许你为同一个函数提供多个类型签名，以便在调用函数时可以根据不同的参数类型或数量来执行不同的逻辑。这在处理需要根据输入类型进行不同处理的函数时非常有用。</p>\n<h3><strong>函数重载的基本概念</strong></h3>\n<ul>\n<li><strong>声明多个类型签名</strong>  ：在函数实现之前，先声明多个可能的参数和返回类型组合。</li>\n<li><strong>单个实现</strong>  ：尽管有多个类型签名，函数本身只有一个实现。</li>\n<li><strong>类型检查</strong>  ：TypeScript 编译器根据调用时提供的参数类型，选择最匹配的签名进行类型检查。</li>\n</ul>\n<h3><strong>函数重载的语法</strong></h3>\n<pre><code class="language-typescript"><span class="hljs-comment">// 声明重载签名</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"><span class="hljs-attr">person</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span>;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"><span class="hljs-attr">persons</span>: <span class="hljs-built_in">string</span>[]</span>): <span class="hljs-built_in">string</span>;\n\n<span class="hljs-comment">// 实现函数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"><span class="hljs-attr">param</span>: <span class="hljs-built_in">any</span></span>): <span class="hljs-built_in">string</span> {\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&#x27;string&#x27;</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">${param}</span>!`</span>;\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(param)) {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">${param.join(<span class="hljs-string">&#x27;, &#x27;</span>)}</span>!`</span>;\n  }\n  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Invalid parameter type&#x27;</span>);\n}\n\n<span class="hljs-comment">// 使用重载</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>)); <span class="hljs-comment">// 输出: Hello, Alice!</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">greet</span>([<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>])); <span class="hljs-comment">// 输出: Hello, Alice, Bob!</span>\n</code></pre>\n<h3><strong>示例解析</strong></h3>\n<ol>\n<li><strong>声明重载签名</strong>  ：\n<ul>\n<li><code>function greet(person: string): string;</code> 表示当传入一个字符串时，函数返回一个字符串。</li>\n<li><code>function greet(persons: string[]): string;</code> 表示当传入一个字符串数组时，函数返回一个字符串。</li>\n</ul>\n</li>\n<li><strong>实现函数</strong>  ：\n<ul>\n<li>实现部分使用 <code>any</code> 类型来接收参数，因为实现需要处理所有可能的参数类型。</li>\n<li>在实现中，通过类型检查（如 <code>typeof</code> 和 <code>Array.isArray</code>）来确定实际传入的参数类型，并执行相应的逻辑。</li>\n</ul>\n</li>\n<li><strong>使用重载</strong>  ：\n<ul>\n<li>当调用 <code>greet</code> 函数时，TypeScript 编译器会根据传入的参数类型选择匹配的签名进行类型检查。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>函数重载的优势</strong></h3>\n<ul>\n<li><strong>类型安全</strong>  ：提供多个类型签名可以确保函数在不同调用方式下的类型安全。</li>\n<li><strong>代码可读性</strong>  ：通过重载签名，开发者可以清晰地了解函数在不同情况下的行为。</li>\n<li><strong>灵活性</strong>  ：允许函数根据输入类型执行不同的逻辑，而无需为每种类型创建单独的函数。</li>\n</ul>\n<h3><strong>注意事项</strong></h3>\n<ol>\n<li><strong>实现与签名的一致性</strong>  ：函数的实现必须能够处理所有声明的重载签名。</li>\n<li><strong>参数类型的区分</strong>  ：在实现中，需要能够区分不同的参数类型，通常使用类型检查（如 <code>typeof</code>、<code>instanceof</code>、<code>Array.isArray</code> 等）。</li>\n<li><strong>返回类型的兼容性</strong>  ：虽然实现可以返回 <code>any</code> 类型，但最好确保返回类型与重载签名中的返回类型兼容。</li>\n</ol>\n<h3><strong>高级示例：处理可选参数</strong></h3>\n<pre><code class="language-typescript"><span class="hljs-comment">// 声明重载签名</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">makeDate</span>(<span class="hljs-params"><span class="hljs-attr">timestamp</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">Date</span>;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">makeDate</span>(<span class="hljs-params"><span class="hljs-attr">month</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">day</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">year</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">Date</span>;\n\n<span class="hljs-comment">// 实现函数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">makeDate</span>(<span class="hljs-params"><span class="hljs-attr">arg1</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">arg2</span>?: <span class="hljs-built_in">any</span>, <span class="hljs-attr">arg3</span>?: <span class="hljs-built_in">any</span></span>): <span class="hljs-title class_">Date</span> {\n  <span class="hljs-keyword">if</span> (arg2 === <span class="hljs-literal">undefined</span> &amp;&amp; arg3 === <span class="hljs-literal">undefined</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(arg1);\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(arg1, arg2 - <span class="hljs-number">1</span>, arg3); <span class="hljs-comment">// 月份从 0 开始</span>\n  }\n}\n\n<span class="hljs-comment">// 使用重载</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">makeDate</span>(<span class="hljs-number">1609459200000</span>)); <span class="hljs-comment">// 使用时间戳创建日期</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">makeDate</span>(<span class="hljs-number">12</span>, <span class="hljs-number">25</span>, <span class="hljs-number">2020</span>)); <span class="hljs-comment">// 使用年、月、日创建日期</span>\n</code></pre>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>函数重载是 TypeScript 的强大特性</strong>  ：它允许为同一个函数提供多个类型签名，提高了代码的灵活性和类型安全性。</li>\n<li><strong>实现部分需要处理所有签名</strong>  ：在实现函数中，需要根据参数类型执行相应的逻辑。</li>\n<li><strong>类型检查是关键</strong>  ：在实现中，通常使用类型检查来区分不同的参数类型。</li>\n</ul>\n<p>通过合理使用函数重载，可以编写出更加灵活、类型安全的代码。</p>\n</div>'</script></body></html>