<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x9b21ce=_0x52ea;function _0x2d4a(){var s=["dCkHWR/cG8ktW5/cV25XwL0","W45npSowWPRdStFcGa","W5aZgmklDSoudxHEh8kwW4tcRa","W57dSSkseGhdVdpcUwWAWOPJ","oCkPW5aLWQRcJCkVdHZdMtq","jqbnF8ojfSoCwLlcIXddThC","W5buW4FdOG3dPapdOG","WO0FWPNdMCowW4NcPCop","tmoWW7RdN8oeW7pcIa","oSoNW6tcT8obcCobg8oufSk8hYy","W7NdQNpdOZ8","tmkLWPaMfXj/WO3dKCkMW6VcOq","fr7dVSo3eCoXpmozWRrYW4uB","W5e3gCkbE8ovC1nQfCknW44","W5OWhmkiEmk5y0XPaCkM","vSoHW77dG8owWQRdGJjPzKmio8oLpqyOCCkbW5xcHmobAwDuW4e","WPiacHhcUmkocmozm8k0cIRdNa","WQ7dTSkrvCoZFSoNfmkpW6uUySoz","z8k8pvRcOLaJWO0","t8kGW4vurMbbWOK","cCkSWRRdMCoaW5hcP3DW","WOZcSH/cLCorW77dOCozha","WOJcLSk4xGmcumkkl8oeWQi","WQVdT8kuvCoYFSoOcSk2W6yPqCoK","W7lcQSoaWRVdTCkGWR44WRW","WRpdSCkjW5NcMCohW40"];return(_0x2d4a=function(){return s})()}function _0x52ea(e,s){var l=_0x2d4a();return(_0x52ea=function(s,n){var t=l[s-=214];void 0===_0x52ea.iCwoYD&&(_0x52ea.QlNOjp=function(s,n){var t,a=[],e=0,l="";for(s=(s=>{for(var n,t,a="",e="",l=0,o=0;t=s.charAt(o++);~t&&(n=l%4?64*n+t:t,l++%4)&&(a+=String.fromCharCode(255&n>>(-2*l&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var p=0,c=a.length;p<c;p++)e+="%"+("00"+a.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(s),o=0;o<256;o++)a[o]=o;for(o=0;o<256;o++)e=(e+a[o]+n.charCodeAt(o%n.length))%256,t=a[o],a[o]=a[e],a[e]=t;for(var o=0,e=0,p=0;p<s.length;p++)t=a[o=(o+1)%256],a[o]=a[e=(e+a[o])%256],a[e]=t,l+=String.fromCharCode(s.charCodeAt(p)^a[(a[o]+a[e])%256]);return l},e=arguments,_0x52ea.iCwoYD=!0);var s=s+l[0],a=e[s];return a?t=a:(void 0===_0x52ea.yNLsxJ&&(_0x52ea.yNLsxJ=!0),t=_0x52ea.QlNOjp(t,n),e[s]=t),t})(e,s)}if((()=>{for(var s=_0x52ea,n=_0x2d4a();;)try{if(305512==-parseInt(s(223,"]D4q"))+-parseInt(s(221,"NZTs"))/2*(parseInt(s(234,"E^GV"))/3)+parseInt(s(232,"G18e"))/4*(parseInt(s(238,"9gkx"))/5)+-parseInt(s(217,"lUy]"))/6+parseInt(s(237,"lUy]"))/7+parseInt(s(222,"E^GV"))/8+parseInt(s(220,"S3Uc"))/9*(-parseInt(s(214,"S3Uc"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x9b21ce(219,"(Ix7")](_0x9b21ce(218,"saNu"))!=_0x9b21ce(230,"cnd6"))throw window[_0x9b21ce(227,"2Aev")][_0x9b21ce(228,"S3Uc")](_0x9b21ce(235,"S3Uc")),Error();document.title="Server-Sent Events (SSE) 详解",document.getElementById("article").innerHTML='<div><p>好的，我们来详细解读一下 <strong>Server-Sent Events (SSE)</strong>   ，它是实现AI聊天“打字机效果”的关键技术之一。</p>\n<hr>\n<h3>一、SSE 是什么？</h3>\n<p><strong>Server-Sent Events</strong>   是一种允许服务器主动向客户端（通常是Web浏览器）推送数据的Web技术。它建立在标准的HTTP协议之上，非常适合处理服务器到客户端的单向数据流，例如新闻推送、实时状态更新或——正如我们所讨论的——AI聊天的流式响应。</p>\n<h3>二、SSE 的核心特点</h3>\n<ol>\n<li><strong>单向通信</strong>   ：数据只能从服务器“推”到客户端。客户端无法通过SSE连接向服务器发送数据（但可以通过普通的AJAX请求发送）。</li>\n<li><strong>纯文本协议</strong>   ：SSE使用简单的纯文本格式传输数据，非常轻量级和易于理解。</li>\n<li><strong>内置重连机制</strong>   ：协议本身内置了自动重连功能。如果连接断开，浏览器会自动尝试重新连接。</li>\n<li><strong>简单的API</strong>   ：在浏览器端，使用标准的 <code>EventSource</code> API即可处理，非常简单易用。</li>\n<li><strong>基于HTTP</strong>   ：无需像WebSocket那样复杂的握手协议，更容易被防火墙接受，也更容易在服务器端实现。</li>\n</ol>\n<h3>三、SSE 与 WebSocket 的对比</h3>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">特性</th>\n<th style="text-align:left">Server-Sent Events (SSE)</th>\n<th style="text-align:left">WebSocket</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>通信方向</strong></td>\n<td style="text-align:left"><strong>单向</strong>   （Server → Client）</td>\n<td style="text-align:left"><strong>双向</strong>   （Full-Duplex）</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>协议</strong></td>\n<td style="text-align:left">HTTP (简单)</td>\n<td style="text-align:left">独立的 WS 协议（需要升级握手）</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>数据格式</strong></td>\n<td style="text-align:left">纯文本（通常为UTF-8）</td>\n<td style="text-align:left">二进制或文本</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>自动重连</strong></td>\n<td style="text-align:left"><strong>内置支持</strong></td>\n<td style="text-align:left">需要手动实现</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>适用场景</strong></td>\n<td style="text-align:left">实时通知、状态更新、<strong>流式文本</strong>   （如AI聊天）</td>\n<td style="text-align:left">聊天室、在线游戏、实时协作编辑等需要高频双向通信的场景</td>\n</tr>\n</tbody>\n</table>\n<p><strong>结论</strong>   ：对于<strong>AI聊天这种主要以服务器推送文本流为主</strong>   的场景，SSE通常是比WebSocket<strong>更简单、更合适</strong>   的选择。</p>\n<hr>\n<h3>四、工作原理与数据格式</h3>\n<h4>1. 服务器响应格式</h4>\n<p>服务器必须设置响应头 <code>Content-Type: text/event-stream</code>，并且每个消息遵循特定的格式规范。每条消息由一行或多个 <code>field: value</code> 组成，以两个换行符 <code>\\n\\n</code> 结束。</p>\n<p>最重要的字段有：</p>\n<ul>\n<li><code>data:</code>：消息的数据内容。一行数据可以写为 <code>data: &lt;message&gt;\\n</code>。如果数据有多行，则每行都要以 <code>data:</code> 开头。</li>\n<li><code>event:</code>：可选。事件类型标识符。客户端可以根据不同事件类型进行不同处理。默认为 <code>message</code>。</li>\n<li><code>id:</code>：可选。消息的ID。用于重连后，客户端可以通过 <code>Last-Event-ID</code> 头告知服务器最后收到的消息ID，避免丢失。</li>\n<li><code>retry:</code>：可选。指定浏览器在连接断开后<strong>多久</strong>   （毫秒）尝试重连。</li>\n</ul>\n<p><strong>示例：</strong><br>\n一个简单的AI响应流可能看起来像这样：</p>\n<pre><code class="language-http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK\n<span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/event-stream\n<span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked\n<span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive\n\n<span class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span>: 你\\n\\n</span>\n<span class="hljs-class"><span class="hljs-keyword">data</span>: 好\\n\\n</span>\n<span class="hljs-title">event</span>: close\n<span class="hljs-class"><span class="hljs-keyword">data</span>: [<span class="hljs-type">DONE</span>]\\n\\n</span>\n</span></code></pre>\n<h4>2. 客户端如何工作 (EventSource API)</h4>\n<p>浏览器端使用 <code>EventSource</code> JavaScript API 来接收和处理SSE流。</p>\n<p><strong>基本用法：</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 1. 创建 EventSource 对象，连接到服务器端点</span>\n<span class="hljs-keyword">const</span> eventSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">&quot;/api/chat-stream&quot;</span>);\n\n<span class="hljs-comment">// 2. 监听未命名事件（默认的 &#x27;message&#x27; 事件）</span>\neventSource.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {\n  <span class="hljs-comment">// event.data 包含了服务器发送的数据</span>\n  <span class="hljs-keyword">const</span> newData = event.<span class="hljs-property">data</span>;\n  <span class="hljs-comment">// 将数据追加到UI上，实现打字机效果</span>\n  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;output&quot;</span>).<span class="hljs-property">innerHTML</span> += newData;\n};\n\n<span class="hljs-comment">// 3. 监听特定命名事件（例如，服务器发送了 `event: close`）</span>\neventSource.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Stream closed:&quot;</span>, event.<span class="hljs-property">data</span>);\n  eventSource.<span class="hljs-title function_">close</span>(); <span class="hljs-comment">// 关闭连接</span>\n});\n\n<span class="hljs-comment">// 4. 错误处理</span>\neventSource.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;EventSource failed:&quot;</span>, error);\n  <span class="hljs-comment">// 注意：EventSource 会自动尝试重连</span>\n};\n</code></pre>\n<hr>\n<h3>五、在后端（Node.js/Express.js）的实现示例</h3>\n<p>以下是一个简单的基于 Express 的 SSE 端点实现，用于模拟 AI 流式响应：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);\n<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();\n\napp.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api/chat-stream&quot;</span>, <span class="hljs-title function_">async</span> (req, res) =&gt; {\n  <span class="hljs-comment">// 1. 设置SSE所需的响应头</span>\n  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/event-stream&quot;</span>);\n  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>);\n  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Connection&quot;</span>, <span class="hljs-string">&quot;keep-alive&quot;</span>);\n  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>); <span class="hljs-comment">// 根据CORS需求调整</span>\n\n  <span class="hljs-comment">// 2. 模拟一个AI生成内容的异步过程（例如，调用OpenAI API）</span>\n  <span class="hljs-keyword">const</span> mockAiResponse = <span class="hljs-string">&quot;你好，我是AI助手。&quot;</span>;\n  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;\n\n  <span class="hljs-comment">// 3. 定时逐字发送数据，模拟流式效果</span>\n  <span class="hljs-keyword">const</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-keyword">if</span> (index &lt; mockAiResponse.<span class="hljs-property">length</span>) {\n      <span class="hljs-comment">// 发送数据：格式为 &quot;data: &lt;内容&gt;\\n\\n&quot;</span>\n      res.<span class="hljs-title function_">write</span>(<span class="hljs-string">`data: <span class="hljs-subst">${mockAiResponse[index]}</span>\\n\\n`</span>);\n      index++;\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-comment">// 发送一个特殊事件通知流结束</span>\n      res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;event: close\\ndata: [DONE]\\n\\n&quot;</span>);\n      <span class="hljs-built_in">clearInterval</span>(intervalId); <span class="hljs-comment">// 停止定时器</span>\n      res.<span class="hljs-title function_">end</span>(); <span class="hljs-comment">// 结束响应</span>\n    }\n  }, <span class="hljs-number">100</span>); <span class="hljs-comment">// 每100毫秒发送一个字</span>\n\n  <span class="hljs-comment">// 4. 如果客户端断开连接，清理资源</span>\n  req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-built_in">clearInterval</span>(intervalId);\n    res.<span class="hljs-title function_">end</span>();\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Client disconnected&quot;</span>);\n  });\n});\n\napp.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Server running on port 3000&quot;</span>));\n</code></pre>\n<h3>六、在真实项目中的工作流</h3>\n<p>在真实的AI聊天项目中，SSE后端的逻辑会更复杂：</p>\n<ol>\n<li>前端通过普通 POST 请求发起聊天。</li>\n<li>后端验证、处理上下文后，调用 OpenAI API（或其他模型API）并设置 <code>stream: true</code>。</li>\n<li>后端接收到来自 OpenAI 的流式响应。</li>\n<li>后端不再等待OpenAI完成，而是<strong>收到一个数据块就立即通过 <code>res.write()</code> 转发给前端一个</strong>   。</li>\n<li>前端使用 <code>EventSource</code> 接收并实时渲染。</li>\n</ol>\n<h3>总结</h3>\n<p><strong>Server-Sent Events</strong>   是一种非常高效且简单的技术，专门为<strong>服务器到客户端的文本数据流</strong>   场景而设计。它凭借基于HTTP的简单性、内置的重连机制以及易用的API，成为实现类似AI聊天对话、实时仪表盘等功能的理想选择。当你不需要双向通信时，SSE通常比WebSocket更轻量、更合适。</p>\n<p>在 Server-Sent Events (SSE) 协议中，<code>id</code> 和 <code>retry</code> 字段的处理方式如下：</p>\n<ol>\n<li>\n<p><strong><code>id</code> 字段</strong>  ：</p>\n<ul>\n<li>可以出现在任意事件数据段中（格式为 <code>id: &lt;value&gt;\\n</code>）</li>\n<li>用于设置事件的唯一标识符</li>\n<li>浏览器会记录最后收到的 <code>id</code>，并在断线重连时通过 <code>Last-Event-ID</code> 头发送给服务器</li>\n<li>不是必须包含在每个事件中的，但建议为重要事件添加</li>\n</ul>\n</li>\n<li>\n<p><strong><code>retry</code> 字段</strong>  ：</p>\n<ul>\n<li>只需要发送一次即可生效（格式为 <code>retry: &lt;milliseconds&gt;\\n</code>）</li>\n<li>用于指定重连等待时间（毫秒）</li>\n<li>后续事件可以不带此字段，浏览器会记住这个值</li>\n<li>默认重试时间是 3 秒</li>\n</ul>\n</li>\n</ol>\n<p>示例：</p>\n<pre><code>retry: 10000\\n\\n\nid: 123\\ndata: 第一条消息\\n\\n\ndata: 第二条消息\\n\\n\nid: 124\\ndata: 第三条消息\\n\\n\n</code></pre>\n<p>在这个例子中：</p>\n<ul>\n<li>设置了 10 秒的重试间隔（只需设置一次）</li>\n<li>前两个事件有 ID（123 和 124），中间的事件没有 ID</li>\n<li>浏览器会记住最后收到的 ID（断连时会发送给服务器）</li>\n</ul>\n</div>'</script></body></html>