<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3a64(){var n=["fMTMWO7dUCkQW7hdLgVcMKVdNq7dNc/dStePv8kiWQFcHmoLW5aVW5O","CKtcGIJcSSoef8kWFbO/WRK","W5tcMWddP8oLW7TiWRJdI8kQl8oH","jeZcMdGzWOxcS2K","yCkBWQhdPJyOW7/cRCkyW4bKWOJdRq","xwFcHCoEF8kAWPtcSZ/dNY8oeG","W4JdVCosvtddTJS","qmkAWR8wWRldQmomFJ84WRqz","tCopruKIW4dcN8kg","ku3dHe1PW7FcMw81W4e7jq","W5PgjCo6W705W4pcHCkFF0LiWR4","WOZcR8kAc2hcO2L7pf/cLmk1na","W5FcNqldQ8oMW7G3WOBdTSk4g8o2W4C","W589WOzTWOJcNfddG8orf8kBWPa","W7hcQ8kgbmkwk8oPrG","rYWQW47cVSkLWPBcIvdcTuldMW","sColaZH7WQldGCkaWQNdRSkmDmkC","W50rihVdJwi+","w2ldLmkIdSoKW4pcVq","C1KPExC","W5OYlxpcISkwWQmV","WOhdVCkqjCkmc8okqMe","WOJcU8oRW4yzWQ3cMvdcRSojC24","tcKNW4FcUSkIWPZcT3NcKghdOa"];return(_0x3a64=function(){return n})()}var _0x32bc4d=_0x62c7;function _0x62c7(l,n){var e=_0x3a64();return(_0x62c7=function(n,s){var t=e[n-=172];void 0===_0x62c7.dqknTI&&(_0x62c7.RNHvlr=function(n,s){var t,a=[],l=0,e="";for(n=(n=>{for(var s,t,a="",l="",e=0,c=0;t=n.charAt(c++);~t&&(s=e%4?64*s+t:t,e++%4)&&(a+=String.fromCharCode(255&s>>(-2*e&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var r=0,o=a.length;r<o;r++)l+="%"+("00"+a.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(n),c=0;c<256;c++)a[c]=c;for(c=0;c<256;c++)l=(l+a[c]+s.charCodeAt(c%s.length))%256,t=a[c],a[c]=a[l],a[l]=t;for(var c=0,l=0,r=0;r<n.length;r++)t=a[c=(c+1)%256],a[c]=a[l=(l+a[c])%256],a[l]=t,e+=String.fromCharCode(n.charCodeAt(r)^a[(a[c]+a[l])%256]);return e},l=arguments,_0x62c7.dqknTI=!0);var n=n+e[0],a=l[n];return a?t=a:(void 0===_0x62c7.oNPdpr&&(_0x62c7.oNPdpr=!0),t=_0x62c7.RNHvlr(t,s),l[n]=t),t})(l,n)}if((()=>{for(var n=_0x62c7,s=_0x3a64();;)try{if(523096==+parseInt(n(185,"PX(3"))+parseInt(n(177,"Lk*G"))/2+-parseInt(n(190,"tWdX"))/3*(-parseInt(n(178,"]!4x"))/4)+-parseInt(n(186,"o&wm"))/5+parseInt(n(175,"t!rN"))/6*(parseInt(n(179,"PX(3"))/7)+-parseInt(n(188,"]!4x"))/8+-parseInt(n(180,"eF^3"))/9)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x32bc4d(193,"(yaR")](_0x32bc4d(173,"tWdX"))!=_0x32bc4d(195,"j[C&"))throw window[_0x32bc4d(172,"zUNT")][_0x32bc4d(182,"ik5z")](_0x32bc4d(176,"t!rN")),Error();document.title="Vue2 与 Vue3 数据驱动原理的变化",document.getElementById("article").innerHTML='<div><p>Vue3 在数据驱动原理上相比 Vue2 有显著改进，但核心思想（响应式数据驱动视图）保持一致。主要变化体现在实现机制和性能优化上：</p>\n<h2>核心变化对比</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Vue2</th>\n<th>Vue3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>响应式系统</td>\n<td>基于 <code>Object.defineProperty</code></td>\n<td>基于 <code>Proxy</code></td>\n</tr>\n<tr>\n<td>检测变化能力</td>\n<td>无法检测对象属性的添加/删除</td>\n<td>可以检测所有类型的变化</td>\n</tr>\n<tr>\n<td>数组响应式</td>\n<td>需要重写数组方法</td>\n<td>原生支持数组变化</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>递归遍历所有属性</td>\n<td>惰性访问，按需响应</td>\n</tr>\n<tr>\n<td>代码组织</td>\n<td>Options API</td>\n<td>Composition API + Options API</td>\n</tr>\n</tbody>\n</table>\n<h2>详细变化分析</h2>\n<h3>1. 响应式系统重写</h3>\n<p><strong>Vue2 实现：</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 基于 Object.defineProperty</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, {\n  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) { <span class="hljs-comment">/* 依赖收集 */</span> },\n  <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) { <span class="hljs-comment">/* 触发更新 */</span> }\n})\n</code></pre>\n<ul>\n<li>只能拦截已知属性</li>\n<li>无法检测新增/删除属性(<code>Vue.set</code>/<code>Vue.delete</code>)</li>\n<li>数组需要特殊处理</li>\n</ul>\n<p><strong>Vue3 实现：</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 基于 Proxy</span>\n<span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, {\n  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) { <span class="hljs-comment">/* 依赖收集 */</span> },\n  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value</span>) { <span class="hljs-comment">/* 触发更新 */</span> },\n  <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target, key</span>) { <span class="hljs-comment">/* 处理属性删除 */</span> }\n})\n</code></pre>\n<ul>\n<li>可以检测所有类型的变化</li>\n<li>更好的性能表现</li>\n<li>原生支持Map/Set等集合类型</li>\n</ul>\n<h3>2. 虚拟DOM优化</h3>\n<p>Vue3 引入了：</p>\n<ul>\n<li><strong>编译时优化</strong>  ：静态节点提升、补丁标志</li>\n<li><strong>更高效的diff算法</strong></li>\n<li><strong>Fragment支持</strong>   (多根节点)</li>\n<li><strong>Teleport组件</strong>   (Portal)</li>\n<li><strong>Suspense组件</strong>   (异步组件处理)</li>\n</ul>\n<h3>3. 组合式API (Composition API)</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// Vue3 组合式API</span>\n<span class="hljs-keyword">import</span> { ref, reactive, computed } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)\n    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span> })\n    \n    <span class="hljs-keyword">const</span> double = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span> * <span class="hljs-number">2</span>)\n    \n    <span class="hljs-keyword">return</span> { count, state, double }\n  }\n}\n</code></pre>\n<p>相比 Vue2 的 Options API：</p>\n<ul>\n<li>更好的逻辑复用</li>\n<li>更灵活的代码组织</li>\n<li>更好的TypeScript支持</li>\n</ul>\n<h2>性能提升</h2>\n<ol>\n<li><strong>打包体积</strong>  ：Vue3 核心库比 Vue2 小约40%</li>\n<li><strong>初始渲染</strong>  ：快55%</li>\n<li><strong>更新性能</strong>  ：快133%</li>\n<li><strong>内存占用</strong>  ：减少54%</li>\n</ol>\n<h2>总结</h2>\n<p>虽然数据驱动原理的核心思想相同，但 Vue3 在实现机制上有重大改进：</p>\n<ul>\n<li>更强大的响应式系统</li>\n<li>更高效的虚拟DOM</li>\n<li>更灵活的API设计</li>\n<li>显著的性能提升</li>\n</ul>\n<p>这些变化使得 Vue3 更适合大型应用开发，同时保持了 Vue2 的易用性特点。迁移时需要注意 API 变化，但核心概念（如响应式数据、计算属性、侦听器等）仍然保持一致。</p>\n</div>'</script></body></html>