<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1540df=_0x1177;function _0x1177(a,n){var e=_0x346b();return(_0x1177=function(n,t){var s=e[n-=446];void 0===_0x1177.YXxYNv&&(_0x1177.NuRfsd=function(n,t){var s,o=[],a=0,e="";for(n=(n=>{for(var t,s,o="",a="",e=0,c=0;s=n.charAt(c++);~s&&(t=e%4?64*t+s:s,e++%4)&&(o+=String.fromCharCode(255&t>>(-2*e&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var r=0,l=o.length;r<l;r++)a+="%"+("00"+o.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(a)})(n),c=0;c<256;c++)o[c]=c;for(c=0;c<256;c++)a=(a+o[c]+t.charCodeAt(c%t.length))%256,s=o[c],o[c]=o[a],o[a]=s;for(var c=0,a=0,r=0;r<n.length;r++)s=o[c=(c+1)%256],o[c]=o[a=(a+o[c])%256],o[a]=s,e+=String.fromCharCode(n.charCodeAt(r)^o[(o[c]+o[a])%256]);return e},a=arguments,_0x1177.YXxYNv=!0);var n=n+e[0],o=a[n];return o?s=o:(void 0===_0x1177.KsrBBo&&(_0x1177.KsrBBo=!0),s=_0x1177.NuRfsd(s,t),a[n]=s),s})(a,n)}function _0x346b(){var n=["C0yzyM/cH8o9hWr9W5pdRSkc","W5fpu8otWPOlnGm7W5yGE8og","pSoViuLcW7ddNW","n8kgWQSBW4tcMmocW7dcGXNdUNpcMa","WRSHW5pcVCkvvSo2FK14W4OpWQ3dRSk2WQyoBmojW6P4WRumEmodW6C","Cmojpmk1WR9dW6SCcmkHWOhdUG","W5FcKSkLjmkWlCo6WOVcH8oHWROVWQhcMa","W6ddJwxdKW7dRmooWPJcRGCRWRBcOq","WOCCpdLMW6xdVa","W55fWROGW4NdQ2O","p8okdIZcHa","mCkdWQGFW4RcN8ofW5VcSXRdJLhcUG","qmk9W6dcRri0dq","pCk7BSopdqdcGsG","WQNcTJ4aW68cfgOP","WRtcTXtcUSo1WQRdKCke","pmksj8oDWPFdG8oE","W7mSsCocd1yNeuL7fCkZh8o3","W5xcMCoivmoYDCkNW5G","W6RdOuBdQCkZW7FdJCkTDmo1W7xcUW","WO0qdmo8BCkYnW","W6VdIsddNCoPW7FcQa","bHNdVCo/W4qUW4ldJb3dGvT5fW","WRtdOSkuiSouW63dIG","DdNdL1JcKCo4W5JdG8oTWPVdNmkiW7q","WObDDw44WPdcJmk0jCoBrmo6CG","W4pdUSotW5mXoCoBedlcG1RcSSkP"];return(_0x346b=function(){return n})()}if((()=>{for(var n=_0x1177,t=_0x346b();;)try{if(831994==-parseInt(n(466,"^E&D"))+-parseInt(n(460,"$$om"))/2+-parseInt(n(453,"c*Z!"))/3*(parseInt(n(449,"E!@v"))/4)+parseInt(n(451,"#w86"))/5*(parseInt(n(458,"^E&D"))/6)+-parseInt(n(462,"F1D("))/7*(parseInt(n(471,"]dQj"))/8)+parseInt(n(468,"]95["))/9*(-parseInt(n(456,"mc$f"))/10)+parseInt(n(472,"obTA"))/11)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x1540df(448,"R131")](_0x1540df(469,"b5id"))!=_0x1540df(465,"XAG]"))throw window[_0x1540df(470,"FAkK")][_0x1540df(467,"4ELq")](_0x1540df(459,"0CCH")),Error();document.title="React 在根节点上通过捕获阶段（而非冒泡阶段）监听原生事件",document.getElementById("article").innerHTML='<div><p>是的，<strong>React 在根节点（如 <code>document</code> 或 React 17+ 的应用挂载节点）上通过捕获阶段（<code>capture: true</code>）监听原生事件</strong>   ，这是其合成事件系统能够可靠运行的核心设计之一。以下是详细解释：</p>\n<hr>\n<h3>1. <strong>React 事件监听的核心机制</strong></h3>\n<h4>（1）事件委托到根节点</h4>\n<ul>\n<li><strong>React 16 及之前</strong>   ：所有事件委托到 <code>document</code> 节点。</li>\n<li><strong>React 17+</strong>   ：事件委托到应用挂载的根 DOM 节点（如 <code>ReactDOM.createRoot(root).render()</code>）。</li>\n<li><strong>监听阶段</strong>   ：<br>\nReact 在根节点上通过<strong>捕获阶段</strong>   （而非冒泡阶段）监听原生事件。例如：<pre><code class="language-javascript"><span class="hljs-comment">// React 内部的简化逻辑</span>\nrootNode.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, dispatchEvent, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 第三个参数 true 表示捕获阶段</span>\n</code></pre>\n</li>\n</ul>\n<h4>（2）为什么用捕获阶段？</h4>\n<ul>\n<li><strong>确保优先拦截事件</strong>   ：<br>\n捕获阶段早于目标阶段和冒泡阶段触发。即使子组件调用 <code>e.nativeEvent.stopPropagation()</code> 阻止原生事件冒泡，React 仍能在捕获阶段获取事件。</li>\n<li><strong>绕过第三方库的干扰</strong>   ：<br>\n某些库可能会阻止事件冒泡，但无法阻止捕获阶段的监听。</li>\n</ul>\n<hr>\n<h3>2. <strong>完整事件流程（以点击事件为例）</strong></h3>\n<ol>\n<li>\n<p><strong>用户点击 <code>&lt;button&gt;</code></strong>   ：<br>\n浏览器生成原生 <code>click</code> 事件，按顺序触发：</p>\n<ul>\n<li><strong>捕获阶段</strong>   ：从 <code>window</code> → <code>document</code> → ... → <code>&lt;button&gt;</code> 的父节点。</li>\n<li><strong>目标阶段</strong>   ：触发 <code>&lt;button&gt;</code> 上的原生事件。</li>\n<li><strong>冒泡阶段</strong>   ：从 <code>&lt;button&gt;</code> → 父节点 → ... → <code>document</code>（如果未被阻止）。</li>\n</ul>\n</li>\n<li>\n<p><strong>React 的捕获监听</strong>   ：<br>\nReact 的根节点在捕获阶段监听到事件，调用 <code>dispatchEvent</code>：</p>\n<ul>\n<li>通过 <code>event.target</code> 找到实际点击的 DOM 节点。</li>\n<li>根据 Fiber 树（虚拟 DOM）定位对应的 React 组件。</li>\n</ul>\n</li>\n<li>\n<p><strong>合成事件的派发</strong>   ：<br>\nReact <strong>手动模拟</strong>   事件流程：</p>\n<ul>\n<li><strong>捕获阶段</strong>   ：从根组件向下调用 <code>onClickCapture</code>。</li>\n<li><strong>冒泡阶段</strong>   ：从目标组件向上调用 <code>onClick</code>（除非调用 <code>e.stopPropagation()</code>）。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>3. <strong>关键验证：<code>e.nativeEvent.stopPropagation()</code> 无效的原因</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params">e</span>) =&gt; {\n    e.<span class="hljs-property">nativeEvent</span>.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 阻止原生冒泡</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Button clicked&quot;</span>);\n  };\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> console.log(&quot;Div clicked&quot;)}&gt;\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n};\n</code></pre>\n<h4>输出：</h4>\n<pre><code>Button clicked\nDiv clicked // 合成事件仍触发！\n</code></pre>\n<ul>\n<li><strong>原因</strong>   ：<br>\n<code>e.nativeEvent.stopPropagation()</code> 只能阻止原生事件冒泡到 <code>&lt;div&gt;</code> 的原生监听器，但 React 已在捕获阶段获取事件，并独立触发了合成事件冒泡。</li>\n</ul>\n<hr>\n<h3>4. <strong>特殊情况：阻止合成事件冒泡</strong></h3>\n<p>若想同时阻止原生和合成事件冒泡，需：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params">e</span>) =&gt; {\n  e.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 阻止合成事件冒泡</span>\n  e.<span class="hljs-property">nativeEvent</span>.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 阻止原生事件冒泡</span>\n};\n</code></pre>\n<hr>\n<h3>5. **React 17+ 的变化</h3>\n<ul>\n<li><strong>事件委托节点变化</strong>   ：<br>\n从 <code>document</code> 改为应用挂载的根节点（如 <code>const root = ReactDOM.createRoot(app)</code>）。</li>\n<li><strong>隔离多版本 React</strong>   ：<br>\n避免多个 React 版本的事件在 <code>document</code> 上冲突。</li>\n<li><strong>机制不变</strong>   ：<br>\n仍通过捕获阶段监听原生事件，合成事件冒泡仍是独立模拟的。</li>\n</ul>\n<hr>\n<h3>6. **总结</h3>\n<table>\n<thead>\n<tr>\n<th>行为</th>\n<th>原生 DOM 事件</th>\n<th>React 合成事件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>e.nativeEvent.stopPropagation()</code></td>\n<td>❌ 阻止后续原生冒泡</td>\n<td>✅ 无影响</td>\n</tr>\n<tr>\n<td><code>e.stopPropagation()</code></td>\n<td>✅ 无影响</td>\n<td>❌ 阻止合成事件冒泡</td>\n</tr>\n<tr>\n<td>React 根节点监听</td>\n<td>捕获阶段（<code>capture: true</code>）</td>\n<td>手动模拟捕获/冒泡</td>\n</tr>\n</tbody>\n</table>\n<p><strong>核心结论</strong>   ：<br>\nReact 通过在根节点的<strong>捕获阶段</strong>   监听原生事件，确保即使原生冒泡被阻止，合成事件仍能正常触发。合成事件的冒泡是 React 手动模拟的，与原生事件无关。</p>\n</div>'</script></body></html>