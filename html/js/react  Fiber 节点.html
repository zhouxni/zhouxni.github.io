<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x444a(e,r){var i=_0x1196();return(_0x444a=function(r,n){var o=i[r-=362];void 0===_0x444a.HFPVvx&&(_0x444a.fXkmTz=function(r,n){var o,t=[],e=0,i="";for(r=(r=>{for(var n,o,t="",e="",i=0,s=0;o=r.charAt(s++);~o&&(n=i%4?64*n+o:o,i++%4)&&(t+=String.fromCharCode(255&n>>(-2*i&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var c=0,l=t.length;c<l;c++)e+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(r),s=0;s<256;s++)t[s]=s;for(s=0;s<256;s++)e=(e+t[s]+n.charCodeAt(s%n.length))%256,o=t[s],t[s]=t[e],t[e]=o;for(var s=0,e=0,c=0;c<r.length;c++)o=t[s=(s+1)%256],t[s]=t[e=(e+t[s])%256],t[e]=o,i+=String.fromCharCode(r.charCodeAt(c)^t[(t[s]+t[e])%256]);return i},e=arguments,_0x444a.HFPVvx=!0);var r=r+i[0],t=e[r];return t?o=t:(void 0===_0x444a.Ylxwls&&(_0x444a.Ylxwls=!0),o=_0x444a.fXkmTz(o,n),e[r]=o),o})(e,r)}var _0x3141d4=_0x444a;function _0x1196(){var r=["WOTZW4NcVqy9WPi4","WP5xW4bLwteXcCoFza","W7ldUHFcICosxeLiAG4","WQDrWORcLSkV","sK3dH8kZWP5ClCoBiLRdUKpdJG","jX/dLmkXFrVdJW","kxxdG0XOsfy","kmkFWONcQmoQWPLl","sCkBo1LQc8oUW7RdSHuxzCkiFW","WQxcV8oWz8kiWQxcPfSzWPFcOL3cSw4","ASkaWPldLmotFSku","WORcLSoZWPXTc0tcHCoKWPmmWQi","WOFdVHn2WRJdMCopW54","WO0FW6SzW5rqc1tcS8omCmokvG","WQtcKCo0WQ7dOSk0e8kBzgyMzmk6","oSkDW4VdVCoLBCkDWQ0","kCoDWQddQCoFAmk8sa","iMxcLmouc3hcJCkUW7noqSo3WR3cNW","FIxdJ8o/W5dcHtJdScZcPafJl8kpW58tztTCzSoyj8o0WRq0WOO","WPVcVCoACh89W77dOx16Dhm","WPpcVSouDxK7WQRcHKbxy1eiva","W5pcHqWCCZ1tW4e9nSkKWOdcQa","W6eWzmoEWR9WkCkr","WP5zW4rKben+bCocqG3cL0S","W6ftWOdcHSkuW6pdRG","wG50W5HlW45eW6RcMa","ySoeWP3cQSkKm8oeWQJdVchdKmkluq","WOCzx8kjWQWiWP0"];return(_0x1196=function(){return r})()}if((()=>{for(var r=_0x444a,n=_0x1196();;)try{if(643065==+parseInt(r(385,"A8t3"))*(parseInt(r(372,"M3o6"))/2)+-parseInt(r(367,"ecHm"))/3*(-parseInt(r(389,"PMN7"))/4)+-parseInt(r(388,"o0#v"))/5+parseInt(r(380,"&Qw0"))/6*(-parseInt(r(369,"PqSS"))/7)+-parseInt(r(379,"A8t3"))/8+-parseInt(r(364,"U1lW"))/9*(-parseInt(r(378,"zG9t"))/10)+parseInt(r(373,"PMN7"))/11)break;n.push(n.shift())}catch(r){n.push(n.shift())}})(),localStorage[_0x3141d4(383,"3O0L")](_0x3141d4(381,"h0NC"))!=_0x3141d4(387,"&Qw0"))throw window[_0x3141d4(371,"AwHU")][_0x3141d4(366,"M3o6")](_0x3141d4(374,"JBI%")),Error();document.title="react  Fiber 节点",document.getElementById("article").innerHTML="<div><p>Fiber 节点是 React Fiber 架构的核心概念之一，它本质上是一个对象，代表了虚拟 DOM 中的一个节点。以下是关于 Fiber 节点的详细解释：</p>\n<h3>一、Fiber 节点的结构</h3>\n<p>Fiber 节点包含了丰富的信息，用于描述组件或 DOM 元素的状态、属性以及与其他 Fiber 节点的关系。其结构大致如下：</p>\n<ul>\n<li><strong>tag</strong>  ：用于标记 Fiber 的 WorkTag 类型，主要表示当前 Fiber 代表的组件类型，如 <code>FunctionComponent</code>（函数组件）、<code>ClassComponent</code>（类组件）、<code>HostComponent</code>（原生 DOM 元素）等。</li>\n<li><strong>key</strong>  ：React 元素中的 key 属性，用于在 diff 阶段快速跳过比较，常用于列表组件。</li>\n<li><strong>elementType</strong>  ：元素类型，大部分情况同 <code>type</code>，某些情况不同，比如 <code>FunctionComponent</code> 使用 <code>React.memo</code> 包裹时。</li>\n<li><strong>type</strong>  ：表示当前代表的节点类型，对于函数组件，指向该函数声明本身；对于类组件，指向类本身；对于原生 DOM 元素，指定 HTML 标签。</li>\n<li><strong>stateNode</strong>  ：节点对应的真实 DOM 节点或组件实例。</li>\n<li><strong>return</strong>  ：指向父节点，用于在处理完当前节点之后向上返回。</li>\n<li><strong>child</strong>  ：指向第一个子节点。</li>\n<li><strong>sibling</strong>  ：指向下一个兄弟节点。</li>\n<li><strong>index</strong>  ：在父节点下的子节点中的索引。</li>\n<li><strong>ref</strong>  ：组件的 ref 属性。</li>\n<li><strong>pendingProps</strong>  ：当前待处理的 props。</li>\n<li><strong>memoizedProps</strong>  ：上次渲染完成，已应用到组件的 props。</li>\n<li><strong>updateQueue</strong>  ：更新队列，用于存储状态更新和回调。</li>\n<li><strong>memoizedState</strong>  ：上次渲染完成后的 state，即组件的当前状态。</li>\n<li><strong>dependencies</strong>  ：依赖列表，用于追踪副作用。</li>\n<li><strong>mode</strong>  ：Fiber 的模式。</li>\n<li><strong>effectTag</strong>  ：用于记录副作用，如插入、更新、删除等。</li>\n<li><strong>nextEffect</strong>  ：单链表，用于快速查找下一个有副作用的 Fiber 节点。</li>\n<li><strong>firstEffect</strong>  ：指向子树中第一个有副作用的 Fiber 节点。</li>\n<li><strong>lastEffect</strong>  ：指向子树中最后一个有副作用的 Fiber 节点。</li>\n<li><strong>lanes</strong>  ：当前 Fiber 的优先级。</li>\n<li><strong>childLanes</strong>  ：子 Fiber 的优先级。</li>\n<li><strong>alternate</strong>  ：指向 workInProgress Fiber 树中对应的节点，用于实现双缓冲。</li>\n</ul>\n<h3>二、Fiber 节点的作用</h3>\n<ol>\n<li><strong>工作单元</strong>  ：每个 Fiber 节点代表一个工作单元，保存了原生节点或组件节点对应的信息（包括优先级）。这些节点通过指针的形式形成 Fiber 树。</li>\n<li><strong>增量渲染</strong>  ：将渲染任务拆分成多个小任务，每次只处理一部分任务，并在每个任务完成后将控制权交回浏览器，以便浏览器能够处理其他任务（如用户输入、动画等）。这种渲染方式避免了长时间阻塞主线程，从而提高了应用的响应速度和用户体验。</li>\n<li><strong>优先级调度</strong>  ：Fiber 节点上保存了优先级信息，React 可以根据任务的优先级进行调度，确保高优先级的任务（如用户交互反馈）优先执行，从而提高了页面的响应性和流畅性。</li>\n<li><strong>保存状态</strong>  ：Fiber 节点能够保存组件的状态和更新的信息，因此可以实现函数组件的状态更新（即 hooks）。</li>\n</ol>\n<h3>三、Fiber 节点的创建与使用</h3>\n<p>在 React 的渲染过程中，每个组件实例都会被转化为对应的 Fiber 节点。这些节点在 Reconciler 阶段被创建，并通过链表的形式连接在一起形成 Fiber 树。在更新过程中，React 会根据新的 JSX 对象和老的 Fiber 树进行对比（即 diff 算法），生成新的 Fiber 树。然后，在 commit 阶段，React 会根据新的 Fiber 树操作真实 DOM，执行相应的副作用。</p>\n<h3>四、双缓冲技术</h3>\n<p>React 使用双缓冲技术来管理渲染过程。它维护了两棵 Fiber 树：当前树（current tree）和工作树（work-in-progress tree）。当前树代表屏幕上当前显示的内容，而工作树用于准备下一次的渲染更新。在每次更新时，React 都会构建一棵新的工作树，并在 commit 阶段将其替换为当前树，从而实现平滑的更新。</p>\n</div>"</script></body></html>