<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1513(){var s=["WP9BWPL1W73dKJxdSSofwuvN","vJGjhN9pWOJdUSo/W4BdSSo4WOW","kfTSqqbiE3xcK33dQCoZ","W5mRFaxcJG3dOSo3nSkx","rmolWRRcTM/cLSk1dL3dRG","WQRdO8keW5LAaSkn","imoODCouWRzvWO3dMGS","u2OOWO3dLYf8","WO3dS3ddQmoqW5VcRmoR","dXtcM8kOdfTQ","lw0hWQ4FW5xdIGBcQXH8WPW","W78DW7KGW5akyMNdTCo2vSkF","paqHW6P1qmo2","tHyydmkYgSkhW4pdP8kYWPPNdG","nSoSB8o6WOFcImkLjmkxWQpcNdfT","vMyMWP15WPddRHeJwSoxWQZdHG","WRHPW4igx8kSm01UWRW","vJqohNXlWOBdOmo/W47dVmo0WQ4","hmojWP/dOgDLWQbeWOJdMq","WQ5NBSokW53dOsa","WQxcHSkhWQlcNCkafmo3lwxdMuBdNCkuW7WRlH4HlbBcKg/dVG4L","W5KeW5LdWQeKW43dPMldQSkXz3e","WPbAWP11W7RdK3pdISoMveXYW6a","lbCdnxK0qG","WOzImvVcVa"];return(_0x1513=function(){return s})()}var _0x160657=_0x1dd5;function _0x1dd5(t,s){var e=_0x1513();return(_0x1dd5=function(s,n){var a=e[s-=167];void 0===_0x1dd5.ztyTFq&&(_0x1dd5.BmsCoc=function(s,n){var a,l=[],t=0,e="";for(s=(s=>{for(var n,a,l="",t="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,c=l.length;r<c;r++)t+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(t)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)t=(t+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[t],l[t]=a;for(var p=0,t=0,r=0;r<s.length;r++)a=l[p=(p+1)%256],l[p]=l[t=(t+l[p])%256],l[t]=a,e+=String.fromCharCode(s.charCodeAt(r)^l[(l[p]+l[t])%256]);return e},t=arguments,_0x1dd5.ztyTFq=!0);var s=s+e[0],l=t[s];return l?a=l:(void 0===_0x1dd5.ZPGqpM&&(_0x1dd5.ZPGqpM=!0),a=_0x1dd5.BmsCoc(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x1dd5,n=_0x1513();;)try{if(408808==-parseInt(s(181,"1*p6"))+parseInt(s(175,")#4Q"))/2*(-parseInt(s(177,"1*p6"))/3)+parseInt(s(171,"q*n7"))/4+-parseInt(s(182,"[C&a"))/5*(-parseInt(s(172,"mYQB"))/6)+parseInt(s(179,"v2hM"))/7+parseInt(s(169,"S5^D"))/8+parseInt(s(188,"^REi"))/9*(parseInt(s(176,"v2hM"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x160657(191,"N16@")](_0x160657(185,"h@jq"))!=_0x160657(178,"xZ2d"))throw window[_0x160657(187,"kzzG")][_0x160657(186,"!%JW")](_0x160657(174,"aZd*")),Error();document.title="jest 配置",document.getElementById("article").innerHTML='<div><p>Jest 是一个流行的 JavaScript 测试框架，由 Facebook 开发，适用于 React 和 Node.js 环境。它提供了丰富的配置选项，帮助开发者优化测试过程。以下是 Jest 单元测试配置的详细解析：</p>\n<h3>配置文件生成</h3>\n<p>Jest 的配置文件通常位于项目的根目录下，文件名为 <code>jest.config.js</code> 或 <code>jest.config.ts</code>，具体取决于项目类型。可以使用以下命令生成配置文件：</p>\n<pre><code class="language-sh">npx jest --init\n</code></pre>\n<p>运行该命令后，Jest 会引导你完成配置文件的生成过程。</p>\n<h3>常见配置项</h3>\n<ol>\n<li><strong>testEnvironment</strong>\n<ul>\n<li>用于配置 Jest 的测试环境。例如，可以设置为 <code>jsdom</code> 来模拟浏览器环境，或设置为 <code>node</code> 来使用 Node.js 环境。</li>\n<li>示例：<code>testEnvironment: \'jsdom\'</code></li>\n</ul>\n</li>\n<li><strong>moduleNameMapper</strong>\n<ul>\n<li>用于配置模块路径映射。当测试代码中使用了别名或需要模拟某些模块时，可以通过此配置进行映射。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-attr">moduleNameMapper</span>: {\n  <span class="hljs-string">&#x27;^@/(.*)$&#x27;</span>: <span class="hljs-string">&#x27;&lt;rootDir&gt;/src/$1&#x27;</span>,  <span class="hljs-comment">// 将 &#x27;@/&#x27; 映射到 &#x27;src/&#x27; 目录</span>\n  <span class="hljs-string">&#x27;\\\\.(css|less|scss|sass)$&#x27;</span>: <span class="hljs-string">&#x27;identity-obj-proxy&#x27;</span>,  <span class="hljs-comment">// 忽略 CSS 等文件的导入</span>\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>moduleFileExtensions</strong>\n<ul>\n<li>用于指定 Jest 查找测试文件时应该搜索的文件扩展名。</li>\n<li>示例：<code>moduleFileExtensions: [\'js\', \'jsx\', \'ts\', \'tsx\', \'json\', \'node\']</code></li>\n</ul>\n</li>\n<li><strong>transform</strong>\n<ul>\n<li>用于指定代码转译器。例如，可以使用 <code>babel-jest</code> 来处理通过 Babel 转换的代码，或使用 <code>ts-jest</code> 来处理 TypeScript 文件。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-attr">transform</span>: {\n  <span class="hljs-string">&#x27;^.+\\\\.js$&#x27;</span>: <span class="hljs-string">&#x27;babel-jest&#x27;</span>,\n  <span class="hljs-string">&#x27;.*\\\\.(vue)$&#x27;</span>: <span class="hljs-string">&#x27;vue-jest&#x27;</span>,  <span class="hljs-comment">// 处理 Vue 文件</span>\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>testMatch</strong>\n<ul>\n<li>用于指定 Jest 应该运行哪些测试文件。默认情况下，Jest 会查找以 <code>.test.js</code> 或 <code>.spec.js</code> 结尾的文件。</li>\n<li>示例：<code>testMatch: [\'**/__tests__/**  /*.[jt]s?(x)\', \'**/?(*.)+(spec|test).[jt]s?(x)\']</code></li>\n</ul>\n</li>\n<li><strong>setupFilesAfterEnv</strong>\n<ul>\n<li>用于指定 Jest 在运行测试之前应该运行的文件。这些文件通常用于初始化测试环境，例如设置全局变量或加载第三方库。</li>\n<li>示例：<code>setupFilesAfterEnv: [\'&lt;rootDir&gt;/src/setupTests.js\']</code></li>\n</ul>\n</li>\n<li><strong>collectCoverage</strong>\n<ul>\n<li>用于启用代码覆盖率收集。启用后，Jest 会在测试完成后生成一个覆盖率报告。</li>\n<li>示例：<code>collectCoverage: true</code></li>\n</ul>\n</li>\n<li><strong>coverageThreshold</strong>\n<ul>\n<li>用于设置代码覆盖率的阈值。当覆盖率低于设定的阈值时，测试将失败。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-attr">coverageThreshold</span>: {\n  <span class="hljs-attr">global</span>: {\n    <span class="hljs-attr">branches</span>: <span class="hljs-number">90</span>,\n    <span class="hljs-attr">functions</span>: <span class="hljs-number">90</span>,\n    <span class="hljs-attr">lines</span>: <span class="hljs-number">90</span>,\n    <span class="hljs-attr">statements</span>: <span class="hljs-number">90</span>,\n  },\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>coverageDirectory</strong>\n<ul>\n<li>用于指定 Jest 输出覆盖率文件的目录。</li>\n<li>示例：<code>coverageDirectory: \'&lt;rootDir&gt;/coverage\'</code></li>\n</ul>\n</li>\n<li><strong>testPathIgnorePatterns</strong>\n<ul>\n<li>用于指定 Jest 应该忽略的测试文件或目录。</li>\n<li>示例：<code>testPathIgnorePatterns: [\'&lt;rootDir&gt;/node_modules/\']</code></li>\n</ul>\n</li>\n</ol>\n<h3>示例配置文件</h3>\n<p>以下是一个完整的 Jest 配置文件示例：</p>\n<pre><code class="language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">testEnvironment</span>: <span class="hljs-string">&#x27;jsdom&#x27;</span>,  <span class="hljs-comment">// 测试环境</span>\n  <span class="hljs-attr">moduleNameMapper</span>: {\n    <span class="hljs-string">&#x27;^@/(.*)$&#x27;</span>: <span class="hljs-string">&#x27;&lt;rootDir&gt;/src/$1&#x27;</span>,  <span class="hljs-comment">// 模块路径映射</span>\n    <span class="hljs-string">&#x27;\\\\.(css|less|scss|sass)$&#x27;</span>: <span class="hljs-string">&#x27;identity-obj-proxy&#x27;</span>,  <span class="hljs-comment">// 忽略 CSS 文件</span>\n  },\n  <span class="hljs-attr">moduleFileExtensions</span>: [<span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-string">&#x27;jsx&#x27;</span>, <span class="hljs-string">&#x27;ts&#x27;</span>, <span class="hljs-string">&#x27;tsx&#x27;</span>, <span class="hljs-string">&#x27;json&#x27;</span>, <span class="hljs-string">&#x27;node&#x27;</span>],  <span class="hljs-comment">// 文件扩展名</span>\n  <span class="hljs-attr">transform</span>: {\n    <span class="hljs-string">&#x27;^.+\\\\.js$&#x27;</span>: <span class="hljs-string">&#x27;babel-jest&#x27;</span>,  <span class="hljs-comment">// Babel 转译器</span>\n    <span class="hljs-string">&#x27;.*\\\\.(vue)$&#x27;</span>: <span class="hljs-string">&#x27;vue-jest&#x27;</span>,  <span class="hljs-comment">// Vue 文件转译器</span>\n  },\n  <span class="hljs-attr">testMatch</span>: [<span class="hljs-string">&#x27;**/__tests__/**  /*.[jt]s?(x)&#x27;</span>, <span class="hljs-string">&#x27;**/?(*.)+(spec|test).[jt]s?(x)&#x27;</span>],  <span class="hljs-comment">// 测试文件匹配规则</span>\n  <span class="hljs-attr">setupFilesAfterEnv</span>: [<span class="hljs-string">&#x27;&lt;rootDir&gt;/src/setupTests.js&#x27;</span>],  <span class="hljs-comment">// 测试前运行的文件</span>\n  <span class="hljs-attr">collectCoverage</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 启用代码覆盖率收集</span>\n  <span class="hljs-attr">coverageThreshold</span>: {\n    <span class="hljs-attr">global</span>: {\n      <span class="hljs-attr">branches</span>: <span class="hljs-number">90</span>,\n      <span class="hljs-attr">functions</span>: <span class="hljs-number">90</span>,\n      <span class="hljs-attr">lines</span>: <span class="hljs-number">90</span>,\n      <span class="hljs-attr">statements</span>: <span class="hljs-number">90</span>,\n    },\n  },\n  <span class="hljs-attr">coverageDirectory</span>: <span class="hljs-string">&#x27;&lt;rootDir&gt;/coverage&#x27;</span>,  <span class="hljs-comment">// 覆盖率文件输出目录</span>\n  <span class="hljs-attr">testPathIgnorePatterns</span>: [<span class="hljs-string">&#x27;&lt;rootDir&gt;/node_modules/&#x27;</span>],  <span class="hljs-comment">// 忽略的文件或目录</span>\n};\n</code></pre>\n<h3>运行测试</h3>\n<p>配置完成后，可以通过以下命令运行 Jest 测试：</p>\n<pre><code class="language-sh">npm <span class="hljs-built_in">test</span>\n</code></pre>\n<p>或者，如果全局安装了 Jest，可以直接运行：</p>\n<pre><code class="language-sh">jest\n</code></pre>\n<p>Jest 会自动查找项目中所有符合命名规则的测试用例文件，并执行其中的测试函数。测试结果会在终端中显示，包括每个测试用例的成功与否、执行时间等信息。</p>\n</div>'</script></body></html>