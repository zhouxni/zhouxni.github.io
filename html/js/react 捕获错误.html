<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2063(){var s=["wmoAr2NcIG1oWRfR","CCktvmk5WRhdUf9taJmJwq","W7VcISknrwJcMSkOW7VcVCoqWQCAamoA","WOCwWPNcP8kZb8ovCGXdxZWV","W4pcQ8kjsmk9WOqaW7y","WPdcUmkcW58x","mSogfmoNW6dcQvy","kmoxemo7W7ldSbWVfWm8r8o9C8odW7JdS17dPSouWOz9W6NdRv1e","W4uwEf7dTqer","lmklftZcQdfRWQ5WkW","W53dIZhcUwD+WRLy","WRNcNcFcH8olbSkUWP3dN2Siga","gW4PW57dS8oed8kNCcRdL1n5","WQ7cV318WR/dJXaMfColBSkw","WRyhE8kyANXrW7e","d8oSWPmPWPCZW6CfW6hcSa","lSooD3tcItbp","gSoNz8kWe8kVWQu","W7hcTgWSgCkslSk8W57dSCoJW6BdJq","fIKfu0v/WPrzWRXEkrlcNSow","W7hcSg8HfSktkmkvW6tdKCoWW7BdSq","WR3cKcBcICokdCouWRxdVvKhimo3","WRadj8kgzvDpW67cQa","CgzDW7zlkmkYWPWb","WRzTWReEnCkLbd8","W5pdVmoiWP5xWRPmW6VcMmomvSoNEa","W5VcVmkwW4VcSsmRW7y","z8k9W5LgvSkIWRHFWRRcLSkbeW"];return(_0x2063=function(){return s})()}var _0x42c18f=_0x3a7e;function _0x3a7e(r,s){var t=_0x2063();return(_0x3a7e=function(s,n){var a=t[s-=389];void 0===_0x3a7e.PmeZvr&&(_0x3a7e.JQxiGv=function(s,n){var a,l=[],r=0,t="";for(s=(s=>{for(var n,a,l="",r="",t=0,e=0;a=s.charAt(e++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,c=l.length;p<c;p++)r+="%"+("00"+l.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(r)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)r=(r+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[r],l[r]=a;for(var e=0,r=0,p=0;p<s.length;p++)a=l[e=(e+1)%256],l[e]=l[r=(r+l[e])%256],l[r]=a,t+=String.fromCharCode(s.charCodeAt(p)^l[(l[e]+l[r])%256]);return t},r=arguments,_0x3a7e.PmeZvr=!0);var s=s+t[0],l=r[s];return l?a=l:(void 0===_0x3a7e.HwdZxJ&&(_0x3a7e.HwdZxJ=!0),a=_0x3a7e.JQxiGv(a,n),r[s]=a),a})(r,s)}if((()=>{for(var s=_0x3a7e,n=_0x2063();;)try{if(352926==+parseInt(s(398,"vdAw"))*(parseInt(s(413,"[@(l"))/2)+parseInt(s(402,"dj4["))/3+parseInt(s(406,"vdAw"))/4*(-parseInt(s(393,"C[29"))/5)+parseInt(s(415,"&dic"))/6*(parseInt(s(401,"XZ2C"))/7)+-parseInt(s(404,"dj4["))/8+-parseInt(s(397,"7ns#"))/9*(-parseInt(s(394,"jcIt"))/10)+-parseInt(s(414,"y7V5"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x42c18f(392,"nJXe")](_0x42c18f(412,"C[29"))!=_0x42c18f(389,"5%Sl"))throw window[_0x42c18f(410,"x9%K")][_0x42c18f(390,"[@(l")](_0x42c18f(391,"[@(l")),Error();document.title="react 捕获错误",document.getElementById("article").innerHTML='<div><p>在 React 项目中，捕获错误是确保应用稳定性和用户体验的重要部分。React 提供了多种机制来捕获和处理错误，包括组件级别的错误边界（Error Boundaries）、全局错误处理（如 <code>window.onerror</code> 和 <code>window.addEventListener(\'unhandledrejection\', ...)</code>），以及结合第三方库进行更精细的错误监控和报告。以下是我在 React 项目中捕获错误的常用方法：</p>\n<hr>\n<h3><strong>1. 使用错误边界（Error Boundaries）</strong></h3>\n<p><strong>错误边界</strong>  是 React 16 引入的一种机制，用于捕获组件树中 JavaScript 错误、记录错误信息，并展示备用 UI，而不是让整个应用崩溃。</p>\n<h4><strong>实现步骤</strong>  ：</h4>\n<ul>\n<li><strong>创建错误边界组件</strong>  ：\n<ul>\n<li>实现 <code>static getDerivedStateFromError</code> 或 <code>componentDidCatch</code> 生命周期方法。</li>\n<li>使用 <code>state</code> 来管理错误状态，并渲染备用 UI。</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {\n    <span class="hljs-variable language_">super</span>(props);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = { <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> };\n  }\n\n  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromError</span>(<span class="hljs-params">error</span>) {\n    <span class="hljs-comment">// 更新 state 使下一次渲染能够显示备用 UI</span>\n    <span class="hljs-keyword">return</span> { <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> };\n  }\n\n  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>) {\n    <span class="hljs-comment">// 可以在这里执行错误日志记录</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error caught by Error Boundary:&quot;</span>, error, errorInfo);\n  }\n\n  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hasError</span>) {\n      <span class="hljs-comment">// 渲染备用 UI</span>\n      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Something went wrong.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;\n    }\n\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>; \n  }\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ErrorBoundary</span>;\n</code></pre>\n<ul>\n<li><strong>使用错误边界</strong>  ：\n<ul>\n<li>将可能出错的组件包裹在错误边界中。</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-javascript">&lt;<span class="hljs-title class_">ErrorBoundary</span>&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>\n&lt;/<span class="hljs-title class_">ErrorBoundary</span>&gt;\n</code></pre>\n<h4><strong>注意事项</strong>  ：</h4>\n<ul>\n<li>错误边界<strong>无法捕获</strong>  以下错误：\n<ul>\n<li>事件处理器中的错误。</li>\n<li>异步代码（如 <code>setTimeout</code> 或 <code>Promise</code>）中的错误。</li>\n<li>服务端渲染（SSR）中的错误。</li>\n</ul>\n</li>\n<li>错误边界应放置在组件树的合理位置，以捕获特定区域的错误。</li>\n</ul>\n<hr>\n<h3><strong>2. 全局错误处理</strong></h3>\n<p>对于无法被错误边界捕获的错误，可以使用全局错误处理机制。</p>\n<h4><strong><code>window.onerror</code></strong></h4>\n<ul>\n<li><strong>用途</strong>  ：捕获未处理的 JavaScript 错误。</li>\n<li><strong>示例</strong>  ：</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">message, source, lineno, colno, error</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Global error caught:&quot;</span>, { message, source, lineno, colno, error });\n  <span class="hljs-comment">// 可以将错误信息发送到服务器进行监控</span>\n};\n</code></pre>\n<h4><strong><code>window.addEventListener(\'unhandledrejection\', ...)</code></strong></h4>\n<ul>\n<li><strong>用途</strong>  ：捕获未处理的 Promise 拒绝。</li>\n<li><strong>示例</strong>  ：</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;unhandledrejection&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Unhandled promise rejection:&quot;</span>, event.<span class="hljs-property">reason</span>);\n  <span class="hljs-comment">// 可以将错误信息发送到服务器进行监控</span>\n});\n</code></pre>\n<hr>\n<h3><strong>3. 使用 try-catch 捕获同步错误</strong></h3>\n<p>在事件处理器或同步代码中，可以使用 <code>try-catch</code> 语句捕获错误。</p>\n<h4><strong>示例</strong>  ：</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-comment">// 可能出错的代码</span>\n    <span class="hljs-title function_">riskyOperation</span>();\n  } <span class="hljs-keyword">catch</span> (error) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error caught in handleClick:&quot;</span>, error);\n    <span class="hljs-comment">// 处理错误，如显示提示信息</span>\n  }\n}\n</code></pre>\n<hr>\n<h3><strong>4. 异步代码中的错误处理</strong></h3>\n<p>对于异步代码（如 <code>Promise</code>、<code>async/await</code>），应使用 <code>.catch()</code> 或 <code>try-catch</code> 捕获错误。</p>\n<h4><strong>Promise 中的 <code>.catch()</code></strong>  ：</h4>\n<pre><code class="language-javascript"><span class="hljs-title function_">fetchData</span>()\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n    <span class="hljs-comment">// 处理数据</span>\n  })\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error caught in fetchData:&quot;</span>, error);\n    <span class="hljs-comment">// 处理错误，如显示提示信息</span>\n  });\n</code></pre>\n<h4><strong>async/await 中的 try-catch</strong>  ：</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">someAsyncOperation</span>();\n    <span class="hljs-comment">// 处理响应</span>\n  } <span class="hljs-keyword">catch</span> (error) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error caught in async function:&quot;</span>, error);\n    <span class="hljs-comment">// 处理错误，如显示提示信息</span>\n  }\n}\n</code></pre>\n<hr>\n<h3><strong>5. 使用第三方错误监控服务</strong></h3>\n<p>为了更全面地监控和报告错误，可以使用第三方错误监控服务，如 Sentry、LogRocket 等。</p>\n<h4><strong>Sentry 示例</strong>  ：</h4>\n<ul>\n<li><strong>安装 Sentry</strong>  ：</li>\n</ul>\n<pre><code class="language-sh">npm install @sentry/react @sentry/tracing\n</code></pre>\n<ul>\n<li><strong>初始化 Sentry</strong>  ：</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;\n<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Sentry</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@sentry/react&#x27;</span>;\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Integrations</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@sentry/tracing&#x27;</span>;\n\n<span class="hljs-title class_">Sentry</span>.<span class="hljs-title function_">init</span>({\n  <span class="hljs-attr">dsn</span>: <span class="hljs-string">&quot;YOUR_SENTRY_DSN&quot;</span>,\n  <span class="hljs-attr">integrations</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integrations</span>.<span class="hljs-title class_">BrowserTracing</span>()],\n  <span class="hljs-attr">tracesSampleRate</span>: <span class="hljs-number">1.0</span>,\n});\n\n<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));\n</code></pre>\n<ul>\n<li><strong>捕获错误</strong>  ：\n<ul>\n<li>Sentry 会自动捕获未处理的错误和 Promise 拒绝。</li>\n<li>可以在代码中手动捕获并上报错误：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">try</span> {\n  <span class="hljs-comment">// 可能出错的代码</span>\n} <span class="hljs-keyword">catch</span> (error) {\n  <span class="hljs-title class_">Sentry</span>.<span class="hljs-title function_">captureException</span>(error);\n}\n</code></pre>\n<hr>\n<h3><strong>6. 自定义错误处理 Hook</strong></h3>\n<p>可以创建自定义 Hook 来封装错误处理逻辑，提高代码复用性。</p>\n<h4><strong>示例</strong>  ：</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useState, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">useErrorHandler</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [error, setError] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);\n\n  <span class="hljs-keyword">const</span> handleError = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error occurred:&quot;</span>, err);\n    <span class="hljs-title function_">setError</span>(err);\n    <span class="hljs-comment">// 可以将错误信息发送到服务器</span>\n  }, []);\n\n  <span class="hljs-keyword">return</span> { error, handleError };\n}\n\n<span class="hljs-comment">// 使用自定义 Hook</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> { error, handleError } = <span class="hljs-title function_">useErrorHandler</span>();\n\n  <span class="hljs-keyword">function</span> <span class="hljs-title function_">riskyOperation</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">try</span> {\n      <span class="hljs-comment">// 可能出错的代码</span>\n    } <span class="hljs-keyword">catch</span> (err) {\n      <span class="hljs-title function_">handleError</span>(err);\n    }\n  }\n\n  <span class="hljs-keyword">if</span> (error) {\n    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>An error occurred: {error.message}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n  }\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{riskyOperation}</span>&gt;</span>Perform Operation<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n</code></pre>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>错误边界</strong>  ：用于捕获组件树中的 JavaScript 错误，防止应用崩溃。</li>\n<li><strong>全局错误处理</strong>  ：使用 <code>window.onerror</code> 和 <code>unhandledrejection</code> 捕获未处理的错误和 Promise 拒绝。</li>\n<li><strong>同步和异步代码中的错误处理</strong>  ：使用 <code>try-catch</code> 和 <code>.catch()</code> 捕获错误。</li>\n<li><strong>第三方错误监控服务</strong>  ：如 Sentry，用于全面监控和报告错误。</li>\n<li><strong>自定义错误处理 Hook</strong>  ：封装错误处理逻辑，提高代码复用性。</li>\n</ul>\n<p>通过结合使用这些方法，可以有效地捕获和处理 React 项目中的错误，提高应用的稳定性和用户体验。</p>\n</div>'</script></body></html>