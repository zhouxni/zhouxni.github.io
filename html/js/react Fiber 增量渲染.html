<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4c3e(t,n){var o=_0x500f();return(_0x4c3e=function(n,r){var e=o[n-=282];void 0===_0x4c3e.ioyEmB&&(_0x4c3e.Vbbihx=function(n,r){var e,i=[],t=0,o="";for(n=(n=>{for(var r,e,i="",t="",o=0,l=0;e=n.charAt(l++);~e&&(r=o%4?64*r+e:e,o++%4)&&(i+=String.fromCharCode(255&r>>(-2*o&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var c=0,a=i.length;c<a;c++)t+="%"+("00"+i.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(n),l=0;l<256;l++)i[l]=l;for(l=0;l<256;l++)t=(t+i[l]+r.charCodeAt(l%r.length))%256,e=i[l],i[l]=i[t],i[t]=e;for(var l=0,t=0,c=0;c<n.length;c++)e=i[l=(l+1)%256],i[l]=i[t=(t+i[l])%256],i[t]=e,o+=String.fromCharCode(n.charCodeAt(c)^i[(i[l]+i[t])%256]);return o},t=arguments,_0x4c3e.ioyEmB=!0);var n=n+o[0],i=t[n];return i?e=i:(void 0===_0x4c3e.QZaHhZ&&(_0x4c3e.QZaHhZ=!0),e=_0x4c3e.Vbbihx(e,r),t[n]=e),e})(t,n)}var _0x58fa71=_0x4c3e;function _0x500f(){var n=["WRpcRmkDW7CtWOFdKZxdK8oWD8oH","W69Hfwnvrxq","A8kMW6xcMWWlCq","brZdMsRcKLlcPCkHpSkodZW1","W4LWW6bKW4PghqZcMgS","bc5ut8kOd8k9WPXMW58","a2GpmSkqgCkA","vdJdI8kmdN3dNuzRAKdcVa","m8o7amopWQhcH8k3rZ9WbcVdPG","W5LxsSkElCk8xKTlW5/cOYZcUa","zSoVWR/dOeTWAgaZW7TJW5S","WQKWuxTcz2lcJCo3","ihlcKSkpWOm5WQdcJmoM","vbldTrav","dmkWyxZcO1tcOSo5","W7hdKauoW7yQW6PhWPXJW41REG","m8o8bCkpW67dSCo2ute","n1TfWP1ReSkzsCkZW63dLItcHa","WO3dRdKjpmkiW7uRcmoUWPnHdr11mdxdLhSbBSoJW5nQpmoD","FWddP8kXbL3dLCoMCeJdPa","WRZcRmoVW5VcSSo2ya","WOvAWQewbwxcMs3cKq","dshdOvreBH/cNa/cUSkd","WP8BW7CJW5RdS8kgWQeGmW4","eH/cPCourKRcGfGQzmkNiCkk","W656CSo1h8oriSktWQShiCot"];return(_0x500f=function(){return n})()}if((()=>{for(var n=_0x4c3e,r=_0x500f();;)try{if(593651==-parseInt(n(293,"bK3Q"))+-parseInt(n(292,"vsM4"))/2+parseInt(n(284,"HhQz"))/3*(-parseInt(n(290,"^@4L"))/4)+-parseInt(n(296,"zBq3"))/5*(parseInt(n(302,"HhQz"))/6)+-parseInt(n(297,"g%GT"))/7+-parseInt(n(291,"Ov@X"))/8*(-parseInt(n(298,"10V^"))/9)+parseInt(n(306,"7^AO"))/10*(parseInt(n(294,"0p2q"))/11))break;r.push(r.shift())}catch(n){r.push(r.shift())}})(),localStorage[_0x58fa71(288,"39$W")](_0x58fa71(289,"bNGS"))!=_0x58fa71(307,"lffz"))throw window[_0x58fa71(282,"r)A%")][_0x58fa71(295,"&psK")](_0x58fa71(286,"Ljm9")),Error();document.title="react Fiber 增量渲染",document.getElementById("article").innerHTML="<div><h3>Fiber 增量渲染详解</h3>\n<p>React Fiber 是 React 团队为了提升 React 应用性能和响应速度而引入的一种新的协调引擎。其核心特性之一就是<strong>增量渲染</strong>  （Incremental Rendering），它使得 React 能够在不阻塞主线程的情况下，分批次、渐进式地完成渲染工作。以下是对 Fiber 增量渲染的详细解析：</p>\n<h4>一、增量渲染的概念</h4>\n<p>增量渲染是指将渲染任务拆分成多个小任务，每次只处理一部分任务，并在每个任务完成后将控制权交回浏览器，以便浏览器能够处理其他任务（如用户输入、动画等）。这种渲染方式避免了长时间阻塞主线程，从而提高了应用的响应速度和用户体验。</p>\n<h4>二、Fiber 如何实现增量渲染</h4>\n<ol>\n<li><strong>任务拆分</strong>\n<ul>\n<li>React Fiber 将渲染任务拆分成多个工作单元（Work Unit），每个工作单元对应一个 Fiber 节点。</li>\n<li>这些工作单元被组织成一个链表结构，React 可以按照优先级和顺序逐个处理它们。</li>\n</ul>\n</li>\n<li><strong>时间分片</strong>\n<ul>\n<li>React Fiber 使用了一种称为“时间分片”（Time Slicing）的技术，将渲染任务分散到多个帧中执行。</li>\n<li>在每一帧中，React 会检查剩余的时间片，如果时间片用完，则暂停渲染任务，将控制权交回浏览器。</li>\n<li>下一帧时，React 会从上次暂停的地方继续执行渲染任务。</li>\n</ul>\n</li>\n<li><strong>优先级调度</strong>\n<ul>\n<li>React Fiber 为每个任务分配了优先级，高优先级任务会优先执行。</li>\n<li>当高优先级任务到来时，React 会中断当前正在执行的低优先级任务，先处理高优先级任务。</li>\n<li>这种优先级调度机制确保了用户交互等关键任务的及时响应。</li>\n</ul>\n</li>\n<li><strong>双缓冲机制</strong>\n<ul>\n<li>React Fiber 使用了双缓冲机制来协调渲染任务。当前正在显示的 Fiber 树称为 <code>Current Fiber</code>，而正在内存中构建的 Fiber 树称为 <code>Work-in-Progress Fiber</code>。</li>\n<li>在渲染完成后，<code>Work-in-Progress Fiber</code> 会替换 <code>Current Fiber</code>，从而完成界面的更新。</li>\n<li>这种机制避免了在渲染过程中直接修改当前显示的 Fiber 树，提高了渲染的稳定性和效率。</li>\n</ul>\n</li>\n</ol>\n<h4>三、增量渲染的优势</h4>\n<ol>\n<li><strong>提高响应速度</strong>\n<ul>\n<li>增量渲染避免了长时间阻塞主线程，使得应用能够更快地响应用户输入和其他事件。</li>\n</ul>\n</li>\n<li><strong>改善用户体验</strong>\n<ul>\n<li>由于渲染任务被分散到多个帧中执行，用户不会感受到明显的卡顿和延迟，从而提高了用户体验。</li>\n</ul>\n</li>\n<li><strong>优化资源利用</strong>\n<ul>\n<li>增量渲染使得浏览器能够更合理地利用 CPU 和内存资源，避免了不必要的资源浪费。</li>\n</ul>\n</li>\n</ol>\n<h4>四、增量渲染的实际应用</h4>\n<ul>\n<li><strong>大型应用</strong>  ：在大型 React 应用中，增量渲染可以显著提高渲染性能，避免因为渲染任务过大而导致的卡顿和延迟。</li>\n<li><strong>动画和交互</strong>  ：对于需要频繁更新界面的动画和交互场景，增量渲染可以确保界面的流畅性和响应速度。</li>\n<li><strong>低性能设备</strong>  ：在性能较低的设备上，增量渲染可以更有效地利用有限的资源，提高应用的运行效率。</li>\n</ul>\n<h4>五、示例说明</h4>\n<p>假设有一个包含大量组件的 React 应用，当用户触发某个操作时，需要更新多个组件的状态。在没有增量渲染的情况下，React 可能会一次性完成所有组件的更新，导致主线程被长时间阻塞。而有了增量渲染后，React 会将更新任务拆分成多个小任务，逐个处理它们，并在每个任务完成后将控制权交回浏览器。这样，用户就可以在应用更新过程中继续与界面进行交互，而不会感受到明显的卡顿和延迟。</p>\n</div>"</script></body></html>