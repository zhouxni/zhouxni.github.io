<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x7bbc(o,n){var l=_0x3c92();return(_0x7bbc=function(n,s){var t=l[n-=181];void 0===_0x7bbc.bnibyN&&(_0x7bbc.YyXHTd=function(n,s){var t,r=[],o=0,l="";for(n=(n=>{for(var s,t,r="",o="",l=0,a=0;t=n.charAt(a++);~t&&(s=l%4?64*s+t:t,l++%4)&&(r+=String.fromCharCode(255&s>>(-2*l&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var c=0,g=r.length;c<g;c++)o+="%"+("00"+r.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(o)})(n),a=0;a<256;a++)r[a]=a;for(a=0;a<256;a++)o=(o+r[a]+s.charCodeAt(a%s.length))%256,t=r[a],r[a]=r[o],r[o]=t;for(var a=0,o=0,c=0;c<n.length;c++)t=r[a=(a+1)%256],r[a]=r[o=(o+r[a])%256],r[o]=t,l+=String.fromCharCode(n.charCodeAt(c)^r[(r[a]+r[o])%256]);return l},o=arguments,_0x7bbc.bnibyN=!0);var n=n+l[0],r=o[n];return r?t=r:(void 0===_0x7bbc.HnzjQu&&(_0x7bbc.HnzjQu=!0),t=_0x7bbc.YyXHTd(t,s),o[n]=t),t})(o,n)}var _0x470c54=_0x7bbc;function _0x3c92(){var n=["WOJcSmkWW5PRWQORWPHgWRddSCoNufa","WQtdImo+ptnTjSkAWQO","AWyxaJFdJgqHia","W4tcNCoNWQlcUSolWPGC","W4BcNvvAsSkuWPO","xSklW5BcJmoFWRyMWOjFWQqv","W4pdTgXmumkCWRxcQG","aZpdSmoPW6JcMsK1g8kRda","atlcPCkWWQxcQqmG","WQpdH8o/qJ1Un8kgWQGl","DSkLWO/dU8kkcmkfBNa","W4tdV3Tew8kKWP7cKq","yCkRd8o4W4rFCW","hJq7fYZdLNG","mSo3W4/dNmkeoSkw","geTYW7uZW6nvW6C","nqpcI8k2W6OqWQyohhtcUSog","ySkBWPObW6ZcSSozW6VdOCkfC8koW60","v8odW41plmkEW59NW4VdUa","vSkmW5ZcI8oDW7DcWObUWOumW5jd","WOVdIhBdSJvFpCoX","D8kLWOFcG8oqAmkysN1gg8kp","vSo4tmogdCklcbaJEJm","pN7dLCofwc7dNmoNW6nmWQO","W7G/g8kcWOTxW4lcPGZcVmocWPhdRmk9","hqldTSkGWOJdUZdcN8oYWQtcPYmv","WR08EXCXW4RdV2S","EsHictHnpZpcP8kKfZG3","cSklW6bslIJcIqWgW4VdGgKUDIqvWOpdHmoCBmk6WPGQkCo0Fa","W4fusqddPa"];return(_0x3c92=function(){return n})()}if((()=>{for(var n=_0x7bbc,s=_0x3c92();;)try{if(384685==-parseInt(n(188,"(J[U"))*(parseInt(n(205,"U74J"))/2)+parseInt(n(194,"pHV1"))/3*(parseInt(n(191,"#Iu6"))/4)+-parseInt(n(206,"rB(5"))/5+parseInt(n(190,"qB4J"))/6*(parseInt(n(208,"!W]R"))/7)+-parseInt(n(192,"rB(5"))/8*(parseInt(n(198,"#Iu6"))/9)+parseInt(n(204,"0L[y"))/10*(-parseInt(n(202,"HcEy"))/11)+parseInt(n(181,"z%B&"))/12)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x470c54(199,"^gkF")](_0x470c54(189,"iKg#"))!=_0x470c54(186,"!9BF"))throw window[_0x470c54(207,"cxKo")][_0x470c54(201,"!W]R")](_0x470c54(185,"6Due")),Error();document.title="SVG 为什么不失真",document.getElementById("article").innerHTML='<div><p>SVG（可缩放矢量图形，Scalable Vector Graphics）之所以不失真，主要归因于其基于<strong>矢量图形</strong>  的本质，而非传统的基于像素的位图图像。以下是详细解释：</p>\n<hr>\n<h3><strong>1. 矢量图形的本质</strong></h3>\n<ul>\n<li><strong>数学描述</strong>  ：<br>\nSVG图形由数学公式（如点、线、曲线、形状）定义，而非像素网格。例如，一个圆形可以用中心点和半径描述，矩形用位置和尺寸描述。\n<ul>\n<li><strong>示例</strong>  ：一个SVG圆定义为 <code>&lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot;/&gt;</code>，无论放大多少倍，始终保持完美圆形。</li>\n</ul>\n</li>\n<li><strong>分辨率无关</strong>  ：<br>\n由于基于数学公式，SVG图形与分辨率无关。放大或缩小时，浏览器重新计算图形的数学描述并重新渲染，而非拉伸像素。</li>\n</ul>\n<hr>\n<h3><strong>2. 与位图图像的对比</strong></h3>\n<ul>\n<li><strong>位图图像（如JPEG、PNG）</strong>  ：<br>\n由固定数量的像素组成。放大时，像素被拉伸，导致模糊或锯齿（失真）。\n<ul>\n<li><strong>示例</strong>  ：一张100x100像素的图片放大到200x200像素时，每个像素被放大为4个像素，细节丢失。</li>\n</ul>\n</li>\n<li><strong>SVG的优势</strong>  ：<br>\n无论放大到何种尺寸，SVG始终根据数学公式重新绘制，保持清晰锐利。</li>\n</ul>\n<hr>\n<h3><strong>3. 渲染机制</strong></h3>\n<ul>\n<li><strong>动态渲染</strong>  ：<br>\n浏览器在渲染SVG时，根据当前视口大小和缩放比例实时计算图形的形状和位置。\n<ul>\n<li><strong>示例</strong>  ：在网页中缩放SVG图形时，浏览器会重新计算每个路径和形状的坐标，确保平滑显示。</li>\n</ul>\n</li>\n<li><strong>硬件加速</strong>  ：<br>\n现代浏览器利用GPU加速SVG渲染，进一步提升性能和缩放效果。</li>\n</ul>\n<hr>\n<h3><strong>4. 文件结构</strong></h3>\n<ul>\n<li><strong>XML格式</strong>  ：<br>\nSVG文件是文本文件，包含XML标签描述图形元素（如<code>&lt;path&gt;</code>、<code>&lt;rect&gt;</code>、<code>&lt;circle&gt;</code>）。\n<ul>\n<li><strong>示例</strong>  ：以下SVG代码定义了一个简单的红色圆形：<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;40&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;red&quot;</span>/&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>\n</code></pre>\n</li>\n<li>放大或缩小时，浏览器解析这些标签并重新计算渲染。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>5. 实际应用场景</strong></h3>\n<ul>\n<li><strong>图标和Logo</strong>  ：<br>\nSVG图标可无损缩放到任意尺寸，适合响应式设计。</li>\n<li><strong>数据可视化</strong>  ：<br>\n图表和地图使用SVG可保持缩放时的清晰度。</li>\n<li><strong>动画和交互</strong>  ：<br>\nSVG支持CSS和JavaScript动画，且缩放时动画效果依然平滑。</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>SVG不失真的核心原因是其<strong>基于数学公式的矢量描述</strong>  ，而非像素网格。这种特性使得SVG图形在任意缩放比例下都能保持清晰锐利，非常适合需要高分辨率和动态缩放的场景。</p>\n</div>'</script></body></html>