<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3fc635=_0x4e5b;if((()=>{for(var s=_0x4e5b,n=_0x5866();;)try{if(823674==-parseInt(s(187,"[7Wh"))+-parseInt(s(186,"DJ6a"))/2+parseInt(s(181,"zx&%"))/3*(parseInt(s(166,"tn[("))/4)+parseInt(s(180,"*pQ*"))/5*(-parseInt(s(165,"CFv["))/6)+parseInt(s(168,"Kz^V"))/7+parseInt(s(172,"a!Uk"))/8+parseInt(s(176,"tn[("))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3fc635(184,"uvZ5")](_0x3fc635(185,"uvZ5"))!=_0x3fc635(182,"NxHo"))throw window[_0x3fc635(178,"P4c7")][_0x3fc635(179,"bB@R")](_0x3fc635(177,"qIJl")),Error();function _0x4e5b(l,s){var e=_0x5866();return(_0x4e5b=function(s,n){var a=e[s-=165];void 0===_0x4e5b.WbNckg&&(_0x4e5b.wVFCPj=function(s,n){var a,t=[],l=0,e="";for(s=(s=>{for(var n,a,t="",l="",e=0,c=0;a=s.charAt(c++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,p=t.length;o<p;o++)l+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)l=(l+t[c]+n.charCodeAt(c%n.length))%256,a=t[c],t[c]=t[l],t[l]=a;for(var c=0,l=0,o=0;o<s.length;o++)a=t[c=(c+1)%256],t[c]=t[l=(l+t[c])%256],t[l]=a,e+=String.fromCharCode(s.charCodeAt(o)^t[(t[c]+t[l])%256]);return e},l=arguments,_0x4e5b.WbNckg=!0);var s=s+e[0],t=l[s];return t?a=t:(void 0===_0x4e5b.KINalZ&&(_0x4e5b.KINalZ=!0),a=_0x4e5b.wVFCPj(a,n),l[s]=a),a})(l,s)}function _0x5866(){var s=["WPLUpGGdWRhcIrTLfSkPW71DdG","W6/dJ8khqSkmbI3cI8k4W4maWPZcUq","nmkQW5Pub8kdW7m","CLFdRgfov2hdStZdQmkqoJrS","W5RcQ8o7W6jVwCoZfCo9ysW","W6/dGCkdimoMxwNcL8kI","WQJcT8o/wepcOSktimoyb2hdQLa","W48TjCozeGWgW5zObGzMWQC","xc3dS15mW7lcLCkOW5ZdKSk8yZCNEx0+WPJcK8oDhglcM8oVWP44","WO3dVmoqWRKEWQVdTmop","WPJdJufjW7OeW60","B8oZW59+W6JcUaDmW5GGW7aREW","wCkFW53dISofWRVdGSkRWOZdVq4","WPNdPSk+WQeI","cCoYWP7cPsldRKnrtqRdOui","xWZdNmkNWRDYDq","EqRdI8klWRbKu8oeCa","W5ZcQCkxWQWzWQekWOiWWRGwcq0","hmosl24kWODaFmk4WRhdGmoP","eCoCWQykFmkOySoTBrLcWRBcOW","kCoUW5/dO8oVW7KQ","W4KOjmk6EffcW4TP","W7NdOmo8ECkAr8kibqVcTSoSt8oA","jcaCgKT3CsBcMqqLnSki"];return(_0x5866=function(){return s})()}document.title="React 18 通过 执行上下文标记（ExecutionContext） 和 调度器（Scheduler）的协作 来判断当前批处理是处于同步代码还是异步代码环境",document.getElementById("article").innerHTML='<div><p>React 18 通过 <strong>执行上下文标记（ExecutionContext）</strong>   和 <strong>调度器（Scheduler）的协作</strong>   来判断当前批处理是处于同步代码还是异步代码环境。以下是其核心实现原理：</p>\n<hr>\n<h3>一、同步 vs 异步的判定机制</h3>\n<h4>1. <strong>执行上下文标记（ExecutionContext）</strong></h4>\n<p>React 内部维护一个二进制位掩码 <code>executionContext</code>，用于标记当前代码的执行环境：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ExecutionContext</span> = <span class="hljs-built_in">number</span>;\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">NoContext</span> = <span class="hljs-number">0b000</span>; <span class="hljs-comment">// 默认状态</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">BatchedContext</span> = <span class="hljs-number">0b001</span>; <span class="hljs-comment">// 批处理上下文（同步）</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">RenderContext</span> = <span class="hljs-number">0b010</span>; <span class="hljs-comment">// 渲染阶段</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">CommitContext</span> = <span class="hljs-number">0b100</span>; <span class="hljs-comment">// 提交阶段</span>\n</code></pre>\n<ul>\n<li><strong>同步代码检测</strong>  ：<br>\n当 React 事件系统触发回调（如 <code>onClick</code>）时，会先设置 <code>executionContext |= BatchedContext</code>，标记当前为同步批处理环境：<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">batchedUpdates</span>(<span class="hljs-params">fn</span>) {\n  <span class="hljs-keyword">const</span> prevContext = executionContext;\n  executionContext |= <span class="hljs-title class_">BatchedContext</span>; <span class="hljs-comment">// 标记同步批处理</span>\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 执行回调（如 onClick）</span>\n  } <span class="hljs-keyword">finally</span> {\n    executionContext = prevContext;\n    <span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span>) {\n      <span class="hljs-title function_">flushSyncCallbacks</span>(); <span class="hljs-comment">// 同步代码结束，处理队列</span>\n    }\n  }\n}\n</code></pre>\n</li>\n<li><strong>异步代码检测</strong>  ：<br>\n如果 <code>setState</code> 执行时 <code>executionContext</code> 不包含 <code>BatchedContext</code>，则判定为异步环境（如 <code>setTimeout</code>、<code>Promise</code>）。</li>\n</ul>\n<h4>2. <strong>调度器的优先级标记</strong></h4>\n<ul>\n<li>所有更新（无论同步/异步）都会被分配一个 <strong>优先级（lane）</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">SyncLane</span> = <span class="hljs-number">0b0001</span>; <span class="hljs-comment">// 同步优先级（如事件回调）</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">InputContinuousLane</span> = <span class="hljs-number">0b0010</span>; <span class="hljs-comment">// 连续输入（如onScroll）</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">DefaultLane</span> = <span class="hljs-number">0b0100</span>; <span class="hljs-comment">// 默认异步优先级</span>\n</code></pre>\n</li>\n<li>调度器根据优先级判断更新来源：\n<ul>\n<li><strong>同步优先级（SyncLane）</strong>   → 同步代码</li>\n<li><strong>默认优先级（DefaultLane）</strong>   → 异步代码</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>二、不同场景的具体判定</h3>\n<h4>1. <strong>同步代码（如 <code>onClick</code>）</strong></h4>\n<ul>\n<li><strong>标记流程</strong>  ：\n<ol>\n<li>React 事件系统调用 <code>batchedUpdates</code>，设置 <code>BatchedContext</code>。</li>\n<li>同步代码中的 <code>setState</code> 检测到 <code>BatchedContext</code>，加入 <strong>同步批处理队列</strong>  。</li>\n<li>同步代码执行完毕，清除 <code>BatchedContext</code>，统一处理队列。</li>\n</ol>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-jsx">onClick = <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// executionContext |= BatchedContext</span>\n  <span class="hljs-title function_">setState</span>({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> }); <span class="hljs-comment">// 同步批处理</span>\n  <span class="hljs-title function_">setState</span>({ <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> }); <span class="hljs-comment">// 同步批处理</span>\n  <span class="hljs-comment">// executionContext 恢复，触发合并渲染</span>\n};\n</code></pre>\n</li>\n</ul>\n<h4>2. <strong>微任务（如 <code>Promise.then</code>）</strong></h4>\n<ul>\n<li><strong>标记流程</strong>  ：\n<ol>\n<li>微任务回调执行时，<code>executionContext</code> 为 <code>NoContext</code>（无同步标记）。</li>\n<li>React 通过 <code>queueMicrotask</code> 或劫持 <code>Promise.then</code> 捕获微任务边界。</li>\n<li>微任务中的 <code>setState</code> 被分配 <code>DefaultLane</code>，加入 <strong>微任务队列</strong>  。</li>\n</ol>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-jsx">onClick = <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-comment">// executionContext === NoContext</span>\n    <span class="hljs-title function_">setState</span>({ <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> }); <span class="hljs-comment">// 微任务队列</span>\n    <span class="hljs-title function_">setState</span>({ <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> }); <span class="hljs-comment">// 微任务队列</span>\n  });\n};\n</code></pre>\n</li>\n</ul>\n<h4>3. <strong>宏任务（如 <code>setTimeout</code>）</strong></h4>\n<ul>\n<li><strong>判定逻辑</strong>  ：\n<ol>\n<li>宏任务回调执行时，<code>executionContext</code> 为 <code>NoContext</code>。</li>\n<li>调度器通过时间戳判断当前属于新的宏任务周期。</li>\n<li><code>setState</code> 被分配 <code>DefaultLane</code>，加入 <strong>全局异步队列</strong>  。</li>\n</ol>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-jsx"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// executionContext === NoContext</span>\n  <span class="hljs-title function_">setState</span>({ <span class="hljs-attr">c</span>: <span class="hljs-number">1</span> }); <span class="hljs-comment">// 宏任务队列</span>\n  <span class="hljs-title function_">setState</span>({ <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> }); <span class="hljs-comment">// 宏任务队列</span>\n}, <span class="hljs-number">0</span>);\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>三、关键代码实现</h3>\n<h4>1. 判断同步/异步的核心函数</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">requestUpdateLane</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> ((executionContext &amp; <span class="hljs-title class_">BatchedContext</span>) !== <span class="hljs-title class_">NoContext</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">SyncLane</span>; <span class="hljs-comment">// 同步代码</span>\n  }\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">getCurrentPriorityLevel</span>(); <span class="hljs-comment">// 异步代码（返回 DefaultLane 等）</span>\n}\n</code></pre>\n<h4>2. 微任务劫持（示例）</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> originalPromiseThen = <span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span>;\n<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled</span>) {\n  <span class="hljs-keyword">if</span> (isInsideMicrotask) <span class="hljs-keyword">return</span> originalPromiseThen.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, onFulfilled);\n  \n  isInsideMicrotask = <span class="hljs-literal">true</span>;\n  <span class="hljs-keyword">return</span> originalPromiseThen.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-title function_">onFulfilled</span>();\n    isInsideMicrotask = <span class="hljs-literal">false</span>;\n    <span class="hljs-title function_">flushMicrotasks</span>(); <span class="hljs-comment">// 处理微任务队列</span>\n  });\n};\n</code></pre>\n<hr>\n<h3>四、与 React 17 的差异</h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th>React 17</th>\n<th>React 18</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>同步检测</strong></td>\n<td>仅依赖 <code>isBatchingUpdates</code> 布尔值</td>\n<td>使用 <code>executionContext</code> 位掩码</td>\n</tr>\n<tr>\n<td><strong>异步处理</strong></td>\n<td>不区分微任务/宏任务</td>\n<td>通过调度器精确识别微任务边界</td>\n</tr>\n<tr>\n<td><strong>优先级控制</strong></td>\n<td>无</td>\n<td>基于 <code>lane</code> 的优先级调度</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>五、开发者注意事项</h3>\n<ol>\n<li><strong>避免跨环境状态依赖</strong><br>\n同步和异步代码中的 <code>setState</code> 可能分属不同渲染周期：<pre><code class="language-jsx"><span class="hljs-comment">// ❌ 可能触发2次渲染</span>\n<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> }); <span class="hljs-comment">// 同步</span>\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setState</span>({ <span class="hljs-attr">y</span>: <span class="hljs-number">1</span> }), <span class="hljs-number">0</span>); <span class="hljs-comment">// 宏任务</span>\n\n<span class="hljs-comment">// ✅ 统一环境</span>\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">setState</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> });\n  <span class="hljs-title function_">setState</span>({ <span class="hljs-attr">y</span>: <span class="hljs-number">1</span> }); <span class="hljs-comment">// 合并为1次</span>\n}, <span class="hljs-number">0</span>);\n</code></pre>\n</li>\n<li><strong>强制同步行为</strong><br>\n使用 <code>flushSync</code> 可临时退出批处理：<pre><code class="language-javascript"><span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setState</span>({ <span class="hljs-attr">z</span>: <span class="hljs-number">1</span> })); <span class="hljs-comment">// 立即渲染</span>\n</code></pre>\n</li>\n</ol>\n<hr>\n<h3>六、总结</h3>\n<p>React 18 通过 <strong>执行上下文标记 + 优先级调度 + 微任务劫持</strong>   三重机制，精准判断代码的同步/异步环境：</p>\n<ol>\n<li><strong>同步代码</strong>  ：通过 <code>BatchedContext</code> 标记，合并到同步队列。</li>\n<li><strong>异步代码</strong>  ：根据 <code>lane</code> 优先级和微任务边界，分配到不同队列。</li>\n<li><strong>渲染优化</strong>  ：最终合并为最少次数的渲染，兼顾性能与一致性。</li>\n</ol>\n</div>'</script></body></html>