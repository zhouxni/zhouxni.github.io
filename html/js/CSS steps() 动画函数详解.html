<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x169b84=_0x449d;function _0x2c88(){var s=["FXtdIZnjWQH5v1ZcTYBdR8oR","smkGlSkiAGNcVmkynItdOrO","W5RcPN3cQ8o1WQZdMSojWPhcGCo6","tx1TWOmTBmoUW5C","WQBdLuiNB8kBW7yCgmkGWQu5","WRpdMH7dUcSIrmkdWQxcNmk1WQm","pSoTW4POvmklWQi","WRhcTtJdLrNcUfa","WPDAW5ldKSo1tK1nW6m","cSkAWPhdJvNcPNJdTx3cPSo4Eq","W6uNWQdcGSkjoZe","WPNcTCkzW5f8W7fxyCoPW5jQW4m","EcfYfGBdM1Tau3BcHCoZ","WRaAWOtcTsFcImojWQ8m","DSoQybaoWPRcG8oBWPO","W5NcR3RcQCoXW4ZdKCoNWOJcKSoOWPK","E8oQW7H8DmksWOu","WQxdNeuLA8o7W70YaCkZWRC","smkGkCkdBq3cVCk4nctdSWy","n8k8WQNdQ18","kmkCoZ/dPvZdR8okWPv7W51E","od/cPXxcR2RdQeTqvJ7cKbq3r218W7tdUCkcb8kiimkFhJ8","WQ9wWQnHBhrpW5BdHWmeqSou","WQRdRSkOWPisdMBcUSkbW7ixW5S"];return(_0x2c88=function(){return s})()}function _0x449d(l,s){var e=_0x2c88();return(_0x449d=function(s,n){var a=e[s-=251];void 0===_0x449d.REoRLa&&(_0x449d.zRSzVc=function(s,n){var a,t=[],l=0,e="";for(s=(s=>{for(var n,a,t="",l="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=t.length;c<r;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)l=(l+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[l],t[l]=a;for(var p=0,l=0,c=0;c<s.length;c++)a=t[p=(p+1)%256],t[p]=t[l=(l+t[p])%256],t[l]=a,e+=String.fromCharCode(s.charCodeAt(c)^t[(t[p]+t[l])%256]);return e},l=arguments,_0x449d.REoRLa=!0);var s=s+e[0],t=l[s];return t?a=t:(void 0===_0x449d.cvOpfJ&&(_0x449d.cvOpfJ=!0),a=_0x449d.zRSzVc(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x449d,n=_0x2c88();;)try{if(259129==-parseInt(s(269,"k%fQ"))+parseInt(s(267,"4Alg"))/2+-parseInt(s(258,"ApZw"))/3+parseInt(s(266,"ki@N"))/4*(parseInt(s(262,"#iSC"))/5)+parseInt(s(261,"Rg$)"))/6+parseInt(s(255,"B6lZ"))/7*(-parseInt(s(264,"wl^L"))/8)+parseInt(s(273,"n[8a"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x169b84(259,"5Ed6")](_0x169b84(257,"K%Je"))!=_0x169b84(268,"xfmT"))throw window[_0x169b84(252,"f[QX")][_0x169b84(265,"B6lZ")](_0x169b84(270,"DgS!")),Error();document.title="CSS steps() 动画函数详解",document.getElementById("article").innerHTML='<div><p><code>steps()</code> 是 CSS 动画中一种特殊的时序函数，它可以让动画以离散的步进方式运行，而不是默认的平滑过渡。</p>\n<h2>基本语法</h2>\n<pre><code class="language-css"><span class="hljs-attribute">animation-timing-function</span>: <span class="hljs-built_in">steps</span>(n, [start|end]);\n</code></pre>\n<ul>\n<li><strong>n</strong>  ：正整数，表示动画被分成多少步</li>\n<li><strong>start</strong>  /<strong>end</strong>  （可选）：指定每一步变化发生在步进的开始还是结束（默认为 <code>end</code>）</li>\n</ul>\n<h2>参数详解</h2>\n<h3>1. 步数 (n)</h3>\n<p>定义动画被分成多少等份。例如：</p>\n<pre><code class="language-css"><span class="hljs-comment">/* 动画分4步完成 */</span>\n<span class="hljs-attribute">animation-timing-function</span>: <span class="hljs-built_in">steps</span>(<span class="hljs-number">4</span>);\n</code></pre>\n<h3>2. 方向 (start/end)</h3>\n<ul>\n<li><strong>end</strong>  （默认值）：变化发生在每一步的结束</li>\n<li><strong>start</strong>  ：变化发生在每一步的开始</li>\n</ul>\n<pre><code class="language-css"><span class="hljs-comment">/* 4步，每步开始时变化 */</span>\n<span class="hljs-attribute">animation-timing-function</span>: <span class="hljs-built_in">steps</span>(<span class="hljs-number">4</span>, start);\n\n<span class="hljs-comment">/* 4步，每步结束时变化（默认） */</span>\n<span class="hljs-attribute">animation-timing-function</span>: <span class="hljs-built_in">steps</span>(<span class="hljs-number">4</span>, end);\n</code></pre>\n<h2>视觉差异</h2>\n<p>假设我们有一个从左到右移动的动画：</p>\n<ul>\n<li><strong>steps(4, end)</strong>  ：元素会在每25%时间点结束时&quot;跳跃&quot;到新位置</li>\n<li><strong>steps(4, start)</strong>  ：元素会在每25%时间点开始时立即&quot;跳跃&quot;到新位置</li>\n</ul>\n<h2>实际应用示例</h2>\n<h3>1. 帧动画（精灵图）</h3>\n<pre><code class="language-css"><span class="hljs-selector-class">.sprite</span> {\n  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;\n  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;\n  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;sprite-sheet.png&#x27;</span>);\n  <span class="hljs-attribute">animation</span>: play <span class="hljs-number">1s</span> <span class="hljs-built_in">steps</span>(<span class="hljs-number">6</span>) infinite;\n}\n\n<span class="hljs-keyword">@keyframes</span> play {\n  <span class="hljs-selector-tag">from</span> { <span class="hljs-attribute">background-position</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>; }\n  <span class="hljs-selector-tag">to</span> { <span class="hljs-attribute">background-position</span>: -<span class="hljs-number">600px</span> <span class="hljs-number">0</span>; }\n}\n</code></pre>\n<h3>2. 打字机效果</h3>\n<pre><code class="language-css"><span class="hljs-selector-class">.typewriter</span> {\n  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">overflow</span>: hidden;\n  <span class="hljs-attribute">white-space</span>: nowrap;\n  <span class="hljs-attribute">animation</span>: typing <span class="hljs-number">4s</span> <span class="hljs-built_in">steps</span>(<span class="hljs-number">40</span>) forwards;\n}\n\n<span class="hljs-keyword">@keyframes</span> typing {\n  <span class="hljs-selector-tag">from</span> { <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span> }\n  <span class="hljs-selector-tag">to</span> { <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span> }\n}\n</code></pre>\n<h3>3. 加载指示器</h3>\n<pre><code class="language-css"><span class="hljs-selector-class">.loader</span> {\n  <span class="hljs-attribute">width</span>: <span class="hljs-number">0%</span>;\n  <span class="hljs-attribute">height</span>: <span class="hljs-number">5px</span>;\n  <span class="hljs-attribute">background</span>: blue;\n  <span class="hljs-attribute">animation</span>: loading <span class="hljs-number">2s</span> <span class="hljs-built_in">steps</span>(<span class="hljs-number">10</span>) infinite;\n}\n\n<span class="hljs-keyword">@keyframes</span> loading {\n  <span class="hljs-selector-tag">from</span> { <span class="hljs-attribute">width</span>: <span class="hljs-number">0%</span> }\n  <span class="hljs-selector-tag">to</span> { <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span> }\n}\n</code></pre>\n<h2>注意事项</h2>\n<ol>\n<li><code>steps()</code> 只能用于 <code>animation-timing-function</code>，不能用于 <code>transition-timing-function</code></li>\n<li>步数必须为正整数</li>\n<li>与 <code>cubic-bezier()</code> 不同，<code>steps()</code> 创建的是离散的、非连续的动画效果</li>\n<li>对于复杂的步进动画，可能需要精确计算关键帧位置</li>\n</ol>\n<h2>简写形式</h2>\n<p>在 <code>animation</code> 简写属性中使用：</p>\n<pre><code class="language-css"><span class="hljs-selector-class">.element</span> {\n  <span class="hljs-attribute">animation</span>: move <span class="hljs-number">2s</span> <span class="hljs-built_in">steps</span>(<span class="hljs-number">5</span>, start) infinite;\n}\n</code></pre>\n<p><code>steps()</code> 函数为创建特定类型的动画效果提供了强大的控制能力，特别是需要精确控制动画节奏或创建帧动画时非常有用。</p>\n</div>'</script></body></html>