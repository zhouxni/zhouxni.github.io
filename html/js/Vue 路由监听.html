<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x471d(p,s){var t=_0x80c5();return(_0x471d=function(s,n){var a=t[s-=417];void 0===_0x471d.hSHRbt&&(_0x471d.iXucWS=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,c=0;a=s.charAt(c++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,o=l.length;e<o;e++)p+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(p)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)p=(p+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[p],l[p]=a;for(var c=0,p=0,e=0;e<s.length;e++)a=l[c=(c+1)%256],l[c]=l[p=(p+l[c])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(e)^l[(l[c]+l[p])%256]);return t},p=arguments,_0x471d.hSHRbt=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x471d.pciXWR&&(_0x471d.pciXWR=!0),a=_0x471d.iXucWS(a,n),p[s]=a),a})(p,s)}var _0x7c9b44=_0x471d;if((()=>{for(var s=_0x471d,n=_0x80c5();;)try{if(903972==+parseInt(s(428,"Sdty"))*(-parseInt(s(417,"N6e3"))/2)+parseInt(s(421,"Xbek"))/3*(-parseInt(s(436,"2Np3"))/4)+-parseInt(s(424,"1WWt"))/5+parseInt(s(427,"khV9"))/6+parseInt(s(420,"oZ6H"))/7*(-parseInt(s(446,"[tjl"))/8)+-parseInt(s(425,"2Np3"))/9*(-parseInt(s(435,"mThE"))/10)+-parseInt(s(445,"xxCh"))/11*(-parseInt(s(430,"$6R)"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x7c9b44(443,"(JeR")](_0x7c9b44(418,"@ZJ3"))!=_0x7c9b44(440,"xxCh"))throw window[_0x7c9b44(433,"(JeR")][_0x7c9b44(432,"I5P$")](_0x7c9b44(437,"[tjl")),Error();function _0x80c5(){var s=["vH/cLrvskmopW7qna8oBqdy","de7dRSogWPGHgq","WPtdHqldMKOGW6xdUq","W7/cHaVdQ2XaW4XA","W7BcR8kpqbNdP8oZEW","dIZcTSoOWRmnWRldJNmrWQTk","qCkOoqyzW5W7W47cR8oDWRDnW7XyyXHPoSkfWOvKycNcNCk2W5K","c8k+e1ddHexcSSo2B1VcGCkBAG","tdJcJZVcI8kjW47cSIvtlCoOcq","W6hcPtddSmob","WQ1JCmonjSoMWO4","ed/dUWxdHcbxBCk1WOeUW6S","WP/dJXxdSKOSW6C","W7bGgtztWRtdPx8","WQNdO3tcS8kbW7ldUCkjWQzWAWHh","gmoUDufyWPvAWOpcL8o2WPe","WO/cHSkWWRFcKLuWamogqCkGWRBdVa","lqmSrSo/WQW7ra8","bdJcNvVcNXlcL8k5gSkCWQ7cSNe","Ch3dSXxdH8k2WQ96WOJdKW","eCkvWQpcLftdSCoxW70","BSoDDhCmW5OeWRu","Emo5W6NcUI/dUCkvW7jLfcq","cZtcKvhcKbdcKSk3fmkXWQtcMM0","csZcTSoTWRqmW5NdShOgWR96qq","sH/cRCkBWRqxdHxcOSog","cSk4hfJdI0FcSColw0FcICkrBq","D086qCk9gXW","ACoFdIrYWRLZWR3dLCoGW4nAWOC","eXecaL3dSZGQ"];return(_0x80c5=function(){return s})()}document.title="Vue 路由监听",document.getElementById("article").innerHTML='<div><p>在 Vue.js 中，你可以通过几种方式来监听路由变化。以下是常用的方法：</p>\n<h2>1. 使用 <code>watch</code> 监听 <code>$route</code> 对象</h2>\n<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">watch</span>: {\n    <span class="hljs-string">&#x27;$route&#x27;</span>(to, <span class="hljs-keyword">from</span>) {\n      <span class="hljs-comment">// to: 目标路由对象</span>\n      <span class="hljs-comment">// from: 当前路由对象</span>\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;路由从&#x27;</span>, <span class="hljs-keyword">from</span>.<span class="hljs-property">path</span>, <span class="hljs-string">&#x27;变化到&#x27;</span>, to.<span class="hljs-property">path</span>)\n    }\n  }\n}\n\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">watch</span>: {\n    <span class="hljs-attr">$route</span>: {\n      <span class="hljs-title function_">handler</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;路由从&#x27;</span>, <span class="hljs-keyword">from</span>.<span class="hljs-property">path</span>, <span class="hljs-string">&#x27;变化到&#x27;</span>, to.<span class="hljs-property">path</span>)\n      },\n      <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否在初始化时立即执行一次</span>\n      <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>       <span class="hljs-comment">// 是否深度监听（适用于嵌套路由）</span>\n    }\n  }\n}\n</code></pre>\n<h2>2. 使用导航守卫</h2>\n<p>Vue Router 提供了几种导航守卫：</p>\n<h3>全局前置守卫</h3>\n<pre><code class="language-javascript">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> {\n  <span class="hljs-comment">// 必须调用 next() 才能继续路由跳转</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;全局前置守卫&quot;</span>);\n  <span class="hljs-title function_">next</span>();\n});\n</code></pre>\n<h3>全局解析守卫</h3>\n<pre><code class="language-javascript">router.<span class="hljs-title function_">beforeResolve</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> {\n  <span class="hljs-comment">// 在所有组件内守卫和异步路由组件被解析之后调用</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;全局解析守卫&quot;</span>);\n  <span class="hljs-title function_">next</span>();\n});\n</code></pre>\n<h3>全局后置钩子</h3>\n<pre><code class="language-javascript">router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> {\n  <span class="hljs-comment">// 没有 next 函数，不会影响导航</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;全局后置钩子&quot;</span>);\n});\n</code></pre>\n<h3>路由独享守卫</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>({\n  <span class="hljs-attr">routes</span>: [\n    {\n      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/foo&quot;</span>,\n      <span class="hljs-attr">component</span>: <span class="hljs-title class_">Foo</span>,\n      <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> {\n        <span class="hljs-comment">// 只对这个路由生效</span>\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;路由独享守卫&quot;</span>);\n        <span class="hljs-title function_">next</span>();\n      },\n    },\n  ],\n});\n</code></pre>\n<h3>组件内守卫</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) {\n    <span class="hljs-comment">// 在渲染该组件的对应路由被 confirm 前调用</span>\n    <span class="hljs-comment">// 不能获取组件实例 `this`</span>\n    <span class="hljs-title function_">next</span>(<span class="hljs-function">(<span class="hljs-params">vm</span>) =&gt;</span> {\n      <span class="hljs-comment">// 通过 `vm` 访问组件实例</span>\n    });\n  },\n  <span class="hljs-title function_">beforeRouteUpdate</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) {\n    <span class="hljs-comment">// 在当前路由改变，但是该组件被复用时调用</span>\n    <span class="hljs-comment">// 可以访问组件实例 `this`</span>\n    <span class="hljs-title function_">next</span>();\n  },\n  <span class="hljs-title function_">beforeRouteLeave</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) {\n    <span class="hljs-comment">// 导航离开该组件的对应路由时调用</span>\n    <span class="hljs-comment">// 可以访问组件实例 `this`</span>\n    <span class="hljs-title function_">next</span>();\n  },\n};\n</code></pre>\n<h2>3. 使用 <code>onReady</code> 和 <code>onError</code></h2>\n<pre><code class="language-javascript">router.<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;路由初始化完成&quot;</span>);\n});\n\nrouter.<span class="hljs-title function_">onError</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;路由错误:&quot;</span>, error);\n});\n</code></pre>\n<h2>4. 使用 Vue Router 4.x 的组合式 API</h2>\n<p>在 Vue 3 和 Vue Router 4 中，可以使用组合式 API：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { watch } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n<span class="hljs-keyword">import</span> { useRoute } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>();\n\n    <span class="hljs-title function_">watch</span>(\n      <span class="hljs-function">() =&gt;</span> route.<span class="hljs-property">path</span>,\n      <span class="hljs-function">(<span class="hljs-params">newPath, oldPath</span>) =&gt;</span> {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;路由路径从&quot;</span>, oldPath, <span class="hljs-string">&quot;变化到&quot;</span>, newPath);\n      },\n    );\n  },\n};\n</code></pre>\n<p>选择哪种方式取决于你的具体需求：</p>\n<ul>\n<li>简单的路由变化监听可以使用 <code>watch</code></li>\n<li>需要控制导航流程使用导航守卫</li>\n<li>全局逻辑使用全局守卫</li>\n<li>特定路由逻辑使用路由独享守卫</li>\n<li>组件特定逻辑使用组件内守卫</li>\n</ul>\n</div>'</script></body></html>