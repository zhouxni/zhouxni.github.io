<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x255c15=_0xce05;function _0x55d1(){var n=["bGxcO3b9BCk1BMq","WPnODmoSW5qCEKG/W7JcJsPa","W7dcNCkju8kjWPS1W7VdPmkQW6nVALC","jt/dOSkEomoWWOm1EwFdJuFcTIy","iZD+os/dRMG","ytvuWOX8W4JdHbqttSoZWOJcGW","W5JcGmkBwmkxms81W7S","mrtcHJ3dQmkPcSkOW4C","wN3dRwhcNdub","W5NdL8kGpSk+omkoWQi","WRnCEtWbWQj8W6D3WRBcJmo8WPq","ESo9zSk/DmkZutJdNJ3cO8kJymk8WOlcPmkIW67cGL7dG8k8W7xdIdmh","W41Mv8o2WO7dQCk8WPhdGvy","vCouW5NdNCk9mZvU","jhxcUSktWOXjW6BcGSorncnDW4K","WOdcUsO5WPO","j8k6k8o5D8oAouhdRGy","WPNcGSkOfmkjeSkJ","heJcLKmaW6dcHMZdR3RdUmoqWQK","W4iGsfSEW7CK","fuBcNuyiW6lcJuNdMwBdV8osWRy","WPGnwgKMW7aOWPy","DxzcWOpcP8oAWOJdRG5Y","WRnDEJ8iWQj7W65pWOhcGmofWOi","W7JcUSkJW7xdV8kxW6eIdmorudP3","jZ/dQSkDDmktW71qBgu","ltNdP8ooCCk6W6j/vG","WOXJi8kIe3RcPCkSwq"];return(_0x55d1=function(){return n})()}function _0xce05(s,n){var c=_0x55d1();return(_0xce05=function(n,l){var o=c[n-=478];void 0===_0xce05.PdVdkf&&(_0xce05.PnTabU=function(n,l){var o,i=[],s=0,c="";for(n=(n=>{for(var l,o,i="",s="",c=0,t=0;o=n.charAt(t++);~o&&(l=c%4?64*l+o:o,c++%4)&&(i+=String.fromCharCode(255&l>>(-2*c&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var r=0,e=i.length;r<e;r++)s+="%"+("00"+i.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(s)})(n),t=0;t<256;t++)i[t]=t;for(t=0;t<256;t++)s=(s+i[t]+l.charCodeAt(t%l.length))%256,o=i[t],i[t]=i[s],i[s]=o;for(var t=0,s=0,r=0;r<n.length;r++)o=i[t=(t+1)%256],i[t]=i[s=(s+i[t])%256],i[s]=o,c+=String.fromCharCode(n.charCodeAt(r)^i[(i[t]+i[s])%256]);return c},s=arguments,_0xce05.PdVdkf=!0);var n=n+c[0],i=s[n];return i?o=i:(void 0===_0xce05.svifYD&&(_0xce05.svifYD=!0),o=_0xce05.PnTabU(o,l),s[n]=o),o})(s,n)}if((()=>{for(var n=_0xce05,l=_0x55d1();;)try{if(814254==-parseInt(n(485,"g5Vt"))*(-parseInt(n(497,"s)sJ"))/2)+parseInt(n(484,"oaRR"))/3*(-parseInt(n(479,"eSAc"))/4)+parseInt(n(480,"v5sL"))/5+-parseInt(n(504,"K0YI"))/6*(parseInt(n(488,"GM!Z"))/7)+parseInt(n(486,"o*Mq"))/8+-parseInt(n(490,"UVt$"))/9+-parseInt(n(498,"IYN9"))/10*(parseInt(n(505,"9#zp"))/11))break;l.push(l.shift())}catch(n){l.push(l.shift())}})(),localStorage[_0x255c15(489,"Khq#")](_0x255c15(492,"moht"))!=_0x255c15(500,"w#s)"))throw window[_0x255c15(478,"K0YI")][_0x255c15(502,"r!U^")](_0x255c15(496,"]cT%")),Error();document.title="js 栈和堆",document.getElementById("article").innerHTML='<div><p>在 JavaScript 中，内存管理是一个重要的概念，其中“栈”和“堆”是两种基本的内存分配方式。理解栈和堆的工作机制对于掌握 JavaScript 的执行过程和性能优化非常有帮助。</p>\n<h3>栈（Stack）</h3>\n<ol>\n<li><strong>定义</strong>  ：\n<ul>\n<li>栈是一种后进先出（LIFO, Last In First Out）的数据结构。</li>\n<li>在 JavaScript 中，栈用于存储原始值（如 <code>number</code>、<code>boolean</code>、<code>undefined</code>、<code>null</code>）和引用（指向堆中对象的地址）。</li>\n</ul>\n</li>\n<li><strong>用途</strong>  ：\n<ul>\n<li>栈主要用于存储函数调用（执行上下文）和局部变量。</li>\n<li>每当一个函数被调用时，一个新的执行上下文（包括函数参数、局部变量等）会被压入栈中。</li>\n<li>当函数执行完毕后，其执行上下文会被弹出栈，释放内存。</li>\n</ul>\n</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li>栈的大小是有限的，通常由操作系统决定。</li>\n<li>栈内存的分配和释放非常快速，因为它们是顺序进行的。</li>\n<li>栈溢出（Stack Overflow）通常是由于递归调用过深或函数调用过多导致的。</li>\n</ul>\n</li>\n</ol>\n<h3>堆（Heap）</h3>\n<ol>\n<li><strong>定义</strong>  ：\n<ul>\n<li>堆是一种用于动态分配内存的区域。</li>\n<li>在 JavaScript 中，堆用于存储对象（包括数组和函数对象）以及它们的属性。</li>\n</ul>\n</li>\n<li><strong>用途</strong>  ：\n<ul>\n<li>堆内存用于存储引用类型的数据，如对象字面量、数组、函数等。</li>\n<li>堆中的对象可以通过栈中的引用来访问。</li>\n</ul>\n</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li>堆的大小通常比栈大得多，但分配和释放内存的速度相对较慢。</li>\n<li>堆内存的管理更加复杂，因为对象可以动态地分配和释放，且对象之间可能存在引用关系。</li>\n<li>垃圾回收机制（Garbage Collection）主要用于回收堆中不再使用的内存，以防止内存泄漏。</li>\n</ul>\n</li>\n</ol>\n<h3>栈和堆的区别</h3>\n<ol>\n<li><strong>内存分配方式</strong>  ：\n<ul>\n<li>栈内存是自动分配的，当函数调用时分配，函数执行完毕后释放。</li>\n<li>堆内存是动态分配的，需要显式地通过代码（如使用 <code>new</code> 关键字）来分配，并由垃圾回收机制自动回收。</li>\n</ul>\n</li>\n<li><strong>存储内容</strong>  ：\n<ul>\n<li>栈主要存储原始值和引用。</li>\n<li>堆主要存储对象和数组等复杂数据结构。</li>\n</ul>\n</li>\n<li><strong>访问速度</strong>  ：\n<ul>\n<li>栈内存的访问速度比堆内存快，因为栈内存的分配和释放是顺序进行的，且栈的大小有限。</li>\n<li>堆内存的访问速度相对较慢，因为堆中的对象可能分散在内存的不同位置，且需要处理对象的引用关系。</li>\n</ul>\n</li>\n<li><strong>内存管理</strong>  ：\n<ul>\n<li>栈内存的管理由操作系统自动进行，开发者无需关心。</li>\n<li>堆内存的管理需要垃圾回收机制的参与，开发者需要注意避免内存泄漏和不必要的内存分配。</li>\n</ul>\n</li>\n</ol>\n<h3>示例</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>; <span class="hljs-comment">// 原始值，存储在栈中</span>\n    <span class="hljs-keyword">let</span> b = { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> }; <span class="hljs-comment">// 对象，存储在堆中，引用存储在栈中</span>\n}\n\n<span class="hljs-title function_">foo</span>();\n</code></pre>\n<p>在这个示例中，变量 <code>a</code> 是一个原始值，直接存储在栈中。变量 <code>b</code> 是一个对象，存储在堆中，而栈中存储的是指向该对象的引用。当函数 <code>foo</code> 执行完毕后，栈中的变量 <code>a</code> 和 <code>b</code>（引用）会被弹出栈，而堆中的对象（如果没有其他引用）则会被垃圾回收机制回收。</p>\n</div>'</script></body></html>