<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x260fee=_0x9114;function _0x492b(){var s=["W43dHvSzW6C","CmoVlSkjdmkyrHy","mbVcKmk4WRKeuNyKW4FcV8oaWPm","WQpcHCoTWRJcPd/cOW8OASoVW5u","nYpdQd4FWRpdICoL","fCo3wCkeWQZcK1lcMCoOWRq","qSkUWONcMmoQC8o/W6yypLu","smkPWOtcN8oLl8k6W4yVaLLWlW","ymonW5NcQw5gyCot","W7BdP0P9hmocsSoyusJdKCoI","umorsmoTW50eFCoOWPe","D1hdSmkDhbtdVGaHva","WPRcGX/dRIeoga","WQBcHmoOWR7cOJZdPYSlzSoOW5zn","CCkmW5zBWPhcSCkamCk9W5ddO8kl","W4mGBKqhqSok","ncBdSYi7WOVdV8oH","c8k/dCkxkhfahrqqWRBdGCkxW44Svhm9W4ZdSalcOL14qCoc","W4zyW7NdHCkrlLPMD8obWOGesa","WP3dJSoEWO3dNH3dMmon","euDkuqi3d8ovWQBdJCoca8kT","W4z5WRpcKCk8u8kUW5G/ESkDnG","e8o/x8kcW5pdLcJcSmoTWRZdV8oqW78","aGqiivLGlmk1WOqtWPm","WRDsB3xdNSkhda","CCoTwmo3xmoTjI7dM1OcWPRdPa","WOxcItqyeSoiW7S","gLldTmoza0RdKaCpW7OVyt4"];return(_0x492b=function(){return s})()}function _0x9114(o,s){var e=_0x492b();return(_0x9114=function(s,n){var a=e[s-=355];void 0===_0x9114.dCtkTt&&(_0x9114.deDSmw=function(s,n){var a,l=[],o=0,e="";for(s=(s=>{for(var n,a,l="",o="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,t=l.length;c<t;c++)o+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(o)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)o=(o+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[o],l[o]=a;for(var p=0,o=0,c=0;c<s.length;c++)a=l[p=(p+1)%256],l[p]=l[o=(o+l[p])%256],l[o]=a,e+=String.fromCharCode(s.charCodeAt(c)^l[(l[p]+l[o])%256]);return e},o=arguments,_0x9114.dCtkTt=!0);var s=s+e[0],l=o[s];return l?a=l:(void 0===_0x9114.aSGDUj&&(_0x9114.aSGDUj=!0),a=_0x9114.deDSmw(a,n),o[s]=a),a})(o,s)}if((()=>{for(var s=_0x9114,n=_0x492b();;)try{if(449641==-parseInt(s(363,"hKcU"))*(parseInt(s(376,"ei#&"))/2)+-parseInt(s(371,"IZv#"))/3*(parseInt(s(360,"DHdc"))/4)+-parseInt(s(366,"Kh6i"))/5+parseInt(s(358,"M5(q"))/6*(parseInt(s(357,"ecv%"))/7)+-parseInt(s(369,"ND3B"))/8+-parseInt(s(374,"6lsu"))/9+parseInt(s(372,"@1ab"))/10*(parseInt(s(373,"6lsu"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x260fee(379,"%!W&")](_0x260fee(377,"qBH4"))!=_0x260fee(367,"Je2o"))throw window[_0x260fee(375,"J5S*")][_0x260fee(365,"@5yV")](_0x260fee(356,"zb%E")),Error();document.title="内置 Symbols",document.getElementById("article").innerHTML='<div><p>JavaScript 中的内置 Symbols 是一种特殊类型的属性键，用于为对象定义一些内置的、不可枚举的行为或特性。它们以 <code>Symbol</code> 对象的形式存在，并且每个 Symbol 值都是唯一的，即使它们的描述相同。内置 Symbols 提供了一种机制，让开发者可以在不污染对象本身属性命名空间的情况下，为对象添加特殊行为。</p>\n<p>以下是一些常用的内置 Symbols 及其用途：</p>\n<hr>\n<h3>1. <strong><code>Symbol.iterator</code></strong></h3>\n<ul>\n<li><strong>用途</strong>  ：使对象可迭代（如 <code>for...of</code> 循环）。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> myIterable = {\n  *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() {\n    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;\n    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;\n    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;\n  }\n};\n\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> myIterable) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 输出: 1, 2, 3</span>\n}\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>2. <strong><code>Symbol.asyncIterator</code></strong></h3>\n<ul>\n<li><strong>用途</strong>  ：使对象可异步迭代（如 <code>for await...of</code> 循环）。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> myAsyncIterable = {\n  <span class="hljs-keyword">async</span> *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]() {\n    <span class="hljs-keyword">yield</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);\n    <span class="hljs-keyword">yield</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);\n    <span class="hljs-keyword">yield</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);\n  }\n};\n\n(<span class="hljs-title function_">async</span> () =&gt; {\n  <span class="hljs-keyword">for</span> <span class="hljs-title function_">await</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> myAsyncIterable) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 输出: 1, 2, 3</span>\n  }\n})();\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>3. <strong><code>Symbol.toPrimitive</code></strong></h3>\n<ul>\n<li><strong>用途</strong>  ：定义对象在转换为原始值时的行为。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = {\n  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toPrimitive</span>](hint) {\n    <span class="hljs-keyword">if</span> (hint === <span class="hljs-string">&#x27;number&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;\n    <span class="hljs-keyword">if</span> (hint === <span class="hljs-string">&#x27;string&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello&#x27;</span>;\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;\n  }\n};\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+obj);    <span class="hljs-comment">// 输出: 42 （转换为数字）</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${obj}</span>`</span>); <span class="hljs-comment">// 输出: &quot;hello&quot; （转换为字符串）</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>4. <strong><code>Symbol.toStringTag</code></strong></h3>\n<ul>\n<li><strong>用途</strong>  ：自定义 <code>Object.prototype.toString</code> 的返回值。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {\n  get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]() {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;MyClass&#x27;</span>;\n  }\n}\n\n<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(instance)); <span class="hljs-comment">// 输出: &quot;[object MyClass]&quot;</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>5. <strong><code>Symbol.hasInstance</code></strong></h3>\n<ul>\n<li><strong>用途</strong>  ：自定义 <code>instanceof</code> 操作符的行为。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> {\n  <span class="hljs-keyword">static</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>](instance) {\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(instance);\n  }\n}\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyArray</span>); <span class="hljs-comment">// 输出: true</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>({} <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyArray</span>); <span class="hljs-comment">// 输出: false</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>6. <strong><code>Symbol.isConcatSpreadable</code></strong></h3>\n<ul>\n<li><strong>用途</strong>  ：控制数组在 <code>concat</code> 方法中的展开行为。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> arrayLike = { <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>, <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>]: <span class="hljs-literal">true</span> };\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([].<span class="hljs-title function_">concat</span>(arrayLike)); <span class="hljs-comment">// 输出: [&#x27;a&#x27;, &#x27;b&#x27;]</span>\n\n<span class="hljs-keyword">const</span> nonSpreadable = { <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>, <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>]: <span class="hljs-literal">false</span> };\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([].<span class="hljs-title function_">concat</span>(nonSpreadable)); <span class="hljs-comment">// 输出: [{ length: 2, 0: &#x27;a&#x27;, 1: &#x27;b&#x27;, ... }]</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>7. <strong><code>Symbol.species</code></strong></h3>\n<ul>\n<li><strong>用途</strong>  ：用于返回构造函数的默认种类，通常用于继承类中的方法（如 <code>map</code>、<code>filter</code> 等）。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> {\n  <span class="hljs-keyword">static</span> get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">species</span>]() {\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>; <span class="hljs-comment">// 返回原生的 Array 而不是 MyArray</span>\n  }\n}\n\n<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArray</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);\n<span class="hljs-keyword">const</span> mapped = instance.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>);\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mapped <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyArray</span>); <span class="hljs-comment">// 输出: false</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mapped <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>);   <span class="hljs-comment">// 输出: true</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>8. <strong><code>Symbol.toPrimitive</code>（细化）</strong></h3>\n<ul>\n<li><strong>补充</strong>  ：当需要处理更复杂的转换逻辑时，可以基于 <code>hint</code> 参数实现不同的行为。</li>\n<li><strong>常见 <code>hint</code> 值</strong>  ：\n<ul>\n<li><code>&quot;string&quot;</code>：当对象需要被转换为字符串时（如 <code>String(obj)</code>）。</li>\n<li><code>&quot;number&quot;</code>：当对象需要被转换为数字时（如 <code>+obj</code>）。</li>\n<li><code>&quot;default&quot;</code>：当没有明确提示时（如 <code>==</code> 运算）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>9. <strong><code>Symbol.unscopables</code></strong></h3>\n<ul>\n<li><strong>用途</strong>  ：定义在使用 <code>with</code> 语句时哪些属性是不可用的。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = {\n  <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,\n  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">unscopables</span>]: {\n    <span class="hljs-attr">foo</span>: <span class="hljs-literal">true</span>\n  }\n};\n\n<span class="hljs-title function_">with</span> (obj) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo); <span class="hljs-comment">// 报错：foo 不可用</span>\n}\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>10. <strong><code>Symbol.match</code>、<code>Symbol.replace</code>、<code>Symbol.search</code>、<code>Symbol.split</code></strong></h3>\n<ul>\n<li><strong>用途</strong>  ：为字符串的正则表达式相关方法提供自定义行为。</li>\n<li><strong>示例</strong>  （<code>Symbol.match</code>）：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRegExp</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">pattern</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pattern</span> = pattern;\n  }\n\n  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">match</span>](str) {\n    <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">match</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">pattern</span>);\n  }\n}\n\n<span class="hljs-keyword">const</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRegExp</span>(<span class="hljs-regexp">/hello/</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>.<span class="hljs-title function_">match</span>(regex)); <span class="hljs-comment">// 输出: [&#x27;hello&#x27;]</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>11. <strong><code>Symbol.for</code> 和 <code>Symbol.keyFor</code></strong></h3>\n<ul>\n<li><strong><code>Symbol.for</code></strong>  ：创建一个全局共享的 Symbol（通过名称）。</li>\n<li><strong><code>Symbol.keyFor</code></strong>  ：获取全局 Symbol 的键名。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> sym1 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);\n<span class="hljs-keyword">const</span> sym2 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sym1 === sym2); <span class="hljs-comment">// 输出: true</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(sym1)); <span class="hljs-comment">// 输出: &#x27;foo&#x27;</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>总结</h3>\n<p>内置 Symbols 提供了一种强大的机制，用于扩展和自定义 JavaScript 对象的行为，而无需污染对象本身的属性命名空间。它们主要用于库和框架开发，以及需要高度自定义对象行为的场景。</p>\n<p><strong>注意事项</strong>  ：</p>\n<ul>\n<li>内置 Symbols 不会影响对象的常规属性访问。</li>\n<li>它们通常用于底层实现或框架开发，日常开发中较少直接使用。</li>\n<li>使用 <code>Symbol.for</code> 可以创建全局共享的 Symbol，而普通的 <code>Symbol</code> 是唯一的。</li>\n</ul>\n<p>希望这些信息对你理解 JavaScript 内置 Symbols 有所帮助！</p>\n</div>'</script></body></html>