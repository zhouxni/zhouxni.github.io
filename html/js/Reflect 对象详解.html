<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x411b(){var s=["hSoAE8o1W69gbsyT","WQXPcSk3WRDyW6VcGwvlW5WWW6O","WPBcP8koEufLW67cMmk5e1P7W4G","WQFcU8ofWP9Wbw4","W7JcKmoFWRDJd0q","W6b4csfLWPG9i8oQbhSQla","W7hdQCkdW64ZvdDBWQLnWPy/WQ0","WQJcTmojDmk0zmo1oCkzoJ8","WPO3xLeldSolWOHnDWW","WQWSWRFcJCknsuRdPSoqWOfLWP09","C8kqu8kLWRahW64","W6f5uKLbWRVcN33dIcy4aHa","W44DWOpdLCk4pmkdmG","n8kHBuNdRq","W5JcGCodbSkrWRxcOCo/WPtcLu7cVG","WPZdH8oTW7PagCk6l0bVW49kBMxdNJlcS8kjAwaNehxcISkbzq","WO8MWRZdV8kjdmk6BSkCF8ozWQlcPq","W6TnWOldJYbuWPn4hCkOwSoVlG","WQ7dR8ozW7hdVYJcRCk3W7iYWOip","pYNcSNxcUCkGWQqxxCkFWRTsfq","yWCNsSkFbL7cKHClW4tcTGi","WQpcKmkpWQhcQxtcHq"];return(_0x411b=function(){return s})()}var _0x410cd1=_0x5de3;function _0x5de3(e,s){var t=_0x411b();return(_0x5de3=function(s,n){var l=t[s-=303];void 0===_0x5de3.sAqcBE&&(_0x5de3.WbNDsZ=function(s,n){var l,a=[],e=0,t="";for(s=(s=>{for(var n,l,a="",e="",t=0,c=0;l=s.charAt(c++);~l&&(n=t%4?64*n+l:l,t++%4)&&(a+=String.fromCharCode(255&n>>(-2*t&6))))l="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(l);for(var o=0,p=a.length;o<p;o++)e+="%"+("00"+a.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(e)})(s),c=0;c<256;c++)a[c]=c;for(c=0;c<256;c++)e=(e+a[c]+n.charCodeAt(c%n.length))%256,l=a[c],a[c]=a[e],a[e]=l;for(var c=0,e=0,o=0;o<s.length;o++)l=a[c=(c+1)%256],a[c]=a[e=(e+a[c])%256],a[e]=l,t+=String.fromCharCode(s.charCodeAt(o)^a[(a[c]+a[e])%256]);return t},e=arguments,_0x5de3.sAqcBE=!0);var s=s+t[0],a=e[s];return a?l=a:(void 0===_0x5de3.yNDtSO&&(_0x5de3.yNDtSO=!0),l=_0x5de3.WbNDsZ(l,n),e[s]=l),l})(e,s)}if((()=>{for(var s=_0x5de3,n=_0x411b();;)try{if(347266==-parseInt(s(310,"e6#A"))+-parseInt(s(317,"]IOX"))/2*(parseInt(s(304,"bNJf"))/3)+parseInt(s(315,"Sw0O"))/4+-parseInt(s(320,"A9ul"))/5+parseInt(s(316,"n8W7"))/6+-parseInt(s(307,"J74X"))/7+parseInt(s(323,"0n&Z"))/8)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x410cd1(321,"UF!a")](_0x410cd1(318,"s#eM"))!=_0x410cd1(309,"wNTw"))throw window[_0x410cd1(308,"d6P[")][_0x410cd1(306,"8o$j")](_0x410cd1(311,"qlB2")),Error();document.title="Reflect 对象详解",document.getElementById("article").innerHTML='<div><p><strong>Reflect 对象详解</strong></p>\n<p>Reflect 是 ES6（ECMAScript 2015）引入的一个内置对象，它提供了一系列静态方法，用于操作对象。Reflect 的设计目的是为了更优雅地操作对象，并统一某些操作的行为。以下是对 Reflect 对象的详细解释：</p>\n<h3>一、Reflect 的基本概念</h3>\n<ol>\n<li><strong>非构造函数</strong>   ：Reflect 不是一个构造函数，不能使用 <code>new</code> 关键字进行实例化。</li>\n<li><strong>静态方法</strong>   ：Reflect 的所有方法都是静态的，直接通过 Reflect 对象调用。</li>\n<li><strong>与 Proxy 的关系</strong>   ：Reflect 的方法与 Proxy 处理器方法一一对应，通常用于 Proxy 处理器中执行默认操作。</li>\n</ol>\n<h3>二、Reflect 的主要方法</h3>\n<p>Reflect 提供了一系列静态方法，用于操作对象。以下是一些常用的方法及其作用：</p>\n<ol>\n<li><strong>Reflect.apply(target, thisArgument, argumentsList)</strong>\n<ul>\n<li>作用：调用一个函数，并传递指定的参数。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">${name}</span>!`</span>;\n}\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(greet, <span class="hljs-literal">null</span>, [<span class="hljs-string">&quot;Alice&quot;</span>])); <span class="hljs-comment">// 输出: Hello, Alice!</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Reflect.construct(target, argumentsList[, newTarget])</strong>\n<ul>\n<li>作用：使用指定的参数列表创建一个新对象，类似于使用 <code>new</code> 操作符。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;\n  }\n}\n<span class="hljs-keyword">const</span> person = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(<span class="hljs-title class_">Person</span>, [<span class="hljs-string">&quot;Bob&quot;</span>]);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出: Bob</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Reflect.get(target, propertyKey[, receiver])</strong>\n<ul>\n<li>作用：获取对象的属性值。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> };\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(obj, <span class="hljs-string">&quot;x&quot;</span>)); <span class="hljs-comment">// 输出: 1</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Reflect.set(target, propertyKey, value[, receiver])</strong>\n<ul>\n<li>作用：设置对象的属性值。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> };\n<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">2</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">x</span>); <span class="hljs-comment">// 输出: 2</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Reflect.has(target, propertyKey)</strong>\n<ul>\n<li>作用：检查对象是否具有指定的属性。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> };\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(obj, <span class="hljs-string">&quot;x&quot;</span>)); <span class="hljs-comment">// 输出: true</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Reflect.deleteProperty(target, propertyKey)</strong>\n<ul>\n<li>作用：删除对象的指定属性。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> };\n<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(obj, <span class="hljs-string">&quot;x&quot;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">// 输出: {}</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Reflect.defineProperty(target, propertyKey, attributes)</strong>\n<ul>\n<li>作用：定义或修改对象的属性。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = {};\n<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;x&quot;</span>, { <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span> });\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">x</span>); <span class="hljs-comment">// 输出: 1</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Reflect.getOwnPropertyDescriptor(target, propertyKey)</strong>\n<ul>\n<li>作用：获取对象的属性描述符。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> };\n<span class="hljs-keyword">const</span> desc = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(obj, <span class="hljs-string">&quot;x&quot;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(desc.<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出: 1</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Reflect.getPrototypeOf(target)</strong>\n<ul>\n<li>作用：获取对象的原型。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> proto = {};\n<span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proto);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj) === proto); <span class="hljs-comment">// 输出: true</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Reflect.setPrototypeOf(target, prototype)</strong>\n<ul>\n<li>作用：设置对象的原型。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> proto = {};\n<span class="hljs-keyword">const</span> obj = {};\n<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, proto);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj) === proto); <span class="hljs-comment">// 输出: true</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Reflect.isExtensible(target)</strong>\n<ul>\n<li>作用：判断对象是否可扩展。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = {};\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">isExtensible</span>(obj)); <span class="hljs-comment">// 输出: true</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Reflect.preventExtensions(target)</strong>\n<ul>\n<li>作用：阻止对象扩展。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = {};\n<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">preventExtensions</span>(obj);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">isExtensible</span>(obj)); <span class="hljs-comment">// 输出: false</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Reflect.ownKeys(target)</strong>\n<ul>\n<li>作用：获取对象的所有自身属性的键名，包括不可枚举属性和 Symbol 属性。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = { [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>)]: <span class="hljs-number">123</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> };\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj)); <span class="hljs-comment">// 输出: [&quot;name&quot;, Symbol(id)]</span>\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h3>三、Reflect 的优势</h3>\n<ol>\n<li><strong>一致的 API</strong>   ：Reflect 提供了一套统一的 API，用于替代传统的对象操作方法，使得代码更加一致和可预测。</li>\n<li><strong>更直观的命名和用法</strong>   ：Reflect 方法的命名和用法通常更加直观和清晰，易于理解和使用。</li>\n<li><strong>与 Proxy 的协同工作</strong>   ：Reflect 方法与 Proxy 处理器方法一一对应，为开发者提供了更强大的元编程能力。</li>\n<li><strong>标准化的错误处理</strong>   ：使用 Reflect 方法通常会返回布尔值或抛出标准的错误（如 TypeError），这有助于错误处理更加标准化和可预测。</li>\n</ol>\n<h3>四、Reflect 的使用场景</h3>\n<ol>\n<li><strong>简化对象操作</strong>   ：Reflect 提供了一套简洁的 API，用于替代传统的对象操作方法，简化了对象的操作。</li>\n<li><strong>与 Proxy 结合使用</strong>   ：Reflect 常与 Proxy 对象结合使用，以实现对对象操作的拦截和自定义处理。</li>\n<li><strong>提高代码可读性</strong>   ：Reflect 方法的使用使得代码的意图更加清晰，尤其是对于对象的操作。</li>\n</ol>\n<h3>五、注意事项</h3>\n<ol>\n<li><strong>学习成本</strong>   ：对于初学者来说，Reflect 对象及其相关 API 可能需要一定的时间和学习成本来掌握。</li>\n<li><strong>兼容性</strong>   ：虽然现代浏览器已经广泛支持 Reflect 对象，但在一些旧版本的浏览器或环境中可能无法使用。</li>\n<li><strong>性能开销</strong>   ：在某些情况下，使用 Reflect 方法可能会引入性能开销，尤其是在大规模循环或性能敏感的代码中。</li>\n</ol>\n<ul>\n<li><strong><code>receiver</code> 仅影响 <code>this</code> 绑定</strong>  ：\n<ul>\n<li>在 <code>Reflect.get(target, prop, receiver)</code> 或 <code>Reflect.set</code> 中，<code>receiver</code> 只决定：\n<ul>\n<li><strong>Getter/Setter 中的 <code>this</code> 值</strong>  （如 <code>obj.info</code> 的 setter 里的 <code>this</code>）。</li>\n<li><strong>原型链查找的起点</strong>  （如果 <code>target</code> 是继承对象）。</li>\n</ul>\n</li>\n<li><strong>普通属性（如 <code>name</code>）的读写依然直接操作 <code>target</code></strong>  。</li>\n</ul>\n</li>\n</ul>\n</div>'</script></body></html>