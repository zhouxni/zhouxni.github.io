<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x19a80c=_0x1e02;function _0x1e02(a,s){var l=_0x4ab5();return(_0x1e02=function(s,n){var e=l[s-=407];void 0===_0x1e02.kQSCYz&&(_0x1e02.ettKdw=function(s,n){var e,o=[],a=0,l="";for(s=(s=>{for(var n,e,o="",a="",l=0,r=0;e=s.charAt(r++);~e&&(n=l%4?64*n+e:e,l++%4)&&(o+=String.fromCharCode(255&n>>(-2*l&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var c=0,t=o.length;c<t;c++)a+="%"+("00"+o.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(a)})(s),r=0;r<256;r++)o[r]=r;for(r=0;r<256;r++)a=(a+o[r]+n.charCodeAt(r%n.length))%256,e=o[r],o[r]=o[a],o[a]=e;for(var r=0,a=0,c=0;c<s.length;c++)e=o[r=(r+1)%256],o[r]=o[a=(a+o[r])%256],o[a]=e,l+=String.fromCharCode(s.charCodeAt(c)^o[(o[r]+o[a])%256]);return l},a=arguments,_0x1e02.kQSCYz=!0);var s=s+l[0],o=a[s];return o?e=o:(void 0===_0x1e02.ssaZHx&&(_0x1e02.ssaZHx=!0),e=_0x1e02.ettKdw(e,n),a[s]=e),e})(a,s)}function _0x4ab5(){var s=["W4xdGCkEocGfna","W4BcImoStLrXrrekd8kbgMW","W43cICkXcs4tcJG","W59qWPTSlhagWOWEWRddPYy","W5KNW4VdMce","vd8pW7j6o8ouoSk2sCkBW6q","WQ7cLYhcKCoTW4SBW47cItNcPgW","i0VdJSkmW4LbeSkSW7i","WQ1LW6HSWPufpSkpWRNcJSkaea","W43cJ8oQs1r4kcm8hmksla","W4pcGYfpW67cGCo4jmonCXxdLW","f8oIW7dcIsNdIvP4WRZdRxldRW","W445cfG4W59SCcm3Av7dV0eKCJCKW5PLW5/cO8kTAYH1","WQ0jW54OW7VcO8oDyG","AJmkc8oadulcOSoxW7JcVx8T","pmkoWQnRgexdQIi","WOusnSovjCoucLnwxmo1WQJdPq","uCktkmkuENJcVq","W7ZcImkqg2/cPCkl","BCkYzCozWO7dRKO","WOhcRCk1dCkSqW4HCCkuWOyD","W5DvWP9Jl3WeWQGfWRVdGca","t8oVWOFcHgWPWQudfmkoWPvCW5O","BJCnbSocdbRcQCooW4FcVLG"];return(_0x4ab5=function(){return s})()}if((()=>{for(var s=_0x1e02,n=_0x4ab5();;)try{if(292891==+parseInt(s(430,"k7JT"))*(parseInt(s(418,"b%E("))/2)+-parseInt(s(410,"oHUf"))/3+-parseInt(s(423,"d!U3"))/4+-parseInt(s(414,"7oqv"))/5+-parseInt(s(424,"i#6g"))/6+-parseInt(s(415,"7oqv"))/7*(-parseInt(s(416,"oHUf"))/8)+parseInt(s(411,"lo7z"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x19a80c(408,"iaZB")](_0x19a80c(420,"qsUb"))!=_0x19a80c(417,"(PGm"))throw window[_0x19a80c(428,"1l&8")][_0x19a80c(407,"Exv&")](_0x19a80c(425,"eDAX")),Error();document.title="ajax responseType",document.getElementById("article").innerHTML='<div><p><code>responseType</code> 是 <code>XMLHttpRequest</code> 对象的一个属性，用于指定服务器响应的数据类型。通过设置 <code>responseType</code>，你可以告诉浏览器如何解析服务器返回的数据，从而更高效地处理不同类型的响应内容。</p>\n<h3><code>responseType</code> 的可选值</h3>\n<p><code>responseType</code> 属性可以设置为以下值：</p>\n<ol>\n<li><strong><code>&quot;&quot;</code>（空字符串）或 <code>&quot;text&quot;</code></strong>  （默认值）\n<ul>\n<li>服务器响应被视为文本。</li>\n<li>适用于返回普通文本、HTML 或 JSON 字符串的响应。</li>\n<li>示例：<code>xhr.responseType = &quot;text&quot;;</code> 或省略设置（因为默认就是 <code>&quot;text&quot;</code>）。</li>\n</ul>\n</li>\n<li><strong><code>&quot;arraybuffer&quot;</code></strong>\n<ul>\n<li>服务器响应被视为一个 <code>ArrayBuffer</code> 对象，表示原始的二进制数据。</li>\n<li>适用于处理图像、音频、视频等二进制数据。</li>\n<li>示例：<code>xhr.responseType = &quot;arraybuffer&quot;;</code></li>\n</ul>\n</li>\n<li><strong><code>&quot;blob&quot;</code></strong>\n<ul>\n<li>服务器响应被视为一个 <code>Blob</code> 对象，表示不可变的、原始数据的类文件对象。</li>\n<li>适用于处理文件下载、图像等。</li>\n<li>示例：<code>xhr.responseType = &quot;blob&quot;;</code></li>\n</ul>\n</li>\n<li><strong><code>&quot;document&quot;</code></strong>\n<ul>\n<li>服务器响应被视为一个 <code>Document</code> 对象（通常是 XML 或 HTML 文档）。</li>\n<li>适用于处理 XML 或 HTML 响应。</li>\n<li>示例：<code>xhr.responseType = &quot;document&quot;;</code></li>\n</ul>\n</li>\n<li><strong><code>&quot;json&quot;</code></strong>\n<ul>\n<li>服务器响应被视为一个 JSON 对象。</li>\n<li>浏览器会自动解析 JSON 字符串为 JavaScript 对象。</li>\n<li>示例：<code>xhr.responseType = &quot;json&quot;;</code></li>\n</ul>\n</li>\n</ol>\n<h3>使用示例</h3>\n<p>以下是一个使用 <code>responseType</code> 属性的 AJAX 请求示例，请求一个 JSON 响应：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();\nxhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>, <span class="hljs-literal">true</span>);\n\n<span class="hljs-comment">// 设置 responseType 为 &#x27;json&#x27;</span>\nxhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&#x27;json&#x27;</span>;\n\nxhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) {\n    <span class="hljs-comment">// 由于 responseType 设置为 &#x27;json&#x27;，xhr.response 已经是一个 JavaScript 对象</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">response</span>);\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求失败，状态码:&#x27;</span>, xhr.<span class="hljs-property">status</span>);\n  }\n};\n\nxhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求出错&#x27;</span>);\n};\n\nxhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);\n</code></pre>\n<h3>注意事项</h3>\n<ol>\n<li><strong>设置时机</strong>  ：<code>responseType</code> 必须在调用 <code>send()</code> 方法之前设置，否则会导致错误。</li>\n<li><strong>浏览器兼容性</strong>  ：虽然现代浏览器都支持 <code>responseType</code>，但在使用之前最好检查浏览器的兼容性。</li>\n<li><strong>性能考虑</strong>  ：对于大型二进制数据（如图像、视频），使用 <code>arraybuffer</code> 或 <code>blob</code> 可以提高性能，因为浏览器可以直接处理二进制数据，而不需要先将其转换为字符串。</li>\n<li><strong>错误处理</strong>  ：即使设置了 <code>responseType</code>，仍然需要处理可能的请求错误（如网络问题、服务器错误等）。</li>\n</ol>\n<h3>总结</h3>\n<p><code>responseType</code> 属性是 <code>XMLHttpRequest</code> 对象的一个重要特性，它允许你指定服务器响应的数据类型，从而更高效地处理不同类型的响应内容。通过合理设置 <code>responseType</code>，你可以优化 AJAX 请求的性能，并简化数据处理逻辑。</p>\n</div>'</script></body></html>