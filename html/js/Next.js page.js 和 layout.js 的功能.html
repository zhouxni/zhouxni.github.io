<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3bdc(t,s){var d=_0x36e0();return(_0x3bdc=function(s,n){var a=d[s-=414];void 0===_0x3bdc.DJGCXh&&(_0x3bdc.AXqBJr=function(s,n){var a,o=[],t=0,d="";for(s=(s=>{for(var n,a,o="",t="",d=0,e=0;a=s.charAt(e++);~a&&(n=d%4?64*n+a:a,d++%4)&&(o+=String.fromCharCode(255&n>>(-2*d&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=o.length;c<r;c++)t+="%"+("00"+o.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)o[e]=e;for(e=0;e<256;e++)t=(t+o[e]+n.charCodeAt(e%n.length))%256,a=o[e],o[e]=o[t],o[t]=a;for(var e=0,t=0,c=0;c<s.length;c++)a=o[e=(e+1)%256],o[e]=o[t=(t+o[e])%256],o[t]=a,d+=String.fromCharCode(s.charCodeAt(c)^o[(o[e]+o[t])%256]);return d},t=arguments,_0x3bdc.DJGCXh=!0);var s=s+d[0],o=t[s];return o?a=o:(void 0===_0x3bdc.GKLtyc&&(_0x3bdc.GKLtyc=!0),a=_0x3bdc.AXqBJr(a,n),t[s]=a),a})(t,s)}function _0x36e0(){var s=["WPCAACoQW6hdGmkOWQm","xCkjaCoYCCo9bmkxW7RcHmkOW7W","W5rjC8oKW7hdLmk+","W6dcU2ikW75VosrcdCoadbm","b8oHo8kEW60+W7mYWQ7cP2e","qSowrGRdLXH1W6G","sbSlW6L7WOe6hq","WP3cP8kPW57cUb1GWRq","WOZcVmoqjSoDWPrxW4VcSSksAmoIBG","WPldLanlmXZcTSkg","WOhdHv3cSCkca8o4WQFdRYFdS8oDqa","W7bHlmkJoSkHWQZdNCo3emo1WQKH","W43cI2VcQf/dRCo2WQ7cJKtcNXn4eq","W4CVWOFcQcX7jvS","W6ddOqvaWQe+tG","W6ddRSkxWOvTjdRcSCksthlcImke","W5ldSWniASkDW5i","yYZdMCoPW4nbWP4","lvpdHeDoWOxcSMy","W5fjgCoMWQS","W5HUWOddUMPxWQvZWQn+WQK","WRVcL8kakNH+WPJdUmo6B8o4W6r8W4JcTK7dOCkshaVcJCkYW74tW4ql","BaRcMmkHer3cRCo7WOGnW5W3WQy","WPXneCk+dsLfmComWQ8tpHe","WQ7dNmkWj8obW614nSo8wYyjW6O","W4RdQL3dUvzDlJ5p","kGJcLGbTW4jweKnTWRZcRG","WOhdGf7cUCkmcmo+W5ldSshdJCoTsSkk"];return(_0x36e0=function(){return s})()}var _0x56508d=_0x3bdc;if((()=>{for(var s=_0x3bdc,n=_0x36e0();;)try{if(844331==+parseInt(s(428,"Aw0M"))*(parseInt(s(422,"^1kS"))/2)+parseInt(s(429,"yUUu"))/3+-parseInt(s(432,"^DfW"))/4*(-parseInt(s(440,"3DsC"))/5)+-parseInt(s(437,"UfWf"))/6+-parseInt(s(424,"^DT@"))/7+parseInt(s(434,"WR]Q"))/8*(parseInt(s(427,"J92T"))/9)+parseInt(s(426,"23iy"))/10*(-parseInt(s(419,"&05p"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x56508d(430,"27tD")](_0x56508d(439,"JpuZ"))!=_0x56508d(433,"9r&v"))throw window[_0x56508d(423,"00yh")][_0x56508d(416,"dI9M")](_0x56508d(435,"uH8%")),Error();document.title="Next.js page.js 和 layout.js 的功能",document.getElementById("article").innerHTML='<div><p><strong><code>page.js</code> 和 <code>layout.js</code> 的功能是明确分开的</strong>   ，二者在 Next.js 的 App Router 架构中承担不同的职责，但通过嵌套协作共同构建页面。以下是具体解析：</p>\n<hr>\n<h3><strong>1. 职责分离</strong></h3>\n<table>\n<thead>\n<tr>\n<th>文件</th>\n<th>核心功能</th>\n<th>示例场景（基于图片中的 <code>dashboard/</code>）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong><code>page.js</code></strong></td>\n<td>定义当前路由的<strong>专属内容</strong></td>\n<td><code>/dashboard</code> 页面的主体内容（如数据统计卡片列表）</td>\n</tr>\n<tr>\n<td><strong><code>layout.js</code></strong></td>\n<td>提供<strong>共享的布局框架</strong>   （如导航栏、侧边栏），包裹所有子路由的 <code>page.js</code></td>\n<td>为 <code>/dashboard/*</code> 所有子路由添加统一的控制面板框架</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>2. 协作关系</strong></h3>\n<h4><strong>文件结构</strong></h4>\n<pre><code class="language-bash">dashboard/\n  ├── layout.js   <span class="hljs-comment"># 布局容器</span>\n  └── page.js     <span class="hljs-comment"># 页面内容</span>\n</code></pre>\n<h4><strong>渲染逻辑</strong></h4>\n<pre><code class="language-mermaid">flowchart TB\n  A[用户访问 /dashboard] --&gt; B[加载 layout.js 的框架]\n  B --&gt; C[加载 page.js 的内容]\n  C --&gt; D[将 page.js 注入 layout.js 的 children 位置]\n  D --&gt; E[最终输出: 布局 + 内容]\n</code></pre>\n<h4><strong>代码示例</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// dashboard/layout.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">DashboardLayout</span>(<span class="hljs-params">{ children }</span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;dashboard&quot;</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Sidebar</span> /&gt;</span> {/* 共享侧边栏 */}\n      <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span> {/* page.js 内容在此渲染 */}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-comment">// dashboard/page.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">DashboardPage</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这里是控制面板的核心内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n<hr>\n<h3><strong>3. 为什么需要分离？</strong></h3>\n<ul>\n<li><strong>关注点分离</strong>   ：布局与业务逻辑解耦，便于维护。</li>\n<li><strong>性能优化</strong>   ：布局仅在路由切换时局部更新，<code>page.js</code> 可独立动态加载。</li>\n<li><strong>复用性</strong>   ：同一布局可包裹多个子路由（如 <code>/dashboard/analytics</code> 和 <code>/dashboard/settings</code> 共享 <code>dashboard/layout.js</code>）。</li>\n</ul>\n<hr>\n<h3><strong>4. 常见误区澄清</strong></h3>\n<table>\n<thead>\n<tr>\n<th>误区</th>\n<th>实际情况</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>layout.js</code> 可以替代 <code>page.js</code></td>\n<td>不能！<code>layout.js</code> 必须包含 <code>{children}</code> 才能渲染 <code>page.js</code> 的内容</td>\n</tr>\n<tr>\n<td><code>page.js</code> 需要手动引入布局</td>\n<td>不需要！Next.js 自动将 <code>page.js</code> 嵌套到同目录的 <code>layout.js</code> 中</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>5. 特殊场景处理</strong></h3>\n<h4><strong>如果目录只有 <code>page.js</code> 没有 <code>layout.js</code></strong></h4>\n<ul>\n<li>页面直接渲染 <code>page.js</code> 内容，不继承任何布局。</li>\n<li>若需全局布局，需在更上层目录（如 <code>app/layout.js</code>）中定义。</li>\n</ul>\n<h4><strong>如果目录只有 <code>layout.js</code> 没有 <code>page.js</code></strong></h4>\n<ul>\n<li>该路由不会渲染任何内容（除非有子路由的 <code>page.js</code> 被嵌套渲染）。</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>图片中的 <code>dashboard/page.js</code> 和 <code>dashboard/layout.js</code> 是典型的 Next.js App Router 文件结构，二者<strong>功能分离但协作紧密</strong>   ：</p>\n<ul>\n<li><strong><code>layout.js</code></strong>   是“画布”，定义结构和可复用组件。</li>\n<li><strong><code>page.js</code></strong>   是“颜料”，填充当前路由的独特内容。</li>\n</ul>\n<p>这种设计模式使得开发者能够高效管理复杂路由的布局一致性，同时保持页面内容的独立性。</p>\n</div>'</script></body></html>