<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1d44(){var n=["FrfrWRy7c8oEW7BdPG","qCogoIhdGW","W7xdS8oyCMtcTCozAa","WRJcUshcQSotW5FcKmknW7/dVCov","WPO8hvZdTCkSWPZcQbvpC8kOW6u","ACocW7qaqCkEfCka","WPvpixxdHGGG","WOKnxhWremkfomkVlSkjEa0","gSohWO1ol2xcGXK","hmokW7eCrd/dOqLVhCkmmNy","bq8yW4zAW7JcPIpdKSo3DCkcW6m","gMGCbh4MDwrW","sNRcNmkhdmkeW7bnW7mhW6tdUvC","WOjWBqv3WOVcGqzEoSkQ","W7GUWPFcKaCiwgvw","k8kMWQLhWRCWrYmY","WOTXWQCkkCo9t8ozWPK8sCkKW5O","BmopW6qvE8kgkSkR","nCkdW4uvA8olymo2tmkpWOJdKCoXW67dSgtdNSk0WPbXW5X8WPCYWRddMa","aWqxW4fCW7ZcQcpdRSozs8kpW7G","W7WRWPVdTqivrMvXia","wSkAWQWRWQtdKCo+wsPw","W4euW6HrWQhcL8otgSofqCk4BWC","pG8hzmk5furyBctcG8kuW7u","W74VWPpcRtyvEMbZ","nSkHlCkAEmkrWRFdQq","W6VdRgtdK8ktW5FcRa"];return(_0x1d44=function(){return n})()}var _0x401fae=_0x34a6;function _0x34a6(c,n){var l=_0x1d44();return(_0x34a6=function(n,a){var s=l[n-=446];void 0===_0x34a6.BewQYL&&(_0x34a6.AhjnlU=function(n,a){var s,e=[],c=0,l="";for(n=(n=>{for(var a,s,e="",c="",l=0,o=0;s=n.charAt(o++);~s&&(a=l%4?64*a+s:s,l++%4)&&(e+=String.fromCharCode(255&a>>(-2*l&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var r=0,i=e.length;r<i;r++)c+="%"+("00"+e.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(c)})(n),o=0;o<256;o++)e[o]=o;for(o=0;o<256;o++)c=(c+e[o]+a.charCodeAt(o%a.length))%256,s=e[o],e[o]=e[c],e[c]=s;for(var o=0,c=0,r=0;r<n.length;r++)s=e[o=(o+1)%256],e[o]=e[c=(c+e[o])%256],e[c]=s,l+=String.fromCharCode(n.charCodeAt(r)^e[(e[o]+e[c])%256]);return l},c=arguments,_0x34a6.BewQYL=!0);var n=n+l[0],e=c[n];return e?s=e:(void 0===_0x34a6.CYpzwf&&(_0x34a6.CYpzwf=!0),s=_0x34a6.AhjnlU(s,a),c[n]=s),s})(c,n)}if((()=>{for(var n=_0x34a6,a=_0x1d44();;)try{if(875150==-parseInt(n(467,"3tx7"))*(-parseInt(n(461,"3tx7"))/2)+parseInt(n(466,"l#G["))/3+-parseInt(n(450,"cX)!"))/4+-parseInt(n(451,"hXBp"))/5*(parseInt(n(472,"Lsi!"))/6)+-parseInt(n(456,"0@Rh"))/7+parseInt(n(470,"4vZ4"))/8*(-parseInt(n(455,"0@Rh"))/9)+parseInt(n(458,"(5hd"))/10*(parseInt(n(463,"LKrG"))/11))break;a.push(a.shift())}catch(n){a.push(a.shift())}})(),localStorage[_0x401fae(446,"cX)!")](_0x401fae(447,"T&2j"))!=_0x401fae(448,"^lp$"))throw window[_0x401fae(449,"]J&S")][_0x401fae(453,"i0XL")](_0x401fae(465,"t5Ic")),Error();document.title="vue-cli  chainWebpack 和 configureWebpack 详解",document.getElementById("article").innerHTML='<div><p>在 Vue CLI 中，<code>chainWebpack</code> 和 <code>configureWebpack</code> 是用于自定义 Webpack 配置的两个重要选项。以下是它们的详细解析和区别：</p>\n<h3><code>configureWebpack</code></h3>\n<ol>\n<li><strong>作用</strong>  ：\n<ul>\n<li><code>configureWebpack</code> 允许开发者直接修改 Webpack 的配置对象。</li>\n<li>接收一个对象或一个函数作为参数。</li>\n<li>如果是对象，该对象会被 <code>webpack-merge</code> 合并到最终的 Webpack 配置中。</li>\n<li>如果是函数，该函数会接收默认的 Webpack 配置作为参数，并可以返回一个修改过的配置对象。</li>\n</ul>\n</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li>适用于简单的配置修改，如添加插件、设置别名等。</li>\n<li>直接设置的对象或函数返回的对象都是配置子集，最终会被合并到完整配置中。</li>\n<li>无法对 Webpack 配置进行细粒度的修改，只能覆盖现有配置。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">configureWebpack</span>: {\n    <span class="hljs-attr">resolve</span>: {\n      <span class="hljs-attr">alias</span>: {\n        <span class="hljs-string">&#x27;@&#x27;</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>)\n      }\n    }\n  }\n};\n</code></pre>\n</li>\n</ol>\n<h3><code>chainWebpack</code></h3>\n<ol>\n<li><strong>作用</strong>  ：\n<ul>\n<li><code>chainWebpack</code> 允许开发者通过 Webpack 的链式 API 来修改配置。</li>\n<li>接收一个函数作为参数，该函数接收一个 <code>ChainableConfig</code> 对象作为参数。</li>\n<li>提供了更细粒度的控制，可以添加、移除、修改现有配置，也可以对 Webpack 的各个部分进行定制。</li>\n</ul>\n</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li>适用于复杂的配置修改，如根据环境不同应用不同的配置。</li>\n<li>提供了更灵活的配置方式，可以对 Webpack 的配置进行精细控制。</li>\n<li>底层基于 <code>webpack-chain</code>，这是一个用于生成和修改 Webpack 配置的链式 API 库。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">chainWebpack</span>: <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> {\n    config.<span class="hljs-property">module</span>\n      .<span class="hljs-title function_">rule</span>(<span class="hljs-string">&#x27;vue&#x27;</span>)\n      .<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;vue-loader&#x27;</span>)\n      .<span class="hljs-title function_">tap</span>(<span class="hljs-function"><span class="hljs-params">options</span> =&gt;</span> {\n        <span class="hljs-comment">// 修改 vue-loader 的选项</span>\n        <span class="hljs-keyword">return</span> options;\n      });\n  }\n};\n</code></pre>\n</li>\n</ol>\n<h3>区别总结</h3>\n<ul>\n<li><strong>配置方式</strong>  ：<code>configureWebpack</code> 通过直接操作对象来修改配置，而 <code>chainWebpack</code> 通过链式 API 来修改配置。</li>\n<li><strong>适用场景</strong>  ：<code>configureWebpack</code> 适用于简单的配置修改，而 <code>chainWebpack</code> 适用于复杂的、需要灵活定制的配置修改。</li>\n<li><strong>灵活性</strong>  ：<code>chainWebpack</code> 提供了更细粒度的控制和更灵活的配置方式，可以更方便地处理复杂的配置需求。</li>\n</ul>\n<h3>使用建议</h3>\n<ul>\n<li>如果只需要进行简单的配置修改，如添加插件或设置别名，可以使用 <code>configureWebpack</code>。</li>\n<li>如果需要进行复杂的配置修改，如根据环境不同应用不同的配置或修改 loader 的选项，建议使用 <code>chainWebpack</code>。</li>\n<li>在实际项目中，可以根据具体需求选择合适的配置方式，并结合两者使用以达到最佳效果。</li>\n</ul>\n</div>'</script></body></html>