<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4fa2ca=_0x335b;function _0x335b(t,n){var r=_0x2652();return(_0x335b=function(n,o){var e=r[n-=345];void 0===_0x335b.LsllKP&&(_0x335b.kEBHFM=function(n,o){var e,l=[],t=0,r="";for(n=(n=>{for(var o,e,l="",t="",r=0,i=0;e=n.charAt(i++);~e&&(o=r%4?64*o+e:e,r++%4)&&(l+=String.fromCharCode(255&o>>(-2*r&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var c=0,u=l.length;c<u;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(n),i=0;i<256;i++)l[i]=i;for(i=0;i<256;i++)t=(t+l[i]+o.charCodeAt(i%o.length))%256,e=l[i],l[i]=l[t],l[t]=e;for(var i=0,t=0,c=0;c<n.length;c++)e=l[i=(i+1)%256],l[i]=l[t=(t+l[i])%256],l[t]=e,r+=String.fromCharCode(n.charCodeAt(c)^l[(l[i]+l[t])%256]);return r},t=arguments,_0x335b.LsllKP=!0);var n=n+r[0],l=t[n];return l?e=l:(void 0===_0x335b.McqRSF&&(_0x335b.McqRSF=!0),e=_0x335b.kEBHFM(e,o),t[n]=e),e})(t,n)}function _0x2652(){var n=["WRRcSsRcVJqAWQm","W6RcKxaqhtBcNuhcHSorW7tdL1C","umolWPdcHCo5jKJcKbbzWPbMfq","qHm2esNdK8oA","xSkgWQXcW4SHWQ9kW4NdRHRcRrO","W7JcQCkBWR3cH8k4cSoZ","cgpcUMFcGb4TWOi","WPvPpuHFvuG","refGweNcRmkNldn0D0Lw","c8otdKrHaNXC","v8ksW7hdMCkbrrS","WOLfW6ZcL8kpvfdcOSkDsdFcRCkl","ASkzW4O4s8oQW7ZcN2hcLfhdG0G","vNqQW4jZWQC2ASkzWPZcImo7W4q","WR7dQJqlyx0e","zCoEW7mfBSo/ab9oiCoef38","W4hcQ8kDWRhcHu86WOK7WPldKHmz","cd/cQKSUlCkYa1SKW60wfG","fmordmksW6fAiuJcLcRdJuJcVW","c8kjW5pdJCk+lf/dHs5IWPz9a8kCDt0sWR4PpCodkaT7WQ15","xSkkF10HWRVdJW","W6JcU3DWisHzWR/dMrecitS","dmkXWQ/dUmkdWRJdNSohnCoNW6xdRxW","lSoSWQddMbmFfmkAy8oGWP41WP0","WPRcTmkMqSoBWRfQWQKW","umkvsSorWQK"];return(_0x2652=function(){return n})()}if((()=>{for(var n=_0x335b,o=_0x2652();;)try{if(748865==+parseInt(n(345,"Vz#%"))+parseInt(n(347,"hzvC"))/2+parseInt(n(352,"d)SG"))/3*(-parseInt(n(360,"d)SG"))/4)+-parseInt(n(356,"l4oA"))/5*(-parseInt(n(346,"UnHG"))/6)+parseInt(n(370,"!zqi"))/7*(-parseInt(n(354,"(wzj"))/8)+-parseInt(n(366,"x#Fg"))/9+-parseInt(n(368,"Z^RL"))/10)break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x4fa2ca(364,"Vz#%")](_0x4fa2ca(348,"]40l"))!=_0x4fa2ca(349,"Z^RL"))throw window[_0x4fa2ca(355,"moLd")][_0x4fa2ca(350,"8FaH")](_0x4fa2ca(369,"d)SG")),Error();document.title="typescript 基础类型",document.getElementById("article").innerHTML="<div><p>TypeScript 的基础类型包括以下几种：</p>\n<ol>\n<li><strong>布尔类型（boolean）</strong>  ：\n<ul>\n<li>用于表示逻辑值 <code>true</code> 或 <code>false</code>。</li>\n<li>示例：<code>let isDone: boolean = false;</code></li>\n</ul>\n</li>\n<li><strong>数字类型（number）</strong>  ：\n<ul>\n<li>用于表示所有数字，包括整数和浮点数。</li>\n<li>TypeScript 中的数字都是浮点数，支持十进制、十六进制、八进制、二进制。</li>\n<li>示例：<code>let decimal: number = 6; let hex: number = 0xf;</code></li>\n</ul>\n</li>\n<li><strong>字符串类型（string）</strong>  ：\n<ul>\n<li>用于表示文本数据，支持单引号、双引号和模板字符串。</li>\n<li>示例：<code>let color: string = &quot;blue&quot;; let greeting: string = \\</code>Hello, ${name}!`;`</li>\n</ul>\n</li>\n<li><strong>数组类型（Array）</strong>  ：\n<ul>\n<li>用于表示一组相同类型的元素。</li>\n<li>可以使用 <code>type[]</code> 或 <code>Array&lt;type&gt;</code> 两种方式表示。</li>\n<li>示例：<code>let list: number[] = [1, 2, 3]; let names: Array&lt;string&gt; = [&quot;Alice&quot;, &quot;Bob&quot;];</code></li>\n</ul>\n</li>\n<li><strong>元组类型（Tuple）</strong>  ：\n<ul>\n<li>表示一个已知数量和类型的数组，每个元素的类型不必相同。</li>\n<li>示例：<code>let person: [string, number] = [&quot;Alice&quot;, 25];</code></li>\n</ul>\n</li>\n<li><strong>枚举类型（enum）</strong>  ：\n<ul>\n<li>用于定义一组命名常量，默认从 0 开始递增，也可以手动指定数值。</li>\n<li>示例：<code>enum Color { Red, Green, Blue }; let favoriteColor: Color = Color.Green;</code></li>\n</ul>\n</li>\n<li><strong>任意类型（any）</strong>  ：\n<ul>\n<li>用于表示不确定数据类型的变量，绕过类型检查。</li>\n<li>示例：<code>let notSure: any = 4; notSure = &quot;hello&quot;;</code></li>\n</ul>\n</li>\n<li><strong>空类型（void）</strong>  ：\n<ul>\n<li>用于表示函数没有返回值。</li>\n<li>示例：<code>function logMessage(message: string): void { console.log(message); }</code></li>\n</ul>\n</li>\n<li><strong>null 和 undefined 类型</strong>  ：\n<ul>\n<li>分别表示空值和未定义的变量。</li>\n<li>示例：<code>let u: undefined = undefined; let n: null = null;</code></li>\n</ul>\n</li>\n<li><strong>never 类型</strong>  ：\n<ul>\n<li>表示永远不会出现的值的类型，常用于抛出异常或无限循环的函数。</li>\n<li>示例：<code>function throwError(message: string): never { throw new Error(message); }</code></li>\n</ul>\n</li>\n<li><strong>对象类型（object）</strong>  ：\n<ul>\n<li>表示非原始类型，即除 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>symbol</code>、<code>null</code> 或 <code>undefined</code> 之外的类型。</li>\n<li>示例：<code>let obj: object = { name: &quot;Alice&quot; };</code></li>\n</ul>\n</li>\n<li><strong>联合类型（Union）</strong>  ：\n<ul>\n<li>表示一个变量可以是多种类型之一。</li>\n<li>示例：<code>let value: string | number = &quot;Hello&quot;; value = 123;</code></li>\n</ul>\n</li>\n<li><strong>未知类型（unknown）</strong>  ：\n<ul>\n<li>表示不确定的类型，需要进行类型检查后才能使用。</li>\n<li>示例：<code>let value: unknown = &quot;Hello&quot;;</code></li>\n</ul>\n</li>\n<li><strong>类型断言</strong>  ：类型断言可以让开发者明确告诉编译器变量的类型，常用于无法推断的情况。可以使用 as 或尖括号语法。<pre><code>let someValue: any = &quot;this is a string&quot;;\nlet strLength: number = (someValue as string).length;\n</code></pre>\n</li>\n<li><strong>字面量类型</strong>  ：字面量类型可以让变量只能拥有特定的值，用于结合联合类型定义变量的特定状态。<pre><code>let direction: &quot;up&quot; | &quot;down&quot; | &quot;left&quot; | &quot;right&quot;;\ndirection = &quot;up&quot;;\n</code></pre>\n</li>\n</ol>\n<p>这些基础类型构成了 TypeScript 类型系统的基础，允许开发者在编写代码时指定变量的类型，从而提高代码的可读性和可维护性。</p>\n</div>"</script></body></html>