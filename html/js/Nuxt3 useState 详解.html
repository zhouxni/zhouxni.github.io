<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4a5b(){var s=["W6ZcHSkekID6W4K","W6ddSge2W7NcH2W","eYTsWRRdRmohW5NdVG","vSkKFe7dGvxcTb7dV15d","WQvgWO48WRieeSk6pmoakq","zKtcG3eAW7q0W7VcNmk8","sSo8hmoYW6i","W7iUC2VdPafXWQpdGSk5","z8ogWOFdMCo1BatdK8k2","zmkol8otW60rlSkqWOS","WO0GWRJcK8oGFuqd","fYpcHJxdUrZcHYm","cmooW6ZdJ3BcSLW+W7O","ESoaELpcLmkaAdWSsmocmCo6","WPyCWOeWWOdcUY/cJhrOja","W4hdLJfIW4BdKSkpb34","euGewSoYWOqfvZCjWRDLW4K","u8kHWOZdL8kbWPCBdCkqb1fWW7S","lSokuZHtf8kXW51EWPVdVSoaumkgBfSFWRqcWQ0pWOxcJ8ogucu","t8oNW7qHW5ddVJZdKa","W7yLFqRdQsvWWPxdVq","WQSoW4ZdL8kPnCk3W4HTWRi6","ErxcUSo/hCosW78gymkQ","eCkJrmoSzSk+yJvpd8kp","ymonWOJcSCoUBZFdHSkczW","Fr7cS8o3w8kjWOWnwSkiEJ1p","WRi2mYtcIb1Pfq","FHxcTSo/xmoOW5qbCmkdrq","WPresCoZjqaRW5HgjSoVhx4","nSoonLVdLmkdW6WgWODeW7tcIGO"];return(_0x4a5b=function(){return s})()}var _0x3aabf6=_0x2553;function _0x2553(e,s){var l=_0x4a5b();return(_0x2553=function(s,n){var a=l[s-=403];void 0===_0x2553.KznTpe&&(_0x2553.ZtFzil=function(s,n){var a,t=[],e=0,l="";for(s=(s=>{for(var n,a,t="",e="",l=0,p=0;a=s.charAt(p++);~a&&(n=l%4?64*n+a:a,l++%4)&&(t+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=t.length;o<c;o++)e+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(e)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)e=(e+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[e],t[e]=a;for(var p=0,e=0,o=0;o<s.length;o++)a=t[p=(p+1)%256],t[p]=t[e=(e+t[p])%256],t[e]=a,l+=String.fromCharCode(s.charCodeAt(o)^t[(t[p]+t[e])%256]);return l},e=arguments,_0x2553.KznTpe=!0);var s=s+l[0],t=e[s];return t?a=t:(void 0===_0x2553.QrPOpR&&(_0x2553.QrPOpR=!0),a=_0x2553.ZtFzil(a,n),e[s]=a),a})(e,s)}if((()=>{for(var s=_0x2553,n=_0x4a5b();;)try{if(385846==+parseInt(s(415,"ZVqf"))*(-parseInt(s(420,"k^8R"))/2)+-parseInt(s(410,"ZVqf"))/3*(-parseInt(s(430,"S#*r"))/4)+-parseInt(s(413,"ZVqf"))/5+-parseInt(s(416,"kqW)"))/6*(parseInt(s(407,"JzvA"))/7)+-parseInt(s(426,"4KWy"))/8*(-parseInt(s(422,"AXxv"))/9)+-parseInt(s(405,"wwxf"))/10+-parseInt(s(412,"4KWy"))/11*(-parseInt(s(409,"vcih"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3aabf6(418,"jgmr")](_0x3aabf6(403,"c^@u"))!=_0x3aabf6(424,"Kr0H"))throw window[_0x3aabf6(429,"Ulf[")][_0x3aabf6(419,"f])[")](_0x3aabf6(406,"WwO1")),Error();document.title="Nuxt3 useState 详解",document.getElementById("article").innerHTML='<div><p><code>useState</code> 是 Nuxt 3 在 <strong>服务端渲染 + 客户端 hydration</strong>   场景下专门设计的**“同构响应式状态”**   工具。<br>\n它看起来像一个 Vue 的 <code>ref</code>，但底层做了三件事：</p>\n<ol>\n<li>在 SSR 时把初始值序列化到 HTML（<code>__NUXT_DATA__</code>）。</li>\n<li>在客户端 hydration 时把值原样“捡”回来，避免闪动 / 二次请求。</li>\n<li>在 Vue 实例之外做全局键值映射，跨组件、跨插件、跨中间件都能共享，且<strong>同名自动合并</strong>   。</li>\n</ol>\n<hr>\n<p>一、基本签名</p>\n<pre><code class="language-ts"><span class="hljs-keyword">function</span> useState&lt;T&gt;(<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">init</span>?: <span class="hljs-function">() =&gt;</span> T | <span class="hljs-title class_">Ref</span>&lt;T&gt;): <span class="hljs-title class_">Ref</span>&lt;T&gt;;\n</code></pre>\n<ul>\n<li>必须给 key（除非你写在 <code>&lt;script setup&gt;</code> 且编译器能自动推导）。</li>\n<li>init 只在<strong>服务端</strong>   或<strong>客户端第一次调用</strong>   且缓存未命中时执行；后续直接返回缓存。</li>\n<li>返回的是 <code>Ref&lt;T&gt;</code>，所以 <code>.value</code> 读写即可。</li>\n</ul>\n<hr>\n<p>二、最小例子</p>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- app.vue --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-comment">// 自动 key: &quot;$s0&quot;（编译器生成）</span>\n  <span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-number">0</span>);\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;counter++&quot;</span>&gt;</span>{{ counter }}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n<p>刷新页面，数字不会归零，也不会闪 0→1；服务端 0 已写进 HTML，客户端直接接管。</p>\n<hr>\n<p>三、显式 key &amp; 跨文件共享</p>\n<pre><code class="language-ts"><span class="hljs-comment">// composables/useCounter.ts</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useCounter</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;counter&quot;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-number">0</span>); <span class="hljs-comment">// 同一 key 全局单例</span>\n</code></pre>\n<p>任何组件、插件、server/api 里调用 <code>useCounter()</code> 都拿到同一 Ref。</p>\n<hr>\n<p>四、与 <code>ref</code> 区别速记</p>\n<table>\n<thead>\n<tr>\n<th>ref</th>\n<th>useState</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>组件内部私有</td>\n<td>全局同名共享</td>\n</tr>\n<tr>\n<td>每次创建新值</td>\n<td>仅第一次运行 init</td>\n</tr>\n<tr>\n<td>不参与序列化</td>\n<td>自动序列化到 HTML</td>\n</tr>\n<tr>\n<td>客户端专用</td>\n<td>同构</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>五、进阶场景</p>\n<ol>\n<li>插件里初始化</li>\n</ol>\n<pre><code class="language-ts"><span class="hljs-comment">// plugins/init-auth.ts</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtPlugin</span>(<span class="hljs-title function_">async</span> () =&gt; {\n  <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">User</span> | <span class="hljs-literal">null</span>);\n  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">server</span>) {\n    <span class="hljs-comment">// 只在服务端拉取</span>\n    user.<span class="hljs-property">value</span> = <span class="hljs-keyword">await</span> $fetch(<span class="hljs-string">&quot;/api/me&quot;</span>);\n  }\n});\n</code></pre>\n<p>任何页面直接 <code>const user = useState(\'user\')</code> 即可拿到登录态，<strong>0 次额外请求</strong>   。</p>\n<ol start="2">\n<li>中间件里复写</li>\n</ol>\n<pre><code class="language-ts"><span class="hljs-comment">// middleware/auth.ts</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtRouteMeta</span>(<span class="hljs-title function_">async</span> (to) =&gt; {\n  <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;user&quot;</span>);\n  <span class="hljs-keyword">if</span> (!user.<span class="hljs-property">value</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">navigateTo</span>(<span class="hljs-string">&quot;/login&quot;</span>);\n});\n</code></pre>\n<ol start="3">\n<li>手动清除缓存</li>\n</ol>\n<pre><code class="language-ts"><span class="hljs-keyword">const</span> nuxtApp = <span class="hljs-title function_">useNuxtApp</span>();\nnuxtApp.<span class="hljs-property">payload</span>.<span class="hljs-property">state</span>.<span class="hljs-property">counter</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 下次重新跑 init</span>\n</code></pre>\n<ol start="4">\n<li>深度响应式\n<code>useState</code> 只包一层 <code>ref</code>，里层对象不会自动代理；需要 <code>ref</code>/<code>reactive</code> 自己包：</li>\n</ol>\n<pre><code class="language-ts"><span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;meta&quot;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Nuxt&quot;</span> }));\n</code></pre>\n<hr>\n<p>六、常见坑</p>\n<ol>\n<li>\n<p><strong>key 重复</strong><br>\n同名 key 会合并，可能导致插件把组件状态覆盖；建议加命名空间：</p>\n<pre><code class="language-ts"><span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;myPlugin:settings&quot;</span>, <span class="hljs-function">() =&gt;</span> ({}));\n</code></pre>\n</li>\n<li>\n<p><strong>init 里用客户端 API</strong><br>\ninit 会在服务端跑一次，如果直接访问 <code>window</code>、<code>document</code> 会报错；用</p>\n<pre><code class="language-ts"><span class="hljs-keyword">if</span> (process.<span class="hljs-property">client</span>) {\n  <span class="hljs-comment">/* ... */</span>\n}\n</code></pre>\n</li>\n<li>\n<p><strong>循环依赖</strong><br>\n在 <code>useState</code> init 里立即 <code>await $fetch(\'/api/xxx\')</code>，而 api 内部又 <code>useState</code> 同名 key → 死锁。<br>\n解决：把逻辑拆到插件或页面 <code>onMounted</code> 再补数据。</p>\n</li>\n<li>\n<p><strong>JSON 无法序列化</strong><br>\n函数、<code>Infinity</code>、<code>undefined</code>、<code>BigInt</code> 等会丢；只放纯数据。</p>\n</li>\n</ol>\n<hr>\n<p>七、原理解剖（1 分钟看懂）</p>\n<ol>\n<li>\n<p>SSR：<br>\n<code>useState(\'foo\', init)</code> → 执行 init → 结果存入 <code>nuxtApp.payload.state.foo</code> → Nuxt 把 <code>payload</code> 序列化进 <code>window.__NUXT__.state</code>。</p>\n</li>\n<li>\n<p>Hydration：<br>\n客户端创建 Vue 应用前，Nuxt 把 <code>__NUXT__.state</code> 恢复到 <code>nuxtApp.payload.state</code>；<br>\n之后每次 <code>useState(\'foo\')</code> 直接返回 <code>ref(nuxtApp.payload.state.foo)</code>，不再执行 init。</p>\n</li>\n<li>\n<p>全局映射：<br>\n所有 <code>useState</code> 实例通过 <code>nuxtApp._asyncDataPromises</code> + <code>payload.state</code> 做同 key 单例，因此跨文件共享零配置。</p>\n</li>\n</ol>\n<hr>\n<p>八、一句话总结\n<code>useState = ref</code> 的同构升级版：<br>\n“<strong>服务端初始化 → 序列化 → 客户端接管 → 全局共享</strong>   ”，<br>\n在 Nuxt 3 里任何需要“<strong>跨组件且不二次请求</strong>   ”的状态，第一时间想到 <code>useState</code> 就对了。</p>\n</div>'</script></body></html>