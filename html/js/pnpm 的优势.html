<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x170b(l,n){var i=_0x34f7();return(_0x170b=function(n,t){var r=i[n-=353];void 0===_0x170b.TozOtE&&(_0x170b.geCEEM=function(n,t){var r,o=[],l=0,i="";for(n=(n=>{for(var t,r,o="",l="",i=0,s=0;r=n.charAt(s++);~r&&(t=i%4?64*t+r:r,i++%4)&&(o+=String.fromCharCode(255&t>>(-2*i&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var g=0,p=o.length;g<p;g++)l+="%"+("00"+o.charCodeAt(g).toString(16)).slice(-2);return decodeURIComponent(l)})(n),s=0;s<256;s++)o[s]=s;for(s=0;s<256;s++)l=(l+o[s]+t.charCodeAt(s%t.length))%256,r=o[s],o[s]=o[l],o[l]=r;for(var s=0,l=0,g=0;g<n.length;g++)r=o[s=(s+1)%256],o[s]=o[l=(l+o[s])%256],o[l]=r,i+=String.fromCharCode(n.charCodeAt(g)^o[(o[s]+o[l])%256]);return i},l=arguments,_0x170b.TozOtE=!0);var n=n+i[0],o=l[n];return o?r=o:(void 0===_0x170b.YwwuiK&&(_0x170b.YwwuiK=!0),r=_0x170b.geCEEM(r,t),l[n]=r),r})(l,n)}function _0x34f7(){var n=["WOldO0NdSs8Uf8k/W4lcLmoOcmoIvG","W57cV8k6kwFdII3cNqPS","it3cN8kjD8oayq","jSoUWPNdNxr0WQS","i3PIW4pcJadcR8oEhCkKW6HEheW","WPvUW6BcSCkfkxi","Fq3cJSoFomkSr05wnryxW6DvEuFdVWTLgmoNWOLPc11z","W4fHoZiqeZ8dpre","jIxdH8knjSkqWRe3W63dM8k/BJS","WPtcQWGwpu8r","WOWgkmkgc8oCeSoDW5Dq","E8orBmkuW68oWRixp8keW6KL","WO7cMSooWQFcL21SzmkBWPxdU8krBa","W5GnfthcQSkiW7ZdQSoCeaDWW5m","iSkipConWQ9vWRGA","W6C2wCk1AxCDW6RdHb3cJXO","isZdImknjSkDW5u+W7tdTSk9Fq","W5/cTmk8kghdJqVcGrjY","W5O9m8oGoSoqWOpdUCoFCq","zSk/W5dcGsaHW77cRmk/h8oOW5hcMa","BCoQiJ/cSKhcUq4XWOJcUvi","jc3dH8kkFSoVW4agW5/dUa","W4VdN8keW6pdMG","W6VdRfBcT0tcSaTMWQa"];return(_0x34f7=function(){return n})()}var _0x1fc84f=_0x170b;if((()=>{for(var n=_0x170b,t=_0x34f7();;)try{if(358688==+parseInt(n(360,"7Zi0"))+parseInt(n(374,"bzG5"))/2*(parseInt(n(370,"uE)K"))/3)+-parseInt(n(365,"@h@D"))/4+parseInt(n(364,"fQEI"))/5+parseInt(n(366,"#i^2"))/6*(parseInt(n(362,"uE)K"))/7)+parseInt(n(353,"#i^2"))/8+-parseInt(n(369,"f)@C"))/9)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x1fc84f(354,"uTzq")](_0x1fc84f(368,"Fen!"))!=_0x1fc84f(367,"xdDY"))throw window[_0x1fc84f(359,"EYD5")][_0x1fc84f(372,"fQEI")](_0x1fc84f(375,"&YaP")),Error();document.title="pnpm 的优势",document.getElementById("article").innerHTML='<div><p><strong>pnpm 的核心优势</strong></p>\n<p>pnpm（Performant NPM）是一款高效的包管理工具，专为提升 JavaScript/TypeScript 项目的依赖管理效率而设计。其核心优势体现在性能、磁盘空间优化和依赖管理灵活性上。以下是 pnpm 的主要优势分析：</p>\n<hr>\n<h3><strong>1. 磁盘空间的高效利用</strong></h3>\n<ul>\n<li><strong>硬链接机制</strong>  ：\n<ul>\n<li>pnpm 将依赖包下载到全局缓存目录，并通过硬链接将包链接到各个项目的 <code>node_modules</code> 中。</li>\n<li><strong>效果</strong>  ：多个项目共享同一份依赖包文件，避免重复安装，显著节省磁盘空间。</li>\n</ul>\n</li>\n<li><strong>对比 npm/yarn</strong>  ：\n<ul>\n<li>npm 和 yarn 会为每个项目复制一份依赖包，导致磁盘占用大。</li>\n<li><strong>示例</strong>  ：\n<ul>\n<li>假设有 10 个项目，每个项目依赖 <code>lodash</code>（大小 1MB）。</li>\n<li>npm/yarn：10 个项目 × 1MB = 10MB。</li>\n<li>pnpm：1 个全局缓存 × 1MB = 1MB。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>2. 快速的安装速度</strong></h3>\n<ul>\n<li><strong>依赖复用</strong>  ：\n<ul>\n<li>由于硬链接机制，pnpm 在安装依赖时只需创建链接，无需重新下载和复制文件。</li>\n<li><strong>效果</strong>  ：安装速度比 npm 和 yarn 快数倍，尤其在大型 Monorepo 项目中表现突出。</li>\n</ul>\n</li>\n<li><strong>并行安装</strong>  ：\n<ul>\n<li>pnpm 支持并行安装多个依赖包，进一步提升安装效率。</li>\n</ul>\n</li>\n<li><strong>实际数据</strong>  ：\n<ul>\n<li>在包含 1000 个依赖的大型项目中，pnpm 的安装时间可能比 npm 快 50% 以上。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>3. 精确的依赖管理</strong></h3>\n<ul>\n<li><strong>扁平化 node_modules 结构</strong>  ：\n<ul>\n<li>pnpm 采用扁平化结构，但避免了 npm 的依赖冲突问题。</li>\n<li><strong>效果</strong>  ：确保每个包都能访问到正确的依赖版本，减少版本冲突。</li>\n</ul>\n</li>\n<li><strong>严格的依赖隔离</strong>  ：\n<ul>\n<li>每个包的依赖都被严格隔离，不会影响到其他包。</li>\n<li><strong>示例</strong>  ：\n<ul>\n<li>项目 A 依赖 <code>lodash@4.17.21</code>，项目 B 依赖 <code>lodash@4.17.20</code>。</li>\n<li>pnpm 会为两个项目分别链接到全局缓存中的不同版本，避免冲突。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>4. 高效的 Monorepo 支持</strong></h3>\n<ul>\n<li><strong>工作区（Workspace）功能</strong>  ：\n<ul>\n<li>pnpm 原生支持 Monorepo 架构，通过 <code>pnpm-workspace.yaml</code> 文件轻松管理多个包。</li>\n<li><strong>效果</strong>  ：简化大型项目的依赖管理，提升开发效率。</li>\n</ul>\n</li>\n<li><strong>共享依赖</strong>  ：\n<ul>\n<li>工作区中的包可以共享依赖，减少重复安装。</li>\n<li><strong>示例</strong>  ：\n<ul>\n<li>Monorepo 中有 10 个包，每个包都依赖 <code>react</code>。</li>\n<li>pnpm 只需在根目录安装一次 <code>react</code>，所有包共享该依赖。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>5. 安全性与稳定性</strong></h3>\n<ul>\n<li><strong>内容可寻址存储</strong>  ：\n<ul>\n<li>pnpm 使用内容可寻址存储，确保依赖包的完整性和一致性。</li>\n<li><strong>效果</strong>  ：防止依赖包被篡改，提升项目安全性。</li>\n</ul>\n</li>\n<li><strong>锁定文件（pnpm-lock.yaml）</strong>  ：\n<ul>\n<li>pnpm 生成精确的锁定文件，确保团队成员安装相同版本的依赖。</li>\n<li><strong>对比 npm/yarn</strong>  ：\n<ul>\n<li>pnpm 的锁定文件更详细，能准确还原依赖树。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>6. 灵活的依赖提升（Hoisting）控制</strong></h3>\n<ul>\n<li><strong>自动依赖提升</strong>  ：\n<ul>\n<li>pnpm 会自动将公共依赖提升到根目录，减少重复安装。</li>\n<li><strong>效果</strong>  ：优化依赖结构，提升安装速度。</li>\n</ul>\n</li>\n<li><strong>手动控制</strong>  ：\n<ul>\n<li>开发者可以通过配置手动控制依赖提升行为，满足特殊需求。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>7. 丰富的插件生态</strong></h3>\n<ul>\n<li><strong>插件系统</strong>  ：\n<ul>\n<li>pnpm 支持丰富的插件，扩展功能强大。</li>\n<li><strong>示例</strong>  ：\n<ul>\n<li><code>pnpm-check-updates</code>：检查依赖更新。</li>\n<li><code>pnpm-audit</code>：安全审计依赖。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>与 CI/CD 集成</strong>  ：\n<ul>\n<li>pnpm 易于与 CI/CD 工具集成，支持自动化构建和部署。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>8. 跨平台兼容性</strong></h3>\n<ul>\n<li><strong>支持多平台</strong>  ：\n<ul>\n<li>pnpm 在 Windows、macOS 和 Linux 上表现一致，无需额外配置。</li>\n<li><strong>对比 npm</strong>  ：\n<ul>\n<li>npm 在 Windows 上可能存在路径长度限制问题。</li>\n<li>pnpm 通过符号链接和硬链接机制，避免此类问题。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>9. 开源与社区支持</strong></h3>\n<ul>\n<li><strong>活跃的社区</strong>  ：\n<ul>\n<li>pnpm 拥有活跃的开源社区，更新频繁，问题响应迅速。</li>\n<li><strong>GitHub</strong>  ：\n<ul>\n<li>星标数超过 20,000，贡献者众多。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>企业支持</strong>  ：\n<ul>\n<li>被多家大型企业采用，如阿里巴巴、腾讯等。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>10. 易于迁移</strong></h3>\n<ul>\n<li><strong>从 npm/yarn 迁移</strong>  ：\n<ul>\n<li>pnpm 提供简单的迁移工具，支持从 npm 或 yarn 无缝迁移。</li>\n<li><strong>命令示例</strong>  ：<pre><code class="language-sh">pnpm import\n</code></pre>\n<ul>\n<li>自动生成 <code>pnpm-lock.yaml</code> 和 <code>pnpm-workspace.yaml</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>总结：pnpm 的核心优势</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>优势</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>节省磁盘空间</strong></td>\n<td>通过硬链接机制，多个项目共享依赖包，减少磁盘占用。</td>\n</tr>\n<tr>\n<td><strong>快速安装</strong></td>\n<td>依赖复用和并行安装，提升安装速度。</td>\n</tr>\n<tr>\n<td><strong>精确的依赖管理</strong></td>\n<td>扁平化结构，避免依赖冲突，确保每个包使用正确版本。</td>\n</tr>\n<tr>\n<td><strong>高效的 Monorepo 支持</strong></td>\n<td>原生支持工作区，简化大型项目管理。</td>\n</tr>\n<tr>\n<td><strong>安全性与稳定性</strong></td>\n<td>内容可寻址存储，精确的锁定文件，确保依赖一致性。</td>\n</tr>\n<tr>\n<td><strong>灵活的依赖提升</strong></td>\n<td>自动提升公共依赖，同时支持手动控制。</td>\n</tr>\n<tr>\n<td><strong>丰富的插件生态</strong></td>\n<td>支持多种插件，扩展功能强大。</td>\n</tr>\n<tr>\n<td><strong>跨平台兼容性</strong></td>\n<td>在 Windows、macOS 和 Linux 上表现一致。</td>\n</tr>\n<tr>\n<td><strong>开源与社区支持</strong></td>\n<td>活跃的开源社区，企业支持广泛。</td>\n</tr>\n<tr>\n<td><strong>易于迁移</strong></td>\n<td>提供迁移工具，支持从 npm/yarn 无缝迁移。</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>结论</strong>  ：pnpm 通过其独特的硬链接机制、高效的依赖管理和对 Monorepo 的原生支持，成为现代 JavaScript/TypeScript 项目中依赖管理的优选工具。对于需要管理大量依赖或采用 Monorepo 架构的团队，pnpm 能显著提升开发效率和项目稳定性。</p>\n</div>'</script></body></html>