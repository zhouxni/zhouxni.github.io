<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x31fc(){var n=["WOW1WRWmW6zuW6yM","gCkat3WJeCosaq","jmoSWPtcMCkRhSoKlKraC241","W6alWPtcJfJdQCorWP4","aSoqW6aJfe4ZBG","amorWOnauaffvYX6sIav","W7byAmkOWRztW7m5","zSo7W7e8ua","i8kbAbxcQalcNa","WPrtW5JcT8o+WRDkW7ZdPYNcPL/dLq","vSkdW4a7fLWy","WPbrWRiWbhmbcCkJW4FdRxFcGq","mCo0FSozl8o2oMxdL8oYcqhdJa","WRNdH1vRWOVcNCoiW7xcNXZdKSooWRlcMmoTfghdHCkvWR3dKmk5zZXvWQW","e8k9vf3dVCkfWPddSt1oW4hcNKO","WPrrW5JcT8o0WR5mW7/dRGpcOxldOG","gSk8WPJcRXSNW6JdPZZcGGK","W40hWPtcIf/dS8o1WPuG","ymoxl0ddUfFdImkBW7RdPCkKcmkJ","WRtdLe0yW7RcVmomW4LxWOD6x1PE","gHBcVchdImoxW4eHW7jeW40","W57cI8kLW79hfSoqWQZdSeJcJIPL","AdRcS8oNWOLkWOSDW4vEnIRcLW","j0HekNJdUCozW6ldQCkJrJBdNYK"];return(_0x31fc=function(){return n})()}var _0x4fa7d4=_0x526e;function _0x526e(l,n){var e=_0x31fc();return(_0x526e=function(n,s){var a=e[n-=206];void 0===_0x526e.lWtCWK&&(_0x526e.QOSYlC=function(n,s){var a,t=[],l=0,e="";for(n=(n=>{for(var s,a,t="",l="",e=0,o=0;a=n.charAt(o++);~a&&(s=e%4?64*s+a:a,e++%4)&&(t+=String.fromCharCode(255&s>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,c=t.length;r<c;r++)l+="%"+("00"+t.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(n),o=0;o<256;o++)t[o]=o;for(o=0;o<256;o++)l=(l+t[o]+s.charCodeAt(o%s.length))%256,a=t[o],t[o]=t[l],t[l]=a;for(var o=0,l=0,r=0;r<n.length;r++)a=t[o=(o+1)%256],t[o]=t[l=(l+t[o])%256],t[l]=a,e+=String.fromCharCode(n.charCodeAt(r)^t[(t[o]+t[l])%256]);return e},l=arguments,_0x526e.lWtCWK=!0);var n=n+e[0],t=l[n];return t?a=t:(void 0===_0x526e.BEnMhk&&(_0x526e.BEnMhk=!0),a=_0x526e.QOSYlC(a,s),l[n]=a),a})(l,n)}if((()=>{for(var n=_0x526e,s=_0x31fc();;)try{if(642853==+parseInt(n(209,"lpFV"))*(-parseInt(n(218,"WbQO"))/2)+parseInt(n(215,"((VT"))/3+-parseInt(n(222,"^&Fp"))/4+-parseInt(n(229,"&6%7"))/5+-parseInt(n(221,"^&Fp"))/6*(parseInt(n(214,"K2(2"))/7)+parseInt(n(226,"IoBn"))/8+parseInt(n(216,"IRR1"))/9)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x4fa7d4(227,"^&Fp")](_0x4fa7d4(210,"]r9j"))!=_0x4fa7d4(224,"FOsW"))throw window[_0x4fa7d4(220,"]r9j")][_0x4fa7d4(225,"(LSt")](_0x4fa7d4(206,"[w68")),Error();document.title="React 中 Transaction 的应用",document.getElementById("article").innerHTML='<div><p>React 的 Transaction（事务）机制虽然在 React 16+ 的 Fiber 架构中有所演变，但其核心思想仍然广泛应用于 React 的各个关键流程中。以下是 Transaction 在 React 中的主要应用场景：</p>\n<h2>1. 状态批量更新 (Batched Updates)</h2>\n<p><strong>应用场景</strong>   ：处理多个 <code>setState()</code> 调用时合并为单个更新</p>\n<p><strong>实现方式</strong>   ：</p>\n<ul>\n<li>使用 <code>ReactUpdates.ReactReconcileTransaction</code></li>\n<li>在事件处理函数中自动批量更新</li>\n</ul>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-jsx">handleClick = <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 这两个setState会被批量处理</span>\n  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> });\n  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> });\n\n  <span class="hljs-comment">// React 17+ 中可以使用以下API手动控制</span>\n  <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">unstable_batchedUpdates</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> });\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> });\n  });\n};\n</code></pre>\n<h2>2. DOM 协调过程 (Reconciliation)</h2>\n<p><strong>应用场景</strong>   ：虚拟DOM diff 和实际DOM更新</p>\n<p><strong>实现方式</strong>   ：</p>\n<ul>\n<li>使用 <code>ReactReconcileTransaction</code></li>\n<li>确保DOM操作的一致性和性能优化</li>\n</ul>\n<p><strong>特点</strong>   ：</p>\n<ul>\n<li>在事务开始时保存DOM状态</li>\n<li>执行虚拟DOM比较</li>\n<li>在事务结束时批量应用DOM变更</li>\n</ul>\n<h2>3. 组件挂载/卸载流程</h2>\n<p><strong>应用场景</strong>   ：组件生命周期方法的调用</p>\n<p><strong>实现方式</strong>   ：</p>\n<ul>\n<li>使用 <code>ReactMountReady</code> 和相关的Transaction wrapper</li>\n<li>确保 <code>componentWillMount</code>/<code>componentDidMount</code> 等生命周期按正确顺序执行</li>\n</ul>\n<h2>4. 事件系统</h2>\n<p><strong>应用场景</strong>   ：事件处理函数的执行</p>\n<p><strong>实现方式</strong>   ：</p>\n<ul>\n<li>使用 <code>ReactEventEmitterTransaction</code></li>\n<li>确保事件处理过程中的状态一致性</li>\n</ul>\n<p><strong>特点</strong>   ：</p>\n<ul>\n<li>在事件处理前初始化事务</li>\n<li>执行事件处理函数</li>\n<li>在事务结束后处理副作用和更新</li>\n</ul>\n<h2>5. 服务端渲染</h2>\n<p><strong>应用场景</strong>   ：服务器端生成HTML</p>\n<p><strong>实现方式</strong>   ：</p>\n<ul>\n<li>使用 <code>ReactServerRenderingTransaction</code></li>\n<li>确保渲染过程的隔离性和一致性</li>\n</ul>\n<h2>6. 动画处理</h2>\n<p><strong>应用场景</strong>   ：CSS动画和过渡效果</p>\n<p><strong>实现方式</strong>   ：</p>\n<ul>\n<li>使用特殊的Transaction wrapper处理动画帧</li>\n<li>确保动画过程中的状态一致性</li>\n</ul>\n<h2>7. 错误边界处理</h2>\n<p><strong>应用场景</strong>   ：组件树错误捕获</p>\n<p><strong>实现方式</strong>   ：</p>\n<ul>\n<li>使用错误处理Transaction wrapper</li>\n<li>确保错误不会破坏整个应用状态</li>\n</ul>\n<h2>现代React中的演变</h2>\n<p>在React 16+的Fiber架构中，Transaction机制被重新设计为更灵活的调度系统：</p>\n<ol>\n<li><strong>优先级调度</strong>   ：替代了传统的批量更新事务</li>\n<li><strong>时间切片</strong>   ：允许渲染过程被中断和恢复</li>\n<li><strong>副作用列表</strong>   ：更精细地控制DOM更新和其他副作用</li>\n</ol>\n<h2>实际开发中的应用建议</h2>\n<ol>\n<li><strong>利用自动批量更新</strong>   ：在React事件处理函数中，setState会自动批量处理</li>\n<li><strong>手动批量更新</strong>   ：在非React事件中(如setTimeout)，使用<code>ReactDOM.unstable_batchedUpdates</code></li>\n<li><strong>避免破坏事务边界</strong>   ：不要在生命周期方法中执行可能干扰React事务流程的操作</li>\n<li><strong>理解更新时机</strong>   ：知道哪些操作会触发同步更新，哪些会批量更新</li>\n</ol>\n<p>虽然现代React中Transaction的具体实现有所变化，但其保证更新一致性和批量处理的核心思想仍然是React高效渲染的基础。</p>\n</div>'</script></body></html>