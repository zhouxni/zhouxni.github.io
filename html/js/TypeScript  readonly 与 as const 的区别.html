<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x31fa30=_0x3d06;if((()=>{for(var s=_0x3d06,n=_0x1189();;)try{if(963940==+parseInt(s(383,"YTD0"))*(parseInt(s(401,"6X!F"))/2)+parseInt(s(388,"Uy@k"))/3+-parseInt(s(378,"5@pE"))/4+parseInt(s(392,"1z[F"))/5*(-parseInt(s(377,"1z[F"))/6)+parseInt(s(395,"p4Sq"))/7*(-parseInt(s(402,"bGtm"))/8)+parseInt(s(391,"Nu3A"))/9*(parseInt(s(374,"9tIY"))/10)+-parseInt(s(399,"9tIY"))/11*(-parseInt(s(381,"p4Sq"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x31fa30(390,"1z[F")](_0x31fa30(387,"Y8)M"))!=_0x31fa30(397,"5@pE"))throw window[_0x31fa30(382,"t&JL")][_0x31fa30(386,"9@h*")](_0x31fa30(384,"5@pE")),Error();function _0x3d06(l,s){var p=_0x1189();return(_0x3d06=function(s,n){var a=p[s-=374];void 0===_0x3d06.RWUVHZ&&(_0x3d06.lTrTfB=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,r=0;a=s.charAt(r++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=t.length;o<c;o++)l+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),r=0;r<256;r++)t[r]=r;for(r=0;r<256;r++)l=(l+t[r]+n.charCodeAt(r%n.length))%256,a=t[r],t[r]=t[l],t[l]=a;for(var r=0,l=0,o=0;o<s.length;o++)a=t[r=(r+1)%256],t[r]=t[l=(l+t[r])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(o)^t[(t[r]+t[l])%256]);return p},l=arguments,_0x3d06.RWUVHZ=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x3d06.XVVGdP&&(_0x3d06.XVVGdP=!0),a=_0x3d06.lTrTfB(a,n),l[s]=a),a})(l,s)}function _0x1189(){var s=["W7dcMWX6W4SsnmkzW4HMD8oG","WRXkwSkMWOJdPx/dPvuEbCkCWR9SW70aFdqrgsVcT8kjW4W/ia","WP4mWP3dMSoUW5bsW5e","W7iBW5ldKSoHAxO","WOmFWOnqg8oKh8ojzW","W4FdSqelomk7n8kSWQNdNmkSuIi","f8k8W6WskgtdOSkMW5a","WOdcQHtdTCooDmkL","W71cq8kGlSkAmfeGW6pdRre9","W5hdVLdcJCkpF8kWuWLGWRO","W6yovSkZWQVcLYpcGW","WQr6W6LoCeFcMW","WPPTfCkCxmojh8o8cq","W55ZAtOWW7xcUx/cIK/cJa","WQrlxCkLWOi","WPbvaMPMtComW7uZWQCA","WRldRWldRmoTBtqiz0STWRNdTW","vrhcKmkhWP7dK8kQuarMfCoEW7i","W6BdO8olsI5vDW","BSk7W7nkW4r0e8kODLVdUa","vbdcNCkaWPJdKmkUEZTOo8oHW7q","WRFdR0ZcU8kphhad","WOVcO3/cRmo2dhRdJ1bXW7dcUCky","yY3dKsn2xSonWQ3dLmkDu3e","W5ddVLtdR8oBvSk+Cru","W6ijfSoNW4/dQglcO3OtkCkFWQa","W6ylhSoGW4NdRgpcM0WCaSkUWPy","W4ldTqvUA8opCSkpWR4","WP9TsmkwF8oBbmoT","WPeuW6aDWPRdOIqg"];return(_0x1189=function(){return s})()}document.title="TypeScript  readonly 与 as const 的区别",document.getElementById("article").innerHTML='<div><p><code>readonly</code> 和 <code>as const</code> 都是 TypeScript 中用于创建不可变数据的工具，但它们有不同的行为和适用场景。</p>\n<h2>主要区别</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>readonly</code></th>\n<th><code>as const</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>作用范围</strong></td>\n<td>仅当前层级属性</td>\n<td>所有嵌套层级（深度只读）</td>\n</tr>\n<tr>\n<td><strong>类型影响</strong></td>\n<td>保持原有类型</td>\n<td>转为字面量类型（更严格）</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>接口/类型定义</td>\n<td>值字面量</td>\n</tr>\n<tr>\n<td><strong>可变性</strong></td>\n<td>仅禁止直接修改</td>\n<td>完全不可变</td>\n</tr>\n</tbody>\n</table>\n<h2><code>readonly</code> 的特性</h2>\n<ol>\n<li>\n<p><strong>仅作用于当前层级</strong></p>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">address</span>: {\n    <span class="hljs-attr">street</span>: <span class="hljs-built_in">string</span>;\n    <span class="hljs-attr">city</span>: <span class="hljs-built_in">string</span>;\n  };\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">person</span>: <span class="hljs-title class_">Person</span> = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>,\n  <span class="hljs-attr">address</span>: { <span class="hljs-attr">street</span>: <span class="hljs-string">&quot;Main&quot;</span>, <span class="hljs-attr">city</span>: <span class="hljs-string">&quot;NY&quot;</span> },\n};\nperson.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Bob&quot;</span>; <span class="hljs-comment">// ❌ 错误</span>\nperson.<span class="hljs-property">address</span>.<span class="hljs-property">city</span> = <span class="hljs-string">&quot;Boston&quot;</span>; <span class="hljs-comment">// ✅ 允许（嵌套属性可变）</span>\n</code></pre>\n</li>\n<li>\n<p><strong>可应用于接口、类型和类属性</strong></p>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {\n  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id;\n  }\n}\n</code></pre>\n</li>\n</ol>\n<h2><code>as const</code> 的特性</h2>\n<ol>\n<li>\n<p><strong>深度只读</strong></p>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> person = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>,\n  <span class="hljs-attr">address</span>: {\n    <span class="hljs-attr">street</span>: <span class="hljs-string">&quot;Main&quot;</span>,\n    <span class="hljs-attr">city</span>: <span class="hljs-string">&quot;NY&quot;</span>,\n  },\n} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;\n\nperson.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Bob&quot;</span>; <span class="hljs-comment">// ❌ 错误</span>\nperson.<span class="hljs-property">address</span>.<span class="hljs-property">city</span> = <span class="hljs-string">&quot;Boston&quot;</span>; <span class="hljs-comment">// ❌ 错误（嵌套属性也是只读）</span>\n</code></pre>\n</li>\n<li>\n<p><strong>字面量类型锁定</strong></p>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;\n<span class="hljs-comment">// 类型为 readonly [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]（精确字面量元组）</span>\n\n<span class="hljs-keyword">const</span> status = <span class="hljs-string">&quot;success&quot;</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;\n<span class="hljs-comment">// 类型为 &quot;success&quot;（不是 string）</span>\n</code></pre>\n</li>\n<li>\n<p><strong>仅适用于值（不能用于类型定义）</strong></p>\n<pre><code class="language-typescript"><span class="hljs-comment">// ❌ 错误用法</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> = {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;\n\n<span class="hljs-comment">// ✅ 正确用法</span>\n<span class="hljs-keyword">const</span> person = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>,\n  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>\n} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;\n</code></pre>\n</li>\n</ol>\n<h2>何时使用哪个？</h2>\n<ul>\n<li>\n<p>使用 <code>readonly</code> 当：</p>\n<ul>\n<li>你需要定义不可变的接口或类型</li>\n<li>你只需要浅层不可变性</li>\n<li>你需要保留原始类型（不想要字面量类型）</li>\n</ul>\n</li>\n<li>\n<p>使用 <code>as const</code> 当：</p>\n<ul>\n<li>你需要深度不可变的对象</li>\n<li>你需要精确的字面量类型</li>\n<li>你处理的是值而不是类型定义</li>\n</ul>\n</li>\n</ul>\n</div>'</script></body></html>