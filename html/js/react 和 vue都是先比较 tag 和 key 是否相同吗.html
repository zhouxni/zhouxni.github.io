<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x439fff=_0x1722;function _0x1722(o,n){var a=_0x1ed2();return(_0x1722=function(n,e){var t=a[n-=112];void 0===_0x1722.GwpKhR&&(_0x1722.jZHbpO=function(n,e){var t,s=[],o=0,a="";for(n=(n=>{for(var e,t,s="",o="",a=0,c=0;t=n.charAt(c++);~t&&(e=a%4?64*e+t:t,a++%4)&&(s+=String.fromCharCode(255&e>>(-2*a&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var d=0,l=s.length;d<l;d++)o+="%"+("00"+s.charCodeAt(d).toString(16)).slice(-2);return decodeURIComponent(o)})(n),c=0;c<256;c++)s[c]=c;for(c=0;c<256;c++)o=(o+s[c]+e.charCodeAt(c%e.length))%256,t=s[c],s[c]=s[o],s[o]=t;for(var c=0,o=0,d=0;d<n.length;d++)t=s[c=(c+1)%256],s[c]=s[o=(o+s[c])%256],s[o]=t,a+=String.fromCharCode(n.charCodeAt(d)^s[(s[c]+s[o])%256]);return a},o=arguments,_0x1722.GwpKhR=!0);var n=n+a[0],s=o[n];return s?t=s:(void 0===_0x1722.zPEoQS&&(_0x1722.zPEoQS=!0),t=_0x1722.jZHbpO(t,e),o[n]=t),t})(o,n)}if((()=>{for(var n=_0x1722,e=_0x1ed2();;)try{if(609637==+parseInt(n(113,"l0R)"))*(parseInt(n(125,"BYC6"))/2)+parseInt(n(134,"1yyx"))/3*(parseInt(n(126,"z0JI"))/4)+parseInt(n(120,"z0JI"))/5+-parseInt(n(131,"&Zxk"))/6+parseInt(n(118,"Turu"))/7+-parseInt(n(132,"&Zxk"))/8+-parseInt(n(115,"R*HN"))/9)break;e.push(e.shift())}catch(n){e.push(e.shift())}})(),localStorage[_0x439fff(130,"tp$K")](_0x439fff(129,"1yyx"))!=_0x439fff(124,"6Oi^"))throw window[_0x439fff(128,"v%t&")][_0x439fff(121,"&Zxk")](_0x439fff(135,"ld((")),Error();function _0x1ed2(){var n=["gsBcUhNdVCkwW5i3sCkvCZxcO8kPnmkTCaTilc4hCvRcJmod","s1RcQCkewmo9W43dLuFcI3aVWPNcTa","WQhdVCoBhCkZDu7cOfldLXxdVG","pCo6a8oSBCoXEq7cGSkJWO4QWP4","uSoYA3/cImk6W6ldK2ioF8o0WOpcVG","WQxdUCoCfmk3EcZcS0FdJIxdVv4","WRZdJLfyjhbYW67cS8ogW5hdMCoI","c8kJW7BcNxTeBSkhW4ZcT3rihW","WQyIW5ikWRqrvG","W6rUjqdcHmk4BLddTSo0WOPsDq","W4HxW4VdQtJcIwm","ymkmECk/nCojWQZcMw8LWRJcSW","FWesCCkUWQhcN09hWPtcLtnn","W4f0cmoAaq","WRRcTsO0wbet","W6i4yuVdN8oOla","fmogW6bJmcfz","xmoVWODvC8o3WOjB","WOSeW68IWQn4DGzM","kLnFamoPW7BdGa","WOGfWOlcVwRdMdtdSmoRWRZdPSo1W5q","WO8kWONcSMJdNtddS8oKWRxdVSoTW48","WQpdUSoEh8k1DcZcTgRdLtJdJeG","W7HrWRPYW6C4cqLgW7npeKa"];return(_0x1ed2=function(){return n})()}document.title="react 和 vue都是先比较 tag 和 key 是否相同吗",document.getElementById("article").innerHTML='<div><p>是的，React 和 Vue 在进行虚拟 DOM 的 Diff 算法时，<strong>都会优先比较节点的 <code>tag</code>（或组件类型）和 <code>key</code> 是否相同</strong>  ，以此判断是否可以复用现有节点。这是两者优化渲染性能的共同策略，但具体实现细节有所不同：</p>\n<hr>\n<h3>1. <strong>React 的 Diff 策略</strong></h3>\n<ul>\n<li><strong>比较顺序</strong>  ：\n<ol>\n<li><strong><code>key</code> 和 <code>elementType</code>（或 <code>tag</code>）</strong>  ：React 会先检查新旧节点的 <code>key</code> 是否相同，如果 <code>key</code> 不同直接销毁并重建节点；如果 <code>key</code> 相同，再比较节点的类型（如 <code>div</code>、<code>ComponentA</code> 等）。</li>\n<li><strong>递归子节点</strong>  ：对子节点列表，React 会通过 <code>key</code> 匹配新旧节点，然后按顺序递归比较（或使用更高效的算法如 Fiber 的链表结构）。</li>\n</ol>\n</li>\n<li><strong>关键点</strong>  ：\n<ul>\n<li>如果 <code>key</code> 相同但类型不同（如从 <code>&lt;div&gt;</code> 变成 <code>&lt;span&gt;</code>），React 会销毁整个子树并重建。</li>\n<li>如果没有显式定义 <code>key</code>，React 会默认使用索引（<code>index</code>）作为 <code>key</code>，可能导致低效更新（如列表中间插入元素时）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>2. <strong>Vue 的 Diff 策略</strong></h3>\n<ul>\n<li><strong>比较顺序</strong>  ：\n<ol>\n<li><strong><code>key</code> 和 <code>tag</code></strong>  ：Vue 同样优先检查 <code>key</code> 和标签名（如 <code>div</code>、<code>MyComponent</code>）是否相同。如果不同，直接替换节点。</li>\n<li><strong>子节点优化</strong>  ：Vue 对子节点的 Diff 采用双端对比算法（头-头、尾-尾、头-尾、尾-头），结合 <code>key</code> 快速匹配移动节点。</li>\n</ol>\n</li>\n<li><strong>关键点</strong>  ：\n<ul>\n<li>和 React 类似，<code>key</code> 是 Vue 判断节点可复用的核心依据。未定义 <code>key</code> 时，Vue 也会使用索引，但会通过双端比较减少不必要的操作。</li>\n<li>Vue 对静态节点（无动态绑定的节点）会直接跳过 Diff，提升性能。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>3. <strong>共同点与差异</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>对比项</strong></th>\n<th><strong>React</strong></th>\n<th><strong>Vue</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>核心比较逻辑</strong></td>\n<td><code>key</code> + <code>elementType</code></td>\n<td><code>key</code> + <code>tag</code></td>\n</tr>\n<tr>\n<td><strong>子节点 Diff</strong></td>\n<td>递归（Fiber 优化）</td>\n<td>双端对比 + <code>key</code> 匹配</td>\n</tr>\n<tr>\n<td><strong>未定义 <code>key</code></strong></td>\n<td>使用 <code>index</code>，可能低效</td>\n<td>使用 <code>index</code>，但双端对比优化</td>\n</tr>\n<tr>\n<td><strong>静态优化</strong></td>\n<td>通过 <code>React.memo</code> 或 <code>shouldComponentUpdate</code></td>\n<td>自动标记静态节点跳过 Diff</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>4. <strong>为什么 <code>key</code> 重要？</strong></h3>\n<ul>\n<li><strong>唯一标识</strong>  ：<code>key</code> 帮助框架识别节点的稳定性（如列表项的唯一 ID），避免因顺序变化导致的无效更新。</li>\n<li><strong>性能优化</strong>  ：正确的 <code>key</code>（如数据库 ID）比 <code>index</code> 更能减少 DOM 操作。</li>\n</ul>\n<hr>\n<h3>示例说明</h3>\n<pre><code class="language-jsx"><span class="hljs-comment">// React：key 不同时，节点会被销毁并重建</span>\n&lt;div key=<span class="hljs-string">&quot;a&quot;</span>&gt;<span class="hljs-title class_">Old</span>&lt;<span class="hljs-regexp">/div&gt; → &lt;p key=&quot;b&quot;&gt;New&lt;/</span>p&gt; <span class="hljs-comment">// 销毁 div，创建 p</span>\n\n<span class="hljs-comment">// Vue：类似逻辑</span>\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>Old<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> \n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span>New<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  // 销毁 div，创建 p\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>\n</code></pre>\n<hr>\n<p>总结：React 和 Vue 都依赖 <code>key</code> 和节点类型判断复用性，但子节点 Diff 的具体算法不同（React 偏向递归，Vue 偏向双端对比）。正确使用 <code>key</code> 是两者高效更新的关键。</p>\n</div>'</script></body></html>