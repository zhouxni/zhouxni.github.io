<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2af8(e,n){var r=_0x30b3();return(_0x2af8=function(n,o){var d=r[n-=386];void 0===_0x2af8.zLlOEs&&(_0x2af8.tWhvAH=function(n,o){var d,t=[],e=0,r="";for(n=(n=>{for(var o,d,t="",e="",r=0,c=0;d=n.charAt(c++);~d&&(o=r%4?64*o+d:d,r++%4)&&(t+=String.fromCharCode(255&o>>(-2*r&6))))d="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(d);for(var i=0,l=t.length;i<l;i++)e+="%"+("00"+t.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(e)})(n),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)e=(e+t[c]+o.charCodeAt(c%o.length))%256,d=t[c],t[c]=t[e],t[e]=d;for(var c=0,e=0,i=0;i<n.length;i++)d=t[c=(c+1)%256],t[c]=t[e=(e+t[c])%256],t[e]=d,r+=String.fromCharCode(n.charCodeAt(i)^t[(t[c]+t[e])%256]);return r},e=arguments,_0x2af8.zLlOEs=!0);var n=n+r[0],t=e[n];return t?d=t:(void 0===_0x2af8.RgqHOr&&(_0x2af8.RgqHOr=!0),d=_0x2af8.tWhvAH(d,o),e[n]=d),d})(e,n)}var _0x18790d=_0x2af8;if((()=>{for(var n=_0x2af8,o=_0x30b3();;)try{if(377728==+parseInt(n(397,"E@gh"))*(-parseInt(n(400,"0s^$"))/2)+parseInt(n(390,"%oRP"))/3+parseInt(n(415,"vu##"))/4*(-parseInt(n(412,"J%Qg"))/5)+-parseInt(n(389,"lNv1"))/6*(-parseInt(n(386,"N4IG"))/7)+parseInt(n(405,"t]4M"))/8*(-parseInt(n(399,"wAgr"))/9)+-parseInt(n(393,"1yTy"))/10*(parseInt(n(403,"h*x7"))/11)+parseInt(n(407,"G&$!"))/12*(parseInt(n(404,"3InE"))/13))break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x18790d(416,"ic3g")](_0x18790d(402,")pPN"))!=_0x18790d(408,"#1(G"))throw window[_0x18790d(406,"qeA9")][_0x18790d(401,"qeA9")](_0x18790d(387,"]#Co")),Error();function _0x30b3(){var n=["lCkeyLJcUmkPWPqBW4LW","lI3cNCkkdLlcSa","W75BzCkYWORdJ0q","phL7r8k7W4FcMdhdLgRcHG","ECk6WRqLgN3dHLL8bwu","i8k2WOKBWO1FWQW","nSkXobHOntpdJ2S","zeldPqS6kmoQWPHWW7FdMwjy","W4xdPLiVFCkTnmo1WQPW","W6xdHIpdSNGtW5JdQmkk","pCk8WPOwWPHvWQBdUW","WRz5WRFcHNFcTeuKW4ZdMHu","W4FcNCkXbmkJ","W685W4pdHHWxWR0lCvD4","WRv2WRBcIxpdL3iPW57dRdjK","rCoLAuOTeIddNNHDrG","sxLBWRBcRcJcQ8oqWP8","W7fkWQmHvGH5m1ddNSkTWOddVG","W6yDWQBcVCozW7RdP8oOicfF","WOJdOKlcIcpcUSoEW73dKeBdOa","W4fbW5WZW6NdRmkc","bNxdL8oLW5z3WQXcW47dPCo9WRu","imoubmo6W6xcNshcSmk4W4CVW6hcV8otbx4kWQ7cTCo/W51vB8ooiwe","emo4vCk/WPpdUu7dSmoQgCk7","WP8XWPNcG8kfW7f7jW","BqGKWQddVuFdIvi+W4PmWQJdIq","ASk2ngZcRXBcPSofvW","WORdRKBdN03cQmoWW7JdRW","W4lcP8kyexiGaSkv","ECkqeSoUW77dQwZdVG","W57dQgqkW4Pjc8oG"];return(_0x30b3=function(){return n})()}document.title="IEEE 754 标准的 64 位双精度浮点数",document.getElementById("article").innerHTML="<div><p>IEEE 754 标准的 64 位双精度浮点数（Double-Precision Floating-Point，简称 <code>double</code>）是计算机中表示小数和大整数的核心格式，也是 JavaScript、Java、C++ 等主流语言中“数字”类型的底层实现。它通过<strong>固定的位分布</strong>   平衡了数值范围、精度和存储效率，以下从位结构、编码规则、数值范围、精度特性、特殊值等维度展开详解：</p>\n<h3>一、核心位结构：64位的三部分划分</h3>\n<p>64 位被严格划分为 <strong>符号位、指数位、尾数位</strong>   三部分，每部分功能独立，共同决定最终数值，具体分布如下（位位置从高位到低位，共 0-63 位，第 63 位为最高位）：</p>\n<table>\n<thead>\n<tr>\n<th>位范围（从高到低）</th>\n<th>位数</th>\n<th>名称</th>\n<th>核心作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>第 63 位</td>\n<td>1 位</td>\n<td>符号位（S）</td>\n<td>表示数值正负：<code>0</code> 为正数，<code>1</code> 为负数（正零和负零在此区分，运算中视为等价）</td>\n</tr>\n<tr>\n<td>第 62 位 ~ 第 52 位</td>\n<td>11 位</td>\n<td>指数位（E）</td>\n<td>存储指数的“偏移值”，用于表示数值的量级（范围覆盖极大/极小值）</td>\n</tr>\n<tr>\n<td>第 51 位 ~ 第 0 位</td>\n<td>52 位</td>\n<td>尾数位（M）</td>\n<td>存储有效数字的“小数部分”，通过“隐含首位 1”实现 53 位精度</td>\n</tr>\n</tbody>\n</table>\n<p><strong>结构示意图</strong>   （高位到低位）：<br>\n<code>[S] [E(11位)] [M(52位)]</code><br>\n即：<code>1位符号位 + 11位指数位 + 52位尾数位 = 64位</code></p>\n<h3>二、各部分编码规则：如何计算最终数值</h3>\n<p>64 位双精度浮点数的最终数值需通过 <strong>“符号位决定正负、指数位计算量级、尾数位计算精度”</strong>   三步推导，核心公式分为「规格化数」和「非规格化数」两类（规格化数是绝大多数场景的正常表示，非规格化数用于接近 0 的极小值）。</p>\n<h4>1. 规格化数（最常用，覆盖 99%+ 正常数值）</h4>\n<p>当 <strong>指数位 E 既不全为 0，也不全为 1</strong>   时，属于规格化数，此时数值计算公式为：<br>\n<code>Value = (-1)^S × (1 + M / 2^52) × 2^(E - 1023)</code></p>\n<p>对公式中各部分的拆解：</p>\n<ul>\n<li><strong>(-1)^S</strong>   ：由符号位 S 决定正负，S=0 时结果为 1（正数），S=1 时结果为 -1（负数）。</li>\n<li><strong>(1 + M / 2^52)</strong>   ：尾数位 M 的实际有效数字。<br>\n尾数位 M 是 52 位二进制数（范围 0 ~ 2^52 - 1），<code>M / 2^52</code> 表示将 52 位二进制转换为“小数点后的小数”（如 M=0b101 时，M/2^52 = 0.000...000101，共 49 个 0 后接 101）；<br>\n加上“隐含的首位 1”，最终有效数字为 <code>1.xxxx...</code>（类似科学计数法的 <code>1.×10ⁿ</code>），这是 64 位浮点数“用 52 位实现 53 位精度”的关键设计。</li>\n<li><strong>2^(E - 1023)</strong>   ：指数的实际量级。<br>\n11 位指数位 E 的范围是 0 ~ 2047（2^11 - 1），但规格化数中 E 排除了 0 和 2047（留给非规格化数和特殊值），实际 E 范围是 1 ~ 2046；<br>\n“1023” 是 11 位指数的 <strong>偏移值</strong>   （计算方式：2^(11-1) - 1 = 1023），用“E - 1023”得到实际指数（范围：1-1023 = -1022，2046-1023 = 1023），即数值的量级是 2 的 -1022 次方到 2 的 1023 次方。</li>\n</ul>\n<h4>2. 非规格化数（用于表示接近 0 的极小值）</h4>\n<p>当 <strong>指数位 E 全为 0</strong>   时，属于非规格化数，此时数值计算公式为：<br>\n<code>Value = (-1)^S × (M / 2^52) × 2^(-1022)</code></p>\n<p>与规格化数的核心区别：</p>\n<ul>\n<li>尾数位 M 不再隐含“首位 1”，而是隐含“首位 0”，有效数字变为 <code>0.xxxx...</code>（避免规格化数无法表示“比 2^-1022 更小的数”的问题）；</li>\n<li>实际指数固定为 <code>-1022</code>（而非 E-1023，因 E=0 时 0-1023=-1023，为统一量级，非规格化数指数上调 1 为 -1022）。</li>\n</ul>\n<p>非规格化数的作用是“平滑连接 0 和最小的规格化数”，避免数值表示的“断层”。</p>\n<h4>3. 特殊值（指数位 E 全为 1 时）</h4>\n<p>当 <strong>指数位 E 全为 1</strong>   时，不再表示正常数值，而是用于定义特殊值，具体由尾数位 M 决定：</p>\n<ul>\n<li><strong>无穷大（Infinity）</strong>   ：若 M 全为 0\n<ul>\n<li>S=0 时为 <strong>正无穷（+Infinity）</strong>   ，表示“大于所有有限数的数值”（如 1/0）；</li>\n<li>S=1 时为 <strong>负无穷（-Infinity）</strong>   ，表示“小于所有有限数的数值”（如 -1/0）。</li>\n</ul>\n</li>\n<li><strong>非数（NaN）</strong>   ：若 M 不全为 0<br>\n表示“无效的数值结果”（如 0/0、sqrt(-1)、Infinity - Infinity），NaN 有两个特性：\n<ol>\n<li>任何涉及 NaN 的运算结果仍是 NaN；</li>\n<li>NaN 不等于任何值（包括自身，需用 <code>isNaN()</code> 函数判断）。</li>\n</ol>\n</li>\n</ul>\n<h3>三、数值范围与精度特性</h3>\n<h4>1. 数值范围（可表示的有限数范围）</h4>\n<ul>\n<li><strong>最大值</strong>   ：规格化数的最大情况（S=0，E=2046，M=2^52-1）<br>\n计算：<code>(1 + (2^52-1)/2^52) × 2^(2046-1023) ≈ 1.7976931348623157 × 10^308</code>（即 <code>Number.MAX_VALUE</code>）。</li>\n<li><strong>最小值（正数）</strong>   ：非规格化数的最大情况（S=0，E=0，M=2^52-1）<br>\n计算：<code>(2^52-1)/2^52 × 2^(-1022) ≈ 2.2250738585072014 × 10^-308</code>（即 <code>Number.MIN_VALUE</code>）。</li>\n<li><strong>整数精确范围</strong>   ：由于尾数位（含隐含 1）共 53 位，整数在 <code>-2^53</code> 到 <code>2^53</code> 之间时可精确表示；超出此范围（如 <code>2^53 + 1</code>）会因尾数位无法容纳全部二进制位而丢失精度。<br>\n例：<code>2^53 = 9007199254740992</code>（精确），<code>2^53 + 1 = 9007199254740993</code>（实际存储为 9007199254740992，精度丢失）。</li>\n</ul>\n<h4>2. 精度特性（为什么会有“0.1 + 0.2 ≠ 0.3”？）</h4>\n<p>64 位双精度浮点数的精度约为 <strong>15-17 位十进制数字</strong>   ，但本质是“二进制精度”—— 部分十进制小数（如 0.1、0.2）无法用有限位二进制表示，会被存储为无限循环的二进制小数，导致计算误差。</p>\n<p>例：十进制 <code>0.1</code> 转换为二进制是 <code>0.0001100110011...</code>（循环节 <code>0011</code>），尾数位仅能存储前 52 位循环部分，导致实际存储值为 <code>0.10000000000000000555...</code>；同理 <code>0.2</code> 存储为 <code>0.2000000000000000111...</code>，两者相加结果为 <code>0.3000000000000000444...</code>，即 <code>0.1 + 0.2 = 0.30000000000000004</code>（而非 0.3）。</p>\n<h3>四、典型示例：拆解一个具体数值</h3>\n<p>以十进制 <code>5.5</code> 为例，看其如何用 64 位双精度浮点数表示：</p>\n<ol>\n<li><strong>转换为二进制</strong>   ：<code>5.5</code> 的二进制是 <code>101.1</code>。</li>\n<li><strong>标准化为规格化形式</strong>   ：<code>101.1 = 1.011 × 2^2</code>（类似科学计数法，确保整数部分为 1）。</li>\n<li><strong>分配各部分位</strong>   ：\n<ul>\n<li>符号位 S：正数，S=0（第 63 位为 0）；</li>\n<li>指数位 E：实际指数为 2，偏移值 1023，故 E=2+1023=1025，1025 的 11 位二进制是 <code>10000000001</code>（第 62-52 位为 <code>10000000001</code>）；</li>\n<li>尾数位 M：标准化后小数点后部分为 <code>011</code>，需补 0 至 52 位，即 <code>0110000000000000000000000000000000000000000000000000</code>（第 51-0 位）。</li>\n</ul>\n</li>\n<li><strong>最终 64 位表示</strong>   （二进制）：<br>\n<code>0 10000000001 0110000000000000000000000000000000000000000000000000</code></li>\n</ol>\n<h3>五、总结</h3>\n<p>IEEE 754 64 位双精度浮点数的设计核心是“用有限位实现大范围+可控精度”：</p>\n<ul>\n<li>1 位符号位覆盖正负，11 位指数位实现 <code>10^-308</code> 到 <code>10^308</code> 的量级，52 位尾数位（+隐含 1）提供 53 位二进制精度；</li>\n<li>规格化数是主流表示，非规格化数补全极小值范围，特殊值处理无穷和无效结果；</li>\n<li>精度限制导致部分十进制小数计算有误差，整数精确范围需注意 <code>-2^53</code> 到 <code>2^53</code> 边界。</li>\n</ul>\n<p>这一格式是现代计算机数值计算的基础，理解其原理能解释 JavaScript 等语言中“数字异常”（如 <code>0.1+0.2≠0.3</code>）的本质。</p>\n</div>"</script></body></html>