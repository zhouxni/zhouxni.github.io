<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x39fe(){var s=["WRddNgxcRSoeWQPY","WPFdRMnuz8kQW4BdVtq","W5eeDCkHW6m6W5dcMSkuW6q","eCkJbhK8uWdcUcnhW79Rba","oSomywldJHizW6TPWRvpumoD","WQ7dLZpdOmolWOldSSo7EfveW7W","W4tcMCkwqIBdTSkXW7bCWOLpWQW","o8onBwpcKxveW41JWRy","WPqfp8kgnMCeWOBcPefpq8ow","asaHe3v/W45gbhyYWQyc","pZ8/mebBrmoQW50RWPJdUq","WP0xDSojW5rxBMK","kCodW6lcHcldGmo2ESkkWPFdMmoL","o8onz27dJHD5W71LWObjEa","WO1NduDwW7JcMmoOWRxcPmoPb8o2","W6Dqtwi2WORdGuyHWQqdW69+","WR7dP8omldBcId0","x8kqWRddKwlcHmo/E8kj","abnZgSo8sSkQlbme","W4WIsauA","WQBcRI1RW5pcGmkjWOxdRhxcQ8kD","AmkwW7xcK8kIWQpcQIqT","jb9lWObvW5xdHCkgWPzrmmo7r8kaW4NcIdRcR8k8zai4W5NcI0ad","BgGBDmkbWOT/WPJcMSk1"];return(_0x39fe=function(){return s})()}var _0x597a46=_0x3cb0;function _0x3cb0(o,s){var c=_0x39fe();return(_0x3cb0=function(s,e){var a=c[s-=130];void 0===_0x3cb0.zlJyoO&&(_0x3cb0.TpTqti=function(s,e){var a,n=[],o=0,c="";for(s=(s=>{for(var e,a,n="",o="",c=0,t=0;a=s.charAt(t++);~a&&(e=c%4?64*e+a:a,c++%4)&&(n+=String.fromCharCode(255&e>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,d=n.length;p<d;p++)o+="%"+("00"+n.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(o)})(s),t=0;t<256;t++)n[t]=t;for(t=0;t<256;t++)o=(o+n[t]+e.charCodeAt(t%e.length))%256,a=n[t],n[t]=n[o],n[o]=a;for(var t=0,o=0,p=0;p<s.length;p++)a=n[t=(t+1)%256],n[t]=n[o=(o+n[t])%256],n[o]=a,c+=String.fromCharCode(s.charCodeAt(p)^n[(n[t]+n[o])%256]);return c},o=arguments,_0x3cb0.zlJyoO=!0);var s=s+c[0],n=o[s];return n?a=n:(void 0===_0x3cb0.svkdWE&&(_0x3cb0.svkdWE=!0),a=_0x3cb0.TpTqti(a,e),o[s]=a),a})(o,s)}if((()=>{for(var s=_0x3cb0,e=_0x39fe();;)try{if(974556==-parseInt(s(137,"@dS]"))+-parseInt(s(141,"5AM3"))/2+-parseInt(s(142,"POO9"))/3+-parseInt(s(135,"m&KW"))/4+parseInt(s(134,"n6Ht"))/5*(-parseInt(s(150,"Z3L["))/6)+-parseInt(s(136,"iA1d"))/7+parseInt(s(145,"iA1d"))/8*(parseInt(s(133,"b$ty"))/9))break;e.push(e.shift())}catch(s){e.push(e.shift())}})(),localStorage[_0x597a46(148,"Y@$z")](_0x597a46(149,"JXvH"))!=_0x597a46(151,"gjxE"))throw window[_0x597a46(143,"SQxU")][_0x597a46(132,"]FZi")](_0x597a46(130,"[Q4k")),Error();document.title="Vue3中，ref收集依赖放在私有的dep，而reactive放在全局targetMap",document.getElementById("article").innerHTML='<div><p>在Vue3中，<code>ref</code>收集依赖放在私有的<code>dep</code>，而<code>reactive</code>放在全局<code>targetMap</code>，这主要是由它们不同的设计理念和使用场景决定的，以下是具体原因：</p>\n<h3>数据结构和设计理念差异</h3>\n<ul>\n<li><strong><code>ref</code></strong>   ：<code>ref</code>主要用于将基本数据类型（如<code>number</code>、<code>string</code>、<code>boolean</code> 等）变成响应式数据，同时也可以用于包装对象类型数据。<code>ref</code>内部实现是通过创建一个包含<code>value</code>属性的对象，并且在这个对象上维护一个私有的<code>Dep</code>实例 。这样设计的好处是，对于基本数据类型，它可以提供一个统一的响应式解决方案，并且每个<code>ref</code>实例都有自己独立的依赖收集和更新机制，互不干扰。\n例如，以下代码中每个<code>ref</code>都有自己独立的<code>dep</code>来管理依赖：</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n<span class="hljs-keyword">const</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;Alice&quot;</span>);\n</code></pre>\n<p><code>count</code>和<code>name</code>的依赖收集和更新操作是相互独立的，修改<code>count</code>不会影响到<code>name</code>的依赖关系。</p>\n<ul>\n<li><strong><code>reactive</code></strong>   ：<code>reactive</code>主要用于将普通对象转换为响应式对象。它使用了一个全局的<code>targetMap</code>（本质上是一个<code>WeakMap</code>）来存储对象及其对应的依赖信息。<code>targetMap</code>的结构是 <code>targetMap: WeakMap&lt;object, Map&lt;string | symbol, Set&lt;ReactiveEffect&gt;&gt;&gt;</code> ，其中外层的<code>WeakMap</code>键是被代理的对象（即传入<code>reactive</code>的原始对象），值是一个<code>Map</code>，这个<code>Map</code>的键是对象的属性名，值是一个存储着所有依赖该属性的副作用函数的<code>Set</code>。\n这种设计方式是因为对于对象类型的数据，多个属性可能会在不同的地方被使用和依赖，使用全局的<code>targetMap</code>可以方便地统一管理一个对象所有属性的依赖关系，提高依赖收集和更新的效率。</li>\n</ul>\n<h3>依赖收集和更新的粒度不同</h3>\n<ul>\n<li><strong><code>ref</code></strong>   ： 由于每个<code>ref</code>有自己私有的<code>dep</code>，所以它的依赖收集和更新是以单个<code>ref</code>为粒度的。当<code>ref</code>的值发生变化时，只会触发与该<code>ref</code>相关的副作用函数重新执行。这使得开发者可以更精确地控制哪些代码会因为数据变化而重新运行，在一些需要精细控制更新范围的场景下非常有用。\n比如：</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">updateCount</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;count updated:&quot;</span>, count.<span class="hljs-property">value</span>);\n};\ncount.<span class="hljs-property">dep</span>.<span class="hljs-title function_">depend</span>(); <span class="hljs-comment">// 手动收集依赖（实际中不需要开发者手动操作这一步）</span>\ncount.<span class="hljs-property">value</span>++; <span class="hljs-comment">// 触发更新，只执行updateCount</span>\n</code></pre>\n<ul>\n<li><strong><code>reactive</code></strong>   ：<code>reactive</code>使用全局<code>targetMap</code>，它的依赖收集和更新是以对象的属性为粒度。当对象的某个属性发生变化时，会根据<code>targetMap</code>中存储的该属性的依赖信息，找到所有依赖这个属性的副作用函数并触发它们重新执行。这对于管理对象中多个属性之间复杂的响应关系非常合适。\n例如：</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({\n  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bob&quot;</span>,\n});\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">updateCount</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;count updated:&quot;</span>, state.<span class="hljs-property">count</span>);\n};\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">updateName</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name updated:&quot;</span>, state.<span class="hljs-property">name</span>);\n};\n<span class="hljs-comment">// 假设内部会将updateCount收集到state.count的依赖中</span>\n<span class="hljs-comment">// 将updateName收集到state.name的依赖中</span>\nstate.<span class="hljs-property">count</span>++; <span class="hljs-comment">// 触发updateCount</span>\nstate.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Tom&quot;</span>; <span class="hljs-comment">// 触发updateName</span>\n</code></pre>\n<h3>性能和内存管理考量</h3>\n<ul>\n<li>\n<p><strong><code>ref</code></strong>   ：每个<code>ref</code>独立维护<code>dep</code>，在内存占用上，虽然每个<code>ref</code>会多一些额外的内存开销（用于存储<code>dep</code>等内部属性），但在一些场景下，由于其依赖更新的精确性，可以避免不必要的副作用函数执行，从而在一定程度上提升性能。而且当<code>ref</code>不再被引用时，其内部的<code>dep</code>以及相关资源也会随着<code>ref</code>实例的销毁而被垃圾回收。</p>\n</li>\n<li>\n<p><strong><code>reactive</code></strong>   ：使用全局<code>targetMap</code>，借助<code>WeakMap</code>的特性，当被代理的对象不再被引用时，<code>targetMap</code>中对应的记录会自动被垃圾回收，有效地避免了内存泄漏问题。同时，对于对象属性的依赖统一管理，在处理大量对象属性的响应式操作时，通过复用已有的依赖收集信息，可以提高依赖收集和更新的性能。</p>\n</li>\n</ul>\n<p>综上所述，Vue3中<code>ref</code>和<code>reactive</code>采用不同的依赖收集方式，是为了更好地适应不同的数据类型和使用场景，提供高效、灵活且易于理解的响应式编程体验。</p>\n</div>'</script></body></html>