<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2be5(s,o){var l=_0x45ad();return(_0x2be5=function(o,n){var e=l[o-=263];void 0===_0x2be5.nAWcxP&&(_0x2be5.VfAnkf=function(o,n){var e,t=[],s=0,l="";for(o=(o=>{for(var n,e,t="",s="",l=0,a=0;e=o.charAt(a++);~e&&(n=l%4?64*n+e:e,l++%4)&&(t+=String.fromCharCode(255&n>>(-2*l&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var c=0,r=t.length;c<r;c++)s+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(s)})(o),a=0;a<256;a++)t[a]=a;for(a=0;a<256;a++)s=(s+t[a]+n.charCodeAt(a%n.length))%256,e=t[a],t[a]=t[s],t[s]=e;for(var a=0,s=0,c=0;c<o.length;c++)e=t[a=(a+1)%256],t[a]=t[s=(s+t[a])%256],t[s]=e,l+=String.fromCharCode(o.charCodeAt(c)^t[(t[a]+t[s])%256]);return l},s=arguments,_0x2be5.nAWcxP=!0);var o=o+l[0],t=s[o];return t?e=t:(void 0===_0x2be5.aowlJs&&(_0x2be5.aowlJs=!0),e=_0x2be5.VfAnkf(e,n),s[o]=e),e})(s,o)}var _0x235109=_0x2be5;function _0x45ad(){var o=["CmkDWRNdR8kWhSkozCotz3pcS8kVtW","WRJdUmkLkwddGSo5qmoEWQm","WQZcS8kaaJRdKwe","W47dOeFdVWVdTmk5WQPjW6pdTCkUWRBdHq","kCk2pCkxE8ksW7hdTmk1","xCoIAmohpmosW5/dPmkKW6z1nq","kYqxpLb9buPqsmkhjSknEa","B8klWPfChJJdGeBcJSktW5HvyG","W4PQWOilWRaFcSo4kHPqWPWtdq","wCoTgmkNumkpW5ddTa","WQ7cKIj2umkaCWS","ALmyW5JcI8oseq","kSotdsRdHmklWQ7dTuRcJmoQW5JcKa","qGRcNXdcVG","WQ3dTCo8F3BcJJxdTcTNW5KNW64","W6n2cNZcL3hcUt7cQCkLWQNcSay","gvXUk3hdPrGGqmkMWPtcTG","B1RdNSk2pH0UlKjv","W7LowSokeSkgW6K6FCk7saddM8oEhKPBuSklwr/dH8oJmrhcOG","omktb2lcM3ZdG8oy","DcFcLu9lrCoqmSkH","lIeCmfe/xdbDFCkr","WQLjwuldOCoLda","lsarnZa4DXP8wW","W7TDAupdRmoSbW","taNcMMOtWRqPumkkWP5p","W79uWQNcLgRdHCknW5xdVa","gvPRjWtcRZWqsCkv"];return(_0x45ad=function(){return o})()}if((()=>{for(var o=_0x2be5,n=_0x45ad();;)try{if(755274==+parseInt(o(271,"QSF@"))*(-parseInt(o(274,"E%t0"))/2)+parseInt(o(270,"anvE"))/3+-parseInt(o(268,"fPv4"))/4*(-parseInt(o(278,"r@e#"))/5)+-parseInt(o(273,"tpFK"))/6*(parseInt(o(266,"YM9R"))/7)+-parseInt(o(275,"1N[r"))/8*(parseInt(o(283,"VU(E"))/9)+-parseInt(o(285,"eM@q"))/10+parseInt(o(290,"qZ1a"))/11)break;n.push(n.shift())}catch(o){n.push(n.shift())}})(),localStorage[_0x235109(276,"r@e#")](_0x235109(286,"F)1A"))!=_0x235109(267,"1Mv7"))throw window[_0x235109(264,"4(k(")][_0x235109(265,"^Dyr")](_0x235109(272,"7p1w")),Error();document.title="react Fiber 节点 存储 hooks 链表",document.getElementById("article").innerHTML='<div><p>在 React 的 Fiber 架构中，Hooks 是通过链表结构存储在 Fiber 节点上的，这种设计使得 React 能够在函数组件中高效地管理和追踪状态及副作用。以下是关于 Fiber 节点如何存储 Hooks 链表的详细解释：</p>\n<h3>一、Hooks 链表存储机制</h3>\n<ol>\n<li><strong>Hooks 链表的结构</strong>  ：\n<ul>\n<li>每个 Fiber 节点都有一个 <code>memoizedState</code> 属性，用于存储与该节点相关的状态信息。</li>\n<li>对于函数组件，<code>memoizedState</code> 指向一个链表，这个链表就是 Hooks 链表。</li>\n<li>链表中的每个节点代表一个 Hook，包含 Hook 的类型（如 <code>useState</code>、<code>useEffect</code> 等）、当前状态值、以及指向下一个 Hook 的指针。</li>\n</ul>\n</li>\n<li><strong>Hooks 链表的创建与更新</strong>  ：\n<ul>\n<li>当 React 首次渲染函数组件时，它会根据组件中调用的 Hook 顺序创建 Hooks 链表。</li>\n<li>在后续更新中，React 会复用之前创建的 Hooks 链表，并根据新的状态值更新链表中的节点。</li>\n<li>这种复用机制确保了 Hook 在多次渲染之间保持稳定的身份和顺序。</li>\n</ul>\n</li>\n</ol>\n<h3>二、Hooks 链表的工作原理</h3>\n<ol>\n<li><strong>调用 Hook</strong>  ：\n<ul>\n<li>当函数组件调用 Hook（如 <code>useState</code>）时，React 会从当前 Fiber 节点的 <code>memoizedState</code> 属性开始遍历 Hooks 链表。</li>\n<li>如果找到对应类型的 Hook 节点，则更新其状态值；否则，在链表末尾添加一个新的 Hook 节点。</li>\n</ul>\n</li>\n<li><strong>状态更新</strong>  ：\n<ul>\n<li>当调用 <code>setState</code> 或其他更新函数时，React 会更新 Hooks 链表中对应 Hook 节点的状态值。</li>\n<li>然后，React 会标记当前 Fiber 节点有更新，以便在后续渲染过程中应用这些更新。</li>\n</ul>\n</li>\n<li><strong>渲染与提交</strong>  ：\n<ul>\n<li>在渲染阶段，React 会根据 Hooks 链表中的状态值生成新的 JSX 对象。</li>\n<li>在提交阶段，React 会将新的 JSX 对象应用到真实 DOM 上，并更新 Hooks 链表中的状态值以反映最新的 UI 状态。</li>\n</ul>\n</li>\n</ol>\n<h3>三、Hooks 链表的优势</h3>\n<ol>\n<li><strong>高效的状态管理</strong>  ：\n<ul>\n<li>通过链表结构，React 能够高效地管理和追踪函数组件中的状态及副作用。</li>\n<li>这种设计使得状态更新更加直观和可预测。</li>\n</ul>\n</li>\n<li><strong>稳定的 Hook 身份</strong>  ：\n<ul>\n<li>Hooks 链表确保了 Hook 在多次渲染之间保持稳定的身份和顺序。</li>\n<li>这使得 React 能够在不同渲染周期之间正确地关联和更新状态。</li>\n</ul>\n</li>\n<li><strong>灵活的组件设计</strong>  ：\n<ul>\n<li>Hooks 链表使得函数组件能够像类组件一样拥有状态、生命周期方法等特性。</li>\n<li>这提高了组件的灵活性和可复用性。</li>\n</ul>\n</li>\n</ol>\n<h3>四、示例说明</h3>\n<p>假设有一个简单的函数组件，它使用了两个 <code>useState</code> Hook：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);\n  <span class="hljs-keyword">const</span> [text, setText] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);\n\n  <span class="hljs-comment">// ...</span>\n}\n</code></pre>\n<p>在这个组件的 Fiber 节点中，<code>memoizedState</code> 属性将指向一个包含两个节点的 Hooks 链表：</p>\n<ul>\n<li>第一个节点代表第一个 <code>useState</code> Hook，包含状态值 <code>count</code> 和更新函数 <code>setCount</code>。</li>\n<li>第二个节点代表第二个 <code>useState</code> Hook，包含状态值 <code>text</code> 和更新函数 <code>setText</code>。</li>\n</ul>\n<p>当组件更新时，React 会根据新的状态值更新这个 Hooks 链表，并确保 Hook 的顺序和身份保持不变。</p>\n</div>'</script></body></html>