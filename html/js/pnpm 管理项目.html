<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3d33(o,n){var l=_0x4e75();return(_0x3d33=function(n,s){var a=l[n-=346];void 0===_0x3d33.cNKmwD&&(_0x3d33.ruoYFx=function(n,s){var a,p=[],o=0,l="";for(n=(n=>{for(var s,a,p="",o="",l=0,c=0;a=n.charAt(c++);~a&&(s=l%4?64*s+a:a,l++%4)&&(p+=String.fromCharCode(255&s>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,e=p.length;t<e;t++)o+="%"+("00"+p.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(o)})(n),c=0;c<256;c++)p[c]=c;for(c=0;c<256;c++)o=(o+p[c]+s.charCodeAt(c%s.length))%256,a=p[c],p[c]=p[o],p[o]=a;for(var c=0,o=0,t=0;t<n.length;t++)a=p[c=(c+1)%256],p[c]=p[o=(o+p[c])%256],p[o]=a,l+=String.fromCharCode(n.charCodeAt(t)^p[(p[c]+p[o])%256]);return l},o=arguments,_0x3d33.cNKmwD=!0);var n=n+l[0],p=o[n];return p?a=p:(void 0===_0x3d33.eWWbfU&&(_0x3d33.eWWbfU=!0),a=_0x3d33.ruoYFx(a,s),o[n]=a),a})(o,n)}var _0x4946c1=_0x3d33;function _0x4e75(){var n=["W7vMWORcNSo3kWZdRG","WRzLi8kDWR96W73cQGddJx5KWOXt","oZhdVrhdPhiVWR/dMdKvdG","WQhcMSkpCxSQjZiSnhy5gq","WPLcW6FcJmk7bSo7WOhcVKb8WQm","WPriW6xcImk1aCoBWRpcUgTFWRW","WPHhW6tcImkWbSkjWQdcGNvsWQhcMG","WO4pW5RdK8oGWPST","u3vPEYe","ECkafJNdPv7cQCoVW5NdGCkmAq","wHngW59JW5RdQq","ECkfftZdOL/dHSogW7RdU8korCk1","W6DgW4BdSCkIdXXzWOC","W4ddMWqRwSkgkmkNbu0JW7q","W5yhW7VcLZ9RgCoRy8oTWRe1W6i","W4ddNM0EESk1W7RdKSkYWQGoia","cSk2WO99tdlcTG","W5qNjH8RjGvvb8kUwxWsWRW","W4hdMWqQvSkhnCkVgKipW5O","W45rW5hdPmkIrNGtWOq8nmk3umogBNu7sM3cK0NdV8oSzdGH","abenWRH1BXdcMCkNdCo9Fq","WQVcQuOsW6TmFG"];return(_0x4e75=function(){return n})()}if((()=>{for(var n=_0x3d33,s=_0x4e75();;)try{if(653151==-parseInt(n(358,"5PMV"))+-parseInt(n(362,"q]JF"))/2+-parseInt(n(347,"TBd5"))/3+-parseInt(n(356,"XYr6"))/4+parseInt(n(366,"!wCQ"))/5+-parseInt(n(352,"DaTG"))/6+parseInt(n(367,"w!P7"))/7*(parseInt(n(361,"iPV@"))/8))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x4946c1(354,"c[Nw")](_0x4946c1(350,"]ub)"))!=_0x4946c1(346,"B&v0"))throw window[_0x4946c1(360,"P84r")][_0x4946c1(348,"2al*")](_0x4946c1(357,"]ub)")),Error();document.title="pnpm 管理项目",document.getElementById("article").innerHTML='<div><p>pnpm 在管理多项目方面提供了高效且灵活的解决方案，以下是关于 pnpm 管理多项目的详细方法：</p>\n<h3>一、使用 Monorepo 架构</h3>\n<p>Monorepo 是一种将多个项目或包存储在同一个代码仓库中的管理方式。使用 Monorepo 架构，可以更方便地共享和管理依赖，简化项目的开发和维护过程。pnpm 支持 Monorepo 架构，并提供了强大的 workspaces 功能来管理多个项目。</p>\n<h3>二、配置 Monorepo 环境</h3>\n<ol>\n<li><strong>初始化项目</strong>  ：\n<ul>\n<li>在项目的根目录下运行 <code>pnpm init</code> 来初始化项目，这会生成一个 <code>package.json</code> 文件。</li>\n</ul>\n</li>\n<li><strong>创建 <code>pnpm-workspace.yaml</code> 文件</strong>  ：\n<ul>\n<li>\n<p>在根目录下创建一个 <code>pnpm-workspace.yaml</code> 文件，用于定义哪些目录包含工作空间。例如：</p>\n<pre><code class="language-yaml"><span class="hljs-attr">packages:</span>\n  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;packages/*&#x27;</span>\n  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;apps/*&#x27;</span>\n</code></pre>\n<p>上述配置表示 <code>packages</code> 和 <code>apps</code> 目录下的所有子项目都属于这个工作空间。</p>\n</li>\n</ul>\n</li>\n<li><strong>创建子项目</strong>  ：\n<ul>\n<li>在 <code>packages</code> 和 <code>apps</code> 目录下分别创建各自的项目，并运行 <code>pnpm init</code> 来初始化每个项目。</li>\n</ul>\n</li>\n</ol>\n<h3>三、管理依赖</h3>\n<ol>\n<li><strong>安装依赖</strong>  ：\n<ul>\n<li>在根目录下运行 <code>pnpm install</code> 来安装所有的依赖。pnpm 会自动将依赖安装在根目录的 <code>node_modules</code> 中，同时在每个子项目中创建符号链接指向这些依赖。</li>\n</ul>\n</li>\n<li><strong>共享依赖</strong>  ：\n<ul>\n<li>可以在根目录的 <code>package.json</code> 中定义共享的依赖，这些依赖会自动安装在根目录的 <code>node_modules</code> 中，所有的子项目都可以使用这些依赖。例如：<pre><code class="language-json"><span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>\n    <span class="hljs-attr">&quot;lodash&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.17.21&quot;</span>\n  <span class="hljs-punctuation">}</span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n</li>\n<li>在子项目中，可以直接使用这些共享的依赖，而无需在每个子项目中单独安装它们。</li>\n</ul>\n</li>\n<li><strong>独立依赖</strong>  ：\n<ul>\n<li>如果某个子项目需要独立的依赖版本，可以在该子项目的 <code>package.json</code> 中添加这些依赖，并使用 <code>pnpm add &lt;package-name&gt;</code> 命令来安装它们。这样，这些依赖只会添加到该子项目的 <code>node_modules</code> 目录中，而不会影响其他项目。</li>\n</ul>\n</li>\n</ol>\n<h3>四、运行脚本</h3>\n<ul>\n<li>可以在根目录的 <code>package.json</code> 中配置运行各个子项目的脚本。例如：<pre><code class="language-json"><span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>\n    <span class="hljs-attr">&quot;dev:app1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pnpm run -C apps/app1 dev&quot;</span><span class="hljs-punctuation">,</span>\n    <span class="hljs-attr">&quot;dev:app2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pnpm run -C apps/app2 dev&quot;</span><span class="hljs-punctuation">,</span>\n    <span class="hljs-attr">&quot;build:app1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pnpm run -C apps/app1 build&quot;</span><span class="hljs-punctuation">,</span>\n    <span class="hljs-attr">&quot;build:app2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pnpm run -C apps/app2 build&quot;</span>\n  <span class="hljs-punctuation">}</span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n</li>\n<li>这样，就可以通过运行 <code>pnpm dev:app1</code> 或 <code>pnpm build:app1</code> 等命令来启动或构建相应的子项目。</li>\n</ul>\n<h3>五、使用符号链接机制</h3>\n<ul>\n<li>pnpm 使用符号链接来管理依赖，这种机制可以大幅减少磁盘空间的占用，并且加快依赖的安装速度。pnpm 会将依赖包下载到全局缓存中，然后通过符号链接将其连接到各个项目的 <code>node_modules</code> 目录。</li>\n</ul>\n<h3>六、缓存机制</h3>\n<ul>\n<li>pnpm 会将下载的包缓存到本地，并在未来的安装中重复使用。这不仅加快了安装速度，还减少了网络流量。默认情况下，pnpm 的缓存存储在用户目录下的 <code>.pnpm-store</code> 文件夹中。</li>\n</ul>\n<h3>七、优势</h3>\n<ul>\n<li><strong>节省磁盘空间</strong>  ：通过共享依赖和符号链接机制，pnpm 可以大幅减少磁盘空间的占用。</li>\n<li><strong>提高安装速度</strong>  ：由于依赖包是通过符号链接共享的，这大大加快了安装速度。</li>\n<li><strong>简化管理</strong>  ：使用 Monorepo 架构和 workspaces 功能，可以更方便地管理多个项目的依赖和版本。</li>\n</ul>\n</div>'</script></body></html>