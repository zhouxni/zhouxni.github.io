<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2113f2=_0x3f26;function _0x3f26(l,n){var e=_0x3040();return(_0x3f26=function(n,o){var r=e[n-=223];void 0===_0x3f26.inunWO&&(_0x3f26.QRfEfH=function(n,o){var r,t=[],l=0,e="";for(n=(n=>{for(var o,r,t="",l="",e=0,i=0;r=n.charAt(i++);~r&&(o=e%4?64*o+r:r,e++%4)&&(t+=String.fromCharCode(255&o>>(-2*e&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var s=0,c=t.length;s<c;s++)l+="%"+("00"+t.charCodeAt(s).toString(16)).slice(-2);return decodeURIComponent(l)})(n),i=0;i<256;i++)t[i]=i;for(i=0;i<256;i++)l=(l+t[i]+o.charCodeAt(i%o.length))%256,r=t[i],t[i]=t[l],t[l]=r;for(var i=0,l=0,s=0;s<n.length;s++)r=t[i=(i+1)%256],t[i]=t[l=(l+t[i])%256],t[l]=r,e+=String.fromCharCode(n.charCodeAt(s)^t[(t[i]+t[l])%256]);return e},l=arguments,_0x3f26.inunWO=!0);var n=n+e[0],t=l[n];return t?r=t:(void 0===_0x3f26.WAHFWv&&(_0x3f26.WAHFWv=!0),r=_0x3f26.QRfEfH(r,o),l[n]=r),r})(l,n)}if((()=>{for(var n=_0x3f26,o=_0x3040();;)try{if(177561==-parseInt(n(246,"p!%G"))+-parseInt(n(229,"vwJt"))/2*(-parseInt(n(250,"k^qJ"))/3)+parseInt(n(225,"q]FT"))/4+parseInt(n(241,"2R!Z"))/5+-parseInt(n(244,"#BZ0"))/6*(-parseInt(n(242,"#CCQ"))/7)+parseInt(n(235,"2R!Z"))/8*(-parseInt(n(240,"#CCQ"))/9)+parseInt(n(247,"VurH"))/10*(-parseInt(n(228,"SMN9"))/11))break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x2113f2(243,"SMN9")](_0x2113f2(223,"jdgh"))!=_0x2113f2(239,"p0VU"))throw window[_0x2113f2(230,"D()*")][_0x2113f2(227,"D()*")](_0x2113f2(245,"p!%G")),Error();function _0x3040(){var n=["WPvTW4/cHxu","WR7cIdhdJmkrEeZdPmkHCvtcMG","aSoDELn5FCkeWR9wW7tcG8kRWOe","WRpcHJxcNSoiaMNdLCkJ","jmkTW613iLPp","WQNcRgNcGmoBACkwWQ/cLSkv","W7TahJaueSkbWOXiWQeeW5z+W4ZcR0hdKmo2wSo3W48ZlmkuB2y","WQigxhnEh8oJW6D3WQqJW64","cmoiW7eJu8kLt8owvCoJW48l","WQubx3GxzColW5z9WOC","AhRcUNpcMs7cHGL8WQ9dxq","W4rTB8oVkmo3WPVdRmkR","WPhdNCoQxmkoc8oHc8o6","WQRcMKddI8oiW4/cO2ZdNKO","W4BcSqLeW53cSrLOWOSYbNC","W4VcUaSvWQtdUqvPWQ0","W4xdNmkRgmoQxvq","D8o9WQHrlfPbqCoT","sSkCWRbFWOmwiJNcIXq","W5VdLSk4fCo/v14U","uCkSrY0Zw3HZc8oPg1O","fd7cVCkdW7RdNh5RaW","W47cRv8hkexdGtL4xCkdvG","W6RdTmodW4yrWPixW7q4q0D/WR0","aSoBgc8RdmoNWOK","W4fQc8opbmobWOxdJG","W7ncW5NcNqmbeuXzWPaRFa","WRrooSoIW7RdPGtdImkY"];return(_0x3040=function(){return n})()}document.title="React Reconciler 详解",document.getElementById("article").innerHTML='<div><p>React Reconciler（协调器）是React内部的核心机制，负责协调虚拟DOM与实际DOM之间的差异，并决定如何高效地更新用户界面。</p>\n<h2>1. 什么是Reconciler</h2>\n<p>Reconciler是React架构中的核心部分，它：</p>\n<ul>\n<li>比较新旧虚拟DOM树（称为&quot;协调&quot;过程）</li>\n<li>计算最小变更集（称为&quot;差异算法&quot;或&quot;diff算法&quot;）</li>\n<li>生成更新指令交给渲染器（如ReactDOM、React Native）</li>\n</ul>\n<h2>2. Reconciler的主要职责</h2>\n<ol>\n<li><strong>虚拟DOM管理</strong>  ：创建和维护虚拟DOM树</li>\n<li><strong>差异比较</strong>  ：比较新旧虚拟DOM树的差异</li>\n<li><strong>调度更新</strong>  ：决定更新的优先级和时机</li>\n<li><strong>副作用管理</strong>  ：处理组件生命周期和Hooks</li>\n<li><strong>批处理优化</strong>  ：合并多个更新以提高性能</li>\n</ol>\n<h2>3. Reconciler的工作流程</h2>\n<h3>3.1 协调过程（Reconciliation）</h3>\n<ol>\n<li><strong>开始工作</strong>  ：从根Fiber节点开始遍历</li>\n<li><strong>比较子节点</strong>  ：递归比较新旧Fiber节点</li>\n<li><strong>生成效果标记</strong>  ：标记需要插入、更新或删除的节点</li>\n<li><strong>构建效果列表</strong>  ：收集所有需要应用的变更</li>\n</ol>\n<h3>3.2 提交阶段（Commit）</h3>\n<ol>\n<li><strong>应用变更</strong>  ：根据效果列表实际更新DOM</li>\n<li><strong>执行副作用</strong>  ：调用生命周期方法和Hooks回调</li>\n</ol>\n<h2>4. Fiber架构</h2>\n<p>现代React Reconciler基于Fiber架构：</p>\n<ul>\n<li><strong>Fiber节点</strong>  ：代表一个工作单元，包含组件信息、状态、props等</li>\n<li><strong>链表结构</strong>  ：Fiber节点组成链表树，便于暂停和恢复工作</li>\n<li><strong>时间切片</strong>  ：将工作分成小块，避免长时间阻塞主线程</li>\n</ul>\n<h2>5. Diff算法原理</h2>\n<p>React的diff算法基于两个假设：</p>\n<ol>\n<li><strong>相同类型的元素</strong>  ：相同类型的组件会生成相似的树结构</li>\n<li><strong>key属性</strong>  ：key帮助识别哪些元素是稳定的</li>\n</ol>\n<p>比较策略：</p>\n<ul>\n<li><strong>逐层比较</strong>  ：只比较同一层级的节点</li>\n<li><strong>类型不同时直接替换</strong>  ：如果元素类型不同，直接重建子树</li>\n<li><strong>key匹配</strong>  ：使用key来匹配新旧树中的对应节点</li>\n</ul>\n<h2>6. 双缓冲技术</h2>\n<p>React使用双缓冲技术优化更新：</p>\n<ul>\n<li><strong>current树</strong>  ：当前渲染的UI对应的Fiber树</li>\n<li><strong>workInProgress树</strong>  ：正在构建的新Fiber树</li>\n<li>完成构建后交换两棵树，减少内存分配</li>\n</ul>\n<h2>7. 调度机制</h2>\n<p>React Reconciler实现了优先级调度：</p>\n<ul>\n<li><strong>同步优先级</strong>  ：立即执行（如用户输入）</li>\n<li><strong>高优先级</strong>  ：很快执行（如动画）</li>\n<li><strong>普通优先级</strong>  ：常规更新</li>\n<li><strong>低优先级</strong>  ：可以延迟的更新（如数据获取）</li>\n</ul>\n<h2>8. 自定义Reconciler</h2>\n<p>React允许创建自定义Reconciler，用于非DOM环境：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Reconciler</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;react-reconciler&#x27;</span>);\n\n<span class="hljs-keyword">const</span> hostConfig = {\n  <span class="hljs-comment">// 实现各种宿主环境相关的方法</span>\n  createInstance,\n  appendChild,\n  removeChild,\n  <span class="hljs-comment">// ...</span>\n};\n\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyRenderer</span> = <span class="hljs-title class_">Reconciler</span>(hostConfig);\n</code></pre>\n<h2>9. 性能优化</h2>\n<p>Reconciler内置多种优化：</p>\n<ul>\n<li><strong>批量更新</strong>  ：合并setState调用</li>\n<li><strong>惰性创建</strong>  ：延迟创建DOM节点直到需要时</li>\n<li><strong>子树跳过</strong>  ：如果shouldComponentUpdate返回false，跳过整个子树</li>\n</ul>\n<h2>10. 与渲染器的关系</h2>\n<p>Reconciler与渲染器（如ReactDOM）分离：</p>\n<ul>\n<li>Reconciler负责&quot;计算&quot;需要更新什么</li>\n<li>渲染器负责&quot;执行&quot;这些更新到具体环境</li>\n</ul>\n<p>这种分离使React可以支持多种渲染目标（Web、Native、Canvas等）。</p>\n<h2>总结</h2>\n<p>React Reconciler是React高效更新的核心，通过Fiber架构、智能diff算法和优先级调度，实现了高性能的UI更新机制。理解Reconciler有助于编写更高效的React应用和进行深度性能优化。</p>\n</div>'</script></body></html>