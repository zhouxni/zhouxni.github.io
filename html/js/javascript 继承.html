<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2d250c=_0x1695;function _0x1695(p,s){var c=_0x460d();return(_0x1695=function(s,a){var n=c[s-=131];void 0===_0x1695.rVfSaU&&(_0x1695.ZIumQg=function(s,a){var n,l=[],p=0,c="";for(s=(s=>{for(var a,n,l="",p="",c=0,t=0;n=s.charAt(t++);~n&&(a=c%4?64*a+n:n,c++%4)&&(l+=String.fromCharCode(255&a>>(-2*c&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var e=0,r=l.length;e<r;e++)p+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(p)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)p=(p+l[t]+a.charCodeAt(t%a.length))%256,n=l[t],l[t]=l[p],l[p]=n;for(var t=0,p=0,e=0;e<s.length;e++)n=l[t=(t+1)%256],l[t]=l[p=(p+l[t])%256],l[p]=n,c+=String.fromCharCode(s.charCodeAt(e)^l[(l[t]+l[p])%256]);return c},p=arguments,_0x1695.rVfSaU=!0);var s=s+c[0],l=p[s];return l?n=l:(void 0===_0x1695.MkJVeQ&&(_0x1695.MkJVeQ=!0),n=_0x1695.ZIumQg(n,a),p[s]=n),n})(p,s)}function _0x460d(){var s=["m8kgiSk2W7nSW5fKFJxdKJJdTNW","dJVdHCkWlI5Ki8oSWRxdGCk+WQe","CmovA8oJWQa6WOu","W77cMCkJiSoTWP/dLGm","B8kWW5xcRHKBsSoeWOyFx8kA","dG9wW7rZWPddU8outSk+yxFcVY9qBSkiW6pdLmkRsmk5W4FcHc5u","W7ldV8kApmkkpSo5","WPLeW4TijSkaWRJcLSklxSkNW7q","bY7cLKRdKaldSCkUj8ooW53dLa","ENtdVmoNhmo7Emo+","t8ooWRRcK8kCqsZcSq","AtLqyJNdP8kIvZHPWOhdTa","W77dRmo7pSoqh8oHteTVW7ZcHHK","WRb/EmoQWQFdTSodWQJdLCkclCk3WP7dQG","WRGqWPTqASodWQeXW64aWRpcOG","WRP6W5nKW6VdUcpdOmkC","m8kelSk5W7fPW5iBBshdLtldKG","utRdRKRdPa7cQmk1W4FdTmkfW4G","v08xWRiWWPRdPSk2tSkvrw/cLG","i8kVeCk9h8kcW7dcQSk0fHtdTu0","WPxdOJVdOvC","W7ueWPlcJ07cLxBcHCodWOtcLwjR"];return(_0x460d=function(){return s})()}if((()=>{for(var s=_0x1695,a=_0x460d();;)try{if(660467==+parseInt(s(146,"7L0B"))+parseInt(s(141,")&B%"))/2+parseInt(s(134,"c&UK"))/3+-parseInt(s(152,"v%lN"))/4+parseInt(s(135,"@g^W"))/5+-parseInt(s(149,"3%UH"))/6*(-parseInt(s(148,"dDag"))/7)+-parseInt(s(145,"Qk)Q"))/8)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x2d250c(151,"T3#e")](_0x2d250c(138,"Ka@J"))!=_0x2d250c(143,"[F1h"))throw window[_0x2d250c(133,"$yqE")][_0x2d250c(147,"Qk)Q")](_0x2d250c(150,")&B%")),Error();document.title="javascript 继承",document.getElementById("article").innerHTML='<div><p>JavaScript 中的继承方式多种多样，以下是常见的几种方式及其示例代码：</p>\n<hr>\n<h3>1. <strong>原型链继承</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：将子类的原型指向父类的实例。</li>\n<li><strong>特点</strong>  ：子类实例共享父类实例的引用属性。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>];\n}\n\n<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getColor</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span>;\n};\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) {}\n\n<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();\n<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>;\n\n<span class="hljs-keyword">const</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();\nchild1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;black&#x27;</span>);\n\n<span class="hljs-keyword">const</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">colors</span>); <span class="hljs-comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27;]，共享了引用</span>\n</code></pre>\n<hr>\n<h3>2. <strong>借用构造函数继承（伪经典继承）</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：在子类构造函数中调用父类构造函数。</li>\n<li><strong>特点</strong>  ：子类实例不共享父类引用属性。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) {\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>];\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name</span>) {\n  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name); <span class="hljs-comment">// 借用构造函数</span>\n}\n\n<span class="hljs-keyword">const</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);\nchild1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;black&#x27;</span>);\n\n<span class="hljs-keyword">const</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">colors</span>); <span class="hljs-comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]，不共享</span>\n</code></pre>\n<hr>\n<h3>3. <strong>组合继承</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：结合原型链继承和借用构造函数继承。</li>\n<li><strong>特点</strong>  ：避免引用属性共享，但父类构造函数会被调用两次。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) {\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>];\n}\n\n<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);\n};\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name, age</span>) {\n  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name); <span class="hljs-comment">// 第二次调用</span>\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;\n}\n\n<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>(); <span class="hljs-comment">// 第一次调用</span>\n<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>;\n\n<span class="hljs-keyword">const</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">18</span>);\nchild1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;black&#x27;</span>);\n\n<span class="hljs-keyword">const</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">20</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">colors</span>); <span class="hljs-comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]</span>\n</code></pre>\n<hr>\n<h3>4. <strong>原型式继承</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：使用 <code>Object.create()</code> 实现继承。</li>\n<li><strong>特点</strong>  ：简单，但无法传递参数。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> parent = {\n  <span class="hljs-attr">colors</span>: [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>],\n  <span class="hljs-attr">getColor</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span>;\n  }\n};\n\n<span class="hljs-keyword">const</span> child1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent);\nchild1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;black&#x27;</span>);\n\n<span class="hljs-keyword">const</span> child2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">colors</span>); <span class="hljs-comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27;]，共享了引用</span>\n</code></pre>\n<hr>\n<h3>5. <strong>寄生式继承</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：在原型式继承的基础上封装增强功能。</li>\n<li><strong>特点</strong>  ：灵活性高，但同样存在引用共享问题。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObject</span>(<span class="hljs-params">o</span>) {\n  <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) {}\n  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o;\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">extend</span>(<span class="hljs-params">o, additionalProperties</span>) {\n  <span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">createObject</span>(o);\n  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(obj, additionalProperties);\n  <span class="hljs-keyword">return</span> obj;\n}\n\n<span class="hljs-keyword">const</span> parent = {\n  <span class="hljs-attr">colors</span>: [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>]\n};\n\n<span class="hljs-keyword">const</span> child1 = <span class="hljs-title function_">extend</span>(parent, { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> });\nchild1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;black&#x27;</span>);\n\n<span class="hljs-keyword">const</span> child2 = <span class="hljs-title function_">extend</span>(parent, { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span> });\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">colors</span>); <span class="hljs-comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27;]，共享了引用</span>\n</code></pre>\n<hr>\n<h3>6. <strong>寄生组合式继承</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：结合寄生式继承和组合式继承，避免多次调用父类构造函数。</li>\n<li><strong>特点</strong>  ：被认为是最理想的继承方式。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) {\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>];\n}\n\n<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);\n};\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name, age</span>) {\n  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name); <span class="hljs-comment">// 借用构造函数</span>\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;\n}\n\n<span class="hljs-comment">// 寄生组合继承的实现</span>\n<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);\n<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>;\n\n<span class="hljs-keyword">const</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">18</span>);\nchild1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;black&#x27;</span>);\n\n<span class="hljs-keyword">const</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">20</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">colors</span>); <span class="hljs-comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]</span>\n</code></pre>\n<hr>\n<h3>7. <strong>ES6 类继承</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：使用 <code>class</code> 和 <code>extends</code> 关键字。</li>\n<li><strong>特点</strong>  ：语法简洁，符合现代 JavaScript 编程风格。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>];\n  }\n\n  <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);\n  }\n}\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) {\n    <span class="hljs-variable language_">super</span>(name); <span class="hljs-comment">// 调用父类构造函数</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;\n  }\n}\n\n<span class="hljs-keyword">const</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">18</span>);\nchild1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;black&#x27;</span>);\n\n<span class="hljs-keyword">const</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">20</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">colors</span>); <span class="hljs-comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]</span>\n</code></pre>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>推荐使用 ES6 类继承</strong>  ：语法简洁，功能强大，符合现代 JavaScript 编程风格。</li>\n<li><strong>寄生组合继承</strong>  ：在需要兼容 ES5 或更早版本时，可以考虑使用，因为它性能较好且避免了父类构造函数的多次调用。</li>\n<li><strong>避免使用原型链继承和借用构造函数</strong>  ：前者无法传递参数且共享引用属性，后者无法复用方法。</li>\n</ul>\n</div>'</script></body></html>