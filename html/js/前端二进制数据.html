<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4d7d23=_0x4f45;function _0x4f45(t,s){var e=_0x59d1();return(_0x4f45=function(s,n){var a=e[s-=448];void 0===_0x4f45.LhMRxO&&(_0x4f45.AennSm=function(s,n){var a,l=[],t=0,e="";for(s=(s=>{for(var n,a,l="",t="",e=0,r=0;a=s.charAt(r++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,o=l.length;p<o;p++)t+="%"+("00"+l.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(t)})(s),r=0;r<256;r++)l[r]=r;for(r=0;r<256;r++)t=(t+l[r]+n.charCodeAt(r%n.length))%256,a=l[r],l[r]=l[t],l[t]=a;for(var r=0,t=0,p=0;p<s.length;p++)a=l[r=(r+1)%256],l[r]=l[t=(t+l[r])%256],l[t]=a,e+=String.fromCharCode(s.charCodeAt(p)^l[(l[r]+l[t])%256]);return e},t=arguments,_0x4f45.LhMRxO=!0);var s=s+e[0],l=t[s];return l?a=l:(void 0===_0x4f45.liasUp&&(_0x4f45.liasUp=!0),a=_0x4f45.AennSm(a,n),t[s]=a),a})(t,s)}function _0x59d1(){var s=["WR5OeWaKcComWP5uW5W","sXy4WOBdQcqRWQRdMmkG","W6rfWRygW7r1WPJcKZ1CWPz4W7jDFSkJzwhcHIHFW6ddINi6mW","m8kiDHqVq8kehvBdNSkuCH0","omo5kH4msZlcKmkcxSkuWOlcTG","yZJcHHBcNsXayLuCmNLZ","emoeW77dILnVnaDaW7K","jexcVWRcJLj7W6VcLebKEG","WRS5W6ddTCoJWR7cKmoGW5KD","x8k9WOWUW54nWRm+xmoPW6NcRCkE","WQxcMSkbxCoVW5vjz1jrWO9WkG","WRbVp8olW4hcHSoZWRZcGa","WPJdNeHvW4XUWRuNCmo0CZK","W7BdV13cOhBdIMRdVmkVFq","cuXNq2NcT1DOW5pdM1H6W5bC","kx3cHaKl","n8oXWPdcSSkXgg4","vCkIofJcLHGuaCkq","W4NdSYldLmk+WP1j","WPCvW6RcKrjrbq","jKdcUq/dVtrXW4NcOLy","W7SeW5LAk3xcVSodtZz8WPldM1G","FbVdQLZdIG1KW7m","imoWAgNcIGqoj8kb","WPpdHCoKxYbkFa","W4VcRh7cGCocW4GuW4ZcHqKNWQldHW"];return(_0x59d1=function(){return s})()}if((()=>{for(var s=_0x4f45,n=_0x59d1();;)try{if(329783==+parseInt(s(466,"MB77"))+-parseInt(s(464,"Ga2w"))/2*(-parseInt(s(470,"TLZh"))/3)+parseInt(s(457,"4!jL"))/4+parseInt(s(453,")uIT"))/5+-parseInt(s(467,"gvx8"))/6*(parseInt(s(471,"bRyD"))/7)+-parseInt(s(460,"[5sI"))/8*(-parseInt(s(455,"k0aJ"))/9)+-parseInt(s(468,"#I5$"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x4d7d23(452,"c4Ys")](_0x4d7d23(451,"bRyD"))!=_0x4d7d23(469,"ru7r"))throw window[_0x4d7d23(450,"snC!")][_0x4d7d23(473,"RST*")](_0x4d7d23(456,"l0Aq")),Error();document.title="前端二进制数据",document.getElementById("article").innerHTML='<div><p>在前端开发中，二进制数据是一种以位（bit）为基础的数字表示形式，通常用于处理图像、文件、网络传输等场景。以下是常见的前端二进制数据格式及其应用场景：</p>\n<h3><strong>1. ArrayBuffer</strong></h3>\n<ul>\n<li><strong>基本概念</strong>   ：\n<ul>\n<li>原始的二进制数据缓冲区，在内存中分配固定大小的连续字节空间。</li>\n<li>不能直接操作，需通过视图（<code>DataView</code> 或 <code>TypedArray</code>）访问。</li>\n</ul>\n</li>\n<li><strong>创建方式</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">16</span>); <span class="hljs-comment">// 创建16字节的缓冲区</span>\n</code></pre>\n</li>\n<li><strong>应用场景</strong>   ：\n<ul>\n<li>文件读取（<code>FileReader.readAsArrayBuffer</code>）。</li>\n<li>WebSocket 二进制帧传输。</li>\n<li>WebGL 纹理数据处理。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>2. TypedArray</strong></h3>\n<ul>\n<li>\n<p><strong>基本概念</strong>   ：</p>\n<ul>\n<li>以特定格式（如 <code>Uint8Array</code>、<code>Float32Array</code>）访问 <code>ArrayBuffer</code> 的视图。</li>\n<li>所有 TypedArray 共享相同的内存空间，修改其中一个会影响其他视图。</li>\n</ul>\n</li>\n<li>\n<p><strong>常见类型</strong>   ：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>描述</th>\n<th>每个元素的字节数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Int8Array</code></td>\n<td>8位有符号整数</td>\n<td>1</td>\n</tr>\n<tr>\n<td><code>Uint8Array</code></td>\n<td>8位无符号整数</td>\n<td>1</td>\n</tr>\n<tr>\n<td><code>Uint8ClampedArray</code></td>\n<td>8位无符号整数（强制截断）</td>\n<td>1</td>\n</tr>\n<tr>\n<td><code>Int16Array</code></td>\n<td>16位有符号整数</td>\n<td>2</td>\n</tr>\n<tr>\n<td><code>Float32Array</code></td>\n<td>32位浮点数</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">8</span>);\n<span class="hljs-keyword">const</span> int32View = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Int32Array</span>(buffer); <span class="hljs-comment">// 2个32位整数</span>\n<span class="hljs-keyword">const</span> uint8View = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(buffer); <span class="hljs-comment">// 8个字节</span>\n\nint32View[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uint8View[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 输出：42（低字节序）</span>\n</code></pre>\n</li>\n<li>\n<p><strong>应用场景</strong>   ：</p>\n<ul>\n<li>音频处理（Web Audio API）。</li>\n<li>Canvas 像素操作（<code>ImageData.data</code> 是 <code>Uint8ClampedArray</code>）。</li>\n<li>二进制协议解析（如 Protobuf）。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>3. DataView</strong></h3>\n<ul>\n<li>\n<p><strong>基本概念</strong>   ：</p>\n<ul>\n<li>灵活的 <code>ArrayBuffer</code> 视图，支持不同字节序（大端/小端）和类型访问。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">4</span>);\n<span class="hljs-keyword">const</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataView</span>(buffer);\n\nview.<span class="hljs-title function_">setInt16</span>(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 从第0字节开始写入16位整数，使用小端序</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(view.<span class="hljs-title function_">getInt16</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>)); <span class="hljs-comment">// 输出：256</span>\n</code></pre>\n</li>\n<li>\n<p><strong>应用场景</strong>   ：</p>\n<ul>\n<li>解析复杂二进制格式（如文件头、网络包）。</li>\n<li>处理跨平台字节序差异。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>4. Blob</strong></h3>\n<ul>\n<li>\n<p><strong>基本概念</strong>   ：</p>\n<ul>\n<li>不可变的二进制大对象，代表原始数据（如文件）。</li>\n<li>可以包含文本或二进制数据，支持按块读取。</li>\n</ul>\n</li>\n<li>\n<p><strong>创建方式</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-string">&quot;Hello, world!&quot;</span>], { <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;text/plain&quot;</span> });\n</code></pre>\n</li>\n<li>\n<p><strong>应用场景</strong>   ：</p>\n<ul>\n<li>文件上传/下载（<code>URL.createObjectURL</code>）。</li>\n<li>媒体流处理（如录制音视频）。</li>\n</ul>\n</li>\n<li>\n<p><strong>与其他格式的转换</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// Blob → ArrayBuffer</span>\n<span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();\nreader.<span class="hljs-title function_">readAsArrayBuffer</span>(blob);\nreader.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> buffer = reader.<span class="hljs-property">result</span>;\n};\n\n<span class="hljs-comment">// ArrayBuffer → Blob</span>\n<span class="hljs-keyword">const</span> newBlob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([buffer], { <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;application/octet-stream&quot;</span> });\n</code></pre>\n</li>\n</ul>\n<h3><strong>5. File</strong></h3>\n<ul>\n<li><strong>基本概念</strong>   ：\n<ul>\n<li>继承自 <code>Blob</code>，表示用户选择或通过 API 创建的文件对象。</li>\n<li>包含文件名、修改日期等元信息。</li>\n</ul>\n</li>\n<li><strong>应用场景</strong>   ：\n<ul>\n<li>文件上传（<code>&lt;input type=&quot;file&quot;&gt;</code>）。</li>\n<li>拖放文件处理（<code>DataTransfer.files</code>）。</li>\n</ul>\n</li>\n<li><strong>示例</strong>   ：<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span> /&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-keyword">const</span> fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;fileInput&quot;</span>);\n  fileInput.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;change&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> file = e.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(file.<span class="hljs-property">name</span>, file.<span class="hljs-property">size</span>, file.<span class="hljs-property">type</span>);\n  });\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n</li>\n</ul>\n<h3><strong>6. Base64 编码</strong></h3>\n<ul>\n<li>\n<p><strong>基本概念</strong>   ：</p>\n<ul>\n<li>将二进制数据转换为 ASCII 字符串的编码方式。</li>\n<li>常用于通过文本协议（如 HTTP、JSON）传输二进制数据。</li>\n</ul>\n</li>\n<li>\n<p><strong>编码/解码</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 字符串 → Base64</span>\n<span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;\n<span class="hljs-keyword">const</span> encoded = <span class="hljs-title function_">btoa</span>(<span class="hljs-built_in">unescape</span>(<span class="hljs-built_in">encodeURIComponent</span>(str)));\n\n<span class="hljs-comment">// Base64 → 字符串</span>\n<span class="hljs-keyword">const</span> decoded = <span class="hljs-built_in">decodeURIComponent</span>(<span class="hljs-built_in">escape</span>(<span class="hljs-title function_">atob</span>(encoded)));\n\n<span class="hljs-comment">// Blob → Base64</span>\n<span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();\nreader.<span class="hljs-title function_">readAsDataURL</span>(blob);\nreader.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> base64String = reader.<span class="hljs-property">result</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 去除前缀 &quot;data:*/*;base64,&quot;</span>\n};\n</code></pre>\n</li>\n<li>\n<p><strong>应用场景</strong>   ：</p>\n<ul>\n<li>嵌入小图片（<code>&lt;img src=&quot;data:image/png;base64,...&quot;&gt;</code>）。</li>\n<li>通过 JSON 传递二进制数据。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>7. 二进制数据的应用场景</strong></h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>常用格式</th>\n<th>示例 API</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>文件处理</td>\n<td><code>File</code>、<code>Blob</code>、<code>ArrayBuffer</code></td>\n<td><code>FileReader</code>、<code>URL.createObjectURL</code></td>\n</tr>\n<tr>\n<td>网络请求</td>\n<td><code>ArrayBuffer</code>、<code>Blob</code></td>\n<td><code>fetch().arrayBuffer()</code>、<code>XHR.responseType = \'arraybuffer\'</code></td>\n</tr>\n<tr>\n<td>Canvas 操作</td>\n<td><code>Uint8ClampedArray</code></td>\n<td><code>ctx.getImageData().data</code></td>\n</tr>\n<tr>\n<td>WebSocket</td>\n<td><code>ArrayBuffer</code></td>\n<td><code>socket.binaryType = \'arraybuffer\'</code></td>\n</tr>\n<tr>\n<td>音频处理</td>\n<td><code>Float32Array</code></td>\n<td><code>AudioBuffer.getChannelData()</code></td>\n</tr>\n</tbody>\n</table>\n<h3><strong>8. 不同格式间的转换</strong></h3>\n<ul>\n<li><strong>ArrayBuffer → Blob</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([arrayBuffer], { <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;application/octet-stream&quot;</span> });\n</code></pre>\n</li>\n<li><strong>Blob → ArrayBuffer</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();\nreader.<span class="hljs-title function_">readAsArrayBuffer</span>(blob);\nreader.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> arrayBuffer = reader.<span class="hljs-property">result</span>;\n};\n</code></pre>\n</li>\n<li><strong>ArrayBuffer → Base64</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> uint8Array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(arrayBuffer);\n<span class="hljs-keyword">const</span> base64 = <span class="hljs-title function_">btoa</span>(<span class="hljs-title class_">String</span>.<span class="hljs-property">fromCharCode</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, uint8Array));\n</code></pre>\n</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<p>前端二进制数据处理需要根据场景选择合适的格式：</p>\n<ul>\n<li><strong>底层操作</strong>   （如协议解析）：使用 <code>ArrayBuffer</code> + <code>DataView</code>/<code>TypedArray</code>。</li>\n<li><strong>文件/媒体处理</strong>   ：使用 <code>Blob</code>/<code>File</code>。</li>\n<li><strong>文本协议传输</strong>   ：使用 Base64 编码。</li>\n</ul>\n<p>理解这些格式的特性和转换方式，是处理图像、音视频、文件上传等复杂场景的关键。</p>\n</div>'</script></body></html>