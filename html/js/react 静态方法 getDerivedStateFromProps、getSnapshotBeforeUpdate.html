<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1adb(){var s=["WQebA2VcJCkdnLRdPG","WQPkr8kbwhuI","WQH/gmkRDmkgkva","W6OwbCozdc4bWRBdHCobW7NdOq","jxRcV3iRFmoKDd8+WQ4/WOa","v0ZcL8ovWP4aW4FcPq","WQRcLmk/nJivWQSgWP1rFComxa","W5TVW6v8oCoObx/cK8o6WRNdRG","qmk0ehuhkIFcSCkId8ohWPFcNG","xa/dTriOWOhdM8kVqmoRWPjin8kB","s8k2eNmhlMFcU8kQgmo4WPe","WObFiCoLW4ezWPy","xa7dSHuSWOxdNCouyCo2WQzgda","WQ02jCkEq8k/kW","WOuwhmoqW7yGWPtdNW","W5LxpZZdImogcxRdLhvwW7u","EhBcHSoCzCo+W5K6W5FcPSo+zZ3cIG","bMKAW4hcH8ogbq","iCo8pCkemSofWQxcSSoqxCoAzCkXBG","FSoYpIfLWQ3dUunvWQ3cGfRcKmkIWP92B8kDW5aHWOGgW7qkWONcRG","lSoGWPeVWOOeWQJdPuSUW48tW64","W5TGW6v7pSoMCsJcLCoyWPRdVCo5Dq","ssutW7i2","W5TvW4ZdMvKAv05eWP/cIXddJq"];return(_0x1adb=function(){return s})()}function _0x5e4d(p,s){var l=_0x1adb();return(_0x5e4d=function(s,a){var n=l[s-=206];void 0===_0x5e4d.nSsZXw&&(_0x5e4d.kIVVlS=function(s,a){var n,e=[],p=0,l="";for(s=(s=>{for(var a,n,e="",p="",l=0,t=0;n=s.charAt(t++);~n&&(a=l%4?64*a+n:n,l++%4)&&(e+=String.fromCharCode(255&a>>(-2*l&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var o=0,c=e.length;o<c;o++)p+="%"+("00"+e.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(p)})(s),t=0;t<256;t++)e[t]=t;for(t=0;t<256;t++)p=(p+e[t]+a.charCodeAt(t%a.length))%256,n=e[t],e[t]=e[p],e[p]=n;for(var t=0,p=0,o=0;o<s.length;o++)n=e[t=(t+1)%256],e[t]=e[p=(p+e[t])%256],e[p]=n,l+=String.fromCharCode(s.charCodeAt(o)^e[(e[t]+e[p])%256]);return l},p=arguments,_0x5e4d.nSsZXw=!0);var s=s+l[0],e=p[s];return e?n=e:(void 0===_0x5e4d.OjaVoH&&(_0x5e4d.OjaVoH=!0),n=_0x5e4d.kIVVlS(n,a),p[s]=n),n})(p,s)}var _0x2a4e3c=_0x5e4d;if((()=>{for(var s=_0x5e4d,a=_0x1adb();;)try{if(961489==+parseInt(s(221,"vwaY"))*(-parseInt(s(218,"rUOV"))/2)+parseInt(s(216,"rUOV"))/3+-parseInt(s(228,"y%Q2"))/4+-parseInt(s(222,"kDvc"))/5*(-parseInt(s(211,"i[uO"))/6)+-parseInt(s(226,"8)Y%"))/7+parseInt(s(212,")A%("))/8+parseInt(s(229,"1Cp)"))/9)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x2a4e3c(225,"7$o[")](_0x2a4e3c(208,"19lb"))!=_0x2a4e3c(206,"Z9u!"))throw window[_0x2a4e3c(213,"!%vM")][_0x2a4e3c(209,"i[uO")](_0x2a4e3c(227,"c[8n")),Error();document.title="react 静态方法 getDerivedStateFromProps、getSnapshotBeforeUpdate",document.getElementById("article").innerHTML='<div><p><code>getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code> 是 React Class 组件中两个特殊的生命周期方法，它们在组件的不同阶段发挥着重要作用，下面为你详细介绍：</p>\n<h3><code>getDerivedStateFromProps</code></h3>\n<h4>作用概述</h4>\n<p><code>getDerivedStateFromProps</code> 是一个静态方法，它会在组件实例化以及接收到新的 <code>props</code> 时被调用。其主要作用是根据最新的 <code>props</code> 来更新组件的 <code>state</code>，确保 <code>state</code> 与 <code>props</code> 保持同步。这个方法可以帮助组件在 <code>props</code> 变化时做出相应的状态更新。</p>\n<h4>基本语法</h4>\n<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {\n    state = {\n        <span class="hljs-comment">// 初始 state</span>\n    };\n\n    <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params">props, state</span>) {\n        <span class="hljs-comment">// 根据 props 更新 state</span>\n        <span class="hljs-keyword">if</span> (props.<span class="hljs-property">someProp</span>!== state.<span class="hljs-property">someState</span>) {\n            <span class="hljs-keyword">return</span> {\n                <span class="hljs-attr">someState</span>: props.<span class="hljs-property">someProp</span>\n            };\n        }\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;\n    }\n\n    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n        <span class="hljs-keyword">return</span> (\n            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n                {/* 组件渲染内容 */}\n            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n        );\n    }\n}\n</code></pre>\n<p>此方法接收两个参数：</p>\n<ul>\n<li><code>props</code>：最新的 <code>props</code> 对象。</li>\n<li><code>state</code>：当前的 <code>state</code> 对象。</li>\n</ul>\n<h4>使用场景</h4>\n<ul>\n<li><strong>同步 <code>props</code> 到 <code>state</code></strong>  ：当组件的 <code>state</code> 需要根据 <code>props</code> 的变化而更新时使用。例如，一个接收初始值 <code>props</code> 的输入框组件，可根据 <code>props</code> 更新内部 <code>state</code>。</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InputComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {\n    state = {\n        <span class="hljs-attr">inputValue</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">initialValue</span>\n    };\n\n    <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params">props, state</span>) {\n        <span class="hljs-keyword">if</span> (props.<span class="hljs-property">initialValue</span>!== state.<span class="hljs-property">inputValue</span>) {\n            <span class="hljs-keyword">return</span> {\n                <span class="hljs-attr">inputValue</span>: props.<span class="hljs-property">initialValue</span>\n            };\n        }\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;\n    }\n\n    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n        <span class="hljs-keyword">return</span> (\n            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{this.state.inputValue}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> this.setState({ inputValue: e.target.value })} /&gt;</span>\n        );\n    }\n}\n</code></pre>\n<ul>\n<li><strong>重置 <code>state</code></strong>  ：当 <code>props</code> 发生特定变化时，重置组件的 <code>state</code>。例如，一个分页组件，当 <code>currentPage</code> <code>props</code> 改变时，重置页面数据。</li>\n</ul>\n<h4>注意事项</h4>\n<ul>\n<li>它是静态方法，不能使用 <code>this</code> 关键字。</li>\n<li>该方法必须返回一个对象用于更新 <code>state</code>，或者返回 <code>null</code> 表示不更新。</li>\n<li>要避免在该方法中产生副作用，如网络请求等。</li>\n</ul>\n<h3><code>getSnapshotBeforeUpdate</code></h3>\n<h4>作用概述</h4>\n<p><code>getSnapshotBeforeUpdate</code> 会在最近一次渲染输出（提交到 DOM 节点）之前被调用。它的主要作用是在 DOM 更新之前获取一些信息，例如滚动位置、元素尺寸等，然后将这些信息作为参数传递给 <code>componentDidUpdate</code> 方法，以便在更新后恢复或使用这些信息。</p>\n<h4>基本语法</h4>\n<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {\n    <span class="hljs-title function_">getSnapshotBeforeUpdate</span>(<span class="hljs-params">prevProps, prevState</span>) {\n        <span class="hljs-comment">// 获取 DOM 更新前的信息</span>\n        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-property">scrollTop</span>;\n    }\n\n    <span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState, snapshot</span>) {\n        <span class="hljs-comment">// 使用获取到的信息</span>\n        <span class="hljs-keyword">if</span> (snapshot!== <span class="hljs-literal">null</span>) {\n            <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-property">scrollTop</span> = snapshot;\n        }\n    }\n\n    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n        <span class="hljs-keyword">return</span> (\n            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{(el)</span> =&gt;</span> this.element = el}&gt;\n                {/* 组件渲染内容 */}\n            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n        );\n    }\n}\n</code></pre>\n<p>此方法接收两个参数：</p>\n<ul>\n<li><code>prevProps</code>：更新前的 <code>props</code> 对象。</li>\n<li><code>prevState</code>：更新前的 <code>state</code> 对象。</li>\n</ul>\n<h4>使用场景</h4>\n<ul>\n<li><strong>保持滚动位置</strong>  ：在列表数据更新时，保持滚动位置不变。例如，一个聊天窗口组件，新消息到来时，保持滚动位置，避免页面跳动。</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatWindow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {\n    <span class="hljs-title function_">getSnapshotBeforeUpdate</span>(<span class="hljs-params">prevProps, prevState</span>) {\n        <span class="hljs-keyword">const</span> chatWindow = <span class="hljs-variable language_">this</span>.<span class="hljs-property">chatWindow</span>;\n        <span class="hljs-keyword">return</span> chatWindow.<span class="hljs-property">scrollHeight</span> - chatWindow.<span class="hljs-property">scrollTop</span>;\n    }\n\n    <span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState, snapshot</span>) {\n        <span class="hljs-keyword">const</span> chatWindow = <span class="hljs-variable language_">this</span>.<span class="hljs-property">chatWindow</span>;\n        <span class="hljs-keyword">if</span> (snapshot!== <span class="hljs-literal">null</span>) {\n            <span class="hljs-keyword">const</span> newScrollTop = chatWindow.<span class="hljs-property">scrollHeight</span> - snapshot;\n            chatWindow.<span class="hljs-property">scrollTop</span> = newScrollTop;\n        }\n    }\n\n    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n        <span class="hljs-keyword">return</span> (\n            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{(el)</span> =&gt;</span> this.chatWindow = el}&gt;\n                {/* 聊天消息列表 */}\n            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n        );\n    }\n}\n</code></pre>\n<ul>\n<li><strong>记录元素尺寸</strong>  ：在元素大小改变时，记录之前的尺寸信息，以便后续处理。</li>\n</ul>\n<h4>注意事项</h4>\n<ul>\n<li>该方法返回的值会作为第三个参数传递给 <code>componentDidUpdate</code> 方法。</li>\n<li>它在 DOM 更新之前调用，因此可以安全地读取 DOM 信息。</li>\n</ul>\n</div>'</script></body></html>