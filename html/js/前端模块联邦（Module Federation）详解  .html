<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x39050c=_0x1f4c;function _0x1f4c(o,s){var l=_0x3f52();return(_0x1f4c=function(s,n){var t=l[s-=132];void 0===_0x1f4c.suOGYc&&(_0x1f4c.SYgaTY=function(s,n){var t,a=[],o=0,l="";for(s=(s=>{for(var n,t,a="",o="",l=0,r=0;t=s.charAt(r++);~t&&(n=l%4?64*n+t:t,l++%4)&&(a+=String.fromCharCode(255&n>>(-2*l&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var e=0,p=a.length;e<p;e++)o+="%"+("00"+a.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(o)})(s),r=0;r<256;r++)a[r]=r;for(r=0;r<256;r++)o=(o+a[r]+n.charCodeAt(r%n.length))%256,t=a[r],a[r]=a[o],a[o]=t;for(var r=0,o=0,e=0;e<s.length;e++)t=a[r=(r+1)%256],a[r]=a[o=(o+a[r])%256],a[o]=t,l+=String.fromCharCode(s.charCodeAt(e)^a[(a[r]+a[o])%256]);return l},o=arguments,_0x1f4c.suOGYc=!0);var s=s+l[0],a=o[s];return a?t=a:(void 0===_0x1f4c.iMbwDS&&(_0x1f4c.iMbwDS=!0),t=_0x1f4c.SYgaTY(t,n),o[s]=t),t})(o,s)}function _0x3f52(){var s=["vsRdNCkZA8kiWRpdUmkUW7a","W5NcNaFdMY7dIZRcTsHzfZy/","W6rjW5tcMSkRcab2W6fJhru","BKxcM2ujaSoTsConESoFWOq","r8kVarRdKYVcQMO","ufykWPpdNmkvWOhdSWuHt8oqga","WOSFrCkswG","WQSOaCo9W4ZcUeq","imkJsSoaWP9WW5/cKCodvcpcHmkS","WRHTsSkyW4vdWRtdK8k5WOyLBCkVrmo9W748jCogeNJcG0qGwJC","qmkPxwJcKhVdK0LcW4FcLmo2W5y","wmo2WQFcS09HzaeK","W5RcSXBdOJ5pW63cLhf2qu3cGa","W5/cTrddPZPdW6pcT1nmu0ZcQW","xIhdJ8krg8kiWPy","qmoqW5SYeatcNa","WRNcTSkeALZdR8kCnwvXfdm","tZVcJ8kHt1xcPmkJvmkWWRlcGmoY","a21LWQZcQCohcWq","W6SVzmo+W5elaCo9dY7dSYDP","bCkXkmoyWOmMWQ4","d1BdQ0eYBbtdMWm","W7r+rSkgW4hcM3hdGJ9Y","qCo1WQqxqCkIW6FdTWO","W6qNFmoQW5JdI8o6WRS"];return(_0x3f52=function(){return s})()}if((()=>{for(var s=_0x1f4c,n=_0x3f52();;)try{if(415066==-parseInt(s(136,"T![G"))+parseInt(s(137,"OG3E"))/2*(parseInt(s(134,"BoG8"))/3)+-parseInt(s(145,"%4%W"))/4*(-parseInt(s(141,"AW8%"))/5)+parseInt(s(153,"0eV&"))/6+-parseInt(s(139,"YJy@"))/7+-parseInt(s(148,"@Sj$"))/8*(-parseInt(s(144,"Ci10"))/9)+-parseInt(s(155,"oGkO"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x39050c(152,"r3#w")](_0x39050c(143,"&Ebj"))!=_0x39050c(151,"@78n"))throw window[_0x39050c(138,"O@C&")][_0x39050c(135,"QL9b")](_0x39050c(154,"WJOF")),Error();document.title="前端模块联邦（Module Federation）详解  ",document.getElementById("article").innerHTML='<div><p>Module Federation 是 Webpack 5 引入的一项革命性功能，允许<strong>多个独立应用动态共享代码</strong>   ，实现微前端、跨应用组件复用等场景。以下是深度解析：</p>\n<hr>\n<h2><strong>1. 核心概念</strong></h2>\n<h3><strong>1.1 基本定义</strong></h3>\n<ul>\n<li><strong>目标</strong>   ：让不同项目（甚至不同团队）的代码在运行时相互引用，无需发布到 npm 或重复打包。</li>\n<li><strong>关键角色</strong>   ：\n<ul>\n<li><strong>Host（宿主）</strong>   ：消费其他应用模块的应用。</li>\n<li><strong>Remote（远程）</strong>   ：被其他应用引用的模块提供方。</li>\n<li><strong>Shared（共享）</strong>   ：共用依赖（如 React、lodash）。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>1.2 工作原理</strong></h3>\n<ul>\n<li><strong>运行时加载</strong>   ：Remote 模块按需从其他应用加载，而非编译时打包。</li>\n<li><strong>依赖共享</strong>   ：通过 <code>shared</code> 配置避免重复加载同一库。</li>\n</ul>\n<hr>\n<h2><strong>2. 配置详解</strong></h2>\n<h3><strong>2.1 Remote 端配置</strong></h3>\n<pre><code class="language-js"><span class="hljs-comment">// webpack.config.js (Remote)</span>\n<span class="hljs-keyword">const</span> { <span class="hljs-title class_">ModuleFederationPlugin</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>).<span class="hljs-property">container</span>;\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">plugins</span>: [\n    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>({\n      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;app1&quot;</span>, <span class="hljs-comment">// 唯一标识</span>\n      <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;remoteEntry.js&quot;</span>, <span class="hljs-comment">// 入口文件</span>\n      <span class="hljs-attr">exposes</span>: {\n        <span class="hljs-string">&quot;./Button&quot;</span>: <span class="hljs-string">&quot;./src/components/Button&quot;</span>, <span class="hljs-comment">// 暴露模块路径</span>\n      },\n      <span class="hljs-attr">shared</span>: {\n        <span class="hljs-attr">react</span>: { <span class="hljs-attr">singleton</span>: <span class="hljs-literal">true</span> }, <span class="hljs-comment">// 共享依赖</span>\n        <span class="hljs-string">&quot;react-dom&quot;</span>: { <span class="hljs-attr">singleton</span>: <span class="hljs-literal">true</span> },\n      },\n    }),\n  ],\n};\n</code></pre>\n<h3><strong>2.2 Host 端配置</strong></h3>\n<pre><code class="language-js"><span class="hljs-comment">// webpack.config.js (Host)</span>\n<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>({\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hostApp&quot;</span>,\n  <span class="hljs-attr">remotes</span>: {\n    <span class="hljs-attr">app1</span>: <span class="hljs-string">&quot;app1@http://remote-domain.com/remoteEntry.js&quot;</span>, <span class="hljs-comment">// 引用Remote</span>\n  },\n  <span class="hljs-attr">shared</span>: {\n    <span class="hljs-attr">react</span>: { <span class="hljs-attr">singleton</span>: <span class="hljs-literal">true</span> }, <span class="hljs-comment">// 必须与Remote一致</span>\n    <span class="hljs-string">&quot;react-dom&quot;</span>: { <span class="hljs-attr">singleton</span>: <span class="hljs-literal">true</span> },\n  },\n});\n</code></pre>\n<h3><strong>2.3 动态加载 Remote 模块</strong></h3>\n<pre><code class="language-js"><span class="hljs-comment">// Host 应用中使用</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">RemoteButton</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;app1/Button&quot;</span>));\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&quot;Loading...&quot;</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">RemoteButton</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">React.Suspense</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<hr>\n<h2><strong>3. 核心特性</strong></h2>\n<h3><strong>3.1 依赖共享（Shared）</strong></h3>\n<ul>\n<li><strong>避免重复加载</strong>   ：多个应用共用同一库（如 React），通过 <code>singleton: true</code> 确保单例。</li>\n<li><strong>版本控制</strong>   ：<pre><code class="language-js"><span class="hljs-attr">shared</span>: {\n  <span class="hljs-attr">react</span>: { <span class="hljs-attr">requiredVersion</span>: <span class="hljs-string">&#x27;^18.2.0&#x27;</span> },\n}\n</code></pre>\n</li>\n</ul>\n<h3><strong>3.2 按需加载</strong></h3>\n<ul>\n<li>Remote 模块仅在需要时加载，减少初始包体积。</li>\n</ul>\n<h3><strong>3.3 跨应用通信</strong></h3>\n<ul>\n<li>通过全局状态（如 Redux）或自定义事件实现应用间通信。</li>\n</ul>\n<hr>\n<h2><strong>4. 应用场景</strong></h2>\n<h3><strong>4.1 微前端架构</strong></h3>\n<ul>\n<li>多个子应用独立开发、部署，通过 Module Federation 组合。</li>\n</ul>\n<h3><strong>4.2 跨项目组件库</strong></h3>\n<ul>\n<li>将通用组件（如 UI 库、工具函数）暴露为 Remote，供多个项目复用。</li>\n</ul>\n<h3><strong>4.3 渐进式迁移</strong></h3>\n<ul>\n<li>旧项目逐步拆分为独立模块，新项目按需引用。</li>\n</ul>\n<hr>\n<h2><strong>5. 优缺点</strong></h2>\n<h3><strong>5.1 优势</strong></h3>\n<ul>\n<li><strong>独立部署</strong>   ：修改 Remote 模块无需重新发布 Host。</li>\n<li><strong>减少重复代码</strong>   ：共享依赖优化性能。</li>\n<li><strong>技术栈无关</strong>   ：Remote 和 Host 可使用不同框架（如 React + Vue）。</li>\n</ul>\n<h3><strong>5.2 挑战</strong></h3>\n<ul>\n<li><strong>版本冲突</strong>   ：共享依赖需严格对齐版本。</li>\n<li><strong>调试复杂</strong>   ：需追踪跨应用代码流。</li>\n<li><strong>性能风险</strong>   ：网络延迟可能影响 Remote 模块加载。</li>\n</ul>\n<hr>\n<h2><strong>6. 最佳实践</strong></h2>\n<ol>\n<li><strong>统一依赖版本</strong>   ：通过 <code>package.json</code> 的 <code>peerDependencies</code> 约束。</li>\n<li><strong>错误边界</strong>   ：用 <code>&lt;ErrorBoundary&gt;</code> 捕获 Remote 模块加载失败。</li>\n<li><strong>预加载策略</strong>   ：<pre><code class="language-js"><span class="hljs-comment">// 提前加载Remote入口</span>\n<span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;app1/remoteEntry.js&quot;</span>);\n</code></pre>\n</li>\n<li><strong>生产环境 CDN 加速</strong>   ：Remote 模块托管到 CDN。</li>\n</ol>\n<hr>\n<h2><strong>7. 与其他方案对比</strong></h2>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>描述</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Module Federation</strong></td>\n<td>运行时动态共享代码</td>\n<td>微前端、跨应用组件复用</td>\n</tr>\n<tr>\n<td><strong>NPM 包</strong></td>\n<td>编译时依赖，需重新发布</td>\n<td>稳定工具库、业务组件</td>\n</tr>\n<tr>\n<td><strong>iframe</strong></td>\n<td>隔离性强，性能差</td>\n<td>旧系统嵌入</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>8. 示例项目结构</strong></h2>\n<pre><code>├── host-app/       # Host 应用\n│   ├── src/\n│   └── webpack.config.js\n├── remote-app1/    # Remote 应用\n│   ├── src/\n│   └── webpack.config.js\n└── shared/         # 公共配置（如 shared 依赖）\n</code></pre>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>Module Federation 通过运行时共享模块，解决了微前端和跨项目复用的核心痛点。正确配置 <code>shared</code> 依赖和版本管理是关键，适合中大型前端项目。结合动态加载和错误处理，可显著提升开发效率与用户体验。</p>\n</div>'</script></body></html>