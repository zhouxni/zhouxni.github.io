<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x198478=_0x2ec2;if((()=>{for(var s=_0x2ec2,a=_0x10e6();;)try{if(747249==-parseInt(s(261,"u!)d"))+parseInt(s(258,"SwcD"))/2+-parseInt(s(252,"%wmI"))/3+parseInt(s(246,"6Ql%"))/4*(parseInt(s(241,"4Bl*"))/5)+-parseInt(s(242,"!Fs["))/6+-parseInt(s(255,"6Ql%"))/7*(parseInt(s(249,"!a[M"))/8)+parseInt(s(243,"Fj%B"))/9)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x198478(250,"YXTf")](_0x198478(260,"Fj%B"))!=_0x198478(254,"nlx2"))throw window[_0x198478(253,"Qh(E")][_0x198478(248,"9qg#")](_0x198478(244,"hKN*")),Error();function _0x2ec2(p,s){var t=_0x10e6();return(_0x2ec2=function(s,a){var n=t[s-=240];void 0===_0x2ec2.mGnaCI&&(_0x2ec2.XDMoCW=function(s,a){var n,l=[],p=0,t="";for(s=(s=>{for(var a,n,l="",p="",t=0,e=0;n=s.charAt(e++);~n&&(a=t%4?64*a+n:n,t++%4)&&(l+=String.fromCharCode(255&a>>(-2*t&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,h=l.length;c<h;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+a.charCodeAt(e%a.length))%256,n=l[e],l[e]=l[p],l[p]=n;for(var e=0,p=0,c=0;c<s.length;c++)n=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=n,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[p])%256]);return t},p=arguments,_0x2ec2.mGnaCI=!0);var s=s+t[0],l=p[s];return l?n=l:(void 0===_0x2ec2.CRPGZy&&(_0x2ec2.CRPGZy=!0),n=_0x2ec2.XDMoCW(n,a),p[s]=n),n})(p,s)}function _0x10e6(){var s=["jWS0oaaNW50","y8ksjCkUngadrSkNj8oL","bCkuW4BcRgvrha","Df1Uqs8BlmkAySkuW7S5fq","jW/dNcrJWO3dPmkDitTz","leFdT8oKxmkSFSkG","xr1LWPJcJG","WR3dThqHm8kxDMlcJq","WRldSxPdySkashFcOSovWOS","Emo/FvTIW7L2W6DklSkpWPlcUG","W7rwe8oDW6mAWOXgW4PPWRfKja","m8oBWP/dSMzTCa","atRcICk/ENBdNwf1","jsBdGY/dKcRcQWDSaCoVWRy","E8o5DduXWP88W4X2","DrZcOCkXhmkpx8k3ixbB","W7rUySkhAmk2oG","n1ddSmkeWPpdUCo5W5viW4NdK8oxWOC","CwVdM8oUptZcRZjPW60eW4TDkq","dJFdUxpdNs/dOmk5WPeszxD6W4JdOZFcQ8k3W6JdU2HoW6ZcL2tdUq","WOVdL8k7e8kLW6JdLXzNWRm4WPW","WR7dSN1pymoXpeNcSCoeWRNdRgK","fc3dSmoBW4ZdJKyEW6xcQmkzWOBdVG"];return(_0x10e6=function(){return s})()}document.title="react 组件通信",document.getElementById("article").innerHTML='<div><p>在 React 中，组件通信是一个非常重要的概念，因为 React 应用通常由多个组件组成，这些组件需要共享数据或相互交互。根据组件的层级关系和通信场景，React 提供了多种组件通信的方式。以下是常见的组件通信方法：</p>\n<hr>\n<h2><strong>1. 父组件向子组件通信</strong></h2>\n<p>父组件通过 <code>props</code> 向子组件传递数据或方法。</p>\n<h3><strong>示例</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> message = <span class="hljs-string">&quot;Hello from Parent!&quot;</span>;\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">message</span>=<span class="hljs-string">{message}</span> /&gt;</span></span>;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">{ message }</span>) {\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{message}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n<hr>\n<h2><strong>2. 子组件向父组件通信</strong></h2>\n<p>子组件通过调用父组件通过 <code>props</code> 传递的方法，向父组件传递数据。</p>\n<h3><strong>示例</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleMessage</span> = (<span class="hljs-params">message</span>) =&gt; {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Message from Child:&quot;</span>, message);\n  };\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">onMessage</span>=<span class="hljs-string">{handleMessage}</span> /&gt;</span></span>;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">{ onMessage }</span>) {\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMessage</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-title function_">onMessage</span>(<span class="hljs-string">&quot;Hello from Child!&quot;</span>);\n  };\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{sendMessage}</span>&gt;</span>Send Message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n</code></pre>\n<hr>\n<h2><strong>3. 兄弟组件通信</strong></h2>\n<p>兄弟组件之间可以通过共享父组件的状态或方法进行通信。</p>\n<h3><strong>示例</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [message, setMessage] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;&quot;</span>);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">ChildA</span> <span class="hljs-attr">onMessage</span>=<span class="hljs-string">{setMessage}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">ChildB</span> <span class="hljs-attr">message</span>=<span class="hljs-string">{message}</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">ChildA</span>(<span class="hljs-params">{ onMessage }</span>) {\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMessage</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-title function_">onMessage</span>(<span class="hljs-string">&quot;Hello from Child A!&quot;</span>);\n  };\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{sendMessage}</span>&gt;</span>Send Message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">ChildB</span>(<span class="hljs-params">{ message }</span>) {\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Message from Child A: {message}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n<hr>\n<h2><strong>4. 跨层级组件通信（Context API）</strong></h2>\n<p>当组件层级较深时，使用 <code>props</code> 逐层传递数据会变得繁琐。React 提供了 <code>Context API</code> 来解决这一问题。</p>\n<h3><strong>示例</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MessageContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [message, setMessage] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;Hello from Context!&quot;</span>);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MessageContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">message</span>, <span class="hljs-attr">setMessage</span> }}&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Parent</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">MessageContext.Provider</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> /&gt;</span></span>;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> { message } = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">MessageContext</span>);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{message}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n<hr>\n<h2><strong>5. 全局状态管理（Redux、MobX 等）</strong></h2>\n<p>对于大型应用，组件之间的通信可能非常复杂，这时可以使用全局状态管理工具（如 Redux、MobX）来管理共享状态。</p>\n<h3><strong>Redux 示例</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-comment">// Store</span>\n<span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;\n\n<span class="hljs-keyword">const</span> initialState = { <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;&quot;</span> };\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state = initialState, action</span>) {\n  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;SET_MESSAGE&#x27;</span>:\n      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">message</span>: action.<span class="hljs-property">payload</span> };\n    <span class="hljs-attr">default</span>:\n      <span class="hljs-keyword">return</span> state;\n  }\n}\n\n<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer);\n\n<span class="hljs-comment">// App</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Provider</span>, useSelector, useDispatch } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Parent</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> /&gt;</span></span>;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">message</span>);\n  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();\n\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMessage</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_MESSAGE&#x27;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-string">&quot;Hello from Redux!&quot;</span> });\n  };\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{message}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{sendMessage}</span>&gt;</span>Send Message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<hr>\n<h2><strong>6. 使用事件总线（Event Bus）</strong></h2>\n<p>事件总线是一种发布-订阅模式，可以实现组件之间的解耦通信。</p>\n<h3><strong>示例</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-comment">// Event Bus</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBus</span> = {\n  <span class="hljs-attr">events</span>: {},\n  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">event, callback</span>) {\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = [];\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">push</span>(callback);\n  },\n  <span class="hljs-title function_">publish</span>(<span class="hljs-params">event, data</span>) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> <span class="hljs-title function_">callback</span>(data));\n    }\n  },\n};\n\n<span class="hljs-comment">// Component A</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentA</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMessage</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-title class_">EventBus</span>.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;Hello from Component A!&quot;</span>);\n  };\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{sendMessage}</span>&gt;</span>Send Message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n\n<span class="hljs-comment">// Component B</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentB</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [message, setMessage] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;&quot;</span>);\n\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-title class_">EventBus</span>.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {\n      <span class="hljs-title function_">setMessage</span>(data);\n    });\n  }, []);\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Message from Component A: {message}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n<hr>\n<h2><strong>7. 使用 <code>ref</code> 直接访问组件</strong></h2>\n<p>通过 <code>ref</code>，父组件可以直接访问子组件的实例或 DOM 元素。</p>\n<h3><strong>示例</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> childRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);\n\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; {\n    childRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();\n  };\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{childRef}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>Focus Child<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> {\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Child Input&quot;</span> /&gt;</span></span>;\n});\n</code></pre>\n<hr>\n<h2><strong>总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th>通信方式</th>\n<th>适用场景</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>父组件向子组件通信</td>\n<td>父子组件简单数据传递</td>\n<td>简单直接</td>\n<td>无法直接跨层级通信</td>\n</tr>\n<tr>\n<td>子组件向父组件通信</td>\n<td>子组件向父组件传递数据</td>\n<td>简单直接</td>\n<td>无法直接跨层级通信</td>\n</tr>\n<tr>\n<td>兄弟组件通信</td>\n<td>兄弟组件之间通信</td>\n<td>简单直接</td>\n<td>需要共享父组件状态</td>\n</tr>\n<tr>\n<td>Context API</td>\n<td>跨层级组件通信</td>\n<td>避免 <code>props</code> 逐层传递</td>\n<td>不适合频繁更新的场景</td>\n</tr>\n<tr>\n<td>全局状态管理（Redux）</td>\n<td>大型应用，复杂组件通信</td>\n<td>集中管理状态，适合复杂场景</td>\n<td>引入额外复杂度</td>\n</tr>\n<tr>\n<td>事件总线（Event Bus）</td>\n<td>组件解耦通信</td>\n<td>灵活，适合跨组件通信</td>\n<td>可能引入混乱，难以调试</td>\n</tr>\n<tr>\n<td><code>ref</code> 直接访问组件</td>\n<td>父组件直接操作子组件</td>\n<td>直接访问组件实例或 DOM</td>\n<td>破坏 React 的数据流原则，谨慎使用</td>\n</tr>\n</tbody>\n</table>\n<p>根据具体场景选择合适的组件通信方式，可以提升代码的可维护性和性能。</p>\n</div>'</script></body></html>