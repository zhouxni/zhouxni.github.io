<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4d2d(){var n=["W5q6WPRdG2OvzmodhrVdJce","xmoTiCoxiqhdOGe2emky","W6m1WOblbKrHAG","be1wpmkYW4X9l8o9W5hcNmol","nWRdKCkIWPnPxmkKoN7cP8oiWPO","vCoDWRnGeSoEu8kkFu9+qCo2","bYDYh8oIW6fTW6xdSa","rXGuzmoQWPTF","fYxdOSo1WReve2muW5ux","lJFcTSoOsSk+WQ/cQxv1W7PviG","WPz9W5/cHYm","z8kTtavfW6brWPNdSt7dQYhdJG","rv8nj8oKFJy","y2xdPMdcLmoHBwTcW4Hrra","W6/cSu5BW5tdK8kFjSkgW6RcOSohemkpB8kWD8k/wJGgh8oiDmkqoG","zCkVtWvkW6WMWRxdRJVdTqe","dMbCdmksc8ocnSk5A8kF","W5a6WPVdGwHrEmovoHNdMa","WRXSW5ztqvPcWPzyW4BdUCoF"];return(_0x4d2d=function(){return n})()}var _0x3e80c9=_0x1589;function _0x1589(o,n){var r=_0x4d2d();return(_0x1589=function(n,s){var t=r[n-=259];void 0===_0x1589.owLSQS&&(_0x1589.mgRcAx=function(n,s){var t,a=[],o=0,r="";for(n=(n=>{for(var s,t,a="",o="",r=0,l=0;t=n.charAt(l++);~t&&(s=r%4?64*s+t:t,r++%4)&&(a+=String.fromCharCode(255&s>>(-2*r&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var e=0,d=a.length;e<d;e++)o+="%"+("00"+a.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(o)})(n),l=0;l<256;l++)a[l]=l;for(l=0;l<256;l++)o=(o+a[l]+s.charCodeAt(l%s.length))%256,t=a[l],a[l]=a[o],a[o]=t;for(var l=0,o=0,e=0;e<n.length;e++)t=a[l=(l+1)%256],a[l]=a[o=(o+a[l])%256],a[o]=t,r+=String.fromCharCode(n.charCodeAt(e)^a[(a[l]+a[o])%256]);return r},o=arguments,_0x1589.owLSQS=!0);var n=n+r[0],a=o[n];return a?t=a:(void 0===_0x1589.RVJOjU&&(_0x1589.RVJOjU=!0),t=_0x1589.mgRcAx(t,s),o[n]=t),t})(o,n)}if((()=>{for(var n=_0x1589,s=_0x4d2d();;)try{if(147455==-parseInt(n(262,"XHRU"))+parseInt(n(276,"H4OD"))/2+-parseInt(n(267,"HqK2"))/3+-parseInt(n(271,"^v9["))/4+-parseInt(n(259,"@mrH"))/5+parseInt(n(272,"F^js"))/6+parseInt(n(265,"ZTS4"))/7)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x3e80c9(266,"cM#4")](_0x3e80c9(260,"1ut6"))!=_0x3e80c9(264,"^v9["))throw window[_0x3e80c9(275,"4SjO")][_0x3e80c9(261,"H4OD")](_0x3e80c9(268,"!i%q")),Error();document.title="BroadcastChannel 详解",document.getElementById("article").innerHTML='<div><h3><strong>BroadcastChannel 详解</strong></h3>\n<p><code>BroadcastChannel</code> 是一种允许同源的不同浏览上下文（如标签页、窗口、iframe）进行双向通信的 Web API。它提供了一种简单且高效的方式，使得同一来源的多个页面可以实时地发送和接收消息，而无需依赖服务器或复杂的设置。</p>\n<hr>\n<h3><strong>1. 基本概念</strong></h3>\n<ul>\n<li><strong>同源策略</strong>  ：<code>BroadcastChannel</code> 只能在同源（same origin）的页面间通信。同源意味着协议、域名和端口号必须相同。</li>\n<li><strong>频道名称</strong>  ：通过指定一个频道名称，不同的浏览上下文可以加入同一个频道进行通信。</li>\n<li><strong>实时通信</strong>  ：消息是实时推送的，接收方会立即收到消息，无需轮询。</li>\n</ul>\n<hr>\n<h3><strong>2. 使用场景</strong></h3>\n<ul>\n<li><strong>跨标签页通信</strong>  ：在多个标签页之间共享数据或状态。</li>\n<li><strong>实时更新</strong>  ：当某个标签页的数据发生变化时，通知其他标签页进行更新。</li>\n<li><strong>协作应用</strong>  ：在多人协作的应用中，实现实时的数据同步。</li>\n</ul>\n<hr>\n<h3><strong>3. 基本用法</strong></h3>\n<h4><strong>步骤</strong></h4>\n<ol>\n<li><strong>创建频道</strong>  ：在所有需要通信的浏览上下文中，使用相同的频道名称创建 <code>BroadcastChannel</code> 实例。</li>\n<li><strong>发送消息</strong>  ：通过 <code>postMessage</code> 方法向频道发送消息。</li>\n<li><strong>接收消息</strong>  ：通过监听 <code>message</code> 事件接收来自频道的消息。</li>\n</ol>\n<h4><strong>示例代码</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 创建或加入名为 &#x27;my_channel&#x27; 的频道</span>\n<span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BroadcastChannel</span>(<span class="hljs-string">&#x27;my_channel&#x27;</span>);\n\n<span class="hljs-comment">// 发送消息</span>\nchannel.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;GREETING&#x27;</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Hello from another tab!&#x27;</span> });\n\n<span class="hljs-comment">// 接收消息</span>\nchannel.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received message:&#x27;</span>, event.<span class="hljs-property">data</span>);\n  <span class="hljs-comment">// 根据消息类型处理消息</span>\n  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span>.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;GREETING&#x27;</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">data</span>.<span class="hljs-property">text</span>);\n  }\n};\n\n<span class="hljs-comment">// 可选：关闭频道（当不再需要时）</span>\n<span class="hljs-comment">// channel.close();</span>\n</code></pre>\n<hr>\n<h3><strong>4. 优点</strong></h3>\n<ul>\n<li><strong>简单易用</strong>  ：API 设计直观，易于实现跨标签页通信。</li>\n<li><strong>实时性高</strong>  ：消息是实时推送的，无需轮询。</li>\n<li><strong>无需服务器</strong>  ：完全在客户端实现，无需服务器支持。</li>\n<li><strong>支持双向通信</strong>  ：既可以发送消息，也可以接收消息。</li>\n</ul>\n<hr>\n<h3><strong>5. 缺点</strong></h3>\n<ul>\n<li><strong>同源限制</strong>  ：只能在同源的页面间通信，限制了其使用范围。</li>\n<li><strong>浏览器支持</strong>  ：虽然现代浏览器普遍支持，但在一些旧版浏览器中可能不可用。</li>\n<li><strong>安全性</strong>  ：由于是同源通信，需要注意数据的安全性，避免敏感信息泄露。</li>\n</ul>\n<hr>\n<h3><strong>6. 浏览器支持</strong></h3>\n<ul>\n<li><strong>现代浏览器</strong>  ：Chrome、Firefox、Safari、Edge 等都支持 <code>BroadcastChannel</code>。</li>\n<li><strong>移动浏览器</strong>  ：大多数移动浏览器也支持 <code>BroadcastChannel</code>。</li>\n<li><strong>检查支持</strong>  ：在使用前，可以通过以下代码检查浏览器是否支持 <code>BroadcastChannel</code>：</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;BroadcastChannel&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;BroadcastChannel is supported&#x27;</span>);\n} <span class="hljs-keyword">else</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;BroadcastChannel is not supported&#x27;</span>);\n}\n</code></pre>\n<hr>\n<h3><strong>7. 与其他通信方式的比较</strong></h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>实时性</th>\n<th>复杂度</th>\n<th>浏览器支持</th>\n<th>同源限制</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>localStorage</code> + <code>storage</code> 事件</td>\n<td>高</td>\n<td>低</td>\n<td>广泛</td>\n<td>是</td>\n<td>简单的跨标签页通信</td>\n</tr>\n<tr>\n<td><code>BroadcastChannel</code></td>\n<td>高</td>\n<td>低</td>\n<td>现代浏览器</td>\n<td>是</td>\n<td>同源标签页间的实时通信</td>\n</tr>\n<tr>\n<td>WebSocket</td>\n<td>高</td>\n<td>高</td>\n<td>广泛</td>\n<td>否</td>\n<td>需要服务器支持的实时通信</td>\n</tr>\n<tr>\n<td>Service Worker</td>\n<td>高</td>\n<td>中</td>\n<td>现代浏览器</td>\n<td>否（可跨域，但实现复杂）</td>\n<td>复杂的后台处理和跨标签页通信</td>\n</tr>\n<tr>\n<td>SharedWorker</td>\n<td>中</td>\n<td>中</td>\n<td>有限</td>\n<td>是</td>\n<td>需要共享状态和计算资源的场景</td>\n</tr>\n</tbody>\n</table>\n<p><strong>推荐</strong>  ：</p>\n<ul>\n<li>如果只需要简单的同源标签页通信，<strong><code>BroadcastChannel</code></strong>   是最佳选择。</li>\n<li>如果需要跨域通信或更复杂的场景，可以考虑使用 <strong>WebSocket</strong>   或 <strong>Service Worker</strong>  。</li>\n</ul>\n<hr>\n<h3><strong>8. 注意事项</strong></h3>\n<ul>\n<li><strong>频道名称</strong>  ：确保频道名称唯一且有意义，避免与其他应用或频道冲突。</li>\n<li><strong>消息格式</strong>  ：建议使用结构化的消息格式（如 JSON），以便于解析和处理。</li>\n<li><strong>错误处理</strong>  ：在发送和接收消息时，添加适当的错误处理逻辑，以提高应用的健壮性。</li>\n<li><strong>性能考虑</strong>  ：避免频繁发送大量消息，以免影响性能。</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<p><code>BroadcastChannel</code> 是一种强大且易于使用的 API，适用于同源标签页间的实时通信。它简化了跨标签页通信的实现，提供了高效、实时的消息推送机制。在合适的场景下，使用 <code>BroadcastChannel</code> 可以显著提升 Web 应用的用户体验和交互性。</p>\n</div>'</script></body></html>