<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x58a8cd=_0x3d3e;if((()=>{for(var n=_0x3d3e,s=_0x5832();;)try{if(387179==+parseInt(n(192,"ABuv"))*(parseInt(n(176,"XU$o"))/2)+-parseInt(n(191,"A0HF"))/3+-parseInt(n(195,"R]in"))/4+-parseInt(n(178,"#JJ$"))/5*(-parseInt(n(172,"YO*V"))/6)+parseInt(n(173,"QADH"))/7+parseInt(n(185,"p*G5"))/8+-parseInt(n(193,"HVpq"))/9)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x58a8cd(177,"jJBh")](_0x58a8cd(188,"OO4s"))!=_0x58a8cd(186,"R%55"))throw window[_0x58a8cd(189,"MmQR")][_0x58a8cd(179,"A0HF")](_0x58a8cd(183,"YO*V")),Error();function _0x3d3e(e,n){var c=_0x5832();return(_0x3d3e=function(n,s){var t=c[n-=172];void 0===_0x3d3e.xySPJX&&(_0x3d3e.neibzf=function(n,s){var t,o=[],e=0,c="";for(n=(n=>{for(var s,t,o="",e="",c=0,a=0;t=n.charAt(a++);~t&&(s=c%4?64*s+t:t,c++%4)&&(o+=String.fromCharCode(255&s>>(-2*c&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var l=0,r=o.length;l<r;l++)e+="%"+("00"+o.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(e)})(n),a=0;a<256;a++)o[a]=a;for(a=0;a<256;a++)e=(e+o[a]+s.charCodeAt(a%s.length))%256,t=o[a],o[a]=o[e],o[e]=t;for(var a=0,e=0,l=0;l<n.length;l++)t=o[a=(a+1)%256],o[a]=o[e=(e+o[a])%256],o[e]=t,c+=String.fromCharCode(n.charCodeAt(l)^o[(o[a]+o[e])%256]);return c},e=arguments,_0x3d3e.xySPJX=!0);var n=n+c[0],o=e[n];return o?t=o:(void 0===_0x3d3e.YdlQjK&&(_0x3d3e.YdlQjK=!0),t=_0x3d3e.neibzf(t,s),e[n]=t),t})(e,n)}function _0x5832(){var n=["s8kDvJVcPSk3dG","wCkksdJcVZddMCkdbmk3nmo/W6a","cSoifg/dTCoNwCkPW7hcHbNdM8oB","W4PowXPCWQymWQdcUvi","vSoImLzMwmoLW5BcQK3dNMuxWQ5EWQdcVSo5W47cG8kTW7H2iCooBG","CMvVWRxcIWLtiq","t8k5oGZdTCkwW4RcTSoiqmkaW7JcQq","rCksmmklW4u","W5RcLCoyWRO5gCoOW7OPWRldQmoy","FSoeoeVcPxRcVHxdNq","WQm+W7LAqhFdHSog","smk8p3NcOmoKWPtcSSos","cSolfgpdTCoJl8kKW6FcQH7dOq","WRSxgmkcW7CYrZWI","gColuCkSW6zwnMBcHNlcTgNcOa","iYBcJtrFW5L0rshdV1aQW58","WOWGW4xdUYiDmSosWQmBjhCe","d8kKcgXFlmkbWQ4","p8obW6xcP1qgW5ddTmoHWQWZEau","dmokeg/dSmoTu8kmW4xcKchdVSop","WOzRimk7DCkfWPhdJtv+WR18WQa","tq5EW6O/WRKRc2dcHq","WR58W4pdJK1thG","WRlcGCoRhCkAkZBcISofC8o0W6JdKW"];return(_0x5832=function(){return n})()}document.title="Vue 3  getCurrentInstance() 的 proxy 和 ctx ",document.getElementById("article").innerHTML='<div><p>在 Vue 3 中，<code>getCurrentInstance()</code> 返回的实例对象包含 <code>proxy</code> 和 <code>ctx</code> 两个重要属性，它们都与组件实例的上下文相关，但存在关键区别：</p>\n<h3>1. <code>proxy</code> 属性</h3>\n<ul>\n<li><strong>本质</strong>   ：组件实例的<strong>代理对象</strong>   ，等同于 Options API 中的 <code>this</code></li>\n<li><strong>特点</strong>   ：\n<ul>\n<li>提供对组件公开属性的<strong>响应式访问</strong>   （包括 props、data、methods、computed 等）</li>\n<li>会自动代理到组件的 <code>setup</code> 上下文和选项式 API 中定义的属性</li>\n<li>支持 TypeScript 类型推断，开发体验更好</li>\n</ul>\n</li>\n<li><strong>使用场景</strong>   ：在组合式 API 中访问组件的公开属性和方法</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { getCurrentInstance } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>\n\n<span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> instance = <span class="hljs-title function_">getCurrentInstance</span>()\n\n  <span class="hljs-comment">// 访问 props（响应式）</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">proxy</span>.<span class="hljs-property">title</span>)\n\n  <span class="hljs-comment">// 调用组件方法</span>\n  instance.<span class="hljs-property">proxy</span>.<span class="hljs-title function_">handleClick</span>()\n\n  <span class="hljs-comment">// 访问全局属性（如 $router）</span>\n  instance.<span class="hljs-property">proxy</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/home&#x27;</span>)\n}\n</code></pre>\n<h3>2. <code>ctx</code> 属性</h3>\n<ul>\n<li><strong>本质</strong>   ：组件实例的<strong>内部上下文对象</strong>   ，存储组件的内部状态</li>\n<li><strong>特点</strong>   ：\n<ul>\n<li>直接暴露组件内部属性，<strong>不经过响应式代理</strong></li>\n<li>包含更多内部实现细节（如 <code>_props</code>、<code>_emit</code> 等私有属性）</li>\n<li>生产环境下可能被压缩或修改，属性名可能变为类似 <code>_v</code> 这样的短名称</li>\n<li>不支持 TypeScript 类型推断，类型不安全</li>\n</ul>\n</li>\n<li><strong>使用场景</strong>   ：主要用于 Vue 内部或高级库开发，不推荐在业务代码中使用</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// 不推荐在业务代码中使用</span>\n<span class="hljs-keyword">const</span> instance = <span class="hljs-title function_">getCurrentInstance</span>();\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">ctx</span>.<span class="hljs-property">_props</span>); <span class="hljs-comment">// 直接访问内部 props 存储</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">ctx</span>.<span class="hljs-title function_">_emit</span>(<span class="hljs-string">&quot;event&quot;</span>)); <span class="hljs-comment">// 直接调用内部 emit 方法</span>\n</code></pre>\n<h3>核心区别对比</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>proxy</code></th>\n<th><code>ctx</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>响应式</td>\n<td>支持（访问的是响应式代理）</td>\n<td>不支持（直接访问原始数据）</td>\n</tr>\n<tr>\n<td>公开性</td>\n<td>仅暴露组件公开 API</td>\n<td>包含内部实现细节</td>\n</tr>\n<tr>\n<td>生产环境</td>\n<td>稳定可用</td>\n<td>可能被压缩或修改</td>\n</tr>\n<tr>\n<td>类型支持</td>\n<td>良好（支持 TypeScript）</td>\n<td>差（无类型提示）</td>\n</tr>\n<tr>\n<td>推荐使用</td>\n<td>业务开发中推荐</td>\n<td>仅内部/库开发使用</td>\n</tr>\n</tbody>\n</table>\n<h3>注意事项</h3>\n<ol>\n<li>\n<p><strong>生产环境差异</strong>   ：</p>\n<ul>\n<li><code>proxy</code> 在生产环境中仍然可用，但部分调试信息会被移除</li>\n<li><code>ctx</code> 在生产环境中属性名会被混淆（如 <code>props</code> 可能变成 <code>_p</code>），不建议依赖</li>\n</ul>\n</li>\n<li>\n<p><strong>访问全局属性</strong>   ：</p>\n<ul>\n<li>通过 <code>proxy</code> 访问更安全：<code>instance.proxy.$http</code></li>\n<li>避免通过 <code>ctx</code> 访问：<code>instance.ctx.$http</code>（生产环境可能失效）</li>\n</ul>\n</li>\n<li>\n<p><strong>最佳实践</strong>   ：</p>\n<ul>\n<li>业务开发中优先使用 <code>proxy</code>（或直接使用 <code>setup</code> 参数和标准 API）</li>\n<li>避免使用 <code>ctx</code>，除非你明确知道自己在做什么（如开发组件库）</li>\n</ul>\n</li>\n</ol>\n<p>总结：<code>proxy</code> 是面向开发者的安全接口，而 <code>ctx</code> 更接近 Vue 内部实现，使用时需格外谨慎。</p>\n</div>'</script></body></html>