<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0xd7d3ed=_0x4296;function _0x4296(o,s){var e=_0x5583();return(_0x4296=function(s,n){var a=e[s-=426];void 0===_0x4296.FmqiIX&&(_0x4296.LqBVeK=function(s,n){var a,l=[],o=0,e="";for(s=(s=>{for(var n,a,l="",o="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=l.length;c<r;c++)o+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(o)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)o=(o+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[o],l[o]=a;for(var p=0,o=0,c=0;c<s.length;c++)a=l[p=(p+1)%256],l[p]=l[o=(o+l[p])%256],l[o]=a,e+=String.fromCharCode(s.charCodeAt(c)^l[(l[p]+l[o])%256]);return e},o=arguments,_0x4296.FmqiIX=!0);var s=s+e[0],l=o[s];return l?a=l:(void 0===_0x4296.DYXAqY&&(_0x4296.DYXAqY=!0),a=_0x4296.LqBVeK(a,n),o[s]=a),a})(o,s)}function _0x5583(){var s=["WPhdQmowyCoTsCoKWQHuuMe","e8kFWRtcGCoqW58hWPWh","dY9AW4m4EmkPugJdJM0","lXuAW7/cTCkPWOlcIa","WPugEmogeH0nfCoXW4vZ","W4dcImoPWPddNqpcJJebWPNcLqu","W6iMWPpdJ8kxWPpcU8oV","nhabhu/dUmkNWQvoWPK7","qK8eWOOIDCok","rCkca07dObVcQCkEW547rYxdIa","W6JdOfbpeSoIWQjG","saFdNgFdNSo3bMy0WPxdUa","W5fhm8kgxW","eSkNWQ/cHSoyeXddV3RdNSo+dCkpWPy","BSkdiqaiymosW58","W4pcG8oLWPpdNqxdLw48WQNcGalcSuO","WRyrfNBdIHPt","gCkNWQhcG8kLreFcMMRdJW","WRumg8ohtNxdV8kEW5/cICkv","W6uGW6ZcJSo0WRlcOmo9amolWPK","obG6WO/dN8o1vmkxWRqjWPq","DCo3W63cKCkUDmk0iaO8","jmkXWQ/dLCkylmo+wsq9wuBdUSoRWO7dTCo6ECkNW77cMx0wWQDHta","BuxcPCkzfSoIt3DunGusWRK","duC0kI9PW4ZdTq","W7bZAqhcLCoTWRnXWPC","WOOLWPnEqXq/WQa","W5ddQCkzWRtdVrFcKh1Fx8o8pq","oZxcS8kEW5VdGfdcRG","WRmcv8krlKddISkQ","W4VdUufRWOxdTg/dPuy","W4VdVdThWQFdOgFdKG"];return(_0x5583=function(){return s})()}if((()=>{for(var s=_0x4296,n=_0x5583();;)try{if(947268==+parseInt(s(431,"C4zv"))*(-parseInt(s(432,"mqKH"))/2)+parseInt(s(447,"U(w5"))/3*(-parseInt(s(427,"f&si"))/4)+-parseInt(s(437,"WsAg"))/5*(parseInt(s(454,"8iOg"))/6)+-parseInt(s(457,"LHNe"))/7*(-parseInt(s(430,"zFb!"))/8)+parseInt(s(455,"BdC("))/9*(parseInt(s(429,"Askr"))/10)+parseInt(s(428,"gT7n"))/11*(parseInt(s(445,"tE[i"))/12)+parseInt(s(441,"tE[i"))/13)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0xd7d3ed(436,"wbYI")](_0xd7d3ed(453,"C2RD"))!=_0xd7d3ed(440,"mqKH"))throw window[_0xd7d3ed(442,"frBX")][_0xd7d3ed(444,"EeO5")](_0xd7d3ed(450,"mrJX")),Error();document.title="globalThis 详解",document.getElementById("article").innerHTML='<div><p><code>globalThis</code> 是 JavaScript 语言标准中定义的全局对象引用，旨在统一不同执行环境下访问全局对象的方式，解决了历史上不同环境中全局对象名称不一致的问题。</p>\n<h3>为什么需要 <code>globalThis</code>？</h3>\n<p>在 <code>globalThis</code> 出现之前，JavaScript 不同执行环境的全局对象有不同的名称：</p>\n<ul>\n<li>浏览器主环境：<code>window</code></li>\n<li>Web Worker 环境：<code>self</code></li>\n<li>Node.js 环境：<code>global</code></li>\n<li>部分非标准环境：可能使用其他名称</li>\n</ul>\n<p>这导致跨环境代码需要特殊处理，而 <code>globalThis</code> 提供了一致的访问方式，无论代码运行在什么环境。</p>\n<h3>核心特性</h3>\n<ol>\n<li>\n<p><strong>环境无关性</strong></p>\n<ul>\n<li>在所有 JavaScript 环境中均指向全局对象</li>\n<li>无需检测运行环境即可访问全局对象</li>\n</ul>\n</li>\n<li>\n<p><strong>与全局作用域的关系</strong></p>\n<ul>\n<li>在全局作用域中声明的变量会成为 <code>globalThis</code> 的属性</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">&quot;我是全局变量&quot;</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalThis.<span class="hljs-property">globalVar</span>); <span class="hljs-comment">// &quot;我是全局变量&quot;</span>\n</code></pre>\n<ul>\n<li>注意：<code>let</code>/<code>const</code> 声明的全局变量不会成为 <code>globalThis</code> 的属性</li>\n</ul>\n</li>\n<li>\n<p><strong>与 <code>this</code> 的区别</strong></p>\n<ul>\n<li>在全局作用域中，<code>this</code> 在非模块环境下指向全局对象，但在模块环境中 <code>this</code> 是 <code>undefined</code></li>\n<li><code>globalThis</code> 在任何情况下都指向全局对象，包括模块环境</li>\n</ul>\n</li>\n<li>\n<p><strong>安全性</strong></p>\n<ul>\n<li>在严格模式下，函数中的 <code>this</code> 是 <code>undefined</code>，但 <code>globalThis</code> 仍可正常访问</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// undefined</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalThis); <span class="hljs-comment">// 全局对象</span>\n}\n<span class="hljs-title function_">test</span>();\n</code></pre>\n</li>\n</ol>\n<h3>使用场景</h3>\n<ol>\n<li>\n<p><strong>跨环境代码</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 无需环境检测即可使用全局对象</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">getGlobalObject</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> globalThis;\n}\n</code></pre>\n</li>\n<li>\n<p><strong>全局变量检测</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 检查是否存在全局变量</span>\n<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> globalThis.<span class="hljs-property">fetch</span> === <span class="hljs-string">&quot;function&quot;</span>) {\n  <span class="hljs-comment">// 使用 fetch API</span>\n} <span class="hljs-keyword">else</span> {\n  <span class="hljs-comment">// 提供降级方案</span>\n}\n</code></pre>\n</li>\n<li>\n<p><strong>定义全局变量</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在任何环境下定义全局变量</span>\nglobalThis.<span class="hljs-property">myLibrary</span> = {\n  <span class="hljs-attr">version</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,\n  <span class="hljs-comment">// ...</span>\n};\n</code></pre>\n</li>\n</ol>\n<h3>兼容性</h3>\n<ul>\n<li>现代浏览器（Chrome 71+、Firefox 65+、Safari 12.1+）</li>\n<li>Node.js 12.0.0+</li>\n<li>对于旧环境，可以使用 polyfill：<pre><code class="language-javascript"><span class="hljs-comment">// 简单的 globalThis polyfill</span>\n<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> globalThis === <span class="hljs-string">&quot;undefined&quot;</span>) {\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> self !== <span class="hljs-string">&quot;undefined&quot;</span>) {\n    self.<span class="hljs-property">globalThis</span> = self;\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">&quot;undefined&quot;</span>) {\n    <span class="hljs-variable language_">window</span>.<span class="hljs-property">globalThis</span> = <span class="hljs-variable language_">window</span>;\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">global</span> !== <span class="hljs-string">&quot;undefined&quot;</span>) {\n    <span class="hljs-variable language_">global</span>.<span class="hljs-property">globalThis</span> = <span class="hljs-variable language_">global</span>;\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;无法确定全局对象&quot;</span>);\n  }\n}\n</code></pre>\n</li>\n</ul>\n<h3>注意事项</h3>\n<ol>\n<li>避免过度使用全局对象，可能导致命名冲突和代码维护问题</li>\n<li>在模块系统中，<code>globalThis</code> 是访问全局对象的唯一可靠方式</li>\n<li><code>globalThis</code> 本身是不可配置、不可写的<pre><code class="language-javascript">globalThis = {}; <span class="hljs-comment">// TypeError: Assignment to constant variable</span>\n</code></pre>\n</li>\n</ol>\n<p>总结来说，<code>globalThis</code> 是 JavaScript 标准化进程中的重要改进，为跨环境开发提供了便利，是编写可移植 JavaScript 代码的推荐方案。</p>\n</div>'</script></body></html>