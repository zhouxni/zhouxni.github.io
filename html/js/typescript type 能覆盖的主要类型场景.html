<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x342d(){var s=["WPNcQCkgWPtcUNtdPvu2hCk6r3C","W4/cMSk6WRGGWOPX","nhuEt8kYEKOSWR9o","W4j/jZzqpSonvHdcUmkXW4W6WO7cPsv+WOhcSLJdU8oslmkjjY0","u8oTWPGXW6WQiKFcKq","W5pdKSo2zY52WOCFWOrLgCkz","CCk5wmkhWOH6BCouWRrRWP1Z","dCoYW53cLSoTW7mUnmoKWRBcMMKC","W5vXftW0DCoZ","qb4qWPaqjCk4nCoYtwa","k8onW79ncSozWP0asmkSsSkThG","WQD0W7/cN8o7nmonya","WQP9WPZdPSk2kWv3fSo4W5q","W75uWRSFWPvdW6ddJL56i8kTra","jSk2W45NWQCZdNRcG8kgaa","WQ4Lke3cOSkLoa","WPNdICo/W4rMWQn2hCkkiHS","WP/cQSkcWPFcSNhdP0qdemkACvm","W7ORW7VcH8oMg8oWsW","yHpcOwVdQ8ocr2XShN/cJmk+","WOldHZFcVCo7xq4","ue/cNmoixbVdLxZcKSkFW7/cTCkd","h8kiv0hcTW"];return(_0x342d=function(){return s})()}function _0x1fb8(e,s){var p=_0x342d();return(_0x1fb8=function(s,n){var a=p[s-=296];void 0===_0x1fb8.KAogli&&(_0x1fb8.rDmczH=function(s,n){var a,l=[],e=0,p="";for(s=(s=>{for(var n,a,l="",e="",p=0,c=0;a=s.charAt(c++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,r=l.length;t<r;t++)e+="%"+("00"+l.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(e)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)e=(e+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[e],l[e]=a;for(var c=0,e=0,t=0;t<s.length;t++)a=l[c=(c+1)%256],l[c]=l[e=(e+l[c])%256],l[e]=a,p+=String.fromCharCode(s.charCodeAt(t)^l[(l[c]+l[e])%256]);return p},e=arguments,_0x1fb8.KAogli=!0);var s=s+p[0],l=e[s];return l?a=l:(void 0===_0x1fb8.UNlBIl&&(_0x1fb8.UNlBIl=!0),a=_0x1fb8.rDmczH(a,n),e[s]=a),a})(e,s)}var _0xfb1d64=_0x1fb8;if((()=>{for(var s=_0x1fb8,n=_0x342d();;)try{if(862397==+parseInt(s(310,"3bv&"))+parseInt(s(303,"sXi*"))/2+-parseInt(s(313,"62(*"))/3*(-parseInt(s(311,"FUe&"))/4)+parseInt(s(314,")ovS"))/5*(-parseInt(s(296,"62(*"))/6)+-parseInt(s(315,"8[eI"))/7+parseInt(s(305,"f@fR"))/8*(parseInt(s(298,"[j4c"))/9)+-parseInt(s(302,"zGeS"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0xfb1d64(297,"*n7M")](_0xfb1d64(300,"3bv&"))!=_0xfb1d64(318,"syk1"))throw window[_0xfb1d64(307,")ovS")][_0xfb1d64(316,"WyRZ")](_0xfb1d64(299,"Xvav")),Error();document.title="typescript type 能覆盖的主要类型场景",document.getElementById("article").innerHTML='<div><p>TypeScript 中的 <code>type</code>（类型别名）虽然功能强大，几乎能覆盖绝大多数类型声明场景，但<strong>并不能声明所有类型</strong>   。它与 <code>interface</code> 等类型声明方式各有侧重，存在一些场景只能通过其他方式（如 <code>interface</code>、<code>class</code> 或特殊语法）实现。</p>\n<h3>一、<code>type</code> 能覆盖的主要类型场景</h3>\n<p><code>type</code> 支持声明非常广泛的类型，包括但不限于：</p>\n<ol>\n<li>\n<p><strong>基础类型与复杂结构</strong><br>\n原始类型、对象、数组、函数、联合类型、交叉类型等：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Str</span> = <span class="hljs-built_in">string</span>;\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> };\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">NumOrStr</span> = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Func</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">string</span>;\n</code></pre>\n</li>\n<li>\n<p><strong>高级类型</strong><br>\n泛型、条件类型、映射类型、索引类型等：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Container</span>&lt;T&gt; = { <span class="hljs-attr">value</span>: T };\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">IsNumber</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">ReadonlyObj</span>&lt;T&gt; = { <span class="hljs-keyword">readonly</span> [K <span class="hljs-keyword">in</span> keyof T]: T[K] };\n</code></pre>\n</li>\n<li>\n<p><strong>特殊类型</strong><br>\n<code>never</code>、<code>void</code>、<code>unknown</code> 等，以及与 <code>typeof</code>、<code>keyof</code> 等操作符结合的类型：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ErrorType</span> = <span class="hljs-built_in">never</span>;\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">ObjKeys</span>&lt;T&gt; = keyof T; <span class="hljs-comment">// 获取对象键名的联合类型</span>\n</code></pre>\n</li>\n</ol>\n<h3>二、<code>type</code> 无法覆盖的场景</h3>\n<ol>\n<li>\n<p><strong>声明可被 <code>implements</code> 继承的类接口</strong><br>\n类实现接口时，只能使用 <code>interface</code>，不能用 <code>type</code>：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> {\n  <span class="hljs-title function_">area</span>(): <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> {\n  <span class="hljs-comment">// 正确：interface 可被 implements</span>\n  <span class="hljs-title function_">area</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>;\n  }\n}\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">ShapeType</span> = { <span class="hljs-title function_">area</span>(): <span class="hljs-built_in">number</span> };\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ShapeType</span> {\n  <span class="hljs-comment">// 错误：type 不能被类 implements</span>\n  <span class="hljs-title function_">area</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;\n  }\n}\n</code></pre>\n</li>\n<li>\n<p><strong>声明可合并的类型（声明合并）</strong><br>\n<code>interface</code> 支持多次声明并自动合并，而 <code>type</code> 不支持：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n}\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n} <span class="hljs-comment">// 合并为 { name: string; age: number }</span>\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">UserType</span> = { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> };\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">UserType</span> = { <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> }; <span class="hljs-comment">// 错误：重复声明类型别名</span>\n</code></pre>\n</li>\n<li>\n<p><strong>声明内置全局类型扩展（部分场景）</strong><br>\n扩展全局类型（如 <code>Window</code>、<code>Array</code>）时，<code>interface</code> 更自然，<code>type</code> 通常无法实现：</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// 正确：扩展全局 Array 接口</span>\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Array</span>&lt;T&gt; {\n  <span class="hljs-title function_">myMethod</span>(): T[];\n}\n\n<span class="hljs-comment">// 错误：type 无法扩展全局类型</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Array</span>&lt;T&gt; = {\n  <span class="hljs-title function_">myMethod</span>(): T[];\n};\n</code></pre>\n</li>\n</ol>\n<h3>三、总结</h3>\n<p><code>type</code> 是 TypeScript 中极其灵活的类型声明方式，能应对绝大多数场景（尤其是复杂类型组合、泛型、条件类型等），但并非“万能”。在需要<strong>类实现接口</strong>   、<strong>类型声明合并</strong>   或<strong>扩展全局类型</strong>   等场景下，仍需依赖 <code>interface</code>。</p>\n<p>因此，<code>type</code> 不能声明所有类型，需与 <code>interface</code> 等配合使用以覆盖全部需求。</p>\n</div>'</script></body></html>