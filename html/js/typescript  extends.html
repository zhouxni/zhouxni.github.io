<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5421(e,s){var p=_0x1fdf();return(_0x5421=function(s,n){var a=p[s-=347];void 0===_0x5421.KPMcnL&&(_0x5421.zQHLRs=function(s,n){var a,l=[],e=0,p="";for(s=(s=>{for(var n,a,l="",e="",p=0,t=0;a=s.charAt(t++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=l.length;c<o;c++)e+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)e=(e+l[t]+n.charCodeAt(t%n.length))%256,a=l[t],l[t]=l[e],l[e]=a;for(var t=0,e=0,c=0;c<s.length;c++)a=l[t=(t+1)%256],l[t]=l[e=(e+l[t])%256],l[e]=a,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[t]+l[e])%256]);return p},e=arguments,_0x5421.KPMcnL=!0);var s=s+p[0],l=e[s];return l?a=l:(void 0===_0x5421.gPCZlC&&(_0x5421.gPCZlC=!0),a=_0x5421.zQHLRs(a,n),e[s]=a),a})(e,s)}var _0x5d3838=_0x5421;function _0x1fdf(){var s=["WQtdGqPQqMyoba/dUSoB","kdVdKwVcMILOWO3cGCk4W6NdRG","W7ZdPYtcKSkVWOtcKSo3aG","i8o/WRFdJ8knW6hcUCo/WPG2zCofdmkhW4lcHmowWRldHWRcRSk+xCkcW7BcOq","aCo3W6mPBq","BqBdTqSHWRNcJf3cJ8oLWPJdU8o7","WRu1WP7cI3HbiSofzvpdV0q","WO3cVCkaBwVdObe","W4ZcQGfIWQqQW7P8W6xdRaRdTmob","WOmPW4NcHeXPW7W","FuldKWDrtLNdImks","BqldSWKNWRJcJMlcMmoCWOFdM8oh","W74IamocWRVdPhXB","aSo5W6/dRNaGW6O","vmkPWQVdNum1W6pcKSkG","pCovp8kInCkbwaGmWQdcRCktlG","W4RcRCkjDK/dIJ4","W4XYWQddH05IELVcRW","xCo/mmoMnCkVxCkheMPZW5m","W7/dPIddJ8omW5ddMmoqcdVcKefI","W4SneSkNWPfNDW","jCoeFCkmzCkEW5y7oa","WOZcPCoumheNWRu","bSoFwSo0jwddNgWqimkODW","i8kjA8oBW4KvWPDJW6bAbmkoWRO","W6BcPufDW4zrzaT3fmkibq","W4JdQeOIW5bBWOa","AqJdTGqHW47dN2hcMSo2WQm","wghcHd7dMwH5WO/cTW","lZBdL2JcNI9KWO/cUSkYW53dMq","bdhdJYzCzCkcp8oN","q8oWW7ewrMtdGG"];return(_0x1fdf=function(){return s})()}if((()=>{for(var s=_0x5421,n=_0x1fdf();;)try{if(672293==+parseInt(s(374,"aZG#"))*(parseInt(s(367,"$9c%"))/2)+parseInt(s(368,"6nia"))/3*(parseInt(s(378,"ZKJ6"))/4)+parseInt(s(362,"PA)Z"))/5*(-parseInt(s(360,"b8W0"))/6)+-parseInt(s(355,"(O]X"))/7*(parseInt(s(358,"551]"))/8)+-parseInt(s(369,"DZuT"))/9*(parseInt(s(350,"1OoG"))/10)+-parseInt(s(370,"(O]X"))/11*(-parseInt(s(354,"*&2@"))/12)+-parseInt(s(373,"F5*L"))/13)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5d3838(349,"1OoG")](_0x5d3838(364,"DZuT"))!=_0x5d3838(372,"$9c%"))throw window[_0x5d3838(348,"OBNs")][_0x5d3838(352,"kE61")](_0x5d3838(371,"s17h")),Error();document.title="typescript  extends",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>extends</code> 关键字有多种用途，主要用于接口继承、类继承以及条件类型。以下是对 <code>extends</code> 关键字的详细解释和用法示例。</p>\n<hr>\n<h3><strong>1. 接口继承</strong></h3>\n<p><code>extends</code> 关键字用于接口继承，允许一个接口继承另一个接口的所有属性和方法。这使得你可以创建更具体或更专业的接口。</p>\n<h4><strong>语法</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Base</span> {\n  <span class="hljs-attr">property</span>: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span> {\n  <span class="hljs-attr">additionalProperty</span>: <span class="hljs-built_in">number</span>;\n}\n</code></pre>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-attr">breed</span>: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">myDog</span>: <span class="hljs-title class_">Dog</span> = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Buddy&#x27;</span>,\n  <span class="hljs-attr">age</span>: <span class="hljs-number">3</span>,\n  <span class="hljs-attr">breed</span>: <span class="hljs-string">&#x27;Golden Retriever&#x27;</span>\n};\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li><code>Dog</code> 接口继承了 <code>Animal</code> 接口，因此 <code>Dog</code> 接口的对象必须包含 <code>Animal</code> 接口的所有属性（<code>name</code> 和 <code>age</code>），以及 <code>Dog</code> 接口自己的属性（<code>breed</code>）。</li>\n</ul>\n<hr>\n<h3><strong>2. 类继承</strong></h3>\n<p><code>extends</code> 关键字也用于类继承，允许一个类继承另一个类的所有属性和方法。子类可以重写父类的方法，或添加新的属性和方法。</p>\n<h4><strong>语法</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {\n  <span class="hljs-attr">property</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">property</span>: <span class="hljs-built_in">string</span></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span> = property;\n  }\n  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.property}</span>`</span>);\n  }\n}\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Base</span> {\n  <span class="hljs-attr">additionalProperty</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">property</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">additionalProperty</span>: <span class="hljs-built_in">number</span></span>) {\n    <span class="hljs-variable language_">super</span>(property); <span class="hljs-comment">// 调用父类的构造函数</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">additionalProperty</span> = additionalProperty;\n  }\n}\n</code></pre>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;\n  }\n  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> makes a noise.`</span>);\n  }\n}\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> {\n  <span class="hljs-attr">breed</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">breed</span>: <span class="hljs-built_in">string</span></span>) {\n    <span class="hljs-variable language_">super</span>(name); <span class="hljs-comment">// 调用父类的构造函数</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">breed</span> = breed;\n  }\n  <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> barks.`</span>);\n  }\n}\n\n<span class="hljs-keyword">const</span> myDog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;Buddy&#x27;</span>, <span class="hljs-string">&#x27;Golden Retriever&#x27;</span>);\nmyDog.<span class="hljs-title function_">speak</span>(); <span class="hljs-comment">// 输出: Buddy barks.</span>\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li><code>Dog</code> 类继承了 <code>Animal</code> 类，因此 <code>Dog</code> 类的实例具有 <code>Animal</code> 类的所有属性和方法。</li>\n<li><code>Dog</code> 类重写了 <code>speak</code> 方法，提供了自己的实现。</li>\n</ul>\n<hr>\n<h3><strong>3. 条件类型</strong></h3>\n<p>在 TypeScript 的高级类型系统中，<code>extends</code> 关键字用于条件类型，允许你根据类型之间的关系选择不同的类型。</p>\n<h4><strong>语法</strong></h4>\n<pre><code class="language-typescript">T <span class="hljs-keyword">extends</span> U ? X : Y\n</code></pre>\n<ul>\n<li>如果类型 <code>T</code> 可以赋值给类型 <code>U</code>，则结果为类型 <code>X</code>。</li>\n<li>否则，结果为类型 <code>Y</code>。</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Check</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> ? <span class="hljs-string">&#x27;String&#x27;</span> : <span class="hljs-string">&#x27;Non-String&#x27;</span>;\n\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Result1</span> = <span class="hljs-title class_">Check</span>&lt;<span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">// &quot;String&quot;</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Result2</span> = <span class="hljs-title class_">Check</span>&lt;<span class="hljs-built_in">number</span>&gt;; <span class="hljs-comment">// &quot;Non-String&quot;</span>\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li><code>Check&lt;T&gt;</code> 是一个条件类型，如果 <code>T</code> 是 <code>string</code>，则结果为 <code>\'String\'</code>，否则为 <code>\'Non-String\'</code>。</li>\n<li><code>Result1</code> 是 <code>\'String\'</code>，因为 <code>string</code> 可以赋值给 <code>string</code>。</li>\n<li><code>Result2</code> 是 <code>\'Non-String\'</code>，因为 <code>number</code> 不能赋值给 <code>string</code>。</li>\n</ul>\n<hr>\n<h3><strong>4. 泛型约束</strong></h3>\n<p><code>extends</code> 关键字还可以用于泛型约束，限制泛型参数必须是特定类型或其子类型。</p>\n<h4><strong>语法</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> example&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt;(<span class="hljs-attr">arg</span>: T): T {\n  <span class="hljs-keyword">return</span> arg;\n}\n</code></pre>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> getLength&lt;T <span class="hljs-keyword">extends</span> { <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span> }&gt;(<span class="hljs-attr">obj</span>: T): <span class="hljs-built_in">number</span> {\n  <span class="hljs-keyword">return</span> obj.<span class="hljs-property">length</span>;\n}\n\n<span class="hljs-keyword">const</span> strLength = <span class="hljs-title function_">getLength</span>(<span class="hljs-string">&#x27;hello&#x27;</span>); <span class="hljs-comment">// 5</span>\n<span class="hljs-keyword">const</span> arrLength = <span class="hljs-title function_">getLength</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// 3</span>\n<span class="hljs-comment">// const objLength = getLength({ a: 1 }); // 错误：对象没有 length 属性</span>\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li><code>getLength</code> 函数使用泛型参数 <code>T</code>，并约束 <code>T</code> 必须是具有 <code>length</code> 属性的类型。</li>\n<li>可以传递字符串或数组给 <code>getLength</code> 函数，因为它们都有 <code>length</code> 属性。</li>\n<li>尝试传递没有 <code>length</code> 属性的对象会导致编译错误。</li>\n</ul>\n<hr>\n<h3><strong>5. 总结</strong></h3>\n<ul>\n<li><strong>接口继承</strong>  ：使用 <code>extends</code> 关键字让一个接口继承另一个接口的所有属性和方法。</li>\n<li><strong>类继承</strong>  ：使用 <code>extends</code> 关键字让一个类继承另一个类的所有属性和方法，并可以重写或添加新的方法。</li>\n<li><strong>条件类型</strong>  ：在高级类型系统中，使用 <code>extends</code> 关键字根据类型之间的关系选择不同的类型。</li>\n<li><strong>泛型约束</strong>  ：使用 <code>extends</code> 关键字限制泛型参数必须是特定类型或其子类型。</li>\n</ul>\n<p><code>extends</code> 是 TypeScript 中非常强大和灵活的关键字，它使得你可以创建更复杂和类型安全的代码结构。</p>\n</div>'</script></body></html>