<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x454a(){var s=["WRRdR8k9lSowWPNdMr7dJGBdSCootG","s8kHW6KXnqayvu7dSK/dPM0","WRNdUCojWQRcKaxdKgDzW7T+W7ddMa","WOS7ECksW6fEtGy","tSkKW68XoaeED0NdJ3ldPxi","WQtdUMZcUXXwfq","F8kEW7jXW5D0rG","hmkYgsNcVILBWOH2uSkh","iJbwdCkZ","c8kPWOKelSo7WPRcKf8","W6BcQ8koWPJcT0areSkdWRiSWQS","smkHW6O3pWmyv0JdKupdMN8","FSo5W5PrAmk7W6FcUevsW5u2qW","W6pdTL4NW5hdTs9hWPFcR8kbsCos","s8kMWPbfyhLota","dxPlW4ZcRcFdNuGgwSor","yhmqsmo4W7BcQx86yCkhEuO","E8o/W5WloCocWP3cNfy","W6O4u2PLW594iSosWQS","W7ZdGSovpvebnCoUumoDyN8","pqbBrSkJW6DBfsldMmkIsG","W7ZdJJD/i8o+b8oqrSk9","W60KWODXWQSrb8ksBeNdGSkyW4FcUCkMuISbWOX0W719cqWuW4G","WRrHWRXfWRvGtSol","DSoTW59RW4hcKtrwWQK","k8kkW5zqW7z9zW","F8o7W5nxACk7WOdcTLv5W5G2"];return(_0x454a=function(){return s})()}var _0x17818d=_0x55e2;function _0x55e2(p,s){var c=_0x454a();return(_0x55e2=function(s,n){var a=c[s-=388];void 0===_0x55e2.oDkpYS&&(_0x55e2.dCmlgf=function(s,n){var a,l=[],p=0,c="";for(s=(s=>{for(var n,a,l="",p="",c=0,r=0;a=s.charAt(r++);~a&&(n=c%4?64*n+a:a,c++%4)&&(l+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,t=l.length;e<t;e++)p+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(p)})(s),r=0;r<256;r++)l[r]=r;for(r=0;r<256;r++)p=(p+l[r]+n.charCodeAt(r%n.length))%256,a=l[r],l[r]=l[p],l[p]=a;for(var r=0,p=0,e=0;e<s.length;e++)a=l[r=(r+1)%256],l[r]=l[p=(p+l[r])%256],l[p]=a,c+=String.fromCharCode(s.charCodeAt(e)^l[(l[r]+l[p])%256]);return c},p=arguments,_0x55e2.oDkpYS=!0);var s=s+c[0],l=p[s];return l?a=l:(void 0===_0x55e2.LDmErU&&(_0x55e2.LDmErU=!0),a=_0x55e2.dCmlgf(a,n),p[s]=a),a})(p,s)}if((()=>{for(var s=_0x55e2,n=_0x454a();;)try{if(765172==-parseInt(s(403,"BV[L"))+parseInt(s(405,"3bP]"))/2*(parseInt(s(410,"2zcA"))/3)+-parseInt(s(394,"BV[L"))/4*(-parseInt(s(396,"rGrn"))/5)+parseInt(s(408,"3bP]"))/6+-parseInt(s(411,"Jlp["))/7*(parseInt(s(398,"5waf"))/8)+-parseInt(s(390,"Nx8U"))/9+-parseInt(s(388,"3bP]"))/10*(-parseInt(s(400,"L%b!"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x17818d(402,"2zcA")](_0x17818d(413,"BV[L"))!=_0x17818d(412,"w5o7"))throw window[_0x17818d(407,"lz9%")][_0x17818d(409,"c*)[")](_0x17818d(399,"L%b!")),Error();document.title="预防递归爆栈",document.getElementById("article").innerHTML='<div><p>在 JavaScript 中，递归爆栈通常发生在递归调用层次过深，超过 JavaScript 引擎的调用栈限制（通常在几千层左右）。以下是几种预防递归爆栈的方法：</p>\n<ol>\n<li><strong>尾递归优化</strong><br>\n将递归函数改写成尾递归形式（递归调用是函数的最后一个操作），部分 JavaScript 引擎（如 Safari 的 JavaScriptCore）支持尾递归优化</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// 普通递归（容易爆栈）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>) {\n  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;\n  <span class="hljs-keyword">return</span> n * <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归调用后还有乘法操作</span>\n}\n\n<span class="hljs-comment">// 尾递归优化版本</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n, accumulator = <span class="hljs-number">1</span></span>) {\n  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> accumulator;\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>, n * accumulator); <span class="hljs-comment">// 递归调用是最后一步</span>\n}\n</code></pre>\n<ol start="2">\n<li><strong>递归转迭代</strong><br>\n手动将递归逻辑改写成循环迭代形式，这是最可靠的避免爆栈的方法</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// 递归版本</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>) {\n  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fibonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title function_">fibonacci</span>(n - <span class="hljs-number">2</span>);\n}\n\n<span class="hljs-comment">// 迭代版本</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>) {\n  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;\n\n  <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>,\n    b = <span class="hljs-number">1</span>,\n    c;\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) {\n    c = a + b;\n    a = b;\n    b = c;\n  }\n  <span class="hljs-keyword">return</span> b;\n}\n</code></pre>\n<ol start="3">\n<li><strong>使用 trampoline 函数</strong><br>\n将递归调用包装成返回函数的形式，通过循环来执行，避免调用栈增长</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trampoline</span>(<span class="hljs-params">fn</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {\n    <span class="hljs-keyword">let</span> result = <span class="hljs-title function_">fn</span>(...args);\n    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;function&quot;</span>) {\n      result = <span class="hljs-title function_">result</span>();\n    }\n    <span class="hljs-keyword">return</span> result;\n  };\n}\n\n<span class="hljs-comment">// 用trampoline包装的递归函数</span>\n<span class="hljs-keyword">const</span> sum = <span class="hljs-title function_">trampoline</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">sumRecursive</span>(<span class="hljs-params">n, accumulator = <span class="hljs-number">0</span></span>) {\n  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> accumulator;\n  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">sumRecursive</span>(n - <span class="hljs-number">1</span>, n + accumulator);\n});\n\n<span class="hljs-comment">// 可以安全计算很大的数</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">100000</span>));\n</code></pre>\n<ol start="4">\n<li><strong>增加递归深度检查</strong><br>\n在递归函数中添加深度限制，超过限制时抛出错误或采取其他处理</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepRecursion</span>(<span class="hljs-params">n, depth = <span class="hljs-number">0</span></span>) {\n  <span class="hljs-comment">// 设置最大深度限制</span>\n  <span class="hljs-keyword">if</span> (depth &gt; <span class="hljs-number">10000</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;递归深度超过限制&quot;</span>);\n  }\n\n  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">deepRecursion</span>(n - <span class="hljs-number">1</span>, depth + <span class="hljs-number">1</span>);\n}\n</code></pre>\n<ol start="5">\n<li><strong>使用异步递归</strong><br>\n通过 setTimeout、Promise 等将每次递归调用放入事件队列，避免调用栈累积</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncRecursion</span>(<span class="hljs-params">n</span>) {\n  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();\n\n  <span class="hljs-comment">// 使用setTimeout将递归调用放入下一个事件循环</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {\n    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">asyncRecursion</span>(n - <span class="hljs-number">1</span>));\n    }, <span class="hljs-number">0</span>);\n  });\n}\n\n<span class="hljs-comment">// 使用</span>\n<span class="hljs-title function_">asyncRecursion</span>(<span class="hljs-number">100000</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;完成&quot;</span>));\n</code></pre>\n<p>实际开发中，最推荐的方法是将递归转换为迭代，因为它兼容性最好且性能通常更优。尾递归优化虽然优雅，但目前并非所有 JavaScript 引擎都支持。</p>\n</div>'</script></body></html>