<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1b7766=_0x5ed2;function _0x106d(){var s=["WPFcO3hdTvTjW7lcGbH8WRa4j8ok","W5tdN8k4WRFcOmoSxLtdKCkLW70cW7yU","qSkYW6FdNYVdP14","qCkiheBdPXilhYHEW4VdSW","n8oAtHpcOfKopbi","mhHkWOBdIu/dOSoc","WRb4W68ZW6u","qSkoh0BdOvapldPhW4O","W5nMWPJcOSofaCoz","tJ7cMCo+W4xdL8owW6auWQnj","WQP/WONcOM3dM8oJpSkmumkvxmoYW6TBWPFcLXa8uc3dKmoeW4nOW4i","WOfAWPz4W7usWOG","W6v8W53cGCkhW5y1W4JcOGNdMcVcTW","WQeilmoYB8kWWPaZ","WO0pW4faW5DdW5xdOX5AbmoDW7K","W4FdHe8WW65itq4HWOiCBq","btFcVSkHmYtdPSkNW4JcPMOevq","g3RcHCkfm1mn","r8kjscBcLfSrnG","sd/cN8o+W47cMmo+W6WaWOTfWP4","W5hcPSoHWReMbSkuWRiNWPxcMmkIDW","WOldSLlcHSoqybC","wCoAW5dcPLxdR2pcQcpcNsmCcW","AxfRWRdcPWfu","rCkjwYhcVguHka","WQfQWQClW6qvW7pcIHlcQLdcGW","WPZdUehcI8ofAH3dPq","smobWOtcMflcVaZdU2iKWOmlW6G"];return(_0x106d=function(){return s})()}function _0x5ed2(l,s){var c=_0x106d();return(_0x5ed2=function(s,n){var a=c[s-=249];void 0===_0x5ed2.qGBkkq&&(_0x5ed2.eDkpKA=function(s,n){var a,e=[],l=0,c="";for(s=(s=>{for(var n,a,e="",l="",c=0,r=0;a=s.charAt(r++);~a&&(n=c%4?64*n+a:a,c++%4)&&(e+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,p=e.length;t<p;t++)l+="%"+("00"+e.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(l)})(s),r=0;r<256;r++)e[r]=r;for(r=0;r<256;r++)l=(l+e[r]+n.charCodeAt(r%n.length))%256,a=e[r],e[r]=e[l],e[l]=a;for(var r=0,l=0,t=0;t<s.length;t++)a=e[r=(r+1)%256],e[r]=e[l=(l+e[r])%256],e[l]=a,c+=String.fromCharCode(s.charCodeAt(t)^e[(e[r]+e[l])%256]);return c},l=arguments,_0x5ed2.qGBkkq=!0);var s=s+c[0],e=l[s];return e?a=e:(void 0===_0x5ed2.uNSaug&&(_0x5ed2.uNSaug=!0),a=_0x5ed2.eDkpKA(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x5ed2,n=_0x106d();;)try{if(386020==+parseInt(s(275,"CZSp"))+parseInt(s(267,"NcdR"))/2*(-parseInt(s(249,"(31p"))/3)+-parseInt(s(276,"qQT@"))/4+parseInt(s(257,"]8SD"))/5*(-parseInt(s(265,"L*I!"))/6)+-parseInt(s(272,"vP2["))/7+parseInt(s(254,"kGUg"))/8*(parseInt(s(262,"s@ji"))/9)+-parseInt(s(273,"tx]I"))/10*(-parseInt(s(260,"$Zu%"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1b7766(268,"^fn&")](_0x1b7766(264,"NcdR"))!=_0x1b7766(266,"sRz3"))throw window[_0x1b7766(258,"fa%(")][_0x1b7766(253,"fa%(")](_0x1b7766(270,"#0jx")),Error();document.title="Service Worker 缓存",document.getElementById("article").innerHTML='<div><p><strong>Service Worker 缓存详解</strong></p>\n<p>Service Worker 是一种运行在浏览器后台的脚本，它独立于网页文档之外，不能直接操作 DOM，但可以拦截和处理浏览器发出的网络请求。这种特性使得 Service Worker 在缓存管理、离线访问、推送通知等方面具有强大的能力。以下是关于 Service Worker 缓存的详细解析：</p>\n<h3>一、缓存机制</h3>\n<ol>\n<li><strong>缓存位置与优先级</strong>\n<ul>\n<li>Service Worker 的缓存与浏览器其他内建的缓存机制（如 Memory Cache、Disk Cache、Push Cache）不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</li>\n<li>当浏览器尝试获取某个资源时，Service Worker 会按照特定的优先级顺序查找缓存：首先查找 Service Worker 缓存，然后是 Memory Cache、Disk Cache，最后是 Push Cache。如果都没有命中，才会向服务器发送请求。</li>\n</ul>\n</li>\n<li><strong>缓存的创建与管理</strong>\n<ul>\n<li>Service Worker 在安装阶段（<code>install</code> 事件）可以创建缓存并添加需要缓存的资源。这通常通过 <code>caches.open()</code> 和 <code>cache.addAll()</code> 方法实现。</li>\n<li>在激活阶段（<code>activate</code> 事件），Service Worker 可以清理旧缓存，确保新版本的资源被正确加载。</li>\n</ul>\n</li>\n<li><strong>拦截请求与响应</strong>\n<ul>\n<li>Service Worker 通过监听 <code>fetch</code> 事件来拦截客户端发出的网络请求。</li>\n<li>对于已经缓存的资源，Service Worker 可以直接从缓存中返回响应，而无需向服务器发送请求。这大大提高了页面的加载速度，尤其是在离线状态下。</li>\n<li>如果请求的资源未缓存或缓存已过期，Service Worker 可以根据定义的缓存策略从网络获取资源，并更新缓存。</li>\n</ul>\n</li>\n</ol>\n<h3>二、缓存策略</h3>\n<p>Service Worker 支持多种缓存策略，开发者可以根据实际需求选择合适的策略：</p>\n<ol>\n<li><strong>缓存优先（Cache First）</strong>  ：优先从缓存中获取资源，如果缓存不存在则从网络获取并缓存。这种策略适用于不经常变化的资源，如静态文件。</li>\n<li><strong>网络优先（Network First）</strong>  ：优先从网络获取资源，如果网络请求失败则从缓存中获取。这种策略适用于需要频繁更新的资源，如动态内容。</li>\n<li><strong>缓存回退（Stale-While-Revalidate）</strong>  ：立即从缓存中提供资源，同时在后台更新缓存。这种策略结合了缓存优先和网络优先的优点，既保证了响应速度又保证了资源的最新性。</li>\n<li><strong>仅缓存（Cache Only）</strong>  ：只从缓存中获取资源，不从网络请求。这种策略适用于完全离线可用的资源。</li>\n<li><strong>仅网络（Network Only）</strong>  ：只从网络获取资源，不使用缓存。这种策略适用于不需要缓存的资源。</li>\n</ol>\n<h3>三、缓存更新</h3>\n<p>Service Worker 通过以下机制保证离线缓存资源的更新：</p>\n<ol>\n<li><strong>版本管理</strong>  ：通过为缓存命名添加版本号，确保在更新 Service Worker 时清理旧缓存，缓存新资源。这通常通过在安装阶段创建新的缓存并删除旧缓存实现。</li>\n<li><strong>生命周期管理</strong>  ：Service Worker 的生命周期包括安装、激活和事件监听等阶段。在每个阶段都可以执行相应的缓存操作，如添加、更新和清理缓存。</li>\n<li><strong>后台同步</strong>  ：Service Worker 支持后台同步功能，可以在网络连接可用时同步数据，确保缓存资源的最新性。这通常用于处理需要在线更新的资源。</li>\n</ol>\n<h3>四、示例代码</h3>\n<p>以下是一个简单的 Service Worker 缓存示例，展示了如何注册 Service Worker、创建缓存、拦截请求并返回缓存响应：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 注册 Service Worker</span>\n<span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;serviceWorker&#x27;</span> <span class="hljs-keyword">in</span> navigator) {\n  navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;/service-worker.js&#x27;</span>)\n    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">registration</span> =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Service Worker 注册成功:&#x27;</span>, registration);\n    })\n    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Service Worker 注册失败:&#x27;</span>, error);\n    });\n}\n\n<span class="hljs-comment">// service-worker.js</span>\n<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_NAME</span> = <span class="hljs-string">&#x27;my-app-cache-v1&#x27;</span>;\n<span class="hljs-keyword">const</span> urlsToCache = [\n  <span class="hljs-string">&#x27;/&#x27;</span>,\n  <span class="hljs-string">&#x27;/index.html&#x27;</span>,\n  <span class="hljs-string">&#x27;/styles/main.css&#x27;</span>,\n  <span class="hljs-string">&#x27;/script/main.js&#x27;</span>\n];\n\nself.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">waitUntil</span>(\n    caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>)\n      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;[Service Worker] Caching all: app shell and content&#x27;</span>);\n        <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">addAll</span>(urlsToCache);\n      })\n  );\n});\n\nself.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  event.<span class="hljs-title function_">respondWith</span>(\n    caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>)\n      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {\n        <span class="hljs-keyword">if</span> (response) {\n          <span class="hljs-keyword">return</span> response; <span class="hljs-comment">// 从缓存中返回响应</span>\n        }\n        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>); <span class="hljs-comment">// 从网络获取资源</span>\n      })\n  );\n});\n\nself.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {\n  <span class="hljs-keyword">const</span> cacheWhitelist = [<span class="hljs-variable constant_">CACHE_NAME</span>];\n  event.<span class="hljs-title function_">waitUntil</span>(\n    caches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">cacheNames</span> =&gt;</span> {\n      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(\n        cacheNames.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">cacheName</span> =&gt;</span> {\n          <span class="hljs-keyword">if</span> (cacheWhitelist.<span class="hljs-title function_">indexOf</span>(cacheName) === -<span class="hljs-number">1</span>) {\n            <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">delete</span>(cacheName); <span class="hljs-comment">// 删除旧缓存</span>\n          }\n        })\n      );\n    })\n  );\n});\n</code></pre>\n<h3>五、注意事项</h3>\n<ol>\n<li><strong>安全性</strong>  ：出于安全考虑，Service Worker 要求网站必须通过 HTTPS 协议进行部署。这确保了缓存资源在传输过程中的安全性，防止中间人攻击和数据篡改。</li>\n<li><strong>浏览器兼容性</strong>  ：一些老版本的浏览器可能不支持 Service Worker，因此在使用前需要进行兼容性判断，并提供替代方案。</li>\n<li><strong>缓存策略选择</strong>  ：需要根据具体需求选择合适的缓存策略，以平衡资源更新速度和用户体验。例如，对于需要频繁更新的资源，可以选择网络优先策略；对于不经常变化的资源，可以选择缓存优先策略。</li>\n<li><strong>缓存大小限制</strong>  ：不同浏览器对缓存大小有不同的限制，开发者需要合理配置缓存大小，避免无限制地缓存导致用户设备空间被过度占用。</li>\n</ol>\n</div>'</script></body></html>