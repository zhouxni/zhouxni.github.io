<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0xc15ad4=_0x70bf;function _0x70bf(t,s){var p=_0x2853();return(_0x70bf=function(s,n){var a=p[s-=259];void 0===_0x70bf.KlbWBv&&(_0x70bf.OsaEMO=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,c=0;a=s.charAt(c++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,e=l.length;o<e;o++)t+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(t)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)t=(t+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[t],l[t]=a;for(var c=0,t=0,o=0;o<s.length;o++)a=l[c=(c+1)%256],l[c]=l[t=(t+l[c])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(o)^l[(l[c]+l[t])%256]);return p},t=arguments,_0x70bf.KlbWBv=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x70bf.BRXdGv&&(_0x70bf.BRXdGv=!0),a=_0x70bf.OsaEMO(a,n),t[s]=a),a})(t,s)}function _0x2853(){var s=["tCoOamk1W7jBW7hcHKVcGCoNWQ7cRq","W5LOnsOaENaFtmkAWRTApa","WQ0JiCk7sX3dKq","xK8QpxdcKwldU8klW4eGoq","iSkMzCkIca/dR8ko","vuTuEGhdV2RdRq","W5DAiKNdNvyvWObaWORdTrpcGZ8","W7LAW5/cJmoqEYO","BvxcTmk3WQv3rCohkmkFW5OjmW","rWTEWO7cUSozWO8VECktBe3dHa","ySkCWRPCWQaTwgnQWQuq","tCoKW48+WPVdLSobWOPmwehdH8oz","ASkuW6WjWRdcLSo6F8k9WRddSHBcGW","WRrGWRtcPSkiW78pWPZcUCo3eMddNmk/","gCkIW5pdJ8ksvb7cP8kyWPq9W7bP","W63cLW3cI07dRgddSCkxW6xdRMpdPq","W7ZdI3ejWRXUkvldGCoyWRhdTq","WQ5iWP/dTbpcVCkS","w8oUWPxcISoE","W6DVWRVdGSkkhXS","WPFcQKpcHLP+W4tdJb0","ACkzW68jWR3dQmkSxSkzWQhdVG","W65EWONcPGz4WRzR","WO4ABG7cMvGdWPP3WO7dJatcSJuUo0BdUqNcQNNdJ0ehtmks"];return(_0x2853=function(){return s})()}if((()=>{for(var s=_0x70bf,n=_0x2853();;)try{if(880622==-parseInt(s(261,"&g6Q"))*(parseInt(s(269,"&fcL"))/2)+-parseInt(s(268,"l[aY"))/3+-parseInt(s(278,"]3&J"))/4+parseInt(s(282,"a7@1"))/5+parseInt(s(277,"b0LM"))/6+parseInt(s(266,"Mv$G"))/7*(parseInt(s(260,"da4L"))/8)+parseInt(s(281,"b&aN"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0xc15ad4(270,"hT3i")](_0xc15ad4(264,"5MW0"))!=_0xc15ad4(262,"a7@1"))throw window[_0xc15ad4(272,"^AaC")][_0xc15ad4(275,"xjw1")](_0xc15ad4(267,"Q^nb")),Error();document.title="React 数据状态管理库",document.getElementById("article").innerHTML='<div><p>在 React 生态中，数据状态管理库非常丰富，不同库适用于不同场景（从简单的组件内状态到复杂的全局状态管理）。以下是目前主流的 React 数据状态管理库及其特点：</p>\n<h3>1. <strong>Redux 生态（最成熟的全局状态方案）</strong></h3>\n<ul>\n<li>\n<p><strong>核心库</strong>   ：<code>redux</code> + <code>react-redux</code><br>\nRedux 是最经典的状态管理方案，基于 Flux 架构，采用单一状态树、不可变数据和纯函数 reducer。</p>\n<ul>\n<li>优点：生态完善、调试工具强大（Redux DevTools）、适合大型应用和团队协作</li>\n<li>缺点：模板代码较多，学习曲线较陡</li>\n</ul>\n</li>\n<li>\n<p><strong>增强工具</strong>   ：</p>\n<ul>\n<li><code>@reduxjs/toolkit</code>：官方推荐的 Redux 工具集，简化了 Redux 样板代码（内置 <code>createSlice</code>、<code>configureStore</code> 等），现在是使用 Redux 的首选方式。</li>\n<li><code>redux-thunk</code>/<code>redux-saga</code>：处理异步逻辑（Thunk 简单直观，Saga 适合复杂异步流控制）。</li>\n</ul>\n</li>\n</ul>\n<h3>2. <strong>MobX</strong></h3>\n<p>基于观察者模式的响应式状态管理库，通过 <code>observable</code> 定义状态，<code>action</code> 修改状态，组件自动追踪依赖并更新。</p>\n<ul>\n<li>\n<p>优点：代码简洁、学习成本低、响应式自动更新，适合中小型应用</p>\n</li>\n<li>\n<p>缺点：灵活性高可能导致代码规范难以统一，大型应用需谨慎设计</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { makeAutoObservable } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;\n<span class="hljs-keyword">import</span> { observer } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span>;\n\n<span class="hljs-comment">// 定义 store</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterStore</span> {\n  count = <span class="hljs-number">0</span>;\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 自动实现响应式</span>\n  }\n  increment = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;\n}\n\n<span class="hljs-comment">// 使用组件（被 observer 包裹）</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">Counter</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">{ store }</span>) =&gt;</span> (\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{store.increment}</span>&gt;</span>{store.count}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>\n));\n</code></pre>\n</li>\n</ul>\n<h3>3. <strong>Zustand</strong></h3>\n<p>轻量级状态管理库，API 简洁，无需 Provider 包裹，直接通过钩子访问状态。</p>\n<ul>\n<li>\n<p>优点：极简 API、无样板代码、支持中间件（如 Redux DevTools）、适合中小型应用</p>\n</li>\n<li>\n<p>缺点：状态逻辑复杂时可能需要手动拆分 store</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> create <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;zustand&quot;</span>;\n\n<span class="hljs-comment">// 创建 store</span>\n<span class="hljs-keyword">const</span> useCounterStore = <span class="hljs-title function_">create</span>(<span class="hljs-function">(<span class="hljs-params">set</span>) =&gt;</span> ({\n  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,\n  <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">set</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> })),\n}));\n\n<span class="hljs-comment">// 组件中使用</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> { count, increment } = <span class="hljs-title function_">useCounterStore</span>();\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{increment}</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ul>\n<h3>4. <strong>Recoil</strong></h3>\n<p>Facebook 推出的专为 React 设计的状态管理库，支持派生状态（Derived State）和异步状态，适合需要细粒度控制状态依赖的场景。</p>\n<ul>\n<li>\n<p>优点：与 React 范式高度契合、支持状态分片（Atom）、自动处理异步状态</p>\n</li>\n<li>\n<p>缺点：生态相对较新，大型项目实践案例较少</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { atom, useRecoilState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;recoil&quot;</span>;\n\n<span class="hljs-comment">// 定义原子状态</span>\n<span class="hljs-keyword">const</span> countState = <span class="hljs-title function_">atom</span>({\n  <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;countState&quot;</span>,\n  <span class="hljs-attr">default</span>: <span class="hljs-number">0</span>,\n});\n\n<span class="hljs-comment">// 组件中使用</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useRecoilState</span>(countState);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;{count}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ul>\n<h3>5. <strong>Jotai</strong></h3>\n<p>受 Recoil 启发的轻量级状态库，核心是“原子化状态”（Atom），支持状态组合和派生，API 更简洁。</p>\n<ul>\n<li>\n<p>优点：体积小（约 2KB）、无 Provider、适合中小型应用</p>\n</li>\n<li>\n<p>特点：状态可按原子拆分，避免不必要的重渲染</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { atom, useAtom } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jotai&quot;</span>;\n\n<span class="hljs-keyword">const</span> countAtom = <span class="hljs-title function_">atom</span>(<span class="hljs-number">0</span>);\n<span class="hljs-keyword">const</span> doubleCountAtom = <span class="hljs-title function_">atom</span>(<span class="hljs-function">(<span class="hljs-params">get</span>) =&gt;</span> <span class="hljs-title function_">get</span>(countAtom) * <span class="hljs-number">2</span>); <span class="hljs-comment">// 派生状态</span>\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useAtom</span>(countAtom);\n  <span class="hljs-keyword">const</span> [doubleCount] = <span class="hljs-title function_">useAtom</span>(doubleCountAtom);\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount((c) =&gt; c + 1)}&gt;{count}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Double: {doubleCount}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n</li>\n</ul>\n<h3>6. <strong>XState</strong></h3>\n<p>基于有限状态机（FSM）和状态图的状态管理库，适合处理复杂的状态逻辑（如表单流程、交互状态）。</p>\n<ul>\n<li>\n<p>优点：严格的状态流转控制、可视化状态图（便于调试）、适合复杂业务逻辑</p>\n</li>\n<li>\n<p>缺点：学习成本较高，简单场景可能过于繁琐</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { createMachine, assign } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@xstate/fsm&quot;</span>;\n<span class="hljs-keyword">import</span> { useMachine } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@xstate/react&quot;</span>;\n\n<span class="hljs-comment">// 定义状态机</span>\n<span class="hljs-keyword">const</span> counterMachine = <span class="hljs-title function_">createMachine</span>({\n  <span class="hljs-attr">initial</span>: <span class="hljs-string">&quot;active&quot;</span>,\n  <span class="hljs-attr">context</span>: { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> },\n  <span class="hljs-attr">states</span>: {\n    <span class="hljs-attr">active</span>: {\n      <span class="hljs-attr">on</span>: {\n        <span class="hljs-attr">INCREMENT</span>: {\n          <span class="hljs-attr">actions</span>: <span class="hljs-title function_">assign</span>({ <span class="hljs-attr">count</span>: <span class="hljs-function">(<span class="hljs-params">ctx</span>) =&gt;</span> ctx.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> }),\n        },\n      },\n    },\n  },\n});\n\n<span class="hljs-comment">// 组件中使用</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [state, send] = <span class="hljs-title function_">useMachine</span>(counterMachine);\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> send(&quot;INCREMENT&quot;)}&gt;{state.context.count}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>\n  );\n}\n</code></pre>\n</li>\n</ul>\n<h3>7. <strong>Valtio</strong></h3>\n<p>基于 Proxy 的响应式状态库，API 简单，支持直接修改状态（无需 action）。</p>\n<ul>\n<li>\n<p>优点：使用直观（类似 Vue 的响应式）、自动追踪依赖、适合快速开发</p>\n</li>\n<li>\n<p>缺点：Proxy 兼容性限制（不支持 IE）</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { proxy, useSnapshot } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;valtio&quot;</span>;\n\n<span class="hljs-comment">// 创建响应式状态</span>\n<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">proxy</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> });\n\n<span class="hljs-comment">// 组件中使用</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> snap = <span class="hljs-title function_">useSnapshot</span>(state); <span class="hljs-comment">// 自动追踪用到的状态</span>\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> state.count++}&gt;{snap.count}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ul>\n<h3>选择建议：</h3>\n<ul>\n<li><strong>简单场景</strong>   ：React 内置的 <code>useState</code> + <code>useContext</code> 足够，无需额外库。</li>\n<li><strong>中小型应用</strong>   ：优先选 <code>Zustand</code>、<code>Jotai</code> 或 <code>Valtio</code>（API 简洁，学习成本低）。</li>\n<li><strong>大型复杂应用</strong>   ：<code>Redux Toolkit</code>（生态完善）或 <code>MobX</code>（灵活响应式）。</li>\n<li><strong>复杂状态逻辑</strong>   ：<code>XState</code>（状态流转可控）。</li>\n<li><strong>React 深度集成</strong>   ：<code>Recoil</code>（适合需要细粒度状态依赖的场景）。</li>\n</ul>\n<p>实际项目中，需根据团队熟悉度、项目复杂度和性能需求综合选择。</p>\n</div>'</script></body></html>