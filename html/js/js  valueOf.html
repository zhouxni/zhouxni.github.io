<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x46e28b=_0x280a;function _0x280a(e,s){var c=_0x5ca1();return(_0x280a=function(s,a){var n=c[s-=151];void 0===_0x280a.nZikPp&&(_0x280a.jpHUJl=function(s,a){var n,l=[],e=0,c="";for(s=(s=>{for(var a,n,l="",e="",c=0,o=0;n=s.charAt(o++);~n&&(a=c%4?64*a+n:n,c++%4)&&(l+=String.fromCharCode(255&a>>(-2*c&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var p=0,t=l.length;p<t;p++)e+="%"+("00"+l.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(s),o=0;o<256;o++)l[o]=o;for(o=0;o<256;o++)e=(e+l[o]+a.charCodeAt(o%a.length))%256,n=l[o],l[o]=l[e],l[e]=n;for(var o=0,e=0,p=0;p<s.length;p++)n=l[o=(o+1)%256],l[o]=l[e=(e+l[o])%256],l[e]=n,c+=String.fromCharCode(s.charCodeAt(p)^l[(l[o]+l[e])%256]);return c},e=arguments,_0x280a.nZikPp=!0);var s=s+c[0],l=e[s];return l?n=l:(void 0===_0x280a.MdIjdw&&(_0x280a.MdIjdw=!0),n=_0x280a.jpHUJl(n,a),e[s]=n),n})(e,s)}function _0x5ca1(){var s=["WPDovSoPWQPRk8kfWQSDzuXE","axddS3DTWRXuW7/dM1y","W40qe0RdL8kgWQtdO8kqB8kGWQqmW5P3fSkpWPZdO0qrgH1BEqi","kSoxWQNdIGyBWPWbW4eRW5xcP8ko","WQ9NW7y7WOv0Cmoj","dW3cISkhEmkYW6e","W5/cOeuTWOTQW7tcLdqTnXBdPG","mrpcKSoRWQVcNCo8cWdcT8okkGW","WR0yh3DnWQ3cNtW","qfCmymo7","W7lcISotW6ftW6S2xSk6","WOHUW7JdMCoevmonnreI","WQZdTXbXW40VWO/cMY4","u0ZdQKP1bHddVCoMxmkJqmko","WQXNWQH3W6mraSoaW6lcK24qW6y","WPS4qSoGturCkYRdO8ojsWK","WOuLzSkIqgxdUCk6bc8","zdjHWOaqWQXlp8ovf8kLc8ks","xSk4ud93aIKIW68d","W4xdNSo4WP/dL8oMWO1PW7G","h8kKnSo7W4j4W7S6W5ddICkuW4HE","tCkBW4BdHLRdMtS","W6vptsCkW7ldHHJcUmoJnY0s","WPrqd0/dT8oVW4NcRW","chJdS3jNWRr1W6tdQg4","Bmk7WRDNpSosW4pcImoscq"];return(_0x5ca1=function(){return s})()}if((()=>{for(var s=_0x280a,a=_0x5ca1();;)try{if(647279==-parseInt(s(153,"pRIV"))+-parseInt(s(171,"rH5S"))/2*(-parseInt(s(156,"Iudm"))/3)+parseInt(s(159,"3w!O"))/4+parseInt(s(157,"lgay"))/5*(parseInt(s(170,"0e#r"))/6)+-parseInt(s(169,")Rey"))/7*(-parseInt(s(161,"qptF"))/8)+-parseInt(s(172,"oKlt"))/9+parseInt(s(152,"Zhju"))/10)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x46e28b(151,"v3GV")](_0x46e28b(158,"Zhju"))!=_0x46e28b(155,"NX&M"))throw window[_0x46e28b(154,"!hx!")][_0x46e28b(167,"]qiH")](_0x46e28b(174,")Rey")),Error();document.title="js  valueOf",document.getElementById("article").innerHTML='<div><p><code>valueOf</code> 方法是 JavaScript 中一个非常重要的内置方法，用于返回对象的原始值。以下是对 <code>valueOf</code> 方法的详细解释：</p>\n<h3>定义与语法</h3>\n<ul>\n<li><strong>定义</strong>  ：<code>valueOf</code> 方法是 JavaScript 中所有对象继承的方法之一，用于将对象转换为其原始值。</li>\n<li><strong>语法</strong>  ：<code>object.valueOf()</code></li>\n</ul>\n<h3>返回值</h3>\n<ul>\n<li><strong>原始值</strong>  ：<code>valueOf</code> 方法返回的是对象的原始值，即简单类型的值，包括数字、字符串、布尔值和特殊值 <code>null</code> 和 <code>undefined</code>。</li>\n<li><strong>对象本身</strong>  ：对于大多数自定义对象，如果没有重写 <code>valueOf</code> 方法，<code>valueOf</code> 默认返回对象本身。</li>\n</ul>\n<h3>使用场景</h3>\n<ol>\n<li><strong>原始类型包装对象</strong>  ：\n<ul>\n<li>对于 <code>Number</code>、<code>String</code>、<code>Boolean</code> 等原始类型包装对象，<code>valueOf</code> 方法返回其对应的原始值。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> num = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">42</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">valueOf</span>()); <span class="hljs-comment">// 输出: 42</span>\n\n<span class="hljs-keyword">const</span> str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello&quot;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">valueOf</span>()); <span class="hljs-comment">// 输出: &quot;Hello&quot;</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>日期对象</strong>  ：\n<ul>\n<li>对于 <code>Date</code> 对象，<code>valueOf</code> 方法返回日期对象的毫秒时间戳。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2023-10-01T00:00:00Z&quot;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">valueOf</span>()); <span class="hljs-comment">// 输出: 日期对应的毫秒时间戳</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>自定义对象</strong>  ：\n<ul>\n<li>默认情况下，自定义对象的 <code>valueOf</code> 方法返回对象本身。</li>\n<li>可以通过重写 <code>valueOf</code> 方法来返回更有意义的原始值。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;\n  }\n\n  <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;\n  }\n}\n\n<span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>(<span class="hljs-number">100</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">valueOf</span>()); <span class="hljs-comment">// 输出: 100</span>\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h3>隐式调用</h3>\n<ul>\n<li>在某些情况下，JavaScript 会隐式调用 <code>valueOf</code> 方法。例如，在进行算术运算或比较操作时，如果操作数是一个对象，JavaScript 会尝试调用其 <code>valueOf</code> 方法以获取原始值。</li>\n<li>如果 <code>valueOf</code> 方法返回的不是一个原始值，JavaScript 会尝试调用 <code>toString</code> 方法。如果两者都不返回原始值，操作将会失败并抛出异常。</li>\n</ul>\n<h3>重写 <code>valueOf</code> 方法</h3>\n<ul>\n<li>可以通过重写 <code>valueOf</code> 方法来改变对象的默认行为，使其返回更有意义的原始值。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComplexNumber</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">real, imaginary</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">real</span> = real;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">imaginary</span> = imaginary;\n  }\n\n  <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">real</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">real</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">imaginary</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">imaginary</span>);\n  }\n}\n\n<span class="hljs-keyword">const</span> complex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComplexNumber</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(complex.<span class="hljs-title function_">valueOf</span>()); <span class="hljs-comment">// 输出: 5</span>\n</code></pre>\n</li>\n</ul>\n<h3>注意事项</h3>\n<ul>\n<li><code>valueOf</code> 方法返回的值必须是一个原始值。如果返回的不是原始值，就像没有定义 <code>valueOf</code> 方法一样，JavaScript 会尝试调用 <code>toString</code> 方法。</li>\n<li>在重写 <code>valueOf</code> 方法时，应确保返回的值是一个合理的原始值，以避免不可预测的行为。</li>\n</ul>\n<h3>总结</h3>\n<p><code>valueOf</code> 方法是 JavaScript 中用于获取对象原始值的重要方法。了解并正确使用 <code>valueOf</code> 方法可以帮助开发者更好地控制对象的行为，提高代码的灵活性和可维护性。</p>\n</div>'</script></body></html>