<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4b07(t,s){var c=_0x7d4a();return(_0x4b07=function(s,n){var a=c[s-=118];void 0===_0x4b07.xSPOEC&&(_0x4b07.BDwIZu=function(s,n){var a,e=[],t=0,c="";for(s=(s=>{for(var n,a,e="",t="",c=0,l=0;a=s.charAt(l++);~a&&(n=c%4?64*n+a:a,c++%4)&&(e+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,r=e.length;o<r;o++)t+="%"+("00"+e.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(t)})(s),l=0;l<256;l++)e[l]=l;for(l=0;l<256;l++)t=(t+e[l]+n.charCodeAt(l%n.length))%256,a=e[l],e[l]=e[t],e[t]=a;for(var l=0,t=0,o=0;o<s.length;o++)a=e[l=(l+1)%256],e[l]=e[t=(t+e[l])%256],e[t]=a,c+=String.fromCharCode(s.charCodeAt(o)^e[(e[l]+e[t])%256]);return c},t=arguments,_0x4b07.xSPOEC=!0);var s=s+c[0],e=t[s];return e?a=e:(void 0===_0x4b07.heGzFg&&(_0x4b07.heGzFg=!0),a=_0x4b07.BDwIZu(a,n),t[s]=a),a})(t,s)}function _0x7d4a(){var s=["lCoXoCkvcwvGWQaX","W5BcTN3cIYmvdG","BNFdRSkoWRldMSkbF8ocWQVdPGO","WPRcH0mNjSkJCf8mW7ZdGwO","nmkGl8k1W4qlWOu","W6eRdSkwr8ksy8ol","wvJdS8kuWPi5WOy","g8kfW5ZcTYFdMSkMjanNFSkRBW","WRRdUNWGiCoGWPS","D2dcK8o9W7VcH8kgW6y4WO3dRLNdMq","k8o0p8ojrayGWQOXdXbdWO0","ygRdS2CMW4BdGSk1WRi","W5a7WQ1Qf8kxWQq","hSkbW5tcScBdLSkRkdv5qSkgCG","pmoBDuhcU8o5WOiVWQRcNGFcMq","WOxdP2aZb8kcW4/dImo7","W57cHmoEWO3dQLNcJmk1W6LdW7Gqsq","zIKCyhdcH8one8klzCk/p20","dmocW4tcR8oW","WPRcRCkspSk3W5XMe8kjA8oIiei","WQRcIJqvWR8kW53cNmo9WPDUrIa","xuRdN8ohA1xdQSkUqCoppCoDWOaiw17dMmknW4XgW4XSW4L9k0C","WOrNWRHfdK7cT8o3W7jqFq8","xghdRmkFWQ4lWP4","WR59xSoob8olySokW6dcL8ktW4C","WPFcQSkqnmk5W5mwgmk0qSoOfW"];return(_0x7d4a=function(){return s})()}var _0x23c2c9=_0x4b07;if((()=>{for(var s=_0x4b07,n=_0x7d4a();;)try{if(438360==+parseInt(s(130,"Qc)n"))*(parseInt(s(140,"uV@z"))/2)+-parseInt(s(128,"sTZr"))/3+parseInt(s(127,"#R6]"))/4*(-parseInt(s(120,"4(a4"))/5)+parseInt(s(139,"opBR"))/6+parseInt(s(119,"x]]w"))/7+parseInt(s(135,"%auX"))/8+-parseInt(s(137,"y2vQ"))/9*(parseInt(s(124,"(KIb"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x23c2c9(134,"^IQ3")](_0x23c2c9(141,"gydt"))!=_0x23c2c9(118,"6DsG"))throw window[_0x23c2c9(131,"(KIb")][_0x23c2c9(138,"CzJe")](_0x23c2c9(121,"cCR7")),Error();document.title="Vue3 为什么没有循环处理对象",document.getElementById("article").innerHTML='<div><p>在 Vue 3 的响应式系统中，<code>createReactiveObject</code> 函数确实 <strong>不会显式循环遍历对象的所有属性</strong>   来递归处理它们。这是因为 Vue 3 采用了 <strong>惰性代理（Lazy Proxy）</strong>   的设计策略，即只有在访问某个属性时才会动态处理它，而不是一次性递归处理整个对象。这种设计显著提升了性能，尤其是对于大型对象或嵌套结构。</p>\n<hr>\n<h3>为什么没有循环处理对象？</h3>\n<ol>\n<li><strong>惰性代理（Lazy Proxy）</strong><br>\nVue 3 的响应式代理（Proxy）会在 <strong>属性被访问时</strong>   才递归将其转换为响应式。例如：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>({ \n  <span class="hljs-attr">nested</span>: { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> } <span class="hljs-comment">// `nested` 不会立即被代理，直到访问 `obj.nested` 时才会处理</span>\n})\n</code></pre>\n<ul>\n<li>初始时，只有 <code>obj</code> 被代理，<code>nested</code> 仍是普通对象。</li>\n<li>当访问 <code>obj.nested</code> 时，Proxy 的 <code>get</code> 拦截器会触发，此时才会将 <code>nested</code> 转换为响应式。</li>\n</ul>\n</li>\n<li><strong>性能优化</strong><br>\n避免一次性递归遍历整个对象，减少不必要的开销。对于深层嵌套或未访问的属性，不会提前转换。</li>\n<li><strong>动态响应性</strong><br>\n只有实际被访问的属性会被代理，未被访问的属性保持原样，符合按需响应的原则。</li>\n</ol>\n<hr>\n<h3>源码逻辑解析（简化版）</h3>\n<p>在 <code>createReactiveObject</code> 函数中，核心逻辑是创建一个 Proxy 并存储到 <code>reactiveMap</code>，而 <strong>递归处理</strong>   是通过 Proxy 的 <code>get</code> 拦截器动态完成的：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactiveObject</span>(<span class="hljs-params">target, handlers</span>) {\n  <span class="hljs-comment">// 1. 检查是否已有代理（通过 reactiveMap）</span>\n  <span class="hljs-keyword">if</span> (reactiveMap.<span class="hljs-title function_">has</span>(target)) {\n    <span class="hljs-keyword">return</span> reactiveMap.<span class="hljs-title function_">get</span>(target)\n  }\n\n  <span class="hljs-comment">// 2. 创建 Proxy（不递归处理属性）</span>\n  <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {\n    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) {\n      <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)\n      <span class="hljs-comment">// 惰性转换：当访问属性时，如果是对象则递归 reactive()</span>\n      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="hljs-literal">null</span>) {\n        <span class="hljs-keyword">return</span> <span class="hljs-title function_">reactive</span>(res) <span class="hljs-comment">// 关键点：按需递归</span>\n      }\n      <span class="hljs-keyword">return</span> res\n    },\n    <span class="hljs-comment">// ... 其他拦截器（set/deleteProperty 等）</span>\n  })\n\n  <span class="hljs-comment">// 3. 存储代理到 reactiveMap</span>\n  reactiveMap.<span class="hljs-title function_">set</span>(target, proxy)\n  <span class="hljs-keyword">return</span> proxy\n}\n</code></pre>\n<hr>\n<h3>示例验证</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>\n\n<span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>({\n  <span class="hljs-attr">nested</span>: { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> },\n  <span class="hljs-attr">untouched</span>: { <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> } <span class="hljs-comment">// 此属性不会被立即代理</span>\n})\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">nested</span>) <span class="hljs-comment">// 访问时，nested 被递归转换为响应式</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isReactive</span>(obj.<span class="hljs-property">nested</span>)) <span class="hljs-comment">// true</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isReactive</span>(obj.<span class="hljs-property">untouched</span>)) <span class="hljs-comment">// false （未访问时仍是普通对象）</span>\n</code></pre>\n<hr>\n<h3>总结</h3>\n<ul>\n<li><strong>没有循环处理</strong>  ：<code>createReactiveObject</code> 不会主动遍历对象属性，而是通过 Proxy 的 <code>get</code> 拦截器 <strong>按需递归转换</strong>  。</li>\n<li><strong>优势</strong>  ：减少初始化开销，动态响应，避免不必要的递归。</li>\n<li><strong>开发者注意</strong>  ：Vue 3 的响应式是“浅层”的，只有被访问的嵌套属性才会变为响应式。如果需要强制深度响应式，可使用 <code>shallowReactive()</code> 或手动递归调用 <code>reactive()</code>。</li>\n</ul>\n</div>'</script></body></html>