<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x54c58a=_0x2521;function _0x401a(){var s=["W4dcG38NW5iSqH04eSkzq8oC","WONdQH7cTSoOW5rHW5CzoW","BmktWRrWeCkwh29IW6NcTG","WPNcHSk5W7vlmd/dRW","uevYW4FcNCoaFfFdRuK","l8oaW5VdTSovb3NdQCkx","FCkLirZdIZ9eWOlcSgFcVSobmq","iSoqW4lcHSkUW5T3WQRcVSk8ta","aJXWWQDbexr6pCkTWOa","cM/dSmoExcLvW6pdGJm","WOVcIa0hW4uLWPT8uKZcML5V","qCoXd8kJW4nuWQyUrxxcGSoqWOq","k8kovCktWOJcJ8oWW4XWw3e","aKNcUZddICktW4e","WRBcVmklW5HpWRPtoCoVCa","uYTUlbpdS2O","W7aLxG/dHdDLfhNdOG","W6pdH0hdJGiCfZi6Dseh","W6fWW5KluCo5WRdcK8oFWO8","pdZdK8k+ms7dSfy2","W4iAurZdOKmFdSko","arpdQCkZsSo8BdddL3JcRSkKiq","W5CHDvpdSG","sgZcImoVCM3dQKaDpWSW","h3NdMSoDW5ddPMGClmkexColpa","cqe3WOdcTmk5bbddSfvwWR/cKCkkacK7EmkbWPzRW5tcUG4GW5e"];return(_0x401a=function(){return s})()}function _0x2521(o,s){var t=_0x401a();return(_0x2521=function(s,n){var a=t[s-=357];void 0===_0x2521.RRksMc&&(_0x2521.LYGSXR=function(s,n){var a,l=[],o=0,t="";for(s=(s=>{for(var n,a,l="",o="",t=0,p=0;a=s.charAt(p++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,c=l.length;e<c;e++)o+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(o)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)o=(o+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[o],l[o]=a;for(var p=0,o=0,e=0;e<s.length;e++)a=l[p=(p+1)%256],l[p]=l[o=(o+l[p])%256],l[o]=a,t+=String.fromCharCode(s.charCodeAt(e)^l[(l[p]+l[o])%256]);return t},o=arguments,_0x2521.RRksMc=!0);var s=s+t[0],l=o[s];return l?a=l:(void 0===_0x2521.CHLDwU&&(_0x2521.CHLDwU=!0),a=_0x2521.LYGSXR(a,n),o[s]=a),a})(o,s)}if((()=>{for(var s=_0x2521,n=_0x401a();;)try{if(588909==+parseInt(s(363,"Vx)h"))+-parseInt(s(358,"oOlv"))/2*(parseInt(s(377,"yhHn"))/3)+-parseInt(s(360,"O$Qf"))/4*(parseInt(s(362,"PVZa"))/5)+parseInt(s(372,"d!d%"))/6+parseInt(s(367,"9hBo"))/7+-parseInt(s(374,"Z^9^"))/8*(-parseInt(s(373,"X8&W"))/9)+parseInt(s(382,"5QaC"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x54c58a(359,"PYn9")](_0x54c58a(365,"RH*W"))!=_0x54c58a(368,"1(Cq"))throw window[_0x54c58a(375,"A^2z")][_0x54c58a(361,"tkVe")](_0x54c58a(371,"sZoo")),Error();document.title="Vue3 进阶 API - 渲染函数",document.getElementById("article").innerHTML='<div><p>这些 API 主要来自 Vue 3 的<strong>渲染函数（Render Function）</strong>   体系，用于在 JavaScript 中编程式地创建、操作虚拟 DOM（VNode），是实现“模板语法”底层逻辑的核心工具，也能让开发者在需要高度动态性的场景下直接通过代码控制组件渲染。以下是对每个 API 的详细解释：</p>\n<h3>1. <code>h()</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：全称 <code>createVNode</code>，用于<strong>创建虚拟 DOM 节点（VNode）</strong>   ，是渲染函数的“核心入口”。</p>\n</li>\n<li>\n<p><strong>参数与原理</strong>   ：</p>\n<ul>\n<li>语法：<code>h(type, props, children)</code></li>\n<li><code>type</code>：节点类型（如 HTML 标签名 <code>\'div\'</code>、组件对象 <code>MyComponent</code>）。</li>\n<li><code>props</code>：节点的属性、事件等（如 <code>{ class: \'box\', onClick: () =&gt; {} }</code>）。</li>\n<li><code>children</code>：子节点（可以是 VNode、字符串、数组等）。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { h } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-comment">// 创建一个 &lt;div class=&quot;hello&quot;&gt;Hello&lt;/div&gt; 的 VNode</span>\n<span class="hljs-keyword">const</span> vnode = <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;div&quot;</span>, { <span class="hljs-attr">class</span>: <span class="hljs-string">&quot;hello&quot;</span> }, <span class="hljs-string">&quot;Hello&quot;</span>);\n</code></pre>\n<p>它等价于模板语法：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n</li>\n</ul>\n<h3>2. <code>mergeProps()</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：<strong>合并多个属性对象</strong>   ，常用于处理组件的 <code>props</code> 合并（比如父组件传递的 <code>props</code> 与子组件内部默认 <code>props</code> 合并）。</p>\n</li>\n<li>\n<p><strong>场景与原理</strong>   ：</p>\n<ul>\n<li>当多个对象包含相同属性时，<code>mergeProps</code> 会智能合并（如事件监听器会被合并为数组，避免覆盖）。</li>\n<li>是处理组件属性透传、默认属性与用户属性合并的工具。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { mergeProps } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-keyword">const</span> defaultProps = {\n  <span class="hljs-attr">class</span>: <span class="hljs-string">&quot;default&quot;</span>,\n  <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;默认点击&quot;</span>),\n};\n<span class="hljs-keyword">const</span> userProps = { <span class="hljs-attr">class</span>: <span class="hljs-string">&quot;custom&quot;</span>, <span class="hljs-attr">onFocus</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;聚焦&quot;</span>) };\n\n<span class="hljs-keyword">const</span> merged = <span class="hljs-title function_">mergeProps</span>(defaultProps, userProps);\n<span class="hljs-comment">// merged 结果：</span>\n<span class="hljs-comment">// {</span>\n<span class="hljs-comment">//   class: &#x27;custom&#x27;, // 普通属性，后者覆盖前者</span>\n<span class="hljs-comment">//   onClick: () =&gt; console.log(&#x27;默认点击&#x27;),</span>\n<span class="hljs-comment">//   onFocus: () =&gt; console.log(&#x27;聚焦&#x27;)</span>\n<span class="hljs-comment">// }</span>\n</code></pre>\n</li>\n</ul>\n<h3>3. <code>cloneVNode()</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：<strong>深克隆一个 VNode</strong>   ，生成与原 VNode 结构、数据完全一致的新 VNode。</p>\n</li>\n<li>\n<p><strong>场景与原理</strong>   ：</p>\n<ul>\n<li>当需要复用 VNode 但又要避免引用共享（防止修改一个影响另一个）时使用。</li>\n<li>克隆时会保留 VNode 的所有属性、子节点等。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { h, cloneVNode } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-keyword">const</span> originalVNode = <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;div&quot;</span>, <span class="hljs-string">&quot;原始节点&quot;</span>);\n<span class="hljs-keyword">const</span> clonedVNode = <span class="hljs-title function_">cloneVNode</span>(originalVNode);\n\nclonedVNode.<span class="hljs-property">children</span> = <span class="hljs-string">&quot;克隆后修改的内容&quot;</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(originalVNode.<span class="hljs-property">children</span>); <span class="hljs-comment">// 仍为 &#x27;原始节点&#x27;（互不影响）</span>\n</code></pre>\n</li>\n</ul>\n<h3>4. <code>isVNode()</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：判断一个值<strong>是否为 Vue 的虚拟节点（VNode）</strong>   。</p>\n</li>\n<li>\n<p><strong>场景与原理</strong>   ：</p>\n<ul>\n<li>在处理动态内容、自定义渲染逻辑时，用于校验输入是否为合法的 VNode，避免类型错误。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { h, isVNode } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-keyword">const</span> vnode = <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;div&quot;</span>);\n<span class="hljs-keyword">const</span> isVNodeResult = <span class="hljs-title function_">isVNode</span>(vnode); <span class="hljs-comment">// true</span>\n\n<span class="hljs-keyword">const</span> normalObj = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;test&quot;</span> };\n<span class="hljs-keyword">const</span> isObjVNode = <span class="hljs-title function_">isVNode</span>(normalObj); <span class="hljs-comment">// false</span>\n</code></pre>\n</li>\n</ul>\n<h3>5. <code>resolveComponent()</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：在<strong>渲染函数中解析（获取）组件对象</strong>   ，常用于动态组件场景（如根据名称动态加载组件）。</p>\n</li>\n<li>\n<p><strong>场景与原理</strong>   ：</p>\n<ul>\n<li>当组件是通过注册（如 <code>app.component(\'MyComp\', MyComp)</code>）而非直接导入时，需要用 <code>resolveComponent</code> 按名称查找组件。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { h, resolveComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-comment">// 假设 &#x27;MyComponent&#x27; 已全局注册</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComp</span> = <span class="hljs-title function_">resolveComponent</span>(<span class="hljs-string">&quot;MyComponent&quot;</span>);\n\n<span class="hljs-comment">// 动态创建该组件的 VNode</span>\n<span class="hljs-keyword">const</span> vnode = <span class="hljs-title function_">h</span>(<span class="hljs-title class_">MyComp</span>, { <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;hello&quot;</span> });\n</code></pre>\n</li>\n</ul>\n<h3>6. <code>resolveDirective()</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：在<strong>渲染函数中解析（获取）指令对象</strong>   ，用于编程式地给 VNode 添加指令。</p>\n</li>\n<li>\n<p><strong>场景与原理</strong>   ：</p>\n<ul>\n<li>与 <code>resolveComponent</code> 类似，当指令是注册的（如 <code>app.directive(\'my-dir\', MyDir)</code>），需通过名称解析后才能在渲染函数中使用。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { h, resolveDirective, withDirectives } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-comment">// 假设 &#x27;my-dir&#x27; 已全局注册</span>\n<span class="hljs-keyword">const</span> myDir = <span class="hljs-title function_">resolveDirective</span>(<span class="hljs-string">&quot;my-dir&quot;</span>);\n\n<span class="hljs-keyword">const</span> vnode = <span class="hljs-title function_">withDirectives</span>(<span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;div&quot;</span>, <span class="hljs-string">&quot;带指令的节点&quot;</span>), [[myDir, <span class="hljs-string">&quot;指令参数&quot;</span>]]);\n</code></pre>\n</li>\n</ul>\n<h3>7. <code>withDirectives()</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：<strong>给 VNode 添加指令</strong>   ，是在渲染函数中使用“指令”的核心工具（因为指令本质是对 VNode 的增强逻辑）。</p>\n</li>\n<li>\n<p><strong>场景与原理</strong>   ：</p>\n<ul>\n<li>接收一个 VNode 和“指令数组”，返回添加了指令的新 VNode。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { h, withDirectives } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-keyword">const</span> vnode = <span class="hljs-title function_">withDirectives</span>(\n  <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;input&quot;</span>), <span class="hljs-comment">// 要添加指令的 VNode</span>\n  [\n    <span class="hljs-comment">// 指令数组：[指令对象, 指令参数, 修饰符]</span>\n    [\n      vModel,\n      modelValue,\n      [\n        <span class="hljs-comment">/* 修饰符 */</span>\n      ],\n    ],\n    [myCustomDir, <span class="hljs-string">&quot;dir-arg&quot;</span>, [<span class="hljs-string">&quot;mod1&quot;</span>, <span class="hljs-string">&quot;mod2&quot;</span>]],\n  ],\n);\n</code></pre>\n</li>\n</ul>\n<h3>8. <code>withModifiers()</code></h3>\n<ul>\n<li>\n<p><strong>作用</strong>   ：给<strong>事件处理函数添加修饰符逻辑</strong>   （如 <code>.stop</code>、<code>.prevent</code> 等），让渲染函数中定义的事件能像模板中一样支持修饰符。</p>\n</li>\n<li>\n<p><strong>场景与原理</strong>   ：</p>\n<ul>\n<li>接收一个事件处理函数和修饰符数组，返回带有修饰符逻辑的新函数。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { h, withModifiers } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-keyword">const</span> vnode = <span class="hljs-title function_">h</span>(\n  <span class="hljs-string">&quot;button&quot;</span>,\n  {\n    <span class="hljs-attr">onClick</span>: <span class="hljs-title function_">withModifiers</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;点击且阻止冒泡、阻止默认行为&quot;</span>);\n    }, [<span class="hljs-string">&quot;stop&quot;</span>, <span class="hljs-string">&quot;prevent&quot;</span>]),\n  },\n  <span class="hljs-string">&quot;点击我&quot;</span>,\n);\n</code></pre>\n<p>等价于模板：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop.prevent</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>点击我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n</code></pre>\n</li>\n</ul>\n<h3>总结</h3>\n<p>这些 API 是 Vue 3 渲染函数的“工具库”，核心作用是：</p>\n<ul>\n<li>用 JavaScript 代码替代模板，实现<strong>更灵活、更动态的组件渲染逻辑</strong>   （比如根据复杂条件生成不同 VNode）。</li>\n<li>暴露模板语法的底层能力，让开发者能精准控制虚拟 DOM 的创建、合并、指令与事件修饰符等细节。</li>\n<li>是实现“渲染逻辑复用”“动态组件系统”“自定义渲染器”等高级功能的基础。</li>\n</ul>\n<p>如果是 Vue 开发者，掌握这些 API 能让你在“模板无法满足需求”时（如动态生成大量结构、开发渲染库），更灵活地操控组件渲染。</p>\n</div>'</script></body></html>