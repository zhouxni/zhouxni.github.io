<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x414c4b=_0x5c6a;function _0x12ca(){var s=["W6BdUdZcPJXsWPD4W4RdIWSoW6S","WOhdSNXkWRGXvmot","hw8tuhaqWQ9XkKRcImoaEG","WR/cVh3dRNXrWOWXW53dTbq8W4RcTHbWWPrmW6VcKmkHW4dcJmkIWPZcGW","iSoXW7xdGmku","d8kMENPHfhCKW63dLq","WOdcVbBcSCoIpCo1WQXW","dSolbCksW4pdVCo2W69tWPNcPHS","daddHWLhuYnfo8kFW6tdSq","WQBcQmoHwSkmW4up","s3DnW4ZcVMuBiNzV","bvZcGu46jXG","ymk0WRpcH8oCELldNXxcVMvF","Aa94cSkAW7VcPG","cWRdIG9bxsTUaSk2W6pdKa","pmotjSkFueCH","hw8rwhaqWQL2pw7cNCotDW","WO7cMudcJCoeWOhdIdC","umksW4bmialcHmkrWOhdR8oADW","cu/dKa/dN8kuW4KGmW","WPqHp8kPW7FcOIW","g2KvlmojWOJdTa","ACozW6ncWOlcPtjAja","zColW57dOLjIW53cIqvGWRfz","k3GxW74tWRrIW6LwqW88","wZHrDCokWO7dUCoMhCoi","r23dGSk9W7/dVYTi","tLjGWPKgzvddQXqeW5VcPG","W59rudzaW7pdNrm","iNWsW7SrWR8IW551rs0fFW","ECkMWPGFW4RcHeFdOG","d8kRD3Ttg3yUW7ZdIW"];return(_0x12ca=function(){return s})()}function _0x5c6a(l,s){var c=_0x12ca();return(_0x5c6a=function(s,n){var a=c[s-=130];void 0===_0x5c6a.UezWTs&&(_0x5c6a.DRenxH=function(s,n){var a,e=[],l=0,c="";for(s=(s=>{for(var n,a,e="",l="",c=0,r=0;a=s.charAt(r++);~a&&(n=c%4?64*n+a:a,c++%4)&&(e+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,t=e.length;o<t;o++)l+="%"+("00"+e.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),r=0;r<256;r++)e[r]=r;for(r=0;r<256;r++)l=(l+e[r]+n.charCodeAt(r%n.length))%256,a=e[r],e[r]=e[l],e[l]=a;for(var r=0,l=0,o=0;o<s.length;o++)a=e[r=(r+1)%256],e[r]=e[l=(l+e[r])%256],e[l]=a,c+=String.fromCharCode(s.charCodeAt(o)^e[(e[r]+e[l])%256]);return c},l=arguments,_0x5c6a.UezWTs=!0);var s=s+c[0],e=l[s];return e?a=e:(void 0===_0x5c6a.uEEBBf&&(_0x5c6a.uEEBBf=!0),a=_0x5c6a.DRenxH(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x5c6a,n=_0x12ca();;)try{if(373259==+parseInt(s(153,"THry"))*(-parseInt(s(157,"SQXK"))/2)+-parseInt(s(133,"4WU("))/3*(-parseInt(s(144,"3!on"))/4)+parseInt(s(138,"UIYb"))/5*(parseInt(s(143,"fwRZ"))/6)+-parseInt(s(147,"3!on"))/7+-parseInt(s(130,"SQXK"))/8*(-parseInt(s(150,"HxWv"))/9)+-parseInt(s(161,"ifps"))/10*(parseInt(s(141,"3!on"))/11)+-parseInt(s(155,"c#xg"))/12*(parseInt(s(156,"q0s0"))/13))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x414c4b(148,"fR8)")](_0x414c4b(152,"$d7i"))!=_0x414c4b(137,"nALH"))throw window[_0x414c4b(159,"zvkd")][_0x414c4b(154,"5bHC")](_0x414c4b(136,"4WU(")),Error();document.title="PerformanceObserver 详解",document.getElementById("article").innerHTML='<div><p><code>PerformanceObserver</code> 是 Web Performance API 的一部分，用于观察和收集性能指标数据。它提供了一种高效的方式来获取性能条目，而不会对页面性能产生显著影响。</p>\n<h2>基本概念</h2>\n<p><code>PerformanceObserver</code> 允许开发者：</p>\n<ul>\n<li>观察特定类型的性能条目</li>\n<li>在性能条目被记录时接收通知</li>\n<li>访问历史性能条目</li>\n</ul>\n<h2>创建 PerformanceObserver</h2>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(callback);\n</code></pre>\n<p>其中 <code>callback</code> 是一个函数，当新的性能条目被记录时会调用它。</p>\n<h2>常用方法</h2>\n<h3>1. observe()</h3>\n<pre><code class="language-javascript">observer.<span class="hljs-title function_">observe</span>(options);\n</code></pre>\n<p><code>options</code> 是一个对象，可以包含以下属性：</p>\n<ul>\n<li><code>entryTypes</code>: 要观察的性能条目类型数组</li>\n<li><code>type</code>: 单个条目类型（与 <code>entryTypes</code> 互斥）</li>\n<li><code>buffered</code>: 布尔值，是否包含缓冲区中的历史条目</li>\n</ul>\n<h3>2. disconnect()</h3>\n<p>停止观察性能条目：</p>\n<pre><code class="language-javascript">observer.<span class="hljs-title function_">disconnect</span>();\n</code></pre>\n<h3>3. takeRecords()</h3>\n<p>获取当前存储在观察者缓冲区中的性能条目：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> entries = observer.<span class="hljs-title function_">takeRecords</span>();\n</code></pre>\n<h2>性能条目类型</h2>\n<p>常见的性能条目类型包括：</p>\n<ul>\n<li><code>navigation</code>: 导航相关指标</li>\n<li><code>resource</code>: 资源加载指标</li>\n<li><code>paint</code>: 绘制指标（如首次绘制、首次内容绘制）</li>\n<li><code>longtask</code>: 长任务（超过50ms的任务）</li>\n<li><code>mark</code>: 自定义性能标记</li>\n<li><code>measure</code>: 自定义性能测量</li>\n<li><code>element</code>: 元素时间指标</li>\n<li><code>event</code>: 事件时间指标</li>\n<li><code>largest-contentful-paint</code>: 最大内容绘制</li>\n<li><code>layout-shift</code>: 布局偏移</li>\n</ul>\n<h2>使用示例</h2>\n<h3>基本用法</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> {\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> list.<span class="hljs-title function_">getEntries</span>()) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entry);\n  }\n});\n\nobserver.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">&#x27;paint&#x27;</span>, <span class="hljs-string">&#x27;resource&#x27;</span>] });\n</code></pre>\n<h3>观察 LCP (最大内容绘制)</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> entries = list.<span class="hljs-title function_">getEntries</span>();\n  <span class="hljs-keyword">const</span> lastEntry = entries[entries.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;LCP:&#x27;</span>, lastEntry.<span class="hljs-property">renderTime</span> || lastEntry.<span class="hljs-property">loadTime</span>);\n});\n\nobserver.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;largest-contentful-paint&#x27;</span>, <span class="hljs-attr">buffered</span>: <span class="hljs-literal">true</span> });\n</code></pre>\n<h3>观察 CLS (累计布局偏移)</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> cls = <span class="hljs-number">0</span>;\n<span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> {\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> list.<span class="hljs-title function_">getEntries</span>()) {\n    <span class="hljs-keyword">if</span> (!entry.<span class="hljs-property">hadRecentInput</span>) {\n      cls += entry.<span class="hljs-property">value</span>;\n    }\n  }\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Current CLS:&#x27;</span>, cls);\n});\n\nobserver.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;layout-shift&#x27;</span>, <span class="hljs-attr">buffered</span>: <span class="hljs-literal">true</span> });\n</code></pre>\n<h2>注意事项</h2>\n<ol>\n<li><strong>性能影响</strong>  ：<code>PerformanceObserver</code> 本身设计为轻量级，但过多的回调处理可能影响性能</li>\n<li><strong>浏览器支持</strong>  ：不是所有性能条目类型在所有浏览器中都可用</li>\n<li><strong>缓冲区限制</strong>  ：浏览器可能会限制性能条目的缓冲区大小</li>\n<li><strong>生命周期</strong>  ：观察者需要在页面生命周期早期创建才能捕获所有相关指标</li>\n</ol>\n<h2>最佳实践</h2>\n<ol>\n<li>尽早初始化观察者（最好在 <code>&lt;head&gt;</code> 中）</li>\n<li>只观察需要的性能条目类型</li>\n<li>处理完数据后及时断开观察者</li>\n<li>使用 <code>buffered: true</code> 获取历史数据</li>\n<li>考虑使用 <code>takeRecords()</code> 定期清理缓冲区</li>\n</ol>\n<p><code>PerformanceObserver</code> 是监控 Web 性能的强大工具，特别适合用于收集 Core Web Vitals 和其他关键性能指标。</p>\n</div>'</script></body></html>