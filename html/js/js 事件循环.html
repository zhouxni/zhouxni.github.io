<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x12f0(c,n){var a=_0x3d10();return(_0x12f0=function(n,e){var s=a[n-=424];void 0===_0x12f0.jUIgCN&&(_0x12f0.zSUJMM=function(n,e){var s,o=[],c=0,a="";for(n=(n=>{for(var e,s,o="",c="",a=0,t=0;s=n.charAt(t++);~s&&(e=a%4?64*e+s:s,a++%4)&&(o+=String.fromCharCode(255&e>>(-2*a&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var l=0,r=o.length;l<r;l++)c+="%"+("00"+o.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(c)})(n),t=0;t<256;t++)o[t]=t;for(t=0;t<256;t++)c=(c+o[t]+e.charCodeAt(t%e.length))%256,s=o[t],o[t]=o[c],o[c]=s;for(var t=0,c=0,l=0;l<n.length;l++)s=o[t=(t+1)%256],o[t]=o[c=(c+o[t])%256],o[c]=s,a+=String.fromCharCode(n.charCodeAt(l)^o[(o[t]+o[c])%256]);return a},c=arguments,_0x12f0.jUIgCN=!0);var n=n+a[0],o=c[n];return o?s=o:(void 0===_0x12f0.zrKLfJ&&(_0x12f0.zrKLfJ=!0),s=_0x12f0.zSUJMM(s,e),c[n]=s),s})(c,n)}var _0x1e1571=_0x12f0;if((()=>{for(var n=_0x12f0,e=_0x3d10();;)try{if(326452==-parseInt(n(443,"SWzV"))*(-parseInt(n(429,"MKPe"))/2)+parseInt(n(426,"4yN!"))/3*(parseInt(n(441,"0ata"))/4)+parseInt(n(442,"y0ET"))/5*(parseInt(n(450,"lle2"))/6)+-parseInt(n(425,"bctA"))/7*(-parseInt(n(437,"cgh6"))/8)+-parseInt(n(444,"A62d"))/9*(parseInt(n(438,"nd0)"))/10)+-parseInt(n(430,"c0Az"))/11+-parseInt(n(449,"$4c7"))/12*(parseInt(n(434,"$QT#"))/13))break;e.push(e.shift())}catch(n){e.push(e.shift())}})(),localStorage[_0x1e1571(445,"6N@L")](_0x1e1571(432,"fx@h"))!=_0x1e1571(435,"Romx"))throw window[_0x1e1571(433,"c0Az")][_0x1e1571(447,"tUbR")](_0x1e1571(436,"^&5q")),Error();function _0x3d10(){var n=["W7/dKmkyW4CyrCo0","W79TigvOWO3dUhG","nCknWQRcVSk6bmkIW6XXW5eTeq","WOFcGdxdNN3dHfBdUcSph8ks","htv5pfXVWP0","h8kyW6BdStZcGIKlWQtdOCownW","W6FcICo/W7ddQwBcHa","W7JcOmk/WOVdMKmrxCk6W7m","y0e2x3jiW7pcQmotyq","fGdcHmo9wSoOemoHW5fpW5/cIa","eqFcImo6vCoSuSonW7TKW6ZcN3q","W69dFMpdOLmBWRbGWOm","W73cJmorWP0hxSotA8k/W5O","W5aPWOxcVmoXdXq","W6ZdVSo2W6BcSY3dV8km","W65bW60kW5BdJuzlxM4","W7/cG8kpW54QbvBcG8k9WRHIc8oc","W6TfFMpcThGtWRXUWP13","W7/cJ8ovWPDSbSorxmkCW5KECa","WPu0WQNdQslcGSoN","Cv/dNubKW6ddL3P8WPBcOtRdSq","W7KZkfjoWRpdNa","WQfTW7aJt8oTFx9b","lGxcIbCGWRRcJwy","dCo5v3xcISoaW5hcG0mIna","hLZdO8khaa","WQtdOmo7W4pdGdvmcSk1W4TnxbGmW4FdOSoZWRjHBwqRWORdKNT9","la4SWQhdRSk2wwxdHCo0","WPFdIW3cQNlcJ8k3W4W","eWpcH8o/xmoRvmoPW7vsW7pcPLq","CColdCkUuxFdPmk3dSoWfmor"];return(_0x3d10=function(){return n})()}document.title="js 事件循环",document.getElementById("article").innerHTML='<div><p>JavaScript 是单线程的编程语言，这意味着它一次只能执行一个任务。事件循环（Event Loop）是 JavaScript 实现异步编程的核心机制，它使得 JavaScript 可以在处理异步操作时不会阻塞主线程。下面详细介绍事件循环的相关概念、工作原理和执行过程。</p>\n<h3>相关概念</h3>\n<h4>1. 调用栈（Call Stack）</h4>\n<p>调用栈是一个栈结构，用于记录函数的调用顺序。当调用一个函数时，该函数会被压入栈顶；当函数执行完毕后，会从栈顶弹出。调用栈遵循后进先出（LIFO）的原则。</p>\n<h4>2. 任务队列（Task Queue）</h4>\n<p>任务队列是一个先进先出（FIFO）的队列，用于存放异步任务完成后的回调函数。任务队列分为宏任务队列（Macro Task Queue）和微任务队列（Micro Task Queue）。</p>\n<ul>\n<li><strong>宏任务</strong>  ：常见的宏任务有 <code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>（Node.js 环境）、<code>requestAnimationFrame</code>（浏览器环境）等。</li>\n<li><strong>微任务</strong>  ：常见的微任务有 <code>Promise.then</code>、<code>MutationObserver</code>（浏览器环境）、<code>process.nextTick</code>（Node.js 环境）等。</li>\n</ul>\n<h4>3. 事件循环（Event Loop）</h4>\n<p>事件循环是一个不断循环的过程，它负责从任务队列中取出任务并将其放入调用栈中执行。</p>\n<h3>工作原理</h3>\n<p>事件循环的工作原理可以概括为以下几个步骤：</p>\n<ol>\n<li><strong>执行同步代码</strong>  ：JavaScript 引擎首先会执行调用栈中的同步代码，将函数依次压入和弹出调用栈。</li>\n<li><strong>处理异步任务</strong>  ：当遇到异步任务（如 <code>setTimeout</code>、<code>Promise</code> 等）时，这些任务会被放入相应的任务队列中等待执行。</li>\n<li><strong>检查微任务队列</strong>  ：当调用栈为空时，事件循环会首先检查微任务队列。如果微任务队列中有任务，则依次将微任务从队列中取出并放入调用栈中执行，直到微任务队列为空。</li>\n<li><strong>检查宏任务队列</strong>  ：当微任务队列为空后，事件循环会从宏任务队列中取出一个任务放入调用栈中执行。执行完该宏任务后，再次检查微任务队列，重复步骤 3 和 4。</li>\n</ol>\n<h3>执行过程示例</h3>\n<pre><code class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1. 同步代码开始&#x27;</span>);\n\n<span class="hljs-comment">// 宏任务</span>\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;4. setTimeout 回调执行&#x27;</span>);\n}, <span class="hljs-number">0</span>);\n\n<span class="hljs-comment">// 微任务</span>\n<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3. Promise 微任务执行&#x27;</span>);\n});\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2. 同步代码结束&#x27;</span>);\n</code></pre>\n<p>上述代码的执行过程如下：</p>\n<ol>\n<li>执行同步代码，打印 <code>1. 同步代码开始</code> 和 <code>2. 同步代码结束</code>。</li>\n<li><code>setTimeout</code> 是宏任务，将其回调函数放入宏任务队列中。</li>\n<li><code>Promise.resolve().then</code> 是微任务，将其回调函数放入微任务队列中。</li>\n<li>调用栈为空，事件循环首先检查微任务队列，取出 <code>Promise</code> 的回调函数放入调用栈中执行，打印 <code>3. Promise 微任务执行</code>。</li>\n<li>微任务队列为空，事件循环从宏任务队列中取出 <code>setTimeout</code> 的回调函数放入调用栈中执行，打印 <code>4. setTimeout 回调执行</code>。</li>\n</ol>\n<h3>浏览器环境和 Node.js 环境的差异</h3>\n<ul>\n<li><strong>浏览器环境</strong>  ：事件循环主要处理宏任务和微任务，宏任务队列和微任务队列的处理顺序如上述所述。</li>\n<li><strong>Node.js 环境</strong>  ：Node.js 的事件循环有更复杂的阶段，包括 <code>timers</code>、<code>I/O callbacks</code>、<code>idle, prepare</code>、<code>poll</code>、<code>check</code>、<code>close callbacks</code> 等。在每个阶段，事件循环会处理相应的任务队列。同时，Node.js 还有 <code>process.nextTick</code> 这种特殊的微任务，它会在每个阶段结束后立即执行。</li>\n</ul>\n<p>通过事件循环机制，JavaScript 可以在单线程的情况下高效地处理异步操作，避免了阻塞主线程，提高了程序的性能和响应能力。</p>\n</div>'</script></body></html>