<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4aea(){var s=["W7tdILHhbLj3WP7cNdpdVSocWQ8","wYvyWQ8NWQy/","WQT2WORdICo1cCkXCJtcPSopmCkdWQa","jWpdVGOEh8kH","W5GvDqvoW406W4eftJRcPG","nYi0W54WE8kDsa","W6BdIdldN1K7WQVcKSkbbSkdtYPde8o3WOGaWOH6WQVdOJVdOCkowG","FmoSWORcM0u","W6lcSCkgDKTSha","lbRdVmk8pIrUhL9wWPNdRCo4W5m","jWpdLcpcHM7cOSo7W4z7W7LGlW","WOXljfidWPaNW5u","W7tdIfHkaLn0WQtcTqhdKCocWRa","WOy+vSolW6epWRlcOhNdVGSUW48","b8oCdhtcISoEothcTW","WOSqW6ldLCo3wZKIA8k9f8kvjq","lSoGWPpdUXRcI8kzW4i","W7tcKruXwZGo","iCkmWOVdO8oUW4mLw8k8AsxcNcu","WOWqW6FdNSo7udiKy8kGpCkwga","W6xdPmoyW6mBjCoRmZDwDSkwrq","WOHev8ktWPldTIHDWQDiW7bhra","k2jJy8kcrh/dGIfYFuBdRG","W6/dO8osW60riSkVecHhF8k9","iCoAg1JcJCoihW"];return(_0x4aea=function(){return s})()}function _0x5d0e(p,s){var l=_0x4aea();return(_0x5d0e=function(s,n){var a=l[s-=458];void 0===_0x5d0e.gKfAEo&&(_0x5d0e.zPSEYg=function(s,n){var a,e=[],p=0,l="";for(s=(s=>{for(var n,a,e="",p="",l=0,t=0;a=s.charAt(t++);~a&&(n=l%4?64*n+a:a,l++%4)&&(e+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,d=e.length;c<d;c++)p+="%"+("00"+e.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),t=0;t<256;t++)e[t]=t;for(t=0;t<256;t++)p=(p+e[t]+n.charCodeAt(t%n.length))%256,a=e[t],e[t]=e[p],e[p]=a;for(var t=0,p=0,c=0;c<s.length;c++)a=e[t=(t+1)%256],e[t]=e[p=(p+e[t])%256],e[p]=a,l+=String.fromCharCode(s.charCodeAt(c)^e[(e[t]+e[p])%256]);return l},p=arguments,_0x5d0e.gKfAEo=!0);var s=s+l[0],e=p[s];return e?a=e:(void 0===_0x5d0e.nkvtWx&&(_0x5d0e.nkvtWx=!0),a=_0x5d0e.zPSEYg(a,n),p[s]=a),a})(p,s)}var _0xd30dc6=_0x5d0e;if((()=>{for(var s=_0x5d0e,n=_0x4aea();;)try{if(734713==+parseInt(s(471,"9Gmb"))*(parseInt(s(475,"qbkz"))/2)+parseInt(s(458,"qbkz"))/3+parseInt(s(470,"qbkz"))/4+parseInt(s(463,"u329"))/5*(parseInt(s(481,"&(53"))/6)+-parseInt(s(476,"M9K@"))/7+parseInt(s(480,"^IfH"))/8+parseInt(s(459,"!Ue4"))/9*(-parseInt(s(467,"t2vp"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0xd30dc6(482,"N)QB")](_0xd30dc6(472,"N)QB"))!=_0xd30dc6(465,"QmL1"))throw window[_0xd30dc6(469,"XJWE")][_0xd30dc6(461,"gUZW")](_0xd30dc6(464,"]DFc")),Error();document.title="vue Watcher.prototype.addDep 的作用详解",document.getElementById("article").innerHTML='<div><p><code>Watcher.prototype.addDep</code> 是 Vue 响应式系统中一个关键方法，它负责建立 Watcher 和 Dep 之间的双向依赖关系。以下是其核心作用的全面分析：</p>\n<h2>一、核心功能</h2>\n<p><code>addDep</code> 方法的主要作用是：</p>\n<ol>\n<li><strong>建立 Watcher 与 Dep 的双向引用</strong>\n<ul>\n<li>让 Watcher 知道它依赖了哪些 Dep（响应式数据的依赖收集器）</li>\n<li>让 Dep 知道有哪些 Watcher 订阅了它的变化</li>\n</ul>\n</li>\n<li><strong>避免重复收集依赖</strong>\n<ul>\n<li>确保同一个 Watcher 不会被重复添加到 Dep 的订阅者列表中</li>\n</ul>\n</li>\n</ol>\n<h2>二、源码实现分析（Vue 2.x）</h2>\n<pre><code class="language-javascript"><span class="hljs-comment">// src/core/observer/watcher.js</span>\n<span class="hljs-title class_">Watcher</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">addDep</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">dep: Dep</span>) {\n  <span class="hljs-keyword">const</span> id = dep.<span class="hljs-property">id</span>\n  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span>.<span class="hljs-title function_">has</span>(id)) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span>.<span class="hljs-title function_">add</span>(id)\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDeps</span>.<span class="hljs-title function_">push</span>(dep)\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">depIds</span>.<span class="hljs-title function_">has</span>(id)) {\n      dep.<span class="hljs-title function_">addSub</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// 关键：将当前Watcher添加到Dep的订阅列表</span>\n    }\n  }\n}\n</code></pre>\n<h2>三、工作流程</h2>\n<ol>\n<li><strong>依赖收集阶段</strong>  ：<pre><code class="language-mermaid">graph LR\n  A[响应式数据getter触发] --&gt; B[检查Dep.target]\n  B --&gt; C{是否有Watcher?}\n  C --&gt;|是| D[调用dep.depend()]\n  D --&gt; E[调用Watcher.addDep(dep)]\n</code></pre>\n</li>\n<li><strong>方法内部执行步骤</strong>  ：\n<ul>\n<li>检查 Dep 的 ID 是否已记录</li>\n<li>如果没有记录：\n<ul>\n<li>添加到 <code>newDepIds</code> 和 <code>newDeps</code> 中</li>\n<li>如果这个 Dep 是新的（不在 <code>depIds</code> 中）：\n<ul>\n<li>调用 <code>dep.addSub(this)</code> 将 Watcher 订阅到 Dep</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2>四、为什么需要这个方法？</h2>\n<ol>\n<li><strong>解决重复依赖问题</strong>  ：\n<ul>\n<li>避免同一轮求值中多次添加相同 Dep</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-attr">computed</span>: {\n  <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> <span class="hljs-comment">// 同一属性被多次访问</span>\n  }\n}\n</code></pre>\n</li>\n<li><strong>支持依赖清理</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 每次更新后会清理不再需要的依赖</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cleanupDeps</span>()\n</code></pre>\n</li>\n<li><strong>优化性能</strong>  ：\n<ul>\n<li>使用 Set 结构（<code>newDepIds</code>）快速判断是否已收集</li>\n</ul>\n</li>\n</ol>\n<h2>五、实际应用场景</h2>\n<h3>1. 计算属性场景</h3>\n<pre><code class="language-javascript"><span class="hljs-attr">computed</span>: {\n  <span class="hljs-title function_">total</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">quantity</span>\n  }\n}\n</code></pre>\n<ul>\n<li><code>price</code> 和 <code>quantity</code> 各自的 Dep 都会通过 <code>addDep</code> 被收集</li>\n</ul>\n<h3>2. 条件渲染场景</h3>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n<ul>\n<li>当 <code>show</code> 为 false 时，<code>message</code> 的 Dep 会被正确清理</li>\n</ul>\n<h2>六、相关属性说明</h2>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>类型</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>newDepIds</code></td>\n<td>Set</td>\n<td>当前轮次收集的 Dep ID 集合</td>\n</tr>\n<tr>\n<td><code>newDeps</code></td>\n<td>Array</td>\n<td>当前轮次收集的 Dep 实例数组</td>\n</tr>\n<tr>\n<td><code>depIds</code></td>\n<td>Set</td>\n<td>上一轮次收集的 Dep ID 集合</td>\n</tr>\n<tr>\n<td><code>deps</code></td>\n<td>Array</td>\n<td>上一轮次收集的 Dep 实例数组</td>\n</tr>\n</tbody>\n</table>\n<h2>七、与 <code>cleanupDeps</code> 的配合</h2>\n<p>每次更新后调用 <code>cleanupDeps</code>：</p>\n<pre><code class="language-javascript"><span class="hljs-title class_">Watcher</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">cleanupDeps</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 移除不再需要的旧依赖</span>\n  <span class="hljs-comment">// 交换 newDeps/deps 和 newDepIds/depIds</span>\n}\n</code></pre>\n<p>这种设计使得 Vue 能够精确追踪动态变化的依赖关系。</p>\n<h2>八、总结</h2>\n<p><code>Watcher.prototype.addDep</code> 是 Vue 响应式系统的桥梁方法，它：</p>\n<ol>\n<li>确保依赖被正确收集</li>\n<li>避免重复收集提高性能</li>\n<li>支持依赖的动态更新</li>\n<li>为计算属性和条件渲染等特性提供基础支持</li>\n</ol>\n<p>理解这个方法的工作机制，有助于深入掌握 Vue 的响应式原理和优化技巧。</p>\n</div>'</script></body></html>