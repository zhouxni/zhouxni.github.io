<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2ba3c4=_0x951a;function _0x951a(n,e){var o=_0x3b1d();return(_0x951a=function(e,r){var t=o[e-=173];void 0===_0x951a.UmNfqu&&(_0x951a.DUaqZs=function(e,r){var t,d=[],n=0,o="";for(e=(e=>{for(var r,t,d="",n="",o=0,a=0;t=e.charAt(a++);~t&&(r=o%4?64*r+t:t,o++%4)&&(d+=String.fromCharCode(255&r>>(-2*o&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var p=0,c=d.length;p<c;p++)n+="%"+("00"+d.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(n)})(e),a=0;a<256;a++)d[a]=a;for(a=0;a<256;a++)n=(n+d[a]+r.charCodeAt(a%r.length))%256,t=d[a],d[a]=d[n],d[n]=t;for(var a=0,n=0,p=0;p<e.length;p++)t=d[a=(a+1)%256],d[a]=d[n=(n+d[a])%256],d[n]=t,o+=String.fromCharCode(e.charCodeAt(p)^d[(d[a]+d[n])%256]);return o},n=arguments,_0x951a.UmNfqu=!0);var e=e+o[0],d=n[e];return d?t=d:(void 0===_0x951a.HAbvpk&&(_0x951a.HAbvpk=!0),t=_0x951a.DUaqZs(t,r),n[e]=t),t})(n,e)}if((()=>{for(var e=_0x951a,r=_0x3b1d();;)try{if(390616==+parseInt(e(188,"M9h7"))+-parseInt(e(189,"^D^N"))/2+parseInt(e(174,")tFx"))/3+-parseInt(e(181,"vz!["))/4*(-parseInt(e(175,"e!aq"))/5)+parseInt(e(178,"BrYI"))/6*(parseInt(e(176,"qf[r"))/7)+parseInt(e(184,"gZ6G"))/8+-parseInt(e(180,"qf[r"))/9)break;r.push(r.shift())}catch(e){r.push(r.shift())}})(),localStorage[_0x2ba3c4(173,"Dq%*")](_0x2ba3c4(194,"USpu"))!=_0x2ba3c4(186,"WAvl"))throw window[_0x2ba3c4(182,"PC%U")][_0x2ba3c4(193,"P@Qa")](_0x2ba3c4(191,"6I](")),Error();function _0x3b1d(){var e=["ifLkdbVcKCovW6/cKNZcHmkWWOmN","W7/dS8oXELRcMCkdWPddLCo8pxpcQq","jh0yWOrSj8okpa","k8ofxSkYvrDzWOfIW6dcOmoDcZu","W5O1W5hcP1hdLCkgkCodgfvIga","cL8eW7tcNN9u","WOTQa8kfuW","bgRcVSoJWRLOcmkjW6RdOCoVWPyG","W7DTvNrujmoAe0ldQmk5rG","jmkEW7PoWRCJW5lcLK0qWRZdKW","WPZdPCovW6zoW7n0lCowgSkFpW","v0yPW6NcHbivy8ktsh0Xjs3dVaqwtSkosmkEWPxcRJexWPm","aCo9WQKWeMpdMfuuW4yaW7SA","W4tdL8kjWPj8j8o6","W5idW4f9W4PlW50nCa","yMhdRXhdMSkmk8kAWQWUWPVdPq","WORcHSknhCoPW6FcRWNdUSkRW6G5uG","W7q8W6qEWOZcLLa","WRTjW4apWOHdCKNcVepdOCo5iW","ACkWWOfAD8oUwa","jG0yBeNdPSkK","W59LWOBdGaxcPSoZ","uCkLz1JdSCoEthXreCkKq8oy","bMpcSCoLWRzUdSkOW6ZdRSoPWOmV"];return(_0x3b1d=function(){return e})()}document.title="vue2 生命周期详解",document.getElementById("article").innerHTML="<div><p>1、new Vue()实例化一个vue实例，然后init初始化event 和 lifecycle， 其实这个过程中分别调用了3个初始化函数（initLifecycle(), initEvents(), initRender()），分别初始化了生命周期，事件以及定义createElement函数，初始化生命周期时，定义了一些属性，比如表示当前状态生命周期状态得_isMounted ，_isDestroyed ，_isBeingDestroyed，表示keep-alive中组件状态的_inactive，而初始化event时，实际上就是定义了<code>$once、$off、$emit、$on</code>几个函数。而createElement函数是在初始化render时定义的（调用了initRender函数）。</p>\n<br/>\n<p>2、执行beforeCreate生命周期函数</p>\n<br/>\n<p>3、beforeCreate执行完后，会开始进行数据初始化，这个过程，会定义data数据，方法以及事件，并且完成数据劫持observe以及给组件实例配置watcher观察者实例。这样，后续当数据发生变化时，才能感知到数据的变化并完成页面的渲染</p>\n<br/>\n<p>4、执行created生命周期函数，所以，当这个函数执行的时候，我们已经可以拿到data下的数据以及methods下的方法了，所以在这里，我们可以开始调用方法进行数据请求了</p>\n<br/>\n<p>5、created执行完后，我们可以看到，这里有个判断，判断当前是否有el参数(这里为什么需要判断，是因为我们后面的操作是会依赖这个el的，后面会详细说)，如果有，我们再看是否有template参数。如果没有el，那么我们会等待调用$mount(el)方法(后面会详细说)。</p>\n<br/>\n<p>6、确保有了el后，继续往下走，判断当有template参数时，我们会选择去将template模板转换成render函数（其实在这前面是还有一个判断的，判断当前是否有render函数，如果有的话，则会直接去渲染当前的render函数，如果没有那么我们才开始去查找是否有template模板），如果没有template，那么我们就会直接将获取到的el（也就是我们常见的#app，#app里面可能还会有其他标签）编译成templae, 然后在将这个template转换成render函数。</p>\n<br/>\n<p>7、之后再调用beforMount， 也就是说实际从creted到beforeMount之间，最主要的工作就是将模板或者el转换为render函数。并且我们可以看出一点，就是你不管是用el，还是用template, 或者是用我们最常用的.vue文件(如果是.vue文件，他其实是会先编译成为template)，最终他都是会被转换为render函数的。</p>\n<br/>\n<p>8、beforeMount调用后，我们是不是要开始渲染render函数了，首先我们会先生产一个虚拟dom（用于后续数据发生变化时，新老虚拟dom对比计算），进行保存，然后再开始将render渲染成为真实的dom。渲染成真实dom后，会将渲染出来的真实dom替换掉原来的<code>vm.$el</code> ，然后再将替换后的<code>$el</code> append到我们的页面内。整个初步流程就算是走完了。</p>\n<br/>\n<p>9、之后再调用mounted，并将标识生命周期的一个属性_isMounted 置为true。所以mounted函数内，我们是可以操作dom的，因为这个时候dom已经渲染完成了。</p>\n<br/>\n<p>10、再之后，只有当我们状态数据发生变化时,我们在触发beforeUpdate，要开始将我们变化后的数据渲染到页面上了（实际上这里是有个判断的，判断当前的_isMounted是不是为ture并且_isDestroyed是不是为false，也就是说，保证dom已经被挂载的情况下，且当前组件并未被销毁，才会走update流程）</p>\n<br/>\n<p>11、beforeUpdate调用之后，我们又会重新生成一个新的虚拟dom(Vnode)，然后会拿这个最新的Vnode和原来的Vnode去做一个diff算，这里就涉及到一系列的计算，算出最小的更新范围，从而更新render函数中的最新数据，再将更新后的render函数渲染成真实dom。也就完成了我们的数据更新</p>\n<br/>\n<p>12、然后再执行updated，所以updated里面也可以操作dom，并拿到最新更新后的dom。不过这里我要插一句话了，mouted和updated的执行，并不会等待所有子组件都被挂载完成后再执行，所以如果你希望所有视图都更新完毕后再做些什么事情，那么你最好在mouted或者updated中加一个<code>$nextTick（）</code>，然后把要做的事情放在<code>$nextTick()</code>中去做。</p>\n<br/>\n<p>13、再之后beforeDestroy没啥说的，实例销毁前，也就是说在这个函数内，你还是可以操作实例的</p>\n<br/>\n<p>14、之后会做一系列的销毁动作，解除各种数据引用，移除事件监听，删除组件_watcher，删除子实例，删除自身self等。同时将实例属性_isDestroyed置为true</p>\n<br/>\n<p>15、销毁完成后，再执行destroyed。</p>\n</div>"</script></body></html>