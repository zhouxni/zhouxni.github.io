<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1bc4(){var e=["W7dcI1ZcJ3f1W64ShmkUkN0","fLxdQmk4m2nYcsKmW5SW","nCksWPxdONq","DbznibO1jmkFAmopAGfl","cCouca/dIapcH8kJk2dcI0K","W4STg3zogCkb","WRm6W43cV8omWPldUCoJ","WPP9W5lcPxjlBsa","W5tdQGRdKmkMW4KZjenjW6nTW4y","W7RdH0fldCkwW5NcPG","vYOzsqLqW5xcUG","W6j0W5ixdszyW7ZdRYODua","j8oYC8kqmmkuWRiQWOvGWONcTmkc","WRddM8kJW6rsuIddN8kHr8kKWQa","W6COFCkjF8o2D8kVWQGvW6G8wa","vmkoW7tcH13cISkMuCkd","nCkZWQFdJSoBWRbDW75GECkitq","WPFcSvVdT8oiWP3dUKZdVq","mCk9WQFdJSoEWRWOW6bkwCkmF8ko","W54Th1nBh8kj","cJJdJWChearcd8odWQtcR8kh","W7NdItGqB8oyW57cMCkVv8k/W6y","WPzvWP82BLtcTuecy3WO","eHXcaejrp8oK","W63cL8oUWQ0rxeZcN8k+s8kfWQzRvNVcKKBcQ8kWCchcSYlcLxGD","WPfDWPTQktdcHv4T"];return(_0x1bc4=function(){return e})()}var _0x22ce56=_0x278a;function _0x278a(n,e){var t=_0x1bc4();return(_0x278a=function(e,c){var d=t[e-=491];void 0===_0x278a.vGqnOr&&(_0x278a.waNTZj=function(e,c){var d,o=[],n=0,t="";for(e=(e=>{for(var c,d,o="",n="",t=0,l=0;d=e.charAt(l++);~d&&(c=t%4?64*c+d:d,t++%4)&&(o+=String.fromCharCode(255&c>>(-2*t&6))))d="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(d);for(var i=0,r=o.length;i<r;i++)n+="%"+("00"+o.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(n)})(e),l=0;l<256;l++)o[l]=l;for(l=0;l<256;l++)n=(n+o[l]+c.charCodeAt(l%c.length))%256,d=o[l],o[l]=o[n],o[n]=d;for(var l=0,n=0,i=0;i<e.length;i++)d=o[l=(l+1)%256],o[l]=o[n=(n+o[l])%256],o[n]=d,t+=String.fromCharCode(e.charCodeAt(i)^o[(o[l]+o[n])%256]);return t},n=arguments,_0x278a.vGqnOr=!0);var e=e+t[0],o=n[e];return o?d=o:(void 0===_0x278a.tatiUv&&(_0x278a.tatiUv=!0),d=_0x278a.waNTZj(d,c),n[e]=d),d})(n,e)}if((()=>{for(var e=_0x278a,c=_0x1bc4();;)try{if(415152==-parseInt(e(515,"wA1Z"))+parseInt(e(504,"q]9*"))/2*(-parseInt(e(513,"Vk!d"))/3)+-parseInt(e(516,"dP%N"))/4+-parseInt(e(507,"rzvd"))/5+parseInt(e(510,"M]pO"))/6*(parseInt(e(498,"7iCh"))/7)+parseInt(e(491,"z&FH"))/8+-parseInt(e(500,"WZde"))/9*(-parseInt(e(495,"u[n)"))/10))break;c.push(c.shift())}catch(e){c.push(c.shift())}})(),localStorage[_0x22ce56(497,"1kqT")](_0x22ce56(493,"p(j8"))!=_0x22ce56(506,"aLFo"))throw window[_0x22ce56(514,"86^x")][_0x22ce56(509,"1kqT")](_0x22ce56(502,"z&FH")),Error();document.title="vue3 link、dep 和 effect 的关系",document.getElementById("article").innerHTML="<div><p>其实不用绕！我们可以用「<strong>微信好友关系</strong>   」来类比 <code>link</code> 和 <code>dep</code> 的关系，把抽象的响应式逻辑转化成日常场景，一下子就能明白：</p>\n<h3>先明确两个核心角色</h3>\n<table>\n<thead>\n<tr>\n<th>技术概念</th>\n<th>类比成生活场景</th>\n<th>核心作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Dep</code></td>\n<td>你的「微信账号」</td>\n<td>代表一个「可被监听的响应式数据」（比如 <code>count</code>），负责管理“谁在关注我”</td>\n</tr>\n<tr>\n<td><code>effect</code></td>\n<td>关注你的「好友A」</td>\n<td>代表一个「副作用函数」（比如组件渲染、<code>watchEffect</code> 回调），负责“关注数据变化并做反应”</td>\n</tr>\n<tr>\n<td><code>link</code></td>\n<td>你和好友A的「聊天窗口」</td>\n<td>连接 <code>Dep</code>（数据）和 <code>effect</code>（副作用）的“中间桥梁”，记录双方的关联关系</td>\n</tr>\n</tbody>\n</table>\n<h3>为什么需要 <code>link</code>？—— 解决“双向记忆”问题</h3>\n<p>假设没有 <code>link</code>，就像你和好友A没有聊天窗口：</p>\n<ul>\n<li>你（<code>Dep</code>）知道“好友A关注我”，但记不住“好友A还关注了谁”；</li>\n<li>好友A（<code>effect</code>）知道“我关注了你”，但记不住“我还关注了哪些人”；</li>\n<li>一旦好友A不想关注你了，你俩都得翻遍自己的列表找对方，效率极低。</li>\n</ul>\n<p>而 <code>link</code>（聊天窗口）的存在，就是让双方都能快速找到彼此、管理关系：</p>\n<ul>\n<li>你（<code>Dep</code>）通过 <code>link</code> 能直接找到“关注我的好友A”；</li>\n<li>好友A（<code>effect</code>）通过 <code>link</code> 能直接找到“我关注的你”；</li>\n<li>想解除关系时，直接删了这个聊天窗口（<code>link</code>），双方都能立刻知道。</li>\n</ul>\n<h3>用“加好友→发动态→删好友”理解三者互动</h3>\n<h4>1. 加好友（依赖收集）：创建 <code>link</code> 桥梁</h4>\n<p>当好友A（<code>effect</code>）第一次“关注”你（<code>Dep</code>，比如访问 <code>count.value</code>）：</p>\n<ul>\n<li>系统自动创建一个「聊天窗口」（<code>link</code>）；</li>\n<li>你（<code>Dep</code>）的“好友列表”（<code>dep.subs</code>）里会加入这个 <code>link</code>，表示“我多了一个关注者”；</li>\n<li>好友A（<code>effect</code>）的“关注列表”（<code>effect.deps</code>）里也会加入这个 <code>link</code>，表示“我多关注了一个人”；</li>\n<li><code>link</code> 里会记着：“我连接的是「你（dep）」和「好友A（effect）」”（<code>link.dep = dep</code>，<code>link.effect = effect</code>）。</li>\n</ul>\n<h4>2. 发动态（数据变化）：通过 <code>link</code> 通知</h4>\n<p>当你（<code>Dep</code>，<code>count.value</code> 变了）发了一条动态：</p>\n<ul>\n<li>你会遍历自己的“好友列表”（<code>dep.subs</code>），找到所有 <code>link</code>；</li>\n<li>通过每个 <code>link</code> 找到对应的好友（<code>effect</code>），告诉他们：“我更新了，快看看！”；</li>\n<li>好友A（<code>effect</code>）收到通知后，就会执行自己的逻辑（比如重新渲染组件、执行回调）。</li>\n</ul>\n<h4>3. 删好友（依赖清理）：删除 <code>link</code> 桥梁</h4>\n<p>当好友A（<code>effect</code>）不想关注你了（比如组件卸载、<code>stop(effect)</code>）：</p>\n<ul>\n<li>会找到你俩的「聊天窗口」（<code>link</code>）；</li>\n<li>你（<code>Dep</code>）的“好友列表”（<code>dep.subs</code>）里删除这个 <code>link</code>，表示“我少了一个关注者”；</li>\n<li>好友A（<code>effect</code>）的“关注列表”（<code>effect.deps</code>）里也删除这个 <code>link</code>，表示“我少关注了一个人”；</li>\n<li>最后删掉这个 <code>link</code>，你俩的关联就彻底断了，后续你发动态也不会再通知他。</li>\n</ul>\n<h3>一句话总结核心关系</h3>\n<ul>\n<li><code>Dep</code> 是“被关注的数据”，管着“谁关注我”（存 <code>link</code>）；</li>\n<li><code>effect</code> 是“关注数据的副作用”，管着“我关注谁”（存 <code>link</code>）；</li>\n<li><code>link</code> 是“双向桥梁”，让 <code>Dep</code> 和 <code>effect</code> 能快速找到彼此、管理关联，避免混乱。</li>\n</ul>\n<p>这样类比后，是不是就不绕了？核心就是用 <code>link</code> 解决“数据和副作用如何精准关联、高效通知、安全解绑”的问题～</p>\n</div>"</script></body></html>