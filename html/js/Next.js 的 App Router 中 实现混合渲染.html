<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2a2a87=_0x599a;function _0x599a(p,s){var t=_0x5d81();return(_0x599a=function(s,a){var n=t[s-=215];void 0===_0x599a.mftpLA&&(_0x599a.gDiTZY=function(s,a){var n,l=[],p=0,t="";for(s=(s=>{for(var a,n,l="",p="",t=0,e=0;n=s.charAt(e++);~n&&(a=t%4?64*a+n:n,t++%4)&&(l+=String.fromCharCode(255&a>>(-2*t&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,o=l.length;c<o;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+a.charCodeAt(e%a.length))%256,n=l[e],l[e]=l[p],l[p]=n;for(var e=0,p=0,c=0;c<s.length;c++)n=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=n,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[p])%256]);return t},p=arguments,_0x599a.mftpLA=!0);var s=s+t[0],l=p[s];return l?n=l:(void 0===_0x599a.zmIoBU&&(_0x599a.zmIoBU=!0),n=_0x599a.gDiTZY(n,a),p[s]=n),n})(p,s)}function _0x5d81(){var s=["vmkHW7tdGau7W43dKSk7WPGUCq","WPLvn8oGkCo9eSo1","uu3dVG5ZW5BcMexcI2P7wKW","WOZcJCo+eghdQ1Ot","WPTtvSkwuSkyhSovWOZdLGWG","aYKJWODAr8k5WO1RW7OWWQGN","W45iW4xdGSkQoMJdICoMWP8","imkFWOLsuq","atKRamkLWP3dNsu","s8omeYtdTfbBbq","m8k6fx3dSYf4eCkFWOVdJxS","WP9+umoMW7volmoejdRdJ34B","j8k7W4mgW54XWPRcPCojWOX0WP8n","WRFdP1NdK8kmgSkqW5q","W5vcWPpcNstcTCkvCu9QW4y/","W48ag8oQf8ojjW","W4LBu8k8sSkoaa","hmotbfCYWQzNCq","qhZcS8kkWRxdOqz+","ewSzW7VcJmkdduLLcYC","xeRdSW50W5ZcLNxcI0fsA0a","W4mUlXHfWPtdGq","CftdQSkfWO7cVIScAc7cH8kXmW","W6rqW53dImkquNRcH8o+raWOW5OAW4TyW4fBaKNdSSoecSkJW7Oa","fH3cVIChW4lcSCkcs00D","au4pa8kdWOddPa","c8oZzmkfW6uWW5xdVeO","WPTrx8kwvSkyi8oyWRFdNXqo","frlcUYefWR7cL8kxyhK4ca","WPD7xSoRWPirtmoskXC"];return(_0x5d81=function(){return s})()}if((()=>{for(var s=_0x599a,a=_0x5d81();;)try{if(737005==+parseInt(s(236,"WnP0"))*(-parseInt(s(215,"mg5K"))/2)+parseInt(s(221,"y5Vn"))/3+-parseInt(s(243,"FjYm"))/4+parseInt(s(224,"OOz3"))/5*(parseInt(s(233,"[55&"))/6)+parseInt(s(217,"&WH2"))/7*(-parseInt(s(235,"6to1"))/8)+parseInt(s(222,"62jM"))/9*(parseInt(s(219,"WnP0"))/10)+parseInt(s(229,"uj)Y"))/11*(-parseInt(s(239,"6to1"))/12))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x2a2a87(226,"mg5K")](_0x2a2a87(237,"gMq)"))!=_0x2a2a87(218,"&bL1"))throw window[_0x2a2a87(228,"NkEq")][_0x2a2a87(227,"jR]g")](_0x2a2a87(234,"1PBQ")),Error();document.title="Next.js 的 App Router 中 实现混合渲染",document.getElementById("article").innerHTML='<div><p>在 Next.js 的 <strong>App Router</strong>   中，确实可以通过 <strong>父组件 SSR（服务端组件） + 子组件 CSR（客户端组件）</strong>   的方式实现混合渲染，但这并非唯一方案。以下是更灵活的控制策略和具体实现方法：</p>\n<hr>\n<h3>一、混合渲染的 3 种实现模式</h3>\n<h4>1. <strong>默认模式：父组件 SSR + 子组件 CSR</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/page.js (服务端组件 - SSR)</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">ClientComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ClientComponent&#x27;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>(); <span class="hljs-comment">// 服务端获取数据</span>\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>SSR 内容: {data.title}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">ClientComponent</span> /&gt;</span> {/* 客户端交互部分 */}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-comment">// app/ClientComponent.js (客户端组件 - CSR)</span>\n<span class="hljs-string">&#x27;use client&#x27;</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ClientComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 客户端状态</span>\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setState(s =&gt; s + 1)}&gt;{state}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n</code></pre>\n<p><strong>适用场景</strong>   ：页面主体静态，局部需要交互（如按钮、表单）。</p>\n<hr>\n<h4>2. <strong>动态路由按需渲染</strong></h4>\n<p>通过 <strong>路由参数</strong>   动态选择渲染模式：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/blog/[slug]/page.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{ params }</span>) {\n  <span class="hljs-keyword">if</span> (params.<span class="hljs-property">slug</span> === <span class="hljs-string">&#x27;interactive&#x27;</span>) {\n    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ClientPage</span> /&gt;</span></span>; <span class="hljs-comment">// 整个页面 CSR</span>\n  }\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ServerPage</span> /&gt;</span></span>;  <span class="hljs-comment">// 整个页面 SSR</span>\n}\n\n<span class="hljs-comment">// app/ClientPage.js</span>\n<span class="hljs-string">&#x27;use client&#x27;</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ClientPage</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 完全客户端渲染</span>\n}\n</code></pre>\n<hr>\n<h4>3. <strong>条件性 SSR/CSR 切换</strong></h4>\n<p>使用 <strong>动态导入</strong>   按需加载客户端组件：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/page.js</span>\n<span class="hljs-keyword">import</span> dynamic <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/dynamic&quot;</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">ClientSideChart</span> = <span class="hljs-title function_">dynamic</span>(\n  <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./Chart&quot;</span>),\n  { <span class="hljs-attr">ssr</span>: <span class="hljs-literal">false</span> }, <span class="hljs-comment">// 强制禁用 SSR</span>\n);\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>SSR 内容<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">ClientSideChart</span> /&gt;</span> {/* 仅客户端渲染 */}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<hr>\n<h3>二、突破限制的高级技巧</h3>\n<h4>1. <strong>服务端组件传递数据给客户端组件</strong></h4>\n<p>通过 <strong>props 序列化</strong>   传递初始数据：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/page.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ClientComponent</span> <span class="hljs-attr">initialData</span>=<span class="hljs-string">{data}</span> /&gt;</span></span>;\n}\n\n<span class="hljs-comment">// app/ClientComponent.js</span>\n<span class="hljs-string">&#x27;use client&#x27;</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ClientComponent</span>(<span class="hljs-params">{ initialData }</span>) {\n  <span class="hljs-comment">// 使用服务端预取的数据初始化</span>\n  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(initialData);\n}\n</code></pre>\n<h4>2. <strong>部分 hydration（实验性）</strong></h4>\n<p>使用 <code>react-server-dom</code> 实现组件级 hydration：</p>\n<pre><code class="language-javascript"><span class="hljs-string">&quot;use client&quot;</span>;\n<span class="hljs-keyword">import</span> { hydrateRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/client&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">ClientWrapper</span>(<span class="hljs-params">{ serverRenderedMarkup }</span>) {\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-title function_">hydrateRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>), serverRenderedMarkup);\n  }, []);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span> /&gt;</span></span>;\n}\n</code></pre>\n<hr>\n<h3>三、适用场景对比</h3>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>优点</th>\n<th>缺点</th>\n<th>典型用例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>默认混合模式</strong></td>\n<td>简单直观</td>\n<td>父子组件耦合</td>\n<td>内容页 + 评论区</td>\n</tr>\n<tr>\n<td><strong>动态路由控制</strong></td>\n<td>路由级灵活切换</td>\n<td>需维护多套组件</td>\n<td>文档页（SSR） + 编辑器（CSR）</td>\n</tr>\n<tr>\n<td><strong>动态导入</strong></td>\n<td>精确控制组件级渲染</td>\n<td>加载延迟</td>\n<td>复杂图表/地图</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>四、性能优化要点</h3>\n<ol>\n<li>\n<p><strong>减少客户端组件依赖</strong>   ：</p>\n<ul>\n<li>将逻辑拆分为 <code>shared</code> 工具函数，服务端和客户端共用</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// lib/utils.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">formatDate</span>(<span class="hljs-params">date</span>) { ... } <span class="hljs-comment">// 无 React 依赖，可跨环境使用</span>\n</code></pre>\n</li>\n<li>\n<p><strong>服务端组件缓存</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://api.example.com&quot;</span>, { <span class="hljs-attr">next</span>: { <span class="hljs-attr">tags</span>: [<span class="hljs-string">&quot;data&quot;</span>] } });\n</code></pre>\n</li>\n<li>\n<p><strong>客户端组件懒加载</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HeavyComponent</span> = <span class="hljs-title function_">dynamic</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./Heavy&quot;</span>), {\n  <span class="hljs-attr">loading</span>: <span class="hljs-function">() =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Spinner</span> /&gt;</span></span>,\n});\n</code></pre>\n</li>\n</ol>\n<hr>\n<h3>五、常见问题解答</h3>\n<h4>Q1：能否在客户端组件中嵌套服务端组件？</h4>\n<p><strong>不能</strong>   。客户端组件内只能导入其他客户端组件。若需混合，应通过 <strong>children props</strong>   传递：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/layout.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Layout</span>(<span class="hljs-params">{ children }</span>) {\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ClientWrapper</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">ClientWrapper</span>&gt;</span></span>;\n}\n\n<span class="hljs-comment">// app/ClientWrapper.js</span>\n<span class="hljs-string">&#x27;use client&#x27;</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ClientWrapper</span>(<span class="hljs-params">{ children }</span>) {\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>; <span class="hljs-comment">// children 可以是服务端组件</span>\n}\n</code></pre>\n<h4>Q2：如何强制整个路由 SSR？</h4>\n<p>使用 <strong>服务端组件</strong>   并关闭 <code>\'use client\'</code> 指令即可，无需额外配置。</p>\n<h4>Q3：如何实现类似 <code>getServerSideProps</code> 的效果？</h4>\n<p>直接在服务端组件中 <code>await</code> 数据请求：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// app/page.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;...&quot;</span>); <span class="hljs-comment">// 自动 SSR</span>\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{data}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n<hr>\n<h3>六、总结</h3>\n<p>Next.js App Router 的渲染模式控制远比「父 SSR + 子 CSR」更灵活。关键原则：</p>\n<ol>\n<li><strong>默认服务端优先</strong>   ：除非需要交互或浏览器 API，否则用服务端组件。</li>\n<li><strong>精确控制 hydration</strong>   ：通过 <code>dynamic imports</code> 或路由级切换优化性能。</li>\n<li><strong>数据流设计</strong>   ：利用 props 从服务端向客户端传递初始状态。</li>\n</ol>\n<p>对于复杂场景，可结合 <strong>Edge Functions</strong>   、<strong>中间件</strong>   和 <strong>React Suspense</strong>   实现更细粒度的渲染策略。</p>\n</div>'</script></body></html>