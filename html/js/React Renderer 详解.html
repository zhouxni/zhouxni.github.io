<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x528c(l,s){var e=_0x185c();return(_0x528c=function(s,n){var a=e[s-=245];void 0===_0x528c.eauGEx&&(_0x528c.PUwVna=function(s,n){var a,t=[],l=0,e="";for(s=(s=>{for(var n,a,t="",l="",e=0,c=0;a=s.charAt(c++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,o=t.length;p<o;p++)l+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(l)})(s),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)l=(l+t[c]+n.charCodeAt(c%n.length))%256,a=t[c],t[c]=t[l],t[l]=a;for(var c=0,l=0,p=0;p<s.length;p++)a=t[c=(c+1)%256],t[c]=t[l=(l+t[c])%256],t[l]=a,e+=String.fromCharCode(s.charCodeAt(p)^t[(t[c]+t[l])%256]);return e},l=arguments,_0x528c.eauGEx=!0);var s=s+e[0],t=l[s];return t?a=t:(void 0===_0x528c.CsIcri&&(_0x528c.CsIcri=!0),a=_0x528c.PUwVna(a,n),l[s]=a),a})(l,s)}var _0x2ae46c=_0x528c;function _0x185c(){var s=["yfZdRmkFu8oNuX4CfmoLWRJcMa","bcldJYBcL8ojW7jTaW","W7jUWQ7cKdtcMCkt","kXTHW4iyaJfXAXdcNItdVh9Qex/cTWtdGCoOpCkWW5JdIr0","W4VcVCoebSo8oatdRgpdGrbiW5e","W7/dTSoUvaeFE3BdNSoNw8kw","lCotWPS4WRhdNeRdLq","DCkkW6NcIXZdLGK","WPRdHLm/D1FcKW","zanava4opW","WRhcGCo4b8kkkmkHrCo6i1FcOa","CSkeW49UW7xcGXFdLvLmW7eoWOq","WPtdTmoNWRT3rw/cIHiTWRNdKN8","kmkWu8kVd1/dVW","ECklW45VW7tcJxFdTfLqW6ap","W4lcU8ofaSo+n0/dNKhdPaPN","WQdcPmkSk0rcra","W5ldTmouWQhdNqffWO7dMs0zESkE","WPJcUsa1bCknW4ZcKCkTaSkpmW","W7pdKWRcImkb","pWLOWRfwlwZdGqS9jsJcIG","lrTeW7tdIwqjfMBdOSk2hx8","FxhcNNtdLCkmW4bBp8oHWQeD","k8oRWQXkW4XTgCkSmmoWjCkYCq"];return(_0x185c=function(){return s})()}if((()=>{for(var s=_0x528c,n=_0x185c();;)try{if(376810==+parseInt(s(248,"Hn7k"))*(parseInt(s(245,"wsy@"))/2)+parseInt(s(253,"N[*D"))/3+-parseInt(s(262,"VX3l"))/4+-parseInt(s(250,"^)15"))/5+parseInt(s(255,"pGch"))/6*(parseInt(s(247,"zD)z"))/7)+parseInt(s(261,"72]X"))/8+-parseInt(s(267,"$L^x"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x2ae46c(254,"$L^x")](_0x2ae46c(263,"jZXB"))!=_0x2ae46c(257,"&fIh"))throw window[_0x2ae46c(268,")FZ1")][_0x2ae46c(246,"7q^X")](_0x2ae46c(265,"st)7")),Error();document.title="React Renderer 详解",document.getElementById("article").innerHTML='<div><p>React Renderer（渲染器）是React架构中负责将虚拟DOM转换为特定平台实际UI的模块。它与Reconciler协同工作，构成React跨平台能力的核心。</p>\n<h2>1. 渲染器的作用与定位</h2>\n<h3>1.1 核心职责</h3>\n<ul>\n<li><strong>平台适配</strong>  ：将React元素映射到目标平台（DOM、Native、Canvas等）</li>\n<li><strong>UI更新</strong>  ：执行Reconciler计算的变更到实际UI</li>\n<li><strong>事件处理</strong>  ：设置平台特定的事件监听机制</li>\n<li><strong>资源管理</strong>  ：管理平台相关资源（DOM节点、原生视图等）</li>\n</ul>\n<h3>1.2 与Reconciler的关系</h3>\n<pre><code>Reconciler (计算what变化) → Renderer (执行how渲染)\n</code></pre>\n<h2>2. 主要渲染器实现</h2>\n<h3>2.1 ReactDOM (Web)</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span>;\n\n<span class="hljs-keyword">const</span> root = <span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));\nroot.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);\n</code></pre>\n<h3>2.2 React Native</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppRegistry</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;\n\n<span class="hljs-title class_">AppRegistry</span>.<span class="hljs-title function_">registerComponent</span>(<span class="hljs-string">&#x27;MyApp&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">App</span>);\n</code></pre>\n<h3>2.3 其他渲染器</h3>\n<ul>\n<li><strong>Three Fiber</strong>  ：Three.js渲染器</li>\n<li><strong>React PDF</strong>  ：PDF文档生成</li>\n<li><strong>React ART</strong>  ：矢量图形渲染</li>\n</ul>\n<h2>3. 渲染器架构剖析</h2>\n<h3>3.1 宿主配置(Host Config)</h3>\n<p>每个渲染器必须实现的接口集：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">HostConfig</span> {\n  <span class="hljs-title function_">createInstance</span>(<span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">props</span>: <span class="hljs-built_in">any</span>): <span class="hljs-title class_">HostInstance</span>;\n  <span class="hljs-title function_">appendChild</span>(<span class="hljs-attr">parent</span>: <span class="hljs-title class_">HostInstance</span>, <span class="hljs-attr">child</span>: <span class="hljs-title class_">HostInstance</span>): <span class="hljs-built_in">void</span>;\n  <span class="hljs-title function_">removeChild</span>(<span class="hljs-attr">parent</span>: <span class="hljs-title class_">HostInstance</span>, <span class="hljs-attr">child</span>: <span class="hljs-title class_">HostInstance</span>): <span class="hljs-built_in">void</span>;\n  <span class="hljs-comment">// 共20+个必须实现的方法</span>\n}\n</code></pre>\n<h3>3.2 核心工作流程</h3>\n<ol>\n<li><strong>初始化阶段</strong>  ：创建根容器</li>\n<li><strong>挂载阶段</strong>  ：首次渲染完整树</li>\n<li><strong>更新阶段</strong>  ：应用增量变更</li>\n<li><strong>卸载阶段</strong>  ：清理资源</li>\n</ol>\n<h2>4. 自定义渲染器开发</h2>\n<h3>4.1 基础示例（控制台渲染器）</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Reconciler</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;react-reconciler&#x27;</span>);\n\n<span class="hljs-keyword">const</span> hostConfig = {\n  <span class="hljs-title function_">createInstance</span>(<span class="hljs-params">type</span>) {\n    <span class="hljs-keyword">return</span> { type, <span class="hljs-attr">children</span>: [], <span class="hljs-attr">text</span>: <span class="hljs-literal">null</span> };\n  },\n  <span class="hljs-title function_">appendChild</span>(<span class="hljs-params">parent, child</span>) {\n    parent.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(child);\n  },\n  <span class="hljs-title function_">createTextInstance</span>(<span class="hljs-params">text</span>) {\n    <span class="hljs-keyword">return</span> { text };\n  },\n  <span class="hljs-comment">// 实现其他必要方法...</span>\n};\n\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">ConsoleRenderer</span> = <span class="hljs-title class_">Reconciler</span>(hostConfig);\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">element</span>) {\n  <span class="hljs-keyword">const</span> container = { <span class="hljs-attr">children</span>: [] };\n  <span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ConsoleRenderer</span>.<span class="hljs-title function_">createContainer</span>(container);\n  <span class="hljs-title class_">ConsoleRenderer</span>.<span class="hljs-title function_">updateContainer</span>(element, root, <span class="hljs-literal">null</span>);\n  <span class="hljs-keyword">return</span> container;\n}\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-keyword">const</span> app = (\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">box</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span>World<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">box</span>&gt;</span></span>\n);\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">render</span>(app));\n</code></pre>\n<h3>4.2 关键方法实现</h3>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>职责描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>createInstance</code></td>\n<td>创建平台特定实例</td>\n</tr>\n<tr>\n<td><code>appendChild</code></td>\n<td>添加子节点</td>\n</tr>\n<tr>\n<td><code>removeChild</code></td>\n<td>移除子节点</td>\n</tr>\n<tr>\n<td><code>commitUpdate</code></td>\n<td>处理属性更新</td>\n</tr>\n<tr>\n<td><code>prepareUpdate</code></td>\n<td>准备更新（性能优化用）</td>\n</tr>\n</tbody>\n</table>\n<h2>5. ReactDOM 深度解析</h2>\n<h3>5.1 渲染模式演进</h3>\n<ul>\n<li><strong>Legacy模式</strong>  ：<code>ReactDOM.render(_, domNode)</code></li>\n<li><strong>并发模式</strong>  ：<code>ReactDOM.createRoot(domNode).render()</code></li>\n</ul>\n<h3>5.2 DOM特定处理</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 特殊属性处理</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleSpecialDOMProps</span>(<span class="hljs-params">domElement, propKey, propValue</span>) {\n  <span class="hljs-keyword">if</span> (propKey === <span class="hljs-string">&#x27;dangerouslySetInnerHTML&#x27;</span>) {\n    domElement.<span class="hljs-property">innerHTML</span> = propValue.<span class="hljs-property">__html</span> || <span class="hljs-string">&#x27;&#x27;</span>;\n  }\n  <span class="hljs-comment">// 处理style、children等...</span>\n}\n</code></pre>\n<h3>5.3 事件系统</h3>\n<ul>\n<li><strong>合成事件</strong>  ：跨浏览器统一事件对象</li>\n<li><strong>事件委托</strong>  ：大部分事件在document级别处理</li>\n<li><strong>事件池</strong>  ：复用事件对象提高性能</li>\n</ul>\n<h2>6. 性能优化策略</h2>\n<h3>6.1 批量更新</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 自动批处理示例</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-title function_">setStateA</span>();  <span class="hljs-comment">// 不会立即触发渲染</span>\n  <span class="hljs-title function_">setStateB</span>();  <span class="hljs-comment">// 与上面的更新一起批量处理</span>\n}\n</code></pre>\n<h3>6.2 差异提交优化</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitRoot</span>(<span class="hljs-params">root</span>) {\n  <span class="hljs-comment">// 分为多个阶段提交</span>\n  <span class="hljs-title function_">commitBeforeMutationEffects</span>();\n  <span class="hljs-title function_">commitMutationEffects</span>();  <span class="hljs-comment">// 实际DOM操作</span>\n  <span class="hljs-title function_">commitLayoutEffects</span>();    <span class="hljs-comment">// 同步布局效果</span>\n}\n</code></pre>\n<h2>7. 多平台渲染原理</h2>\n<h3>7.1 通用抽象层</h3>\n<pre><code>           React Core\n               ↓\n         React Reconciler\n               ↓\n+------------+------------+\n|   ReactDOM  |  React Native |\n+------------+------------+\n</code></pre>\n<h3>7.2 平台特定扩展</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// React Native扩展示例</span>\n<span class="hljs-title class_">UIManager</span>.<span class="hljs-title function_">createView</span>(\n  tag,        <span class="hljs-comment">// React节点标识</span>\n  viewName,   <span class="hljs-comment">// 原生视图类型</span>\n  rootTag,    <span class="hljs-comment">// 根标签</span>\n  props       <span class="hljs-comment">// 属性</span>\n);\n</code></pre>\n<h2>8. 测试渲染器</h2>\n<p>React提供的特殊渲染器用于测试：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">TestRenderer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-test-renderer&#x27;</span>;\n\n<span class="hljs-keyword">const</span> testInstance = <span class="hljs-title class_">TestRenderer</span>.<span class="hljs-title function_">create</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> /&gt;</span></span>);\n\n<span class="hljs-comment">// 查找组件</span>\n<span class="hljs-keyword">const</span> buttonInstance = testInstance.<span class="hljs-property">root</span>.<span class="hljs-title function_">findByType</span>(<span class="hljs-title class_">Button</span>);\n</code></pre>\n<h2>9. 未来发展方向</h2>\n<ol>\n<li><strong>服务器组件</strong>  ：更深度服务端集成</li>\n<li><strong>渐进式水合</strong>  ：更精细的hydration控制</li>\n<li><strong>离线渲染</strong>  ：Web Worker中执行渲染</li>\n<li><strong>WebGPU支持</strong>  ：高性能图形渲染</li>\n</ol>\n<h2>总结</h2>\n<p>React Renderer是将React的声明式组件转换为实际UI的关键桥梁。通过理解渲染器的工作原理，开发者可以：</p>\n<ul>\n<li>创建适配新平台的渲染器</li>\n<li>深度优化现有应用性能</li>\n<li>实现高级自定义渲染逻辑</li>\n<li>更好地理解React的多平台能力本质</li>\n</ul>\n</div>'</script></body></html>