<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3d5ac3=_0xb271;function _0xb271(o,s){var r=_0x1a51();return(_0xb271=function(s,n){var a=r[s-=450];void 0===_0xb271.gpJUfy&&(_0xb271.wFZpOJ=function(s,n){var a,t=[],o=0,r="";for(s=(s=>{for(var n,a,t="",o="",r=0,p=0;a=s.charAt(p++);~a&&(n=r%4?64*n+a:a,r++%4)&&(t+=String.fromCharCode(255&n>>(-2*r&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var l=0,e=t.length;l<e;l++)o+="%"+("00"+t.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(o)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)o=(o+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[o],t[o]=a;for(var p=0,o=0,l=0;l<s.length;l++)a=t[p=(p+1)%256],t[p]=t[o=(o+t[p])%256],t[o]=a,r+=String.fromCharCode(s.charCodeAt(l)^t[(t[p]+t[o])%256]);return r},o=arguments,_0xb271.gpJUfy=!0);var s=s+r[0],t=o[s];return t?a=t:(void 0===_0xb271.EYUVCu&&(_0xb271.EYUVCu=!0),a=_0xb271.wFZpOJ(a,n),o[s]=a),a})(o,s)}function _0x1a51(){var s=["WQFcIwNcL0XvW6NcM8o3WRD+W74+","W6NcNSkRW7fgi8kXEvxdJYrAjhPsWOVdG8klqLNdSeHYW4mhW4G","D8kXhSk+WP8","WOtcMwlcThCAdCkka8kYBSko","W4xcGCo4WPvcWPhdVmoop8krW7NcRG","cSkyWQpcTYBdUmkGW7q0","WRldKSoSWRLesmo9lgddOG","Ad9vBNhcMCkVW5rxz8kynum","o2mveZldImoY","WRyXuCoUnmk8WO0MfSoBhmox","g8obomoiW4azzSk/","WR/dIqOZA8kVW608WRi","sflcPmkCyrytWQ5KW7e","WRpdMSoQWRimk8oPgwldVXPm","WRmaWOiSAZxcRq","WORdImoahmoKmKJcS3JdTmkFycS","tMlcTCkTWQxcSZxdIG","WP12W4BdPLBdKhJcO1VdUfNcLd4","c8kAWQhcTqldISkCW5uX","W6xcUMJdJmoJW7hdJtTyW5tdUMyR","WRFdNCoMWRGdlCoxe2NdHq9/","DHBdJmoimh/cPItdHHSYnW","WPxdHCk2W5ldLJRcMmk6","a8khBSogrbxcSSoLWOmHWQThAq","fmoVvSoYWOhcGComWOhdJG","FhjleuJdNCoBBHm"];return(_0x1a51=function(){return s})()}if((()=>{for(var s=_0xb271,n=_0x1a51();;)try{if(640896==+parseInt(s(462,"uJpi"))*(-parseInt(s(470,"FE%U"))/2)+-parseInt(s(464,"7nw]"))/3+-parseInt(s(458,"FE%U"))/4+parseInt(s(471,"!^LD"))/5+-parseInt(s(461,"F9tI"))/6+parseInt(s(469,"bvhQ"))/7*(parseInt(s(451,"FE%U"))/8)+parseInt(s(468,"!1L$"))/9*(parseInt(s(474,"*wsI"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3d5ac3(472,"!^LD")](_0x3d5ac3(475,"X8Ud"))!=_0x3d5ac3(466,"bX9N"))throw window[_0x3d5ac3(454,"TJs[")][_0x3d5ac3(452,"7]pn")](_0x3d5ac3(465,"FE%U")),Error();document.title="Babel 的插件系统中 Visitor（访问器对象）",document.getElementById("article").innerHTML='<div><h3><strong>Babel Visitor（访问器对象）的作用</strong></h3>\n<p>在 Babel 的插件系统中，<strong>Visitor（访问器对象）</strong>   是一个核心概念，用于<strong>定义如何遍历和修改 AST（抽象语法树）</strong>   。它通过<strong>访问者模式（Visitor Pattern）</strong>   实现对 AST 节点的精确控制，是编写 Babel 插件的关键工具。</p>\n<hr>\n<h2><strong>1. Visitor 的基本作用</strong></h2>\n<h3><strong>(1) 遍历 AST 并拦截特定节点</strong></h3>\n<p>Visitor 是一个 JavaScript 对象，其属性名对应 AST 节点的 <code>type</code>（如 <code>FunctionDeclaration</code>、<code>VariableDeclarator</code>），属性值是处理该节点的函数。<br>\n当 Babel 遍历 AST 时，遇到匹配的节点类型，会调用 Visitor 中对应的函数。</p>\n<h3><strong>(2) 修改或替换节点</strong></h3>\n<p>在 Visitor 的回调函数中，可以通过 <code>path</code> 参数访问当前节点的路径信息，进而：</p>\n<ul>\n<li><strong>读取节点内容</strong>   （如变量名、函数参数）。</li>\n<li><strong>修改节点属性</strong>   （如将 <code>const</code> 改为 <code>var</code>）。</li>\n<li><strong>替换或删除节点</strong>   （如将箭头函数转为普通函数）。</li>\n</ul>\n<hr>\n<h2><strong>2. Visitor 的工作流程</strong></h2>\n<h3><strong>示例代码</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> visitor = {\n  <span class="hljs-comment">// 拦截所有 &quot;箭头函数&quot; 节点</span>\n  <span class="hljs-title class_">ArrowFunctionExpression</span>(path) {\n    <span class="hljs-comment">// 将箭头函数转换为普通函数</span>\n    path.<span class="hljs-title function_">replaceWith</span>(<span class="hljs-comment">/* 新的函数节点 */</span>);\n  },\n  <span class="hljs-comment">// 拦截所有 &quot;变量声明&quot; 节点</span>\n  <span class="hljs-title class_">VariableDeclaration</span>(path) {\n    <span class="hljs-keyword">if</span> (path.<span class="hljs-property">node</span>.<span class="hljs-property">kind</span> === <span class="hljs-string">&quot;const&quot;</span>) {\n      path.<span class="hljs-property">node</span>.<span class="hljs-property">kind</span> = <span class="hljs-string">&quot;var&quot;</span>; <span class="hljs-comment">// 修改 const → var</span>\n    }\n  },\n};\n\n<span class="hljs-comment">// 使用 visitor 遍历 AST</span>\n<span class="hljs-title function_">traverse</span>(ast, visitor);\n</code></pre>\n<h3><strong>执行步骤</strong></h3>\n<ol>\n<li>Babel 从 AST 根节点开始遍历。</li>\n<li>遇到 <code>ArrowFunctionExpression</code> 节点时，调用 <code>visitor.ArrowFunctionExpression(path)</code>。</li>\n<li>遇到 <code>VariableDeclaration</code> 节点时，调用 <code>visitor.VariableDeclaration(path)</code>。</li>\n<li>其他未在 Visitor 中定义的节点类型会被跳过。</li>\n</ol>\n<hr>\n<h2><strong>3. Visitor 的核心功能</strong></h2>\n<h3><strong>(1) <code>path</code> 参数的关键属性</strong></h3>\n<table>\n<thead>\n<tr>\n<th>属性/方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>path.node</code></td>\n<td>当前 AST 节点（如 <code>{ type: &quot;Identifier&quot;, name: &quot;foo&quot; }</code>）</td>\n</tr>\n<tr>\n<td><code>path.parent</code></td>\n<td>父节点</td>\n</tr>\n<tr>\n<td><code>path.replaceWith(node)</code></td>\n<td>用新节点替换当前节点</td>\n</tr>\n<tr>\n<td><code>path.remove()</code></td>\n<td>删除当前节点</td>\n</tr>\n<tr>\n<td><code>path.findParent()</code></td>\n<td>向上查找满足条件的父节点</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>(2) 进入与退出节点</strong></h3>\n<p>Visitor 可以在<strong>进入节点时</strong>   （<code>enter</code>）或<strong>退出节点时</strong>   （<code>exit</code>）执行逻辑：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> visitor = {\n  <span class="hljs-title class_">FunctionDeclaration</span>: {\n    <span class="hljs-title function_">enter</span>(<span class="hljs-params">path</span>) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;进入函数声明节点:&quot;</span>, path.<span class="hljs-property">node</span>.<span class="hljs-property">id</span>.<span class="hljs-property">name</span>);\n    },\n    <span class="hljs-title function_">exit</span>(<span class="hljs-params">path</span>) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;退出函数声明节点:&quot;</span>, path.<span class="hljs-property">node</span>.<span class="hljs-property">id</span>.<span class="hljs-property">name</span>);\n    },\n  },\n};\n</code></pre>\n<hr>\n<h2><strong>4. 实际应用场景</strong></h2>\n<h3><strong>(1) 转换箭头函数</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> visitor = {\n  <span class="hljs-title class_">ArrowFunctionExpression</span>(path) {\n    <span class="hljs-comment">// 替换为普通函数</span>\n    path.<span class="hljs-title function_">replaceWith</span>({\n      <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;FunctionExpression&quot;</span>,\n      <span class="hljs-attr">params</span>: path.<span class="hljs-property">node</span>.<span class="hljs-property">params</span>,\n      <span class="hljs-attr">body</span>: path.<span class="hljs-property">node</span>.<span class="hljs-property">body</span>,\n    });\n  },\n};\n</code></pre>\n<h3><strong>(2) 删除所有 <code>console.log</code></strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> visitor = {\n  <span class="hljs-title class_">CallExpression</span>(path) {\n    <span class="hljs-keyword">if</span> (\n      path.<span class="hljs-property">node</span>.<span class="hljs-property">callee</span>.<span class="hljs-property">object</span>?.<span class="hljs-property">name</span> === <span class="hljs-string">&quot;console&quot;</span> &amp;&amp;\n      path.<span class="hljs-property">node</span>.<span class="hljs-property">callee</span>.<span class="hljs-property">property</span>?.<span class="hljs-property">name</span> === <span class="hljs-string">&quot;log&quot;</span>\n    ) {\n      path.<span class="hljs-title function_">remove</span>(); <span class="hljs-comment">// 删除节点</span>\n    }\n  },\n};\n</code></pre>\n<h3><strong>(3) 重命名变量</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> visitor = {\n  <span class="hljs-title class_">Identifier</span>(path) {\n    <span class="hljs-keyword">if</span> (path.<span class="hljs-property">node</span>.<span class="hljs-property">name</span> === <span class="hljs-string">&quot;oldName&quot;</span>) {\n      path.<span class="hljs-property">node</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;newName&quot;</span>; <span class="hljs-comment">// 修改变量名</span>\n    }\n  },\n};\n</code></pre>\n<hr>\n<h2><strong>5. 为什么需要 Visitor？</strong></h2>\n<ol>\n<li><strong>精准控制遍历过程</strong>   ：避免手动递归 AST，提高代码可维护性。</li>\n<li><strong>分离关注点</strong>   ：将不同节点的处理逻辑解耦（如函数、变量分开处理）。</li>\n<li><strong>与 Babel 插件系统集成</strong>   ：Babel 插件本质上是一个包含 Visitor 的对象。</li>\n</ol>\n<hr>\n<h2><strong>总结</strong></h2>\n<ul>\n<li><strong>Visitor 是 Babel 插件的核心</strong>   ，用于定义如何遍历和修改 AST。</li>\n<li><strong>通过 <code>path</code> 参数</strong>   可以读取、修改或替换节点。</li>\n<li><strong>典型应用</strong>   ：语法转换（ES6 → ES5）、代码优化、静态分析等。</li>\n<li><strong>优势</strong>   ：声明式编程、高效遍历、易于扩展。</li>\n</ul>\n<p>通过 Visitor，你可以轻松编写自定义的 Babel 插件，实现复杂的代码转换需求！</p>\n</div>'</script></body></html>