<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x803f50=_0x1783;function _0x1783(t,s){var e=_0x4ea0();return(_0x1783=function(s,a){var n=e[s-=459];void 0===_0x1783.oPcMPi&&(_0x1783.jufQNa=function(s,a){var n,l=[],t=0,e="";for(s=(s=>{for(var a,n,l="",t="",e=0,p=0;n=s.charAt(p++);~n&&(a=e%4?64*a+n:n,e++%4)&&(l+=String.fromCharCode(255&a>>(-2*e&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,r=l.length;c<r;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)t=(t+l[p]+a.charCodeAt(p%a.length))%256,n=l[p],l[p]=l[t],l[t]=n;for(var p=0,t=0,c=0;c<s.length;c++)n=l[p=(p+1)%256],l[p]=l[t=(t+l[p])%256],l[t]=n,e+=String.fromCharCode(s.charCodeAt(c)^l[(l[p]+l[t])%256]);return e},t=arguments,_0x1783.oPcMPi=!0);var s=s+e[0],l=t[s];return l?n=l:(void 0===_0x1783.hpUisz&&(_0x1783.hpUisz=!0),n=_0x1783.jufQNa(n,a),t[s]=n),n})(t,s)}function _0x4ea0(){var s=["jCoHW63dG8k1WQVcVfdcTfqKWOJdPgNcU8kwWRhdLCofW7hcN8kLW5P3BCog","FMDOxmoAvmoWz3TTxCk4W5u","wxmjpuW","E8kgWQhcNXJcPYVdSZJdPSkb","vmkkW7FdKLD/fHhcH3HQWRRcLa","W4hdSSoCWQhcLc3cPW","r8oCWPddOmkLsahcRW","WRn8tmkdW4hcJb0kwGVdJq","g8ktW5/dHSo2ifTsz8o9W7mskW","WOZcQ8kOWRZcJ8kWW6eOFJpdLCoJDa","d8oqW7ddI1pcJcJdHZK","lmkHW6umy2/dHN5TfvPpxW","WRdcP8kFWOLnqw/cTtS","BmkoW7ZcTLDIjIHOwW","n1tcQ8o+W7qPWRxcQahdPZK","W7TUi3tcRCk7jWZdImkNW6e","tCkkW67cG2GnWPNdQSouySkRW5f2","v8kjW7pdLvn9fJ/cHLXjWQdcUa","uCkkW7xdKfT7edJcNxfGWP3cHq","s8kgWONdMaTjW4ldRW","WP1Jt8o3eXVdTq","v8oiASoQzmkAqG","nCoiAtBcO0tdSHZdSG","r8owWQ3dMdX3W6W","l8kNW6imor7cKMnbpW","WOddOSoEdmoZW5JcLWm","WQlcISoloCkOjmkfomkkpSkAjMK"];return(_0x4ea0=function(){return s})()}if((()=>{for(var s=_0x1783,a=_0x4ea0();;)try{if(910385==+parseInt(s(476,"*cep"))*(-parseInt(s(471,"pkDz"))/2)+parseInt(s(468,"Hz#Y"))/3+-parseInt(s(485,"MXhO"))/4+parseInt(s(466,"Y%zL"))/5+-parseInt(s(464,"bP(]"))/6*(parseInt(s(470,"iCHW"))/7)+-parseInt(s(483,"%^ET"))/8*(parseInt(s(480,"*cep"))/9)+parseInt(s(474,"UMaa"))/10*(parseInt(s(479,"tw7p"))/11))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x803f50(462,"g0au")](_0x803f50(467,"I]%*"))!=_0x803f50(459,"EY!#"))throw window[_0x803f50(482,"OddS")][_0x803f50(477,"qeNV")](_0x803f50(484,"TkJ*")),Error();document.title="React 的 useDeferredValue 钩子详解",document.getElementById("article").innerHTML='<div><p><code>useDeferredValue</code> 是 React 18 引入的并发特性(Concurrent Feature)钩子，用于延迟更新某些非关键部分的UI，以保持界面的响应性。</p>\n<h2>基本用法</h2>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { useState, useDeferredValue } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchResults</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [query, setQuery] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);\n  <span class="hljs-keyword">const</span> deferredQuery = <span class="hljs-title function_">useDeferredValue</span>(query);\n  \n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{query}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{e</span> =&gt;</span> setQuery(e.target.value)} /&gt;\n      <span class="hljs-tag">&lt;<span class="hljs-name">Results</span> <span class="hljs-attr">query</span>=<span class="hljs-string">{deferredQuery}</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/&gt;</span></span>\n  );\n}\n</code></pre>\n<h2>核心概念</h2>\n<h3>1. 工作原理</h3>\n<ul>\n<li><strong>延迟更新</strong>  : 返回一个可能&quot;滞后&quot;于原始值的副本</li>\n<li><strong>可中断渲染</strong>  : React 可以在必要时中断并重新开始渲染</li>\n<li><strong>优先级控制</strong>  : 将派生值的更新标记为低优先级</li>\n</ul>\n<h3>2. 与 <code>useTransition</code> 的区别</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>useDeferredValue</code></th>\n<th><code>useTransition</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>控制对象</strong></td>\n<td>值</td>\n<td>状态更新</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>派生状态</td>\n<td>直接状态更新</td>\n</tr>\n<tr>\n<td><strong>反馈机制</strong></td>\n<td>无直接加载指示</td>\n<td>提供 <code>isPending</code> 状态</td>\n</tr>\n<tr>\n<td><strong>使用方式</strong></td>\n<td>包装值</td>\n<td>包装状态更新逻辑</td>\n</tr>\n</tbody>\n</table>\n<h2>使用场景</h2>\n<h3>1. 搜索输入优化</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchPage</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [text, setText] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);\n  <span class="hljs-keyword">const</span> deferredText = <span class="hljs-title function_">useDeferredValue</span>(text);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{text}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{e</span> =&gt;</span> setText(e.target.value)} /&gt;\n      {/* 结果列表会延迟更新 */}\n      <span class="hljs-tag">&lt;<span class="hljs-name">SearchResults</span> <span class="hljs-attr">query</span>=<span class="hljs-string">{deferredText}</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h3>2. 大数据量渲染</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">BigDataRenderer</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [filter, setFilter] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);\n  <span class="hljs-keyword">const</span> deferredFilter = <span class="hljs-title function_">useDeferredValue</span>(filter);\n  <span class="hljs-keyword">const</span> bigList = <span class="hljs-title function_">filterBigData</span>(deferredFilter); <span class="hljs-comment">// 耗时操作</span>\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">FilterInput</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{filter}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{setFilter}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">List</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{bigList}</span> /&gt;</span> {/* 延迟更新减少卡顿 */}\n    <span class="hljs-tag">&lt;/&gt;</span></span>\n  );\n}\n</code></pre>\n<h2>高级用法</h2>\n<h3>1. 自定义延迟时间</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> deferredValue = <span class="hljs-title function_">useDeferredValue</span>(value, {\n  <span class="hljs-attr">timeoutMs</span>: <span class="hljs-number">2000</span> <span class="hljs-comment">// 最大延迟2秒</span>\n});\n</code></pre>\n<h3>2. 与 <code>Suspense</code> 配合使用</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProfilePage</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [userId, setUserId] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);\n  <span class="hljs-keyword">const</span> deferredUserId = <span class="hljs-title function_">useDeferredValue</span>(userId);\n  \n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setUserId(prev =&gt; prev + 1)}&gt;\n        下一个用户\n      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Spinner</span> /&gt;</span>}&gt;\n        <span class="hljs-tag">&lt;<span class="hljs-name">UserProfile</span> <span class="hljs-attr">userId</span>=<span class="hljs-string">{deferredUserId}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>\n    <span class="hljs-tag">&lt;/&gt;</span></span>\n  );\n}\n</code></pre>\n<h2>性能优化技巧</h2>\n<h3>1. 记忆化子组件</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> deferredData = <span class="hljs-title function_">useDeferredValue</span>(data);\n\n<span class="hljs-comment">// 使用React.memo避免不必要的重新渲染</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">MemoizedComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">ExpensiveComponent</span>);\n\n<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MemoizedComponent</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{deferredData}</span> /&gt;</span></span>;\n</code></pre>\n<h3>2. 结合 <code>useMemo</code> 使用</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> deferredQuery = <span class="hljs-title function_">useDeferredValue</span>(query);\n<span class="hljs-keyword">const</span> results = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">computeExpensiveResult</span>(deferredQuery);\n}, [deferredQuery]);\n</code></pre>\n<h2>注意事项</h2>\n<ol>\n<li><strong>不是防抖/节流替代品</strong>\n<ul>\n<li><code>useDeferredValue</code> 是React层面的优化</li>\n<li>对于网络请求仍需使用防抖/节流</li>\n</ul>\n</li>\n<li><strong>使用限制</strong>\n<ul>\n<li>只能在函数组件内使用</li>\n<li>需要React 18+并发模式</li>\n</ul>\n</li>\n<li><strong>过度使用问题</strong>\n<ul>\n<li>可能导致UI不一致性</li>\n<li>应在性能关键路径上选择性使用</li>\n</ul>\n</li>\n<li><strong>与输入控制组件的兼容性</strong>\n<ul>\n<li>不要用于受控输入组件的value属性</li>\n<li>会导致输入延迟和卡顿</li>\n</ul>\n</li>\n</ol>\n<h2>实际案例</h2>\n<h3>大型表格渲染</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">DataTable</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [sortKey, setSortKey] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;id&#x27;</span>);\n  <span class="hljs-keyword">const</span> deferredSortKey = <span class="hljs-title function_">useDeferredValue</span>(sortKey);\n  <span class="hljs-keyword">const</span> sortedData = <span class="hljs-title function_">sortLargeDataset</span>(data, deferredSortKey);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">SortControls</span> <span class="hljs-attr">onSort</span>=<span class="hljs-string">{setSortKey}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>\n          {sortedData.map(row =&gt; (\n            <span class="hljs-tag">&lt;<span class="hljs-name">TableRow</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{row.id}</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{row}</span> /&gt;</span>\n          ))}\n        <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h3>图表数据更新</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dashboard</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [range, setRange] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;weekly&#x27;</span>);\n  <span class="hljs-keyword">const</span> deferredRange = <span class="hljs-title function_">useDeferredValue</span>(range);\n  <span class="hljs-keyword">const</span> chartData = <span class="hljs-title function_">processChartData</span>(rawData, deferredRange);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">RangeSelector</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{setRange}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">ComplexChart</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{chartData}</span> /&gt;</span> {/* 延迟更新减少动画卡顿 */}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p><code>useDeferredValue</code> 是优化React应用性能的强大工具，特别适合处理计算密集型派生状态和大型数据集渲染的场景。正确使用可以显著提升用户界面的响应速度，同时保持数据的一致性。</p>\n</div>'</script></body></html>