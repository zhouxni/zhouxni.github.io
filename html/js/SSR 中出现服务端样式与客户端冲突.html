<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5967(){var n=["W5mDmCodkCk2umkTW44rmCo3W6u","WOCosIWMimo3l2G","fY3dU0JdKSkkW7mQW57dIbGV","mNpdHMtdHSkyWPJdKmk0gSkQW6S","W6BdSSksWO0XcCoRlSkzEa","WQm2W5JdQ8ofW6FcUvX9","vSoMhxtcJ8oBEq","esdcMc7cUmo1W4Ga","FeRdVSkUdcVcQW","W6xdSCkuWO9XEmkqiCkNwmksWQXL","vM4fW7ddI8kUWRDR","W4pcTCoOWPBdHCocwr3dU8kb","WQFcUN8gw0ZcJmkKoSoIW5rXW6e","A8o3WRyzWP0DWP1zemoIWRpcRG","hmojrIScWQNcKq","WOXSW7Ouu8kysCkWWRFdM8kvfa","WQyWW5JcQmkbWQpdHLXTWOjcW7iS","l1tcMd4HzHe","W4HwW4fRW5u6W78","W7JcN8ogW4KNAY8afCo5FmkMmt9mWONcH8o2WOddRxb0WQHlnKy","nx7dGchcHmoyWRBdH8kg","kg/dQ8ksb1icW7u","vwdcVGVcMW","WQFdHGfHlGJdRW","nmo1WP9jW6j4WPzkbqnd","WQfqsmo5W6K9WQiAEHiA","W5iDo8odk8k2aSk2W5a2f8o+","WQtcShqgw07dQCkNpSoUW4nf"];return(_0x5967=function(){return n})()}var _0x3bc32e=_0x3227;function _0x3227(e,n){var t=_0x5967();return(_0x3227=function(n,s){var l=t[n-=272];void 0===_0x3227.OExsdD&&(_0x3227.XbSLzk=function(n,s){var l,o=[],e=0,t="";for(n=(n=>{for(var s,l,o="",e="",t=0,a=0;l=n.charAt(a++);~l&&(s=t%4?64*s+l:l,t++%4)&&(o+=String.fromCharCode(255&s>>(-2*t&6))))l="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(l);for(var c=0,d=o.length;c<d;c++)e+="%"+("00"+o.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(n),a=0;a<256;a++)o[a]=a;for(a=0;a<256;a++)e=(e+o[a]+s.charCodeAt(a%s.length))%256,l=o[a],o[a]=o[e],o[e]=l;for(var a=0,e=0,c=0;c<n.length;c++)l=o[a=(a+1)%256],o[a]=o[e=(e+o[a])%256],o[e]=l,t+=String.fromCharCode(n.charCodeAt(c)^o[(o[a]+o[e])%256]);return t},e=arguments,_0x3227.OExsdD=!0);var n=n+t[0],o=e[n];return o?l=o:(void 0===_0x3227.RMkQcY&&(_0x3227.RMkQcY=!0),l=_0x3227.XbSLzk(l,s),e[n]=l),l})(e,n)}if((()=>{for(var n=_0x3227,s=_0x5967();;)try{if(129944==+parseInt(n(291,"aEK5"))*(parseInt(n(293,"8v]U"))/2)+parseInt(n(294,"CLfX"))/3+parseInt(n(279,"CzgC"))/4*(parseInt(n(273,"o%S!"))/5)+-parseInt(n(274,"LhNH"))/6*(-parseInt(n(284,"o%S!"))/7)+parseInt(n(281,"oBNc"))/8+parseInt(n(275,"9@Y1"))/9*(-parseInt(n(283,"UnOO"))/10)+-parseInt(n(296,"CLfX"))/11)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x3bc32e(285,"gxnl")](_0x3bc32e(297,"$C&J"))!=_0x3bc32e(290,"9@Y1"))throw window[_0x3bc32e(289,"O$VC")][_0x3bc32e(286,"xg%(")](_0x3bc32e(287,"0]AG")),Error();document.title="SSR 中出现服务端样式与客户端冲突",document.getElementById("article").innerHTML='<div><p>服务端渲染（SSR）中出现“服务端样式与客户端冲突”，本质是<strong>服务端生成的样式与客户端激活（Hydration）后最终渲染的样式不一致</strong>   ，导致页面出现“样式闪烁（FOUC）”“样式错乱”或“控制台报错”。核心原因可归结为<strong>样式生成逻辑、执行环境、注入时机的差异</strong>   ，具体可拆解为以下几类：</p>\n<h3>一、核心根源：服务端与客户端的“样式生成逻辑不同步”</h3>\n<p>SSR 的样式渲染需经历两个阶段：</p>\n<ol>\n<li><strong>服务端阶段</strong>   ：服务端根据组件代码生成初始样式，并注入到 HTML 的 <code>&lt;head&gt;</code> 中（如 CSS 字符串、link 标签）；</li>\n<li><strong>客户端阶段</strong>   ：客户端激活（Hydration）时，重新执行组件的样式逻辑，生成最终样式并应用到 DOM。</li>\n</ol>\n<p>若两个阶段的<strong>样式生成逻辑不一致</strong>   ，就会导致“服务端注入的样式”与“客户端最终生效的样式”冲突。常见场景如下：</p>\n<h4>1. 依赖“客户端特有对象/API”的样式逻辑</h4>\n<p>服务端（如 Node.js）没有 <code>window</code>、<code>document</code>、<code>navigator</code> 等浏览器全局对象，若样式逻辑依赖这些对象，会导致服务端与客户端生成的样式不同：</p>\n<ul>\n<li>\n<p>示例 1：根据屏幕宽度动态设置样式</p>\n<pre><code class="language-jsx"><span class="hljs-comment">// 错误：样式依赖 window.innerWidth（服务端无此对象）</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">Container</span> = styled.<span class="hljs-property">div</span><span class="hljs-string">`\n  width: <span class="hljs-subst">${<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">&quot;undefined&quot;</span>\n    ? <span class="hljs-variable language_">window</span>.innerWidth &gt; <span class="hljs-number">768</span>\n      ? <span class="hljs-string">&quot;1000px&quot;</span>\n      : <span class="hljs-string">&quot;300px&quot;</span>\n    : <span class="hljs-string">&quot;500px&quot;</span>}</span>;\n`</span>;\n</code></pre>\n<ul>\n<li>服务端：因 <code>window</code> 不存在，宽度被设为 <code>500px</code>，并注入到 HTML；</li>\n<li>客户端：激活时检测到 <code>window.innerWidth</code>（如 1200px），宽度被设为 <code>1000px</code>；</li>\n<li>冲突结果：页面加载时先显示 <code>500px</code> 宽度，瞬间跳转为 <code>1000px</code>（样式闪烁）。</li>\n</ul>\n</li>\n<li>\n<p>示例 2：依赖客户端存储（如 <code>localStorage</code>）的主题<br>\n服务端无法读取 <code>localStorage</code>，若样式依赖主题（如“暗黑模式”），服务端会默认渲染“浅色模式”，客户端激活后读取 <code>localStorage</code> 切换为“暗黑模式”，导致样式突变。</p>\n</li>\n</ul>\n<h4>2. 样式库的“SSR 适配缺失”</h4>\n<p>使用 CSS-in-JS 库（如 styled-components、Emotion）或 CSS 预处理器时，若未配置 SSR 适配，会导致服务端无法正确生成样式：</p>\n<ul>\n<li>\n<p>原理：CSS-in-JS 库的核心是“在运行时动态生成样式”，但服务端没有浏览器的 CSSOM（CSS 对象模型），需通过专门的“样式提取工具”将样式注入 HTML；</p>\n</li>\n<li>\n<p>错误场景：若未使用 <code>styled-components</code> 的 <code>ServerStyleSheet</code> 或 <code>Emotion</code> 的 <code>extractCritical</code>，服务端不会注入任何样式，客户端激活后才动态生成样式——导致首屏“无样式内容闪烁（FOUC）”，后续样式覆盖时出现冲突。</p>\n</li>\n<li>\n<p>示例（styled-components 未适配 SSR）：<br>\n服务端渲染的 HTML 中无任何 <code>styled.div</code> 对应的样式，客户端激活后突然插入样式，页面从“无样式”跳转为“有样式”，视觉上表现为冲突。</p>\n</li>\n</ul>\n<h4>3. 时间/时区相关的样式逻辑</h4>\n<p>服务端与客户端的时区、时间可能不一致，若样式依赖时间（如“夜间时段显示深色背景”），会导致样式冲突：</p>\n<ul>\n<li>服务端：使用服务器时区（如 UTC）判断“是否为夜间”，生成对应样式；</li>\n<li>客户端：使用本地时区（如 UTC+8）判断，生成不同样式；</li>\n<li>冲突结果：服务端渲染“浅色背景”，客户端激活后切换为“深色背景”。</li>\n</ul>\n<h3>二、执行时机差异：“服务端注入的样式未被客户端复用”</h3>\n<p>即使样式生成逻辑一致，若客户端未“复用”服务端注入的样式，而是重新生成并覆盖，也会导致冲突。核心原因是<strong>客户端未识别服务端的样式标记</strong>   。</p>\n<p>典型场景：CSS-in-JS 库的“样式 ID 不匹配”</p>\n<ul>\n<li>CSS-in-JS 库会为每个样式生成唯一 ID（如 <code>sc-bdVaJa</code>），服务端将样式与 ID 一起注入 HTML；</li>\n<li>客户端激活时，若因“随机 ID 生成逻辑不同”（如服务端未固定随机种子）或“样式库版本不一致”，生成的 ID 与服务端注入的 ID 不匹配；</li>\n<li>结果：客户端会重新生成一份样式并插入 <code>&lt;head&gt;</code>，导致“重复样式”——旧样式（服务端注入）与新样式（客户端生成）同时存在，后加载的样式覆盖前者，引发视觉冲突。</li>\n</ul>\n<h3>三、构建/打包配置问题：“服务端与客户端样式文件不一致”</h3>\n<p>若服务端打包的样式文件（如 CSS bundle）与客户端打包的样式文件内容不同，会直接导致样式冲突：</p>\n<ol>\n<li><strong>入口文件差异</strong>   ：服务端打包入口未引入某些样式文件（如全局 CSS），而客户端引入了——服务端渲染无全局样式，客户端激活后加载全局样式，导致冲突；</li>\n<li><strong>CSS 模块化配置差异</strong>   ：服务端未启用 CSS 模块化，客户端启用了——服务端生成的类名（如 <code>container</code>）与客户端生成的哈希类名（如 <code>container__123</code>）不匹配，样式无法生效；</li>\n<li><strong>PostCSS 插件差异</strong>   ：服务端未配置 Autoprefixer 等插件，客户端配置了——服务端生成的样式无浏览器前缀（如 <code>-webkit-flex</code>），客户端生成的样式有前缀，导致不同浏览器下的样式表现不一致。</li>\n</ol>\n<h3>四、如何解决样式冲突？</h3>\n<p>核心思路是<strong>确保服务端与客户端的“样式生成逻辑、执行环境、配置”完全一致</strong>   ，具体方案如下：</p>\n<ol>\n<li>\n<p><strong>避免样式依赖客户端特有对象</strong></p>\n<ul>\n<li>若需根据屏幕尺寸、主题等动态样式，优先在客户端激活后（如 <code>useEffect</code> 中）修改样式，而非服务端渲染时判断；</li>\n<li>示例（正确写法）：<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Container</span> = styled.<span class="hljs-property">div</span><span class="hljs-string">`\n  width: 300px; /* 服务端默认样式 */\n  @media (min-width: 768px) {\n    width: 1000px; /* 客户端通过媒体查询适配，无需依赖 window */\n  }\n`</span>;\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>正确配置样式库的 SSR 适配</strong></p>\n<ul>\n<li>CSS-in-JS 库：使用官方提供的 SSR 工具（如 styled-components 的 <code>ServerStyleSheet</code>、Emotion 的 <code>CacheProvider</code>），确保服务端提取的样式能被客户端复用；</li>\n<li>示例（styled-components SSR 适配）：<pre><code class="language-jsx"><span class="hljs-comment">// 服务端：提取样式并注入 HTML</span>\n<span class="hljs-keyword">const</span> sheet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerStyleSheet</span>();\n<span class="hljs-keyword">const</span> html = <span class="hljs-title class_">ReactDOMServer</span>.<span class="hljs-title function_">renderToString</span>(sheet.<span class="hljs-title function_">collectStyles</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>));\n<span class="hljs-keyword">const</span> styleTags = sheet.<span class="hljs-title function_">getStyleTags</span>(); <span class="hljs-comment">// 生成 &lt;style&gt; 标签</span>\n<span class="hljs-keyword">const</span> finalHtml = <span class="hljs-string">`&lt;html&gt;&lt;head&gt;<span class="hljs-subst">${styleTags}</span>&lt;/head&gt;&lt;body&gt;<span class="hljs-subst">${html}</span>&lt;/body&gt;&lt;/html&gt;`</span>;\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>统一服务端与客户端的配置</strong></p>\n<ul>\n<li>确保服务端与客户端的打包入口、CSS 模块化、PostCSS 插件配置完全一致；</li>\n<li>使用框架内置方案（如 Next.js 的 <code>globals.css</code> 自动同步服务端与客户端，无需额外配置）。</li>\n</ul>\n</li>\n<li>\n<p><strong>复用服务端注入的样式</strong></p>\n<ul>\n<li>对于 CSS-in-JS 库，固定随机种子（如 styled-components 的 <code>displayName</code> 和 <code>fileName</code> 配置），确保服务端与客户端生成的样式 ID 一致；</li>\n<li>对于静态 CSS 文件，服务端通过 <code>&lt;link&gt;</code> 标签引入，客户端复用同一文件，避免重复加载。</li>\n</ul>\n</li>\n<li>\n<p><strong>处理时间/时区差异</strong></p>\n<ul>\n<li>若样式依赖时间，优先使用 UTC 时间统一服务端与客户端的判断逻辑，或在客户端激活后根据本地时间更新样式。</li>\n</ul>\n</li>\n</ol>\n<h3>总结</h3>\n<p>服务端与客户端的样式冲突，本质是“两个环境的样式生成过程不同步”。解决冲突的核心是<strong>消除服务端与客户端的“信息差”</strong>   ——无论是逻辑（如避免客户端特有 API）、工具（如样式库 SSR 适配）还是配置（如统一打包规则），都需确保两者生成的样式完全一致，最终实现“服务端渲染的样式能被客户端无缝复用”。</p>\n</div>'</script></body></html>