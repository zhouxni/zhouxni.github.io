<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x42db5b=_0x4c71;function _0x4c71(t,s){var p=_0x3fff();return(_0x4c71=function(s,n){var a=p[s-=184];void 0===_0x4c71.BsFxnn&&(_0x4c71.OCmFYW=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=l.length;c<r;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[t],l[t]=a;for(var e=0,t=0,c=0;c<s.length;c++)a=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[t])%256]);return p},t=arguments,_0x4c71.BsFxnn=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x4c71.rPjwtu&&(_0x4c71.rPjwtu=!0),a=_0x4c71.OCmFYW(a,n),t[s]=a),a})(t,s)}function _0x3fff(){var s=["WQnzWRT6WOxcG8ot","W4DQlmksWPlcLY/cN8o3","m8oQW6RcV8o9WR13WOGIqqW","WQKhoaTiW6JcSSkV","FqjPWQ5iW6qQW7DnWRRdPg/cQq","umopWQ7cN8o+smozcv0","W7SkW4ddHtJdPmo8q8kS","jLdcGf3cLb7cHgelAmojBq","mSoQW67cVSo6WRnMWOectHi","h8kjW5zXWQhdUCkDW5SXW4XGWOzQ","fSkoW5r+WQpcVCotW5GOW7zu","WPnEdJq0lCkL","WP4NnK/cKSoVW43cRCkHWRX7hCo7W5ZdTmoJyNu2neq7W6ZcQWrt","W4ajeXa5pCk8eq","W6VcGSoQnG3cSbJcJa","W79TWP/dRJFdUCof","BxtcTeRdNgldICoCWPDXFCkaaG","sSophmonW4bgWQVcTa","eWHYW7GknmksWPm","W5/dLSk0j3S+W5SoW5a","cSkkWO1cpCksW53cLbrJW7C","EavPWQLiWRPrW5n8WRBdJG","WR14W4q7FNmUl3W","pmkUueu3W4bOhMqHw2y","WPtdP8kfW6tdJZJcTa","dqjHW7uFpSky","WPRcIb9xo8o6WRK","kvhcGLlcN1tcQhSgFSo3","W7u+WOu+rq","W4DOjmoOW4/dJK/cUmobWRVcNxxdSG"];return(_0x3fff=function(){return s})()}if((()=>{for(var s=_0x4c71,n=_0x3fff();;)try{if(124318==+parseInt(s(211,"81NY"))*(-parseInt(s(205,"0M3B"))/2)+parseInt(s(196,"0M3B"))/3*(parseInt(s(212,"#r)e"))/4)+-parseInt(s(200,"10ku"))/5*(-parseInt(s(203,"4zet"))/6)+parseInt(s(199,"10ku"))/7+parseInt(s(187,"B6CB"))/8*(parseInt(s(184,"q)qQ"))/9)+-parseInt(s(197,"B6CB"))/10*(-parseInt(s(193,"ZaRp"))/11)+-parseInt(s(189,"%#oq"))/12)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x42db5b(201,"4zet")](_0x42db5b(209,"U(3Z"))!=_0x42db5b(188,"#r)e"))throw window[_0x42db5b(208,"OKLI")][_0x42db5b(185,"OKLI")](_0x42db5b(202,"BKbq")),Error();document.title="观察者模式 vs 发布订阅模式",document.getElementById("article").innerHTML='<div><p>观察者模式和发布订阅模式都是用于处理对象间通信的设计模式，但它们有一些关键区别：</p>\n<h2>观察者模式 (Observer Pattern)</h2>\n<p><strong>特点</strong>  ：</p>\n<ul>\n<li>直接通信：观察者直接订阅主题(Subject)，主题维护观察者列表</li>\n<li>强耦合：观察者知道主题的存在，主题也知道观察者的存在</li>\n<li>同步触发：当主题状态变化时，直接调用观察者的方法</li>\n</ul>\n<p><strong>示例代码</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = [];\n  }\n  \n  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">observer</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">push</span>(observer);\n  }\n  \n  <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params">observer</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">obs</span> =&gt;</span> obs !== observer);\n  }\n  \n  <span class="hljs-title function_">notify</span>(<span class="hljs-params">data</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.<span class="hljs-title function_">update</span>(data));\n  }\n}\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> {\n  <span class="hljs-title function_">update</span>(<span class="hljs-params">data</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Observer received:&#x27;</span>, data);\n  }\n}\n\n<span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>();\n<span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>();\n\nsubject.<span class="hljs-title function_">subscribe</span>(observer);\nsubject.<span class="hljs-title function_">notify</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>); <span class="hljs-comment">// Observer received: Hello!</span>\n</code></pre>\n<h2>发布订阅模式 (Pub/Sub Pattern)</h2>\n<p><strong>特点</strong>  ：</p>\n<ul>\n<li>间接通信：通过事件通道/消息代理，发布者和订阅者彼此不知道对方</li>\n<li>松耦合：发布者和订阅者不直接交互</li>\n<li>可以异步处理：消息队列可以支持异步处理</li>\n</ul>\n<p><strong>示例代码</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PubSub</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = {};\n  }\n  \n  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">event, callback</span>) {\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = [];\n    }\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">push</span>(callback);\n  }\n  \n  <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params">event, callback</span>) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb !== callback);\n    }\n  }\n  \n  <span class="hljs-title function_">publish</span>(<span class="hljs-params">event, data</span>) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>(data));\n    }\n  }\n}\n\n<span class="hljs-keyword">const</span> pubsub = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PubSub</span>();\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">callback</span> = data =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received:&#x27;</span>, data);\n\npubsub.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;message&#x27;</span>, callback);\npubsub.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-string">&#x27;Hello!&#x27;</span>); <span class="hljs-comment">// Received: Hello!</span>\n</code></pre>\n<h2>主要区别</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>观察者模式</th>\n<th>发布订阅模式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>耦合度</td>\n<td>强耦合（直接依赖）</td>\n<td>松耦合（通过中介）</td>\n</tr>\n<tr>\n<td>通信方式</td>\n<td>直接调用观察者方法</td>\n<td>通过事件通道传递消息</td>\n</tr>\n<tr>\n<td>关系</td>\n<td>主题知道观察者</td>\n<td>发布者不知道订阅者</td>\n</tr>\n<tr>\n<td>灵活性</td>\n<td>较低</td>\n<td>更高（支持多种事件类型）</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>通常更快（直接调用）</td>\n<td>可能稍慢（需要查找事件）</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>对象间直接通知</td>\n<td>需要解耦的复杂系统</td>\n</tr>\n</tbody>\n</table>\n<h2>何时使用</h2>\n<ul>\n<li><strong>观察者模式</strong>  ：当对象间的关系是一对多，且需要直接、明确的通信时</li>\n<li><strong>发布订阅模式</strong>  ：当需要完全解耦组件，或需要支持多种事件类型和异步处理时</li>\n</ul>\n<p>在实际开发中，JavaScript的EventEmitter、Vue的响应式系统等通常使用发布订阅模式，而一些简单的状态管理可能使用观察者模式。</p>\n</div>'</script></body></html>