<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x498b(){var n=["WOJcO8kMmmoDe1WMWOztkCkI","W7JcM8kfvSoKW57dLCkloW","WOFcQSo5W77cUComCfnP","DCo+geeUW6pcIaPRea","e8k1n8okcK5l","WODrm3FcT15bWPW","WOFdMdtdHmonW4hdHq","AsVcNvBcIColkIu2WRi0WRuNW68","W5RdTmo0bSkYW6aDW4JcVSoOCSokbCo0","W4/dOSoSESks","W73cMCkdlSkyWQxcPmkmfr/cVblcUa","cmkYWRfbWOtdOMhdVa","fvugh8oBaYe","W7NcKmkalSkEWQdcPmkHjIRcLXxcIa","t0GXamoevL1xW7OZWR9Ka39+WRZcKCo/WRBdGtyvWQJdNmksWPi","W6JcQxldVmoLdCo1Fa","juyNW5xcG8k/WR7dGftcOW","WOn1FCoHWRxcGSkk","W6FcH8kCeda7W7FdMmo/","WRBdSsJcRCkJkSoEqmk3WRDl","p3JdPCkGW67dN8kIymounGnFW74","W7efE3RdVL3dH2JcLt1ZWR0","WRufW6dcUdxdUMhcKJlcP8k+W40I","WRZdISkcp8osn8kAzhNdUWJdRa","WRHeWRCuW5ddNmkup8kRWPqT","BCkCWRZdPtjjpGLPW4i","WQ3dHvulWO7dJSoxWQldL8ku","FJvSWRdcPILUFu7dQLZdIG"];return(_0x498b=function(){return n})()}var _0x4dd5b4=_0x5677;function _0x5677(d,n){var a=_0x498b();return(_0x5677=function(n,t){var s=a[n-=251];void 0===_0x5677.lYBjAN&&(_0x5677.khvUbL=function(n,t){var s,o=[],d=0,a="";for(n=(n=>{for(var t,s,o="",d="",a=0,r=0;s=n.charAt(r++);~s&&(t=a%4?64*t+s:s,a++%4)&&(o+=String.fromCharCode(255&t>>(-2*a&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var l=0,e=o.length;l<e;l++)d+="%"+("00"+o.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(d)})(n),r=0;r<256;r++)o[r]=r;for(r=0;r<256;r++)d=(d+o[r]+t.charCodeAt(r%t.length))%256,s=o[r],o[r]=o[d],o[d]=s;for(var r=0,d=0,l=0;l<n.length;l++)s=o[r=(r+1)%256],o[r]=o[d=(d+o[r])%256],o[d]=s,a+=String.fromCharCode(n.charCodeAt(l)^o[(o[r]+o[d])%256]);return a},d=arguments,_0x5677.lYBjAN=!0);var n=n+a[0],o=d[n];return o?s=o:(void 0===_0x5677.kZUDJB&&(_0x5677.kZUDJB=!0),s=_0x5677.khvUbL(s,t),d[n]=s),s})(d,n)}if((()=>{for(var n=_0x5677,t=_0x498b();;)try{if(410867==-parseInt(n(262,"qR#^"))*(-parseInt(n(274,"Pti3"))/2)+-parseInt(n(265,"TU$J"))/3*(-parseInt(n(260,"1]4e"))/4)+-parseInt(n(254,"e!Hb"))/5+parseInt(n(252,"6n)O"))/6*(-parseInt(n(258,"dsoc"))/7)+-parseInt(n(261,"[]o&"))/8*(parseInt(n(267,"tgqn"))/9)+-parseInt(n(256,"g3(1"))/10+parseInt(n(270,"kMDB"))/11)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x4dd5b4(266,"3peT")](_0x4dd5b4(264,"&EwU"))!=_0x4dd5b4(271,"qR#^"))throw window[_0x4dd5b4(277,"lYCv")][_0x4dd5b4(268,"w3tR")](_0x4dd5b4(276,"Pti3")),Error();document.title=" JavaScript 中，栈内存 和 堆内存 ",document.getElementById("article").innerHTML='<div><p>在 JavaScript 中，<strong>栈内存（Stack Memory）</strong>   和 <strong>堆内存（Heap Memory）</strong>   是两种不同的内存管理机制，它们分别用来存储不同类型的数据，对 <strong>变量的存储方式、生命周期、访问速度</strong>   都有重要影响。</p>\n<hr>\n<h2>一、什么是栈内存和堆内存？</h2>\n<h3>✅ 栈内存（Stack Memory）</h3>\n<ul>\n<li>是一种 <strong>后进先出（LIFO）</strong>   的数据结构，由系统自动分配和释放</li>\n<li>用来存储 <strong>基本数据类型</strong>   的值 以及 <strong>变量引用地址（指针）</strong></li>\n<li><strong>访问速度快，空间有限，大小固定</strong></li>\n<li>内存分配与释放由系统自动管理（比如函数调用时的栈帧）</li>\n</ul>\n<h3>✅ 堆内存（Heap Memory）</h3>\n<ul>\n<li>是一种 <strong>动态分配的内存区域</strong>   ，结构复杂、不规则</li>\n<li>用来存储 <strong>引用数据类型（对象、数组、函数等）的实际内容</strong></li>\n<li><strong>空间大，但分配和回收相对较慢，需要垃圾回收机制管理</strong></li>\n<li>变量保存的是指向堆内存中数据的 <strong>引用（地址）</strong></li>\n</ul>\n<hr>\n<h2>二、JavaScript 的数据类型与存储位置</h2>\n<h3>1. 基本数据类型（原始类型 / Primitive Types）</h3>\n<p>这些数据直接存储在 <strong>栈内存</strong>   中（或栈中存储其值）：</p>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>说明</th>\n<th>存储位置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>number</code></td>\n<td>数字，如 <code>10</code>, <code>3.14</code></td>\n<td>栈</td>\n</tr>\n<tr>\n<td><code>string</code></td>\n<td>字符串，如 <code>&quot;hello&quot;</code></td>\n<td>栈</td>\n</tr>\n<tr>\n<td><code>boolean</code></td>\n<td>布尔值，如 <code>true/false</code></td>\n<td>栈</td>\n</tr>\n<tr>\n<td><code>undefined</code></td>\n<td>未定义</td>\n<td>栈</td>\n</tr>\n<tr>\n<td><code>null</code></td>\n<td>空值（历史遗留问题，实际是对象类型指针为 null）</td>\n<td>栈</td>\n</tr>\n<tr>\n<td><code>symbol</code></td>\n<td>ES6 引入的唯一标识符</td>\n<td>栈</td>\n</tr>\n<tr>\n<td><code>bigint</code></td>\n<td>大整数，如 <code>100n</code></td>\n<td>栈</td>\n</tr>\n</tbody>\n</table>\n<p>✅ <strong>特点：</strong></p>\n<ul>\n<li>直接存储 <strong>值本身</strong></li>\n<li>占用空间固定、较小</li>\n<li>按值访问、按值传递</li>\n</ul>\n<hr>\n<h3>2. 引用数据类型（Reference Types）</h3>\n<p>这些数据的 <strong>值存储在堆内存</strong>   中，而 <strong>变量本身存储的是指向堆内存的引用地址（指针）</strong>   ，这个引用地址存在 <strong>栈内存</strong>   中。</p>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>说明</th>\n<th>值存储位置</th>\n<th>引用（地址）存储位置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>object</code></td>\n<td>普通对象 <code>{}</code></td>\n<td>堆</td>\n<td>栈</td>\n</tr>\n<tr>\n<td><code>array</code></td>\n<td>数组 <code>[1, 2, 3]</code></td>\n<td>堆</td>\n<td>栈</td>\n</tr>\n<tr>\n<td><code>function</code></td>\n<td>函数</td>\n<td>堆</td>\n<td>栈</td>\n</tr>\n<tr>\n<td><code>Date</code>, <code>RegExp</code> 等内置对象</td>\n<td>也是对象</td>\n<td>堆</td>\n<td>栈</td>\n</tr>\n</tbody>\n</table>\n<p>✅ <strong>特点：</strong></p>\n<ul>\n<li>变量保存的是一个 <strong>内存地址（指针）</strong>   ，指向堆中的实际数据</li>\n<li>数据大小不固定，可能很大，适合存在堆中</li>\n<li>按引用访问、按引用传递（浅拷贝问题与此相关）</li>\n</ul>\n<hr>\n<h2>三、栈内存 vs 堆内存 对比表</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>栈内存（Stack）</th>\n<th>堆内存（Heap）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>存储内容</strong></td>\n<td>基本数据类型的值、变量引用地址（指针）</td>\n<td>引用数据类型（对象、数组、函数等）的实际内容</td>\n</tr>\n<tr>\n<td><strong>内存分配方式</strong></td>\n<td>自动分配和释放（比如函数调用栈帧）</td>\n<td>动态分配，需要垃圾回收机制管理</td>\n</tr>\n<tr>\n<td><strong>访问速度</strong></td>\n<td>快（直接定位）</td>\n<td>相对慢（要通过引用地址间接访问）</td>\n</tr>\n<tr>\n<td><strong>空间大小</strong></td>\n<td>较小、固定</td>\n<td>较大、灵活</td>\n</tr>\n<tr>\n<td><strong>数据大小</strong></td>\n<td>固定（比如 number 是 8 字节）</td>\n<td>不固定（对象可能很大）</td>\n</tr>\n<tr>\n<td><strong>生命周期</strong></td>\n<td>函数执行结束一般自动释放</td>\n<td>由垃圾回收器决定何时回收</td>\n</tr>\n<tr>\n<td><strong>是否手动管理</strong></td>\n<td>否（自动）</td>\n<td>否（由 JS 引擎 GC 管理）</td>\n</tr>\n<tr>\n<td><strong>典型例子</strong></td>\n<td><code>let a = 10;</code> （值存在栈）</td>\n<td><code>let obj = { name: \'Tom\' };</code> （对象在堆，变量 obj 在栈存地址）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>四、示例分析</h2>\n<h3>✅ 示例 1：基本类型 —— 栈内存存储值</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;\n<span class="hljs-keyword">let</span> b = a; <span class="hljs-comment">// b 得到的是 a 的值（10），是拷贝</span>\n\nb = <span class="hljs-number">20</span>;\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 10，a 不受影响</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 20</span>\n</code></pre>\n<p>🔍 <strong>说明：</strong></p>\n<ul>\n<li><code>a</code> 和 <code>b</code> 都是基本类型（number），它们的值直接存在 <strong>栈内存</strong></li>\n<li>当你执行 <code>b = a</code> 时，是 <strong>值的拷贝</strong>   ，两者互不影响</li>\n</ul>\n<hr>\n<h3>✅ 示例 2：引用类型 —— 栈存引用，堆存实际对象</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> obj1 = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> };\n<span class="hljs-keyword">let</span> obj2 = obj1; <span class="hljs-comment">// obj2 和 obj1 指向同一个堆内存对象</span>\n\nobj2.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Bob&quot;</span>;\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;Bob&#x27;，因为 obj1 和 obj2 指向同一个对象</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;Bob&#x27;</span>\n</code></pre>\n<p>🔍 <strong>说明：</strong></p>\n<ul>\n<li><code>obj1</code> 是一个对象，其 <strong>实际数据（{ name: \'Alice\' }）存储在堆内存</strong></li>\n<li>变量 <code>obj1</code> 本身只是保存了一个 <strong>指向堆内存的地址（指针），这个地址存在栈内存</strong></li>\n<li>当你执行 <code>obj2 = obj1</code> 时，是 <strong>地址的拷贝</strong>   ，所以 <code>obj1</code> 和 <code>obj2</code> 指向的是同一个对象</li>\n<li>修改其中一个，另一个也会受影响（浅拷贝问题）</li>\n</ul>\n<hr>\n<h2>五、函数调用与栈内存（调用栈 / 执行上下文栈）</h2>\n<p>JavaScript 是单线程的，函数调用时会形成一个 <strong>调用栈（Call Stack）</strong>   ，用于管理函数的执行顺序和局部变量。</p>\n<h3>✅ 示例：函数调用时的栈帧</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>; <span class="hljs-comment">// x 存储在栈内存中</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-title function_">foo</span>();\n}\n\n<span class="hljs-title function_">bar</span>();\n</code></pre>\n<p>🔍 <strong>说明：</strong></p>\n<ul>\n<li>当 <code>bar()</code> 被调用，它入栈</li>\n<li>然后 <code>foo()</code> 被调用，也入栈</li>\n<li>每个函数都有自己的 <strong>执行上下文</strong>   ，其中的局部变量（比如 <code>x</code>）存放在 <strong>栈帧</strong>   中</li>\n<li>函数执行完，对应的栈帧出栈、释放内存</li>\n</ul>\n<hr>\n<h2>六、垃圾回收（Garbage Collection）与堆内存</h2>\n<p>JavaScript 有自动垃圾回收机制，主要针对 <strong>堆内存</strong>   ：</p>\n<ul>\n<li>当一个对象 <strong>没有任何变量引用它时</strong>   （即没有指针指向它了），它就成为了 <strong>垃圾</strong></li>\n<li>垃圾回收器（GC）会在合适的时机自动清理这些无用的堆内存，释放空间</li>\n</ul>\n<p>🔍 <strong>示例：</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Tom&quot;</span> }; <span class="hljs-comment">// 对象在堆中，obj 变量在栈中保存引用地址</span>\n\nobj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 现在堆中的 { name: &#x27;Tom&#x27; } 没有被任何变量引用了，会被 GC 回收</span>\n</code></pre>\n<hr>\n<h2>七、总结一句话</h2>\n<blockquote>\n<p><strong>栈内存存放基本数据类型的值和引用地址，访问快、自动管理；堆内存存放引用类型（对象/数组等）的实际内容，空间大但需要垃圾回收。</strong></p>\n</blockquote>\n<hr>\n<h2>✅ 对比总结表（简洁版）</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>栈内存（Stack）</th>\n<th>堆内存（Heap）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>存储内容</td>\n<td>基本类型值、变量引用地址</td>\n<td>引用类型的实际数据（对象、数组等）</td>\n</tr>\n<tr>\n<td>存取方式</td>\n<td>直接存取</td>\n<td>通过引用地址（指针）间接存取</td>\n</tr>\n<tr>\n<td>大小</td>\n<td>较小、固定</td>\n<td>较大、动态</td>\n</tr>\n<tr>\n<td>分配与释放</td>\n<td>自动（函数调用栈管理）</td>\n<td>动态分配，由垃圾回收器管理</td>\n</tr>\n<tr>\n<td>访问速度</td>\n<td>快</td>\n<td>相对慢</td>\n</tr>\n<tr>\n<td>典型例子</td>\n<td><code>let a = 10;</code></td>\n<td><code>let obj = { name: \'Tom\' };</code></td>\n</tr>\n<tr>\n<td>是否可共享</td>\n<td>每个变量独立</td>\n<td>多个变量可引用同一个堆对象</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>🧠 拓展知识（进阶）</h2>\n<ul>\n<li><strong>闭包</strong>   ：函数中引用了外部变量，可能导致相关栈/堆内存长期不被释放</li>\n<li><strong>内存泄漏</strong>   ：比如意外的全局变量、未清理的定时器、未移除的事件监听，导致堆内存无法被回收</li>\n<li><strong>深拷贝 vs 浅拷贝</strong>   ：和堆内存中对象的引用机制密切相关</li>\n</ul>\n<hr>\n<p>🎯 <strong>如果你想深入了解：闭包与内存、垃圾回收机制、如何避免内存泄漏、深拷贝实现等，我也可以继续为你讲解！</strong></p>\n</div>'</script></body></html>