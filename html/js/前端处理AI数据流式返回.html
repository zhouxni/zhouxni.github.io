<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x106f9a=_0x3288;function _0x3288(p,s){var t=_0x30d3();return(_0x3288=function(s,n){var a=t[s-=392];void 0===_0x3288.jevgCp&&(_0x3288.xhVbye=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,e=0;a=s.charAt(e++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=l.length;c<o;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[p],l[p]=a;for(var e=0,p=0,c=0;c<s.length;c++)a=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[p])%256]);return t},p=arguments,_0x3288.jevgCp=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x3288.vVlYBT&&(_0x3288.vVlYBT=!0),a=_0x3288.xhVbye(a,n),p[s]=a),a})(p,s)}function _0x30d3(){var s=["WOdcPa0HW5yKWOlcTSoQ","lSknCsZdKeVcSG","kmkmzCoWeMBdGcXAsw3dPG","eL7cG28dkSot","BSoNW7fPlCkYg8oOWQTxyCkdW5G","eq/dMYHKF8kKCIaTAW/dTq","gwtcHaBdSmk7W6yrFZ0","ghv8W7Sxz8kGWP8","bG41WODbW6euW6nUFHu","WQmcj8ouW4iquCoMfmoygmo1","zmoig8o0mM7dSeiz","W61bfr/cGZX+W5m","WOf4WR4DE8o+CfO","W53dSmozW4fVWOhdHSkWW43dHcZdHq","WRzDWQ3cG27dRX4","bmo7aq8bg2C","dSkXWOv7jwJdIelcKSkUsmkPwq","mSo3WOVcNSoLDgPCW5O5mG","WPNdV8oqkJqoWR0CW7KxoSoEW7S","rSosW5ldPMpcJmoCWQRcHKy","W7WlW6ZdNdVcVahdR1BcVmoQwG","AmoNW7StsCo9t8oNWRy","W45oWQuCnwpdOmkjrWS","WQWoW6tdPmkerSomirbpw8kUWRfgWRyGWQ/dOmk+WRVdLMLiaCkPWPe","W4rmWO3cIKa","cCkYWOT/rtRcKvZcVCkh"];return(_0x30d3=function(){return s})()}if((()=>{for(var s=_0x3288,n=_0x30d3();;)try{if(116908==+parseInt(s(410,"TkIx"))*(parseInt(s(414,"%bDl"))/2)+-parseInt(s(403,"qY2G"))/3*(-parseInt(s(407,"MBkZ"))/4)+-parseInt(s(408,"BZM3"))/5+parseInt(s(404,"8oFY"))/6+-parseInt(s(416,"Fn7@"))/7*(-parseInt(s(401,"^arM"))/8)+parseInt(s(413,"1s!U"))/9+-parseInt(s(399,"Fn7@"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x106f9a(396,"ytJQ")](_0x106f9a(395,")nMN"))!=_0x106f9a(393,"&&1N"))throw window[_0x106f9a(406,"V((8")][_0x106f9a(409,"GPO7")](_0x106f9a(392,"lzli")),Error();document.title="前端处理AI数据流式返回",document.getElementById("article").innerHTML='<div><p>前端处理AI数据流式返回的核心是实时接收、解析增量数据，并动态更新页面，以模拟“边生成边展示”的效果，提升用户体验。以下是具体实现方式和关键细节：</p>\n<h3>一、核心原理：基于流式传输协议</h3>\n<p>AI流式返回依赖 <strong>HTTP分块传输（Chunked Encoding）</strong>   或 <strong>WebSocket全双工通信</strong>   ，后端将数据拆分为多个“块”（chunk）逐次发送，前端通过监听数据“增量”持续处理。</p>\n<h3>二、前端接收流式数据的3种主流方式</h3>\n<h4>1. Fetch API（推荐，现代浏览器支持）</h4>\n<p>利用<code>response.body</code>的<code>ReadableStream</code>接口，直接读取流式数据，适合单次请求的流式场景（如生成文本、代码）。</p>\n<p><strong>实现步骤：</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleStream</span>(<span class="hljs-params">prompt</span>) {\n  <span class="hljs-comment">// 1. 发起请求，指定接收流式响应</span>\n  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/ai-stream&quot;</span>, {\n    <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,\n    <span class="hljs-attr">headers</span>: { <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span> },\n    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ prompt }),\n  });\n\n  <span class="hljs-comment">// 2. 检查是否支持流式响应</span>\n  <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">body</span>) {\n    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;浏览器不支持流式传输&quot;</span>);\n    <span class="hljs-keyword">return</span>;\n  }\n\n  <span class="hljs-comment">// 3. 解析流式数据（核心）</span>\n  <span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>(); <span class="hljs-comment">// 获取读取器</span>\n  <span class="hljs-keyword">const</span> decoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>(<span class="hljs-string">&quot;utf-8&quot;</span>); <span class="hljs-comment">// 解码二进制数据</span>\n  <span class="hljs-keyword">let</span> fullContent = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 存储完整内容</span>\n\n  <span class="hljs-comment">// 4. 循环读取数据块</span>\n  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n    <span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>(); <span class="hljs-comment">// 读取一个块</span>\n    <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 传输结束，退出循环</span>\n\n    <span class="hljs-comment">// 5. 解码当前块并拼接</span>\n    <span class="hljs-keyword">const</span> chunk = decoder.<span class="hljs-title function_">decode</span>(value, { <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span> }); <span class="hljs-comment">// 保留后续数据的解码状态</span>\n    fullContent += chunk;\n\n    <span class="hljs-comment">// 6. 实时更新页面（关键：每次获取新内容就刷新UI）</span>\n    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;ai-output&quot;</span>).<span class="hljs-property">innerText</span> = fullContent;\n    <span class="hljs-comment">// 优化：自动滚动到最新内容</span>\n    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;ai-output&quot;</span>).<span class="hljs-property">scrollTop</span> =\n      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;ai-output&quot;</span>).<span class="hljs-property">scrollHeight</span>;\n  }\n\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;流式传输完成，完整内容：&quot;</span>, fullContent);\n}\n</code></pre>\n<h4>2. WebSocket（适合持续交互场景）</h4>\n<p>全双工通信，可双向实时传输，适合需要频繁交互的场景（如聊天机器人、实时问答）。</p>\n<p><strong>实现步骤：</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 1. 建立WebSocket连接</span>\n<span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://your-server.com/ws/ai-stream&quot;</span>);\n\n<span class="hljs-comment">// 2. 发送用户输入</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">sendPrompt</span>(<span class="hljs-params">prompt</span>) {\n  socket.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ prompt }));\n}\n\n<span class="hljs-comment">// 3. 监听流式返回数据</span>\n<span class="hljs-keyword">let</span> fullContent = <span class="hljs-string">&quot;&quot;</span>;\nsocket.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-comment">// 接收单个数据块（后端通常返回JSON格式，如{ content: &quot;xxx&quot;, finished: false }）</span>\n  <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(event.<span class="hljs-property">data</span>);\n\n  <span class="hljs-comment">// 拼接内容并更新页面</span>\n  fullContent += data.<span class="hljs-property">content</span>;\n  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;ai-output&quot;</span>).<span class="hljs-property">innerText</span> = fullContent;\n\n  <span class="hljs-comment">// 若传输结束，关闭连接（可选）</span>\n  <span class="hljs-keyword">if</span> (data.<span class="hljs-property">finished</span>) {\n    socket.<span class="hljs-title function_">close</span>();\n  }\n};\n\n<span class="hljs-comment">// 4. 处理错误和关闭事件</span>\nsocket.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;WebSocket错误：&quot;</span>, error);\nsocket.<span class="hljs-property">onclose</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;流式传输结束&quot;</span>);\n</code></pre>\n<h4>3. XMLHttpRequest（兼容旧浏览器，不推荐）</h4>\n<p>通过<code>progress</code>事件监听增量数据，但功能有限，适合需兼容IE等旧环境的场景。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();\nxhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;/api/ai-stream&quot;</span>);\nxhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);\n\n<span class="hljs-keyword">let</span> fullContent = <span class="hljs-string">&quot;&quot;</span>;\n\n<span class="hljs-comment">// 监听进度事件（接收增量数据）</span>\nxhr.<span class="hljs-property">onprogress</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {\n  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">lengthComputable</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 流式数据通常不计算总长度</span>\n  <span class="hljs-comment">// 从响应中截取新增内容（需处理已有内容的重复问题）</span>\n  <span class="hljs-keyword">const</span> newContent = xhr.<span class="hljs-property">responseText</span>.<span class="hljs-title function_">slice</span>(fullContent.<span class="hljs-property">length</span>);\n  fullContent += newContent;\n  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;ai-output&quot;</span>).<span class="hljs-property">innerText</span> = fullContent;\n};\n\nxhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">prompt</span>: <span class="hljs-string">&quot;你的问题&quot;</span> }));\n</code></pre>\n<h3>三、解析与渲染：处理不同格式的流式数据</h3>\n<h4>1. 文本/纯字符串流式（最常见）</h4>\n<p>直接拼接增量文本，实时更新DOM：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 每次收到chunk后，追加到页面</span>\n<span class="hljs-keyword">const</span> outputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;ai-output&quot;</span>);\noutputEl.<span class="hljs-property">innerText</span> += chunk; <span class="hljs-comment">// 或用textContent（更安全）</span>\n</code></pre>\n<h4>2. JSON格式流式（带元信息）</h4>\n<p>后端可能返回结构化数据（如<code>{ chunk: &quot;xxx&quot;, type: &quot;text&quot;, finished: false }</code>），需先解析单块JSON：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 假设每个chunk是独立的JSON字符串</span>\n<span class="hljs-keyword">const</span> chunkData = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(chunk);\nfullContent += chunkData.<span class="hljs-property">chunk</span>;\n<span class="hljs-comment">// 若包含类型标识（如代码块），可针对性渲染</span>\n<span class="hljs-keyword">if</span> (chunkData.<span class="hljs-property">type</span> === <span class="hljs-string">&quot;code&quot;</span>) {\n  outputEl.<span class="hljs-property">innerHTML</span> += <span class="hljs-string">`&lt;pre&gt;&lt;code&gt;<span class="hljs-subst">${chunkData.chunk}</span>&lt;/code&gt;&lt;/pre&gt;`</span>;\n}\n</code></pre>\n<h4>3. Markdown流式（需实时解析格式）</h4>\n<p>若返回Markdown片段（如带<code>#</code>、<code>**</code>等标记），用<code>marked.js</code>实时转换为HTML：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> marked <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;marked&quot;</span>; <span class="hljs-comment">// 需引入marked库</span>\n\n<span class="hljs-comment">// 每次拼接后解析为HTML</span>\nfullMarkdown += chunk;\noutputEl.<span class="hljs-property">innerHTML</span> = marked.<span class="hljs-title function_">parse</span>(fullMarkdown);\n</code></pre>\n<h3>四、优化用户体验的关键细节</h3>\n<ol>\n<li>\n<p><strong>加载状态提示</strong></p>\n<ul>\n<li>开始请求时显示“正在生成...”，结束后隐藏。</li>\n<li>可添加“打字机”效果（如逐字显示）：<pre><code class="language-javascript"><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">typeWriter</span>(<span class="hljs-params">text</span>) {\n  <span class="hljs-keyword">if</span> (index &lt; text.<span class="hljs-property">length</span>) {\n    outputEl.<span class="hljs-property">innerText</span> += text.<span class="hljs-title function_">charAt</span>(index);\n    index++;\n    <span class="hljs-built_in">setTimeout</span>(typeWriter, <span class="hljs-number">10</span>); <span class="hljs-comment">// 控制打字速度</span>\n  }\n}\n<span class="hljs-comment">// 调用：typeWriter(chunk);</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>中断与重试机制</strong><br>\n允许用户中途停止生成（如点击“停止”按钮）：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 中断Fetch流式请求</span>\n<span class="hljs-keyword">let</span> reader; <span class="hljs-comment">// 全局存储reader</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">abortStream</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (reader) reader.<span class="hljs-title function_">cancel</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;已停止生成&quot;</span>));\n}\n</code></pre>\n</li>\n<li>\n<p><strong>滚动优化</strong><br>\n长文本生成时自动滚动到最新内容：</p>\n<pre><code class="language-javascript">outputEl.<span class="hljs-property">scrollTop</span> = outputEl.<span class="hljs-property">scrollHeight</span>; <span class="hljs-comment">// 每次更新后执行</span>\n</code></pre>\n</li>\n<li>\n<p><strong>错误处理</strong><br>\n捕获网络中断、后端报错等情况：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">try</span> {\n  <span class="hljs-comment">// 流式请求逻辑</span>\n} <span class="hljs-keyword">catch</span> (error) {\n  outputEl.<span class="hljs-property">innerText</span> = <span class="hljs-string">`生成失败：<span class="hljs-subst">${error.message}</span>，请重试`</span>;\n}\n</code></pre>\n</li>\n</ol>\n<h3>五、兼容性与注意事项</h3>\n<ul>\n<li><strong>浏览器支持</strong>   ：<code>ReadableStream</code>在Chrome、Firefox、Edge等现代浏览器支持良好，IE完全不支持（需提示用户升级）。</li>\n<li><strong>数据完整性</strong>   ：单个chunk可能不完整（如JSON截断），需用<code>fullContent</code>存储完整内容，渲染时以完整内容为准，避免显示错乱。</li>\n<li><strong>后端配合</strong>   ：确保后端接口启用分块传输（响应头<code>Transfer-Encoding: chunked</code>），且数据块格式一致（避免混合文本和JSON）。</li>\n</ul>\n<p>通过以上方式，前端可高效处理AI流式返回，实现类似ChatGPT的“边生成边展示”效果，显著降低用户等待感。</p>\n</div>'</script></body></html>