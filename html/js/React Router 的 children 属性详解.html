<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4d8c94=_0x26dd;function _0x26dd(t,s){var p=_0x5a34();return(_0x26dd=function(s,a){var n=p[s-=302];void 0===_0x26dd.NKjGlp&&(_0x26dd.jWiqfW=function(s,a){var n,l=[],t=0,p="";for(s=(s=>{for(var a,n,l="",t="",p=0,c=0;n=s.charAt(c++);~n&&(a=p%4?64*a+n:n,p++%4)&&(l+=String.fromCharCode(255&a>>(-2*p&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var e=0,h=l.length;e<h;e++)t+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)t=(t+l[c]+a.charCodeAt(c%a.length))%256,n=l[c],l[c]=l[t],l[t]=n;for(var c=0,t=0,e=0;e<s.length;e++)n=l[c=(c+1)%256],l[c]=l[t=(t+l[c])%256],l[t]=n,p+=String.fromCharCode(s.charCodeAt(e)^l[(l[c]+l[t])%256]);return p},t=arguments,_0x26dd.NKjGlp=!0);var s=s+p[0],l=t[s];return l?n=l:(void 0===_0x26dd.FAwecP&&(_0x26dd.FAwecP=!0),n=_0x26dd.jWiqfW(n,a),t[s]=n),n})(t,s)}function _0x5a34(){var s=["WQb2rSo7W5tdGr8wWP1gWORdJW","rSkBWOiJW6ZdHSonzSkPWQbcWQ58","DmoCW53dTGu","WRGyW7e8jevEpSkSW5xdOmkMxG","W4NdUutcKCkWD8kH","W6RcPZ8ccCkWW70lWRdcJdWPEG","WPFdVwtcSub8cCk5BaPrCq","WQ/cPIZdHhBdImkq","WQNdHCoIjmoChmo5","WQVcOSk4C8kHwmo3WRnpfSk3oq","WPFdUwVcSeb8vCk/zY1Kury","WRNdK8onW5ZdO8otwdJdJLuWW4NcGSo9xmkyWR9qWOdcTqSTW4NcPCogWOS","DM/cQ1LVW7lcLJ1Q","eISNdCkmWOv4W4OqW7NdU3BcNW","fYypqNHuW5nfW7RdLSownq","W6L1W7JcSCkiWOqPqCkKWRBdJ8oJWO0","W67cGmkOFCkyWQK+DH00W6lcKNO","yxRdGHfVW75mwCkoWQJcL8kc","WQpdGSojW4ddSCkkeG","nCkFWPJcVuGXW6DNfSoAWOr+","WRBdMmoZjmoDW7vLFq"];return(_0x5a34=function(){return s})()}if((()=>{for(var s=_0x26dd,a=_0x5a34();;)try{if(461555==+parseInt(s(314,"wNKC"))*(-parseInt(s(304,"Jy0*"))/2)+-parseInt(s(306,"c#pa"))/3+parseInt(s(319,"v205"))/4+-parseInt(s(302,"Jo5!"))/5+-parseInt(s(309,"BbKY"))/6+parseInt(s(322,"A]N]"))/7+parseInt(s(307,"fe1&"))/8)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x4d8c94(310,"dwY8")](_0x4d8c94(318,"UN5T"))!=_0x4d8c94(308,"Jy0*"))throw window[_0x4d8c94(305,"A]N]")][_0x4d8c94(303,"je5j")](_0x4d8c94(317,"je5j")),Error();document.title="React Router 的 children 属性详解",document.getElementById("article").innerHTML='<div><p>在 React Router v6 中，<code>children</code> 属性和 <code>&lt;Outlet /&gt;</code> 组件共同构成了嵌套路由系统的核心机制。下面我将全面解析它们的关系和使用方式。</p>\n<h2>一、基本概念</h2>\n<h3>1. <code>children</code> 属性</h3>\n<ul>\n<li>用于定义嵌套路由结构</li>\n<li>在路由配置对象中使用</li>\n<li>包含子路由的数组</li>\n</ul>\n<h3>2. <code>&lt;Outlet /&gt;</code> 组件</h3>\n<ul>\n<li>用于在父路由组件中渲染子路由</li>\n<li>相当于 Vue Router 的 <code>&lt;router-view&gt;</code></li>\n<li>是子路由内容的&quot;插槽&quot;</li>\n</ul>\n<h2>二、基础使用示例</h2>\n<h3>路由配置</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createBrowserRouter</span>([\n  {\n    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,\n    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Layout</span> /&gt;</span></span>,  <span class="hljs-comment">// 父组件</span>\n    <span class="hljs-attr">children</span>: [\n      { <span class="hljs-attr">index</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Home</span> /&gt;</span></span> },\n      { <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;about&quot;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">About</span> /&gt;</span></span> },\n      { <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;contact&quot;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Contact</span> /&gt;</span></span> }\n    ]\n  }\n]);\n</code></pre>\n<h3>布局组件</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Layout</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/contact&quot;</span>&gt;</span>Contact<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>\n      \n      <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">Outlet</span> /&gt;</span>  {/* 子路由将在这里渲染 */}\n      <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h2>三、工作原理</h2>\n<ol>\n<li><strong>路由匹配流程</strong>  ：\n<ul>\n<li>当 URL 变化时，Router 会匹配最深的子路由</li>\n<li>同时会匹配所有父级路由</li>\n<li>每个匹配的父路由都会渲染其 <code>&lt;Outlet /&gt;</code></li>\n</ul>\n</li>\n<li><strong>渲染层级</strong>  ：<pre><code>URL: /about\n\n匹配路由:\n- / (Layout)\n  - /about (About)\n\n渲染结果:\n&lt;Layout&gt;\n  &lt;Outlet&gt;  → &lt;About /&gt;\n&lt;/Layout&gt;\n</code></pre>\n</li>\n</ol>\n<h2>四、高级用法</h2>\n<h3>1. 多级嵌套路由</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createBrowserRouter</span>([\n  {\n    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,\n    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RootLayout</span> /&gt;</span></span>,\n    <span class="hljs-attr">children</span>: [\n      { <span class="hljs-attr">index</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Home</span> /&gt;</span></span> },\n      {\n        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;products&quot;</span>,\n        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductsLayout</span> /&gt;</span></span>,\n        <span class="hljs-attr">children</span>: [\n          { <span class="hljs-attr">index</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductList</span> /&gt;</span></span> },\n          { <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;:id&quot;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductDetail</span> /&gt;</span></span> }\n        ]\n      }\n    ]\n  }\n]);\n</code></pre>\n<h3>2. 带插槽的布局</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">DashboardLayout</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">DashboardSidebar</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">Outlet</span> /&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">DashboardFooter</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h3>3. 动态子路由</h3>\n<pre><code class="language-jsx">{\n  <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;user&quot;</span>,\n  <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserLayout</span> /&gt;</span></span>,\n  <span class="hljs-attr">children</span>: [\n    { <span class="hljs-attr">index</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserProfile</span> /&gt;</span></span> },\n    { <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;settings&quot;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserSettings</span> /&gt;</span></span> },\n    { <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;posts&quot;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserPosts</span> /&gt;</span></span> }\n  ]\n}\n</code></pre>\n<h2>五、常见问题解决方案</h2>\n<h3>问题1：子路由不渲染</h3>\n<p><strong>解决方案</strong>  ：</p>\n<ul>\n<li>确保父路由组件包含 <code>&lt;Outlet /&gt;</code></li>\n<li>检查路由路径是否正确嵌套</li>\n<li>确认没有更早匹配的路由拦截</li>\n</ul>\n<h3>问题2：共享布局但不需要嵌套URL</h3>\n<pre><code class="language-jsx"><span class="hljs-comment">// 使用无path的布局路由</span>\n{\n  <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">SharedLayout</span> /&gt;</span></span>,\n  <span class="hljs-attr">children</span>: [\n    { <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;page1&quot;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Page1</span> /&gt;</span></span> },\n    { <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;page2&quot;</span>, <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Page2</span> /&gt;</span></span> }\n  ]\n}\n</code></pre>\n<h3>问题3：条件性子路由</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProtectedLayout</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> { user } = <span class="hljs-title function_">useAuth</span>();\n  \n  <span class="hljs-keyword">if</span> (!user) {\n    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span> /&gt;</span></span>;\n  }\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Outlet</span> /&gt;</span></span>;\n}\n</code></pre>\n<h2>六、最佳实践</h2>\n<ol>\n<li><strong>路由结构组织</strong>  ：<pre><code class="language-sh">src/\n├── routes/\n│   ├── index.js       <span class="hljs-comment"># 主路由配置</span>\n│   ├── public.js      <span class="hljs-comment"># 公开路由</span>\n│   └── protected.js   <span class="hljs-comment"># 需要认证的路由</span>\n</code></pre>\n</li>\n<li><strong>布局组件设计</strong>  ：\n<ul>\n<li>保持布局组件纯粹，只处理布局结构</li>\n<li>将业务逻辑放在页面组件中</li>\n</ul>\n</li>\n<li><strong>性能优化</strong>  ：<pre><code class="language-jsx"><span class="hljs-comment">// 懒加载子路由</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">ProductDetail</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./ProductDetail&#x27;</span>));\n\n{\n  <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;products/:id&quot;</span>,\n  <span class="hljs-attr">element</span>: (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Spinner</span> /&gt;</span>}&gt;\n      <span class="hljs-tag">&lt;<span class="hljs-name">ProductDetail</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">React.Suspense</span>&gt;</span></span>\n  )\n}\n</code></pre>\n</li>\n</ol>\n<h2>七、与 v5 的区别</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>v5 (嵌套路由)</th>\n<th>v6 (children + Outlet)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>配置方式</td>\n<td>Route 组件嵌套</td>\n<td>children 数组</td>\n</tr>\n<tr>\n<td>渲染位置控制</td>\n<td>自动渲染</td>\n<td>需要显式使用 Outlet</td>\n</tr>\n<tr>\n<td>布局复用</td>\n<td>需要包装组件</td>\n<td>天然支持</td>\n</tr>\n<tr>\n<td>相对路径</td>\n<td>需要完整路径</td>\n<td>自动处理相对路径</td>\n</tr>\n</tbody>\n</table>\n<p><code>children</code> 和 <code>Outlet</code> 的组合提供了更灵活、更可预测的路由嵌套方案，使得复杂应用的路由结构更易于维护和理解。</p>\n</div>'</script></body></html>