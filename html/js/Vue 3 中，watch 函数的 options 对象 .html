<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x56c0(l,s){var p=_0x4a65();return(_0x56c0=function(s,n){var a=p[s-=147];void 0===_0x56c0.tXArEs&&(_0x56c0.iqWMbR=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=t.length;c<o;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,c=0;c<s.length;c++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(c)^t[(t[e]+t[l])%256]);return p},l=arguments,_0x56c0.tXArEs=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x56c0.gYzNle&&(_0x56c0.gYzNle=!0),a=_0x56c0.iqWMbR(a,n),l[s]=a),a})(l,s)}var _0x2e9f15=_0x56c0;if((()=>{for(var s=_0x56c0,n=_0x4a65();;)try{if(428188==-parseInt(s(162,"EtN]"))*(parseInt(s(173,"Q#oP"))/2)+-parseInt(s(176,"Q#oP"))/3+parseInt(s(151,"hU$g"))/4*(-parseInt(s(149,"a5Xi"))/5)+parseInt(s(166,"EtN]"))/6*(parseInt(s(158,"TExy"))/7)+-parseInt(s(170,"iVub"))/8*(parseInt(s(163,"IT(2"))/9)+-parseInt(s(171,"L5sr"))/10+-parseInt(s(174,"REWX"))/11*(-parseInt(s(164,"axX$"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x2e9f15(157,"QmK4")](_0x2e9f15(167,"%%1b"))!=_0x2e9f15(156,"(35w"))throw window[_0x2e9f15(147,"ufBF")][_0x2e9f15(159,"#GC4")](_0x2e9f15(165,"hU$g")),Error();function _0x4a65(){var s=["w8k+jGPtCmo9","WOdcSXyqW40euG","WODZWPdcN8oBaCotq8oZh8oTea","kflcPSkaW5RcMKDzWOL0taC","wsCoWRGfoCkWW7NdSmokpmkLhG","dSksfmo3W73cNxDMW4vfk3y","WPSJf8otWR3dHZZcLt0sa8oWWRldIMbIoZNdS8k9tuqfBmoEW6a","kfxcOCoCWPddNvDwWQq","uLBdUmkrW5xdO8kwg8ki","mmoBW5ddVNldPCkLW7/dICkEW4Hb","W4bGuConWRZcI0NdSa4","W5ldRJqvWP/dNSoEWOO","cbddPmklBw5rdbCADCoskq","c1pcOCodDSk6W7RcJ0GbW5Ol","fmkVlrjIWQpcKW","WOxdSgL1W7OxrGpdP8k2","iuJcVCoiWQG5W7aW","gmoMvxaGW5JcKKVcM8oukSkk","rmoBgLT3oCkxWP0","WPzUnmkGWOxcGSkWsmkWW6HfWPRcQa","W5lcJCoCW7BdI3jPBG","WQ4lCCkBd8o5A8o+","W4jJvSkuW73dJ2NdKWywjSo9","W57dHCogcSohWRyPW7C/qG","E2hdLSk7WQuYBmksW4fiWQO","WRy8W4zIW7nxW67cN8ktobVdSG","W78CW496D14zuSkNp2VdI8kN","sHxdPSkeoq","WP1LW6ldVmopBwa","W7qBW4n9Fcjkx8kNjwy"];return(_0x4a65=function(){return s})()}document.title="Vue 3 中，watch 函数的 options 对象 ",document.getElementById("article").innerHTML='<div><p>在 Vue 3 中，<code>watch</code> 函数的 <strong>options 对象</strong>   提供了丰富的配置选项来控制监听行为。以下是完整的参数详解和实际应用指南：</p>\n<hr>\n<h3><strong>一、核心配置选项</strong></h3>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>类型</th>\n<th>默认值</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>deep</code></td>\n<td>boolean</td>\n<td><code>false</code></td>\n<td>是否深度监听对象/数组的内部变化</td>\n</tr>\n<tr>\n<td><code>immediate</code></td>\n<td>boolean</td>\n<td><code>false</code></td>\n<td>是否立即执行回调（初始值时）</td>\n</tr>\n<tr>\n<td><code>flush</code></td>\n<td>string</td>\n<td><code>\'pre\'</code></td>\n<td>控制回调触发时机 (<code>\'pre\'</code>/<code>\'post\'</code>/<code>\'sync\'</code>)</td>\n</tr>\n<tr>\n<td><code>onTrack</code></td>\n<td>function</td>\n<td>-</td>\n<td>调试用：响应式依赖被追踪时调用</td>\n</tr>\n<tr>\n<td><code>onTrigger</code></td>\n<td>function</td>\n<td>-</td>\n<td>调试用：依赖变更触发回调时调用</td>\n</tr>\n<tr>\n<td><code>once</code></td>\n<td>boolean</td>\n<td><code>false</code></td>\n<td>是否只触发一次回调（Vue 3.4+）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>二、选项详解与代码示例</strong></h3>\n<h4>1. <code>deep: true</code> （深度监听）</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({\n  <span class="hljs-attr">user</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> },\n});\n\n<span class="hljs-comment">// 默认监听不到嵌套变化</span>\n<span class="hljs-title function_">watch</span>(\n  <span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">user</span>,\n  <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;User changed:&quot;</span>, newVal);\n  },\n  { <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> },\n); <span class="hljs-comment">// 现在能检测到 state.user.name 的变化</span>\n\nstate.<span class="hljs-property">user</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Bob&quot;</span>; <span class="hljs-comment">// ✅ 触发回调</span>\n</code></pre>\n<p><strong>适用场景</strong>   ：</p>\n<ul>\n<li>监听复杂对象或数组的内部变化</li>\n<li><strong>注意</strong>   ：深度监听对性能影响较大，必要时才启用</li>\n</ul>\n<hr>\n<h4>2. <code>immediate: true</code> （立即执行）</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n\n<span class="hljs-comment">// 默认不会在初始化时执行</span>\n<span class="hljs-title function_">watch</span>(\n  count,\n  <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Count is:&quot;</span>, newVal);\n  },\n  { <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> },\n); <span class="hljs-comment">// ✅ 立即打印 &quot;Count is: 0&quot;</span>\n</code></pre>\n<p><strong>适用场景</strong>   ：</p>\n<ul>\n<li>需要初始值时立即执行逻辑（如初始化加载数据）</li>\n<li><strong>注意</strong>   ：此时 <code>oldVal</code> 会是 <code>undefined</code></li>\n</ul>\n<hr>\n<h4>3. <code>flush: \'post\'</code> （DOM 更新后触发）</h4>\n<pre><code class="language-javascript"><span class="hljs-title function_">watch</span>(\n  <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;element&quot;</span>),\n  <span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Element width:&quot;</span>, element?.<span class="hljs-property">offsetWidth</span>); <span class="hljs-comment">// 获取更新后的 DOM 尺寸</span>\n  },\n  { <span class="hljs-attr">flush</span>: <span class="hljs-string">&quot;post&quot;</span> }, <span class="hljs-comment">// 确保 DOM 已更新</span>\n);\n</code></pre>\n<p><strong>可选值</strong>   ：</p>\n<ul>\n<li><code>\'pre\'</code>：默认值，在 DOM 更新<strong>前</strong>   触发</li>\n<li><code>\'post\'</code>：在 DOM 更新<strong>后</strong>   触发（类似 Vue 2 的 <code>this.$nextTick</code>）</li>\n<li><code>\'sync\'</code>：同步触发（极少使用，可能破坏响应式时序）</li>\n</ul>\n<hr>\n<h4>4. 调试选项：<code>onTrack</code> &amp; <code>onTrigger</code></h4>\n<pre><code class="language-javascript"><span class="hljs-title function_">watch</span>(\n  <span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">count</span>,\n  <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;New value:&quot;</span>, newVal),\n  {\n    <span class="hljs-title function_">onTrack</span>(<span class="hljs-params">e</span>) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;依赖被追踪:&quot;</span>, e.<span class="hljs-property">target</span>); <span class="hljs-comment">// 调试哪些属性被监听</span>\n    },\n    <span class="hljs-title function_">onTrigger</span>(<span class="hljs-params">e</span>) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;依赖触发更新:&quot;</span>, e); <span class="hljs-comment">// 调试变化来源</span>\n    },\n  },\n);\n</code></pre>\n<p><strong>输出示例</strong>   ：</p>\n<pre><code>依赖被追踪: Ref&lt;0&gt;\n依赖触发更新: { target: Ref&lt;0&gt;, oldValue: 0, newValue: 1 }\n</code></pre>\n<hr>\n<h4>5. <code>once: true</code> （一次性监听）</h4>\n<pre><code class="language-javascript"><span class="hljs-title function_">watch</span>(\n  <span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">notification</span>,\n  <span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> <span class="hljs-title function_">alert</span>(msg),\n  { <span class="hljs-attr">once</span>: <span class="hljs-literal">true</span> }, <span class="hljs-comment">// 仅第一次变化时触发</span>\n);\n</code></pre>\n<p><strong>适用场景</strong>   ：</p>\n<ul>\n<li>只需响应第一次变化（如首次数据加载完成提示）</li>\n<li><strong>注意</strong>   ：需 Vue 3.4+ 版本支持</li>\n</ul>\n<hr>\n<h3><strong>三、组合使用示例</strong></h3>\n<h4>场景：深度监听 + DOM 更新后执行</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> formData = <span class="hljs-title function_">reactive</span>({\n  <span class="hljs-attr">fields</span>: { <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&quot;&quot;</span> },\n});\n\n<span class="hljs-title function_">watch</span>(\n  <span class="hljs-function">() =&gt;</span> formData.<span class="hljs-property">fields</span>,\n  <span class="hljs-function">(<span class="hljs-params">newFields</span>) =&gt;</span> {\n    <span class="hljs-comment">// 在 DOM 更新后验证表单</span>\n    <span class="hljs-title function_">validateForm</span>(<span class="hljs-title function_">toRaw</span>(newFields));\n  },\n  { <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">flush</span>: <span class="hljs-string">&quot;post&quot;</span> }, <span class="hljs-comment">// 组合选项</span>\n);\n</code></pre>\n<hr>\n<h3><strong>四、注意事项</strong></h3>\n<ol>\n<li>\n<p><strong>性能陷阱</strong>   ：</p>\n<ul>\n<li>\n<p><code>deep: true</code> 会对整个对象递归监听，避免在大型数据结构上使用</p>\n</li>\n<li>\n<p>优先监听具体路径而非整个对象：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// ✅ 更高效</span>\n<span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">user</span>.<span class="hljs-property">name</span>, <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {...});\n\n<span class="hljs-comment">// ❌ 不必要的深度监听</span>\n<span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">user</span>, <span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> {...}, { <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> });\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>内存泄漏</strong>   ：</p>\n<ul>\n<li>组件卸载时自动停止监听，但异步代码中可能需手动清理：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> stop = <span class="hljs-title function_">watch</span>(...);\n<span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">stop</span>()); <span class="hljs-comment">// 手动停止</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>与 <code>watchEffect</code> 的区别</strong>   ：</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>watch</code></th>\n<th><code>watchEffect</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>依赖收集</td>\n<td>显式指定数据源</td>\n<td>自动收集回调内所有依赖</td>\n</tr>\n<tr>\n<td>立即执行</td>\n<td>需 <code>immediate: true</code></td>\n<td>总是立即执行</td>\n</tr>\n<tr>\n<td>旧值访问</td>\n<td>可获取 <code>(newVal, oldVal)</code></td>\n<td>无旧值</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ol>\n<hr>\n<h3><strong>五、TypeScript 类型定义</strong></h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">WatchOptions</span> {\n  <span class="hljs-attr">deep</span>?: <span class="hljs-built_in">boolean</span>;\n  <span class="hljs-attr">immediate</span>?: <span class="hljs-built_in">boolean</span>;\n  <span class="hljs-attr">flush</span>?: <span class="hljs-string">&quot;pre&quot;</span> | <span class="hljs-string">&quot;post&quot;</span> | <span class="hljs-string">&quot;sync&quot;</span>;\n  <span class="hljs-attr">onTrack</span>?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">event</span>: <span class="hljs-title class_">DebuggerEvent</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;\n  <span class="hljs-attr">onTrigger</span>?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">event</span>: <span class="hljs-title class_">DebuggerEvent</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;\n  <span class="hljs-attr">once</span>?: <span class="hljs-built_in">boolean</span>;\n}\n</code></pre>\n<p>掌握这些选项后，可以更精准地控制监听行为，平衡功能与性能需求。</p>\n</div>'</script></body></html>