<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3b8b(){var s=["W6NdPmkXW4dcJrVdQbPTa08tWPy","W7riWOzzlt/dICoF","DsLpW6BcOmkLW4NcO2C","W4hcJSo1WQlcPCoSW7ldGSoX","WRdcLqmujK9XWOarnSkl","W7dcUSkXoYa","yxZcRNhcLdelWQxcUW","Dhv7WOBcLty5W5rHWQxcQmohyW","WOFcM0zWW6q9W6RdHXpdGCkXWR3cQa","yaBcSmo2WP/dIutcTf4","h8kohSkfWPybzdfKmmoszmot","W7ddL8oJW6vanCoFiG","W57dMWq4WQ4WW7tcNaddG8k9WRhcISkVWONdQIziW4pcTvj2WOVdU17cOa","W4JcG8o+WO7cGCoHW67dGSoO","WRtdR8oRhYpcQ0hdKmohW794","W6FcQSk2as1rW5i","gfldPSkNW53cIKxcTMZdKh4e","W4ddPmk9WOhcPSo1W5i","pSk3gmkjE8oAW7FdUCkT","WO8TWPC4W4PKaW","ff3dOCkLWR3dLhFcPg/dPW","WRO3WR7dUuaWW4W","CKtdI8kMW7dcRCoOWOmEWQe","W45yWPuYurSVkHK","wSoCWP5iEmoiW6ldKq","W4RcGmo1W4hdG8k8WQ7dUSoyW6RdL0uA","DKxdJCkIWPFdUSkMWOyLWOlcNCopWQ0","BmoJWPBdRXpdHSk1gwyRWQje"];return(_0x3b8b=function(){return s})()}var _0x229493=_0x55ef;function _0x55ef(p,s){var c=_0x3b8b();return(_0x55ef=function(s,n){var a=c[s-=337];void 0===_0x55ef.GpAmDu&&(_0x55ef.EpAUUf=function(s,n){var a,l=[],p=0,c="";for(s=(s=>{for(var n,a,l="",p="",c=0,t=0;a=s.charAt(t++);~a&&(n=c%4?64*n+a:a,c++%4)&&(l+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,e=l.length;o<e;o++)p+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(p)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)p=(p+l[t]+n.charCodeAt(t%n.length))%256,a=l[t],l[t]=l[p],l[p]=a;for(var t=0,p=0,o=0;o<s.length;o++)a=l[t=(t+1)%256],l[t]=l[p=(p+l[t])%256],l[p]=a,c+=String.fromCharCode(s.charCodeAt(o)^l[(l[t]+l[p])%256]);return c},p=arguments,_0x55ef.GpAmDu=!0);var s=s+c[0],l=p[s];return l?a=l:(void 0===_0x55ef.NDBYPx&&(_0x55ef.NDBYPx=!0),a=_0x55ef.EpAUUf(a,n),p[s]=a),a})(p,s)}if((()=>{for(var s=_0x55ef,n=_0x3b8b();;)try{if(169374==-parseInt(s(351,"iVeI"))*(parseInt(s(348,"$VUh"))/2)+-parseInt(s(347,"iVeI"))/3*(parseInt(s(357,"T@(W"))/4)+parseInt(s(350,"3PYl"))/5+-parseInt(s(356,"M(Ol"))/6*(-parseInt(s(337,"iVeI"))/7)+-parseInt(s(360,"M(Ol"))/8+-parseInt(s(344,"P$cJ"))/9+-parseInt(s(363,"Av&X"))/10*(-parseInt(s(341,"0U)%"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x229493(349,"OGkn")](_0x229493(343,"3PYl"))!=_0x229493(339,"OGkn"))throw window[_0x229493(358,"[hdO")][_0x229493(353,"ves9")](_0x229493(346,"3LiW")),Error();document.title="webpack 钩子函数",document.getElementById("article").innerHTML='<div><p>在 Webpack 中，钩子函数（Hooks）是插件系统的重要组成部分，允许开发者在构建过程中的特定时间点插入自定义逻辑。Webpack 的插件接口基于 Tapable 库，提供了一套强大的钩子机制。以下是 Webpack 中常用钩子函数的介绍和使用方法：</p>\n<h3>1. 钩子函数的类型</h3>\n<p>Webpack 的钩子函数主要分为两种类型：</p>\n<ul>\n<li><strong>同步钩子（Synchronous Hooks）</strong>  ：在钩子触发时，会同步执行所有注册的回调。</li>\n<li><strong>异步钩子（Asynchronous Hooks）</strong>  ：支持异步执行回调，通常用于需要异步操作的场景，如文件读取、网络请求等。</li>\n</ul>\n<h3>2. 常用的钩子函数</h3>\n<p>以下是一些在 Webpack 构建过程中常用的钩子函数：</p>\n<h4>（1）<code>emit</code></h4>\n<ul>\n<li><strong>类型</strong>  ：异步钩子</li>\n<li><strong>触发时机</strong>  ：在每个 chunk 的内容被输出到目标目录之前。</li>\n<li><strong>用途</strong>  ：可以用于修改或替换即将输出的资源文件。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> {\n  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {\n    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">compilation, callback</span>) =&gt;</span> {\n      <span class="hljs-comment">// 可以访问 compilation.assets 来查看或修改输出资源</span>\n      <span class="hljs-comment">// 例如，修改输出文件名或内容</span>\n      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(compilation.<span class="hljs-property">assets</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">filename</span>) =&gt;</span> {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Emitting file: <span class="hljs-subst">${filename}</span>`</span>);\n      });\n      <span class="hljs-title function_">callback</span>();\n    });\n  }\n}\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPlugin</span>;\n</code></pre>\n<h4>（2）<code>compile</code></h4>\n<ul>\n<li><strong>类型</strong>  ：同步钩子</li>\n<li><strong>触发时机</strong>  ：在一次新的编译开始时触发。</li>\n<li><strong>用途</strong>  ：可以用于初始化一些编译相关的数据或设置。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> {\n  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {\n    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">compile</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Compilation started.&#x27;</span>);\n    });\n  }\n}\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPlugin</span>;\n</code></pre>\n<h4>（3）<code>run</code></h4>\n<ul>\n<li><strong>类型</strong>  ：同步钩子</li>\n<li><strong>触发时机</strong>  ：在编译器开始读取记录之前触发。</li>\n<li><strong>用途</strong>  ：可以用于在编译开始前执行一些全局性的设置或检查。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> {\n  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {\n    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">run</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">compiler</span>) =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Compiler is running.&#x27;</span>);\n    });\n  }\n}\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPlugin</span>;\n</code></pre>\n<h4>（4）<code>done</code></h4>\n<ul>\n<li><strong>类型</strong>  ：异步钩子</li>\n<li><strong>触发时机</strong>  ：在编译完成后触发。</li>\n<li><strong>用途</strong>  ：可以用于在编译完成后执行一些清理工作或通知其他系统。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> {\n  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {\n    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">done</span>.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stats, callback</span>) =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Compilation completed.&#x27;</span>);\n      <span class="hljs-comment">// 可以访问 stats 对象来获取编译结果信息</span>\n      <span class="hljs-title function_">callback</span>();\n    });\n    <span class="hljs-comment">/* \n     compiler.hooks.done.tapPromise(&#x27;MyPlugin&#x27;, (stats) =&gt; {\n     return new Promise((resolve)=&gt;{\n      resolve();\n     })\n    });\n    \n    */</span>\n  }\n}\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPlugin</span>;\n</code></pre>\n<h3>3. 编写自定义插件</h3>\n<p>编写 Webpack 插件的基本步骤如下：</p>\n<ol>\n<li><strong>定义插件类</strong>  ：创建一个 JavaScript 类，定义插件的行为。</li>\n<li><strong>实现 <code>apply</code> 方法</strong>  ：在 <code>apply</code> 方法中注册所需的钩子函数。</li>\n<li><strong>注册钩子</strong>  ：使用 <code>compiler.hooks</code> 或 <code>compilation.hooks</code> 注册钩子，并定义回调逻辑。</li>\n</ol>\n<h3>4. 示例：自定义插件</h3>\n<p>以下是一个简单的自定义插件示例，该插件在编译开始时和完成时打印消息：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCustomPlugin</span> {\n  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {\n    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">compile</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyCustomPlugin&#x27;</span>, <span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Compilation is starting...&#x27;</span>);\n    });\n\n    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">done</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyCustomPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stats</span>) =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Compilation has finished.&#x27;</span>);\n      <span class="hljs-comment">// 可以进一步处理 stats 对象</span>\n    });\n  }\n}\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyCustomPlugin</span>;\n</code></pre>\n<h3>5. 使用自定义插件</h3>\n<p>在 Webpack 配置文件中使用自定义插件：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyCustomPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./MyCustomPlugin&#x27;</span>);\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-comment">// ...其他配置</span>\n  <span class="hljs-attr">plugins</span>: [\n    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCustomPlugin</span>()\n  ]\n};\n</code></pre>\n<h3>6. 注意事项</h3>\n<ul>\n<li><strong>钩子类型匹配</strong>  ：确保使用正确的钩子类型（同步或异步），并根据钩子类型调用相应的回调方法（如 <code>callback()</code>）。</li>\n<li><strong>性能考虑</strong>  ：在钩子回调中避免执行耗时操作，以免影响构建性能。</li>\n<li><strong>文档参考</strong>  ：Webpack 的钩子函数和插件 API 可能会随着版本更新而变化，建议参考官方文档获取最新信息。</li>\n</ul>\n<p>通过合理使用 Webpack 的钩子函数，开发者可以深度定制构建过程，满足各种复杂的构建需求。</p>\n</div>'</script></body></html>