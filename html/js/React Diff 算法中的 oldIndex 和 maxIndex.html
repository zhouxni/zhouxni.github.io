<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3b0e16=_0x5475;function _0x21af(){var n=["fmk/BmknWRXBWQfCCt/dPCksW50","lbjyfLGhla","AbpdMCkxlSkFWQ7dVSkrsh3dNW","fZWPWOnz","dvmFzmotWQJdLSkbfrLfW4lcTG","W6hcTxX1WPdcJWzt","Bu1xWPP5Emkge3PxxXOP","W7H2zmkkWRX3v8ofWPpdQNHPWRK","WQ0uWO7dTWT1WPyrvv3dHCkkWQS","C0uDArKMmgJcTCkRWQa","zchdT24AWRHxhSoSW6GIvc87aCkMgSoRW79LW4pdLchdHSockq","EKyFzH1ACvxcGSkcWOtcOCks","BwNcL8oit8oPWRu","AePtWPj5C8oVjfncyYy","FJddS3iiW6eD","WPFcSh4IjYlcM8oaW4qyW6y","WQ0rW7JcG1eeW6W/","dvqwAmozWQldNmkYnJD2W6JcNa","W6/cLZ3cRJBdLftcGa","lCorWRj8v03dSSk7WRe","vmkNiSojdCkgWOC","gSkLW5lcVSovWOtcL8ot","cLjeAmoMW5y/WPxdRmkADuRcUW","WPBdVmkSguzxhWy"];return(_0x21af=function(){return n})()}function _0x5475(e,n){var o=_0x21af();return(_0x5475=function(n,s){var l=o[n-=181];void 0===_0x5475.KxlrEB&&(_0x5475.bFlMEc=function(n,s){var l,a=[],e=0,o="";for(n=(n=>{for(var s,l,a="",e="",o=0,t=0;l=n.charAt(t++);~l&&(s=o%4?64*s+l:l,o++%4)&&(a+=String.fromCharCode(255&s>>(-2*o&6))))l="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(l);for(var c=0,p=a.length;c<p;c++)e+="%"+("00"+a.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(n),t=0;t<256;t++)a[t]=t;for(t=0;t<256;t++)e=(e+a[t]+s.charCodeAt(t%s.length))%256,l=a[t],a[t]=a[e],a[e]=l;for(var t=0,e=0,c=0;c<n.length;c++)l=a[t=(t+1)%256],a[t]=a[e=(e+a[t])%256],a[e]=l,o+=String.fromCharCode(n.charCodeAt(c)^a[(a[t]+a[e])%256]);return o},e=arguments,_0x5475.KxlrEB=!0);var n=n+o[0],a=e[n];return a?l=a:(void 0===_0x5475.ePoFyH&&(_0x5475.ePoFyH=!0),l=_0x5475.bFlMEc(l,s),e[n]=l),l})(e,n)}if((()=>{for(var n=_0x5475,s=_0x21af();;)try{if(323091==-parseInt(n(199,"vG7l"))*(parseInt(n(198,"9gD3"))/2)+parseInt(n(188,"9gD3"))/3+-parseInt(n(191,"u^Hz"))/4*(parseInt(n(201,"Rl)#"))/5)+parseInt(n(190,"WYDb"))/6+parseInt(n(194,"lzo1"))/7*(parseInt(n(202,"lzo1"))/8)+-parseInt(n(184,"zlE0"))/9+parseInt(n(186,"klml"))/10)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x3b0e16(187,"lrKh")](_0x3b0e16(181,"M[Ep"))!=_0x3b0e16(189,"y64R"))throw window[_0x3b0e16(183,"JrF%")][_0x3b0e16(200,"$ri$")](_0x3b0e16(196,"$ri$")),Error();document.title="React Diff 算法中的 oldIndex 和 maxIndex",document.getElementById("article").innerHTML='<div><p>在 React 的协调(Reconciliation)过程中，<code>oldIndex</code> 和 <code>maxIndex</code> 是两个关键变量，用于优化列表更新的性能。以下是它们的详细解释：</p>\n<h2>oldIndex（旧索引）</h2>\n<h3>定义</h3>\n<ul>\n<li><code>oldIndex</code> 表示当前节点在 <strong>旧子节点集合</strong>   中的位置索引</li>\n<li>用于判断节点是否发生了移动</li>\n</ul>\n<h3>特性</h3>\n<ol>\n<li><strong>取值范围</strong>  ：\n<ul>\n<li><code>≥0</code>：表示节点存在于旧集合中</li>\n<li><code>-1</code>：表示是新增节点（旧集合中不存在）</li>\n</ul>\n</li>\n<li><strong>计算方式</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 伪代码</span>\noldIndex = oldChildren.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> child.<span class="hljs-property">key</span> === newChild.<span class="hljs-property">key</span>)\n</code></pre>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-jsx"><span class="hljs-comment">// 旧集合</span>\n[<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;a&quot;</span>/&gt;</span></span>, <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;b&quot;</span>/&gt;</span></span>, <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;c&quot;</span>/&gt;</span></span>]\n\n<span class="hljs-comment">// 新集合中 key=&quot;b&quot; 的 oldIndex 是 1</span>\n</code></pre>\n</li>\n</ol>\n<h2>maxIndex（最大索引）</h2>\n<h3>定义</h3>\n<ul>\n<li><code>maxIndex</code> 是遍历新集合时维护的一个变量</li>\n<li>记录 <strong>当前已处理节点在旧集合中的最大索引值</strong></li>\n</ul>\n<h3>作用</h3>\n<ol>\n<li><strong>移动判断</strong>  ：\n<ul>\n<li>如果当前节点的 <code>oldIndex &lt; maxIndex</code>，说明该节点需要移动</li>\n<li>否则更新 <code>maxIndex = oldIndex</code></li>\n</ul>\n</li>\n<li><strong>优化目的</strong>  ：\n<ul>\n<li>避免不必要的DOM移动操作</li>\n<li>保持稳定的节点顺序</li>\n</ul>\n</li>\n</ol>\n<h2>两者协作的工作流程</h2>\n<pre><code class="language-mermaid">graph TD\n    A[遍历新集合] --&gt; B{获取oldIndex}\n    B --&gt;|oldIndex &gt;= 0| C[比较与maxIndex]\n    C --&gt;|oldIndex &lt; maxIndex| D[标记为移动]\n    C --&gt;|oldIndex &gt;= maxIndex| E[更新maxIndex]\n    B --&gt;|oldIndex = -1| F[标记为新增]\n</code></pre>\n<h2>实际案例解析</h2>\n<h3>示例场景</h3>\n<pre><code class="language-jsx"><span class="hljs-comment">// 旧集合</span>\n[\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;a&quot;</span>/&gt;</span></span> (<span class="hljs-attr">oldIndex</span>: <span class="hljs-number">0</span>),\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;b&quot;</span>/&gt;</span></span> (<span class="hljs-attr">oldIndex</span>: <span class="hljs-number">1</span>), \n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;c&quot;</span>/&gt;</span></span> (<span class="hljs-attr">oldIndex</span>: <span class="hljs-number">2</span>)\n]\n\n<span class="hljs-comment">// 新集合</span>\n[\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;b&quot;</span>/&gt;</span></span>,\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;a&quot;</span>/&gt;</span></span>,\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;c&quot;</span>/&gt;</span></span>\n]\n</code></pre>\n<h3>Diff 过程</h3>\n<ol>\n<li>处理 <code>key=&quot;b&quot;</code>：\n<ul>\n<li><code>oldIndex = 1</code></li>\n<li><code>maxIndex = 1</code> (初始为0，1&gt;0所以更新)</li>\n</ul>\n</li>\n<li>处理 <code>key=&quot;a&quot;</code>：\n<ul>\n<li><code>oldIndex = 0</code></li>\n<li>比较 <code>0 &lt; 1</code> (maxIndex) → 需要移动</li>\n</ul>\n</li>\n<li>处理 <code>key=&quot;c&quot;</code>：\n<ul>\n<li><code>oldIndex = 2</code></li>\n<li><code>2 &gt; 1</code> → 更新 <code>maxIndex = 2</code></li>\n</ul>\n</li>\n</ol>\n<h2>源码中的关键逻辑</h2>\n<p>React 的 <code>reconcileChildrenArray</code> 函数核心部分：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> resultingFirstChild = <span class="hljs-literal">null</span>;\n<span class="hljs-keyword">let</span> previousNewFiber = <span class="hljs-literal">null</span>;\n\n<span class="hljs-keyword">let</span> oldFiber = currentFirstChild;\n<span class="hljs-keyword">let</span> lastPlacedIndex = <span class="hljs-number">0</span>; <span class="hljs-comment">// 相当于 maxIndex</span>\n<span class="hljs-keyword">let</span> newIdx = <span class="hljs-number">0</span>;\n\n<span class="hljs-keyword">for</span> (; oldFiber !== <span class="hljs-literal">null</span> &amp;&amp; newIdx &lt; newChildren.<span class="hljs-property">length</span>; newIdx++) {\n  <span class="hljs-comment">// 获取 oldIndex</span>\n  <span class="hljs-keyword">const</span> oldIndex = oldFiber.<span class="hljs-property">index</span>;\n  \n  <span class="hljs-keyword">if</span> (oldIndex &lt; lastPlacedIndex) {\n    <span class="hljs-comment">// 需要移动</span>\n    oldFiber.<span class="hljs-property">effectTag</span> = <span class="hljs-title class_">Placement</span>;\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 更新 lastPlacedIndex</span>\n    lastPlacedIndex = oldIndex;\n  }\n  \n  <span class="hljs-comment">// ...创建 fiber 并链接</span>\n}\n</code></pre>\n<h2>性能优化意义</h2>\n<ol>\n<li><strong>最小化移动操作</strong>  ：\n<ul>\n<li>只有 <code>oldIndex &lt; maxIndex</code> 时才移动</li>\n<li>其他情况只需更新位置索引</li>\n</ul>\n</li>\n<li><strong>稳定顺序优化</strong>  ：\n<ul>\n<li>保持大部分节点的原始顺序</li>\n<li>仅移动真正需要调整位置的节点</li>\n</ul>\n</li>\n<li><strong>O(n)复杂度</strong>  ：\n<ul>\n<li>通过单次遍历完成diff</li>\n<li>避免O(n²)的完全比较</li>\n</ul>\n</li>\n</ol>\n<h2>特殊边界情况</h2>\n<ol>\n<li><strong>新增节点</strong>  ：\n<ul>\n<li><code>oldIndex = -1</code></li>\n<li>直接创建新fiber节点</li>\n<li>不影响 <code>maxIndex</code> 的值</li>\n</ul>\n</li>\n<li><strong>删除节点</strong>  ：\n<ul>\n<li>不会出现在新集合中</li>\n<li>后续统一处理删除效果</li>\n</ul>\n</li>\n<li><strong>key相同但类型不同</strong>  ：\n<ul>\n<li>视为删除旧节点+新增新节点</li>\n<li>重新计算索引关系</li>\n</ul>\n</li>\n</ol>\n<p>理解 <code>oldIndex</code> 和 <code>maxIndex</code> 的协作机制，是掌握React高效更新列表的关键。这种设计使得React能够以最小代价完成复杂的列表更新。</p>\n</div>'</script></body></html>