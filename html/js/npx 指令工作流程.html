<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x366e(){var n=["F8o1iZddRSk4Dmk5tSoOWPVcVmkWiq","s2n/WO/cSGhdMG","yqueCLe","htu7W7lcGaldVX9YWQK","WP7dNCkxWOjyzmkEvLe","W4f3WQVdHJfvcCkoWODAW6qw","W6ZcJmoaWPb7B8ktFgK","y8k4d8olWOTJyq","pM7dOmkxC8kAnmo5WRpdTmk+i8kXWOi","WR/dQ8kifSo9xSo2EWPFqenc","WRfTWPxcK8kNiSkjaSk2WPVdTsFdJW","W4ZdT8kFWO/cPuP7C07cNSomW6Ck","W4f2WQNdHdmIeSk+WQPDW78","yfbnWO0jW5ddUuKgC3zZWOq","W4JdSSkFW43dHaeltvO","WRDNWPFcNmkKw8oDiSkNWONdRq","WPldO0VcS8oSWONdKmkPW6rk","W4/cUqZdGmk0hSoIjvZdGtP9o8ocW4hdKwBdIu3dQmoYW6VdS8kXW5NcNG","WObwW4uxo8o4eSoNW7zYWO3cKG","W6VcHSocW58EwCk3ufHika","eCoxW5VcP8kngIxcKxysCa","W6/cQSkGx8oPsWVcHa","nmoOsmo/nCofW5NcKqdcKmofh8oQ","ECo2lZxdR8k4D8oiFmo4WRJcOSkt"];return(_0x366e=function(){return n})()}var _0x1fa21a=_0x390c;function _0x390c(s,n){var c=_0x366e();return(_0x390c=function(n,o){var e=c[n-=421];void 0===_0x390c.DLlKsn&&(_0x390c.LGMSNx=function(n,o){var e,t=[],s=0,c="";for(n=(n=>{for(var o,e,t="",s="",c=0,r=0;e=n.charAt(r++);~e&&(o=c%4?64*o+e:e,c++%4)&&(t+=String.fromCharCode(255&o>>(-2*c&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var l=0,d=t.length;l<d;l++)s+="%"+("00"+t.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(s)})(n),r=0;r<256;r++)t[r]=r;for(r=0;r<256;r++)s=(s+t[r]+o.charCodeAt(r%o.length))%256,e=t[r],t[r]=t[s],t[s]=e;for(var r=0,s=0,l=0;l<n.length;l++)e=t[r=(r+1)%256],t[r]=t[s=(s+t[r])%256],t[s]=e,c+=String.fromCharCode(n.charCodeAt(l)^t[(t[r]+t[s])%256]);return c},s=arguments,_0x390c.DLlKsn=!0);var n=n+c[0],t=s[n];return t?e=t:(void 0===_0x390c.nHkksb&&(_0x390c.nHkksb=!0),e=_0x390c.LGMSNx(e,o),s[n]=e),e})(s,n)}if((()=>{for(var n=_0x390c,o=_0x366e();;)try{if(700694==-parseInt(n(431,"5dQy"))+-parseInt(n(436,"UD5J"))/2+parseInt(n(435,"c2IV"))/3+-parseInt(n(432,"f$Mf"))/4*(parseInt(n(422,"4[Wq"))/5)+-parseInt(n(437,"kh@9"))/6+parseInt(n(441,"UD5J"))/7*(-parseInt(n(442,"#6i*"))/8)+parseInt(n(434,"7ZKE"))/9)break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x1fa21a(427,"sd9#")](_0x1fa21a(430,"f$Mf"))!=_0x1fa21a(428,"q8*G"))throw window[_0x1fa21a(423,"E%wa")][_0x1fa21a(433,"(%Yz")](_0x1fa21a(443,"HeTj")),Error();document.title="npx 指令工作流程",document.getElementById("article").innerHTML='<div><p><code>npx</code> 的工作流程可以分为 <strong>本地优先检查 → 远程下载执行 → 清理缓存</strong>   三个阶段，以下是详细步骤和底层逻辑：</p>\n<hr>\n<h3><strong>1. 完整工作流程</strong></h3>\n<h4><strong>阶段 1：检查本地依赖</strong></h4>\n<ol>\n<li><strong>解析命令</strong><br>\n输入 <code>npx &lt;包名&gt;</code> 后，<code>npx</code> 首先检查当前项目的 <code>node_modules/.bin/</code> 目录下是否存在对应的可执行文件。\n<ul>\n<li>如果本地已安装（如通过 <code>npm install &lt;包名&gt;</code>），直接运行本地版本。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-sh">npx eslint  <span class="hljs-comment"># 优先使用本地安装的 eslint</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>检查全局缓存</strong><br>\n若本地未找到，检查是否在全局 <code>node_modules</code> 中（即用户通过 <code>npm install -g &lt;包名&gt;</code> 安装过）。</li>\n</ol>\n<h4><strong>阶段 2：远程下载执行（若本地不存在）</strong></h4>\n<ol start="3">\n<li><strong>临时下载包</strong><br>\n如果本地和全局均未找到包，<code>npx</code> 会：\n<ul>\n<li>从 npm 仓库下载最新版本的包（或指定版本，如 <code>npx &lt;包名&gt;@版本号</code>）。</li>\n<li>将包缓存在 <code>~/.npm/_npx/</code> 目录（以唯一哈希 ID 命名文件夹）。</li>\n</ul>\n</li>\n<li><strong>执行包命令</strong>\n<ul>\n<li>解压下载的包，运行其 <code>package.json</code> 中 <code>bin</code> 字段指定的可执行文件。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-sh">npx create-react-app@5.0.0 my-app  <span class="hljs-comment"># 下载指定版本并执行</span>\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h4><strong>阶段 3：执行后清理</strong></h4>\n<ol start="5">\n<li><strong>自动清理（默认行为）</strong>\n<ul>\n<li>执行完成后，临时下载的包会被自动删除，<strong>不会保存到项目的 <code>node_modules</code></strong>  。</li>\n<li>可通过 <code>--no-clean</code> 参数保留缓存（用于调试）：<pre><code class="language-sh">npx --no-clean cowsay <span class="hljs-string">&quot;Hello&quot;</span>  <span class="hljs-comment"># 保留临时文件</span>\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>2. 底层机制</strong></h3>\n<h4><strong>关键目录</strong></h4>\n<table>\n<thead>\n<tr>\n<th>路径</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>./node_modules/.bin/</code></td>\n<td>存储本地安装包的可执行文件（软链接）。</td>\n</tr>\n<tr>\n<td><code>~/.npm/_npx/</code></td>\n<td>存储 <code>npx</code> 临时下载的包（按哈希ID）。</td>\n</tr>\n</tbody>\n</table>\n<h4><strong>环境变量控制</strong></h4>\n<ul>\n<li><code>--no-install</code>：强制使用本地包，拒绝远程下载。<pre><code class="language-sh">npx --no-install prettier  <span class="hljs-comment"># 仅用本地版本，找不到则报错</span>\n</code></pre>\n</li>\n<li><code>--ignore-existing</code>：忽略本地包，强制下载远程版本。<pre><code class="language-sh">npx --ignore-existing tsc  <span class="hljs-comment"># 总是下载最新 TypeScript</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>3. 特殊场景处理</strong></h3>\n<h4><strong>场景 1：运行非 <code>bin</code> 文件</strong></h4>\n<p>若需直接执行包内的某个 JS 文件（非 <code>bin</code> 入口）：</p>\n<pre><code class="language-sh">npx -p &lt;包名&gt; node &lt;包内路径&gt;\n<span class="hljs-comment"># 示例：执行包内脚本</span>\nnpx -p lodash node -e <span class="hljs-string">&quot;console.log(require(&#x27;lodash&#x27;).VERSION)&quot;</span>\n</code></pre>\n<h4><strong>场景 2：多包组合操作</strong></h4>\n<p>通过 <code>-p</code> 参数临时安装多个包，组合使用：</p>\n<pre><code class="language-sh">npx -p cowsay -p lolcatjs <span class="hljs-string">&#x27;cowsay &quot;Hello&quot; | lolcatjs&#x27;</span>\n<span class="hljs-comment"># 先安装 cowsay 和 lolcatjs，再执行管道命令</span>\n</code></pre>\n<h4><strong>场景 3：指定 Node 版本</strong></h4>\n<p>通过 <code>-p node@版本</code> 临时使用特定 Node 环境：</p>\n<pre><code class="language-sh">npx -p node@14 node -v  <span class="hljs-comment"># 临时使用 Node.js 14</span>\n</code></pre>\n<hr>\n<h3><strong>4. 安全性与性能</strong></h3>\n<h4><strong>安全性</strong></h4>\n<ul>\n<li><strong>风险</strong>  ：远程包可能包含恶意代码（尤其是不明确的第三方包）。</li>\n<li><strong>防护</strong>  ：\n<ul>\n<li>使用前检查包来源（如 <code>npm view &lt;包名&gt;</code>）。</li>\n<li>对敏感操作优先使用本地已知版本。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>性能</strong></h4>\n<ul>\n<li><strong>网络依赖</strong>  ：首次运行远程包需下载，受网络速度影响。</li>\n<li><strong>缓存优化</strong>  ：同一版本的包在缓存有效期内不会重复下载。</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<pre><code class="language-mermaid">flowchart TB\n  A[输入 npx &lt;包名&gt;] --&gt; B{本地是否存在?}\n  B --&gt;|是| C[执行本地版本]\n  B --&gt;|否| D{全局是否存在?}\n  D --&gt;|是| E[执行全局版本]\n  D --&gt;|否| F[从 npm 下载最新版]\n  F --&gt; G[解压到临时目录]\n  G --&gt; H[执行包命令]\n  H --&gt; I[自动清理缓存]\n</code></pre>\n<p><code>npx</code> 的设计平衡了便捷性和隔离性，适合现代 JavaScript 生态的灵活需求。使用时需权衡 <strong>快速体验</strong>   和 <strong>环境稳定性</strong>  ，关键场景建议固化依赖到 <code>package.json</code>。</p>\n</div>'</script></body></html>