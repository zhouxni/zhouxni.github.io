<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2be084=_0x5f41;function _0x4534(){var n=["amk6yepcScaSrq","zLHJWRrVmvtcOmkM","eqK2W6aPCfNcK8kgW7JdLSk+","kJ7cImkSCrWNlCkCwH0","WRbOWPuKE2lcQbRcVSkYW5W","cSovhCoqWQZcHaWMWPK","W7RdHmoxW7HXjgvqWPWX","qSogW5mgmgPFkv7cKa","W5nSmSkAt8k1WOZdGmkHW7ikW7e","W6lcPXddGmk1W7HNWPJdS2hdJ8kW","qSowWRNdV8khWQBcMW","D8oWW7ddUhZcPJVcHG4","lJxcImkSFuCOgSknzrJdTW","wSkKjgtdJWlcUaVdRq","WOSWW43dJmkIW7NcLsOBnG","WOVcGCkibCoEWPiDlSk+W7/dHqpdLG","yXldU8kkktvklSokWPDsW7a","WPLvpmoVdW","CSoZttmjW47dGuTFtG","W50vFSkOrCoqW6yqWPqggSk0jW","yXxcVSoczvrgdG","v17cQwxdIWZcLqPGW6JcVCksh3nAWRjjxmkcWR/cHWpcKcddHcS","a8k8jW/dSJK9r2RdK1G","cmo2W4VdNmovumo5uG","CSoYsJn+WO/dV25Ps08T","WRhcGgxdUmk1wCol","WOGYW4/dJSoNW7pcIH0RdSon","WOq0oSoeqxNdKvr2"];return(_0x4534=function(){return n})()}function _0x5f41(c,n){var d=_0x4534();return(_0x5f41=function(n,o){var e=d[n-=128];void 0===_0x5f41.aXjvno&&(_0x5f41.aIKyBq=function(n,o){var e,t=[],c=0,d="";for(n=(n=>{for(var o,e,t="",c="",d=0,l=0;e=n.charAt(l++);~e&&(o=d%4?64*o+e:e,d++%4)&&(t+=String.fromCharCode(255&o>>(-2*d&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var r=0,a=t.length;r<a;r++)c+="%"+("00"+t.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(c)})(n),l=0;l<256;l++)t[l]=l;for(l=0;l<256;l++)c=(c+t[l]+o.charCodeAt(l%o.length))%256,e=t[l],t[l]=t[c],t[c]=e;for(var l=0,c=0,r=0;r<n.length;r++)e=t[l=(l+1)%256],t[l]=t[c=(c+t[l])%256],t[c]=e,d+=String.fromCharCode(n.charCodeAt(r)^t[(t[l]+t[c])%256]);return d},c=arguments,_0x5f41.aXjvno=!0);var n=n+d[0],t=c[n];return t?e=t:(void 0===_0x5f41.QXenMC&&(_0x5f41.QXenMC=!0),e=_0x5f41.aIKyBq(e,o),c[n]=e),e})(c,n)}if((()=>{for(var n=_0x5f41,o=_0x4534();;)try{if(156705==-parseInt(n(136,"J@&A"))+-parseInt(n(130,"J@&A"))/2*(-parseInt(n(154,"x0^I"))/3)+parseInt(n(152,"j#9j"))/4+-parseInt(n(139,"U!dn"))/5*(-parseInt(n(138,"x0^I"))/6)+-parseInt(n(149,"#0hE"))/7*(-parseInt(n(132,"OHFf"))/8)+parseInt(n(143,"j#9j"))/9*(-parseInt(n(153,"VK*o"))/10)+-parseInt(n(155,"BI0z"))/11)break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x2be084(137,"2qrF")](_0x2be084(141,"wzTb"))!=_0x2be084(129,"ilvx"))throw window[_0x2be084(135,"kny*")][_0x2be084(150,"lENt")](_0x2be084(133,"X%03")),Error();document.title="请求头和响应头 cache-control",document.getElementById("article").innerHTML='<div><h3>请求头 <code>Cache-Control</code> 和响应头 <code>Cache-Control</code> 的区别</h3>\n<p><code>Cache-Control</code> 是一个 HTTP 头字段，用于定义缓存策略。它在请求头和响应头中都可以出现，但作用和使用场景有所不同。</p>\n<hr>\n<h4><strong>1. 请求头中的 <code>Cache-Control</code></strong></h4>\n<ul>\n<li><strong>作用</strong>  ：\n<ul>\n<li>客户端通过请求头中的 <code>Cache-Control</code> 指示中间缓存（如浏览器缓存、CDN 缓存）或服务器如何处理缓存。</li>\n<li>主要用于控制缓存的验证和获取行为。</li>\n</ul>\n</li>\n<li><strong>常见指令</strong>  ：\n<ul>\n<li><code>no-cache</code>：强制要求缓存把请求提交给原始服务器进行验证，即使缓存中有副本。</li>\n<li><code>no-store</code>：不存储请求或响应的任何内容。</li>\n<li><code>max-age=0</code>：请求必须向服务器验证，即使缓存中有副本。</li>\n<li><code>max-stale</code>：允许使用过期的缓存。</li>\n<li><code>min-fresh</code>：要求缓存的内容在指定时间内保持新鲜。</li>\n<li><code>only-if-cached</code>：只使用缓存中的副本，如果没有缓存则失败。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/resource</span> <span class="hljs-meta">HTTP/1.1</span>\n<span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com\n<span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache\n</code></pre>\n<ul>\n<li>含义：客户端要求服务器验证缓存的有效性，即使缓存中有副本。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4><strong>2. 响应头中的 <code>Cache-Control</code></strong></h4>\n<ul>\n<li><strong>作用</strong>  ：\n<ul>\n<li>服务器通过响应头中的 <code>Cache-Control</code> 指示客户端或中间缓存如何存储和重用响应。</li>\n<li>主要用于控制缓存的存储和过期策略。</li>\n</ul>\n</li>\n<li><strong>常见指令</strong>  ：\n<ul>\n<li><code>public</code>：响应可以被任何缓存存储（如浏览器、CDN）。</li>\n<li><code>private</code>：响应只能被单个用户缓存，不能被共享缓存（如 CDN）存储。</li>\n<li><code>no-cache</code>：缓存必须在使用前向服务器验证。</li>\n<li><code>no-store</code>：不存储响应的任何部分。</li>\n<li><code>max-age=&lt;seconds&gt;</code>：指定响应的最大新鲜时间（以秒为单位）。</li>\n<li><code>s-maxage=&lt;seconds&gt;</code>：覆盖 <code>max-age</code>，仅适用于共享缓存（如 CDN）。</li>\n<li><code>must-revalidate</code>：缓存过期后必须向服务器验证。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK\n<span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>public, max-age=3600\n</code></pre>\n<ul>\n<li>含义：响应可以被任何缓存存储，并且在 1 小时内被认为是新鲜的。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4><strong>3. 核心区别</strong></h4>\n<table>\n<thead>\n<tr>\n<th><strong>方面</strong></th>\n<th><strong>请求头 <code>Cache-Control</code></strong></th>\n<th><strong>响应头 <code>Cache-Control</code></strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>作用对象</strong></td>\n<td>客户端向缓存或服务器发出的指令</td>\n<td>服务器向客户端或缓存发出的指令</td>\n</tr>\n<tr>\n<td><strong>主要目的</strong></td>\n<td>控制缓存的验证和获取行为</td>\n<td>控制缓存的存储和过期策略</td>\n</tr>\n<tr>\n<td><strong>常见指令</strong></td>\n<td><code>no-cache</code>, <code>max-age=0</code>, <code>only-if-cached</code></td>\n<td><code>public</code>, <code>private</code>, <code>max-age</code>, <code>s-maxage</code></td>\n</tr>\n<tr>\n<td><strong>示例场景</strong></td>\n<td>客户端要求验证缓存的有效性</td>\n<td>服务器指示响应可以被缓存多长时间</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h4><strong>4. 实际应用场景</strong></h4>\n<ul>\n<li><strong>请求头 <code>Cache-Control</code></strong>  ：\n<ul>\n<li>当客户端希望确保获取最新数据时，可以使用 <code>no-cache</code> 或 <code>max-age=0</code>。</li>\n<li>当客户端希望使用缓存（即使过期）以减少延迟时，可以使用 <code>max-stale</code>。</li>\n</ul>\n</li>\n<li><strong>响应头 <code>Cache-Control</code></strong>  ：\n<ul>\n<li>当服务器希望响应被广泛缓存时，可以使用 <code>public</code> 和 <code>max-age</code>。</li>\n<li>当服务器希望响应仅被客户端缓存时，可以使用 <code>private</code>。</li>\n<li>当服务器希望响应不被缓存时，可以使用 <code>no-store</code>。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4><strong>5. 总结</strong></h4>\n<ul>\n<li><strong>请求头 <code>Cache-Control</code></strong>   是客户端用来控制缓存行为的工具，主要用于缓存验证和获取。</li>\n<li><strong>响应头 <code>Cache-Control</code></strong>   是服务器用来指示缓存策略的工具，主要用于缓存存储和过期管理。</li>\n</ul>\n<p>理解这两者的区别有助于更好地控制 HTTP 缓存，提高应用的性能和用户体验。</p>\n</div>'</script></body></html>