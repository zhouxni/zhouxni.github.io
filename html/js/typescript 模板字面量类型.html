<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2f51(t,s){var e=_0x53a3();return(_0x2f51=function(s,n){var a=e[s-=308];void 0===_0x2f51.bQquuM&&(_0x2f51.GWklSL=function(s,n){var a,l=[],t=0,e="";for(s=(s=>{for(var n,a,l="",t="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=l.length;o<c;o++)t+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(t)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)t=(t+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[t],l[t]=a;for(var p=0,t=0,o=0;o<s.length;o++)a=l[p=(p+1)%256],l[p]=l[t=(t+l[p])%256],l[t]=a,e+=String.fromCharCode(s.charCodeAt(o)^l[(l[p]+l[t])%256]);return e},t=arguments,_0x2f51.bQquuM=!0);var s=s+e[0],l=t[s];return l?a=l:(void 0===_0x2f51.eZXKEz&&(_0x2f51.eZXKEz=!0),a=_0x2f51.GWklSL(a,n),t[s]=a),a})(t,s)}var _0x5d6b5a=_0x2f51;function _0x53a3(){var s=["WRddQSkXWR/cMSk0WPddICozW4VdJq","mw5yW6aAqSk3vwu","kSkAWPTZWQLMtWG","WOtcLdzpW7upWRTDkmoTWO/dUW","WO1AvmkoWQdcT3qaWPFcRglcHSky","Emo6WQdcPhStWQVcN8kffg48W6q","yGZcNmoSW5RdNmkDW6O","gmoeWQ8knYenW7yJaH7cSf4","xG7cPHTaw8onbmoXAG57WRO","p2VcOmoBW7X4WQq+WQBcMq","WP0JxXxcH8kxW5ZcQ8k4W5uptHa","wNhdVYvZamolW4q","kmkxW4anW5SueHFdOXxcHsHP","wSo2W5NcNbPwpI7cRcW","qSkadmkuqSkOWOS","mSk+WP1+oWjoas/cM28kwMddHSoNW60CrL7dImoiW4y6W6RcMq","W7ddGWdcVrPbWPG","gCk3cCo2W6S6xSkJ","geNdTYOH","WRdcLehdPe0qWQTnWRpcTgXF","W6xdTCo6WRRdGGhcU8kq","W4hcVmotWPRcKmkVWPn3W6mWWPBcH8ow","rmoGcCoFW5WxxmkR","B8o9WObxcMiLsq","FCo7WQlcQhzeW5tcQmkSkfK"];return(_0x53a3=function(){return s})()}if((()=>{for(var s=_0x2f51,n=_0x53a3();;)try{if(195264==+parseInt(s(308,"EN2w"))*(parseInt(s(322,"Fs*m"))/2)+-parseInt(s(328,"zrRN"))/3*(-parseInt(s(310,"s)BD"))/4)+-parseInt(s(326,"cHlr"))/5+parseInt(s(325,"136v"))/6+-parseInt(s(332,"G(61"))/7+-parseInt(s(330,"gbwl"))/8*(-parseInt(s(319,"el5P"))/9)+parseInt(s(309,"w*]U"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5d6b5a(311,"Yo&q")](_0x5d6b5a(323,"9ZbS"))!=_0x5d6b5a(315,"4Y%f"))throw window[_0x5d6b5a(314,"el5P")][_0x5d6b5a(313,"6^Ja")](_0x5d6b5a(312,"aEDT")),Error();document.title="typescript 模板字面量类型",document.getElementById("article").innerHTML='<div><p>模板字面量类型是 TypeScript 中一个强大的特性，它允许你使用模板字符串语法来构造和操作字符串类型。这种特性使得在类型级别进行字符串拼接、模式匹配和类型推断成为可能。</p>\n<h3>基本用法</h3>\n<p>模板字面量类型的基本语法与 JavaScript 中的模板字符串类似，使用反引号（<code>`</code>）括起来，并可以通过 <code>${}</code> 插入其他类型。</p>\n<h4>示例 1：简单拼接</h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Greeting</span> = <span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-built_in">string</span>}</span>`</span>;\n\n<span class="hljs-comment">// 示例用法</span>\n<span class="hljs-keyword">const</span> <span class="hljs-attr">message</span>: <span class="hljs-title class_">Greeting</span> = <span class="hljs-string">&quot;Hello, World&quot;</span>; <span class="hljs-comment">// 有效</span>\n<span class="hljs-comment">// const invalidMessage: Greeting = &quot;Hi, World&quot;; // 无效，因为不符合模板字面量类型</span>\n</code></pre>\n<p><strong>解析</strong>  ：</p>\n<ul>\n<li><code>Greeting</code> 类型表示所有以 <code>&quot;Hello, &quot;</code> 开头的字符串，后面可以跟任意字符串。</li>\n<li><code>message</code> 符合这个类型，而 <code>invalidMessage</code> 不符合。</li>\n</ul>\n<h4>示例 2：模式匹配</h4>\n<p>模板字面量类型可以用于模式匹配，以提取字符串的特定部分。</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ExtractAfterHello</span>&lt;S <span class="hljs-keyword">extends</span> <span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-built_in">string</span>}</span>`</span>&gt; = S <span class="hljs-keyword">extends</span> <span class="hljs-string">`Hello, <span class="hljs-subst">${infer Rest}</span>`</span> ? <span class="hljs-title class_">Rest</span> : <span class="hljs-built_in">never</span>;\n\n<span class="hljs-comment">// 示例用法</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span> = <span class="hljs-title class_">ExtractAfterHello</span>&lt;<span class="hljs-string">&quot;Hello, TypeScript&quot;</span>&gt;; <span class="hljs-comment">// Result 的类型为 &quot;TypeScript&quot;</span>\n</code></pre>\n<p><strong>解析</strong>  ：</p>\n<ul>\n<li><code>ExtractAfterHello</code> 类型工具使用条件类型和 <code>infer</code> 关键字来提取 <code>&quot;Hello, &quot;</code> 后面的部分。</li>\n<li><code>Result</code> 的类型为 <code>&quot;TypeScript&quot;</code>，因为 <code>&quot;Hello, TypeScript&quot;</code> 符合模式，并提取了 <code>&quot;TypeScript&quot;</code>。</li>\n</ul>\n<h3>高级用法</h3>\n<h4>示例 3：字符串长度限制</h4>\n<p>你可以结合模板字面量类型和递归来实现对字符串长度的限制。</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Repeat</span>&lt;S <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, N <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>&gt; = N <span class="hljs-keyword">extends</span> N\n  ? <span class="hljs-string">`<span class="hljs-subst">${S}</span><span class="hljs-subst">${N <span class="hljs-keyword">extends</span> <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> : Repeat&lt;S, N - <span class="hljs-number">1</span>&gt;}</span>`</span>\n  : <span class="hljs-built_in">never</span>;\n\n<span class="hljs-comment">// 示例用法：生成一个由 &#x27;a&#x27; 重复 5 次的字符串</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">FiveAs</span> = <span class="hljs-title class_">Repeat</span>&lt;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">5</span>&gt;; <span class="hljs-comment">// &quot;aaaaa&quot;</span>\n</code></pre>\n<p><strong>注意</strong>  ：这个示例中的 <code>Repeat</code> 类型在实际使用中可能由于 TypeScript 的限制而需要更复杂的实现，特别是 <code>N</code> 的处理需要更精确的类型运算库（如 <code>type-fest</code>）来支持。TypeScript 本身对数字类型的处理有限，通常需要借助第三方库或手动展开。</p>\n<h4>示例 4：联合类型中的模板字面量</h4>\n<p>模板字面量类型可以与联合类型结合使用，以生成多个可能的字符串。</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Direction</span> = <span class="hljs-string">&quot;left&quot;</span> | <span class="hljs-string">&quot;right&quot;</span> | <span class="hljs-string">&quot;up&quot;</span> | <span class="hljs-string">&quot;down&quot;</span>;\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Move</span>&lt;D <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Direction</span>&gt; = <span class="hljs-string">`Move <span class="hljs-subst">${D}</span>`</span>;\n\n<span class="hljs-comment">// 示例用法</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Moves</span> = <span class="hljs-title class_">Move</span>&lt;<span class="hljs-string">&quot;left&quot;</span>&gt; | <span class="hljs-title class_">Move</span>&lt;<span class="hljs-string">&quot;right&quot;</span>&gt; | <span class="hljs-title class_">Move</span>&lt;<span class="hljs-string">&quot;up&quot;</span>&gt; | <span class="hljs-title class_">Move</span>&lt;<span class="hljs-string">&quot;down&quot;</span>&gt;;\n<span class="hljs-comment">// Moves 的类型为 &quot;Move left&quot; | &quot;Move right&quot; | &quot;Move up&quot; | &quot;Move down&quot;</span>\n</code></pre>\n<p><strong>解析</strong>  ：</p>\n<ul>\n<li><code>Move</code> 类型工具将方向字符串转换为带有前缀 <code>&quot;Move &quot;</code> 的字符串。</li>\n<li><code>Moves</code> 是所有可能移动字符串的联合类型。</li>\n</ul>\n<h3>实际应用</h3>\n<p>模板字面量类型在以下场景中非常有用：</p>\n<ul>\n<li><strong>构建类型安全的字符串常量</strong>  ：确保字符串符合特定的格式或模式。</li>\n<li><strong>字符串解析和提取</strong>  ：从字符串中提取特定部分，用于进一步的类型操作。</li>\n<li><strong>生成基于字符串的类型</strong>  ：根据字符串模式生成新的类型，如 API 路由、事件名称等。</li>\n</ul>\n<h3>注意事项</h3>\n<ul>\n<li><strong>性能</strong>  ：复杂的模板字面量类型可能导致 TypeScript 编译器性能下降，特别是在递归和大规模联合类型的情况下。</li>\n<li><strong>限制</strong>  ：TypeScript 的类型系统在某些情况下可能无法处理非常复杂的字符串模式，需要结合其他类型工具或库。</li>\n</ul>\n<p>模板字面量类型为 TypeScript 带来了强大的字符串处理能力，使得在类型级别进行复杂的字符串操作成为可能，极大地增强了类型系统的表达能力。</p>\n</div>'</script></body></html>