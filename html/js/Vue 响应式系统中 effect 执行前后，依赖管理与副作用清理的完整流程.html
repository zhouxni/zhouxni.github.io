<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3ad0(c,e){var p=_0x4ffe();return(_0x3ad0=function(e,s){var n=p[e-=112];void 0===_0x3ad0.FJBTLb&&(_0x3ad0.IEdIfH=function(e,s){var n,a=[],c=0,p="";for(e=(e=>{for(var s,n,a="",c="",p=0,l=0;n=e.charAt(l++);~n&&(s=p%4?64*s+n:n,p++%4)&&(a+=String.fromCharCode(255&s>>(-2*p&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var o=0,d=a.length;o<d;o++)c+="%"+("00"+a.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(c)})(e),l=0;l<256;l++)a[l]=l;for(l=0;l<256;l++)c=(c+a[l]+s.charCodeAt(l%s.length))%256,n=a[l],a[l]=a[c],a[c]=n;for(var l=0,c=0,o=0;o<e.length;o++)n=a[l=(l+1)%256],a[l]=a[c=(c+a[l])%256],a[c]=n,p+=String.fromCharCode(e.charCodeAt(o)^a[(a[l]+a[c])%256]);return p},c=arguments,_0x3ad0.FJBTLb=!0);var e=e+p[0],a=c[e];return a?n=a:(void 0===_0x3ad0.IFMsUo&&(_0x3ad0.IFMsUo=!0),n=_0x3ad0.IEdIfH(n,s),c[e]=n),n})(c,e)}var _0x59ed20=_0x3ad0;function _0x4ffe(){var e=["qYhcUCkrW4nvWQfI","rtS3tXq","wttcMmkiW43cGdS","W7vraSkxW7RdSvW","lNJdGSkyW6pcKCkic8kRWOit","WRpdJYFdOSoICWJcO8kZW5Kw","WPhcVZddGc7cSqr0cCopcSkaiCoorsVcJIxcVmojWPHZvaBdGwq","WPlcVdDeW6uTjmkNmmoUm8o8WP8","BYyYvCocDwOoWPJcUH4+W4a","wCk8WOCetCkcWPCyWPFcQSkUWQrd","WOJcGMjhzbJcPq","hSouWRD+fWPeW4qKW7aAW7yX","WOSfamkkW43dHh7dOmkFcftdTta","WP16W7jrz8krChdcSCkuW5GpW5O","hghdM8ouWPZdKw3dOCoQWRVcGZZcLq","zN7cVWVcUYPMFmoD","W4hcJcNdLG3dNg8","WQNcKdFcNSoBaSo4ySkYWOngWRyK","WOPyy8o3WOxcGbW","bhH3df9eoSkQW4pdJX4PwW","W6dcPv9fEsddRq","WOxdKXpcKh/dR8k8","W6FdLYCzigtcOXTbFbTDsG","AgddOW4dW6VcR8k3W4FcIJO","eSophsNcI8kMyW","WO1lW5OSaHW6C0pcP8of","WOn7W6VdQCoxsN4","W5RdSqRcV1VdNCkv"];return(_0x4ffe=function(){return e})()}if((()=>{for(var e=_0x3ad0,s=_0x4ffe();;)try{if(442681==+parseInt(e(120,"11sS"))*(parseInt(e(118,"!Z(x"))/2)+-parseInt(e(137,"(@]K"))/3*(-parseInt(e(125,"Ya8A"))/4)+parseInt(e(123,"oDlW"))/5+parseInt(e(135,"(@]K"))/6*(parseInt(e(138,"eKZi"))/7)+parseInt(e(114,"DT@T"))/8*(-parseInt(e(124,"xMwX"))/9)+parseInt(e(122,"y[wx"))/10+-parseInt(e(126,"%t@G"))/11)break;s.push(s.shift())}catch(e){s.push(s.shift())}})(),localStorage[_0x59ed20(136,"DT@T")](_0x59ed20(130,"*h]H"))!=_0x59ed20(116,"%MI$"))throw window[_0x59ed20(115,"eIFx")][_0x59ed20(117,"*oh0")](_0x59ed20(121,"ILdQ")),Error();document.title="Vue 响应式系统中 effect 执行前后，依赖管理与副作用清理的完整流程",document.getElementById("article").innerHTML='<div><h3>1. <code>cleanupEffect</code>：清理自定义副作用</h3>\n<ul>\n<li>从 <code>effect</code> 实例（<code>e</code>）中获取用户或框架定义的 <code>cleanup</code> 函数（用于清理副作用，如移除事件监听、清除定时器等）。</li>\n<li>先保存当前活跃的订阅者（<code>prevSub</code>），并临时将活跃订阅者置空（<code>activeSub = void 0</code>），防止清理过程中意外触发新的依赖收集。</li>\n<li>执行 <code>cleanup</code> 函数，完成副作用清理后，在 <code>finally</code> 块中恢复之前保存的活跃订阅者（<code>activeSub = prevSub</code>），确保依赖收集的状态正确。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanupEffect</span>(<span class="hljs-params">e</span>) {\n  <span class="hljs-keyword">const</span> { cleanup } = e;\n  e.<span class="hljs-property">cleanup</span> = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;\n  <span class="hljs-keyword">if</span> (cleanup) {\n    <span class="hljs-keyword">const</span> prevSub = activeSub;\n    activeSub = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;\n    <span class="hljs-keyword">try</span> {\n      <span class="hljs-title function_">cleanup</span>();\n    } <span class="hljs-keyword">finally</span> {\n      activeSub = prevSub;\n    }\n  }\n}\n</code></pre>\n<h3>2. <code>prepareDeps</code>：标记依赖为待验证状态</h3>\n<ul>\n<li>遍历 <code>effect</code> 关联的双向链表（从 <code>sub.deps</code> 开始，通过 <code>link.nextDep</code> 依次访问每个节点）。</li>\n<li>将每个链表节点（<code>link</code>）的版本号（<code>link.version</code>）设为 <code>-1</code>，标记这些依赖“需要在本轮 <code>effect</code> 执行中重新验证有效性”。</li>\n<li>同时维护 <code>Dep</code>（依赖）的“活跃依赖链”：将当前 <code>link</code> 的 <code>prevActiveLink</code> 设为该依赖（<code>link.dep</code>）之前的活跃节点，再把当前 <code>link</code> 设为该依赖新的活跃节点（<code>link.dep.activeLink = link</code>），以便后续追踪本轮被访问的依赖。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">prepareDeps</span>(<span class="hljs-params">sub</span>) {\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> link = sub.<span class="hljs-property">deps</span>; link; link = link.<span class="hljs-property">nextDep</span>) {\n    link.<span class="hljs-property">version</span> = -<span class="hljs-number">1</span>;\n    link.<span class="hljs-property">prevActiveLink</span> = link.<span class="hljs-property">dep</span>.<span class="hljs-property">activeLink</span>;\n    link.<span class="hljs-property">dep</span>.<span class="hljs-property">activeLink</span> = link;\n  }\n}\n</code></pre>\n<h3>3. <code>cleanupDeps</code>：清理无效依赖</h3>\n<ul>\n<li>从双向链表的尾部（<code>sub.depsTail</code>）开始遍历。</li>\n<li>若链表节点（<code>link</code>）的版本号为 <code>-1</code>（结合 <code>prepareDeps</code> 可知，这表示该依赖在本轮 <code>effect</code> 执行中未被访问，为无效依赖）：\n<ul>\n<li>如果该节点是链表尾部（<code>link === tail</code>），更新尾部指针（<code>tail = prev</code>）。</li>\n<li>调用 <code>removeSub</code> 和 <code>removeDep</code> 函数，从相关结构中移除该无效依赖，解除 <code>effect</code> 与这些无效依赖的关联。</li>\n</ul>\n</li>\n<li>若节点版本号不为 <code>-1</code>，则标记为有效依赖（<code>head = link</code>）。</li>\n<li>恢复依赖的“活跃依赖链”：将依赖（<code>link.dep</code>）的活跃节点指针（<code>activeLink</code>）设为之前保存的活跃节点（<code>link.prevActiveLink</code>），并清空当前节点的 <code>prevActiveLink</code>。</li>\n<li>遍历结束后，更新 <code>effect</code> 关联的双向链表的头（<code>sub.deps = head</code>）和尾（<code>sub.depsTail = tail</code>）指针，确保链表中仅保留有效依赖。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanupDeps</span>(<span class="hljs-params">sub</span>) {\n  <span class="hljs-keyword">let</span> head;\n  <span class="hljs-keyword">let</span> tail = sub.<span class="hljs-property">depsTail</span>;\n  <span class="hljs-keyword">let</span> link = tail;\n  <span class="hljs-keyword">while</span> (link) {\n    <span class="hljs-keyword">const</span> prev = link.<span class="hljs-property">prevDep</span>;\n    <span class="hljs-keyword">if</span> (link.<span class="hljs-property">version</span> === -<span class="hljs-number">1</span>) {\n      <span class="hljs-keyword">if</span> (link === tail) tail = prev;\n      <span class="hljs-title function_">removeSub</span>(link);\n      <span class="hljs-title function_">removeDep</span>(link);\n    } <span class="hljs-keyword">else</span> {\n      head = link;\n    }\n    link.<span class="hljs-property">dep</span>.<span class="hljs-property">activeLink</span> = link.<span class="hljs-property">prevActiveLink</span>;\n    link.<span class="hljs-property">prevActiveLink</span> = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;\n    link = prev;\n  }\n  sub.<span class="hljs-property">deps</span> = head;\n  sub.<span class="hljs-property">depsTail</span> = tail;\n}\n</code></pre>\n<p>整体流程通过 <code>cleanupEffect</code> 清理旧副作用，<code>prepareDeps</code> 标记待验证依赖，<code>cleanupDeps</code> 精准清理无效依赖，实现了 <code>effect</code> 依赖的动态管理与副作用的有效控制，保证响应式更新的精准性与性能。</p>\n</div>'</script></body></html>