<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5899(a,n){var c=_0x5c01();return(_0x5899=function(n,s){var e=c[n-=376];void 0===_0x5899.VupgHu&&(_0x5899.fFEWpC=function(n,s){var e,o=[],a=0,c="";for(n=(n=>{for(var s,e,o="",a="",c=0,r=0;e=n.charAt(r++);~e&&(s=c%4?64*s+e:e,c++%4)&&(o+=String.fromCharCode(255&s>>(-2*c&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var t=0,d=o.length;t<d;t++)a+="%"+("00"+o.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(a)})(n),r=0;r<256;r++)o[r]=r;for(r=0;r<256;r++)a=(a+o[r]+s.charCodeAt(r%s.length))%256,e=o[r],o[r]=o[a],o[a]=e;for(var r=0,a=0,t=0;t<n.length;t++)e=o[r=(r+1)%256],o[r]=o[a=(a+o[r])%256],o[a]=e,c+=String.fromCharCode(n.charCodeAt(t)^o[(o[r]+o[a])%256]);return c},a=arguments,_0x5899.VupgHu=!0);var n=n+c[0],o=a[n];return o?e=o:(void 0===_0x5899.XHqsJL&&(_0x5899.XHqsJL=!0),e=_0x5899.fFEWpC(e,s),a[n]=e),e})(a,n)}var _0x3ce9d1=_0x5899;function _0x5c01(){var n=["sMddGSoSWPRcJ8kgWQq5W7GGW7FcUa","umo3t8kzW5zrscu1","CmoYW5GdW73dHa44FKSWW59M","WP02yenWW7FdIf0f","WRnqWPtdNmoxxWSK","W7xcMCoejmoHWOBdQtP9CHzv","WRxdMSkTv8oeW5tcIrC","WPP0W5afW7OTfCkhWOq","WONdH8kAWPldQJxcNfVcPsRdU3PxWQdcN2ZdKhVdTWz+ncJdNSkCfq","vCkOWPmVW4BdK8kKW7idW7RdQG","WQ97W6rvW6KUW6m","W7tdM1eYxZTiA8oaoG","zeusqmkCWRxcUCkGWRdcKIO","WORcKmkHxLe2WOK","W51Rkg52W5RdGq","vCkVWPONW4pcJCoTWRiNW6RdJZDBpG","qKVdGCoNWRZcRSk0iG","W4tdQhFcUSkaWRVcK8k1sHpdRaBcQq","W5pcG8oEW5RcRZBcGYxcIHhdM1vw","WR/dKSovfSkeWR/cRbJdVmkJWRpcJW","v8kOWPyRWQBdT8kNW7m9W7a","WPDNWRztxmkNza0r","W55icmkiWOJdKue","WRhcJtVdNCoJFCkmkXLtW4hcJG","WQyqW5NcS1DjWPK","W65WWQ/dVSoGEd4","kCoXcCoht8oHWOhdGYfmW7JcMCk1W7S","wSoBWQKcWOP2WQuBDCoCsW","w8oFWQKcWOGKWQqUFCoVwCoQ","tCoCvsRdICkICYddL8obWPC","gmomWQ9nWOe","WP1Gr8olWRVdGSofWPrw"];return(_0x5c01=function(){return n})()}if((()=>{for(var n=_0x5899,s=_0x5c01();;)try{if(678461==-parseInt(n(395,"&Heg"))*(parseInt(n(404,"HoKD"))/2)+parseInt(n(382,"Yaln"))/3*(-parseInt(n(377,"rSmD"))/4)+parseInt(n(381,"xKY9"))/5*(-parseInt(n(379,"(AH%"))/6)+parseInt(n(386,"]Thn"))/7*(-parseInt(n(407,"4I(d"))/8)+-parseInt(n(392,"L!Xi"))/9*(-parseInt(n(402,"*DB6"))/10)+-parseInt(n(393,"7Olz"))/11*(-parseInt(n(405,"LT!B"))/12)+parseInt(n(385,"(AH%"))/13)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x3ce9d1(394,"]qk9")](_0x3ce9d1(391,"M%tI"))!=_0x3ce9d1(400,"#TH$"))throw window[_0x3ce9d1(406,"&Heg")][_0x3ce9d1(384,"LT!B")](_0x3ce9d1(378,"1SnO")),Error();document.title="vue2  __ob__ 属性",document.getElementById("article").innerHTML='<div><p>在 Vue 2 的源码中，<code>__ob__</code> 是一个内部属性，用于标记一个对象是否已经被 Vue 的响应式系统所劫持（即被观察）。这是 Vue 2 实现响应式系统的关键部分之一。</p>\n<h3><code>__ob__</code> 属性的作用</h3>\n<ol>\n<li><strong>标记响应式对象</strong>  ：当一个对象被 Vue 的响应式系统处理时，Vue 会在该对象上添加一个 <code>__ob__</code> 属性。这个属性是一个观察者对象（Observer），它包含了与该对象相关的依赖收集和通知更新的机制。</li>\n<li><strong>避免重复观察</strong>  ：通过检查对象是否已有 <code>__ob__</code> 属性，Vue 可以避免对同一个对象进行重复的观察，从而提高性能。</li>\n</ol>\n<h3><code>__ob__</code> 属性的结构</h3>\n<p><code>__ob__</code> 属性通常是一个 Observer 实例，其结构大致如下：</p>\n<pre><code class="language-javascript">{\n  <span class="hljs-attr">value</span>: {...},    <span class="hljs-comment">// 被观察的对象</span>\n  <span class="hljs-attr">dep</span>: {...},      <span class="hljs-comment">// 依赖对象，用于存储依赖于该对象的 Watcher</span>\n  <span class="hljs-attr">vmCount</span>: <span class="hljs-number">0</span>       <span class="hljs-comment">// 与该对象关联的 Vue 实例的数量（用于一些内部优化）</span>\n}\n</code></pre>\n<ul>\n<li><strong><code>value</code></strong>  ：指向被观察的对象本身。</li>\n<li><strong><code>dep</code></strong>  ：一个 Dep（依赖）对象，用于管理依赖于该对象的所有 Watcher。当对象发生变化时，Dep 会通知所有相关的 Watcher 进行更新。</li>\n<li><strong><code>vmCount</code></strong>  ：在某些情况下用于跟踪与该对象关联的 Vue 实例数量，尽管在标准的 Vue 2 源码中可能不直接暴露或使用这个属性。</li>\n</ul>\n<h3>响应式系统的基本流程</h3>\n<ol>\n<li><strong>初始化</strong>  ：当 Vue 实例初始化时，会遍历其 <code>data</code> 对象，对每个属性进行响应式处理。</li>\n<li><strong>劫持对象</strong>  ：对于每个对象，Vue 会创建一个 Observer 实例，并将其赋值给对象的 <code>__ob__</code> 属性。</li>\n<li><strong>依赖收集</strong>  ：当组件渲染时，会触发对响应式属性的访问，此时会进行依赖收集，将当前的 Watcher 添加到对应属性的 Dep 中。</li>\n<li><strong>通知更新</strong>  ：当响应式对象发生变化时，会触发 Dep 通知所有相关的 Watcher，从而触发组件的重新渲染。</li>\n</ol>\n<h3>注意事项</h3>\n<ul>\n<li><strong><code>__ob__</code> 是内部属性</strong>  ：<code>__ob__</code> 是 Vue 的内部实现细节，通常不建议在应用程序代码中直接访问或修改它。</li>\n<li><strong>Vue 3 的变化</strong>  ：在 Vue 3 中，响应式系统的实现方式有所改变，不再使用 <code>__ob__</code> 属性，而是采用了基于 Proxy 的实现，提供了更强大和灵活的响应式能力。</li>\n</ul>\n<h3>示例</h3>\n<p>虽然直接操作 <code>__ob__</code> 不是推荐的做法，但了解它的存在有助于理解 Vue 的响应式原理。以下是一个简化的示例，展示如何在 Vue 2 中（通过某种方式）访问 <code>__ob__</code> 属性（仅用于学习目的）：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({\n  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> {\n      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello Vue!&#x27;</span>\n    };\n  }\n});\n\n<span class="hljs-comment">// 访问响应式对象的 __ob__ 属性（不推荐在生产代码中使用）</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-property">message</span>.<span class="hljs-property">__ob__</span>); <span class="hljs-comment">// 这是一个 Observer 实例（在开发环境中可能可用，生产环境可能被移除或优化）</span>\n</code></pre>\n<p><strong>重要提示</strong>  ：直接依赖或操作 Vue 的内部实现细节（如 <code>__ob__</code>）可能会导致代码在未来的 Vue 版本中不兼容。建议始终使用 Vue 提供的公共 API 来实现功能。</p>\n</div>'</script></body></html>