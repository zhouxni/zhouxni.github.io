<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x169fc3=_0x529b;function _0x529b(e,n){var a=_0x54fa();return(_0x529b=function(n,t){var s=a[n-=194];void 0===_0x529b.FHcvWo&&(_0x529b.BRcLjX=function(n,t){var s,o=[],e=0,a="";for(n=(n=>{for(var t,s,o="",e="",a=0,r=0;s=n.charAt(r++);~s&&(t=a%4?64*t+s:s,a++%4)&&(o+=String.fromCharCode(255&t>>(-2*a&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var c=0,d=o.length;c<d;c++)e+="%"+("00"+o.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(n),r=0;r<256;r++)o[r]=r;for(r=0;r<256;r++)e=(e+o[r]+t.charCodeAt(r%t.length))%256,s=o[r],o[r]=o[e],o[e]=s;for(var r=0,e=0,c=0;c<n.length;c++)s=o[r=(r+1)%256],o[r]=o[e=(e+o[r])%256],o[e]=s,a+=String.fromCharCode(n.charCodeAt(c)^o[(o[r]+o[e])%256]);return a},e=arguments,_0x529b.FHcvWo=!0);var n=n+a[0],o=e[n];return o?s=o:(void 0===_0x529b.Wqjtrr&&(_0x529b.Wqjtrr=!0),s=_0x529b.BRcLjX(s,t),e[n]=s),s})(e,n)}function _0x54fa(){var n=["WQ/dI8ohWOVcTvlcVhi","WPlcUCknW7PIE3HzWPrHsJKJ","W4hcMsFcKSotW5GDW44JmmkBACk2a2JcVLrWWR0tW7lcJf1DWOCm","WQ7dHtCxWPdcIMXTW6CnWO05","W7BcUmoNW6RcN8kgCHn4","WQZdGtCvWPFcJrD8W4ifWOqAWOC","WPFcR8oJW5FdUcv6ugnLW7hcPW","AmkaW7f3W5JdThBdPGa","jSoCumk8fmoWWQ1PgKJdLmog","W4XZW7tdKc9BW6hcQCkIt8oUcxO","jSoAk8o6umklWO9R","rCkbh1/cJIBdR8kNFXnsbSoG","WOBdJCkKwCk9WQLs","W7/cO8ocn8kzrCkLvmo2","W6H6W53cQ8kCsrldKmouWOHat8k2","WOhcRmomW4dcV8kauq","kG0kW5hcNrePE8oUW5P2pW","l2vQjCkerheDvCk7ha","smoPphJcNSoPW6C+WOG","W43dOWdcO8ol","W4fyECogcSoWWQq","W6zjWOhcS0nODCkruKrCWRO","W7FcKCkxW53dSxhcG1GhW61H","f2RcR8kVyeSFCSkCAKOp","oe3cTCogs8kJW5JdRWS","W67cRCklW6remmkJ","WOKkW7xcQSkuvXjnW7jZlcWu"];return(_0x54fa=function(){return n})()}if((()=>{for(var n=_0x529b,t=_0x54fa();;)try{if(798288==-parseInt(n(216,"Ttu]"))*(-parseInt(n(201,"PlYu"))/2)+parseInt(n(207,"B&n^"))/3+-parseInt(n(202,"!ejL"))/4+parseInt(n(211,"bP(Z"))/5+parseInt(n(199,"OgEr"))/6*(parseInt(n(205,"t*Z("))/7)+parseInt(n(212,"9fO@"))/8*(-parseInt(n(203,"kNc8"))/9)+-parseInt(n(214,"Ttu]"))/10*(parseInt(n(219,"V(4g"))/11))break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x169fc3(218,"jQTs")](_0x169fc3(210,"0c@V"))!=_0x169fc3(198,"teOr"))throw window[_0x169fc3(206,"PlYu")][_0x169fc3(204,"TGK0")](_0x169fc3(208,"Ax!R")),Error();document.title="TypeScript 中 typeof 操作符的返回值",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>typeof</code> 操作符的返回值取决于它所操作的目标类型。以下是全面的总结：</p>\n<h3>1. 基本规则</h3>\n<table>\n<thead>\n<tr>\n<th>操作对象</th>\n<th><code>typeof</code> 返回内容</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>值（变量、常量）</strong></td>\n<td>返回该值的 <strong>类型注解</strong></td>\n<td><code>typeof 42</code> → <code>number</code></td>\n</tr>\n<tr>\n<td><strong>类</strong></td>\n<td>返回类的 <strong>构造函数类型</strong>  （包含静态成员和原型链）</td>\n<td><code>typeof Person</code> → <code>{ new(name: string): Person; say(): void; }</code></td>\n</tr>\n<tr>\n<td><strong>函数</strong></td>\n<td>返回函数签名类型</td>\n<td><code>typeof Math.max</code> → <code>(...numbers: number[]) =&gt; number</code></td>\n</tr>\n<tr>\n<td><strong>数组</strong></td>\n<td>返回数组元素类型的简写形式（实际包含所有数组方法，但不显式展示）</td>\n<td><code>typeof [1,2,3]</code> → <code>number[]</code></td>\n</tr>\n<tr>\n<td><strong>对象</strong></td>\n<td>返回对象字面量类型</td>\n<td><code>typeof {x:1}</code> → <code>{ x: number }</code></td>\n</tr>\n<tr>\n<td><strong>枚举</strong></td>\n<td>返回枚举的双重类型（既是值也是类型）</td>\n<td><code>enum Color {Red}</code> → <code>typeof Color</code> 包含所有枚举成员</td>\n</tr>\n</tbody>\n</table>\n<h3>2. 特殊行为说明</h3>\n<ul>\n<li><strong>类的 <code>typeof</code></strong><br>\n返回的构造函数类型包含：<pre><code class="language-typescript">{\n  <span class="hljs-title function_">new</span>(...args): 实例类型    <span class="hljs-comment">// 构造签名</span>\n  <span class="hljs-keyword">static</span>成员类型            <span class="hljs-comment">// 静态属性和方法</span>\n  <span class="hljs-attr">prototype</span>: 原型方法类型   <span class="hljs-comment">// 实例方法</span>\n}\n</code></pre>\n</li>\n<li><strong>数组的隐藏方法</strong><br>\n虽然 <code>typeof [1,2,3]</code> 显示为 <code>number[]</code>，但实际通过 <code>Array&lt;T&gt;</code> 接口隐式包含所有方法：<pre><code class="language-typescript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];\narr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// ✅ 可用但不在类型显示中</span>\n</code></pre>\n</li>\n<li><strong>与 JavaScript 的区别</strong>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>TypeScript 的 <code>typeof</code></th>\n<th>JavaScript 的 <code>typeof</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>运行时机</strong></td>\n<td>编译时类型检查</td>\n<td>运行时类型判断</td>\n</tr>\n<tr>\n<td><strong>返回值</strong></td>\n<td>TypeScript 类型</td>\n<td><code>&quot;string&quot;</code>/<code>&quot;number&quot;</code> 等字符串</td>\n</tr>\n<tr>\n<td><strong>操作类</strong></td>\n<td>返回构造函数类型</td>\n<td>返回 <code>&quot;function&quot;</code></td>\n</tr>\n</tbody>\n</table>\n</li>\n</ul>\n<h3>3. 实用技巧</h3>\n<ul>\n<li><strong>获取实例类型</strong>  ：结合 <code>InstanceType</code><pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {}\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">PersonInstance</span> = <span class="hljs-title class_">InstanceType</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Person</span>&gt;; <span class="hljs-comment">// =&gt; Person</span>\n</code></pre>\n</li>\n<li><strong>强制显示方法类型</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ExpandedArray</span>&lt;T&gt; = T[] &amp; {\n  <span class="hljs-attr">push</span>: <span class="hljs-function">(<span class="hljs-params">...<span class="hljs-attr">items</span>: T[]</span>) =&gt;</span> <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">pop</span>: <span class="hljs-function">() =&gt;</span> T | <span class="hljs-literal">undefined</span>;\n};\n</code></pre>\n</li>\n<li><strong>类型守卫应用</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isString</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">any</span></span>): x is <span class="hljs-built_in">string</span> {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;string&quot;</span>; <span class="hljs-comment">// 这里用的是 JS 的 typeof</span>\n}\n</code></pre>\n</li>\n</ul>\n<h3>4. 设计原理</h3>\n<p>TypeScript 的 <code>typeof</code> 设计遵循：</p>\n<ol>\n<li><strong>类型空间与值空间分离</strong>  ：类作为值时的 <code>typeof</code> 与作为类型时的行为不同</li>\n<li><strong>简洁性原则</strong>  ：数组等复杂类型默认显示简化形式</li>\n<li><strong>结构化类型系统</strong>  ：通过隐式接口实现类型兼容</li>\n</ol>\n<h3>总结流程图</h3>\n<pre><code class="language-mermaid">graph TD\n    A[typeof 操作] --&gt; B{操作目标}\n    B --&gt;|值| C[返回值的类型注解]\n    B --&gt;|类| D[返回构造函数类型&lt;br&gt;+静态成员+原型链]\n    B --&gt;|数组| E[返回元素类型简写&lt;br&gt;实际包含所有方法]\n    B --&gt;|函数| F[返回函数签名]\n    B --&gt;|枚举| G[返回枚举对象类型]\n</code></pre>\n<p>通过理解这些规则，您可以更精准地利用 <code>typeof</code> 进行类型操作。</p>\n</div>'</script></body></html>