<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x309e(){var s=["W5K0WPVcQSknn8o8DCoAnc0SWP0","FCk6WPTDW7ZdImoBA8oUomkSW5tdOW","dmkHmWSwW4BcVSovW5OzkeZcHa","lIhcHmk+WR0WChm","dMldGCoexsNdVSoqWPK","dgm8tWzjdw3dRmk/","zM7cSmoJB8k8W50","cSoomdbyycHxgtu","gCoNu8keE8ona3BdTCk8kX0","vCkZgmkWWQi","m8kWjSooW6SNW6e3WRaUscddTbC8W6hdUSoPW4SUcxdcVf3cRmoK","DxRdK8oNW7XHl2VdM8kGWPqMlW","W4VcSaxdLCo1qSozAvFcKL/cTW","tCkAeatdSConf8odWRNcO8ku","z8koWR4GWQlcLxpdMZDMWPxdGa","pxDbBSkHzSoKCeNdLdddOG","W6VdQg/cQCo7os0","W7pdT8ktWPdcRhjAySoqWR7dUay","WPfKW5LDzSolgmoeWP9QWR/cNG","WOHiW6fMEmkxlWWLW5ZcRq","z8oYW5dcMahdKSkfWR/dUCokEbOn","W6VdIg7cKXPXqdZdHrXJWPTQ"];return(_0x309e=function(){return s})()}function _0x37f1(o,s){var e=_0x309e();return(_0x37f1=function(s,n){var a=e[s-=241];void 0===_0x37f1.TBEnkW&&(_0x37f1.bOudpp=function(s,n){var a,l=[],o=0,e="";for(s=(s=>{for(var n,a,l="",o="",e=0,r=0;a=s.charAt(r++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,c=l.length;t<c;t++)o+="%"+("00"+l.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(o)})(s),r=0;r<256;r++)l[r]=r;for(r=0;r<256;r++)o=(o+l[r]+n.charCodeAt(r%n.length))%256,a=l[r],l[r]=l[o],l[o]=a;for(var r=0,o=0,t=0;t<s.length;t++)a=l[r=(r+1)%256],l[r]=l[o=(o+l[r])%256],l[o]=a,e+=String.fromCharCode(s.charCodeAt(t)^l[(l[r]+l[o])%256]);return e},o=arguments,_0x37f1.TBEnkW=!0);var s=s+e[0],l=o[s];return l?a=l:(void 0===_0x37f1.gVEEpH&&(_0x37f1.gVEEpH=!0),a=_0x37f1.bOudpp(a,n),o[s]=a),a})(o,s)}var _0x338a82=_0x37f1;if((()=>{for(var s=_0x37f1,n=_0x309e();;)try{if(699268==+parseInt(s(261,"qpw*"))+parseInt(s(248,"FDz3"))/2+-parseInt(s(247,"wt6I"))/3+parseInt(s(242,"s6Ni"))/4+-parseInt(s(254,"Przd"))/5+-parseInt(s(257,"z34^"))/6+parseInt(s(253,"hN*v"))/7*(parseInt(s(259,"p$%H"))/8))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x338a82(252,"*$ZQ")](_0x338a82(250,"0WNf"))!=_0x338a82(255,"6QP("))throw window[_0x338a82(249,"z34^")][_0x338a82(262,"86Su")](_0x338a82(256,"gCdx")),Error();document.title="Symbol.iterator 详解",document.getElementById("article").innerHTML='<div><p><code>Symbol.iterator</code> 是一个内置的 Symbol，用于定义对象的默认迭代器。它是 JavaScript 迭代协议的一部分，使得对象可以被迭代，例如在 <code>for...of</code> 循环中，或者与扩展运算符（<code>...</code>）一起使用。</p>\n<h3><strong>理解 <code>Symbol.iterator</code></strong></h3>\n<ul>\n<li><strong>Symbol 类型</strong>  ：<code>Symbol</code> 是一种原始数据类型，表示独一无二且不可变的标识符。<code>Symbol.iterator</code> 是 JavaScript 中预定义的 Symbol，专门用于定义迭代行为。</li>\n<li><strong>迭代协议</strong>  ：当一个对象实现了 <code>[Symbol.iterator]</code> 方法，它就被认为是可迭代的。这个方法需要返回一个迭代器对象，该对象具有 <code>next()</code> 方法，每次调用 <code>next()</code> 都返回一个结果对象，包含 <code>value</code> 和 <code>done</code> 属性。</li>\n</ul>\n<h3><strong><code>Symbol.iterator</code> 的作用</strong></h3>\n<ol>\n<li><strong>使对象可迭代</strong>  ：通过实现 <code>[Symbol.iterator]</code> 方法，自定义对象可以像数组、字符串、<code>Map</code>、<code>Set</code> 等内置可迭代对象一样被迭代。</li>\n<li><strong>支持迭代语法</strong>  ：可迭代对象可以在 <code>for...of</code> 循环中使用，可以与扩展运算符（<code>...</code>）一起展开，还可以被其他接受迭代器的 API 使用，如 <code>Array.from()</code>。</li>\n</ol>\n<h3><strong>实现 <code>Symbol.iterator</code></strong></h3>\n<h4><strong>示例 1：为自定义类实现迭代器</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRange</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">start, end</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> = start;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">end</span> = end;\n  }\n\n  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() {\n    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span>;\n    <span class="hljs-keyword">const</span> end = <span class="hljs-variable language_">this</span>.<span class="hljs-property">end</span>;\n    <span class="hljs-keyword">return</span> {\n      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) {\n        <span class="hljs-keyword">if</span> (current &lt;= end) {\n          <span class="hljs-keyword">return</span> { <span class="hljs-attr">value</span>: current++, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> };\n        } <span class="hljs-keyword">else</span> {\n          <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> };\n        }\n      }\n    };\n  }\n}\n\n<span class="hljs-keyword">const</span> range = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRange</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);\n\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> range) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 输出: 1 2 3 4 5</span>\n}\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li><code>SimpleRange</code> 类表示一个从 <code>start</code> 到 <code>end</code> 的整数范围。</li>\n<li>实现了 <code>[Symbol.iterator]</code> 方法，返回一个迭代器对象。</li>\n<li>迭代器对象的 <code>next()</code> 方法在每次调用时返回下一个值，直到达到范围的末尾。</li>\n</ul>\n<h4><strong>示例 2：为数组类对象实现迭代器</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> myIterable = {\n  *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() {\n    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;\n    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;\n    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;\n  }\n};\n\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> myIterable) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 输出: 1 2 3</span>\n}\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li><code>myIterable</code> 对象使用生成器函数实现了 <code>[Symbol.iterator]</code> 方法。</li>\n<li>生成器函数使用 <code>yield</code> 关键字依次产生值。</li>\n</ul>\n<h3><strong>内置可迭代对象</strong></h3>\n<p>JavaScript 中的一些内置对象已经默认实现了 <code>Symbol.iterator</code>，包括：</p>\n<ul>\n<li><strong>数组（Array）</strong>  ：遍历数组元素。</li>\n<li><strong>字符串（String）</strong>  ：遍历字符串的字符。</li>\n<li><strong><code>Map</code> 和 <code>Set</code></strong>  ：遍历键值对或集合元素。</li>\n<li><strong><code>TypedArray</code></strong>  ：遍历类型化数组的元素。</li>\n<li><strong><code>arguments</code> 对象</strong>  ：在函数内部，<code>arguments</code> 对象实现了迭代器，允许遍历函数的参数。</li>\n</ul>\n<h3><strong>使用迭代器的优势</strong></h3>\n<ol>\n<li><strong>统一的迭代接口</strong>  ：无论对象的数据结构如何，只要实现了 <code>[Symbol.iterator]</code>，就可以使用相同的迭代语法。</li>\n<li><strong>简化代码</strong>  ：使用 <code>for...of</code> 循环和扩展运算符，可以使代码更简洁、易读。</li>\n<li><strong>支持函数式编程</strong>  ：迭代器与生成器结合，可以方便地实现函数式编程风格，如惰性求值、无限序列等。</li>\n</ol>\n<h3><strong>注意事项</strong></h3>\n<ul>\n<li><strong>迭代器是状态化的</strong>  ：每次调用迭代器的 <code>next()</code> 方法，都会更新其内部状态。</li>\n<li><strong>迭代器的耗尽</strong>  ：一旦迭代器遍历完成，再次调用 <code>next()</code> 将返回 <code>{ done: true }</code>。</li>\n<li><strong>与 <code>for...in</code> 的区别</strong>  ：<code>for...in</code> 循环用于遍历对象的可枚举属性，而不是迭代元素。对于数组和类数组对象，应使用 <code>for...of</code> 或传统的 <code>for</code> 循环。</li>\n</ul>\n<h3><strong>高级用法：自定义迭代逻辑</strong></h3>\n<p>通过实现复杂的 <code>[Symbol.iterator]</code> 方法，可以定义自定义的迭代逻辑。例如，按特定顺序迭代对象属性，或者实现树形结构的遍历。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> tree = {\n  <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,\n  <span class="hljs-attr">children</span>: [\n    { <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">children</span>: [] },\n    { <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">children</span>: [\n      { <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">children</span>: [] }\n    ]}\n  ],\n  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() {\n    <span class="hljs-keyword">const</span> stack = [<span class="hljs-variable language_">this</span>];\n    <span class="hljs-keyword">return</span> {\n      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) {\n        <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span>) {\n          <span class="hljs-keyword">const</span> node = stack.<span class="hljs-title function_">pop</span>();\n          <span class="hljs-keyword">if</span> (node.<span class="hljs-property">children</span>) {\n            <span class="hljs-comment">// 将子节点逆序压入栈中，保证先遍历左子树</span>\n            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = node.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {\n              stack.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">children</span>[i]);\n            }\n          }\n          <span class="hljs-keyword">return</span> { <span class="hljs-attr">value</span>: node.<span class="hljs-property">value</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> };\n        }\n        <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> };\n      }\n    };\n  }\n};\n\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> tree) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 输出: 1 2 3 4</span>\n}\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li><code>tree</code> 对象表示一个简单的树形结构。</li>\n<li>实现了深度优先的迭代器，使用栈来辅助遍历。</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong><code>Symbol.iterator</code> 是迭代协议的核心</strong>  ：它允许对象定义自己的迭代行为，使得对象可以在 <code>for...of</code> 循环等迭代语法中使用。</li>\n<li><strong>实现迭代器需要返回迭代器对象</strong>  ：该对象必须具有 <code>next()</code> 方法，返回包含 <code>value</code> 和 <code>done</code> 属性的结果对象。</li>\n<li><strong>迭代器的应用广泛</strong>  ：从简单的数组遍历到复杂的树形结构遍历，迭代器提供了一种统一且强大的迭代机制。</li>\n<li><strong>理解迭代器的原理</strong>  ：有助于编写更灵活、可复用的代码，提升对 JavaScript 异步编程和函数式编程的理解。</li>\n</ul>\n</div>'</script></body></html>