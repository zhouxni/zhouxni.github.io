<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0xdf5f(c,s){var o=_0x28a7();return(_0xdf5f=function(s,n){var a=o[s-=419];void 0===_0xdf5f.eDnPHv&&(_0xdf5f.gTpMYv=function(s,n){var a,t=[],c=0,o="";for(s=(s=>{for(var n,a,t="",c="",o=0,e=0;a=s.charAt(e++);~a&&(n=o%4?64*n+a:a,o++%4)&&(t+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var l=0,r=t.length;l<r;l++)c+="%"+("00"+t.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(c)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)c=(c+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[c],t[c]=a;for(var e=0,c=0,l=0;l<s.length;l++)a=t[e=(e+1)%256],t[e]=t[c=(c+t[e])%256],t[c]=a,o+=String.fromCharCode(s.charCodeAt(l)^t[(t[e]+t[c])%256]);return o},c=arguments,_0xdf5f.eDnPHv=!0);var s=s+o[0],t=c[s];return t?a=t:(void 0===_0xdf5f.ikJwRf&&(_0xdf5f.ikJwRf=!0),a=_0xdf5f.gTpMYv(a,n),c[s]=a),a})(c,s)}var _0x5b3604=_0xdf5f;function _0x28a7(){var s=["EmkOgZP7WRpcTmkZffe","W7dcQ8kHbIGlWRzEE8kIaK0","xSkFW7pcGCk7WQhcM1O2Adu+sG","lSkxFtygW5idlh7cVW","W7/cRmkPcYCjW4TIDCkFnMldHa","W5NdQmkvtmoqWPBdOc3dOsr3","W4vRwLBdJCkqW5JdTq","DSoWW4BdIG/dMwSOs8kh","WPGQW6BdVmkvW5neW5BdOxW9WOdcKCk/","W5hcKCo8jJ9hW4uk","zYFdPwRcGCoLW5hdOSk2htLp","WPOVW6ldVSkzWQycWQ3dIxWd","WRJdKSoRW5ldNG","wWxdT8oCFfqfjmokWQpcI8kqWOigeCoIWOzinCkjW7NdMWxdGSkita","a8o5Dxv6W4ddTmkhW58B","WRT+WQNdPmogWRhdHCopsCofoG","oMldSMDFWRBdNSk9r3WKAui","WPFdGSo+jazRW5K","aKhcTCkBoIXEq8oxWRlcQa","FxFcGSkdk8oyCu9sW4lcJSouDa","EcyBW4W2jIyT","hmoQWOJdQSokpmoQ","W6P8WRFcRmoFWPC9WOddLW","WRFdTSosWRtdGLJdTdO+WRDBW5zvW4m"];return(_0x28a7=function(){return s})()}if((()=>{for(var s=_0xdf5f,n=_0x28a7();;)try{if(779570==-parseInt(s(435,"avn&"))*(parseInt(s(436,"c@3^"))/2)+parseInt(s(440,"LNLj"))/3+-parseInt(s(430,"hdGa"))/4*(parseInt(s(424,"f*g$"))/5)+-parseInt(s(425,"m%Ox"))/6+-parseInt(s(437,"81TA"))/7+-parseInt(s(432,")r)6"))/8+parseInt(s(438,"H!lD"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5b3604(427,"Y6XI")](_0x5b3604(428,"H!lD"))!=_0x5b3604(442,"6TUO"))throw window[_0x5b3604(426,"UKGi")][_0x5b3604(423,"*Epf")](_0x5b3604(419,"f*g$")),new Error;document.title="JavaScript 混淆加密",document.getElementById("article").innerHTML='<div><p>JavaScript 混淆（Obfuscation）是通过转换代码结构来保护 JavaScript 代码的技术，使其难以被逆向工程或理解，同时保持功能不变。<code>javascript-obfuscator</code> 是目前最流行的 JavaScript 混淆工具之一，它提供了多种混淆策略，能有效提高代码的安全性。</p>\n<h3>一、核心混淆技术原理</h3>\n<p><code>javascript-obfuscator</code> 主要通过以下手段对代码进行混淆：</p>\n<ol>\n<li>\n<p><strong>变量/函数名混淆</strong><br>\n将有意义的变量名（如 <code>userName</code>、<code>calculateTotal</code>）替换为无意义的字符（如 <code>a</code>、<code>_0x123b</code>），破坏代码的可读性。<br>\n示例：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 原始代码</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateTotal</span>(<span class="hljs-params">price, quantity</span>) {\n  <span class="hljs-keyword">return</span> price * quantity;\n}\n\n<span class="hljs-comment">// 混淆后</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">_0x1a2b</span>(<span class="hljs-params">_0x3c4d, _0x5e6f</span>) {\n  <span class="hljs-keyword">return</span> _0x3c4d * _0x5e6f;\n}\n</code></pre>\n</li>\n<li>\n<p><strong>字符串加密</strong><br>\n对代码中的字符串（如 <code>&quot;https://api.example.com&quot;</code>）进行加密（如 Base64、RC4），并在运行时动态解密，防止直接读取敏感字符串。<br>\n示例：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 原始代码</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);\n\n<span class="hljs-comment">// 混淆后（伪代码）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">decrypt</span>(<span class="hljs-params">str</span>) {\n  <span class="hljs-comment">/* 解密逻辑 */</span>\n}\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">decrypt</span>(<span class="hljs-string">&quot;SGVsbG8gV29ybGQ=&quot;</span>));\n</code></pre>\n</li>\n<li>\n<p><strong>控制流平坦化（Control Flow Flattening）</strong><br>\n将线性的代码执行流程打乱，转化为通过分支跳转（如 <code>switch-case</code>）实现的非线性结构，使代码执行逻辑难以追踪。<br>\n示例：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 原始代码</span>\na = <span class="hljs-number">1</span>;\nb = <span class="hljs-number">2</span>;\nc = a + b;\n\n<span class="hljs-comment">// 混淆后（伪代码）</span>\n<span class="hljs-keyword">let</span> state = <span class="hljs-number">0</span>;\n<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n  <span class="hljs-keyword">switch</span> (state) {\n    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:\n      a = <span class="hljs-number">1</span>;\n      state = <span class="hljs-number">1</span>;\n      <span class="hljs-keyword">break</span>;\n    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:\n      b = <span class="hljs-number">2</span>;\n      state = <span class="hljs-number">2</span>;\n      <span class="hljs-keyword">break</span>;\n    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:\n      c = a + b;\n      state = <span class="hljs-number">3</span>;\n      <span class="hljs-keyword">break</span>;\n    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:\n      <span class="hljs-keyword">break</span>;\n  }\n}\n</code></pre>\n</li>\n<li>\n<p><strong>死代码注入</strong><br>\n添加不影响执行结果的冗余代码（如无意义的条件判断、空函数），增加代码体积并干扰分析工具。</p>\n</li>\n<li>\n<p><strong>数字转换</strong><br>\n将数字常量（如 <code>100</code>）转换为表达式（如 <code>0x64</code>、<code>50*2</code>），进一步隐藏原始逻辑。</p>\n</li>\n<li>\n<p><strong>标识符污染</strong><br>\n生成大量相似的变量名（如 <code>_0x123</code>、<code>_0x124</code>），增加人工识别难度。</p>\n</li>\n</ol>\n<h3>二、<code>javascript-obfuscator</code> 关键配置</h3>\n<p>该工具通过配置选项控制混淆强度和策略，常用配置包括：</p>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>作用说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>compact</code></td>\n<td>压缩代码（移除空格、换行），默认 <code>true</code></td>\n</tr>\n<tr>\n<td><code>controlFlowFlattening</code></td>\n<td>启用控制流平坦化，增强混淆强度，默认 <code>false</code>（启用会降低性能）</td>\n</tr>\n<tr>\n<td><code>stringArray</code></td>\n<td>收集字符串并加密存储，默认 <code>true</code></td>\n</tr>\n<tr>\n<td><code>stringArrayEncoding</code></td>\n<td>字符串加密方式（<code>base64</code>/<code>rc4</code>），<code>rc4</code> 安全性更高但性能开销大</td>\n</tr>\n<tr>\n<td><code>rotateStringArray</code></td>\n<td>打乱字符串数组顺序，增加破解难度，默认 <code>true</code></td>\n</tr>\n<tr>\n<td><code>deadCodeInjection</code></td>\n<td>注入死代码，默认 <code>false</code>（启用会增加代码体积）</td>\n</tr>\n<tr>\n<td><code>debugProtection</code></td>\n<td>防止调试（如检测 <code>debugger</code> 语句），默认 <code>false</code></td>\n</tr>\n<tr>\n<td><code>disableConsoleOutput</code></td>\n<td>禁用 <code>console.log</code> 等输出，保护调试信息</td>\n</tr>\n</tbody>\n</table>\n<h3>三、使用示例</h3>\n<p>通过 Node.js 调用 <code>javascript-obfuscator</code> 进行混淆：</p>\n<ol>\n<li>\n<p>安装工具：</p>\n<pre><code class="language-bash">npm install javascript-obfuscator --save-dev\n</code></pre>\n</li>\n<li>\n<p>编写脚本（<code>obfuscate.js</code>）：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obfuscator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;javascript-obfuscator&quot;</span>);\n<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);\n\n<span class="hljs-comment">// 读取原始代码</span>\n<span class="hljs-keyword">const</span> code = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;source.js&quot;</span>, <span class="hljs-string">&quot;utf8&quot;</span>);\n\n<span class="hljs-comment">// 配置混淆选项</span>\n<span class="hljs-keyword">const</span> options = {\n  <span class="hljs-attr">compact</span>: <span class="hljs-literal">true</span>,\n  <span class="hljs-attr">controlFlowFlattening</span>: <span class="hljs-literal">true</span>,\n  <span class="hljs-attr">stringArray</span>: <span class="hljs-literal">true</span>,\n  <span class="hljs-attr">stringArrayEncoding</span>: <span class="hljs-string">&quot;rc4&quot;</span>,\n  <span class="hljs-attr">debugProtection</span>: <span class="hljs-literal">true</span>,\n};\n\n<span class="hljs-comment">// 执行混淆</span>\n<span class="hljs-keyword">const</span> obfuscatedCode = obfuscator\n  .<span class="hljs-title function_">obfuscate</span>(code, options)\n  .<span class="hljs-title function_">getObfuscatedCode</span>();\n\n<span class="hljs-comment">// 保存混淆后的代码</span>\nfs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">&quot;obfuscated.js&quot;</span>, obfuscatedCode);\n</code></pre>\n</li>\n<li>\n<p>运行脚本：</p>\n<pre><code class="language-bash">node obfuscate.js\n</code></pre>\n</li>\n</ol>\n<h3>四、局限性与应对</h3>\n<p>尽管 <code>javascript-obfuscator</code> 能有效提高逆向难度，但并非绝对安全：</p>\n<ul>\n<li><strong>性能损耗</strong>   ：复杂混淆（如控制流平坦化）会降低代码执行效率（约 10%-50%）。</li>\n<li><strong>可逆性</strong>   ：专业逆向工程师可通过静态分析（如还原变量名）或动态调试（如 Hook 解密函数）破解。</li>\n<li><strong>兼容性问题</strong>   ：过度混淆可能导致部分浏览器或环境报错。</li>\n</ul>\n<p><strong>应对建议</strong>   ：</p>\n<ul>\n<li>根据需求平衡混淆强度与性能（如生产环境启用核心混淆，开发环境禁用）。</li>\n<li>结合其他保护手段（如代码分片、服务器端渲染、使用 WebAssembly 替代核心逻辑）。</li>\n</ul>\n<h3>五、总结</h3>\n<p><code>javascript-obfuscator</code> 是前端代码保护的实用工具，通过多种技术手段显著提高了代码的逆向门槛。但需注意，混淆仅是安全防护的一层，不能替代完整的安全策略。在实际应用中，应根据业务需求选择合适的混淆配置，并结合其他安全措施保障代码安全。</p>\n</div>'</script></body></html>