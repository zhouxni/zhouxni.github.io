<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x87d8e0=_0x9542;function _0xd552(){var s=["W7BdPCo8WO4+a8ouluy5W4viW4O","W7j9WPVdN8kLWQ7cVW","F3NdImkCWPtcLmkxWQ4","qSofW4PwnqBcH2VdPmo1W5dcSq","W7ddPSoXWOGWamkkdgWEW79l","W5BcUmohFSkti8km","nCoosJtcVmojaa/cTM/dOConW6xcIa","W7SKW4/cPmoyW5dcH2JdJq/dPSol","W5CXyuNdPJtcL1O","WO/dT8kJyHOfWOBdUX7dR8kBbCkL","xb1KW7WjoCkedxdcVmkQWQeE","mI7cV1KsWOtdT8oA","rL9Ue1aAxCopW4ddO3me","tCk1WR7cRCk9nmkloSkecMBcRa","p0e7WO/dKeWmWQuSWQyvWQW","WPvRW5mTW5VdScbWDwRdMh9JW7xdG8kEC2JdJmowW7xdVSo0WPHlW4W","DLL1rr9LWR/dPHldN8krW6S","cCoLW5bKnYpdLmon","uKykW7CUoCoK","W4y2W5LKdCouW4uQWPq0WOSMWPe","xrPUW70koCoDlexcImkcWRK","WOT/WPNdS8kAWPhcGxVdRa","FsxdSYxdUYJdSmoD","wSopnrZdVG","dN5AW6jmeJTAmmkEW4FcUCk4Dq","bYOpWPWZBNS","W7TMlwL3WRXv","BZtdOLHebmkH"];return(_0xd552=function(){return s})()}function _0x9542(l,s){var p=_0xd552();return(_0x9542=function(s,n){var a=p[s-=427];void 0===_0x9542.wtRgTi&&(_0x9542.nIdClq=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,r=t.length;o<r;o++)l+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,o=0;o<s.length;o++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(o)^t[(t[e]+t[l])%256]);return p},l=arguments,_0x9542.wtRgTi=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x9542.PPKVdr&&(_0x9542.PPKVdr=!0),a=_0x9542.nIdClq(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x9542,n=_0xd552();;)try{if(235652==-parseInt(s(434,"Bxkk"))+-parseInt(s(453,"1nde"))/2+-parseInt(s(427,"*[N@"))/3*(-parseInt(s(429,"SuAD"))/4)+-parseInt(s(452,"NFqJ"))/5*(parseInt(s(435,"*la1"))/6)+-parseInt(s(441,"%]ck"))/7+-parseInt(s(447,"h&Jl"))/8*(parseInt(s(450,"ui%W"))/9)+parseInt(s(428,"R!&0"))/10*(parseInt(s(430,"chu8"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x87d8e0(440,"aH4%")](_0x87d8e0(443,"SuAD"))!=_0x87d8e0(445,"pU8X"))throw window[_0x87d8e0(433,"*I6g")][_0x87d8e0(448,"CtG^")](_0x87d8e0(437,"7DM7")),Error();document.title="Next.js 路由跳转",document.getElementById("article").innerHTML='<div><p>在 Next.js 中，路由跳转是核心功能之一，支持多种导航方式。以下是 <strong>Next.js 14</strong>   （基于 App Router）和 <strong>Pages Router</strong>   两种模式下的路由跳转方法详解：</p>\n<hr>\n<h3><strong>一、App Router（Next.js 13/14 推荐）</strong></h3>\n<h4>1. <strong><code>&lt;Link&gt;</code> 组件跳转（客户端导航，推荐）</strong></h4>\n<pre><code class="language-tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Link</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/link&#x27;</span>;\n\n<span class="hljs-comment">// 基本跳转</span>\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>关于我们<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span>\n\n<span class="hljs-comment">// 动态路由跳转</span>\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">{</span>`/<span class="hljs-attr">posts</span>/${<span class="hljs-attr">postId</span>}`}&gt;</span>查看详情<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span>\n\n<span class="hljs-comment">// 附加属性（如 className、滚动复位等）</span>\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span>\n  <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/contact&quot;</span>\n  <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;text-blue-500&quot;</span>\n  <span class="hljs-attr">scroll</span>=<span class="hljs-string">{false}</span> // <span class="hljs-attr">禁止滚动到顶部</span>\n&gt;</span>\n  联系我们\n<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span>\n</code></pre>\n<p><strong>特点</strong>   ：</p>\n<ul>\n<li>客户端导航（无页面刷新），提升用户体验。</li>\n<li>自动预加载 <code>href</code> 路径的资源（生产环境默认开启）。</li>\n</ul>\n<hr>\n<h4>2. <strong><code>useRouter</code> 编程式跳转</strong></h4>\n<pre><code class="language-tsx"><span class="hljs-string">&quot;use client&quot;</span>; <span class="hljs-comment">// 必须在客户端组件中使用</span>\n<span class="hljs-keyword">import</span> { useRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/navigation&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>();\n\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-comment">// 基本跳转</span>\n    router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;/dashboard&quot;</span>);\n\n    <span class="hljs-comment">// 动态路由跳转</span>\n    router.<span class="hljs-title function_">push</span>(<span class="hljs-string">`/user/<span class="hljs-subst">${userId}</span>`</span>);\n\n    <span class="hljs-comment">// 替换当前路由（不保留历史记录）</span>\n    router.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;/login&quot;</span>);\n\n    <span class="hljs-comment">// 控制滚动行为</span>\n    router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;/settings&quot;</span>, { <span class="hljs-attr">scroll</span>: <span class="hljs-literal">false</span> });\n  };\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>跳转<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n</code></pre>\n<p><strong>特点</strong>   ：</p>\n<ul>\n<li>适合表单提交后跳转等逻辑场景。</li>\n<li><code>replace</code> 方法适用于登录后重定向（避免用户回退到登录页）。</li>\n</ul>\n<hr>\n<h4>3. <strong>重定向（服务端组件）</strong></h4>\n<p>在服务端组件（Server Component）中使用：</p>\n<pre><code class="language-tsx"><span class="hljs-keyword">import</span> { redirect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/navigation&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-title function_">redirect</span>(<span class="hljs-string">&quot;/login&quot;</span>); <span class="hljs-comment">// 服务端直接重定向</span>\n}\n</code></pre>\n<p><strong>适用场景</strong>   ：</p>\n<ul>\n<li>权限校验未通过时直接跳转。</li>\n<li>旧路径永久迁移到新路径。</li>\n</ul>\n<hr>\n<h4>4. <strong>路由拦截（Middleware）</strong></h4>\n<p>通过中间件实现全局路由控制：</p>\n<pre><code class="language-ts"><span class="hljs-comment">// middleware.ts</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/server&quot;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">NextRequest</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/server&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params"><span class="hljs-attr">request</span>: <span class="hljs-title class_">NextRequest</span></span>) {\n  <span class="hljs-keyword">if</span> (!request.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">has</span>(<span class="hljs-string">&quot;auth&quot;</span>)) {\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">redirect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&quot;/login&quot;</span>, request.<span class="hljs-property">url</span>));\n  }\n  <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>();\n}\n</code></pre>\n<p><strong>作用</strong>   ：</p>\n<ul>\n<li>实现 A/B 测试、身份验证、地域限制等。</li>\n</ul>\n<hr>\n<h3><strong>二、Pages Router（传统模式）</strong></h3>\n<h4>1. <strong><code>&lt;Link&gt;</code> 组件</strong></h4>\n<pre><code class="language-tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Link</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/link&quot;</span>;\n\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>关于我们<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span>;\n</code></pre>\n<h4>2. <strong><code>useRouter</code> 编程式跳转</strong></h4>\n<pre><code class="language-tsx"><span class="hljs-keyword">import</span> { useRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/router&quot;</span>;\n\n<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>();\nrouter.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;/profile&quot;</span>); <span class="hljs-comment">// 跳转</span>\nrouter.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;/home&quot;</span>); <span class="hljs-comment">// 替换</span>\n</code></pre>\n<h4>3. <strong>服务端重定向（SSR/API Routes）</strong></h4>\n<pre><code class="language-ts"><span class="hljs-comment">// pages/api/login.ts</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handler</span>(<span class="hljs-params">req, res</span>) {\n  res.<span class="hljs-title function_">redirect</span>(<span class="hljs-number">302</span>, <span class="hljs-string">&quot;/dashboard&quot;</span>);\n}\n</code></pre>\n<hr>\n<h3><strong>三、关键区别（App Router vs Pages Router）</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>App Router (Next.js 13+)</th>\n<th>Pages Router (传统)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>组件位置</strong></td>\n<td><code>app/about/page.tsx</code></td>\n<td><code>pages/about.tsx</code></td>\n</tr>\n<tr>\n<td><strong>路由钩子</strong></td>\n<td><code>useRouter</code> from <code>next/navigation</code></td>\n<td><code>useRouter</code> from <code>next/router</code></td>\n</tr>\n<tr>\n<td><strong>服务端组件支持</strong></td>\n<td>✅ 是</td>\n<td>❌ 否</td>\n</tr>\n<tr>\n<td><strong>动态路由</strong></td>\n<td><code>app/user/[id]/page.tsx</code></td>\n<td><code>pages/user/[id].tsx</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>四、最佳实践</strong></h3>\n<ol>\n<li>\n<p><strong>优先使用 <code>&lt;Link&gt;</code></strong><br>\n客户端导航提升性能，避免整页刷新。</p>\n</li>\n<li>\n<p><strong>动态路由参数获取</strong></p>\n<pre><code class="language-tsx"><span class="hljs-comment">// App Router:</span>\n<span class="hljs-keyword">const</span> { id } = params; <span class="hljs-comment">// 从服务端组件参数获取</span>\n\n<span class="hljs-comment">// Pages Router:</span>\n<span class="hljs-keyword">const</span> { query } = <span class="hljs-title function_">useRouter</span>(); <span class="hljs-comment">// 客户端获取</span>\n</code></pre>\n</li>\n<li>\n<p><strong>处理加载状态</strong></p>\n<pre><code class="language-tsx"><span class="hljs-keyword">import</span> { usePathname } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/navigation&quot;</span>;\n\n<span class="hljs-keyword">const</span> pathname = <span class="hljs-title function_">usePathname</span>();\n<span class="hljs-keyword">if</span> (pathname === <span class="hljs-string">&quot;/loading&quot;</span>) <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Spinner</span> /&gt;</span></span>;\n</code></pre>\n</li>\n<li>\n<p><strong>SEO 优化</strong><br>\n对关键页面使用服务端重定向（<code>redirect</code>），确保搜索引擎索引正确路径。</p>\n</li>\n</ol>\n<hr>\n<p>通过以上方法，你可以灵活控制 Next.js 应用的路由跳转逻辑。如果需要更复杂的路由管理（如动画过渡），可结合 <code>framer-motion</code> 等库实现。</p>\n</div>'</script></body></html>