<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3011(l,n){var s=_0x15af();return(_0x3011=function(n,r){var o=s[n-=396];void 0===_0x3011.urVCKA&&(_0x3011.bivPqa=function(n,r){var o,t=[],l=0,s="";for(n=(n=>{for(var r,o,t="",l="",s=0,g=0;o=n.charAt(g++);~o&&(r=s%4?64*r+o:o,s++%4)&&(t+=String.fromCharCode(255&r>>(-2*s&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var i=0,e=t.length;i<e;i++)l+="%"+("00"+t.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(l)})(n),g=0;g<256;g++)t[g]=g;for(g=0;g<256;g++)l=(l+t[g]+r.charCodeAt(g%r.length))%256,o=t[g],t[g]=t[l],t[l]=o;for(var g=0,l=0,i=0;i<n.length;i++)o=t[g=(g+1)%256],t[g]=t[l=(l+t[g])%256],t[l]=o,s+=String.fromCharCode(n.charCodeAt(i)^t[(t[g]+t[l])%256]);return s},l=arguments,_0x3011.urVCKA=!0);var n=n+s[0],t=l[n];return t?o=t:(void 0===_0x3011.VgNJng&&(_0x3011.VgNJng=!0),o=_0x3011.bivPqa(o,r),l[n]=o),o})(l,n)}function _0x15af(){var n=["m33dRLFcPfXqW79nW73cGa","W6jEW6PJWPxcLuJcPZaLutRdSq","iSkZgMepFCkb","W5usAeyTWQjeFCkjWQldTSk+","rILiWOVdGwzB","m3ZdRvtcOefpW7n4W4dcQG","nvylWQPIW7GpWPlcLmk1WPhdG8kR","lSkxbmk9jGJcH8kzDW","WQvdW60VWPmtWRrZdeiNg8kz","WOhdJfnjWPBcNCkqW4JdGCoqrq","mxNdRvtcPtGQW5j6W5VcGs46","W6ZdOCo/BeiSWOhdJ8oCWQBdMa","oYldKeH1W4bpCG","C8kLAcpcOSk9gmoTWPPpWR5B","W61SWOdcV1O","fKtcLh8ksqi8nbu","W5FcNXmXW5FcTCkR","fCo/smk5uwFdLmkrWR3cO8oBfSoI","n8k7WQddTWeiWROi","zbtdGsOJwb8saW","WQLnWPhcP1SttW","WPZcPSoXwSk0s2NcN8oiW4G","mmkwWO15EmkOemo6W4X6WQjoW5S","WQtcG1WLlMFcIrPZW7FdStJcPYNdJCkhh8odcCkJWO4KW7FdNmkgAq","vMldRSoGtupcUrTeWRtcJJm9","q8oeW68Hg8onkbFdKG","EMGIqbBdShRcK8oipSoeAvG"];return(_0x15af=function(){return n})()}var _0x5d3f20=_0x3011;if((()=>{for(var n=_0x3011,r=_0x15af();;)try{if(627446==-parseInt(n(417,"CYbH"))+parseInt(n(404,"j8h9"))/2+-parseInt(n(397,"pC7T"))/3*(-parseInt(n(418,"mgI%"))/4)+parseInt(n(419,"pC7T"))/5*(-parseInt(n(412,"$55O"))/6)+-parseInt(n(420,"iZU*"))/7+parseInt(n(402,"YfU*"))/8*(parseInt(n(398,"vp(2"))/9)+parseInt(n(413,"5w[N"))/10*(-parseInt(n(405,"3]x1"))/11))break;r.push(r.shift())}catch(n){r.push(r.shift())}})(),localStorage[_0x5d3f20(403,"#3Rv")](_0x5d3f20(406,"YfU*"))!=_0x5d3f20(401,"V%gQ"))throw window[_0x5d3f20(399,"XyKa")][_0x5d3f20(416,"MY#*")](_0x5d3f20(410,"&A6g")),Error();document.title="浏览器垃圾回收机制",document.getElementById("article").innerHTML="<div><p>浏览器的回收机制主要指的是<strong>垃圾回收机制（Garbage Collection, GC）</strong>  ，这是浏览器内存管理的重要组成部分。以下是对浏览器回收机制的全面、深入解析：</p>\n<hr>\n<h3><strong>一、为什么需要垃圾回收机制？</strong></h3>\n<p>在 JavaScript 中，开发者不需要手动管理内存（如 C/C++ 中的 <code>malloc</code> 和 <code>free</code>），浏览器通过垃圾回收机制自动管理内存：</p>\n<ul>\n<li><strong>自动分配内存</strong>  ：当创建对象、数组或函数时，浏览器自动分配内存。</li>\n<li><strong>自动释放内存</strong>  ：当对象不再被引用时，浏览器自动回收其占用的内存。</li>\n</ul>\n<hr>\n<h3><strong>二、垃圾回收机制的核心原理</strong></h3>\n<p>垃圾回收机制的核心是<strong>识别并回收不再被引用的内存</strong>  ，主要基于以下概念：</p>\n<ol>\n<li><strong>可达性（Reachability）</strong>  ：\n<ul>\n<li>如果一个对象可以通过根对象（如全局对象、当前执行上下文等）访问，则它是可达的。</li>\n<li>不可达的对象被视为垃圾，可以被回收。</li>\n</ul>\n</li>\n<li><strong>标记-清除算法（Mark-and-Sweep）</strong>  ：\n<ul>\n<li><strong>标记阶段</strong>  ：从根对象开始，遍历所有可达对象，并标记为“存活”。</li>\n<li><strong>清除阶段</strong>  ：遍历堆内存，回收未被标记的对象。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>三、V8 引擎的垃圾回收机制</strong></h3>\n<p>V8 引擎（Chrome 和 Node.js 使用的 JavaScript 引擎）采用了分代垃圾回收机制，将内存分为<strong>新生代</strong>  和<strong>老生代</strong>  ，分别使用不同的回收策略：</p>\n<h4><strong>1. 新生代（Young Generation）</strong></h4>\n<ul>\n<li><strong>特点</strong>  ：存储生命周期较短的对象。</li>\n<li><strong>算法</strong>  ：使用 <strong>Scavenge 算法</strong>  ，基于复制的方式。\n<ul>\n<li><strong>From 空间</strong>  和<strong>To 空间</strong>  ：对象首先分配在 From 空间，当 From 空间满时，存活对象被复制到 To 空间，然后清空 From 空间。</li>\n<li><strong>频繁回收</strong>  ：新生代垃圾回收频繁，但每次回收的时间短。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>2. 老生代（Old Generation）</strong></h4>\n<ul>\n<li><strong>特点</strong>  ：存储生命周期较长的对象。</li>\n<li><strong>算法</strong>  ：主要使用 <strong>Mark-Sweep 算法</strong>  ，并辅以 <strong>Mark-Compact 算法</strong>  。\n<ul>\n<li><strong>Mark-Sweep</strong>  ：标记存活对象，清除未标记对象。</li>\n<li><strong>Mark-Compact</strong>  ：在内存碎片较多时，将存活对象移动到一端，整理内存空间。</li>\n<li><strong>回收频率低</strong>  ：老生代垃圾回收较少，但每次回收的时间较长。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>四、增量垃圾回收（Incremental Garbage Collection）</strong></h3>\n<p>为了减少垃圾回收对应用性能的影响，V8 引擎采用了增量垃圾回收：</p>\n<ul>\n<li><strong>分步骤执行</strong>  ：将垃圾回收任务拆分为多个小步骤，穿插在 JavaScript 代码执行之间。</li>\n<li><strong>减少停顿时间</strong>  ：避免长时间阻塞主线程，提高应用的响应速度。</li>\n</ul>\n<hr>\n<h3><strong>五、内存泄漏与避免方法</strong></h3>\n<p>尽管有垃圾回收机制，但不当的编程习惯仍可能导致<strong>内存泄漏</strong>  ：</p>\n<ol>\n<li><strong>全局变量</strong>  ：\n<ul>\n<li>未声明的变量会成为全局变量，无法被回收。</li>\n<li><strong>避免方法</strong>  ：使用 <code>let</code>、<code>const</code> 或 <code>var</code> 声明变量，避免意外创建全局变量。</li>\n</ul>\n</li>\n<li><strong>闭包</strong>  ：\n<ul>\n<li>闭包会引用外部函数的变量，可能导致这些变量无法被回收。</li>\n<li><strong>避免方法</strong>  ：在不需要时手动将变量设为 <code>null</code>，断开引用。</li>\n</ul>\n</li>\n<li><strong>事件监听器</strong>  ：\n<ul>\n<li>未移除的事件监听器会一直存在，导致内存泄漏。</li>\n<li><strong>避免方法</strong>  ：在不需要时移除事件监听器。</li>\n</ul>\n</li>\n<li><strong>DOM 引用</strong>  ：\n<ul>\n<li>移除 DOM 元素时，如果仍有 JavaScript 引用，会导致内存泄漏。</li>\n<li><strong>避免方法</strong>  ：在移除 DOM 元素时，同时清除相关的 JavaScript 引用。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>六、开发者工具与内存优化</strong></h3>\n<ol>\n<li><strong>Chrome DevTools</strong>  ：\n<ul>\n<li><strong>Memory 面板</strong>  ：用于分析内存使用情况，检测内存泄漏。</li>\n<li><strong>Heap Snapshot</strong>  ：拍摄堆内存快照，查看对象分配情况。</li>\n</ul>\n</li>\n<li><strong>性能优化建议</strong>  ：\n<ul>\n<li><strong>避免创建不必要的对象</strong>  ：重用对象，减少内存分配。</li>\n<li><strong>及时清理引用</strong>  ：在对象不再需要时，手动断开引用。</li>\n<li><strong>使用 WeakMap 和 WeakSet</strong>  ：存储弱引用，不会阻止垃圾回收。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>七、总结</strong></h3>\n<ul>\n<li><strong>自动管理内存</strong>  ：浏览器的垃圾回收机制自动管理内存分配和释放，开发者无需手动干预。</li>\n<li><strong>分代回收</strong>  ：V8 引擎采用分代垃圾回收，针对新生代和老生代使用不同的回收策略。</li>\n<li><strong>避免内存泄漏</strong>  ：注意编程习惯，避免创建全局变量、未移除的事件监听器等。</li>\n<li><strong>利用开发者工具</strong>  ：使用 Chrome DevTools 分析内存使用情况，优化应用性能。</li>\n</ul>\n<hr>\n<h3><strong>类比说明</strong></h3>\n<p>可以将浏览器的垃圾回收机制类比为城市的垃圾处理系统：</p>\n<ul>\n<li><strong>垃圾收集车</strong>  ：定期收集垃圾（垃圾回收器）。</li>\n<li><strong>垃圾处理厂</strong>  ：对垃圾进行分类和处理（标记-清除或标记-整理）。</li>\n<li><strong>居民</strong>  ：创建垃圾（开发者创建对象）。</li>\n<li><strong>可回收物</strong>  ：仍被引用的对象（存活对象）。</li>\n<li><strong>不可回收物</strong>  ：不再被引用的对象（垃圾对象）。</li>\n</ul>\n<p>通过这个类比，可以更容易理解垃圾回收机制的工作原理和重要性。</p>\n</div>"</script></body></html>