<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1a97(o,n){var t=_0x5f53();return(_0x1a97=function(n,s){var a=t[n-=361];void 0===_0x1a97.gIfdIX&&(_0x1a97.bazLJN=function(n,s){var a,e=[],o=0,t="";for(n=(n=>{for(var s,a,e="",o="",t=0,l=0;a=n.charAt(l++);~a&&(s=t%4?64*s+a:a,t++%4)&&(e+=String.fromCharCode(255&s>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,c=e.length;r<c;r++)o+="%"+("00"+e.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(o)})(n),l=0;l<256;l++)e[l]=l;for(l=0;l<256;l++)o=(o+e[l]+s.charCodeAt(l%s.length))%256,a=e[l],e[l]=e[o],e[o]=a;for(var l=0,o=0,r=0;r<n.length;r++)a=e[l=(l+1)%256],e[l]=e[o=(o+e[l])%256],e[o]=a,t+=String.fromCharCode(n.charCodeAt(r)^e[(e[l]+e[o])%256]);return t},o=arguments,_0x1a97.gIfdIX=!0);var n=n+t[0],e=o[n];return e?a=e:(void 0===_0x1a97.ADVaVt&&(_0x1a97.ADVaVt=!0),a=_0x1a97.bazLJN(a,s),o[n]=a),a})(o,n)}var _0x22920c=_0x1a97;function _0x5f53(){var n=["W4BcOSkwlmooCfiZW7ddS1LqDG","WODgrrhdSCorWO/cUSkj","W5v7C8oFWQ9xf8kjtCkXiay","WRtdS8ofF8klnIWmW4a","g3uAW7xdLeddOb9CWQBcQaxdHCkw","WQiFW6VdSHdcKCozr0K","gtv4ySkh","W6SzW7WfWQRcSfH/","BdemW6ddGa7cHcldQ8kVz8oF","W5DtWPRdTCoLvCohWQ3cKG","ne3dLuviWPxdNa","FSkfWOjdW4TDW4WeW5GP","BqlcHmkZpmoWyIrX","wxpdM2fIpSkNtWNdImodvhOXWPuahqDmW7DAt15lfSoV","W6HVW58zW7XEW7NcImoREqC6W5i","FCkeWO84W71fW50UW4G","WRBdKCohWPiTt8kEgrSP","CmorW59iw8oTWPFcPd/dSZVcJq","iSkphYlcOJCmWRldHhxcGG","o3BdV2xdSCkuW5TSWRuPW4ZdSGy","WQddJXBdUZ3cTv3dKmk+W6DLda","WQyDW6xcLwZdPCkdwgX3sCoToq","qeWgs8knWPxcHq","ECkaWOKsW7D6W4CyW6a","WRzdWQ1sW6JdQaCHW5DTnHxcVHq","WQpcUqhcVG3dTgvLzSkIfq"];return(_0x5f53=function(){return n})()}if((()=>{for(var n=_0x1a97,s=_0x5f53();;)try{if(550189==-parseInt(n(361,"!@AR"))+parseInt(n(372,"SPH$"))/2*(parseInt(n(378,"w7J*"))/3)+parseInt(n(362,"SPH$"))/4+-parseInt(n(384,"$K^W"))/5*(parseInt(n(364,"w7J*"))/6)+-parseInt(n(385,"NnXi"))/7*(parseInt(n(376,"$&7y"))/8)+-parseInt(n(386,"GaP("))/9+parseInt(n(371,"Oqzd"))/10)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x22920c(377,"iTEG")](_0x22920c(370,"y*P&"))!=_0x22920c(373,"u#UK"))throw window[_0x22920c(374,"VsPV")][_0x22920c(363,"6!RW")](_0x22920c(380,"S0B(")),Error();document.title="react 源码 useRef",document.getElementById("article").innerHTML='<div><p><code>useRef</code> 是 React 的一个 Hook，用于在函数组件中持有一个可变的引用对象（ref）。它通常用于访问 DOM 元素或存储任意可变值，而不会触发组件的重新渲染。以下是对 <code>useRef</code> 的详细解析，包括其源码实现和实际应用。</p>\n<hr>\n<h3><strong>一、<code>useRef</code> 的基本用法</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);\n\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-keyword">if</span> (inputRef.<span class="hljs-property">current</span>) {\n      inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>(); <span class="hljs-comment">// 访问 DOM 元素</span>\n    }\n  };\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{inputRef}</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>Focus Input<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<ul>\n<li><strong>创建一个 ref 对象</strong>  ：<code>const inputRef = useRef(null);</code> 创建一个初始值为 <code>null</code> 的 ref 对象。</li>\n<li><strong>访问 DOM 元素</strong>  ：通过 <code>inputRef.current</code> 访问绑定的 DOM 元素。</li>\n<li><strong>不会触发重新渲染</strong>  ：修改 <code>ref.current</code> 的值不会触发组件的重新渲染。</li>\n</ul>\n<hr>\n<h3><strong>二、<code>useRef</code> 的源码实现</strong></h3>\n<p>虽然 React 的源码是用 C++ 和 JavaScript 混合编写的，且具体实现细节可能因版本而异，但我们可以基于 React 的设计理念和公开文档，理解 <code>useRef</code> 的核心实现原理。</p>\n<h4><strong>核心源码概念（简化版）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useRef</span>(<span class="hljs-params">initialValue</span>) {\n  <span class="hljs-keyword">const</span> hook = {\n    <span class="hljs-attr">current</span>: initialValue, <span class="hljs-comment">// 初始值</span>\n  };\n\n  <span class="hljs-comment">// 假设有一个全局的 hooks 数组来存储 hook 对象</span>\n  <span class="hljs-comment">// 在实际 React 实现中，hooks 是通过链表结构管理的</span>\n  <span class="hljs-keyword">if</span> (!currentlyRenderingFiber.<span class="hljs-property">alternate</span>) {\n    <span class="hljs-comment">// 初次渲染时，将 hook 对象存储到 fiber 的 hooks 链表中</span>\n    currentlyRenderingFiber.<span class="hljs-property">hooks</span>.<span class="hljs-title function_">push</span>(hook);\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 更新时，从 alternate fiber 的 hooks 链表中获取之前的 hook 对象</span>\n    <span class="hljs-keyword">const</span> oldHookIndex = <span class="hljs-comment">// ... 找到对应的 hook 索引</span>\n    <span class="hljs-keyword">const</span> oldHook = currentlyRenderingFiber.<span class="hljs-property">alternate</span>.<span class="hljs-property">hooks</span>[oldHookIndex];\n    hook.<span class="hljs-property">current</span> = oldHook.<span class="hljs-property">current</span>; <span class="hljs-comment">// 保持 current 的值跨渲染保持一致</span>\n  }\n\n  <span class="hljs-keyword">return</span> hook;\n}\n</code></pre>\n<h4><strong>源码解析</strong></h4>\n<ol>\n<li><strong>Hook 对象</strong>  ：\n<ul>\n<li><code>useRef</code> 返回一个包含 <code>current</code> 属性的对象。</li>\n<li><code>current</code> 属性保存了 ref 的当前值。</li>\n</ul>\n</li>\n<li><strong>Hooks 链表</strong>  ：\n<ul>\n<li>在 React 内部，每个组件的 Fiber 节点维护一个 hooks 链表，用于存储该组件的所有 hooks。</li>\n<li>初次渲染时，<code>useRef</code> 创建的 hook 对象被添加到 hooks 链表中。</li>\n<li>更新时，React 从 alternate Fiber 的 hooks 链表中获取之前的 hook 对象，保持 <code>current</code> 的值跨渲染保持一致。</li>\n</ul>\n</li>\n<li><strong>不会触发重新渲染</strong>  ：\n<ul>\n<li>修改 <code>ref.current</code> 的值不会改变 hook 对象本身，因此不会触发组件的重新渲染。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>三、<code>useRef</code> 的工作原理</strong></h3>\n<ol>\n<li><strong>初次渲染</strong>  ：\n<ul>\n<li>调用 <code>useRef</code> 时，React 创建一个 hook 对象，并将其存储到 Fiber 节点的 hooks 链表中。</li>\n<li>返回的 hook 对象的 <code>current</code> 属性被初始化为传入的初始值。</li>\n</ul>\n</li>\n<li><strong>更新渲染</strong>  ：\n<ul>\n<li>在后续渲染中，React 从 alternate Fiber 的 hooks 链表中获取之前的 hook 对象。</li>\n<li>保持 <code>current</code> 属性的值跨渲染保持一致，除非显式修改。</li>\n</ul>\n</li>\n<li><strong>访问和修改</strong>  ：\n<ul>\n<li>通过 <code>ref.current</code> 访问和修改 ref 的当前值。</li>\n<li>修改 <code>ref.current</code> 不会触发组件的重新渲染。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>四、<code>useRef</code> 的常见应用场景</strong></h3>\n<ol>\n<li><strong>访问 DOM 元素</strong>  ：\n<ul>\n<li>使用 <code>useRef</code> 获取 DOM 元素的引用，以便在组件中直接操作 DOM。</li>\n</ul>\n</li>\n<li><strong>存储任意可变值</strong>  ：\n<ul>\n<li>使用 <code>useRef</code> 存储组件中的任意可变值，如定时器 ID、外部库实例等。</li>\n</ul>\n</li>\n<li><strong>避免不必要的重新渲染</strong>  ：\n<ul>\n<li>使用 <code>useRef</code> 存储不会影响组件渲染状态的值，避免不必要的重新渲染。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>五、<code>useRef</code> 与 <code>useState</code> 的区别</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>useRef</code></th>\n<th><code>useState</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>存储值</strong></td>\n<td>任意可变值</td>\n<td>组件状态值</td>\n</tr>\n<tr>\n<td><strong>触发重新渲染</strong></td>\n<td>不会</td>\n<td>会</td>\n</tr>\n<tr>\n<td><strong>典型用途</strong></td>\n<td>访问 DOM 元素、存储可变值</td>\n<td>管理组件状态</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>六、总结</strong></h3>\n<p><code>useRef</code> 是 React 中一个非常有用的 Hook，它允许在函数组件中持有一个可变的引用对象，而不会触发组件的重新渲染。<code>useRef</code> 的核心实现依赖于 React 的 hooks 链表机制，确保了 ref 对象在组件的整个生命周期内保持一致。通过 <code>useRef</code>，开发者可以方便地访问 DOM 元素、存储任意可变值，并优化组件的性能。</p>\n</div>'</script></body></html>