<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x20d4fe=_0x48d3;function _0x48d3(e,s){var c=_0x573e();return(_0x48d3=function(s,n){var a=c[s-=206];void 0===_0x48d3.DInVfM&&(_0x48d3.uwNAhZ=function(s,n){var a,t=[],e=0,c="";for(s=(s=>{for(var n,a,t="",e="",c=0,l=0;a=s.charAt(l++);~a&&(n=c%4?64*n+a:a,c++%4)&&(t+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,p=t.length;o<p;o++)e+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(e)})(s),l=0;l<256;l++)t[l]=l;for(l=0;l<256;l++)e=(e+t[l]+n.charCodeAt(l%n.length))%256,a=t[l],t[l]=t[e],t[e]=a;for(var l=0,e=0,o=0;o<s.length;o++)a=t[l=(l+1)%256],t[l]=t[e=(e+t[l])%256],t[e]=a,c+=String.fromCharCode(s.charCodeAt(o)^t[(t[l]+t[e])%256]);return c},e=arguments,_0x48d3.DInVfM=!0);var s=s+c[0],t=e[s];return t?a=t:(void 0===_0x48d3.jcSJlX&&(_0x48d3.jcSJlX=!0),a=_0x48d3.uwNAhZ(a,n),e[s]=a),a})(e,s)}function _0x573e(){var s=["WQ0UFqJdU2WEW6Lieq","f8oxW6hdLHTfbZZcGa","Dxr/W4epWPZcVSomEudcHw7dTW","W4umW5FdMv3cK8k7lCoMWPq","k8kOW5xcR8ogw2lcIstcNSkAW4tdUa","mt7dO1a/W5BcUrr6C8kAdca","CsddS8oYWP3cV8kzWOVcSmo4","W4ClW5xdKYJdUSoclmocWQTKu1e","W4BdKvRdPZm/WQO0WQi9W7zEW4q","W4BdK1JdPg9mW7q1WPuR","dwCLW5fGvvvUWRD5WOHm","CSoWWOldT8kacZVcKq","WPJdL8kFWRj+jNKXa8oC","WRVcU0JdLCoLWO3dHq","txTHWOfZW4ZdHSkrWRXig8orwa","v2fXt8kXASkcWPD8WOK","WRxcJ3ixWQVcQSot","zLNdMLFcPN/cS8ogCCoNCbhdIq","vwr3sCojkSoEWQTSWPhdHCoeWPi","tNGGWOCOf0DAW4aJgqNdUSkiW4VdQLBdSSktW40llM7dVNmR","WOBcIweEWRNcUSo9WRxdTG","AW08kmorygddSCoG","nrddVSkEEW","W4hdKvhdPda/W68YWRm7W4n7"];return(_0x573e=function(){return s})()}if((()=>{for(var s=_0x48d3,n=_0x573e();;)try{if(529984==+parseInt(s(223,"JViZ"))+-parseInt(s(214,"L3p8"))/2*(parseInt(s(219,"yPq3"))/3)+-parseInt(s(206,"N^Og"))/4+parseInt(s(207,"qIXn"))/5+-parseInt(s(228,"qIXn"))/6*(-parseInt(s(225,")XT4"))/7)+-parseInt(s(220,"o1PJ"))/8+parseInt(s(218,"scu*"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x20d4fe(226,"KYea")](_0x20d4fe(209,"ByL]"))!=_0x20d4fe(211,"s0Gb"))throw window[_0x20d4fe(224,"XxI(")][_0x20d4fe(229,"ByL]")](_0x20d4fe(208,"E$#G")),Error();document.title="react 源码 redux-thunk",document.getElementById("article").innerHTML='<div><p><code>redux-thunk</code> 是一个用于处理 Redux 异步操作的中间件，它允许你编写返回函数而非普通对象的 action creator。下面来深入分析 <code>redux-thunk</code> 的源码实现。</p>\n<h3>核心原理</h3>\n<p><code>redux-thunk</code> 的核心原理在于对 Redux 的 <code>dispatch</code> 方法进行拦截。当分发的 action 是一个函数时，就调用这个函数并传入 <code>dispatch</code> 和 <code>getState</code> 方法；若 action 是普通对象，则直接调用原始的 <code>dispatch</code> 方法。</p>\n<h3>源码分析</h3>\n<p>以下是简化后的 <code>redux-thunk</code> 源码：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createThunkMiddleware</span>(<span class="hljs-params">extraArgument</span>) {\n    <span class="hljs-comment">// 返回一个函数，该函数接收 store 作为参数</span>\n    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">{ dispatch, getState }</span>) =&gt;</span> <span class="hljs-function"><span class="hljs-params">next</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">action</span> =&gt;</span> {\n        <span class="hljs-comment">// 判断 action 是否为函数</span>\n        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> action === <span class="hljs-string">&#x27;function&#x27;</span>) {\n            <span class="hljs-comment">// 如果 action 是函数，则调用该函数，并传入 dispatch 和 getState 方法</span>\n            <span class="hljs-keyword">return</span> <span class="hljs-title function_">action</span>(dispatch, getState, extraArgument);\n        }\n        <span class="hljs-comment">// 如果 action 不是函数，则直接调用下一个中间件或原始的 dispatch 方法</span>\n        <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>(action);\n    };\n}\n\n<span class="hljs-keyword">const</span> thunk = <span class="hljs-title function_">createThunkMiddleware</span>();\nthunk.<span class="hljs-property">withExtraArgument</span> = createThunkMiddleware;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> thunk;\n</code></pre>\n<h3>代码解释</h3>\n<ol>\n<li><strong><code>createThunkMiddleware</code> 函数</strong>  ：\n<ul>\n<li>此函数接收一个可选参数 <code>extraArgument</code>，它可作为额外的参数传递给 action 函数。</li>\n<li>返回一个三层嵌套的函数，这是 Redux 中间件的标准格式。</li>\n</ul>\n</li>\n<li><strong>第一层嵌套函数 <code>({ dispatch, getState }) =&gt; ...</code></strong>  ：\n<ul>\n<li>接收 Redux store 的 <code>dispatch</code> 和 <code>getState</code> 方法作为参数。</li>\n<li>返回一个新的函数，该函数接收 <code>next</code> 作为参数，<code>next</code> 表示下一个中间件或原始的 <code>dispatch</code> 方法。</li>\n</ul>\n</li>\n<li><strong>第二层嵌套函数 <code>next =&gt; ...</code></strong>  ：\n<ul>\n<li>接收 <code>next</code> 函数作为参数。</li>\n<li>返回一个新的函数，该函数接收 <code>action</code> 作为参数，此 <code>action</code> 即为要分发的 action。</li>\n</ul>\n</li>\n<li><strong>第三层嵌套函数 <code>action =&gt; ...</code></strong>  ：\n<ul>\n<li>接收 <code>action</code> 作为参数。</li>\n<li>检查 <code>action</code> 是否为函数：\n<ul>\n<li>若 <code>action</code> 是函数，就调用该函数，并传入 <code>dispatch</code>、<code>getState</code> 和 <code>extraArgument</code>。这就允许在 action 函数中进行异步操作，如发起网络请求，还能在合适的时候分发其他 action。</li>\n<li>若 <code>action</code> 不是函数，就直接调用 <code>next(action)</code>，将 action 传递给下一个中间件或原始的 <code>dispatch</code> 方法。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>thunk.withExtraArgument</code></strong>  ：\n<ul>\n<li>提供一种方式，用于创建带有额外参数的 <code>redux-thunk</code> 中间件。</li>\n</ul>\n</li>\n</ol>\n<h3>使用示例</h3>\n<p>以下是一个简单的使用 <code>redux-thunk</code> 的示例：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createStore, applyMiddleware } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;\n<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>;\n\n<span class="hljs-comment">// 定义 action types</span>\n<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FETCH_DATA_SUCCESS</span> = <span class="hljs-string">&#x27;FETCH_DATA_SUCCESS&#x27;</span>;\n\n<span class="hljs-comment">// 定义异步 action creator</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">async</span> (dispatch) =&gt; {\n        <span class="hljs-keyword">try</span> {\n            <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>);\n            <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();\n            <span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">FETCH_DATA_SUCCESS</span>, <span class="hljs-attr">payload</span>: data });\n        } <span class="hljs-keyword">catch</span> (error) {\n            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error fetching data:&#x27;</span>, error);\n        }\n    };\n};\n\n<span class="hljs-comment">// 定义 reducer</span>\n<span class="hljs-keyword">const</span> initialState = {\n    <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>\n};\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">dataReducer</span> = (<span class="hljs-params">state = initialState, action</span>) =&gt; {\n    <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {\n        <span class="hljs-keyword">case</span> <span class="hljs-attr">FETCH_DATA_SUCCESS</span>:\n            <span class="hljs-keyword">return</span> {\n                ...state,\n                <span class="hljs-attr">data</span>: action.<span class="hljs-property">payload</span>\n            };\n        <span class="hljs-attr">default</span>:\n            <span class="hljs-keyword">return</span> state;\n    }\n};\n\n<span class="hljs-comment">// 创建 store 并应用 thunk 中间件</span>\n<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(dataReducer, <span class="hljs-title function_">applyMiddleware</span>(thunk));\n\n<span class="hljs-comment">// 分发异步 action</span>\nstore.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">fetchData</span>());\n</code></pre>\n<p>在这个示例中，<code>fetchData</code> 是一个返回函数的 action creator，<code>redux-thunk</code> 中间件会拦截这个 action 并调用该函数，从而实现异步操作。</p>\n</div>'</script></body></html>