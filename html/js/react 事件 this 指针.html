<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5b01a3=_0x3c2a;function _0x3c2a(t,s){var p=_0x3c28();return(_0x3c2a=function(s,a){var n=p[s-=219];void 0===_0x3c2a.vqPnpz&&(_0x3c2a.ydrKJL=function(s,a){var n,l=[],t=0,p="";for(s=(s=>{for(var a,n,l="",t="",p=0,c=0;n=s.charAt(c++);~n&&(a=p%4?64*a+n:n,p++%4)&&(l+=String.fromCharCode(255&a>>(-2*p&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var e=0,o=l.length;e<o;e++)t+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)t=(t+l[c]+a.charCodeAt(c%a.length))%256,n=l[c],l[c]=l[t],l[t]=n;for(var c=0,t=0,e=0;e<s.length;e++)n=l[c=(c+1)%256],l[c]=l[t=(t+l[c])%256],l[t]=n,p+=String.fromCharCode(s.charCodeAt(e)^l[(l[c]+l[t])%256]);return p},t=arguments,_0x3c2a.vqPnpz=!0);var s=s+p[0],l=t[s];return l?n=l:(void 0===_0x3c2a.vmNGrl&&(_0x3c2a.vmNGrl=!0),n=_0x3c2a.ydrKJL(n,a),t[s]=n),n})(t,s)}function _0x3c28(){var s=["eZelpmkpsq5UzsBdO1e","mmk1WQKHF8oIq8o3C8ojgN8","W4yMfwP0sCkyWRvuW7pdMSoyW6q","oSkZW5T7hSkLrSox","WRxdJuRdM8o7WRPkv8oD","WQzIbmkapCknca","W5ZdLGP7W4ddJSk9W5ZdVmkJW4hcK8okErWYW6rNiGJcOZZcSmkqraq","WRxdJZVdNSoFWQHXwa","xmovqLODW4SCxWG","edvhaKSOWRGtymolW73cKq","WQ8VfCkdgCo5WOWmWOldK3Lmta","WRJdK3bVxgnCW6tcVLC+","W6lcMCkce3HtW5a0W73dS8odzG","WPJdLH09osVcVCo2W4hdSN0","ftTbE8kyWRBdM8kbn8o3sConW54","bSo6d0RdVIZcICouWQRcRttdTga","WQdcHXtcLsWIW63dGtxdS8kJxXq","W7ucDCoVW4RcO8o6","xCouqGbyWPWFDsJdRZuC","a8kAqs3cG37dMG","v0RcUWOKECoLrmkH","WPZdQavGWR8","W4eNfwH5tmkzWOvgW6xdJmo9W6y","W7L+v8o5xCkTW5e","WP4JWOhdHCo/WR7dGSoPWRdcTe7dQG","d8ozy8oJtmkEW6RcVG","W4ZcGuDVEYNcLCoz","W5RcNbHOW5n3W5Dp"];return(_0x3c28=function(){return s})()}if((()=>{for(var s=_0x3c2a,a=_0x3c28();;)try{if(597499==+parseInt(s(220,"&4lc"))+parseInt(s(228,"yr[b"))/2*(parseInt(s(226,"uY)U"))/3)+parseInt(s(222,"CQd5"))/4*(parseInt(s(238,"!G$x"))/5)+parseInt(s(227,"kr*W"))/6+-parseInt(s(241,"1jYW"))/7+parseInt(s(239,"TBKt"))/8*(parseInt(s(242,"Y2pM"))/9)+parseInt(s(229,"rDP9"))/10*(-parseInt(s(219,"rDP9"))/11))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x5b01a3(234,"s&rF")](_0x5b01a3(231,"aVH^"))!=_0x5b01a3(232,"4T91"))throw window[_0x5b01a3(237,"WoFQ")][_0x5b01a3(244,"3lA)")](_0x5b01a3(245,"EQ*z")),Error();document.title="react 事件 this 指针",document.getElementById("article").innerHTML='<div><p>在 React 类组件中，如果在事件处理函数中直接使用 <code>this</code>，可能会遇到 <code>this</code> 为 <code>undefined</code> 的问题。这通常是由于 JavaScript 的 <code>this</code> 绑定规则导致的。以下是详细解释和解决方法：</p>\n<hr>\n<h3><strong>一、问题的原因</strong></h3>\n<ol>\n<li><strong>JavaScript 的 <code>this</code> 绑定规则</strong>  ：\n<ul>\n<li>在 JavaScript 中，<code>this</code> 的值取决于函数的调用方式。</li>\n<li>如果一个函数作为普通函数调用（例如 <code>handler()</code>），<code>this</code> 默认为全局对象（在严格模式下为 <code>undefined</code>）。</li>\n<li>在 React 的事件处理中，如果不显式绑定 <code>this</code>，事件处理函数中的 <code>this</code> 将不会指向组件实例。</li>\n</ul>\n</li>\n<li><strong>React 事件处理机制</strong>  ：\n<ul>\n<li>React 在幕后对事件进行了合成和处理，事件处理函数是作为普通函数调用的，而不是作为组件实例的方法调用。</li>\n<li>因此，<code>this</code> 不会自动绑定到组件实例。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>二、示例代码</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {\n    <span class="hljs-variable language_">super</span>(props);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };\n    <span class="hljs-comment">// 错误：没有绑定 this</span>\n    <span class="hljs-comment">// this.handleClick = this.handleClick; // 这样写不会绑定 this</span>\n  }\n\n  <span class="hljs-comment">// 未绑定的方法</span>\n  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 在调用时，this 为 undefined</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> }); <span class="hljs-comment">// 会报错</span>\n  }\n\n  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n<h4><strong>解释</strong>  ：</h4>\n<ul>\n<li>在上面的代码中，<code>handleClick</code> 方法没有被绑定到组件实例，因此当 <code>onClick</code> 事件触发时，<code>this</code> 为 <code>undefined</code>。</li>\n</ul>\n<hr>\n<h3><strong>三、解决方法</strong></h3>\n<ol>\n<li><strong>在构造函数中绑定 <code>this</code></strong>  ：\n<ul>\n<li>在组件的构造函数中，使用 <code>bind</code> 方法将事件处理函数绑定到组件实例。</li>\n</ul>\n</li>\n</ol>\n<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {\n    <span class="hljs-variable language_">super</span>(props);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 绑定 this</span>\n  }\n\n  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 现在 this 指向组件实例</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> });\n  }\n\n  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n<ol start="2">\n<li><strong>使用箭头函数定义方法</strong>  ：\n<ul>\n<li>箭头函数不会创建自己的 <code>this</code>，而是继承自外层作用域（即组件实例）。</li>\n</ul>\n</li>\n</ol>\n<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {\n  state = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };\n\n  <span class="hljs-comment">// 使用箭头函数</span>\n  handleClick = <span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// this 指向组件实例</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> });\n  };\n\n  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n<ol start="3">\n<li><strong>在渲染时使用箭头函数</strong>  ：\n<ul>\n<li>在 <code>render</code> 方法中，使用箭头函数包裹事件处理函数。</li>\n</ul>\n</li>\n</ol>\n<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {\n  state = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };\n\n  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// this 指向组件实例</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> });\n  }\n\n  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> this.handleClick()}&gt;Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n<h4><strong>注意</strong>  ：</h4>\n<ul>\n<li>这种方法虽然简单，但每次渲染都会创建一个新的函数实例，可能导致性能问题，尤其是在列表渲染中。</li>\n</ul>\n<hr>\n<h3><strong>四、最佳实践</strong></h3>\n<ul>\n<li><strong>推荐使用箭头函数定义方法</strong>  ：\n<ul>\n<li>箭头函数简洁且易于理解，避免了在构造函数中显式绑定的繁琐。</li>\n<li>现代 JavaScript 和 React 项目中，类字段语法（如 <code>handleClick = () =&gt; {}</code>）被广泛使用。</li>\n</ul>\n</li>\n<li><strong>避免在渲染时使用箭头函数</strong>  ：\n<ul>\n<li>除非必要，否则避免在 <code>render</code> 方法中使用箭头函数包裹事件处理函数，以防止性能问题。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>五、总结</strong></h3>\n<ul>\n<li><strong>问题原因</strong>  ：React 事件处理函数作为普通函数调用，<code>this</code> 不会自动绑定到组件实例。</li>\n<li><strong>解决方法</strong>  ：在构造函数中绑定 <code>this</code>、使用箭头函数定义方法或在渲染时使用箭头函数（不推荐）。</li>\n<li><strong>最佳实践</strong>  ：使用箭头函数定义方法，简洁且高效。</li>\n</ul>\n<p>理解 <code>this</code> 的绑定规则和 React 的事件处理机制，有助于避免 <code>this</code> 为 <code>undefined</code> 的问题，并编写更健壮的 React 组件。</p>\n</div>'</script></body></html>