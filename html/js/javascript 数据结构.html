<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4b67cc=_0x4baf;if((()=>{for(var s=_0x4baf,n=_0x25a4();;)try{if(162040==-parseInt(s(321,"aq8a"))*(parseInt(s(341,"TOZ5"))/2)+-parseInt(s(325,"oruz"))/3*(parseInt(s(320,"24&y"))/4)+-parseInt(s(339,")hNH"))/5*(-parseInt(s(348,"rD70"))/6)+parseInt(s(344,"s47x"))/7+parseInt(s(349,"X5$1"))/8*(-parseInt(s(333,"MzoQ"))/9)+parseInt(s(331,"TOZ5"))/10+-parseInt(s(327,"NPk!"))/11*(parseInt(s(329,"W@K6"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x4b67cc(332,"YpG2")](_0x4b67cc(347,"jRaL"))!=_0x4b67cc(326,"aq8a"))throw window[_0x4b67cc(343,"%SK(")][_0x4b67cc(334,"MzoQ")](_0x4b67cc(330,"4Kya")),Error();function _0x4baf(p,s){var t=_0x25a4();return(_0x4baf=function(s,n){var a=t[s-=320];void 0===_0x4baf.NbITSw&&(_0x4baf.sLiBoZ=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,e=0;a=s.charAt(e++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=l.length;c<r;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[p],l[p]=a;for(var e=0,p=0,c=0;c<s.length;c++)a=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[p])%256]);return t},p=arguments,_0x4baf.NbITSw=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x4baf.GNdNJQ&&(_0x4baf.GNdNJQ=!0),a=_0x4baf.sLiBoZ(a,n),p[s]=a),a})(p,s)}function _0x25a4(){var s=["pNVcLCkju2PWACoXy2FdO8o2","WOqXW74sn8o5WQO","fdFcLmoBsCkeW4/dL8oWW7f4","yYxdHmoBetOTCW","W7jOW4dcOCobW4xcHCkuFNKFW4Le","DCkUWO/dQauze3ZcSK8OW4nU","WRRcUHOjECo+W4C","WODLWRddPmkevrJdSbG","E8o4n8k7WRDtd8oQawBcHwxdTa","mCodhXldNcxdGW","WQ0QzCkbxMnWnqviWOD8","BxJdUeBcK8kZtmoSWQJcGmk+","WRyYyCofgmoWleS","W6tdImoBnfDrFq","ed7cM8oArSowWPFdJ8ozW5HRW7iI","oSkvWPBcSu/dUv8","kJtcSWZdKW","fI/dSMjCW7TGW7S","W5bYW6qVC3ldTCkybhtdHY/cOq","W63cM8kWBXKUiCk2b1K4lee","W693u8oZdCk+sHdcTmo8WOdcUghcH8kxsXFdT3VcHSoEWOOtW78aWRa","WOvMWR5+DCkLW73cMIRdLebcma","zq9NW4HDW6BdUW","FXvTW5u2W4zoBSk1kmk+WOnY","peKKWO5UWPuA","z1tcJ8kcWPbgW6y","WQRcI8oqWP7cTMFdQa","lMdcKCk/W5SaFvRcOCk+x8k1","DCkMWO7dRq0zgMtcQNOFW6Po","iZ7dKCoiWRn3sq"];return(_0x25a4=function(){return s})()}document.title="javascript 数据结构",document.getElementById("article").innerHTML='<div><p>JavaScript 中常见的数据结构有多种，每种数据结构都有其特点和适用场景。以下是常见的 JavaScript 数据结构：</p>\n<hr>\n<h3>1. <strong>数组（Array）</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：数组是一种线性数据结构，用于存储一组有序的元素，可以通过索引访问。</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li>支持动态调整大小。</li>\n<li>提供丰富的内置方法，如 <code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>map</code>、<code>filter</code>、<code>reduce</code> 等。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];\narr.<span class="hljs-title function_">push</span>(<span class="hljs-number">6</span>); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>2. <strong>对象（Object）</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：对象是键值对的集合，用于存储无序的数据。</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li>键是字符串或符号，值可以是任意类型。</li>\n<li>适合存储和访问非顺序数据。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">let</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> };\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;Alice&#x27;</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>3. <strong>栈（Stack）</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：栈是一种后进先出（LIFO）的数据结构，只允许在一端进行插入和删除操作。</li>\n<li><strong>实现</strong>  ：通常使用数组实现。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = [];\n  }\n  <span class="hljs-title function_">push</span>(<span class="hljs-params">element</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(element);\n  }\n  <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">pop</span>();\n  }\n}\n\n<span class="hljs-keyword">let</span> stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();\nstack.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>);\nstack.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack.<span class="hljs-title function_">pop</span>()); <span class="hljs-comment">// 2</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>4. <strong>队列（Queue）</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：队列是一种先进先出（FIFO）的数据结构，允许在一端插入，在另一端删除。</li>\n<li><strong>实现</strong>  ：通常使用数组实现。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = [];\n  }\n  <span class="hljs-title function_">enqueue</span>(<span class="hljs-params">element</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(element);\n  }\n  <span class="hljs-title function_">dequeue</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">shift</span>();\n  }\n}\n\n<span class="hljs-keyword">let</span> queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>();\nqueue.<span class="hljs-title function_">enqueue</span>(<span class="hljs-number">1</span>);\nqueue.<span class="hljs-title function_">enqueue</span>(<span class="hljs-number">2</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(queue.<span class="hljs-title function_">dequeue</span>()); <span class="hljs-comment">// 1</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>5. <strong>链表（Linked List）</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：链表由一系列节点组成，每个节点包含数据和指向下一个节点的引用。</li>\n<li><strong>类型</strong>  ：\n<ul>\n<li><strong>单链表</strong>  ：每个节点只指向下一个节点。</li>\n<li><strong>双链表</strong>  ：每个节点指向下一个和上一个节点。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  （单链表）：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">data</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = data;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;\n  }\n}\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-literal">null</span>;\n  }\n  <span class="hljs-title function_">append</span>(<span class="hljs-params">data</span>) {\n    <span class="hljs-keyword">let</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(data);\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode;\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;\n      <span class="hljs-keyword">while</span> (current.<span class="hljs-property">next</span>) {\n        current = current.<span class="hljs-property">next</span>;\n      }\n      current.<span class="hljs-property">next</span> = newNode;\n    }\n  }\n}\n\n<span class="hljs-keyword">let</span> list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();\nlist.<span class="hljs-title function_">append</span>(<span class="hljs-number">1</span>);\nlist.<span class="hljs-title function_">append</span>(<span class="hljs-number">2</span>);\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>6. <strong>集合（Set）</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：集合是一种无序且不重复的数据结构。</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li>自动去重。</li>\n<li>提供 <code>add</code>、<code>delete</code>、<code>has</code>、<code>size</code> 等方法。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();\nset.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);\nset.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);\nset.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 重复元素不会被添加</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set); <span class="hljs-comment">// Set { 1, 2 }</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>7. <strong>映射（Map）</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：映射是一种键值对集合，键和值都可以是任意类型。</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li>键值对有序存储。</li>\n<li>提供 <code>set</code>、<code>get</code>、<code>has</code>、<code>delete</code>、<code>size</code> 等方法。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();\nmap.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>);\nmap.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">25</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// &#x27;Alice&#x27;</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>8. <strong>树（Tree）</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：树是一种非线性数据结构，由节点组成，每个节点可以有零个或多个子节点。</li>\n<li><strong>类型</strong>  ：\n<ul>\n<li><strong>二叉树</strong>  ：每个节点最多有两个子节点。</li>\n<li><strong>二叉搜索树</strong>  ：左子节点小于父节点，右子节点大于父节点。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  （二叉树）：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">data</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = data;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span> = <span class="hljs-literal">null</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span> = <span class="hljs-literal">null</span>;\n  }\n}\n\n<span class="hljs-keyword">let</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);\nroot.<span class="hljs-property">left</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>);\nroot.<span class="hljs-property">right</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>9. <strong>图（Graph）</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：图由节点（顶点）和边组成，用于表示实体之间的关系。</li>\n<li><strong>类型</strong>  ：\n<ul>\n<li><strong>无向图</strong>  ：边没有方向。</li>\n<li><strong>有向图</strong>  ：边有方向。</li>\n</ul>\n</li>\n<li><strong>表示方法</strong>  ：\n<ul>\n<li><strong>邻接表</strong>  ：使用对象或数组存储每个节点的相邻节点。</li>\n<li><strong>邻接矩阵</strong>  ：使用二维数组表示节点之间的连接关系。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  （邻接表）：<pre><code class="language-javascript"><span class="hljs-keyword">let</span> graph = {\n  <span class="hljs-attr">A</span>: [<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>],\n  <span class="hljs-attr">B</span>: [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>],\n  <span class="hljs-attr">C</span>: [<span class="hljs-string">&#x27;A&#x27;</span>],\n  <span class="hljs-attr">D</span>: [<span class="hljs-string">&#x27;B&#x27;</span>]\n};\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>10. <strong>哈希表（Hash Table）</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：哈希表通过哈希函数将键映射到值，实现快速查找。</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li>查找、插入、删除操作的时间复杂度接近 O(1)。</li>\n<li>JavaScript 中的对象和 <code>Map</code> 都可以视为哈希表的实现。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">let</span> hashTable = {};\nhashTable[<span class="hljs-string">&#x27;key1&#x27;</span>] = <span class="hljs-string">&#x27;value1&#x27;</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hashTable[<span class="hljs-string">&#x27;key1&#x27;</span>]); <span class="hljs-comment">// &#x27;value1&#x27;</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>基本数据结构</strong>  ：数组、对象。</li>\n<li><strong>线性数据结构</strong>  ：栈、队列、链表。</li>\n<li><strong>集合类数据结构</strong>  ：集合、映射。</li>\n<li><strong>非线性数据结构</strong>  ：树、图。</li>\n<li><strong>高级数据结构</strong>  ：哈希表。</li>\n</ul>\n<p>在实际开发中，选择合适的数据结构可以显著提高程序的性能和可维护性。理解每种数据结构的特点和适用场景是编写高效代码的关键。</p>\n</div>'</script></body></html>