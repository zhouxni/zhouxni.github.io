<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3bd142=_0x5272;function _0x1b53(){var s=["W4SCxmkpW7iClhRdMs53mmoR","W7uTW5RdSwRcM8oIAtHhBSov","WO0kW57dI8kMW7ddNSoJhKPlWPKv","W7JdSCo1WQ3cS8o8WRaL","g8k2W5C0FW4EW7GJWRJcVrK","WRK/pIHZxSoLW5bxW6VcKsu","WROhnsdcUmoZiryHWQba","W6ddV1VcKfTwnSkiz8oDcmkqWR4","W5/dJSkcsSoDumoeWRK","WPBcOSkOCmoiBW/dHeW2bSkYWQ4xW5OIDtCvWQJcQmkZrSorufa","ffldSL5qeCkNWR4K","WOBdPCotC8o4WRLLcCoDgutdPq","r2VdQuOuiCkMW58zWOjBwSkc","f25zWQZcU8ovAcPC","DI9UW57dIq","qYKDW54kychcLNtcSW5/","CITezSoesCk2hSo8nrf7","W75sFxNdQmoZma","cSo1EmoBWQLLWPe3W5dcImoSo3u","W7/dSCkoW7xdHCowWR01kKNdQW","W7yPW5FdT27cKSkIBJfpsCoNW7K","W5WonmkRDKlcVq","W7xdUWz9z1JcUmoUhq","g8oLW44bW4aGe8kv"];return(_0x1b53=function(){return s})()}function _0x5272(l,s){var o=_0x1b53();return(_0x5272=function(s,n){var a=o[s-=211];void 0===_0x5272.dvIsrS&&(_0x5272.eRPZEn=function(s,n){var a,e=[],l=0,o="";for(s=(s=>{for(var n,a,e="",l="",o=0,t=0;a=s.charAt(t++);~a&&(n=o%4?64*n+a:a,o++%4)&&(e+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,p=e.length;r<p;r++)l+="%"+("00"+e.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(s),t=0;t<256;t++)e[t]=t;for(t=0;t<256;t++)l=(l+e[t]+n.charCodeAt(t%n.length))%256,a=e[t],e[t]=e[l],e[l]=a;for(var t=0,l=0,r=0;r<s.length;r++)a=e[t=(t+1)%256],e[t]=e[l=(l+e[t])%256],e[l]=a,o+=String.fromCharCode(s.charCodeAt(r)^e[(e[t]+e[l])%256]);return o},l=arguments,_0x5272.dvIsrS=!0);var s=s+o[0],e=l[s];return e?a=e:(void 0===_0x5272.VbzhRf&&(_0x5272.VbzhRf=!0),a=_0x5272.eRPZEn(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x5272,n=_0x1b53();;)try{if(683981==+parseInt(s(226,"r3Vj"))+parseInt(s(215,"k7aR"))/2+parseInt(s(230,"$6[r"))/3+parseInt(s(222,"hRL["))/4+parseInt(s(213,"rGNe"))/5*(-parseInt(s(217,"M&GM"))/6)+-parseInt(s(216,"Ap4Y"))/7+parseInt(s(223,"5mdj"))/8*(-parseInt(s(225,"6PLo"))/9))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3bd142(231,"CxoH")](_0x3bd142(220,"kj&B"))!=_0x3bd142(224,"drjP"))throw window[_0x3bd142(233,"0Nu7")][_0x3bd142(227,"Ap4Y")](_0x3bd142(219,"NYnC")),Error();document.title="proxy 代理",document.getElementById("article").innerHTML='<div><p><strong><code>Proxy</code> 对象本身不会自动代理对象的所有层级</strong>  ，它只会代理第一层对象的操作。如果需要代理嵌套对象，需要手动实现递归代理。以下是详细解释：</p>\n<hr>\n<h3><strong>1. Proxy 的基本行为</strong></h3>\n<ul>\n<li><strong>代理第一层对象</strong>  ：<code>Proxy</code> 可以拦截并自定义对第一层对象属性的访问、赋值、删除等操作。</li>\n<li><strong>默认不代理嵌套对象</strong>  ：当访问嵌套对象时，返回的是原始嵌套对象，而不是代理对象。</li>\n</ul>\n<hr>\n<h3><strong>2. 示例：Proxy 对嵌套对象的默认行为</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> target = {\n  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,\n  <span class="hljs-attr">nested</span>: {\n    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>\n  }\n};\n\n<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {\n  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop, receiver</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Getting <span class="hljs-subst">${prop}</span>`</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, prop, receiver);\n  }\n});\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">a</span>); <span class="hljs-comment">// 输出 &quot;Getting a&quot;，然后输出 1</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">nested</span>.<span class="hljs-property">b</span>); <span class="hljs-comment">// 输出 &quot;Getting nested&quot;，然后输出 2（没有触发 &quot;Getting b&quot;）</span>\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li>访问 <code>proxy.a</code> 时，触发了 <code>get</code> 捕获器。</li>\n<li>访问 <code>proxy.nested.b</code> 时，只触发了 <code>proxy.nested</code> 的 <code>get</code> 捕获器，返回了原始的 <code>nested</code> 对象，而不是代理对象。</li>\n</ul>\n<hr>\n<h3><strong>3. 如何代理对象的所有层级</strong></h3>\n<p>如果需要代理嵌套对象，可以在 <code>get</code> 捕获器中递归创建代理。</p>\n<h4><strong>示例：递归代理嵌套对象</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createDeepProxy</span>(<span class="hljs-params">target</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {\n    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop, receiver</span>) {\n      <span class="hljs-keyword">const</span> value = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, prop, receiver);\n      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; value !== <span class="hljs-literal">null</span>) {\n        <span class="hljs-keyword">return</span> <span class="hljs-title function_">createDeepProxy</span>(value); <span class="hljs-comment">// 递归创建代理</span>\n      }\n      <span class="hljs-keyword">return</span> value;\n    }\n  });\n}\n\n<span class="hljs-keyword">const</span> target = {\n  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,\n  <span class="hljs-attr">nested</span>: {\n    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>\n  }\n};\n\n<span class="hljs-keyword">const</span> deepProxy = <span class="hljs-title function_">createDeepProxy</span>(target);\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(deepProxy.<span class="hljs-property">a</span>); <span class="hljs-comment">// 输出 1</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(deepProxy.<span class="hljs-property">nested</span>.<span class="hljs-property">b</span>); <span class="hljs-comment">// 输出 2（现在嵌套对象也被代理了）</span>\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li><code>createDeepProxy</code> 函数递归地为嵌套对象创建代理。</li>\n<li>访问 <code>deepProxy.nested.b</code> 时，<code>nested</code> 对象也被代理了。</li>\n</ul>\n<hr>\n<h3><strong>4. 注意事项</strong></h3>\n<ul>\n<li><strong>性能考虑</strong>  ：递归代理嵌套对象可能会增加性能开销，特别是在对象结构复杂或深度嵌套的情况下。</li>\n<li><strong>循环引用</strong>  ：处理循环引用时需要小心，避免无限递归。可以通过记录已经代理过的对象来避免重复代理。</li>\n<li><strong>实际需求</strong>  ：根据实际需求决定是否需要代理嵌套对象。如果只需要代理第一层，可以省略递归代理。</li>\n</ul>\n<hr>\n<h3><strong>5. 总结</strong></h3>\n<ul>\n<li><strong><code>Proxy</code> 不会自动代理对象的所有层级</strong>  ，它只代理第一层对象。</li>\n<li><strong>如果需要代理嵌套对象</strong>  ，需要手动实现递归代理，通常通过递归函数实现。</li>\n<li><strong>根据实际需求</strong>  选择是否代理嵌套对象，权衡性能和功能需求。</li>\n</ul>\n<hr>\n<h3><strong>扩展：Proxy 与 Object.defineProperty 的对比</strong></h3>\n<ul>\n<li><strong><code>Object.defineProperty</code></strong>  ：\n<ul>\n<li>只能劫持对象的已有属性，无法监听属性的添加和删除。</li>\n<li>处理嵌套对象时需要递归遍历，容易出错且性能较差。</li>\n</ul>\n</li>\n<li><strong><code>Proxy</code></strong>  ：\n<ul>\n<li>可以代理对象的所有操作，包括属性访问、赋值、删除等。</li>\n<li>提供了更强大和灵活的响应式系统，可以处理嵌套对象（需要手动实现）。</li>\n</ul>\n</li>\n</ul>\n<p><code>Proxy</code> 是现代 JavaScript 开发中推荐使用的方式，特别是在需要处理复杂对象结构时。</p>\n</div>'</script></body></html>