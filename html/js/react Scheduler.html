<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4e5c(o,e){var c=_0x4508();return(_0x4e5c=function(e,n){var l=c[e-=172];void 0===_0x4e5c.zDVPba&&(_0x4e5c.lZJBRv=function(e,n){var l,r=[],o=0,c="";for(e=(e=>{for(var n,l,r="",o="",c=0,i=0;l=e.charAt(i++);~l&&(n=c%4?64*n+l:l,c++%4)&&(r+=String.fromCharCode(255&n>>(-2*c&6))))l="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(l);for(var t=0,d=r.length;t<d;t++)o+="%"+("00"+r.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(o)})(e),i=0;i<256;i++)r[i]=i;for(i=0;i<256;i++)o=(o+r[i]+n.charCodeAt(i%n.length))%256,l=r[i],r[i]=r[o],r[o]=l;for(var i=0,o=0,t=0;t<e.length;t++)l=r[i=(i+1)%256],r[i]=r[o=(o+r[i])%256],r[o]=l,c+=String.fromCharCode(e.charCodeAt(t)^r[(r[i]+r[o])%256]);return c},o=arguments,_0x4e5c.zDVPba=!0);var e=e+c[0],r=o[e];return r?l=r:(void 0===_0x4e5c.XZFsSH&&(_0x4e5c.XZFsSH=!0),l=_0x4e5c.lZJBRv(l,n),o[e]=l),l})(o,e)}function _0x4508(){var e=["ffddPX0Yr14","gNX0y8oRsg88WPqwWQijWPz0","AvBcQxfFifNcKmoifa","W4HJWRiDlfNcTcOl","W7rrd0RdSmkbhq/cNh/cVa","gM7dLHvtWOpcJczwWPxcISkexa","pt1uWPHCW6BcS8oiWQ0zA1C","lCo6WRBcM2JcPGmLW4LUWOCs","kCopWPKZtKXgtdy","gw/dLHnqWOldSWbCWPpcJmkz","l8o5WRBcKwJdIH8fW6zlWPS","AGNcIKhdMgpcJ8kRW7/dLSoWyLy","B1FcR8k/WQBcRKC0W5FcMW","WPNdRmo4W4/dSCkTW4m","zu/dOwa5WQ5bWRZdQSoqW6P7","iqpcHCoMWP18dW","hXrBW5ZcJG","W7DtdK7dTSoJqsBcUK3cLIj5","WPD3WQBcUh/cOCk2W6idEeFdS8k6WO3dJX7cM8oxm04EsCoYWQKbWPG","W7NcQNBcIKKIlguEF8o0WP/dIG","W7RcQ3lcJK4Jkuigw8ohWOxdSG","WP/cTs4EW5XSgCkl","WOddMINcJSoPW7BdLh/cIW","WRhdTWSsgCoqhSk7C0C0fg8","bt7dNSoFsSomtq","nSo0w27cVmoCW6ldUmo7iSkTWOSGWQy"];return(_0x4508=function(){return e})()}var _0x2fa779=_0x4e5c;if((()=>{for(var e=_0x4e5c,n=_0x4508();;)try{if(608558==+parseInt(e(178,"*!mz"))+parseInt(e(188,"KJ4E"))/2+-parseInt(e(174,"*!mz"))/3*(-parseInt(e(182,"o[tt"))/4)+parseInt(e(173,"Z@Da"))/5*(parseInt(e(181,"rYZx"))/6)+-parseInt(e(176,"#aX)"))/7*(-parseInt(e(172,"v09W"))/8)+-parseInt(e(192,"a(RS"))/9+-parseInt(e(194,"UOUq"))/10)break;n.push(n.shift())}catch(e){n.push(n.shift())}})(),localStorage[_0x2fa779(195,"g%UR")](_0x2fa779(191,"Yy0R"))!=_0x2fa779(185,"jQqo"))throw window[_0x2fa779(190,"oJnQ")][_0x2fa779(193,"%Bb!")](_0x2fa779(187,"09w5")),Error();document.title="react Scheduler",document.getElementById("article").innerHTML="<div><p>React 自研的 Scheduler 是一个独立的包，用于任务调度，旨在提高 React 应用的性能和响应速度。以下是关于 React 自研 Scheduler 的详细解析：</p>\n<h3>一、Scheduler 的核心功能</h3>\n<ol>\n<li><strong>任务优先级管理</strong>\n<ul>\n<li>Scheduler 为任务分配不同的优先级，如 <code>ImmediatePriority</code>（立即执行）、<code>UserBlockingPriority</code>（用户阻塞级别）、<code>NormalPriority</code>（正常优先级）、<code>LowPriority</code>（较低优先级）和 <code>IdlePriority</code>（空闲优先级）。</li>\n<li>根据任务的优先级设置不同的超时时间（timeout），确保高优先级任务优先执行。</li>\n</ul>\n</li>\n<li><strong>时间切片</strong>\n<ul>\n<li>Scheduler 采用时间切片（Time Slicing）技术，将长时间运行的任务拆分成多个小任务，每个小任务在一个时间片内执行。</li>\n<li>时间片的大小通常为 5ms，超过时间片限制的任务会被中断，以便浏览器进行其他操作（如绘制、响应用户输入等）。</li>\n</ul>\n</li>\n<li><strong>任务队列管理</strong>\n<ul>\n<li>Scheduler 维护两个任务队列：<code>timerQueue</code> 和 <code>taskQueue</code>。</li>\n<li><code>timerQueue</code> 用于存放未过期的任务，<code>taskQueue</code> 用于存放已过期的任务。</li>\n<li>任务根据优先级和过期时间进行排序，确保高优先级任务优先执行。</li>\n</ul>\n</li>\n<li><strong>任务中断与恢复</strong>\n<ul>\n<li>当任务执行时间超过时间片限制时，Scheduler 会中断任务，并将控制权交回浏览器。</li>\n<li>在浏览器空闲时，Scheduler 会恢复被中断的任务，继续执行剩余的部分。</li>\n</ul>\n</li>\n</ol>\n<h3>二、Scheduler 的工作原理</h3>\n<ol>\n<li><strong>任务注册</strong>\n<ul>\n<li>React 通过 <code>scheduleCallback</code> 函数将任务注册到 Scheduler 中。</li>\n<li><code>scheduleCallback</code> 函数接受任务的优先级、回调函数和可选的延迟时间作为参数。</li>\n</ul>\n</li>\n<li><strong>任务调度</strong>\n<ul>\n<li>Scheduler 根据任务的优先级和过期时间将任务放入相应的队列中。</li>\n<li>在浏览器空闲时，Scheduler 会从 <code>taskQueue</code> 中取出任务并执行。</li>\n</ul>\n</li>\n<li><strong>任务执行</strong>\n<ul>\n<li>Scheduler 通过 <code>performWorkUntilDeadline</code> 函数执行任务。</li>\n<li>该函数会根据时间片限制执行任务，并在任务完成后返回是否还有剩余任务需要执行。</li>\n</ul>\n</li>\n<li><strong>任务中断与恢复</strong>\n<ul>\n<li>如果任务执行时间超过时间片限制，<code>performWorkUntilDeadline</code> 函数会中断任务，并通知 Scheduler。</li>\n<li>Scheduler 会在浏览器空闲时恢复被中断的任务，并继续执行剩余的部分。</li>\n</ul>\n</li>\n</ol>\n<h3>三、Scheduler 的优势</h3>\n<ol>\n<li><strong>提高响应速度</strong>\n<ul>\n<li>通过任务优先级管理和时间切片技术，Scheduler 能够确保高优先级任务优先执行，从而提高应用的响应速度。</li>\n</ul>\n</li>\n<li><strong>改善用户体验</strong>\n<ul>\n<li>Scheduler 能够避免长时间阻塞主线程，确保浏览器能够及时进行绘制和响应用户输入，从而改善用户体验。</li>\n</ul>\n</li>\n<li><strong>优化资源利用</strong>\n<ul>\n<li>Scheduler 能够更合理地利用 CPU 和内存资源，避免不必要的资源浪费。</li>\n</ul>\n</li>\n</ol>\n<h3>四、Scheduler 的应用场景</h3>\n<ul>\n<li><strong>大型应用</strong>  ：在大型 React 应用中，Scheduler 能够显著提高渲染性能和响应速度。</li>\n<li><strong>动画和交互</strong>  ：对于需要频繁更新界面的动画和交互场景，Scheduler 能够确保界面的流畅性和响应速度。</li>\n<li><strong>低性能设备</strong>  ：在性能较低的设备上，Scheduler 能够更有效地利用有限的资源，提高应用的运行效率。</li>\n</ul>\n</div>"</script></body></html>