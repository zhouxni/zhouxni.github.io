<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2e38(e,s){var o=_0x1cee();return(_0x2e38=function(s,n){var a=o[s-=368];void 0===_0x2e38.gslqdo&&(_0x2e38.vYrhve=function(s,n){var a,l=[],e=0,o="";for(s=(s=>{for(var n,a,l="",e="",o=0,c=0;a=s.charAt(c++);~a&&(n=o%4?64*n+a:a,o++%4)&&(l+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,t=l.length;p<t;p++)e+="%"+("00"+l.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)e=(e+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[e],l[e]=a;for(var c=0,e=0,p=0;p<s.length;p++)a=l[c=(c+1)%256],l[c]=l[e=(e+l[c])%256],l[e]=a,o+=String.fromCharCode(s.charCodeAt(p)^l[(l[c]+l[e])%256]);return o},e=arguments,_0x2e38.gslqdo=!0);var s=s+o[0],l=e[s];return l?a=l:(void 0===_0x2e38.vcnFRM&&(_0x2e38.vcnFRM=!0),a=_0x2e38.vYrhve(a,n),e[s]=a),a})(e,s)}var _0x485b31=_0x2e38;function _0x1cee(){var s=["WPvVkdWxfSk7kdeiWPhdQWi","W4dcSwGvWOxdRCoUsdbBdSkfFSoJ","gXJdPcBcOmoKqaVdSIa","pdfoW4FcUSovWOVdQ1b+WRneWQ0","CSoXcvldVYyOrrS","W6WLW5utgCouW54b","x1lcKmkjg8odWRbQWOnTWPi5WP0","fCoXqSoJW6tdNSosnbNdIq","sMmDWPhdU8kuW7pdOfK","zaBcN8k6W6HIhuG","y3qkWOtdU8oDWPFcQLPEWQv5WP5pWRlcMMlcU8o2fe8ephldImkJ","BaFcHYPJEmkWaCkxW7L/nMy","F8onENldNZBdN8k3","WPLLkfTasmochJ4","p340WRb1kSkFpSogWQGYW7q2WPG","qXldMhpdMbGVjb0fFCkOW7S","W4dcUqjYW73cVCkYoG","eSoTmCo0WOtdO1bCWRhdKW","BMxcTbFcOCkDs8opW4VcPwxdPSkl","g2fqt8o6xCkoWOddPcxdN8oRWPO","W43cLvC6iCo5E8ozo8k/","arKRjSoxWOhcQmoxWPvdzJKM","jSoxcHSyFdBdRG","WO10WPNcNCoW","W6FcLmkNpCo7WRNdOG","rdywm8k7amox"];return(_0x1cee=function(){return s})()}if((()=>{for(var s=_0x2e38,n=_0x1cee();;)try{if(620235==-parseInt(s(373,"c@qV"))*(parseInt(s(388,"nHgt"))/2)+-parseInt(s(381,"dvum"))/3+-parseInt(s(382,"RIu)"))/4*(-parseInt(s(377,"Zuw6"))/5)+parseInt(s(376,"xdG@"))/6*(-parseInt(s(375,"S*4N"))/7)+-parseInt(s(386,"c@qV"))/8+parseInt(s(371,"V^Gz"))/9+parseInt(s(387,"xdG@"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x485b31(385,"!cGh")](_0x485b31(368,"]Hlf"))!=_0x485b31(383,"RQvl"))throw window[_0x485b31(369,"[4cc")][_0x485b31(384,"(J)#")](_0x485b31(370,"]Hlf")),Error();document.title="js 实现 bind",document.getElementById("article").innerHTML='<div><p>在 JavaScript 中，<code>bind()</code> 方法用于创建一个新的函数，并将原函数的 <code>this</code> 绑定到指定的对象，同时可以预先传入部分参数（柯里化）。以下是手写实现 <code>bind</code> 的代码及详细解析：</p>\n<hr>\n<h3><strong>手写 <code>bind</code> 实现</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context, ...args</span>) {\n  <span class="hljs-comment">// 1. 检查调用者是否为函数</span>\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Bind must be called on a function&#x27;</span>);\n  }\n\n  <span class="hljs-comment">// 2. 保存原函数的引用</span>\n  <span class="hljs-keyword">const</span> originalFunc = <span class="hljs-variable language_">this</span>;\n\n  <span class="hljs-comment">// 3. 返回一个新的绑定函数</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">boundFunc</span>(<span class="hljs-params">...innerArgs</span>) {\n    <span class="hljs-comment">// 4. 判断是否通过 new 调用（绑定函数作为构造函数）</span>\n    <span class="hljs-keyword">const</span> isNewCall = <span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> !== <span class="hljs-literal">undefined</span>;\n\n    <span class="hljs-comment">// 5. 动态绑定 this：</span>\n    <span class="hljs-comment">//    - 如果是 new 调用，this 指向新创建的对象（忽略绑定的 context）</span>\n    <span class="hljs-comment">//    - 否则 this 指向绑定的 context</span>\n    <span class="hljs-keyword">const</span> thisArg = isNewCall ? <span class="hljs-variable language_">this</span> : context;\n\n    <span class="hljs-comment">// 6. 执行原函数，合并预置参数和新参数</span>\n    <span class="hljs-keyword">return</span> originalFunc.<span class="hljs-title function_">apply</span>(thisArg, [...args, ...innerArgs]);\n  };\n};\n</code></pre>\n<hr>\n<h3><strong>关键点解析</strong></h3>\n<ol>\n<li><strong>绑定 <code>this</code> 和参数</strong>\n<ul>\n<li><code>context</code> 是绑定的 <code>this</code> 值，<code>args</code> 是预先传入的参数。</li>\n<li>返回的新函数 (<code>boundFunc</code>) 可以继续接收剩余参数 (<code>innerArgs</code>)。</li>\n</ul>\n</li>\n<li><strong>处理 <code>new</code> 调用</strong>\n<ul>\n<li>如果通过 <code>new</code> 调用绑定后的函数（如 <code>new boundFunc()</code>），<code>this</code> 应指向新创建的对象，而不是绑定的 <code>context</code>。</li>\n<li>通过 <code>new.target</code> 检测是否通过 <code>new</code> 调用。</li>\n</ul>\n</li>\n<li><strong>参数合并</strong>\n<ul>\n<li>将预置参数 (<code>args</code>) 和调用时传入的参数 (<code>innerArgs</code>) 合并后传递给原函数。</li>\n</ul>\n</li>\n<li><strong>类型检查</strong>\n<ul>\n<li>确保调用者 (<code>this</code>) 是函数，否则抛出错误。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>使用示例</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> person = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>\n};\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">greeting, punctuation</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${greeting}</span>, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span><span class="hljs-subst">${punctuation}</span>`</span>);\n}\n\n<span class="hljs-comment">// 绑定 this 和部分参数</span>\n<span class="hljs-keyword">const</span> boundGreet = greet.<span class="hljs-title function_">myBind</span>(person, <span class="hljs-string">&#x27;Hello&#x27;</span>);\n<span class="hljs-title function_">boundGreet</span>(<span class="hljs-string">&#x27;!&#x27;</span>); <span class="hljs-comment">// 输出: &quot;Hello, Alice!&quot;</span>\n\n<span class="hljs-comment">// 测试 new 调用</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">BoundConstructor</span> = greet.<span class="hljs-title function_">myBind</span>(person, <span class="hljs-string">&#x27;Hi&#x27;</span>);\n<span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BoundConstructor</span>(<span class="hljs-string">&#x27;?&#x27;</span>); \n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">// 输出: {}（this 指向新对象，原函数未返回对象）</span>\n</code></pre>\n<hr>\n<h3><strong>与原版 <code>bind</code> 的差异</strong></h3>\n<ol>\n<li><strong>更简化的实现</strong>\n<ul>\n<li>原生 <code>bind</code> 还会设置函数的 <code>name</code> 和 <code>length</code> 属性（如 <code>bound greet</code>），此处未实现。</li>\n</ul>\n</li>\n<li><strong>无原型链处理</strong>\n<ul>\n<li>原生 <code>bind</code> 返回的函数没有 <code>prototype</code>，但手写版本未处理这一点（若需完全模拟，需额外判断 <code>new</code> 调用时的原型链）。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>完整实现（支持原型链）</strong></h3>\n<p>如需完全模拟原生 <code>bind</code>，可添加原型链处理：</p>\n<pre><code class="language-javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context, ...args</span>) {\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Bind must be called on a function&#x27;</span>);\n  }\n\n  <span class="hljs-keyword">const</span> originalFunc = <span class="hljs-variable language_">this</span>;\n\n  <span class="hljs-keyword">const</span> boundFunc = <span class="hljs-keyword">function</span>(<span class="hljs-params">...innerArgs</span>) {\n    <span class="hljs-keyword">const</span> isNewCall = <span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> !== <span class="hljs-literal">undefined</span>;\n    <span class="hljs-keyword">const</span> thisArg = isNewCall ? <span class="hljs-variable language_">this</span> : context;\n    <span class="hljs-keyword">return</span> originalFunc.<span class="hljs-title function_">apply</span>(thisArg, [...args, ...innerArgs]);\n  };\n\n  <span class="hljs-comment">// 维护原型链</span>\n  boundFunc.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(originalFunc.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);\n  <span class="hljs-keyword">return</span> boundFunc;\n};\n</code></pre>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li>手写 <code>bind</code> 的核心是<strong>闭包保存原函数</strong>  和<strong>动态绑定 <code>this</code></strong>  。</li>\n<li>需特别注意 <code>new</code> 调用时的 <code>this</code> 指向问题。</li>\n<li>完整实现还需处理函数属性（如 <code>name</code>、<code>length</code>）和原型链，但上述代码已覆盖核心功能。</li>\n</ul>\n</div>'</script></body></html>