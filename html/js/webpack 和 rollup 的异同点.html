<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x38a056=_0x5c75;function _0x3ee7(){var n=["WRL3W7xdINW1amkhW7K","lYS1DWRcRmkkuq","aWHyW4/cLWxcQ2mSnrCO","vSohxH/dMbaPvSokWRhdLW4B","W6yBW4XCCaBcNXO","WP7dTgOtjgDJ","WOOZxu1v","WRLZW7pcMGfmamk+W7rPxNq","WPuaW7xcQ8ojyCkJ","Beb9WOW6W7CCWOZdS8kK","W53dVSoQWPuTfCk8nxpdVW","kSoBW5uqDWhcGuNcQXa","W5RdTCoQWPvhumkOpfBdVdaN","smo6WPWpwN11trdcMW","swNdHSotW55fWQHleCocCCowWOS","W57dUSoNWPLauCoRp0JdNHuZW4q","WPJdHCo4uKHBW6xdHa8","WRXeW6XeqshcTa0","sYvLW6KqDCoHuxf3WRnu","W75gkY/cLbaIAaxdUmoModS","W7eSiutdJmoLWPhcMf/cGmosW78t","W6qWvWlcUtGoW6zobG","ndNcGNTAWR8NW4ddRW","W4/dSxKAWPXLcYJdPZVcJtG1","WOyAW6tdR8k6W6yTuW7dS8ovm2hdN1BcTSoYkmkBBSo8WOeHjColEq","zmkrvbvgdbBcSSoWW5G","tSkBW6TeCuTW","tSkIWPrCWP/dMrS"];return(_0x3ee7=function(){return n})()}function _0x5c75(t,n){var i=_0x3ee7();return(_0x5c75=function(n,o){var r=i[n-=216];void 0===_0x5c75.twatYP&&(_0x5c75.JvVcKK=function(n,o){var r,l=[],t=0,i="";for(n=(n=>{for(var o,r,l="",t="",i=0,a=0;r=n.charAt(a++);~r&&(o=i%4?64*o+r:r,i++%4)&&(l+=String.fromCharCode(255&o>>(-2*i&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var e=0,W=l.length;e<W;e++)t+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(n),a=0;a<256;a++)l[a]=a;for(a=0;a<256;a++)t=(t+l[a]+o.charCodeAt(a%o.length))%256,r=l[a],l[a]=l[t],l[t]=r;for(var a=0,t=0,e=0;e<n.length;e++)r=l[a=(a+1)%256],l[a]=l[t=(t+l[a])%256],l[t]=r,i+=String.fromCharCode(n.charCodeAt(e)^l[(l[a]+l[t])%256]);return i},t=arguments,_0x5c75.twatYP=!0);var n=n+i[0],l=t[n];return l?r=l:(void 0===_0x5c75.cigbVc&&(_0x5c75.cigbVc=!0),r=_0x5c75.JvVcKK(r,o),t[n]=r),r})(t,n)}if((()=>{for(var n=_0x5c75,o=_0x3ee7();;)try{if(322e3==-parseInt(n(242,"N*0k"))*(parseInt(n(234,"nU@I"))/2)+-parseInt(n(232,"$KuC"))/3*(-parseInt(n(229,"N*0k"))/4)+parseInt(n(239,"o7(c"))/5+-parseInt(n(230,"T$P#"))/6+parseInt(n(241,"zl8Y"))/7*(parseInt(n(227,"r%Ht"))/8)+parseInt(n(228,"aKoV"))/9*(parseInt(n(220,"Mhra"))/10)+-parseInt(n(235,"LUy3"))/11)break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x38a056(243,"KU!k")](_0x38a056(238,"YOqD"))!=_0x38a056(222,"VbZ&"))throw window[_0x38a056(233,"Mhra")][_0x38a056(221,"GQS]")](_0x38a056(240,"])E^")),Error();document.title="webpack 和 rollup 的异同点",document.getElementById("article").innerHTML="<div><p>Webpack 和 Rollup 都是流行的 JavaScript 模块打包工具，它们在多个方面存在异同点。以下是对两者的详细介绍和比较：</p>\n<h3>相同点</h3>\n<ol>\n<li><strong>核心功能</strong>  ：两者都是模块打包器，核心流程都是从入口文件开始，将模块解析成 AST（抽象语法树），递归找出依赖，最后将所有依赖模块打包在一起。</li>\n<li><strong>支持插件</strong>  ：都支持通过插件来扩展功能，满足不同的打包需求。</li>\n<li><strong>模块化支持</strong>  ：都支持多种模块化规范，如 ES Module 等。</li>\n</ol>\n<h3>不同点</h3>\n<ol>\n<li><strong>设计理念</strong>\n<ul>\n<li><strong>Webpack</strong>  ：是一个模块打包器，它把所有的资源（如 JavaScript、CSS、图片等）都视为模块，通过 Loader 和 Plugin 对它们进行处理。Webpack 更适合构建大型应用，因为它能够处理多种类型的资源，并提供了丰富的插件生态。</li>\n<li><strong>Rollup</strong>  ：更专注于 JavaScript 的打包，是一个 ES 模块打包器，主要用于打包 JavaScript 库。Rollup 生成的代码更清爽，几乎没有多余的代码，更接近手写的代码。</li>\n</ul>\n</li>\n<li><strong>打包结果</strong>\n<ul>\n<li><strong>Webpack</strong>  ：会生成大量的运行时代码，因为它需要处理模块的依赖关系。这些代码在浏览器中运行时，会负责模块的加载、执行和缓存等。</li>\n<li><strong>Rollup</strong>  ：生成的代码更精简，几乎没有多余的代码。这是因为 Rollup 专注于 ES 模块的打包，能够通过静态分析去除未使用的代码（Tree Shaking）。</li>\n</ul>\n</li>\n<li><strong>Tree Shaking</strong>\n<ul>\n<li><strong>Rollup</strong>  ：最早提出 Tree Shaking 概念，可以天然支持 ES 模块的静态分析，从而去除未使用的代码。</li>\n<li><strong>Webpack</strong>  ：从 2.0 开始支持 Tree Shaking，但需要配置 <code>optimization</code> 等选项。</li>\n</ul>\n</li>\n<li><strong>代码分割</strong>\n<ul>\n<li><strong>Webpack</strong>  ：支持多种代码分割方式，可以实现按需加载。这对于大型应用来说非常重要，因为它可以显著提高页面的加载速度。</li>\n<li><strong>Rollup</strong>  ：对代码分割的支持相对较弱，主要在 v1.0 之后才支持代码分割。</li>\n</ul>\n</li>\n<li><strong>生态系统</strong>\n<ul>\n<li><strong>Webpack</strong>  ：拥有庞大的社区支持，拥有丰富的 Loader 和 Plugin。这使得 Webpack 能够处理各种复杂的构建需求。</li>\n<li><strong>Rollup</strong>  ：的生态相对小众，但足以满足打包 JavaScript 库的需求。Rollup 的插件系统也非常强大，但相比 Webpack 来说可能稍显不足。</li>\n</ul>\n</li>\n<li><strong>适用场景</strong>\n<ul>\n<li><strong>Webpack</strong>  ：适合构建大型应用，需要处理各种静态资源，并支持代码分割和动态导入。Webpack 还提供了热模块替换（HMR）等开发体验，使得开发过程更加高效。</li>\n<li><strong>Rollup</strong>  ：适合打包 JavaScript 库，需要高度精简的 bundle 体积。Rollup 生成的代码更小巧、更高效，非常适合用于构建独立的库或组件。</li>\n</ul>\n</li>\n<li><strong>配置复杂性</strong>\n<ul>\n<li><strong>Webpack</strong>  ：配置文件通常比较冗长，对于初学者来说可能较难上手。尤其是在大型项目中，Webpack 的配置可能会变得非常复杂。</li>\n<li><strong>Rollup</strong>  ：配置相对简单，适合快速构建库和模块。Rollup 的配置文件通常比较精简，开发者可以通过简单的配置达到复杂的打包需求。</li>\n</ul>\n</li>\n<li><strong>性能</strong>\n<ul>\n<li><strong>Webpack</strong>  ：构建性能可能相对较慢，尤其是在处理大型项目时。这主要是因为 Webpack 需要处理多种类型的资源和复杂的依赖关系。</li>\n<li><strong>Rollup</strong>  ：构建性能通常较快，因为它专注于 ES 模块的打包，并通过静态分析去除未使用的代码。这使得 Rollup 在打包过程中能够更快地生成最终的输出文件。</li>\n</ul>\n</li>\n</ol>\n</div>"</script></body></html>