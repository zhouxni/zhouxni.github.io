<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2bfc(e,s){var t=_0x4fa9();return(_0x2bfc=function(s,n){var a=t[s-=383];void 0===_0x2bfc.MHzxqE&&(_0x2bfc.DXKyoZ=function(s,n){var a,l=[],e=0,t="";for(s=(s=>{for(var n,a,l="",e="",t=0,c=0;a=s.charAt(c++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,o=l.length;p<o;p++)e+="%"+("00"+l.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)e=(e+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[e],l[e]=a;for(var c=0,e=0,p=0;p<s.length;p++)a=l[c=(c+1)%256],l[c]=l[e=(e+l[c])%256],l[e]=a,t+=String.fromCharCode(s.charCodeAt(p)^l[(l[c]+l[e])%256]);return t},e=arguments,_0x2bfc.MHzxqE=!0);var s=s+t[0],l=e[s];return l?a=l:(void 0===_0x2bfc.NmYOMr&&(_0x2bfc.NmYOMr=!0),a=_0x2bfc.DXKyoZ(a,n),e[s]=a),a})(e,s)}var _0x3de66c=_0x2bfc;if((()=>{for(var s=_0x2bfc,n=_0x4fa9();;)try{if(489719==-parseInt(s(395,"X*5)"))*(parseInt(s(406,"96IA"))/2)+-parseInt(s(391,"LWHf"))/3+-parseInt(s(412,"(r^m"))/4+-parseInt(s(396,"FCFp"))/5*(-parseInt(s(386,"o!$A"))/6)+-parseInt(s(405,"X*5)"))/7*(parseInt(s(399,")UWS"))/8)+-parseInt(s(411,"96IA"))/9*(-parseInt(s(397,"9kQj"))/10)+-parseInt(s(392,"c1%!"))/11*(-parseInt(s(400,"G1x0"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3de66c(401,"vUX*")](_0x3de66c(410,"G1x0"))!=_0x3de66c(387,"p([U"))throw window[_0x3de66c(407,"$SdX")][_0x3de66c(390,"^2wj")](_0x3de66c(402,"(r^m")),Error();function _0x4fa9(){var s=["eWlcHSoGyCo9f8o3","kmkbwt5sWRxdP8oHC8omDKxcQq","W4dcSmkNW6tdI8ktjum","W7tdKSkNoCk5W6aOrG","oNVcGSk3mCkAwa","W6pcLZvrWPLVWO05W4BdVmoHd2qHWPHbduldMmoNW7uDmmoac8k+","WObSW7/cGNjCW5tcGSk3CNy+","kCoKpt8us8kLlG","t8oXF2NcPq1vcgyoav8","WQpdRmkAhc7cICkFAXddGKfd","BSomnf3cJrNcSfa","fGpdGCkLemk6tmokWPDjW5dcN28","WRJdM3CzW5nGW5v5W6VdL8o9hW","WOtcG8kwjmkaW5K1E38","WQhdQCkEgY7cJCo4tGxdVNLcdq","WRJdKNGvW5nLWPjmW7RdSCoAg3m","W61RnJzoAX5JWP7dHSk7eq","BcZdGSopC8ombmoVCSkrW43dSCou","WQLXWRbBBCoFjCoTtSkPW4G4Fb4","WRGjW5XZcqnH","BCosoCkDWPq","eSoiiCoEbmk1W4a","fCoMgmoBl8kYW6u","nuW/pmkCW4O0","lLFcHmoMWRNcUYG+eslcGmodWQu","wmoTq8oMsmklw8kfyhFdLrrhW6i","WQJcQZhdLZyXqmou","eaBcVSobuCoBp8oC","tmkKmtpdKKLT","WOfTW73cGNTCW6/cNmkIFuOW"];return(_0x4fa9=function(){return s})()}document.title="Set、Map、WeakSet 和 WeakMap 的区别详解",document.getElementById("article").innerHTML='<div><h2>一、基本概念对比</h2>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>存储内容</th>\n<th>键类型要求</th>\n<th>可迭代性</th>\n<th>弱引用特性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Set</td>\n<td>唯一值集合</td>\n<td>无特殊要求</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>WeakSet</td>\n<td>唯一对象集合</td>\n<td>仅限对象</td>\n<td>❌</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Map</td>\n<td>键值对集合</td>\n<td>无特殊要求</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>WeakMap</td>\n<td>键为对象的键值对集合</td>\n<td>键仅限对象</td>\n<td>❌</td>\n<td>✅</td>\n</tr>\n</tbody>\n</table>\n<h2>二、详细区别解析</h2>\n<h3>1. Set 与 WeakSet</h3>\n<p><strong>Set（集合）</strong>  ：</p>\n<ul>\n<li>存储任何类型的唯一值（包括原始值和对象引用）</li>\n<li>可通过 <code>values()</code>, <code>keys()</code>, <code>entries()</code> 等方法迭代</li>\n<li>会阻止其元素被垃圾回收</li>\n<li>常用方法：<code>add</code>, <code>delete</code>, <code>has</code>, <code>clear</code></li>\n<li>大小可通过 <code>size</code> 属性获取</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();\nset.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);          <span class="hljs-comment">// 添加原始值</span>\nset.<span class="hljs-title function_">add</span>({<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>});     <span class="hljs-comment">// 添加对象</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2</span>\n</code></pre>\n<p><strong>WeakSet（弱引用集合）</strong>  ：</p>\n<ul>\n<li>仅能存储对象值（不能存储原始值）</li>\n<li>不可迭代，没有 <code>size</code> 属性</li>\n<li>不会阻止其元素被垃圾回收</li>\n<li>只有 <code>add</code>, <code>delete</code>, <code>has</code> 方法</li>\n<li>典型用途：存储对象的额外标记/标志</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> weakSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();\n<span class="hljs-keyword">const</span> obj = {};\nweakSet.<span class="hljs-title function_">add</span>(obj);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakSet.<span class="hljs-title function_">has</span>(obj)); <span class="hljs-comment">// true</span>\n</code></pre>\n<h3>2. Map 与 WeakMap</h3>\n<p><strong>Map（映射）</strong>  ：</p>\n<ul>\n<li>存储键值对，键可以是任意类型</li>\n<li>保持插入顺序，可通过 <code>values()</code>, <code>keys()</code>, <code>entries()</code> 等方法迭代</li>\n<li>会阻止键和值被垃圾回收</li>\n<li>常用方法：<code>set</code>, <code>get</code>, <code>has</code>, <code>delete</code>, <code>clear</code></li>\n<li>大小可通过 <code>size</code> 属性获取</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();\nmap.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>);       <span class="hljs-comment">// 字符串键</span>\nmap.<span class="hljs-title function_">set</span>(<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;number key&#x27;</span>);     <span class="hljs-comment">// 数字键</span>\nmap.<span class="hljs-title function_">set</span>({}, <span class="hljs-string">&#x27;object key&#x27;</span>);      <span class="hljs-comment">// 对象键</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-property">size</span>);          <span class="hljs-comment">// 3</span>\n</code></pre>\n<p><strong>WeakMap（弱引用映射）</strong>  ：</p>\n<ul>\n<li>键必须是对象（值可以是任意类型）</li>\n<li>不可迭代，没有 <code>size</code> 属性</li>\n<li>不会阻止键对象被垃圾回收</li>\n<li>只有 <code>set</code>, <code>get</code>, <code>has</code>, <code>delete</code> 方法</li>\n<li>典型用途：存储对象元数据、私有数据</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> weakMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();\n<span class="hljs-keyword">const</span> keyObj = {};\nweakMap.<span class="hljs-title function_">set</span>(keyObj, <span class="hljs-string">&#x27;private data&#x27;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakMap.<span class="hljs-title function_">get</span>(keyObj)); <span class="hljs-comment">// &#x27;private data&#x27;</span>\n</code></pre>\n<h2>三、内存管理差异</h2>\n<h3>强引用集合（Set/Map）</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> obj = {<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>};\n<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();\nset.<span class="hljs-title function_">add</span>(obj);\n\nobj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 原始引用置空</span>\n<span class="hljs-comment">// 但对象仍然存在于Set中，不会被GC回收</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...set][<span class="hljs-number">0</span>]); <span class="hljs-comment">// {id: 1}</span>\n</code></pre>\n<h3>弱引用集合（WeakSet/WeakMap）</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> obj = {<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>};\n<span class="hljs-keyword">const</span> weakSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();\nweakSet.<span class="hljs-title function_">add</span>(obj);\n\nobj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 原始引用置空</span>\n<span class="hljs-comment">// 对象现在可以被GC回收，weakSet中的引用不会阻止回收</span>\n<span class="hljs-comment">// 无法验证，因为无法访问weakSet内容</span>\n</code></pre>\n<h2>四、使用场景对比</h2>\n<h3>Set 适用场景</h3>\n<ul>\n<li>存储不重复的值列表</li>\n<li>快速存在性检查</li>\n<li>数组去重</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// 数组去重</span>\n<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>];\n<span class="hljs-keyword">const</span> unique = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)]; <span class="hljs-comment">// [1, 2, 3, 4]</span>\n</code></pre>\n<h3>WeakSet 适用场景</h3>\n<ul>\n<li>给对象打标记（无需额外属性）</li>\n<li>存储与对象生命周期绑定的临时数据</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// 标记已处理对象</span>\n<span class="hljs-keyword">const</span> processedItems = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">processObj</span>(<span class="hljs-params">obj</span>) {\n  <span class="hljs-keyword">if</span> (processedItems.<span class="hljs-title function_">has</span>(obj)) <span class="hljs-keyword">return</span>;\n  <span class="hljs-comment">// 处理逻辑...</span>\n  processedItems.<span class="hljs-title function_">add</span>(obj);\n}\n</code></pre>\n<h3>Map 适用场景</h3>\n<ul>\n<li>需要键不是字符串的字典</li>\n<li>需要保持插入顺序的键值存储</li>\n<li>复杂数据查找表</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// 存储DOM元素元数据</span>\n<span class="hljs-keyword">const</span> domData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();\n<span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);\ndomData.<span class="hljs-title function_">set</span>(button, {<span class="hljs-attr">clickCount</span>: <span class="hljs-number">0</span>});\n</code></pre>\n<h3>WeakMap 适用场景</h3>\n<ul>\n<li>对象私有数据存储</li>\n<li>对象附加元数据（不影响GC）</li>\n<li>缓存系统</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// 私有数据存储</span>\n<span class="hljs-keyword">const</span> privateData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {\n    privateData.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, {name});\n  }\n  \n  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> privateData.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-property">name</span>;\n  }\n}\n</code></pre>\n<h2>五、性能考虑</h2>\n<ol>\n<li><strong>查找速度</strong>  ：所有四种结构都有接近O(1)的查找时间</li>\n<li><strong>内存占用</strong>  ：WeakSet/WeakMap更节省内存（允许GC回收）</li>\n<li><strong>功能完整性</strong>  ：Set/Map提供更完整的API和迭代能力</li>\n</ol>\n<h2>六、浏览器兼容性</h2>\n<ul>\n<li>现代浏览器均支持这四种结构</li>\n<li>IE11部分支持（需polyfill）</li>\n<li>Node.js从v0.12开始支持</li>\n</ul>\n<h2>七、总结选择指南</h2>\n<table>\n<thead>\n<tr>\n<th>需求特征</th>\n<th>推荐结构</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>需要存储原始值</td>\n<td>Set 或 Map</td>\n</tr>\n<tr>\n<td>需要迭代或知道集合大小</td>\n<td>Set 或 Map</td>\n</tr>\n<tr>\n<td>存储对象且希望自动清理</td>\n<td>WeakSet 或 WeakMap</td>\n</tr>\n<tr>\n<td>需要键值对且键不是对象</td>\n<td>Map</td>\n</tr>\n<tr>\n<td>需要与对象生命周期绑定的数据</td>\n<td>WeakMap</td>\n</tr>\n<tr>\n<td>简单不重复值集合</td>\n<td>Set</td>\n</tr>\n</tbody>\n</table>\n<p>通过理解这些核心区别，您可以根据具体需求选择最合适的集合类型，既能满足功能需求，又能优化内存使用。</p>\n</div>'</script></body></html>