<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x525fba=_0x2f32;function _0x5150(){var s=["W5pdIWrPW4LThfSsWP4gWRFcVa","gtNdLMtcOGVdHSoRcCkZWRJcUcO","hudcPYnDCSk5sN8PW4Sc","WPW6WPjoW5JcKqVcOtddPX4","kLRdR8kychVcHwqOdSkfW4ae","B8kcWQ3dQr7dHmkcu8osWOLpBcK","W5pdNCkOW4pcS3rvyG","WRFcIvNdLSkabIRcGbi/WPNcLSkmiSk0w3BdN0KvtrexWOXUW70","hZlcQmkOFSo2omobWOFcUCocAHm5","a8kxWPHVsclcV8k0","WPG6WPHkW5FdJchcMGtdRJ4T","m0tdMq7cU2S2WRXpma","tKldS8kaEbTjDLTbCebKWQ4","WPG5WPndWRNcRXhcTHddUG","ue8mWQJcOmkLuam4meWl","dSk4W7mJW6HgdWK","W4NcKSosWOqk","Ad4suNKVlv/dQmkIWOq","omk+aW7cOSkBnmonWPm","cmkWWRHKWRrQjHTcWOxdIq","aSkxW7e2cf/cTCkZrmkfWRqy","g8oMW7bJsSobW7etBSo4W7i","rSk+WQi7dmo+W4KB","E8oPwmkFWRyFgW","WQ3dM8osWPpdMqBcNW","W63dJxZdJ8klC1ZdPG"];return(_0x5150=function(){return s})()}function _0x2f32(c,s){var r=_0x5150();return(_0x2f32=function(s,n){var a=r[s-=139];void 0===_0x2f32.FFiAXB&&(_0x2f32.sOoqUe=function(s,n){var a,e=[],c=0,r="";for(s=(s=>{for(var n,a,e="",c="",r=0,t=0;a=s.charAt(t++);~a&&(n=r%4?64*n+a:a,r++%4)&&(e+=String.fromCharCode(255&n>>(-2*r&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,p=e.length;o<p;o++)c+="%"+("00"+e.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(c)})(s),t=0;t<256;t++)e[t]=t;for(t=0;t<256;t++)c=(c+e[t]+n.charCodeAt(t%n.length))%256,a=e[t],e[t]=e[c],e[c]=a;for(var t=0,c=0,o=0;o<s.length;o++)a=e[t=(t+1)%256],e[t]=e[c=(c+e[t])%256],e[c]=a,r+=String.fromCharCode(s.charCodeAt(o)^e[(e[t]+e[c])%256]);return r},c=arguments,_0x2f32.FFiAXB=!0);var s=s+r[0],e=c[s];return e?a=e:(void 0===_0x2f32.HIpgWi&&(_0x2f32.HIpgWi=!0),a=_0x2f32.sOoqUe(a,n),c[s]=a),a})(c,s)}if((()=>{for(var s=_0x2f32,n=_0x5150();;)try{if(919333==-parseInt(s(155,"ud*c"))+parseInt(s(164,"9UlO"))/2+-parseInt(s(156,"mLb4"))/3*(-parseInt(s(145,"mLb4"))/4)+-parseInt(s(141,"1m8S"))/5+parseInt(s(142,"*PC*"))/6*(-parseInt(s(163,"uo@6"))/7)+-parseInt(s(153,"ZK9x"))/8*(-parseInt(s(149,"db7u"))/9)+parseInt(s(148,"hbK6"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x525fba(160,"%F7!")](_0x525fba(154,"ns6C"))!=_0x525fba(152,"XyaM"))throw window[_0x525fba(158,"8eG5")][_0x525fba(159,"9znV")](_0x525fba(143,"%GZ6")),Error();document.title="vue2 watcher 队列排序",document.getElementById("article").innerHTML='<div><p>在 Vue 2 中，当响应式数据发生变化时，Vue 会将所有受影响的 watcher 收集到一个队列中，并在下次 tick 时批量更新。在更新前，Vue 会对这个队列进行排序，其中就包括你提到的按 <code>id</code> 排序的操作。这个排序操作是 Vue 2 响应式系统的关键优化，主要出于以下几个原因：</p>\n<h3><strong>一、确保组件更新顺序的确定性</strong></h3>\n<p>Vue 组件的更新顺序需要遵循 <strong>父组件先于子组件更新</strong>   的原则。这是因为子组件的渲染可能依赖于父组件的数据或状态。通过按 <code>id</code> 排序，可以保证：</p>\n<ol>\n<li><strong>父组件 watcher 的 <code>id</code> 小于子组件</strong>   ：Vue 在创建组件实例时，会为每个 watcher 分配一个递增的 <code>id</code>。父组件的实例创建早于子组件，因此其 watcher 的 <code>id</code> 更小。</li>\n<li><strong>排序后队列按 <code>id</code> 升序排列</strong>   ：通过 <code>a.id - b.id</code> 的比较，确保父组件的更新操作先于子组件执行。</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// Vue 2 源码简化示例</span>\nqueue.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">id</span> - b.<span class="hljs-property">id</span>);\n\n<span class="hljs-comment">// 排序后：</span>\n<span class="hljs-comment">// [父组件 watcher, 子组件 watcher, 孙组件 watcher, ...]</span>\n</code></pre>\n<h3><strong>二、避免重复更新</strong></h3>\n<p>在同一轮更新中，同一个 watcher 可能被多次触发（例如在父组件更新过程中修改了子组件的数据）。Vue 通过 <code>id</code> 排序和去重机制确保每个 watcher 只执行一次：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// Vue 2 源码简化逻辑</span>\n<span class="hljs-keyword">const</span> has = {};\n<span class="hljs-keyword">const</span> queue = [];\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">queueWatcher</span>(<span class="hljs-params">watcher</span>) {\n  <span class="hljs-keyword">const</span> id = watcher.<span class="hljs-property">id</span>;\n  <span class="hljs-keyword">if</span> (!has[id]) {\n    has[id] = <span class="hljs-literal">true</span>;\n    queue.<span class="hljs-title function_">push</span>(watcher);\n    <span class="hljs-comment">// 排序和批量更新逻辑</span>\n  }\n}\n</code></pre>\n<p>排序后，相同 <code>id</code> 的 watcher 会相邻排列，方便 Vue 去重处理。</p>\n<h3><strong>三、确保用户自定义 watcher 的执行顺序</strong></h3>\n<p>除了组件渲染 watcher，Vue 还允许用户通过 <code>watch</code> 选项或 <code>$watch</code> 方法创建自定义 watcher。这些 watcher 的执行顺序也需要被正确管理：</p>\n<ol>\n<li><strong>用户 watcher 的 <code>id</code> 小于渲染 watcher</strong>   ：用户 watcher 在 initState() 阶段创建（处理 watch 选项）。</li>\n<li><strong>排序后用户 watcher 会在渲染 watcher 之前执行</strong>   ：确保数据变化先执行用户自定义的回调，再触发 DOM 更新。</li>\n</ol>\n<h3><strong>四、源码验证</strong></h3>\n<p>在 Vue 2 的源码中，可以找到这段排序逻辑：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// vue/src/core/observer/scheduler.js</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">flushSchedulerQueue</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 对 watcher 队列排序</span>\n  queue.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">id</span> - b.<span class="hljs-property">id</span>);\n\n  <span class="hljs-comment">// 遍历执行所有 watcher</span>\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; queue.<span class="hljs-property">length</span>; i++) {\n    <span class="hljs-keyword">const</span> watcher = queue[i];\n    watcher.<span class="hljs-title function_">run</span>();\n  }\n}\n</code></pre>\n<h3><strong>五、总结</strong></h3>\n<p>Vue 2 对 watcher 队列按 <code>id</code> 排序的核心目的是：</p>\n<ol>\n<li><strong>保证组件更新顺序</strong>   ：父组件 → 子组件 → 孙组件，避免子组件依赖的父数据未更新。</li>\n<li><strong>避免重复更新</strong>   ：通过 <code>id</code> 去重，确保每个 watcher 只执行一次。</li>\n<li><strong>管理用户 watcher 执行时机</strong>   ：确保触发用户自定义的回调在 DOM 更新之前。</li>\n</ol>\n<p>这种设计是 Vue 2 响应式系统高效且稳定运行的重要保障。在 Vue 3 中，虽然响应式系统重构为 Proxy 实现，但类似的更新顺序管理原则依然存在。</p>\n</div>'</script></body></html>