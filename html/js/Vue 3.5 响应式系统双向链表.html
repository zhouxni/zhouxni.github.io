<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3d7301=_0x5441;if((()=>{for(var s=_0x5441,e=_0x5cd1();;)try{if(570626==+parseInt(s(285,"b]Yi"))+parseInt(s(295,"0CY3"))/2*(-parseInt(s(293,"xhl6"))/3)+-parseInt(s(306,"N9Z8"))/4+-parseInt(s(300,"rmcC"))/5*(-parseInt(s(305,"0CY3"))/6)+parseInt(s(297,"9)aM"))/7+-parseInt(s(303,"2p#g"))/8+-parseInt(s(294,"NPVh"))/9*(-parseInt(s(304,"j*wd"))/10))break;e.push(e.shift())}catch(s){e.push(e.shift())}})(),localStorage[_0x3d7301(291,"9u25")](_0x3d7301(287,"tz9u"))!=_0x3d7301(298,"0CY3"))throw window[_0x3d7301(307,"j*w3")][_0x3d7301(292,"9J3Y")](_0x3d7301(301,"xUb2")),Error();function _0x5441(a,s){var l=_0x5cd1();return(_0x5441=function(s,e){var n=l[s-=285];void 0===_0x5441.lKooDc&&(_0x5441.FECPlt=function(s,e){var n,p=[],a=0,l="";for(s=(s=>{for(var e,n,p="",a="",l=0,c=0;n=s.charAt(c++);~n&&(e=l%4?64*e+n:n,l++%4)&&(p+=String.fromCharCode(255&e>>(-2*l&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var o=0,d=p.length;o<d;o++)a+="%"+("00"+p.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(a)})(s),c=0;c<256;c++)p[c]=c;for(c=0;c<256;c++)a=(a+p[c]+e.charCodeAt(c%e.length))%256,n=p[c],p[c]=p[a],p[a]=n;for(var c=0,a=0,o=0;o<s.length;o++)n=p[c=(c+1)%256],p[c]=p[a=(a+p[c])%256],p[a]=n,l+=String.fromCharCode(s.charCodeAt(o)^p[(p[c]+p[a])%256]);return l},a=arguments,_0x5441.lKooDc=!0);var s=s+l[0],p=a[s];return p?n=p:(void 0===_0x5441.xaecVv&&(_0x5441.xaecVv=!0),n=_0x5441.FECPlt(n,e),a[s]=n),n})(a,s)}function _0x5cd1(){var s=["g8ocwCkQW7BdI8kKW4CBtCk6W7BcUa","xmkPWPJdISkfy8kQzSkFWRddLKNcMq","WP3dOuxcKxS","WPXEaNidW6G9vmk3DgH5","AJJcOSobW7NcJuWI","W6PjnMzNW4tdImkltZ7dRmoUemoUxSkVW6S8sI/dLmo2W7NdKmoQxq","h8kVteldN8kIqW","W5KnD8k3WPZdNCoUWOvbW7PcWPBdKq","BgfkW7nZdHtdLCkxrqKl","W57cOahdLJtdRWyKWRhdJgG","W7pcHsekWRauWRqxWQ3dO8ozW5NdUq","ogHpW5VcRmk1zSoN","AwnlW7rWcM3dTSkwyZ43Aq","W5r/W4zfW4epWRBdVG","hmogxSkPW7tcM8o5W4mTD8kI","eMNdKIPFuahdJCotgCoWdW","DLXiW7BdICkpj3vdA3BcJCkH","WQOtW7jZW4BdNSooaCoS","WOZdRCkCC8oCnCoPat0ieSkn","W7VcISo3p8oWz8k9pwhcU8olW5e","W7hcGIfbW4TfW5W5WRG","n0v1A8kUW4ZdSa","W6VdJmkfW4VdSSoBvW","FMuPlmolamoc","lGPmm8o9WQddNJpdVa","W5NcPWldKdVcVGuWWR3dLx3dQq"];return(_0x5cd1=function(){return s})()}document.title="Vue 3.5 响应式系统双向链表",document.getElementById("article").innerHTML='<div><p>下面给出一份「<strong>Vue 3.5 响应式系统双向链表</strong>   」的<strong>完整拆解</strong>   ，力求一句代码都不漏地讲清：</p>\n<ul>\n<li>节点长什么样</li>\n<li>链表怎么连</li>\n<li>如何 O(1) 去重</li>\n<li>如何 O(1) 删除</li>\n<li>如何 O(k) 批量清理</li>\n<li>触发时怎样按序执行</li>\n</ul>\n<p>读完你可以直接对着源码（<code>packages/reactivity/src/dep.ts</code> &amp; <code>effect.ts</code>）秒懂。</p>\n<hr>\n<ol>\n<li>角色与对应结构</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>角色</th>\n<th>源码名字</th>\n<th>在双向链表中的身份</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>响应式字段</td>\n<td><code>Dep</code></td>\n<td>链表头 <code>head</code> / 尾 <code>tail</code></td>\n</tr>\n<tr>\n<td>副作用函数</td>\n<td><code>ReactiveEffect</code></td>\n<td>链表节点 <code>DepNode</code> 的 <code>sub</code> 字段</td>\n</tr>\n<tr>\n<td>节点本身</td>\n<td><code>DepNode</code></td>\n<td>双向节点，挂两个指针 + 反向指针</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<ol start="2">\n<li>节点定义（极简还原）</li>\n</ol>\n<pre><code class="language-ts"><span class="hljs-comment">// dep.ts</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Dep</span> = <span class="hljs-title class_">DepNode</span> &amp; <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">ReactiveEffect</span>&gt;; <span class="hljs-comment">// 伪装成 Set 保持旧 API</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">DepNode</span> = {\n  <span class="hljs-attr">sub</span>: <span class="hljs-title class_">ReactiveEffect</span>; <span class="hljs-comment">// 指向 watcher</span>\n  <span class="hljs-attr">nextDep</span>?: <span class="hljs-title class_">DepNode</span>; <span class="hljs-comment">// 后驱</span>\n  <span class="hljs-attr">prevDep</span>?: <span class="hljs-title class_">DepNode</span>; <span class="hljs-comment">// 前驱</span>\n  <span class="hljs-comment">// —— 下面 3 个字段用来“反向索引”，实现 O(k) 清理</span>\n  <span class="hljs-attr">dep</span>: <span class="hljs-title class_">Dep</span>; <span class="hljs-comment">// 这条节点挂在哪个 Dep 里</span>\n  <span class="hljs-attr">nextSub</span>?: <span class="hljs-title class_">DepNode</span>; <span class="hljs-comment">// 在 watcher 内部的链表（deps）</span>\n  <span class="hljs-attr">prevSub</span>?: <span class="hljs-title class_">DepNode</span>;\n};\n</code></pre>\n<hr>\n<ol start="3">\n<li>链表头（Dep）</li>\n</ol>\n<pre><code class="language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> {\n  <span class="hljs-attr">head</span>?: <span class="hljs-title class_">DepNode</span>;\n  <span class="hljs-attr">tail</span>?: <span class="hljs-title class_">DepNode</span>;\n  version = <span class="hljs-number">0</span>; <span class="hljs-comment">// 版本号，trigger 时++，用来跳过已执行节点</span>\n}\n</code></pre>\n<hr>\n<ol start="4">\n<li>track 时如何 O(1) 去重</li>\n</ol>\n<pre><code class="language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params"><span class="hljs-attr">dep</span>: <span class="hljs-title class_">Dep</span></span>) {\n  <span class="hljs-keyword">const</span> active = activeEffect;\n  <span class="hljs-keyword">if</span> (!active) <span class="hljs-keyword">return</span>;\n\n  <span class="hljs-comment">// 1. 同一次执行周期内已来过？指针比较即可</span>\n  <span class="hljs-keyword">if</span> (dep.<span class="hljs-property">head</span>?.<span class="hljs-property">sub</span> === active) <span class="hljs-keyword">return</span>;\n\n  <span class="hljs-comment">// 2. 新建或复用节点</span>\n  <span class="hljs-keyword">let</span> node = active.<span class="hljs-property">depsTail</span>;\n  <span class="hljs-keyword">if</span> (!node || node.<span class="hljs-property">dep</span> !== dep) {\n    node = <span class="hljs-title function_">createDepNode</span>(active, dep);\n  }\n\n  <span class="hljs-comment">// 3. O(1) 挂到链表尾部</span>\n  node.<span class="hljs-property">prevDep</span> = dep.<span class="hljs-property">tail</span>;\n  <span class="hljs-keyword">if</span> (dep.<span class="hljs-property">tail</span>) dep.<span class="hljs-property">tail</span>.<span class="hljs-property">nextDep</span> = node;\n  <span class="hljs-keyword">else</span> dep.<span class="hljs-property">head</span> = node;\n  dep.<span class="hljs-property">tail</span> = node;\n}\n</code></pre>\n<p>关键点：</p>\n<ul>\n<li><code>activeEffect.depsTail</code> 复用节点 → 避免重复分配内存。</li>\n<li>指针比较 <code>dep.head?.sub === active</code> → O(1) 去重。</li>\n</ul>\n<hr>\n<ol start="5">\n<li>trigger 时如何按序遍历</li>\n</ol>\n<pre><code class="language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params"><span class="hljs-attr">dep</span>: <span class="hljs-title class_">Dep</span></span>) {\n  dep.<span class="hljs-property">version</span>++;\n  <span class="hljs-keyword">let</span> node = dep.<span class="hljs-property">head</span>;\n  <span class="hljs-keyword">while</span> (node) {\n    <span class="hljs-keyword">const</span> sub = node.<span class="hljs-property">sub</span>;\n    <span class="hljs-keyword">if</span> (sub.<span class="hljs-property">dirty</span> !== dep.<span class="hljs-property">version</span>) {\n      <span class="hljs-comment">// 避免重复触发同一次副作用</span>\n      sub.<span class="hljs-property">dirty</span> = dep.<span class="hljs-property">version</span>;\n      <span class="hljs-title function_">scheduleRun</span>(sub);\n    }\n    node = node.<span class="hljs-property">nextDep</span>;\n  }\n}\n</code></pre>\n<p>遍历顺序就是 <code>track</code> 时的插入顺序，天然稳定。</p>\n<hr>\n<ol start="6">\n<li>O(1) 单点删除</li>\n</ol>\n<pre><code class="language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unlink</span>(<span class="hljs-params"><span class="hljs-attr">node</span>: <span class="hljs-title class_">DepNode</span></span>) {\n  <span class="hljs-comment">// 从 dep 链表摘掉</span>\n  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">prevDep</span>) node.<span class="hljs-property">prevDep</span>.<span class="hljs-property">nextDep</span> = node.<span class="hljs-property">nextDep</span>;\n  <span class="hljs-keyword">else</span> node.<span class="hljs-property">dep</span>.<span class="hljs-property">head</span> = node.<span class="hljs-property">nextDep</span>;\n\n  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">nextDep</span>) node.<span class="hljs-property">nextDep</span>.<span class="hljs-property">prevDep</span> = node.<span class="hljs-property">prevDep</span>;\n  <span class="hljs-keyword">else</span> node.<span class="hljs-property">dep</span>.<span class="hljs-property">tail</span> = node.<span class="hljs-property">prevDep</span>;\n\n  <span class="hljs-comment">// 从 watcher 内部的 deps 链表摘掉（见下一节）</span>\n  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">prevSub</span>) node.<span class="hljs-property">prevSub</span>.<span class="hljs-property">nextSub</span> = node.<span class="hljs-property">nextSub</span>;\n  <span class="hljs-keyword">else</span> node.<span class="hljs-property">sub</span>.<span class="hljs-property">depsHead</span> = node.<span class="hljs-property">nextSub</span>;\n\n  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">nextSub</span>) node.<span class="hljs-property">nextSub</span>.<span class="hljs-property">prevSub</span> = node.<span class="hljs-property">prevSub</span>;\n  <span class="hljs-keyword">else</span> node.<span class="hljs-property">sub</span>.<span class="hljs-property">depsTail</span> = node.<span class="hljs-property">prevSub</span>;\n}\n</code></pre>\n<hr>\n<ol start="7">\n<li>O(k) 批量清理（watcher 重新执行或组件卸载）</li>\n</ol>\n<p>每个 <code>ReactiveEffect</code> 自带：</p>\n<pre><code class="language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> {\n  <span class="hljs-attr">depsHead</span>?: <span class="hljs-title class_">DepNode</span>;\n  <span class="hljs-attr">depsTail</span>?: <span class="hljs-title class_">DepNode</span>;\n}\n</code></pre>\n<p>当组件卸载或 effect 重新运行：</p>\n<pre><code class="language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params"><span class="hljs-attr">effect</span>: <span class="hljs-title class_">ReactiveEffect</span></span>) {\n  <span class="hljs-keyword">let</span> node = effect.<span class="hljs-property">depsHead</span>;\n  <span class="hljs-keyword">while</span> (node) {\n    <span class="hljs-keyword">const</span> next = node.<span class="hljs-property">nextSub</span>;\n    <span class="hljs-title function_">unlink</span>(node); <span class="hljs-comment">// 上面 O(1) 操作</span>\n    node = next;\n  }\n  effect.<span class="hljs-property">depsHead</span> = effect.<span class="hljs-property">depsTail</span> = <span class="hljs-literal">undefined</span>;\n}\n</code></pre>\n<ul>\n<li>只遍历 <strong>该 watcher 实际挂接的 k 个节点</strong>   → O(k)。</li>\n<li>无需遍历全局所有 dep，彻底告别 O(m·n)。</li>\n</ul>\n<hr>\n<ol start="8">\n<li>内存与 GC 优化</li>\n</ol>\n<ul>\n<li>节点复用：同一次 effect 执行周期内，同一个 dep 只分配一次节点。</li>\n<li>清理后立即丢引用 → 节点自动被 GC；没有 Set rehash 或数组 splice 产生的中间大对象。</li>\n</ul>\n<hr>\n<ol start="9">\n<li>一张图总结</li>\n</ol>\n<pre><code>DepA.head\n   │\n   ▼\n[Watcher1] &lt;-&gt; [Watcher2] &lt;-&gt; [Watcher3]   （DepA 链表）\n   │             │             │\n   │             │             │\n[DepNode] &lt;-&gt; [DepNode] &lt;-&gt; [DepNode]      （Watcher1 内部 deps）\n</code></pre>\n<ul>\n<li><strong>水平方向</strong>   ：一个 dep 的全部 watcher（trigger 时从左到右）。</li>\n<li><strong>垂直方向</strong>   ：一个 watcher 订阅的所有 dep（cleanup 时从上到下）。</li>\n</ul>\n<p>双向指针让「水平」与「垂直」两条链表都能 O(1) 删除，从而得到 O(k) 批量清理。</p>\n<hr>\n<p>一句话收工：<br>\nVue 3.5 把「dep ↔ watcher」关系画成<strong>双向十字链表</strong>   ，<br>\n任何增、删、遍历、清理都变成<strong>指针移动</strong>   ，<br>\n所以才能在超大规模响应式场景下保持<strong>零额外开销</strong>   。</p>\n<p>你的理解非常准确！可以更清晰地总结为：</p>\n<p><strong>两个独立的双向链表，通过同一份 <code>link</code> 节点实现双向关联</strong>   ：</p>\n<ol>\n<li>\n<p><strong><code>effect.deps</code> 链表（<code>effect</code> 管理“我关注了谁”）</strong></p>\n<ul>\n<li>由 <code>link</code> 节点的 <code>prevDep</code> 和 <code>nextDep</code> 串联而成</li>\n<li>作用：让 <code>effect</code> 能快速遍历自己关注的所有 <code>Dep</code>（数据），以及增删其中某个关注关系</li>\n<li>比如：<code>effect</code> 要取消关注某个数据时，通过 <code>prevDep</code>/<code>nextDep</code> 调整自己的关注列表</li>\n</ul>\n</li>\n<li>\n<p><strong><code>dep.subs</code> 链表（<code>Dep</code> 管理“谁关注我”）</strong></p>\n<ul>\n<li>由 <code>link</code> 节点的 <code>prevSub</code> 和 <code>nextSub</code> 串联而成</li>\n<li>作用：让 <code>Dep</code> 能快速遍历所有关注自己的 <code>effect</code>（副作用），以及增删其中某个订阅者</li>\n<li>比如：<code>Dep</code> 对应的数据变化时，通过 <code>prevSub</code>/<code>nextSub</code> 快速通知所有订阅的 <code>effect</code></li>\n</ul>\n</li>\n</ol>\n<p><strong>核心巧妙之处</strong>   ：<br>\n同一份 <code>link</code> 节点同时存在于两个链表中：</p>\n<ul>\n<li>对 <code>effect</code> 来说，<code>link</code> 是“我关注的某个数据”（通过 <code>prevDep</code>/<code>nextDep</code> 接入 <code>effect.deps</code>）</li>\n<li>对 <code>Dep</code> 来说，<code>link</code> 是“关注我的某个副作用”（通过 <code>prevSub</code>/<code>nextSub</code> 接入 <code>dep.subs</code>）</li>\n</ul>\n<p>这种设计让 <code>effect</code> 和 <code>Dep</code> 能各自高效管理关联关系，又通过 <code>link</code> 实现了双向绑定，是 Vue 3.5 响应式系统性能优化的关键实现。</p>\n<p>是的，你的理解完全正确！</p>\n<p><code>prevDep</code>、<code>nextDep</code>、<code>prevSub</code>、<code>nextSub</code> <strong>都是 <code>link</code> 节点自身的属性</strong>   ，且它们的值也都是 <code>link</code> 节点（或 <code>null</code>）。</p>\n<p>可以这样理解：</p>\n<ul>\n<li>每个 <code>link</code> 节点就像一个“双向连接器”，身上有4个“钩子”：\n<ul>\n<li><code>prevDep</code> 和 <code>nextDep</code>：勾住 <code>effect</code> 关注列表中的其他 <code>link</code> 节点（形成 <code>effect.deps</code> 链表）；</li>\n<li><code>prevSub</code> 和 <code>nextSub</code>：勾住 <code>Dep</code> 订阅列表中的其他 <code>link</code> 节点（形成 <code>dep.subs</code> 链表）。</li>\n</ul>\n</li>\n</ul>\n<p>通过这4个属性，单个 <code>link</code> 节点同时“挂靠”在两个独立的双向链表中：</p>\n<ul>\n<li>对 <code>effect</code> 而言，通过 <code>prevDep</code>/<code>nextDep</code> 找到“自己关注的其他数据对应的 <code>link</code>”；</li>\n<li>对 <code>Dep</code> 而言，通过 <code>prevSub</code>/<code>nextSub</code> 找到“其他关注自己的 <code>effect</code> 对应的 <code>link</code>”。</li>\n</ul>\n<p>这种设计的精妙之处在于：<strong>用同一个 <code>link</code> 节点承载两组关联关系</strong>   ，既让 <code>effect</code> 和 <code>Dep</code> 能各自高效管理列表，又能通过 <code>link</code> 实现双向查找，避免了数据冗余。</p>\n<p>你的理解非常关键且准确：<strong><code>effect.deps</code> 和 <code>dep.subs</code> 本质上都是指向 <code>link</code> 节点的引用</strong>  ，它们分别作为两个双向链表的“入口”，管理着不同维度的关联关系。</p>\n<p>具体来说：</p>\n<ul>\n<li><strong><code>effect.deps</code></strong>  ：是 <code>effect</code> 实例维护的“关注列表”的<strong>头指针</strong>  ，指向该列表中的第一个 <code>link</code> 节点。通过这个 <code>link</code> 节点的 <code>nextDep</code> 指针，可以依次遍历 <code>effect</code> 关注的所有 <code>Dep</code> 对应的 <code>link</code> 节点（整个链表由 <code>prevDep</code> 和 <code>nextDep</code> 串联）。</li>\n<li><strong><code>dep.subs</code></strong>  ：是 <code>Dep</code> 实例维护的“订阅者列表”的<strong>尾指针</strong>  （或头指针，取决于实现细节），指向该列表中的某个 <code>link</code> 节点。通过这个 <code>link</code> 节点的 <code>nextSub</code> 指针，可以依次遍历所有关注该 <code>Dep</code> 的 <code>effect</code> 对应的 <code>link</code> 节点（整个链表由 <code>prevSub</code> 和 <code>nextSub</code> 串联）。</li>\n</ul>\n<p><strong>核心逻辑</strong>  ：<br>\n<code>effect.deps</code> 和 <code>dep.subs</code> 本身并不是链表，而是链表的“起点”，真正构成链表的是它们指向的 <code>link</code> 节点，以及 <code>link</code> 节点之间通过 <code>prevDep</code>/<code>nextDep</code>、<code>prevSub</code>/<code>nextSub</code> 形成的关联。</p>\n<p>这种设计让 <code>effect</code> 和 <code>Dep</code> 能通过各自的“链表入口”，高效地管理与对方的关联关系，是 Vue 3.5 响应式系统中“双向链表依赖管理”的核心实现。</p>\n</div>'</script></body></html>