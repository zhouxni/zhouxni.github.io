<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5a3b(l,s){var o=_0x5b6e();return(_0x5a3b=function(s,n){var a=o[s-=171];void 0===_0x5a3b.ztdGvX&&(_0x5a3b.QWLMKQ=function(s,n){var a,t=[],l=0,o="";for(s=(s=>{for(var n,a,t="",l="",o=0,p=0;a=s.charAt(p++);~a&&(n=o%4?64*n+a:a,o++%4)&&(t+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,r=t.length;e<r;e++)l+="%"+("00"+t.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)l=(l+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[l],t[l]=a;for(var p=0,l=0,e=0;e<s.length;e++)a=t[p=(p+1)%256],t[p]=t[l=(l+t[p])%256],t[l]=a,o+=String.fromCharCode(s.charCodeAt(e)^t[(t[p]+t[l])%256]);return o},l=arguments,_0x5a3b.ztdGvX=!0);var s=s+o[0],t=l[s];return t?a=t:(void 0===_0x5a3b.LDgRkb&&(_0x5a3b.LDgRkb=!0),a=_0x5a3b.QWLMKQ(a,n),l[s]=a),a})(l,s)}var _0x163ba9=_0x5a3b;if((()=>{for(var s=_0x5a3b,n=_0x5b6e();;)try{if(728583==+parseInt(s(194,"ixZR"))*(-parseInt(s(172,"d(dO"))/2)+-parseInt(s(193,"se)C"))/3+-parseInt(s(191,"06Bm"))/4*(parseInt(s(174,"GU8k"))/5)+-parseInt(s(189,"fJ(z"))/6*(parseInt(s(188,"oimQ"))/7)+-parseInt(s(181,"E2]h"))/8+-parseInt(s(183,"iG7V"))/9*(-parseInt(s(190,"GU8k"))/10)+parseInt(s(187,"oimQ"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x163ba9(196,"ixZR")](_0x163ba9(197,"9zX("))!=_0x163ba9(173,"se)C"))throw window[_0x163ba9(176,"i@U0")][_0x163ba9(195,"P^uu")](_0x163ba9(179,"ixZR")),Error();function _0x5b6e(){var s=["WOSTfGtdHYXhWPVdH8opWQVdSYG","Erq0jCo3WO/cLCkUAa","lSocvKNcGHm5WPhcHCoXaSoCWPK","WO0PgaNdGc9hW7NdSSolWQ7dLcBdRG","rCoonhaLWOZdSvpcSG","EtnRrSkjW7VcKGHQy8kQW5BdGmkv","EJzKcmorWQBdReHa","a8kEFSo/W6GtqvDtW6/cVW","W55RomkRWQlcH8oYffvDW7e","ymkKkCk5W4JcQ8oGv8olAmk4","a0ZcGvxdGItcMSos","nguMc8oNmLNdGYOFW5tdMCkv","qmomoJXuWO7dOL/cGdaO","mCk3w8o2g8ovW5a","fSkCD0eyWQ7dHq","W6tcVZ3cTN/dT8k8dNS","a0VdIHBcJatcTComW5vywa","bmouWPjfi8oAW5iF","DInStmkV","W5LPpCozW7VcM8oLeKy","WRBdKLOsbCoZW6xcN8oGwr8","gLpcVSouWP7cLCoEWP8","be/dG2tdNrhcSSoqW4K","WP5pDCoeW6jtW6xcNmoaCmkI","gCknD3GFW7hcHWJcVXaSqqVcH8o2W7/cM0qjm30JiCkdWRFcMG","xKnQW4/cHmk4kCoOjmogWQK","W4RdSmkyastcJ1HiWPfWW5rRWQi"];return(_0x5b6e=function(){return s})()}document.title="原生 fetch API 的优点",document.getElementById("article").innerHTML='<div><p>原生 <code>fetch</code> API 是现代浏览器提供的用于替代传统 AJAX（基于 <code>XMLHttpRequest</code>）的接口，它在语法、功能和设计理念上有显著更新。以下是主要区别：</p>\n<h3><strong>1. 语法更简洁，基于 Promise</strong></h3>\n<ul>\n<li><strong>AJAX（XMLHttpRequest）</strong>   ：需要手动管理状态码、事件监听和回调地狱。<pre><code class="language-javascript"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();\nxhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/api/data&quot;</span>, <span class="hljs-literal">true</span>);\nxhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>));\n  }\n};\nxhr.<span class="hljs-title function_">send</span>();\n</code></pre>\n</li>\n<li><strong>fetch</strong>   ：使用 Promise 链式调用，代码更扁平。<pre><code class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/data&quot;</span>)\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.<span class="hljs-title function_">json</span>())\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error:&quot;</span>, error));\n</code></pre>\n</li>\n</ul>\n<h3><strong>2. 更现代化的 API 设计</strong></h3>\n<ul>\n<li><strong>请求配置</strong>   ：通过 <code>init</code> 对象统一配置方法、头信息、请求体等。<pre><code class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/data&quot;</span>, {\n  <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,\n  <span class="hljs-attr">headers</span>: {\n    <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>,\n  },\n  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;value&quot;</span> }),\n});\n</code></pre>\n</li>\n<li><strong>响应处理</strong>   ：<code>Response</code> 对象封装了完整的响应信息（状态码、头信息、Body）。<pre><code class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/data&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">status</span>); <span class="hljs-comment">// 200</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">headers</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>));\n  <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// 解析 JSON 数据</span>\n});\n</code></pre>\n</li>\n</ul>\n<h3><strong>3. 更明确的错误处理</strong></h3>\n<ul>\n<li><strong>fetch 的默认行为</strong>   ：\n<ul>\n<li><strong>仅当网络错误时</strong>   才会 reject（如 DNS 失败、连接超时）。</li>\n<li>HTTP 错误（如 404、500）会返回成功的 Promise，需手动检查 <code>response.ok</code>。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/nonexistent&quot;</span>)\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {\n    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {\n      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP error! status: <span class="hljs-subst">${response.status}</span>`</span>);\n    }\n    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();\n  })\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Fetch error:&quot;</span>, error));\n</code></pre>\n</li>\n</ul>\n<h3><strong>4. 支持 Stream 处理</strong></h3>\n<ul>\n<li><strong>可读流（ReadableStream）</strong>   ：支持分块处理大响应数据（如文件下载）。<pre><code class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/large-file&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();\n  <span class="hljs-comment">// 逐块处理数据</span>\n  reader.<span class="hljs-title function_">read</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">{ done, value }</span>) =&gt;</span> {\n    <span class="hljs-comment">// 处理 value 中的数据块</span>\n  });\n});\n</code></pre>\n</li>\n</ul>\n<h3><strong>5. 更强大的请求控制</strong></h3>\n<ul>\n<li>\n<p><strong>AbortController</strong>   ：支持取消未完成的请求（类似 XHR 的 <code>abort()</code>）。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();\n<span class="hljs-keyword">const</span> signal = controller.<span class="hljs-property">signal</span>;\n\n<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/data&quot;</span>, { signal })\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.<span class="hljs-title function_">json</span>())\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {\n    <span class="hljs-keyword">if</span> (err.<span class="hljs-property">name</span> === <span class="hljs-string">&quot;AbortError&quot;</span>) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Request aborted&quot;</span>);\n    }\n  });\n\n<span class="hljs-comment">// 取消请求</span>\ncontroller.<span class="hljs-title function_">abort</span>();\n</code></pre>\n</li>\n</ul>\n<h3><strong>6. 更灵活的请求体类型</strong></h3>\n<ul>\n<li><strong>支持多种数据格式</strong>   ：除了 JSON，还可以直接发送 <code>FormData</code>、<code>Blob</code>、<code>ArrayBuffer</code> 等。<pre><code class="language-javascript"><span class="hljs-comment">// 发送表单数据</span>\n<span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();\nformData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;file&quot;</span>, fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]);\n<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/upload&quot;</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-attr">body</span>: formData });\n</code></pre>\n</li>\n</ul>\n<h3><strong>7. 更严格的 CORS 策略</strong></h3>\n<ul>\n<li><strong>默认不发送 Cookie</strong>   ：需显式配置 <code>credentials</code>。<pre><code class="language-javascript"><span class="hljs-comment">// 包含凭证（如 Cookie）</span>\n<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/data&quot;</span>, { <span class="hljs-attr">credentials</span>: <span class="hljs-string">&quot;include&quot;</span> });\n</code></pre>\n</li>\n</ul>\n<h3><strong>8. 浏览器兼容性</strong></h3>\n<ul>\n<li><strong>fetch</strong>   ：现代浏览器（Chrome 42+、Firefox 39+、Safari 10.1+）支持，IE 全版本不支持（需 polyfill）。</li>\n<li><strong>XMLHttpRequest</strong>   ：所有主流浏览器（包括 IE6+）均支持。</li>\n</ul>\n<h3><strong>fetch 的局限性</strong></h3>\n<ul>\n<li><strong>缺少进度事件</strong>   ：无法直接监听上传/下载进度（需使用 <code>XMLHttpRequest.upload.onprogress</code>）。</li>\n<li><strong>不支持超时控制</strong>   ：需结合 <code>AbortController</code> 手动实现。</li>\n<li><strong>API 复杂度</strong>   ：处理复杂请求（如重试、拦截器）时需自行封装。</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>AJAX (XHR)</th>\n<th>fetch API</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>语法</strong></td>\n<td>回调地狱，代码冗长</td>\n<td>Promise/async-await</td>\n</tr>\n<tr>\n<td><strong>错误处理</strong></td>\n<td>手动检查状态码</td>\n<td>仅网络错误 reject</td>\n</tr>\n<tr>\n<td><strong>流式处理</strong></td>\n<td>不支持</td>\n<td>支持 ReadableStream</td>\n</tr>\n<tr>\n<td><strong>请求取消</strong></td>\n<td><code>xhr.abort()</code></td>\n<td>AbortController</td>\n</tr>\n<tr>\n<td><strong>默认凭证</strong></td>\n<td>自动发送 Cookie</td>\n<td>需配置 <code>credentials</code></td>\n</tr>\n<tr>\n<td><strong>浏览器兼容性</strong></td>\n<td>全支持</td>\n<td>现代浏览器（需 polyfill）</td>\n</tr>\n</tbody>\n</table>\n<p>如果需要兼容旧浏览器或复杂进度监听，可使用 XHR；否则推荐优先使用 <code>fetch</code>，并结合 <code>AbortController</code> 和错误处理封装工具库（如 <code>ky</code>、<code>axios</code>）提升开发体验。</p>\n</div>'</script></body></html>