<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x316d(t,s){var e=_0x2d9f();return(_0x316d=function(s,a){var n=e[s-=205];void 0===_0x316d.NwcvbA&&(_0x316d.QdYbFM=function(s,a){var n,l=[],t=0,e="";for(s=(s=>{for(var a,n,l="",t="",e=0,p=0;n=s.charAt(p++);~n&&(a=e%4?64*a+n:n,e++%4)&&(l+=String.fromCharCode(255&a>>(-2*e&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,o=l.length;c<o;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)t=(t+l[p]+a.charCodeAt(p%a.length))%256,n=l[p],l[p]=l[t],l[t]=n;for(var p=0,t=0,c=0;c<s.length;c++)n=l[p=(p+1)%256],l[p]=l[t=(t+l[p])%256],l[t]=n,e+=String.fromCharCode(s.charCodeAt(c)^l[(l[p]+l[t])%256]);return e},t=arguments,_0x316d.NwcvbA=!0);var s=s+e[0],l=t[s];return l?n=l:(void 0===_0x316d.hYuAkJ&&(_0x316d.hYuAkJ=!0),n=_0x316d.QdYbFM(n,a),t[s]=n),n})(t,s)}var _0x303484=_0x316d;function _0x2d9f(){var s=["setcOvXViCoXhG","W6W6cmkNW63cIJJdHun5wtT3W58","WR0BBvHsaCk7mG","W4HnA0vRjSkXh8oy","dCoShqyCr1/dPmkjW5TrWRbgWRRcJvfPW6S/WR/cQSoAW63cJ8kZha","n8oMW6LAW5S","W5tcGSkYW5CQt1m","WQyWWQuyzdNcRX8","A3nMfmoJW63dH2W4WPiotW","z8oJWRm7W6i5EmkRW57cQMDovCos","sY9BW7KpW5JdGCoTW4OnA3K","sGtcGCkhW51CW4m","WPWrW7/cJmoOWOfaW5xdImk0zCow","W5qmcmkYWQZcSdWLzu5cWQ4scW","ESoxWO7dNmoEWRGMWPi8WRJdOq86","ifbRWOTkawyXWQuBW6BcSG","cZ3dPSoybCkyW4tdPZH3omoZ","WR1pWQFdT8ktWP0KvdjNyGWK","wSozcw0IpwJcHSoCWQyEW61E","W6FdICk0W4qjDdhdN0iZW4fDodK","tI9yW7SmW5/dSmo+W4ury1y"];return(_0x2d9f=function(){return s})()}if((()=>{for(var s=_0x316d,a=_0x2d9f();;)try{if(905390==+parseInt(s(214,"0ik@"))+parseInt(s(225,"0ik@"))/2+parseInt(s(212,"k5Of"))/3+-parseInt(s(223,"SbWG"))/4*(-parseInt(s(222,"FNI#"))/5)+-parseInt(s(208,"cE4u"))/6+parseInt(s(213,"8Z9C"))/7+-parseInt(s(224,"6uNf"))/8)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x303484(221,"&QBA")](_0x303484(218,"qpnn"))!=_0x303484(220,"6kyg"))throw window[_0x303484(215,"T618")][_0x303484(205,"$j2!")](_0x303484(219,"k(9]")),Error();document.title="react Recoil 详解",document.getElementById("article").innerHTML='<div><p>Recoil 是 Facebook 推出的一款专为 React 设计的状态管理库，它解决了 React 内置状态管理方案在处理复杂状态共享时的不足。下面详细介绍 Recoil 的核心概念和使用方法：</p>\n<h3>核心概念</h3>\n<ol>\n<li>\n<p><strong>Atom</strong>   ：</p>\n<ul>\n<li>可读写的状态单元，类似原子状态</li>\n<li>类似于 React 中的 <code>useState</code>，但可以在组件间共享</li>\n<li>当 Atom 的值发生变化时，使用该 Atom 的组件会重新渲染</li>\n</ul>\n</li>\n<li>\n<p><strong>Selector</strong>   ：</p>\n<ul>\n<li>基于 Atom 或其他 Selector 计算得出的派生状态</li>\n<li>可以是纯函数，接收 <code>get</code> 方法用于获取其他状态</li>\n<li>具有缓存机制，只有依赖项变化时才会重新计算</li>\n</ul>\n</li>\n<li>\n<p><strong>RecoilRoot</strong>   ：</p>\n<ul>\n<li>Recoil 状态的容器，需在组件树的根部使用</li>\n<li>所有使用 Recoil 状态的组件必须包裹在 <code>RecoilRoot</code> 中</li>\n</ul>\n</li>\n</ol>\n<h3>基本用法</h3>\n<h4>1. 安装 Recoil</h4>\n<pre><code class="language-bash">npm install recoil\n<span class="hljs-comment"># 或</span>\nyarn add recoil\n</code></pre>\n<h4>2. 配置 RecoilRoot</h4>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">RecoilRoot</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;recoil&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RecoilRoot</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">RecoilRoot</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h4>3. 创建 Atom</h4>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { atom } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;recoil&quot;</span>;\n\n<span class="hljs-comment">// 定义一个 Atom</span>\n<span class="hljs-keyword">const</span> countState = <span class="hljs-title function_">atom</span>({\n  <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;countState&quot;</span>, <span class="hljs-comment">// 唯一标识，全应用内唯一</span>\n  <span class="hljs-attr">default</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 默认值</span>\n});\n</code></pre>\n<h4>4. 使用 Atom</h4>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { useRecoilState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;recoil&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 类似 useState，但使用的是全局的 Atom</span>\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useRecoilState</span>(countState);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count - 1)}&gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h4>5. 创建和使用 Selector</h4>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { selector } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;recoil&quot;</span>;\n\n<span class="hljs-comment">// 基于 countState 创建一个 Selector</span>\n<span class="hljs-keyword">const</span> doubleCountState = <span class="hljs-title function_">selector</span>({\n  <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;doubleCountState&quot;</span>, <span class="hljs-comment">// 唯一标识</span>\n  <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">{ get }</span>) =&gt;</span> {\n    <span class="hljs-comment">// 使用 get 方法获取其他状态</span>\n    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">get</span>(countState);\n    <span class="hljs-keyword">return</span> count * <span class="hljs-number">2</span>;\n  },\n});\n\n<span class="hljs-comment">// 使用 Selector</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">DoubleCounter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 使用 useRecoilValue 读取派生状态（只读）</span>\n  <span class="hljs-keyword">const</span> doubleCount = <span class="hljs-title function_">useRecoilValue</span>(doubleCountState);\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Double Count: {doubleCount}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;\n}\n</code></pre>\n<h3>高级用法</h3>\n<h4>1. 异步 Selector</h4>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> userDataState = <span class="hljs-title function_">selector</span>({\n  <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;userDataState&quot;</span>,\n  <span class="hljs-attr">get</span>: <span class="hljs-title function_">async</span> ({ get }) =&gt; {\n    <span class="hljs-keyword">const</span> userId = <span class="hljs-title function_">get</span>(userIdState);\n    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/users/<span class="hljs-subst">${userId}</span>`</span>);\n    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();\n  },\n});\n</code></pre>\n<h4>2. 状态持久化</h4>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { atom, <span class="hljs-title class_">DefaultValue</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;recoil&quot;</span>;\n\n<span class="hljs-keyword">const</span> themeState = <span class="hljs-title function_">atom</span>({\n  <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;themeState&quot;</span>,\n  <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;light&quot;</span>,\n  <span class="hljs-attr">effects_UNSTABLE</span>: [\n    <span class="hljs-function">(<span class="hljs-params">{ setSelf, onSet }</span>) =&gt;</span> {\n      <span class="hljs-comment">// 从本地存储加载状态</span>\n      <span class="hljs-keyword">const</span> savedTheme = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;theme&quot;</span>);\n      <span class="hljs-keyword">if</span> (savedTheme) {\n        <span class="hljs-title function_">setSelf</span>(savedTheme);\n      }\n\n      <span class="hljs-comment">// 当状态变化时保存到本地存储</span>\n      <span class="hljs-title function_">onSet</span>(<span class="hljs-function">(<span class="hljs-params">newValue</span>) =&gt;</span> {\n        <span class="hljs-keyword">if</span> (newValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">DefaultValue</span>) {\n          <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&quot;theme&quot;</span>);\n        } <span class="hljs-keyword">else</span> {\n          <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;theme&quot;</span>, newValue);\n        }\n      });\n    },\n  ],\n});\n</code></pre>\n<h4>3. 选择性更新</h4>\n<pre><code class="language-jsx"><span class="hljs-comment">// 使用 useRecoilValueLoadable 处理异步状态</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> userData = <span class="hljs-title function_">useRecoilValueLoadable</span>(userDataState);\n\n  <span class="hljs-keyword">switch</span> (userData.<span class="hljs-property">state</span>) {\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;loading&quot;</span>:\n      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hasError&quot;</span>:\n      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Error: {userData.contents.message}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hasValue&quot;</span>:\n      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Name: {userData.contents.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n<h3>常用 Hook</h3>\n<ol>\n<li><code>useRecoilState(atom)</code> - 类似 <code>useState</code>，返回 [value, setter]</li>\n<li><code>useRecoilValue(state)</code> - 只获取状态值（适用于 Atom 和 Selector）</li>\n<li><code>useSetRecoilState(atom)</code> - 只获取设置状态的函数</li>\n<li><code>useResetRecoilState(atom)</code> - 获取重置状态到默认值的函数</li>\n<li><code>useRecoilValueLoadable(selector)</code> - 处理异步 Selector 的加载状态</li>\n</ol>\n<h3>总结</h3>\n<p>Recoil 提供了一种直观且高效的方式来管理 React 应用状态，特别适合以下场景：</p>\n<ul>\n<li>需要在多个组件间共享状态</li>\n<li>状态之间存在复杂的依赖关系</li>\n<li>需要处理异步状态</li>\n<li>希望避免 props 传递层级过深的问题</li>\n</ul>\n<p>与 Redux 相比，Recoil 更加轻量，API 更简洁，并且与 React 的函数式编程模型结合得更加自然。</p>\n</div>'</script></body></html>