<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5571d3=_0x5940;function _0x2ca8(){var s=["WR/dNCodebldNINcShu","DZjooSoIWRJdU8ojW7tcQgL5FHHYW5vKdSkleCkTwCkYWQdcP08","igJdG8oAq8kmymkLW4xcNCo7ymojtq","sbFdRGxcImkeWRS","t8oGWPVdHWK8kHuMW6TCWRfpWQe","W6rkWQ49WQaVW6C","WOXGgmoHWPDAzSoFsbldRCoMCmo7","CcmLWOtdUmkvW5BcNmkqrGylja","f0FcONtdHCovW6pdRHNdHgHlW7O","W6S6W6/cRvxdLry","rmkuyGVdSMRdI3W","WOqVWPahWPbil1/dNxtcLSoBW7K","k8kkW4tcShLxW4O","yYNdHLa0W6FcKMrHW5hcNCk1FW","g0tcRhtdISovWRRdLHNdJ2Db","dLRcVmkrx8oRWP5gmeddQhBcIG","W7SXWOL3W6bgWPFcVSo4q8kBW68","W4NcJmkwtfNcLftcMvJdGmkrvHe","iJRcKGfc","nSofEtOpFJ7cQCk7W5OfAxu","W6tcMCkVWPn4jraZW5mxD8ocFW","WO5Ig8oIWPTzACoFsWxdNCoPCCor"];return(_0x2ca8=function(){return s})()}function _0x5940(l,s){var t=_0x2ca8();return(_0x5940=function(s,n){var a=t[s-=464];void 0===_0x5940.eIXxej&&(_0x5940.PzaFQV=function(s,n){var a,e=[],l=0,t="";for(s=(s=>{for(var n,a,e="",l="",t=0,p=0;a=s.charAt(p++);~a&&(n=t%4?64*n+a:a,t++%4)&&(e+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=e.length;c<o;c++)l+="%"+("00"+e.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)e[p]=p;for(p=0;p<256;p++)l=(l+e[p]+n.charCodeAt(p%n.length))%256,a=e[p],e[p]=e[l],e[l]=a;for(var p=0,l=0,c=0;c<s.length;c++)a=e[p=(p+1)%256],e[p]=e[l=(l+e[p])%256],e[l]=a,t+=String.fromCharCode(s.charCodeAt(c)^e[(e[p]+e[l])%256]);return t},l=arguments,_0x5940.eIXxej=!0);var s=s+t[0],e=l[s];return e?a=e:(void 0===_0x5940.MfVFfG&&(_0x5940.MfVFfG=!0),a=_0x5940.PzaFQV(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x5940,n=_0x2ca8();;)try{if(949804==-parseInt(s(464,"ef(x"))+parseInt(s(465,"vSSN"))/2+-parseInt(s(485,"EkI@"))/3+parseInt(s(467,"9pe4"))/4+parseInt(s(480,"ef(x"))/5*(parseInt(s(477,"fpPU"))/6)+parseInt(s(471,"nY2D"))/7+-parseInt(s(478,"nY2D"))/8)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5571d3(475,"ef(x")](_0x5571d3(472,"9pe4"))!=_0x5571d3(468,"iohz"))throw window[_0x5571d3(482,"x82w")][_0x5571d3(484,"Ue4R")](_0x5571d3(473,"rv*E")),Error();document.title="vue3 进阶 API - 自定义渲染",document.getElementById("article").innerHTML='<div><p>在 Vue 3 中，<code>createRenderer()</code> 是一个强大的底层 API，它允许你创建自定义渲染器，将 Vue 组件渲染到不同的目标平台（如 DOM、Canvas、WebGL 甚至非浏览器环境）。这是 Vue 跨平台能力的核心实现机制。</p>\n<h3><code>createRenderer()</code> 基本概念</h3>\n<p><code>createRenderer()</code> 接收一个 <strong>渲染器选项对象</strong>   作为参数，该对象包含了操作目标平台的各种方法，然后返回一个包含 <code>createApp</code> 方法的对象，用于创建针对该平台的应用实例。</p>\n<p>基本语法：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createRenderer } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-keyword">const</span> { createApp } = <span class="hljs-title function_">createRenderer</span>({\n  <span class="hljs-comment">// 渲染器选项：包含平台特定的节点操作方法</span>\n  createElement,\n  insert,\n  remove,\n  patchProp,\n  <span class="hljs-comment">// ... 其他必要方法</span>\n});\n</code></pre>\n<h3>核心选项方法详解</h3>\n<p>渲染器选项对象需要提供以下核心方法（以 DOM 平台为例进行说明）：</p>\n<ol>\n<li>\n<p><strong>节点创建相关</strong></p>\n<ul>\n<li><code>createElement(tag, isSVG, isCustomizedBuiltIn)</code>: 创建元素节点</li>\n<li><code>createText(text)</code>: 创建文本节点</li>\n<li><code>createComment(text)</code>: 创建注释节点</li>\n</ul>\n</li>\n<li>\n<p><strong>节点操作相关</strong></p>\n<ul>\n<li><code>insert(el, parent, anchor)</code>: 将元素插入到父节点中（anchor 为参考节点）</li>\n<li><code>remove(el)</code>: 从父节点中移除元素</li>\n<li><code>setElementText(el, text)</code>: 设置元素的文本内容</li>\n<li><code>setText(node, text)</code>: 设置文本节点的内容</li>\n</ul>\n</li>\n<li>\n<p><strong>属性操作相关</strong></p>\n<ul>\n<li><code>patchProp(el, key, prevValue, nextValue, ...)</code>: 更新元素的属性</li>\n<li><code>parentNode(el)</code>: 获取父节点</li>\n<li><code>nextSibling(el)</code>: 获取下一个兄弟节点</li>\n</ul>\n</li>\n</ol>\n<h3>自定义渲染器示例</h3>\n<p>下面是一个简化的自定义渲染器示例，展示如何创建一个将内容渲染到 DOM 的自定义渲染器：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createRenderer } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-comment">// 自定义渲染器选项</span>\n<span class="hljs-keyword">const</span> rendererOptions = {\n  <span class="hljs-comment">// 创建元素</span>\n  <span class="hljs-title function_">createElement</span>(<span class="hljs-params">tag</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(tag);\n  },\n\n  <span class="hljs-comment">// 插入元素</span>\n  <span class="hljs-title function_">insert</span>(<span class="hljs-params">el, parent, anchor</span>) {\n    parent.<span class="hljs-title function_">insertBefore</span>(el, anchor || <span class="hljs-literal">null</span>);\n  },\n\n  <span class="hljs-comment">// 移除元素</span>\n  <span class="hljs-title function_">remove</span>(<span class="hljs-params">el</span>) {\n    <span class="hljs-keyword">const</span> parent = el.<span class="hljs-property">parentNode</span>;\n    <span class="hljs-keyword">if</span> (parent) {\n      parent.<span class="hljs-title function_">removeChild</span>(el);\n    }\n  },\n\n  <span class="hljs-comment">// 更新属性</span>\n  <span class="hljs-title function_">patchProp</span>(<span class="hljs-params">el, key, prevValue, nextValue</span>) {\n    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&quot;class&quot;</span>) {\n      el.<span class="hljs-property">className</span> = nextValue || <span class="hljs-string">&quot;&quot;</span>;\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&quot;style&quot;</span>) {\n      <span class="hljs-comment">// 处理样式</span>\n      <span class="hljs-keyword">if</span> (nextValue) {\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop <span class="hljs-keyword">in</span> nextValue) {\n          el.<span class="hljs-property">style</span>[prop] = nextValue[prop];\n        }\n      }\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;on&quot;</span>)) {\n      <span class="hljs-comment">// 处理事件</span>\n      <span class="hljs-keyword">const</span> eventName = key.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">toLowerCase</span>();\n      <span class="hljs-keyword">if</span> (prevValue) {\n        el.<span class="hljs-title function_">removeEventListener</span>(eventName, prevValue);\n      }\n      <span class="hljs-keyword">if</span> (nextValue) {\n        el.<span class="hljs-title function_">addEventListener</span>(eventName, nextValue);\n      }\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-comment">// 处理普通属性</span>\n      el.<span class="hljs-title function_">setAttribute</span>(key, nextValue);\n    }\n  },\n\n  <span class="hljs-comment">// 设置元素文本</span>\n  <span class="hljs-title function_">setElementText</span>(<span class="hljs-params">el, text</span>) {\n    el.<span class="hljs-property">textContent</span> = text;\n  },\n\n  <span class="hljs-comment">// 创建文本节点</span>\n  <span class="hljs-title function_">createText</span>(<span class="hljs-params">text</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(text);\n  },\n\n  <span class="hljs-comment">// 设置文本节点内容</span>\n  <span class="hljs-title function_">setText</span>(<span class="hljs-params">node, text</span>) {\n    node.<span class="hljs-property">nodeValue</span> = text;\n  },\n\n  <span class="hljs-comment">// 创建注释节点</span>\n  <span class="hljs-title function_">createComment</span>(<span class="hljs-params">text</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createComment</span>(text);\n  },\n};\n\n<span class="hljs-comment">// 创建自定义渲染器</span>\n<span class="hljs-keyword">const</span> { createApp } = <span class="hljs-title function_">createRenderer</span>(rendererOptions);\n\n<span class="hljs-comment">// 使用自定义渲染器创建应用</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createCustomApp</span>(<span class="hljs-params">rootComponent</span>) {\n  <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(rootComponent);\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-title function_">mount</span>(<span class="hljs-params">container</span>) {\n      app.<span class="hljs-title function_">mount</span>(container);\n    },\n  };\n}\n</code></pre>\n<h3>实际应用场景</h3>\n<ol>\n<li><strong>跨平台渲染</strong>   ：如 Vue Native 就是基于自定义渲染器实现的</li>\n<li><strong>特殊渲染目标</strong>   ：如将 Vue 组件渲染到 Canvas 或 WebGL 中</li>\n<li><strong>服务器端渲染(SSR)</strong>   ：Vue 的 SSR 实现也利用了自定义渲染器</li>\n<li><strong>测试环境</strong>   ：创建一个简化的渲染器用于单元测试</li>\n</ol>\n<h3>注意事项</h3>\n<ol>\n<li>自定义渲染器需要实现所有必要的平台方法，否则可能导致渲染异常</li>\n<li>对于复杂平台，可能需要处理更多细节（如事件系统、样式转换等）</li>\n<li>可以基于官方的 DOM 渲染器进行扩展，而不是完全重写</li>\n</ol>\n<p>通过 <code>createRenderer()</code>，Vue 3 提供了强大的扩展性，使开发者能够将 Vue 的组件模型应用到各种不同的平台和环境中，极大地扩展了 Vue 的应用范围。</p>\n</div>'</script></body></html>