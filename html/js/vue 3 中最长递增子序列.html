<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2329(){var s=["h8o1f8orkuO0WPRcRGGXW7tdVSkMW7hcUmo2W4nzWQvdWRVdTuldRSkp","WRj9WPxcSCoXW4aND8kGW6bEabm","dG7cVYPJWRm4WPa","kmovbCocW7ZdHSk5","qWdcTr8SWPtdTCkKW49Xnvq","EmonW7pdLhZcP8oEW7ddV8oQW55bW5G","bc5GFmkzW5NcVqddJM7dKmk8DG","gCovWQ5fW7VdVGddOYxdHCo+W5i","WPRdV0ycW4dcNCo9y0zYWODe","WQHKWRiwWRXXnmkroG","W6hdKMBdMmolWQxdNCklWOpdSb1+mW","rHj2W6tcIhpcUSklz8ouemkkoa","W45XD0mmsSkk","eSkZCSo+W7nAW5ldTSozASkyvqK","W5tcVmoEW5JcRColW7C","qs7dGdiPWPxdK8ktW5ZcGXNdJCki","WOdcIfBdQ8oVW5iMW7q","W7DCvXNcJmoYW65tnJLMeG","WRvfWRRcHejgjmoAk8ofW4bT","W5uWWOuEDhlcNYK","dLejnSke","qmkeWPdcKmkuW6O0","WR3cVgzxW5e3WQS8t8o1lmoYWRu","qSozW6NdImomWOmoeLyBpSkq","F8kCd1iuWRFdGG","gSkQW5uZWQJcQqe"];return(_0x2329=function(){return s})()}var _0x1f127c=_0x2a98;function _0x2a98(e,s){var p=_0x2329();return(_0x2a98=function(s,n){var a=p[s-=481];void 0===_0x2a98.xvmjlC&&(_0x2a98.Mzhhqo=function(s,n){var a,l=[],e=0,p="";for(s=(s=>{for(var n,a,l="",e="",p=0,c=0;a=s.charAt(c++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,t=l.length;r<t;r++)e+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(e)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)e=(e+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[e],l[e]=a;for(var c=0,e=0,r=0;r<s.length;r++)a=l[c=(c+1)%256],l[c]=l[e=(e+l[c])%256],l[e]=a,p+=String.fromCharCode(s.charCodeAt(r)^l[(l[c]+l[e])%256]);return p},e=arguments,_0x2a98.xvmjlC=!0);var s=s+p[0],l=e[s];return l?a=l:(void 0===_0x2a98.mFpjyF&&(_0x2a98.mFpjyF=!0),a=_0x2a98.Mzhhqo(a,n),e[s]=a),a})(e,s)}if((()=>{for(var s=_0x2a98,n=_0x2329();;)try{if(684745==-parseInt(s(495,"R86["))+-parseInt(s(501,"&MsI"))/2*(-parseInt(s(505,"Wdju"))/3)+-parseInt(s(489,"SMFR"))/4*(parseInt(s(493,"R86["))/5)+parseInt(s(503,"JIp!"))/6+-parseInt(s(499,"p5tA"))/7+-parseInt(s(483,"2m50"))/8+parseInt(s(485,"MxXh"))/9*(parseInt(s(500,"VvoJ"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1f127c(496,"6wKs")](_0x1f127c(481,"B8sx"))!=_0x1f127c(492,"^MUn"))throw window[_0x1f127c(488,"#A36")][_0x1f127c(486,"&[xj")](_0x1f127c(498,"fug8")),Error();document.title="vue 3 中最长递增子序列",document.getElementById("article").innerHTML='<div><p>在 Vue 3 中，最长递增子序列（LIS）是一个经典的算法问题，其目标是在一个给定的数值序列中找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。最长递增子序列中的元素在原序列中不一定是连续的。</p>\n<h3>Vue 3 中最长递增子序列的实现方法</h3>\n<p>Vue 3 在处理 DOM Diff 时，使用了最长递增子序列算法来优化节点的移动操作，从而减少重排和重绘的开销。以下是 Vue 3 中最长递增子序列的实现方法：</p>\n<ol>\n<li><strong>动态规划</strong>  ：\n<ul>\n<li>动态规划是一种通过将问题分解为子问题并存储子问题的解来避免重复计算的方法。</li>\n<li>在最长递增子序列问题中，可以定义一个数组 <code>dp</code>，其中 <code>dp[i]</code> 表示以第 <code>i</code> 个元素结尾的最长递增子序列的长度。</li>\n<li>通过遍历数组，更新 <code>dp</code> 数组，最终找到 <code>dp</code> 数组中的最大值，即为最长递增子序列的长度。</li>\n</ul>\n</li>\n<li><strong>贪心算法 + 二分查找</strong>  ：\n<ul>\n<li>贪心算法是一种在每一步选择中都采取当前状态下最优选择的算法设计策略。</li>\n<li>在最长递增子序列问题中，可以使用一个数组 <code>tails</code> 来存储当前最长递增子序列的末尾元素。</li>\n<li>遍历原数组时，使用二分查找在 <code>tails</code> 数组中找到第一个大于当前元素的位置，并更新 <code>tails</code> 数组。</li>\n<li>最终，<code>tails</code> 数组的长度即为最长递增子序列的长度。</li>\n</ul>\n</li>\n<li><strong>回溯修正</strong>  ：\n<ul>\n<li>由于贪心算法可能会导致最长递增子序列的顺序不正确，因此需要使用一个辅助数组来记录每个元素的前驱节点。</li>\n<li>在遍历结束后，通过回溯修正来还原正确的最长递增子序列。</li>\n</ul>\n</li>\n</ol>\n<h3>Vue 3 中最长递增子序列的应用</h3>\n<p>在 Vue 3 的 DOM Diff 算法中，最长递增子序列被用于优化节点的移动操作。当新旧节点列表发生变化时，Vue 3 会先找到新旧节点列表中的最长递增子序列，然后只移动不在最长递增子序列中的节点，从而减少移动操作的次数和开销。</p>\n<h3>示例代码</h3>\n<p>以下是一个使用贪心算法 + 二分查找实现最长递增子序列的 JavaScript 示例代码：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lengthOfLIS</span>(<span class="hljs-params">nums</span>) {\n  <span class="hljs-keyword">if</span> (nums.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;\n  \n  <span class="hljs-keyword">const</span> tails = [nums[<span class="hljs-number">0</span>]];\n  \n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) {\n    <span class="hljs-keyword">const</span> current = nums[i];\n    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = tails.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;\n    \n    <span class="hljs-keyword">while</span> (left &lt;= right) {\n      <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);\n      <span class="hljs-keyword">if</span> (tails[mid] &lt; current) {\n        left = mid + <span class="hljs-number">1</span>;\n      } <span class="hljs-keyword">else</span> {\n        right = mid - <span class="hljs-number">1</span>;\n      }\n    }\n    \n    <span class="hljs-keyword">if</span> (left &lt; tails.<span class="hljs-property">length</span>) {\n      tails[left] = current;\n    } <span class="hljs-keyword">else</span> {\n      tails.<span class="hljs-title function_">push</span>(current);\n    }\n  }\n  \n  <span class="hljs-keyword">return</span> tails.<span class="hljs-property">length</span>;\n}\n\n<span class="hljs-comment">// 示例用法</span>\n<span class="hljs-keyword">const</span> nums = [<span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">101</span>, <span class="hljs-number">18</span>];\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">lengthOfLIS</span>(nums)); <span class="hljs-comment">// 输出: 4</span>\n</code></pre>\n<h3>总结</h3>\n<p>在 Vue 3 中，最长递增子序列算法被用于优化 DOM Diff 过程中的节点移动操作。通过实现最长递增子序列算法，可以减少移动操作的次数和开销，从而提高应用的性能和用户体验。</p>\n</div>'</script></body></html>