<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4a47c6=_0x604e;function _0x604e(l,n){var e=_0x4ad9();return(_0x604e=function(n,s){var a=e[n-=338];void 0===_0x604e.YzdrgR&&(_0x604e.jZvXYp=function(n,s){var a,t=[],l=0,e="";for(n=(n=>{for(var s,a,t="",l="",e=0,r=0;a=n.charAt(r++);~a&&(s=e%4?64*s+a:a,e++%4)&&(t+=String.fromCharCode(255&s>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=t.length;o<c;o++)l+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(n),r=0;r<256;r++)t[r]=r;for(r=0;r<256;r++)l=(l+t[r]+s.charCodeAt(r%s.length))%256,a=t[r],t[r]=t[l],t[l]=a;for(var r=0,l=0,o=0;o<n.length;o++)a=t[r=(r+1)%256],t[r]=t[l=(l+t[r])%256],t[l]=a,e+=String.fromCharCode(n.charCodeAt(o)^t[(t[r]+t[l])%256]);return e},l=arguments,_0x604e.YzdrgR=!0);var n=n+e[0],t=l[n];return t?a=t:(void 0===_0x604e.pgwYtg&&(_0x604e.pgwYtg=!0),a=_0x604e.jZvXYp(a,s),l[n]=a),a})(l,n)}function _0x4ad9(){var n=["p8oSx0DlWO0xW5pdLW","WPRdGZKSWRS/WOZdRXdcNuyt","bCkleKNdNHqjWQDhWQBcLZe","WRNcH8ogdCo2amkgmXJdPSk2","huxcK8ouj2/cGqG","k2ddP8obWPldHem4","uCoQomkxySk3WPZdOmo/W6RdUSohW7O","aCkYmKlcSmoXW6VdGCouWOhcP3TW","lMhcNmk7W4lcM3yVWOeHW4yj","W5pcI1uOpX7dQq","aGhdV1DU","vGXTW7vmW7ddOmowW4NcLIFcTCk+W7/dGeddUmoXW69xW4PsmmkZf2i","aCk5pulcSSo1W6JcLCoaWPRcPvfMhG","WPqDDrldI8knWRjD","W4jFW7tdJGtcNSkTqKS","WOtdQSonWQrtWP5OsviUW48TiG","umovrXdcK0GtWR8","WPNdNrfXAeZcVee2ySkUW5hcOq","WROIlmkkcJOTW6e","W7T6BmkCi29l","W5ujWP3cSmkhW4RcVuNdUdKhW7ftqG","d8k/WOytWOaaW5lcKCoAWQyr","WR3cMCoiEISGid0","uCotW40RW7DgWQC6WPtdQCkuWOS","WQbVW6z2yLq6umkkW5qL","BujteSozWRniDJe","hudcTmoPdfhcHXC","eXhcOmkrWQldObmPWRFdOCkB"];return(_0x4ad9=function(){return n})()}if((()=>{for(var n=_0x604e,s=_0x4ad9();;)try{if(845332==+parseInt(n(353,"B7n("))*(-parseInt(n(364,"Zzf*"))/2)+parseInt(n(355,"&CQ)"))/3+parseInt(n(348,"J6Kx"))/4*(-parseInt(n(344,"O&6)"))/5)+-parseInt(n(357,"@U1H"))/6+-parseInt(n(342,"hZbr"))/7+-parseInt(n(339,"JFkt"))/8*(parseInt(n(340,"k18z"))/9)+-parseInt(n(362,"O3Qj"))/10*(-parseInt(n(352,"c5Og"))/11))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x4a47c6(359,"lq(v")](_0x4a47c6(354,"2ray"))!=_0x4a47c6(350,"TT8L"))throw window[_0x4a47c6(356,"hZbr")][_0x4a47c6(349,"@U1H")](_0x4a47c6(351,"GuHt")),Error();document.title="事件处理函数 return false",document.getElementById("article").innerHTML='<div><p>在事件处理函数中，<code>return false</code> 的作用取决于其使用方式和上下文。理解其行为对于正确控制事件流和默认行为非常重要。</p>\n<h3><strong><code>return false</code> 的作用</strong></h3>\n<ol>\n<li><strong>在传统事件处理模型中（如内联事件处理程序）</strong>  ：\n<ul>\n<li>在某些浏览器中，<code>return false</code> 可以同时阻止默认行为和事件冒泡。</li>\n<li><strong>注意</strong>  ：这种行为并不是标准规定的，依赖于浏览器的实现，因此不建议依赖此行为。</li>\n</ul>\n</li>\n<li><strong>在现代事件处理模型中（使用 <code>addEventListener</code>）</strong>  ：\n<ul>\n<li><code>return false</code> 在事件处理函数的返回值中没有任何特殊意义。</li>\n<li>它不会阻止默认行为或事件冒泡。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>正确的控制事件行为</strong></h3>\n<p>在现代 JavaScript 开发中，推荐使用标准的方法来控制事件行为：</p>\n<ul>\n<li><strong>阻止默认行为</strong>  ：使用 <code>event.preventDefault()</code>。</li>\n<li><strong>阻止事件冒泡</strong>  ：使用 <code>event.stopPropagation()</code>。</li>\n<li><strong>阻止事件继续传播并阻止其他相同事件的处理程序被调用</strong>  ：使用 <code>event.stopImmediatePropagation()</code>。</li>\n</ul>\n<h3><strong>示例</strong></h3>\n<h4><strong>传统事件处理模型（不推荐）</strong></h4>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://example.com&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;return handleClick()&quot;</span>&gt;</span>Go to Example<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Link clicked&#x27;</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 阻止默认行为（跳转）和事件冒泡（在某些浏览器中）</span>\n  }\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<ul>\n<li><strong>问题</strong>  ：这种方式将 HTML 和 JavaScript 耦合在一起，不利于维护。</li>\n<li><strong>行为不一致</strong>  ：不同浏览器对 <code>return false</code> 的处理可能不同。</li>\n</ul>\n<h4><strong>现代事件处理模型（推荐）</strong></h4>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://example.com&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myLink&quot;</span>&gt;</span>Go to Example<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myLink&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {\n    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Link clicked&#x27;</span>);\n    event.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">// 阻止默认行为（跳转）</span>\n    <span class="hljs-comment">// event.stopPropagation(); // 如果需要，阻止事件冒泡</span>\n  });\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<ul>\n<li><strong>分离关注点</strong>  ：HTML 和 JavaScript 分离，代码更清晰。</li>\n<li><strong>明确控制</strong>  ：使用标准方法明确控制事件行为。</li>\n</ul>\n<h3><strong>为什么 <code>return false</code> 不推荐用于现代开发？</strong></h3>\n<ul>\n<li><strong>可读性和可维护性</strong>  ：<code>return false</code> 的含义不明确，可能导致代码难以理解。</li>\n<li><strong>浏览器兼容性</strong>  ：不同浏览器对 <code>return false</code> 的处理可能不同，导致不一致的行为。</li>\n<li><strong>标准方法</strong>  ：使用 <code>event.preventDefault()</code> 和 <code>event.stopPropagation()</code> 是标准方法，行为一致且明确。</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong><code>return false</code> 在现代事件处理中无特殊作用</strong>  ：在 <code>addEventListener</code> 的回调中，<code>return false</code> 不会阻止默认行为或事件冒泡。</li>\n<li><strong>使用标准方法</strong>  ：使用 <code>event.preventDefault()</code> 阻止默认行为，使用 <code>event.stopPropagation()</code> 阻止事件冒泡。</li>\n<li><strong>分离关注点</strong>  ：避免使用内联事件处理程序，将 HTML 和 JavaScript 分离，提高代码的可读性和可维护性。</li>\n</ul>\n<p>通过遵循这些最佳实践，你可以确保事件处理行为一致且可预测，提高代码的质量和可靠性。</p>\n</div>'</script></body></html>