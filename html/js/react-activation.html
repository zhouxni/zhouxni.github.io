<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x6b27be=_0x525f;function _0x525f(e,s){var t=_0x568a();return(_0x525f=function(s,a){var n=t[s-=253];void 0===_0x525f.cOUPGl&&(_0x525f.UarUYy=function(s,a){var n,l=[],e=0,t="";for(s=(s=>{for(var a,n,l="",e="",t=0,c=0;n=s.charAt(c++);~n&&(a=t%4?64*a+n:n,t++%4)&&(l+=String.fromCharCode(255&a>>(-2*t&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var p=0,o=l.length;p<o;p++)e+="%"+("00"+l.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)e=(e+l[c]+a.charCodeAt(c%a.length))%256,n=l[c],l[c]=l[e],l[e]=n;for(var c=0,e=0,p=0;p<s.length;p++)n=l[c=(c+1)%256],l[c]=l[e=(e+l[c])%256],l[e]=n,t+=String.fromCharCode(s.charCodeAt(p)^l[(l[c]+l[e])%256]);return t},e=arguments,_0x525f.cOUPGl=!0);var s=s+t[0],l=e[s];return l?n=l:(void 0===_0x525f.tsSFcK&&(_0x525f.tsSFcK=!0),n=_0x525f.UarUYy(n,a),e[s]=n),n})(e,s)}function _0x568a(){var s=["w8k0peOQWOxcOHL8rqBcJh4","WPrWW63cGhFcRgdcPmo7","W69YW7tdQ8ouW6RdMdX1wCkbtLC","cs/dUZbYW7ZcPG","W6eOW63dPCk9shFcOmonW6BcOZXY","d8kkW4FcR0iGW4hdPqyU","WQlcIdZcHSoMrSkjW4C5WRa","eSoBWP/cQSkTW6KeWOq","WQlcOCkdWOFcLmkdk8kaW7zudG","W7ZdPr/cVHTBWO8rW5pdTSkfWRpcSq","tX/dOa1a","CMxdPIPoWRnMW4OVwmoSW6ZcJW","WQb3W5hcQ8oDaSo0WPjyW4eIxmk9WOJcQSoVW7GZW77dL10iWRqMWOXm","W5JdQCkiWRDiyXS","sSkUomk9WQxcGSk0WOFcU3NcGmkDWQu","W7/dRrRdMvOlW7yWW7C","emk8yCoQW4NdRNaG","W6mGW4lcGwdcSwlcLq","rmk3cxq8W5hcOYBcPmkxW6Gq","r8k2ew7dVsdcPq","W6H2W7NdQCorW6BcGtLFwCkPra","c8kkW4BdI2akW4ddQdy","B8ohWP9GC2NcJCk7feKTnCo/","WRPMW5xcT8opw8k+","W5ZdVSk1W78qWQ/dUCkUESoCW60","WQhcRCkiWRuCCLnfWRDPWP97iG"];return(_0x568a=function(){return s})()}if((()=>{for(var s=_0x525f,a=_0x568a();;)try{if(402651==+parseInt(s(254,"^4jf"))*(-parseInt(s(269,"Cf15"))/2)+parseInt(s(270,"$Cpt"))/3+-parseInt(s(266,"E60("))/4+parseInt(s(272,"ufcG"))/5+-parseInt(s(261,"]V*z"))/6*(parseInt(s(273,"A8(a"))/7)+-parseInt(s(276,"k0i7"))/8+-parseInt(s(264,"x5FN"))/9*(-parseInt(s(259,"1k#("))/10))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x6b27be(267,"8%Nl")](_0x6b27be(275,"WY4E"))!=_0x6b27be(258,"MSeR"))throw window[_0x6b27be(255,"cvST")][_0x6b27be(271,"wg8l")](_0x6b27be(260,"wg8l")),Error();document.title="react-activation",document.getElementById("article").innerHTML='<div><p><code>react-activation</code> 是一个用于 React 应用的组件缓存库，旨在提供类似 Vue 中 <code>&lt;keep-alive&gt;</code> 的功能。以下是 <code>react-activation</code> 的配置详解：</p>\n<h3>一、安装与基本配置</h3>\n<ol>\n<li>\n<p><strong>安装依赖</strong>  ：</p>\n<pre><code class="language-sh">npm install react-activation --save\n</code></pre>\n<p>或</p>\n<pre><code class="language-sh">yarn add react-activation\n</code></pre>\n</li>\n<li>\n<p><strong>基本使用</strong>  ：</p>\n<ul>\n<li>在项目的入口文件中，使用 <code>&lt;AliveScope&gt;</code> 包裹整个应用，以确保组件状态的持久化。</li>\n<li>使用 <code>&lt;KeepAlive&gt;</code> 包裹需要缓存的组件。</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AliveScope</span>, <span class="hljs-title class_">KeepAlive</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-activation&#x27;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span>;\n\n<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AliveScope</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">AliveScope</span>&gt;</span></span>,\n  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)\n);\n</code></pre>\n<p>在 <code>App.js</code> 或其他组件文件中：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">KeepAlive</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-activation&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;Add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [show, setShow] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>);\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setShow(!show)}&gt;Toggle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      {show &amp;&amp; (\n        <span class="hljs-tag">&lt;<span class="hljs-name">KeepAlive</span>&gt;</span>\n          <span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">KeepAlive</span>&gt;</span>\n      )}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;\n</code></pre>\n</li>\n</ol>\n<h3>二、高级配置</h3>\n<ol>\n<li><strong>Babel 插件</strong>  ：\n<ul>\n<li>为了提高缓存的稳定性和性能，建议在 Babel 配置文件中添加 <code>react-activation/babel</code> 插件。</li>\n<li>该插件会在编译阶段为每个 JSX 元素添加 <code>_nk</code> 属性，帮助 <code>react-activation</code> 在运行时生成唯一的缓存标识。</li>\n</ul>\n<pre><code class="language-json"><span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;react-activation/babel&quot;</span><span class="hljs-punctuation">]</span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n</li>\n<li><strong>缓存控制</strong>  ：\n<ul>\n<li><code>&lt;KeepAlive&gt;</code> 组件支持通过 <code>when</code> 属性来控制缓存行为。</li>\n<li><code>when</code> 可以是一个布尔值或一个数组。当为布尔值时，<code>true</code> 表示卸载时缓存，<code>false</code> 表示卸载时不缓存。</li>\n<li>当为数组时，第一个元素表示是否需要在卸载时缓存，第二个元素表示是否卸载 <code>&lt;KeepAlive&gt;</code> 的所有缓存内容，包括嵌套的 <code>&lt;KeepAlive&gt;</code>。</li>\n</ul>\n<pre><code class="language-jsx">&lt;<span class="hljs-title class_">KeepAlive</span> when={[<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>]}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>\n&lt;/<span class="hljs-title class_">KeepAlive</span>&gt;\n</code></pre>\n</li>\n<li><strong>多份缓存</strong>  ：\n<ul>\n<li>在同一个父节点下，相同位置的 <code>&lt;KeepAlive&gt;</code> 默认会使用同一份缓存。</li>\n<li>如果需要按特定条件分成多份缓存，可以使用 <code>&lt;KeepAlive&gt;</code> 的 <code>id</code> 属性。</li>\n</ul>\n<pre><code class="language-jsx">&lt;<span class="hljs-title class_">Route</span> path=<span class="hljs-string">&quot;/item/:id&quot;</span> render={<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> (\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">KeepAlive</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{props.match.params.id}</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">Item</span> {<span class="hljs-attr">...props</span>} /&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">KeepAlive</span>&gt;</span></span>\n)} /&gt;\n</code></pre>\n</li>\n<li><strong>滚动位置保存</strong>  ：\n<ul>\n<li><code>&lt;KeepAlive&gt;</code> 组件会自动检测并保存子节点的滚动位置。</li>\n<li>如果不需要保存滚动位置，可以将 <code>saveScrollPosition</code> 属性设置为 <code>false</code>。</li>\n<li>如果组件共享了屏幕滚动容器，如 <code>document.body</code>，可以将 <code>saveScrollPosition</code> 属性设置为 <code>&quot;screen&quot;</code>。</li>\n</ul>\n<pre><code class="language-jsx">&lt;<span class="hljs-title class_">KeepAlive</span> saveScrollPosition={<span class="hljs-literal">false</span>}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>\n&lt;/<span class="hljs-title class_">KeepAlive</span>&gt;\n</code></pre>\n</li>\n<li><strong>生命周期钩子</strong>  ：\n<ul>\n<li><code>react-activation</code> 提供了 <code>useActivate</code> 和 <code>useUnactivate</code> 钩子，用于在组件激活和卸载时执行特定的逻辑。</li>\n<li>对于类组件，可以使用 <code>withActivation</code> 装饰器，并通过 <code>componentDidActivate</code> 和 <code>componentWillUnactivate</code> 方法来监听组件的激活和去活状态。</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n<span class="hljs-keyword">import</span> { useActivate, useUnactivate } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-activation&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-title function_">useActivate</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Component has been activated.&#x27;</span>);\n  });\n\n  <span class="hljs-title function_">useUnactivate</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Component will be unactivated.&#x27;</span>);\n  });\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>My Component<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ol>\n<h3>三、注意事项</h3>\n<ol>\n<li><strong><code>&lt;AliveScope&gt;</code> 的位置</strong>  ：\n<ul>\n<li><code>&lt;AliveScope&gt;</code> 必须放置在应用的入口处，以确保组件状态的持久化。</li>\n<li>在与 <code>react-router</code> 或 <code>react-redux</code> 配合使用时，需要将 <code>&lt;AliveScope&gt;</code> 放置在 <code>&lt;Router&gt;</code> 或 <code>&lt;Provider&gt;</code> 内部。</li>\n</ul>\n</li>\n<li><strong>缓存标识</strong>  ：\n<ul>\n<li>在多个组件需要缓存时，建议使用 <code>id</code> 或 <code>cacheKey</code> 属性来区分不同的缓存。</li>\n<li>如果不使用 Babel 插件，建议为每个 <code>&lt;KeepAlive&gt;</code> 声明一个全局唯一且不变的 <code>cacheKey</code> 属性。</li>\n</ul>\n</li>\n<li><strong>React 版本兼容性</strong>  ：\n<ul>\n<li><code>react-activation</code> 兼容 React v16、v17 和 v18，以及 Preact v10+。</li>\n<li>在使用 React 18 及以上版本时，注意避免与 <code>&lt;React.StrictMode&gt;</code> 冲突。</li>\n</ul>\n</li>\n</ol>\n<h3>四、总结</h3>\n<p><code>react-activation</code> 是一个功能强大且灵活的组件缓存库，适用于需要在 React 应用中实现状态保持和组件缓存的场景。通过合理配置 <code>&lt;AliveScope&gt;</code> 和 <code>&lt;KeepAlive&gt;</code> 组件，以及使用生命周期钩子和缓存控制选项，可以显著提升应用的性能和用户体验。</p>\n</div>'</script></body></html>