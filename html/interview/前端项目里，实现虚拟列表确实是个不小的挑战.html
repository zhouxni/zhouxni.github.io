<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x6daf(){var s=["BYdcRapcVvuuFmoefCoUWOW","W7Sgs214WQtcJvHYhx/dUmkDqa","yM3cK8kAWPFdVCkugSoteKaf","W4tdQHeup8kdj0C","W7SgmaumW7JdTbK","oSoyWQJdNSkhWQi9","r8kAWOvhcCojbrLR","WOiRr8oiWOZdLse","WOZdPX03E8ktjmoo","W4VcNN87WRBdJLDY","W4q0W7WRW4FdISkjFwBcSMhdUq","W4e1W7CPW4BcN8keC0/cS10","pSoBW4/cO0hdIMBdIa","srNdOJ1OF8koWRXUmKVcUa","W7zlW406WOdcS1FcGSkVCmkz","WP3cRc08cmoxqXRcKNldTeOBsIFdQK7cRmobah3dQ8oRW7BdRCkQ","WQNcRCk0W5RcIJqlWO4","WQ06W5FdGrRcKmoBW6xcJa","WOv7f8kqW5tcHhqvWOBdGSk8WPxdTcq","AtBcK1CRWOe6gadcISk+fG","eCkiDdFdRgyAeMC","WRi9ggZcGGBdKq","WOFdMh0iWRpdSwqGWONdHcFcKmky","B8ovWPRdGmkdWQ8z","WPnAW4bPaW","WOzvWRxdOwlcOvJcQq","W5lcG2OUo8oNWOhdTmkQW6iLwW","W70EW7PRW5POoGNdOvRdOxC","wsneWQhdQ8kCqa","fmozW6CBs8oWgt3dKSoFhSoV","W4hdQ2P6sSovvwpcOfhdI24k","WRy3pvpcMG3dVW"];return(_0x6daf=function(){return s})()}var _0x328b10=_0x1e63;function _0x1e63(p,s){var t=_0x6daf();return(_0x1e63=function(s,a){var n=t[s-=235];void 0===_0x1e63.lEbPBe&&(_0x1e63.prrMqY=function(s,a){var n,l=[],p=0,t="";for(s=(s=>{for(var a,n,l="",p="",t=0,e=0;n=s.charAt(e++);~n&&(a=t%4?64*a+n:n,t++%4)&&(l+=String.fromCharCode(255&a>>(-2*t&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var r=0,c=l.length;r<c;r++)p+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+a.charCodeAt(e%a.length))%256,n=l[e],l[e]=l[p],l[p]=n;for(var e=0,p=0,r=0;r<s.length;r++)n=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=n,t+=String.fromCharCode(s.charCodeAt(r)^l[(l[e]+l[p])%256]);return t},p=arguments,_0x1e63.lEbPBe=!0);var s=s+t[0],l=p[s];return l?n=l:(void 0===_0x1e63.QaEoCs&&(_0x1e63.QaEoCs=!0),n=_0x1e63.prrMqY(n,a),p[s]=n),n})(p,s)}if((()=>{for(var s=_0x1e63,a=_0x6daf();;)try{if(552666==+parseInt(s(245,"QmgX"))*(parseInt(s(263,"hQIT"))/2)+-parseInt(s(265,"[qVM"))/3*(parseInt(s(260,"qmVU"))/4)+-parseInt(s(237,"q(WY"))/5*(parseInt(s(246,"SuBe"))/6)+-parseInt(s(236,"q(WY"))/7*(-parseInt(s(242,"w#RL"))/8)+-parseInt(s(266,"b%$h"))/9*(parseInt(s(258,"Q3]W"))/10)+parseInt(s(256,"UmzG"))/11*(-parseInt(s(261,"UmzG"))/12)+parseInt(s(244,"[qVM"))/13)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x328b10(249,"hQIT")](_0x328b10(243,"N(G2"))!=_0x328b10(250,"EdTd"))throw window[_0x328b10(235,"$u#Z")][_0x328b10(254,"0#hK")](_0x328b10(241,"UmzG")),Error();document.title="前端项目里，实现虚拟列表确实是个不小的挑战",document.getElementById("article").innerHTML='<div><p>在前端项目里，实现虚拟列表确实是个不小的挑战，特别是当需要展示大量数据的时候。下面为你详细阐述实现虚拟列表时会碰到的难点以及相应的解决思路：</p>\n<h3>核心难点分析</h3>\n<ol>\n<li><strong>可见区域精准计算</strong><br>\n要根据容器的滚动位置，精确算出当前可视区域内的列表项。计算过程需要综合考虑列表项的高度、间距以及滚动偏移量。</li>\n<li><strong>动态渲染与重渲染</strong><br>\n当用户滚动页面时，要及时添加进入可视区域的列表项，同时移除离开可视区域的列表项，以此来保证DOM元素数量处于可控状态。</li>\n<li><strong>不同高度列表项的处理</strong><br>\n如果列表项的高度不固定，就需要提前缓存每个列表项的高度信息，进而准确计算滚动位置和可视区域。</li>\n<li><strong>滚动位置与用户体验</strong><br>\n在动态渲染列表项的过程中，要保证滚动位置的平滑过渡，避免出现跳动现象。</li>\n<li><strong>边界情况处理</strong><br>\n像快速滚动、滚动到顶部或底部等边界情况，需要进行特殊处理，防止出现空白或渲染延迟的问题。</li>\n</ol>\n<h3>解决方案示例</h3>\n<p>下面是一个虚拟列表实现的关键代码片段，展示了基本的实现思路：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualList</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span> = options.<span class="hljs-property">container</span>; <span class="hljs-comment">// 容器元素</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemHeight</span> = options.<span class="hljs-property">itemHeight</span>; <span class="hljs-comment">// 列表项高度</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">totalCount</span> = options.<span class="hljs-property">totalCount</span>; <span class="hljs-comment">// 总数据量</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataSource</span> = options.<span class="hljs-property">dataSource</span>; <span class="hljs-comment">// 数据源</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderItem</span> = options.<span class="hljs-property">renderItem</span>; <span class="hljs-comment">// 渲染列表项的函数</span>\n    \n    <span class="hljs-comment">// 计算总高度</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">totalHeight</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">totalCount</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemHeight</span>;\n    \n    <span class="hljs-comment">// 初始化可见区域</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">visibleCount</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-property">clientHeight</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemHeight</span>);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">startIndex</span> = <span class="hljs-number">0</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">endIndex</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">visibleCount</span>;\n    \n    <span class="hljs-comment">// 绑定事件</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleScroll</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>));\n    \n    <span class="hljs-comment">// 初始渲染</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">render</span>();\n  }\n  \n  <span class="hljs-title function_">handleScroll</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-comment">// 计算当前滚动位置对应的起始索引</span>\n    <span class="hljs-keyword">const</span> scrollTop = <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-property">scrollTop</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">startIndex</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(scrollTop / <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemHeight</span>);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">endIndex</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">startIndex</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">visibleCount</span>;\n    \n    <span class="hljs-comment">// 限制索引范围</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">startIndex</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">startIndex</span>);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">endIndex</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">totalCount</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">endIndex</span>);\n    \n    <span class="hljs-comment">// 重新渲染可见区域</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">render</span>();\n  }\n  \n  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-comment">// 清空容器</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&#x27;</span>;\n    \n    <span class="hljs-comment">// 创建占位元素，保证滚动条正常工作</span>\n    <span class="hljs-keyword">const</span> placeholder = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);\n    placeholder.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.totalHeight}</span>px`</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-title function_">appendChild</span>(placeholder);\n    \n    <span class="hljs-comment">// 创建可见区域的列表项</span>\n    <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">startIndex</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">endIndex</span>; i++) {\n      <span class="hljs-keyword">const</span> item = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">renderItem</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dataSource</span>[i], i);\n      <span class="hljs-comment">// 设置正确的位置</span>\n      item.<span class="hljs-property">style</span>.<span class="hljs-property">position</span> = <span class="hljs-string">&#x27;absolute&#x27;</span>;\n      item.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = <span class="hljs-string">`<span class="hljs-subst">${i * <span class="hljs-variable language_">this</span>.itemHeight}</span>px`</span>;\n      fragment.<span class="hljs-title function_">appendChild</span>(item);\n    }\n    \n    <span class="hljs-comment">// 将可见区域的列表项添加到容器中</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-title function_">appendChild</span>(fragment);\n  }\n}\n</code></pre>\n<h3>进阶挑战与优化</h3>\n<ol>\n<li><strong>动态高度列表项</strong><br>\n对于高度不固定的列表项，可以采用以下方法：</li>\n</ol>\n<ul>\n<li>预估高度：先给列表项设置一个预估高度，等实际渲染后再更新准确高度。</li>\n<li>缓存高度：把每个列表项的实际高度缓存起来，用于后续计算。</li>\n</ul>\n<ol start="2">\n<li><strong>性能优化</strong></li>\n</ol>\n<ul>\n<li>防抖与节流：对滚动事件进行防抖或节流处理，减少渲染次数。</li>\n<li>预加载：在可视区域边缘提前加载一些列表项，提升用户体验。</li>\n</ul>\n<ol start="3">\n<li><strong>复杂场景适配</strong></li>\n</ol>\n<ul>\n<li>嵌套滚动：处理好嵌套滚动容器之间的关系。</li>\n<li>响应式布局：在不同屏幕尺寸下，重新计算可见区域和列表项高度。</li>\n</ul>\n<p>实现虚拟列表需要综合考虑性能、用户体验和各种边界情况。在实际项目中，你可能需要根据具体需求对上述方案进行调整和优化。</p>\n</div>'</script></body></html>