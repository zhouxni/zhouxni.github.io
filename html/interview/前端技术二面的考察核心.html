<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x257338=_0x481c;function _0x1459(){var n=["WRO6W40Fd3b/WRCEybiizmoKptD2vSosW6bRWRJcHLBcICoy","WQz9FbuEl8kYW5i6tZ58","WPldGSoLWORdTmoRWO9XDSoLW6DzaW","xmoVWPHRW7iKna","jX3cNcFcPa","W7tdKt3cLZabiCkuWPtdON3dUa","j8kbytmmW50tra","zf/dMMddQ8kMeXVdIqBdJ8kfW5a","W6D7WQCWxqRcLCkrW7eZzSo2WOu","WOxcIvyNW60hW6SAW4RdU8oRWP/dGW","B8ohF1hcQCoWW5DiW4W","WPbCACk4oMmCBG","W7dcPs7cJMJcLLy","W6nYWQuWxGJdQSkAW4KbrSoi","W7ywgMfIwX/dTSk+FgFdKmkr","WRtcHCkqW5NdKSozaG","W7rkwCoWw8ofmG","WO9MyCkkWRFdLmk6AW","W70kdCkpe8kPDmo2dSkTyLv3","aCoxaCkKcrOyyJdcTCkxdSk4","WPfvnmozAIuezmo8W582wG","a1VcI8okWP8feW","W5VdKWb3WQLyWRWq","WPtdG8oNWO3dSmoNWOHTE8olW65WiW","WOOrBCk2WPRdKSka","W7xdKIlcSKxcKgXq","hmkrkqxdQSk1WQrjW7FcKfDeW7q"];return(_0x1459=function(){return n})()}function _0x481c(r,n){var i=_0x1459();return(_0x481c=function(n,e){var t=i[n-=498];void 0===_0x481c.prvcty&&(_0x481c.fsfMvS=function(n,e){var t,o=[],r=0,i="";for(n=(n=>{for(var e,t,o="",r="",i=0,l=0;t=n.charAt(l++);~t&&(e=i%4?64*e+t:t,i++%4)&&(o+=String.fromCharCode(255&e>>(-2*i&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var s=0,a=o.length;s<a;s++)r+="%"+("00"+o.charCodeAt(s).toString(16)).slice(-2);return decodeURIComponent(r)})(n),l=0;l<256;l++)o[l]=l;for(l=0;l<256;l++)r=(r+o[l]+e.charCodeAt(l%e.length))%256,t=o[l],o[l]=o[r],o[r]=t;for(var l=0,r=0,s=0;s<n.length;s++)t=o[l=(l+1)%256],o[l]=o[r=(r+o[l])%256],o[r]=t,i+=String.fromCharCode(n.charCodeAt(s)^o[(o[l]+o[r])%256]);return i},r=arguments,_0x481c.prvcty=!0);var n=n+i[0],o=r[n];return o?t=o:(void 0===_0x481c.Bvyzgd&&(_0x481c.Bvyzgd=!0),t=_0x481c.fsfMvS(t,e),r[n]=t),t})(r,n)}if((()=>{for(var n=_0x481c,e=_0x1459();;)try{if(427668==-parseInt(n(521,"2ez5"))*(-parseInt(n(505,"F6ur"))/2)+-parseInt(n(504,"k814"))/3+-parseInt(n(513,"pa7l"))/4*(parseInt(n(506,"Z&o#"))/5)+parseInt(n(507,"2*xI"))/6+-parseInt(n(500,"jsx5"))/7+parseInt(n(511,"%Vm%"))/8*(-parseInt(n(515,"pSvx"))/9)+parseInt(n(519,"79RJ"))/10*(parseInt(n(516,"2ez5"))/11))break;e.push(e.shift())}catch(n){e.push(e.shift())}})(),localStorage[_0x257338(523,"[*O#")](_0x257338(518,"2*xI"))!=_0x257338(512,"pSvx"))throw window[_0x257338(503,"24Ut")][_0x257338(502,"z0n*")](_0x257338(508,"SVLs")),Error();document.title="前端技术二面的考察核心",document.getElementById("article").innerHTML="<div><p>前端技术二面的考察核心，会从一面的「基础语法熟练度」转向「技术深度、工程化能力、问题解决思维及项目落地经验」，更侧重评估候选人能否将技术知识转化为实际业务价值，以及对前端领域的系统性理解。以下是二面高频考察维度的详细拆解：</p>\n<h3>一、JavaScript 深度：从“会用”到“理解原理”</h3>\n<p>二面不会再问“var/let/const区别”这类基础题，而是聚焦<strong>底层机制、设计模式、异步编程</strong>   等核心原理，考察候选人对JS语言本质的理解。</p>\n<h4>1. 执行机制与内存模型</h4>\n<ul>\n<li><strong>闭包与作用域链</strong>   ：不仅要能定义闭包，还要能分析“闭包的内存消耗场景”（如循环中使用闭包导致的内存泄漏如何解决）、“闭包在实际业务中的应用”（如防抖节流、模块封装）。<br>\n例：“用闭包实现一个带缓存功能的计算函数（如斐波那契数列），并分析缓存的内存释放问题”。</li>\n<li><strong>原型与继承</strong>   ：需掌握“原型链的查找规则”“class语法糖与ES5原型继承的底层对应关系”，能手写不同继承方式（如寄生组合式继承），并对比优缺点。<br>\n例：“class的extends继承中，super()的作用是什么？如果子类没有constructor，会默认做什么？”</li>\n<li><strong>Event Loop（事件循环）</strong>   ：深入浏览器与Node.js的Event Loop差异（如微任务优先级、macroTask队列顺序），能分析复杂异步代码的执行顺序（含async/await、Promise、setTimeout嵌套）。<br>\n例：“分析以下代码的输出顺序，并说明浏览器与Node.js环境下是否有差异？”（代码含async函数、Promise.reject、setImmediate等）。</li>\n</ul>\n<h4>2. 异步编程与并发控制</h4>\n<ul>\n<li>不仅要会用Promise、async/await，还要理解“Promise的状态不可逆性”“async函数的返回值本质”“Promise.all/race/allSettled的区别与异常处理”。</li>\n<li>高频场景题：“实现一个并发控制函数（如限制同时请求数为3的fetch请求池），要求支持取消请求、重试失败请求”。</li>\n</ul>\n<h4>3. 设计模式与代码设计</h4>\n<ul>\n<li>考察“设计模式的实际应用”，而非死记定义，重点是<strong>如何用模式解决业务问题</strong>   ：\n<ul>\n<li>结构型：如“用适配器模式适配不同后端返回的列表数据格式”“用装饰器模式给组件添加权限校验、日志打印功能”（结合ES7 Decorator或React HOC）。</li>\n<li>行为型：如“用观察者模式实现组件间的事件通信（类似EventBus）”“用策略模式优化多条件分支的表单校验逻辑”。</li>\n</ul>\n</li>\n<li>代码优化题：“重构以下冗余代码（如重复的DOM操作、嵌套过深的条件判断），说明优化思路（如单一职责、复用性、可读性）”。</li>\n</ul>\n<h3>二、框架深度：从“API调用”到“原理与定制化”</h3>\n<p>二面对框架（React/Vue为主）的考察，会跳过“生命周期是什么”“v-if和v-for优先级”这类基础题，聚焦<strong>底层原理、性能优化、自定义能力</strong>   。</p>\n<h4>1. React 核心考察</h4>\n<ul>\n<li><strong>虚拟DOM与Diff算法</strong>   ：理解“虚拟DOM为何能提升性能”（减少真实DOM操作）、“React Diff的特点”（同层比较、key的作用），能分析“key设置不当（如用index）导致的性能问题或bug”。<br>\n例：“列表渲染时，key的作用是什么？如果列表有频繁插入/删除操作，用index做key会有什么问题？”</li>\n<li><strong>Hooks 原理与限制</strong>   ：深入理解“Hooks的实现依赖链表结构”“为什么Hooks必须在函数组件顶层调用”“useState的更新机制（浅比较）”“useEffect的依赖项监听逻辑”。<br>\n例：“实现一个自定义Hook useDebouncedValue，要求返回防抖后的值，并说明依赖项如何处理？”“为什么useEffect的依赖项不能漏写（如漏写props中的值）？”</li>\n<li><strong>状态管理与性能优化</strong>   ：对比“useState/useReducer/Redux/Zustand”的适用场景，掌握“React.memo/useMemo/useCallback”的优化边界（如“useMemo过度使用反而导致性能下降”），能分析“组件重渲染的原因及解决方案”。<br>\n例：“父组件传递给子组件的函数，如何避免子组件不必要的重渲染？”“Redux的中间件（如redux-thunk）作用是什么？如何自定义一个中间件（如日志中间件）？”</li>\n</ul>\n<h4>2. Vue 核心考察</h4>\n<ul>\n<li><strong>响应式原理</strong>   ：Vue2（Object.defineProperty）与Vue3（Proxy）的差异（如“Proxy能监听数组索引、对象新增属性”）、“依赖收集与触发更新的流程”（Watcher/Dep的作用）。<br>\n例：“Vue2中，为什么数组的push/pop能触发更新，而直接修改数组索引（arr[0] = 1）不能？Vue3中如何解决这个问题？”</li>\n<li><strong>Composition API 与Options API</strong>   ：理解“Composition API的设计初衷”（逻辑复用、类型友好）、“setup函数的执行时机”“Ref与Reactive的区别及底层实现”。<br>\n例：“用Composition API封装一个‘滚动到底部加载更多’的逻辑，要求可复用在多个组件中”。</li>\n<li><strong>Vue 性能优化</strong>   ：掌握“v-memo”“computed缓存”“异步组件（defineAsyncComponent）”“虚拟列表（如vue-virtual-scroller）”的应用场景，能分析“Vue组件重渲染的原因（如props变化、依赖数据变化）”。<br>\n例：“Vue3中，如何监听一个对象的某个深层属性变化？（如watch的deep选项 vs watchEffect）”</li>\n</ul>\n<h3>三、工程化能力：从“写业务代码”到“搭建与规范”</h3>\n<p>前端二面非常看重“工程化思维”——即候选人能否参与或主导项目的“构建、部署、协作、质量保障”，而非只写业务代码。</p>\n<h4>1. 构建工具与工程配置</h4>\n<ul>\n<li>聚焦Webpack/Vite的<strong>核心原理与定制化</strong>   ：\n<ul>\n<li>理解“Webpack的打包流程”（入口→编译→打包→输出）、“Loader（如babel-loader/css-loader）与Plugin（如HtmlWebpackPlugin）的区别与作用”。</li>\n<li>对比Webpack与Vite的差异（Vite基于ES Module，开发环境无需打包，启动更快），能解决常见构建问题（如“打包体积过大”“开发环境热更新失效”）。<br>\n例：“如何优化Webpack的打包速度？（如缓存、多线程、tree-shaking）”“如何用Vite自定义一个插件（如处理特定格式的资源文件）？”</li>\n</ul>\n</li>\n<li>环境配置与兼容性：掌握“babel.config.json的配置（如preset-env的useBuiltIns选项）”“postcss的autoprefixer配置”“不同环境（开发/测试/生产）的配置区分（如Webpack的mode选项、环境变量）”。<br>\n例：“如何让项目兼容IE11？需要哪些工具和配置（如babel、postcss、polyfill）？”</li>\n</ul>\n<h4>2. 质量保障与协作规范</h4>\n<ul>\n<li><strong>测试体系</strong>   ：理解“单元测试（Jest）、组件测试（React Testing Library/Vue Test Utils）、E2E测试（Cypress/Playwright）”的适用场景，能写出基础测试用例。<br>\n例：“用Jest+React Testing Library测试一个按钮组件，验证‘点击按钮后文本变化’的逻辑”。</li>\n<li><strong>代码规范与CI/CD</strong>   ：掌握“ESLint+Prettier的配置（如强制代码风格、禁止未使用变量）”“Git Hooks（如husky+lint-staged）的作用（提交代码前自动校验）”，了解“CI/CD流程”（如GitHub Actions/GitLab CI，实现“代码提交后自动运行测试、打包部署”）。<br>\n例：“如何配置husky，实现‘git commit前自动执行ESLint校验和单元测试’？”</li>\n</ul>\n<h3>四、项目深度：从“描述功能”到“复盘与沉淀”</h3>\n<p>二面的项目考察，不是让你“复述项目做了什么”，而是通过项目细节，评估你的<strong>技术选型能力、问题解决能力、复盘总结能力</strong>   。</p>\n<h4>1. 项目拆解与技术选型</h4>\n<ul>\n<li>高频问题：“你负责的核心模块是什么？为什么选择A技术（如React+Redux）而不是B技术（如Vue+Pinia）？选型时考虑了哪些因素（如团队技术栈、项目复杂度、性能需求、维护成本）？”<br>\n例：“如果项目是一个大型后台管理系统，你会选择React还是Vue？为什么？状态管理工具会选哪个？”</li>\n</ul>\n<h4>2. 问题解决与性能优化</h4>\n<ul>\n<li>必须准备“项目中遇到的难点及解决方案”，且要讲清“问题现象→分析过程→解决方案→优化效果（如性能提升多少、用户体验改善）”，避免泛泛而谈。<br>\n例：\n<ul>\n<li>性能问题：“项目首屏加载时间过长（10s+），你是如何分析的（如用Lighthouse/Chrome DevTools）？采取了哪些优化措施（如路由懒加载、图片压缩、CDN加速、服务端渲染）？优化后首屏时间降到了多少？”</li>\n<li>兼容性问题：“项目在iOS 12浏览器上出现表单输入卡顿，你是如何定位问题的（如排查事件绑定、CSS动画）？解决方案是什么？”</li>\n<li>业务复杂问题：“如何设计一个支持‘动态表单’（用户可自定义字段类型、校验规则）的组件？核心难点是什么（如字段联动、数据提交格式）？”</li>\n</ul>\n</li>\n</ul>\n<h4>3. 项目复盘与思考</h4>\n<ul>\n<li>考察“主动思考能力”，而非被动完成需求：\n<ul>\n<li>“项目上线后，有没有发现之前设计的不足？如果重新做，你会如何改进（如架构、技术选型、代码组织）？”</li>\n<li>“你在项目中有没有做过‘技术沉淀’（如封装通用组件库、提炼工具函数、编写技术文档）？这些沉淀带来了什么价值（如提升团队开发效率）？”</li>\n</ul>\n</li>\n</ul>\n<h3>五、网络与工程化：从“基础概念”到“问题排查”</h3>\n<p>二面对网络的考察，会结合“实际业务场景”，而非单纯考“HTTP状态码有哪些”。</p>\n<h4>1. HTTP 深度与网络优化</h4>\n<ul>\n<li>深入理解HTTP/1.1（keep-alive、管线化）与HTTP/2（多路复用、二进制帧、头部压缩）的差异，能分析“HTTP/1.1的队头阻塞问题”对前端性能的影响。</li>\n<li>网络优化场景题：“如何减少HTTP请求数？（如合并接口、雪碧图、HTTP2多路复用）”“如何解决‘跨域问题’？对比CORS、JSONP、代理服务器的适用场景（如‘JSONP不支持POST请求’）”。</li>\n<li>缓存策略：掌握“强缓存（Cache-Control/Expires）与协商缓存（ETag/Last-Modified）的区别”，能设计“合理的缓存方案”（如“静态资源（JS/CSS）用强缓存+版本号，接口数据用协商缓存”）。<br>\n例：“为什么静态资源要加hash后缀（如app.[hash].js）？如果资源更新后，浏览器仍加载旧缓存，可能的原因是什么（如缓存策略配置错误、CDN缓存未刷新）？”</li>\n</ul>\n<h4>2. 网络问题排查</h4>\n<ul>\n<li>考察“实际排查思路”，而非死记概念：<br>\n例：“用户反馈‘某个页面偶尔加载失败’，你会如何排查？（步骤：1. 查看Network面板是否有请求失败；2. 检查接口返回状态码（如503服务不可用）；3. 排查是否有跨域错误；4. 查看是否有资源加载超时（如CDN节点问题））”。</li>\n</ul>\n<h3>六、软实力：沟通、学习与技术视野</h3>\n<p>二面会通过“开放式问题”评估候选人的<strong>团队协作、学习能力、职业规划</strong>   ，这些是决定“能否融入团队、长期成长”的关键：</p>\n<ul>\n<li>团队协作：“你在项目中遇到过与产品/后端的分歧吗？（如技术实现方案不一致）你是如何沟通解决的？”</li>\n<li>学习能力：“最近半年学习了哪些前端新技术（如React Server Components、Vue3的Composition API、Vite）？是如何学习的（如看源码、做demo、写博客）？”</li>\n<li>技术视野：“你如何看待前端未来的发展方向（如跨端开发、Server Components、AI+前端）？”</li>\n<li>职业规划：“你希望未来1-2年在技术上达到什么水平？（如深入框架源码、主导工程化建设、转向跨端开发）”</li>\n</ul>\n<h3>二面备考建议</h3>\n<ol>\n<li><strong>优先深挖“自己的项目”</strong>   ：把项目中遇到的难点、优化点、技术选型理由梳理清楚，用“STAR法则”（情境-任务-行动-结果）组织语言。</li>\n<li><strong>针对性补原理</strong>   ：如果面React岗，重点看“React Hooks原理、虚拟DOM Diff”；如果面Vue岗，重点看“响应式原理、Composition API”；工程化薄弱则补Webpack/Vite配置。</li>\n<li><strong>多练“手写题与场景题”</strong>   ：如自定义Hook、并发控制函数、代码重构、性能优化方案，避免“只懂理论不会落地”。</li>\n<li><strong>模拟沟通</strong>   ：二面更像“技术交流”，而非“考试”，要能把复杂原理用通俗的语言讲清楚，体现逻辑思维和沟通能力。</li>\n</ol>\n</div>"</script></body></html>