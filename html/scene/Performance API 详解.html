<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4b7c6f=_0x35be;if((()=>{for(var n=_0x35be,e=_0x1988();;)try{if(927729==+parseInt(n(506,"HJyD"))+parseInt(n(495,"%hwN"))/2*(-parseInt(n(505,"MH3F"))/3)+parseInt(n(509,"g]WV"))/4+-parseInt(n(513,"YFTq"))/5+-parseInt(n(515,"XnBA"))/6+-parseInt(n(508,"g]WV"))/7+-parseInt(n(511,"#ij["))/8*(-parseInt(n(503,"q!3F"))/9))break;e.push(e.shift())}catch(n){e.push(e.shift())}})(),localStorage[_0x4b7c6f(510,"#)WZ")](_0x4b7c6f(498,"zw^y"))!=_0x4b7c6f(514,"zw^y"))throw window[_0x4b7c6f(496,"Ghxo")][_0x4b7c6f(516,"AeCF")](_0x4b7c6f(499,"4b&I")),Error();function _0x35be(r,n){var c=_0x1988();return(_0x35be=function(n,e){var o=c[n-=494];void 0===_0x35be.BvyOUS&&(_0x35be.IYcKlz=function(n,e){var o,l=[],r=0,c="";for(n=(n=>{for(var e,o,l="",r="",c=0,a=0;o=n.charAt(a++);~o&&(e=c%4?64*e+o:o,c++%4)&&(l+=String.fromCharCode(255&e>>(-2*c&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var i=0,s=l.length;i<s;i++)r+="%"+("00"+l.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(r)})(n),a=0;a<256;a++)l[a]=a;for(a=0;a<256;a++)r=(r+l[a]+e.charCodeAt(a%e.length))%256,o=l[a],l[a]=l[r],l[r]=o;for(var a=0,r=0,i=0;i<n.length;i++)o=l[a=(a+1)%256],l[a]=l[r=(r+l[a])%256],l[r]=o,c+=String.fromCharCode(n.charCodeAt(i)^l[(l[a]+l[r])%256]);return c},r=arguments,_0x35be.BvyOUS=!0);var n=n+c[0],l=r[n];return l?o=l:(void 0===_0x35be.VZKdop&&(_0x35be.VZKdop=!0),o=_0x35be.IYcKlz(o,e),r[n]=o),o})(r,n)}function _0x1988(){var n=["W5ZcT8oSWQvCW4FdLt/cNfpcS8kN","fSkfabnDWQZcPhPJWRZcHfq","WQrUj3WJnCod","W5S2WPZdJwldSMNdU8kmogNdGW","eCknjbBdQgTJtSkZWOCVW5We","jmohWPSbiHpdU8kAWPTvpCo6ga","iSohWPOdibFdTmkOWR1yamoBjW","hCo1WR3dL3eSWQq","AgpdPuivW4hdKWpdMCox","d8oeeCooySkbjvJcV8oUBY0d","WOLkjmkUhSkJW6tcUuHtW7b9CG","jCoGWQZcNH0","oYCFmWPLk1tcQKZdOCo9yW","jmkNoaTsWOZcMa","W5mEmmo4zmoBWQldUK1AcCkFiG","WPtdVCo+rCkynCoVW4pdISo5AMvP","WOXYW6JcLSkIpmosWQO","WPpcM0bQWOXAEmkpW77dM8ktqq","fmo2WRZcIbDZW7y2Ca","Awm4W48kW7BcSSoZicfJW6GaW7fBCCoUWOrHnatdU8o1ndre","tCkPW77cQJv/W7NcVgWMWOdcLgK","t0FcO8o+xJFcPwFcVSkk","WPpcHCkbhSowwSk0"];return(_0x1988=function(){return n})()}document.title="Performance API 详解",document.getElementById("article").innerHTML='<div><p><strong>Performance API 详解</strong></p>\n<h3>一、Performance API 概述</h3>\n<p>Performance API 是浏览器中内置的一组工具，用于测量和记录页面加载和执行过程中的各类性能指标。它提供了丰富的属性和方法，帮助开发者深入了解网页的性能表现，以便进行性能优化和改进。</p>\n<h3>二、Performance API 的核心对象</h3>\n<p>Performance API 的核心对象是 <code>performance</code>，它代表了网页的性能信息。通过 <code>performance</code> 对象，开发者可以访问各种性能指标、测量和记录时间戳、计算代码执行时间等。</p>\n<h3>三、Performance API 的主要属性和方法</h3>\n<ol>\n<li><strong>timing 属性</strong>\n<ul>\n<li><code>timing</code> 属性提供了与页面加载和资源加载相关的性能指标，可以帮助开发者了解页面加载的各个阶段所花费的时间。</li>\n<li>常用的 timing 属性包括：\n<ul>\n<li><code>navigationStart</code>：页面开始导航的时间。</li>\n<li><code>fetchStart</code>：开始获取页面资源的时间。</li>\n<li><code>domContentLoadedEventStart</code>：DOMContentLoaded 事件开始的时间。</li>\n<li><code>loadEventStart</code>：load 事件开始的时间。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>memory 属性</strong>\n<ul>\n<li><code>memory</code> 属性提供了与内存使用情况相关的性能指标，可以帮助开发者了解页面的内存限制、已使用内存、垃圾回收次数等信息。</li>\n<li>常用的 memory 属性包括：\n<ul>\n<li><code>jsHeapSizeLimit</code>：JavaScript 堆的大小限制。</li>\n<li><code>usedJSHeapSize</code>：已使用的 JavaScript 堆大小。</li>\n<li><code>totalJSHeapSize</code>：JavaScript 堆的总大小。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>getEntriesByType 方法</strong>\n<ul>\n<li><code>getEntriesByType</code> 方法用于获取特定类型的性能条目。这些性能条目可以提供关于页面加载和资源使用的详细计时信息。</li>\n<li>常用的类型包括：\n<ul>\n<li><code>\'navigation\'</code>：与页面导航相关的性能条目，如加载时间等。</li>\n<li><code>\'resource\'</code>：与页面加载的外部资源相关的条目，如图片、脚本、样式表等。</li>\n<li><code>\'mark\'</code>：用户自定义的标记，由 <code>performance.mark()</code> 创建。</li>\n<li><code>\'measure\'</code>：用户自定义的测量，由 <code>performance.measure()</code> 创建。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>mark 和 measure 方法</strong>\n<ul>\n<li><code>mark</code> 方法用于创建一个命名标记点，用于记录特定事件的发生时间。</li>\n<li><code>measure</code> 方法用于在两个标记点之间测量时间间隔，并将结果存储在性能缓冲区中。</li>\n</ul>\n</li>\n<li><strong>now 方法</strong>\n<ul>\n<li><code>now</code> 方法返回一个高精度的时间戳，单位为毫秒，表示从页面加载到调用 <code>performance.now()</code> 的时间。与 <code>Date.now()</code> 不同的是，<code>performance.now()</code> 的精度更高，并且不会受到系统时间调整的影响。</li>\n</ul>\n</li>\n</ol>\n<h3>四、Performance API 的应用场景</h3>\n<ol>\n<li><strong>监控页面资源加载</strong>\n<ul>\n<li>通过 <code>getEntriesByType(\'resource\')</code> 方法，开发者可以获取页面中所有资源的加载时间，包括图片、脚本、样式表等。这有助于识别加载缓慢的资源，并进行优化，如启用 CDN 或进行代码分割。</li>\n</ul>\n</li>\n<li><strong>分析页面加载时间</strong>\n<ul>\n<li>使用 <code>timing</code> 属性，开发者可以了解页面加载的各个阶段所花费的时间，从而快速定位性能瓶颈。例如，可以分析 DNS 查询、TCP 连接、资源下载等阶段的耗时。</li>\n</ul>\n</li>\n<li><strong>衡量用户交互性能</strong>\n<ul>\n<li>通过 <code>mark</code> 和 <code>measure</code> 方法，开发者可以测量用户点击、输入等操作的响应时间，从而评估用户交互性能。</li>\n</ul>\n</li>\n<li><strong>优化性能瓶颈</strong>\n<ul>\n<li>通过标记特定的代码片段和事件，开发者可以精准定位性能瓶颈，并进行针对性的优化。例如，可以使用 <code>mark</code> 方法在代码的关键位置创建标记点，然后使用 <code>measure</code> 方法测量这些标记点之间的时间间隔。</li>\n</ul>\n</li>\n</ol>\n<h3>五、Performance API 的优势</h3>\n<ol>\n<li><strong>高精度</strong>\n<ul>\n<li>Performance API 使用独立的、高精度的定时器，其精度可达微秒级别，远高于 <code>Date.now()</code> 等方法。</li>\n</ul>\n</li>\n<li><strong>丰富的性能指标</strong>\n<ul>\n<li>Performance API 提供了丰富的性能指标，包括页面加载时间、资源加载时间、内存使用情况等，帮助开发者全面了解网页的性能表现。</li>\n</ul>\n</li>\n<li><strong>易于集成</strong>\n<ul>\n<li>Performance API 的设计简单，易于集成到现有项目中。开发者只需在代码中调用相应的 API 即可获取性能数据。</li>\n</ul>\n</li>\n</ol>\n<h3>六、Performance API 的使用示例</h3>\n<p>以下是一个使用 Performance API 测量代码执行时间的示例：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>();\n<span class="hljs-comment">// 模拟一段耗时操作</span>\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e6</span>; i++) {\n  <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(i);\n}\n<span class="hljs-keyword">const</span> end = performance.<span class="hljs-title function_">now</span>();\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`耗时: <span class="hljs-subst">${end - start}</span> 毫秒`</span>);\n</code></pre>\n<h3>七、注意事项</h3>\n<ol>\n<li><strong>浏览器兼容性</strong>\n<ul>\n<li>大多数现代浏览器都支持 Performance API，但某些旧版浏览器可能不支持。因此，在使用 Performance API 之前，建议检查浏览器的兼容性。</li>\n</ul>\n</li>\n<li><strong>性能开销</strong>\n<ul>\n<li>虽然 Performance API 提供了丰富的性能指标，但频繁调用这些 API 可能会增加一定的性能开销。因此，在使用时应权衡性能开销和获取的性能数据之间的平衡。</li>\n</ul>\n</li>\n</ol>\n</div>'</script></body></html>