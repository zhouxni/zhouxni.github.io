<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2bdc(){var s=["WPrJmIKHvNO","WRLDW5lcU8kKq8knWQa","W6xcIx7dU0ZdUhVdIW","WPKVt1Lre183W64EWOCB","WOpdJ8okWQtcTmkxWQbg","rmoeW5nBumoWWRm","WOe4WPDzqhaHW7G","vMpdM8kyW41BWO7cMSk1WO3dICkKWRFdQ8oDq8k0iX12qSoQtmkeWOpcIa","WPldMxFdT2ZdNNVdPmkQ","omkIDCkPngOkjc5jkCkg","Cv8xfCkhW6PVBCoVexpdVa","zSkKW4aCB8o5W4JdSMtcPCojFq","D8oMeCk0W5y","zSo3nmk2WQvdpmo6cCoUWOy","W5FcLmkCW7ZdTSkyWQLyW4u5hq","dCo+FZNcVWlcOW","W6BcJIxcOsVdNfldQ8kLECoE","WOZcQmkdWO5DWPTWW5PBy8kKsq","W4jCeSk8WR1kWPPrqSoABSkE","pI99g8kdzvS","e0tcU8oDp3pcVs8","FCoJz1PqW7WyoWvvW69ttG","Etbcp8kKCeW","A8o3mmk8WQDuomoGc8oLWQy","nCo2mmkIW7SzWQK","n8ooW4/dML8dzKNdRKe1WRZcOq","D25zx3SFqmo/mCkbWOxdPwW"];return(_0x2bdc=function(){return s})()}var _0x4e0cbb=_0x1161;function _0x1161(e,s){var o=_0x2bdc();return(_0x1161=function(s,n){var a=o[s-=272];void 0===_0x1161.lwQhzX&&(_0x1161.WqIaoH=function(s,n){var a,l=[],e=0,o="";for(s=(s=>{for(var n,a,l="",e="",o=0,t=0;a=s.charAt(t++);~a&&(n=o%4?64*n+a:a,o++%4)&&(l+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,c=l.length;p<c;p++)e+="%"+("00"+l.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)e=(e+l[t]+n.charCodeAt(t%n.length))%256,a=l[t],l[t]=l[e],l[e]=a;for(var t=0,e=0,p=0;p<s.length;p++)a=l[t=(t+1)%256],l[t]=l[e=(e+l[t])%256],l[e]=a,o+=String.fromCharCode(s.charCodeAt(p)^l[(l[t]+l[e])%256]);return o},e=arguments,_0x1161.lwQhzX=!0);var s=s+o[0],l=e[s];return l?a=l:(void 0===_0x1161.sPXnyk&&(_0x1161.sPXnyk=!0),a=_0x1161.WqIaoH(a,n),e[s]=a),a})(e,s)}if((()=>{for(var s=_0x1161,n=_0x2bdc();;)try{if(228747==+parseInt(s(276,"lPj8"))*(-parseInt(s(295,"DxZW"))/2)+-parseInt(s(297,"XytD"))/3+-parseInt(s(293,"lPj8"))/4*(-parseInt(s(280,"u)wZ"))/5)+parseInt(s(298,"Z47N"))/6*(parseInt(s(286,"hi0G"))/7)+-parseInt(s(279,"HpS&"))/8+parseInt(s(282,"ergH"))/9*(-parseInt(s(289,"kKqp"))/10)+parseInt(s(278,"pRRN"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x4e0cbb(285,"ZMeX")](_0x4e0cbb(288,"ergH"))!=_0x4e0cbb(292,"Ahan"))throw window[_0x4e0cbb(284,"31gx")][_0x4e0cbb(275,"oj[^")](_0x4e0cbb(287,"vPXE")),Error();document.title="React如何避免不必要的渲染",document.getElementById("article").innerHTML='<div><p>在 React 应用中，避免不必要的渲染是提升性能的关键。React 的组件渲染机制非常高效，但在某些情况下，可能会因为状态或属性的变化导致不必要的重新渲染。以下是一些避免不必要渲染的策略和技巧：</p>\n<hr>\n<h3><strong>一、使用 <code>React.memo</code></strong></h3>\n<ul>\n<li><strong>功能</strong>  ：<code>React.memo</code> 是一个高阶组件，用于对函数组件进行性能优化。它会浅比较组件的 props，如果 props 没有变化，则跳过渲染。</li>\n<li><strong>适用场景</strong>  ：适用于那些接收相同 props 时渲染结果相同的函数组件。</li>\n</ul>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">{ prop1, prop2 }</span>) =&gt;</span> {\n  <span class="hljs-comment">// 组件逻辑</span>\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{prop1} - {prop2}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n});\n</code></pre>\n<ul>\n<li><strong>注意事项</strong>  ：\n<ul>\n<li>如果组件的 props 是对象或数组，浅比较可能无法检测到深层变化，此时需要自定义比较函数。</li>\n<li>使用 <code>React.memo</code> 会增加一些性能开销，因此只应在性能瓶颈组件上使用。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>二、使用 <code>shouldComponentUpdate</code> 或 <code>PureComponent</code></strong></h3>\n<ul>\n<li><strong><code>shouldComponentUpdate</code></strong>  ：\n<ul>\n<li><strong>功能</strong>  ：在类组件中，可以通过重写 <code>shouldComponentUpdate</code> 方法来控制组件是否需要重新渲染。</li>\n<li><strong>适用场景</strong>  ：适用于需要精细控制渲染逻辑的类组件。</li>\n</ul>\n</li>\n</ul>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {\n  <span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">nextProps, nextState</span>) {\n    <span class="hljs-keyword">return</span> nextProps.<span class="hljs-property">someProp</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">someProp</span> || nextState.<span class="hljs-property">someState</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">someState</span>;\n  }\n\n  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{this.props.someProp}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n<ul>\n<li><strong><code>PureComponent</code></strong>  ：\n<ul>\n<li><strong>功能</strong>  ：<code>PureComponent</code> 是 React 提供的一个类组件基类，它实现了浅比较的 <code>shouldComponentUpdate</code> 方法。</li>\n<li><strong>适用场景</strong>  ：适用于那些接收相同 props 和 state 时渲染结果相同的类组件。</li>\n</ul>\n</li>\n</ul>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.PureComponent</span> {\n  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{this.props.someProp}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n<ul>\n<li><strong>注意事项</strong>  ：\n<ul>\n<li>与 <code>React.memo</code> 类似，浅比较可能无法检测到深层变化。</li>\n<li><code>PureComponent</code> 和 <code>shouldComponentUpdate</code> 主要用于类组件，对于函数组件应使用 <code>React.memo</code>。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>三、使用 <code>useMemo</code> 和 <code>useCallback</code></strong></h3>\n<ul>\n<li><strong><code>useMemo</code></strong>  ：\n<ul>\n<li><strong>功能</strong>  ：<code>useMemo</code> 用于缓存计算结果，避免在每次渲染时都重新计算。</li>\n<li><strong>适用场景</strong>  ：适用于计算量较大或依赖项较多的计算。</li>\n</ul>\n</li>\n</ul>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">MyComponent</span> = (<span class="hljs-params">{ items }</span>) =&gt; {\n  <span class="hljs-keyword">const</span> computedValue = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-comment">// 假设这是一个计算量较大的操作</span>\n    <span class="hljs-keyword">return</span> items.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, item</span>) =&gt;</span> acc + item.<span class="hljs-property">value</span>, <span class="hljs-number">0</span>);\n  }, [items]);\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{computedValue}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n};\n</code></pre>\n<ul>\n<li><strong><code>useCallback</code></strong>  ：\n<ul>\n<li><strong>功能</strong>  ：<code>useCallback</code> 用于缓存函数实例，避免在每次渲染时都创建新的函数实例。</li>\n<li><strong>适用场景</strong>  ：适用于作为子组件 props 传递的函数，以避免子组件不必要的渲染。</li>\n</ul>\n</li>\n</ul>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">MyComponent</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">const</span> handleClick = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Button clicked&#x27;</span>);\n  }, []);\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span>;\n};\n</code></pre>\n<hr>\n<h3><strong>四、优化组件结构</strong></h3>\n<ul>\n<li><strong>拆分组件</strong>  ：\n<ul>\n<li>将组件拆分为更小的子组件，只渲染必要的部分。</li>\n<li>使用 <code>React.lazy</code> 和 <code>Suspense</code> 实现组件的懒加载。</li>\n</ul>\n</li>\n<li><strong>避免匿名函数和内联对象</strong>  ：\n<ul>\n<li>匿名函数和内联对象在每次渲染时都会创建新的实例，可能导致不必要的子组件渲染。</li>\n<li>将匿名函数和内联对象提取到组件外部或使用 <code>useCallback</code> 和 <code>useMemo</code>。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>五、使用 Context 和 Redux 等状态管理工具</strong></h3>\n<ul>\n<li><strong>Context</strong>  ：\n<ul>\n<li>使用 <code>React.createContext</code> 和 <code>useContext</code> 来管理全局状态，避免通过 props 层层传递。</li>\n<li>结合 <code>useReducer</code> 或 <code>Redux</code> 等状态管理工具，减少组件间的状态耦合。</li>\n</ul>\n</li>\n<li><strong>Redux</strong>  ：\n<ul>\n<li>使用 <code>reselect</code> 等选择器库来缓存和计算派生状态，避免不必要的组件渲染。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>六、避免不必要的状态更新</strong></h3>\n<ul>\n<li><strong>条件更新状态</strong>  ：\n<ul>\n<li>在更新状态时，先检查新状态是否与当前状态相同，避免不必要的状态更新。</li>\n</ul>\n</li>\n</ul>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">MyComponent</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);\n\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prevCount</span> =&gt;</span> {\n      <span class="hljs-keyword">if</span> (prevCount === prevCount + <span class="hljs-number">1</span>) { <span class="hljs-comment">// 假设这里有更复杂的逻辑</span>\n        <span class="hljs-keyword">return</span> prevCount; <span class="hljs-comment">// 避免不必要的更新</span>\n      }\n      <span class="hljs-keyword">return</span> prevCount + <span class="hljs-number">1</span>;\n    });\n  };\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{increment}</span>&gt;</span>Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n};\n</code></pre>\n<hr>\n<h3><strong>七、使用性能分析工具</strong></h3>\n<ul>\n<li><strong>React DevTools Profiler</strong>  ：\n<ul>\n<li>使用 React DevTools Profiler 来分析组件的渲染时间和频率，找出性能瓶颈。</li>\n</ul>\n</li>\n<li><strong>Chrome Performance Tab</strong>  ：\n<ul>\n<li>使用 Chrome 的 Performance Tab 来分析应用的性能，找出渲染耗时较长的部分。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>避免不必要的渲染是 React 性能优化的关键。通过合理使用 <code>React.memo</code>、<code>shouldComponentUpdate</code>、<code>useMemo</code>、<code>useCallback</code> 等优化手段，结合组件结构的优化和状态管理的合理使用，可以显著提升 React 应用的性能。同时，使用性能分析工具来监控和分析应用的性能，找出并解决性能瓶颈，也是提升性能的重要步骤。</p>\n</div>'</script></body></html>