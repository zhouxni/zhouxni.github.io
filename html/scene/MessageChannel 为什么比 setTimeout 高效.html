<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4169f5=_0x51f4;function _0x2e25(){var n=["d24bW7iCW4RcP8kKzmkqaMy","xcRdImojD8kOWP8xWOpcG0Hh","A8oiWRrRW7PeWP8","W6NcOepdOcnAjq","zJZdU2rXW6HxWRaLFYH1WONcKW","W45zWPhdKrBcNCkm","pCoeqCkZDCo0ua","WOVdMWNcMIJdT8kZWRlcMMddImoJW60","WPPDWRFdIsCcW7fEdSo3xSkN","tclcOeFcJWlcQGS","W5/cTJhdLCkdu1VcRmoPcLLH","W4hcImoWrmoNWPBcRWtdVSkarSkJW60","oG3cNmkAWQ9OW7K","tc3dVGBdU3FdPdywyIRcVfq","WQ3dN3CcW7xcOHZdUa","WOlcTSohWRtcQ0/dT8kEyCkdB8oqWOy","W48oW4/cLK7dTCoIqSkEW5DvW5ve","WR3dT8kjwYddVCkmW6TPW57dQmk0W5u1","zSkUCSk1gKJdGa","AMrYFMy","W5RdT8kEag3cIadcLv5cW63cTq","zaxcNSkAWO5XW7qb","W5JcHx0uW4pcLI3dUgm","W5zuFuJdLdikgCkyWRj8W6HqWPNdUmoUs8keBWf/WQ3cRHiDsq","W5bvWOjgWQySgxadqCkLeCkN"];return(_0x2e25=function(){return n})()}function _0x51f4(a,n){var o=_0x2e25();return(_0x51f4=function(n,s){var e=o[n-=338];void 0===_0x51f4.SKBlLC&&(_0x51f4.ofWNQZ=function(n,s){var e,t=[],a=0,o="";for(n=(n=>{for(var s,e,t="",a="",o=0,c=0;e=n.charAt(c++);~e&&(s=o%4?64*s+e:e,o++%4)&&(t+=String.fromCharCode(255&s>>(-2*o&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var l=0,d=t.length;l<d;l++)a+="%"+("00"+t.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(a)})(n),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)a=(a+t[c]+s.charCodeAt(c%s.length))%256,e=t[c],t[c]=t[a],t[a]=e;for(var c=0,a=0,l=0;l<n.length;l++)e=t[c=(c+1)%256],t[c]=t[a=(a+t[c])%256],t[a]=e,o+=String.fromCharCode(n.charCodeAt(l)^t[(t[c]+t[a])%256]);return o},a=arguments,_0x51f4.SKBlLC=!0);var n=n+o[0],t=a[n];return t?e=t:(void 0===_0x51f4.TSulzw&&(_0x51f4.TSulzw=!0),e=_0x51f4.ofWNQZ(e,s),a[n]=e),e})(a,n)}if((()=>{for(var n=_0x51f4,s=_0x2e25();;)try{if(992565==-parseInt(n(340,"UEGj"))+-parseInt(n(342,"pZFc"))/2*(-parseInt(n(356,"mimp"))/3)+-parseInt(n(346,"&E1)"))/4*(-parseInt(n(348,"&oU$"))/5)+parseInt(n(338,"VGcm"))/6*(parseInt(n(344,"v@!%"))/7)+parseInt(n(362,"G0Y6"))/8+parseInt(n(354,"w^]M"))/9+-parseInt(n(347,"gU*w"))/10)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x4169f5(358,"5Cty")](_0x4169f5(352,"v@!%"))!=_0x4169f5(349,"S](%"))throw window[_0x4169f5(351,"pZFc")][_0x4169f5(357,"*28k")](_0x4169f5(353,"Y#dV")),Error();document.title="MessageChannel 为什么比 setTimeout 高效",document.getElementById("article").innerHTML='<div><p><code>MessageChannel</code> 比 <code>setTimeout</code> 更高效的原因主要有以下几点：</p>\n<h3>1. <strong>任务调度的优先级不同</strong></h3>\n<ul>\n<li><code>MessageChannel</code> 属于 <strong>宏任务</strong>  ，但其回调在 <strong>事件循环的当前阶段立即执行</strong>  （属于 <code>macroTask</code> 的高优先级队列）。</li>\n<li><code>setTimeout</code> 也是宏任务，但它的回调会被放入 <strong>定时器队列</strong>  ，必须等待指定的延迟时间（即使设为 <code>0</code>，实际最小延迟为 <code>4ms</code> 左右，取决于浏览器实现）。</li>\n</ul>\n<h3>2. <strong><code>setTimeout</code> 的最小延迟限制</strong></h3>\n<ul>\n<li>由于历史原因，<code>setTimeout(fn, 0)</code> 的实际延迟至少为 <code>4ms</code>（HTML5 规范定义的阈值），而 <code>MessageChannel</code> <strong>无延迟</strong>  ，能更快触发回调。</li>\n<li>在频繁调用的场景（如动画、批量更新），<code>setTimeout</code> 的延迟累积会导致性能下降。</li>\n</ul>\n<h3>3. <strong><code>MessageChannel</code> 直接进入事件循环</strong></h3>\n<ul>\n<li><code>MessageChannel</code> 的 <code>port.postMessage()</code> 会直接将任务加入事件循环，<strong>跳过浏览器对定时器的调度优化</strong>  ，因此更接近同步执行的效率。</li>\n<li><code>setTimeout</code> 需要经过定时器管理模块，存在额外的开销（如延迟计算、队列调整）。</li>\n</ul>\n<h3>4. <strong>避免递归调用堆栈问题</strong></h3>\n<ul>\n<li>在需要递归调度任务时（如 React 的调度器），<code>MessageChannel</code> 不会像 <code>setTimeout</code> 那样导致调用栈延迟累积，能更流畅地处理高频任务。</li>\n</ul>\n<hr>\n<h3>示例对比</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 使用 setTimeout（可能有最小延迟）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleWithSetTimeout</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setTimeout&quot;</span>);\n  }, <span class="hljs-number">0</span>);\n}\n\n<span class="hljs-comment">// 使用 MessageChannel（无延迟）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleWithMessageChannel</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>();\n  channel.<span class="hljs-property">port1</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;MessageChannel&quot;</span>);\n  channel.<span class="hljs-property">port2</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-literal">null</span>);\n}\n\n<span class="hljs-comment">// 测试</span>\n<span class="hljs-title function_">scheduleWithSetTimeout</span>();  <span class="hljs-comment">// 可能延迟 ~4ms</span>\n<span class="hljs-title function_">scheduleWithMessageChannel</span>();  <span class="hljs-comment">// 立即执行</span>\n</code></pre>\n<hr>\n<h3>适用场景</h3>\n<ul>\n<li><strong>React Fiber 调度器</strong>  ：React 使用 <code>MessageChannel</code>（或 <code>setImmediate</code>）实现异步可中断渲染，避免 <code>setTimeout</code> 的延迟问题。</li>\n<li><strong>高性能动画/批量更新</strong>  ：需要尽快执行回调时，<code>MessageChannel</code> 是更优选择。</li>\n</ul>\n<h3>总结</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>MessageChannel</code></th>\n<th><code>setTimeout(fn, 0)</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>延迟</strong></td>\n<td>无（立即加入事件循环）</td>\n<td>≥4ms（浏览器限制）</td>\n</tr>\n<tr>\n<td><strong>调度开销</strong></td>\n<td>低</td>\n<td>较高（定时器管理）</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>高频任务、实时调度</td>\n<td>普通延迟任务</td>\n</tr>\n</tbody>\n</table>\n<p>因此，在需要<strong>高效、低延迟</strong>  的异步调度时，<code>MessageChannel</code> 是更好的选择。</p>\n</div>'</script></body></html>