<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2e21(){var n=["jSkWW4FdRaOBW6KRWQ0yW7W","f0z9aNatW5Xd","W5b8W73cV8oUpu7dQWClW4iF","W5hdPmkKjCoEo8kSW4O","W7e5zcJcSvmgWQZdKSkQW799","WOtdUSolAI5vcCkYja","ncddHCkqbIyLWOOX","A2tcGSktW6C4o8kd","BCkOWRG+vSopAWhcQXpdR2W","psldHmkjpdGwWOus","W64FW5G+ee7dUH3dPCoY","kmkpW741zNZdH8ooWQa","WQ7dKSkRaum","WQpcJmksWRVcQSowwweAW48","W6PgWOVdMa3cINxcMSk6wsOtrJC","tSkdW4b5dSoGWRCltCoxs8oOW4O","c2TnEImHiCobWQGkga","AtmNiSooExWpahtcNLCo","nxzOW4T1WRtdM1n1WOlcMG","jSk8W4RdPW1+WPj9WQCMW67dJ8kDbG","nYhcImkKbY4PWRi","rmoTyrRcVmkXWP7dGSk1W41r","nd/dP0i/W58vCa","zCoSWO7cUv4PW4u","heiYguazW7LZCq","WQtcH8krWR7dKCkrEf0bW60SWO8","qXz/oueWW5i","W7m5zxNdIsqPWOZdTG","WQH1jwRdTvTJW5VdGCkJW7HMWRNcQqhdLmkRBeSWWQCSFbCLW6S","j8k4W4/cVb0dFmkCW4i"];return(_0x2e21=function(){return n})()}function _0x3995(a,n){var e=_0x2e21();return(_0x3995=function(n,s){var t=e[n-=457];void 0===_0x3995.sMweVA&&(_0x3995.IBVDOR=function(n,s){var t,r=[],a=0,e="";for(n=(n=>{for(var s,t,r="",a="",e=0,o=0;t=n.charAt(o++);~t&&(s=e%4?64*s+t:t,e++%4)&&(r+=String.fromCharCode(255&s>>(-2*e&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var l=0,c=r.length;l<c;l++)a+="%"+("00"+r.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(a)})(n),o=0;o<256;o++)r[o]=o;for(o=0;o<256;o++)a=(a+r[o]+s.charCodeAt(o%s.length))%256,t=r[o],r[o]=r[a],r[a]=t;for(var o=0,a=0,l=0;l<n.length;l++)t=r[o=(o+1)%256],r[o]=r[a=(a+r[o])%256],r[a]=t,e+=String.fromCharCode(n.charCodeAt(l)^r[(r[o]+r[a])%256]);return e},a=arguments,_0x3995.sMweVA=!0);var n=n+e[0],r=a[n];return r?t=r:(void 0===_0x3995.IuXAsW&&(_0x3995.IuXAsW=!0),t=_0x3995.IBVDOR(t,s),a[n]=t),t})(a,n)}var _0x102d09=_0x3995;if((()=>{for(var n=_0x3995,s=_0x2e21();;)try{if(431735==-parseInt(n(462,"zs(1"))+parseInt(n(475,"x$oz"))/2*(-parseInt(n(459,"NY*7"))/3)+-parseInt(n(477,"&%b5"))/4+-parseInt(n(457,"x$oz"))/5*(parseInt(n(468,"O((e"))/6)+parseInt(n(463,"q1g1"))/7*(-parseInt(n(470,"#Hxb"))/8)+-parseInt(n(486,"q1g1"))/9*(parseInt(n(480,"^]zi"))/10)+parseInt(n(482,"O((e"))/11*(parseInt(n(476,"g5Sy"))/12))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x102d09(458,"q1g1")](_0x102d09(467,"H8K%"))!=_0x102d09(474,"Uy$3"))throw window[_0x102d09(484,"QNO*")][_0x102d09(485,"zs(1")](_0x102d09(460,"NY*7")),Error();document.title="IntersectionObserver 高效的核心原理",document.getElementById("article").innerHTML='<div><p><code>IntersectionObserver</code> 之所以比传统的滚动监听（如 <code>scroll</code> 事件）更高效，是因为它从根本上改变了浏览器检测元素相交状态的方式。以下是其高效性的核心原理：</p>\n<h4><strong>1. 浏览器原生优化的相交计算</strong></h4>\n<ul>\n<li><strong>渲染引擎直接处理</strong><br>\nIntersectionObserver 由浏览器的渲染引擎直接管理，与页面的布局和绘制流程深度整合。在浏览器执行布局（Layout）和绘制（Paint）阶段时，会自然地计算元素的相交状态，无需额外的 JavaScript 干预。</li>\n<li><strong>批量计算与通知</strong><br>\n浏览器会批量处理所有被观察元素的相交状态，一次性将变化通知给 JavaScript 回调。这种批量处理减少了 JavaScript 执行的频率和开销。</li>\n</ul>\n<h4><strong>2. 脱离主线程的异步观察</strong></h4>\n<ul>\n<li><strong>独立于 JavaScript 主线程</strong><br>\nIntersectionObserver 的观察任务在浏览器的渲染线程中执行，不会阻塞主线程的运行。即使页面上有复杂的 JavaScript 计算，观察任务也能按时完成。</li>\n<li><strong>优化的触发时机</strong><br>\n浏览器会智能地安排回调函数的执行时机，通常在帧开始或结束时触发，避免与关键渲染操作冲突。这确保了即使在高帧率的滚动过程中，回调也不会被频繁调用。</li>\n</ul>\n<h4><strong>3. 事件驱动的被动监听</strong></h4>\n<ul>\n<li><strong>仅在状态变化时触发</strong><br>\n传统的 <code>scroll</code> 事件是主动监听，无论元素是否可见，只要用户滚动页面就会触发。而 IntersectionObserver 是事件驱动的，<strong>只有当元素的可见性发生变化时</strong>  （进入或离开视口）才会触发回调。</li>\n<li><strong>减少不必要的计算</strong><br>\n例如，在图片懒加载场景中：\n<ul>\n<li>使用 <code>scroll</code>：每次滚动都要遍历所有图片，计算其位置</li>\n<li>使用 IntersectionObserver：仅在图片进入视口时执行加载逻辑</li>\n</ul>\n</li>\n</ul>\n<h4><strong>4. 避免强制同步布局（Force Synchronous Layout）</strong></h4>\n<ul>\n<li><strong>传统滚动监听的性能陷阱</strong><br>\n在 <code>scroll</code> 事件处理函数中读取元素的布局信息（如 <code>getBoundingClientRect()</code>）会触发强制同步布局，迫使浏览器立即计算最新的布局信息，导致性能损耗。</li>\n<li><strong>IntersectionObserver 的智能设计</strong><br>\n浏览器在计算元素相交状态时，会自然地使用最新的布局信息，无需 JavaScript 主动查询，从而避免了强制同步布局。</li>\n</ul>\n<h4><strong>5. 内存与资源优化</strong></h4>\n<ul>\n<li><strong>高效的内部数据结构</strong><br>\n浏览器使用优化的数据结构（如四叉树）来快速判断元素之间的相交关系，尤其在处理大量观察元素时效率显著提升。</li>\n<li><strong>自动垃圾回收</strong><br>\n当被观察的元素从 DOM 中移除时，IntersectionObserver 会自动释放相关资源，避免内存泄漏。</li>\n</ul>\n<h4><strong>工作流程对比</strong></h4>\n<table>\n<thead>\n<tr>\n<th><strong>传统 scroll 监听</strong></th>\n<th><strong>IntersectionObserver</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1. 用户滚动页面</td>\n<td>1. 创建观察器并注册元素</td>\n</tr>\n<tr>\n<td>2. 触发 scroll 事件</td>\n<td>2. 浏览器在渲染时计算相交状态</td>\n</tr>\n<tr>\n<td>3. JavaScript 遍历所有元素</td>\n<td>3. 仅在状态变化时触发回调</td>\n</tr>\n<tr>\n<td>4. 计算每个元素的可见性</td>\n<td>4. 批量传递变化信息给回调</td>\n</tr>\n<tr>\n<td>5. 执行相应操作</td>\n<td>5. 执行回调逻辑</td>\n</tr>\n</tbody>\n</table>\n<h4><strong>适用场景</strong></h4>\n<ul>\n<li><strong>图片懒加载</strong>  ：仅在图片进入视口时加载</li>\n<li><strong>无限滚动</strong>  ：检测底部元素，触发加载更多</li>\n<li><strong>滚动动画</strong>  ：元素可见时触发动画</li>\n<li><strong>广告曝光统计</strong>  ：精确计算广告展示时间</li>\n<li><strong>内容懒渲染</strong>  ：延迟渲染视口外的复杂组件</li>\n</ul>\n<h4><strong>示例代码</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 创建观察器实例</span>\n<span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(\n  <span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {\n    entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> {\n      <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {\n        <span class="hljs-comment">// 元素进入视口时的操作（如加载图片）</span>\n        entry.<span class="hljs-property">target</span>.<span class="hljs-property">src</span> = entry.<span class="hljs-property">target</span>.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>;\n        observer.<span class="hljs-title function_">unobserve</span>(entry.<span class="hljs-property">target</span>); <span class="hljs-comment">// 加载后停止观察</span>\n      }\n    });\n  },\n  {\n    <span class="hljs-attr">root</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 默认使用视口作为根元素</span>\n    <span class="hljs-attr">threshold</span>: <span class="hljs-number">0.1</span>, <span class="hljs-comment">// 元素可见度达到 10% 时触发</span>\n    <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">&#x27;0px&#x27;</span> <span class="hljs-comment">// 扩展或收缩根元素的边界框</span>\n  }\n);\n\n<span class="hljs-comment">// 观察所有图片元素</span>\n<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;img.lazy&#x27;</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">img</span>) =&gt;</span> {\n  observer.<span class="hljs-title function_">observe</span>(img);\n});\n</code></pre>\n<h3>总结</h3>\n<p>IntersectionObserver 通过浏览器原生优化、异步处理、事件驱动和智能内存管理，彻底解决了传统滚动监听带来的性能问题。它让开发者能够高效地实现复杂的交互效果，同时保持页面的流畅运行。在处理任何与元素可见性相关的场景时，IntersectionObserver 都是首选方案。</p>\n</div>'</script></body></html>