<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1c22(p,s){var t=_0x588d();return(_0x1c22=function(s,n){var a=t[s-=431];void 0===_0x1c22.smgWXt&&(_0x1c22.LMfZys=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,e=0;a=s.charAt(e++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=l.length;c<o;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[p],l[p]=a;for(var e=0,p=0,c=0;c<s.length;c++)a=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[p])%256]);return t},p=arguments,_0x1c22.smgWXt=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x1c22.iNIkhr&&(_0x1c22.iNIkhr=!0),a=_0x1c22.LMfZys(a,n),p[s]=a),a})(p,s)}var _0x5e7830=_0x1c22;function _0x588d(){var s=["nq4xB8odW5ldMwafWP3dLG","WRlcPCkKWPNdSvJcHwm9egRdP0e","W6NdKCojpGxdH1NdVxJcPq","W6pdI8oXkSoivCoTW7PQW4jdW6W","eCkBtbBdN0froCk+WPC","W6hdGSo4lSookmoQW51XW4fj","oCkVqJisWPVdTSoKnq","W6ukW7JdHtNcOwODl8k8W4u","W6hdUmoJW6NcSWNdKa","W6akW74ksSoyW6LaWQuTvdvb","e8kyW5pdU3VdN8kuWQbAmSk9nG","W7xdMgBdV1mmxCkzhIJcQw/cN8klECkvthSaWQ9Qif8PkqO","eZ3dHmkDeCkjW70wEbxcJsWI","W5W2W7pcOseXv8o5oq","E8oQaqqs","tHldQGJcSqDyDmkAn8o/oHy","ebjelcTPaaOxW6NdOmko","WRtcHSktAbxdNv/dKa","WO/cKZNcN8kkW7FdJCotgZGSW7y","WRVdU8k7W7tcQ8k8W7BdSLy","W5iWrxbAoJZdRLy","v8oDW45jW6xdHhtdHCkR","sI0fWOurW5FdL8o1W6pdOCkUWQS","ECo6aHSkWO7dQW","W6pdHmo0uCkTf8oXW5Pt","WQVcNIxcVXKfomoEmYZcHhS","oNDxW5jqWPhdQmoEW5u","f3jSpSouBwBcHJ9bpW"];return(_0x588d=function(){return s})()}if((()=>{for(var s=_0x1c22,n=_0x588d();;)try{if(963202==+parseInt(s(440,"6QrX"))+-parseInt(s(449,"5)E("))/2*(-parseInt(s(457,"QmS3"))/3)+-parseInt(s(454,"HwgP"))/4*(parseInt(s(433,"HwgP"))/5)+-parseInt(s(439,"[H4D"))/6+parseInt(s(432,"PO*K"))/7*(parseInt(s(435,"HwgP"))/8)+-parseInt(s(455,"lRoK"))/9*(-parseInt(s(450,"b7I#"))/10)+parseInt(s(431,"$g6x"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5e7830(438,"$g6x")](_0x5e7830(456,"YTuy"))!=_0x5e7830(444,"XPg6"))throw window[_0x5e7830(447,"PO*K")][_0x5e7830(453,"XPg6")](_0x5e7830(441,"lRoK")),Error();document.title="TypeScript 的 export = 语法详解",document.getElementById("article").innerHTML='<div><p><code>export =</code> 是 TypeScript 中一种特殊的导出语法，主要用于与 CommonJS/AMD 模块系统兼容。以下是它的核心特性和使用场景：</p>\n<p>基本语法</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// math.ts</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {\n  <span class="hljs-keyword">return</span> a + b;\n}\n\n<span class="hljs-keyword">export</span> = add;  <span class="hljs-comment">// 导出单个值</span>\n</code></pre>\n<p>主要特点</p>\n<ol>\n<li>兼容 CommonJS 的 <code>module.exports</code></li>\n</ol>\n<ul>\n<li>\n<p>编译为 CommonJS 时会产生 <code>module.exports = ...</code></p>\n<ul>\n<li>不同于 ES6 的 <code>export default</code></li>\n</ul>\n</li>\n</ul>\n<ol start="2">\n<li>只能导出一个值</li>\n</ol>\n<ul>\n<li>\n<p>可以是函数、类、对象、原始值等</p>\n<ul>\n<li>不能像 ES6 那样导出多个命名导出</li>\n</ul>\n</li>\n</ul>\n<ol start="3">\n<li>需要配套的导入语法</li>\n</ol>\n<ul>\n<li>必须使用 <code>import = require()</code> 语法导入</li>\n</ul>\n<p>使用场景</p>\n<ol>\n<li>导出单个类</li>\n</ol>\n<pre><code class="language-typescript"><span class="hljs-comment">// Logger.ts</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> {\n  <span class="hljs-title function_">log</span>(<span class="hljs-params"><span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);\n  }\n}\n\n<span class="hljs-keyword">export</span> = <span class="hljs-title class_">Logger</span>;\n</code></pre>\n<ol start="2">\n<li>导出函数</li>\n</ol>\n<pre><code class="language-typescript"><span class="hljs-comment">// utilities.ts</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">formatDate</span>(<span class="hljs-params"><span class="hljs-attr">date</span>: <span class="hljs-title class_">Date</span></span>): <span class="hljs-built_in">string</span> {\n  <span class="hljs-keyword">return</span> date.<span class="hljs-title function_">toISOString</span>();\n}\n\n<span class="hljs-keyword">export</span> = formatDate;\n</code></pre>\n<ol start="3">\n<li>导出配置对象</li>\n</ol>\n<pre><code class="language-typescript"><span class="hljs-comment">// config.ts</span>\n<span class="hljs-keyword">const</span> config = {\n  <span class="hljs-attr">apiUrl</span>: <span class="hljs-string">&#x27;https://api.example.com&#x27;</span>,\n  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>\n};\n\n<span class="hljs-keyword">export</span> = config;\n</code></pre>\n<p>配套导入方式</p>\n<p>必须使用 <code>import ... = require()</code> 语法：</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// 导入类</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">Logger</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./Logger&#x27;</span>);\n<span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Logger</span>();\n\n<span class="hljs-comment">// 导入函数</span>\n<span class="hljs-keyword">import</span> formatDate = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./utilities&#x27;</span>);\n<span class="hljs-keyword">const</span> dateStr = <span class="hljs-title function_">formatDate</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());\n\n<span class="hljs-comment">// 导入对象</span>\n<span class="hljs-keyword">import</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./config&#x27;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(config.<span class="hljs-property">apiUrl</span>);\n</code></pre>\n<p>与 ES6 模块的区别</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>export =</code></th>\n<th>ES6 <code>export</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>导出数量</td>\n<td>只能导出一个值</td>\n<td>可多个命名导出或默认导出</td>\n</tr>\n<tr>\n<td>导入语法</td>\n<td><code>import = require()</code></td>\n<td><code>import ... from ...</code></td>\n</tr>\n<tr>\n<td>编译结果(CommonJS)</td>\n<td><code>module.exports = ...</code></td>\n<td><code>exports.default = ...</code></td>\n</tr>\n<tr>\n<td>类型支持</td>\n<td>完全支持</td>\n<td>完全支持</td>\n</tr>\n<tr>\n<td>使用场景</td>\n<td>兼容旧代码/CommonJS 模块</td>\n<td>现代 JavaScript 开发</td>\n</tr>\n</tbody>\n</table>\n<p>注意事项</p>\n<ol>\n<li>不能与 <code>export default</code> 混用<pre><code class="language-typescript"><span class="hljs-comment">// 错误！不能同时使用</span>\n<span class="hljs-keyword">export</span> = add;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> subtract;\n</code></pre>\n</li>\n<li>在 ES6 模块系统中需要特殊处理</li>\n</ol>\n<ul>\n<li>\n<p>如果目标模块系统是 ES6，编译器会报错</p>\n<ul>\n<li>需要设置 <code>&quot;module&quot;: &quot;commonjs&quot;</code> 或 <code>&quot;esModuleInterop&quot;: true</code></li>\n</ul>\n</li>\n</ul>\n<ol start="3">\n<li>类型声明文件(.d.ts)中的使用<pre><code class="language-typescript"><span class="hljs-comment">// 声明一个 CommonJS 模块</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;my-module&#x27;</span> {\n  <span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span>;\n  <span class="hljs-keyword">export</span> = myFunc;\n}\n</code></pre>\n</li>\n<li>逐渐淘汰的趋势</li>\n</ol>\n<ul>\n<li>\n<p>在新项目中建议优先使用 ES6 模块语法</p>\n<ul>\n<li>主要用于维护旧代码或特定库的兼容性</li>\n</ul>\n</li>\n</ul>\n<p>实际应用示例</p>\n<ol>\n<li>导出构造函数</li>\n</ol>\n<pre><code class="language-typescript"><span class="hljs-comment">// database.ts</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Database</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">connectionString</span>: <span class="hljs-built_in">string</span></span>) {}\n  <span class="hljs-title function_">connect</span>(<span class="hljs-params"></span>) { <span class="hljs-comment">/* ... */</span> }\n}\n\n<span class="hljs-keyword">export</span> = <span class="hljs-title class_">Database</span>;\n</code></pre>\n<p>使用：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Database</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./database&#x27;</span>);\n<span class="hljs-keyword">const</span> db = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Database</span>(<span class="hljs-string">&#x27;mysql://localhost&#x27;</span>);\n</code></pre>\n<ol start="2">\n<li>导出函数+对象组合</li>\n</ol>\n<pre><code class="language-typescript"><span class="hljs-comment">// logger.ts</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">createLogger</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>) {\n  <span class="hljs-keyword">return</span> { <span class="hljs-attr">log</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">msg</span>: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[<span class="hljs-subst">${name}</span>] <span class="hljs-subst">${msg}</span>`</span>) };\n}\n\n<span class="hljs-keyword">namespace</span> <span class="hljs-title class_">createLogger</span> {\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> version = <span class="hljs-string">&#x27;1.0&#x27;</span>;\n}\n\n<span class="hljs-keyword">export</span> = createLogger;\n</code></pre>\n<p>使用：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">import</span> loggerFactory = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./logger&#x27;</span>);\n<span class="hljs-keyword">const</span> logger = <span class="hljs-title function_">loggerFactory</span>(<span class="hljs-string">&#x27;app&#x27;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(loggerFactory.<span class="hljs-property">version</span>);\n</code></pre>\n<p><code>export =</code> 语法是 TypeScript 为兼容传统模块系统提供的重要特性，虽然在现代开发中逐渐被 ES6 模块取代，但在处理某些旧代码库或特定场景时仍然非常有用。</p>\n</div>'</script></body></html>