<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4302(d,t){var e=_0x2a49();return(_0x4302=function(t,n){var o=e[t-=377];void 0===_0x4302.RAGLIH&&(_0x4302.iIwkcM=function(t,n){var o,r=[],d=0,e="";for(t=(t=>{for(var n,o,r="",d="",e=0,i=0;o=t.charAt(i++);~o&&(n=e%4?64*n+o:o,e++%4)&&(r+=String.fromCharCode(255&n>>(-2*e&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var c=0,l=r.length;c<l;c++)d+="%"+("00"+r.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(d)})(t),i=0;i<256;i++)r[i]=i;for(i=0;i<256;i++)d=(d+r[i]+n.charCodeAt(i%n.length))%256,o=r[i],r[i]=r[d],r[d]=o;for(var i=0,d=0,c=0;c<t.length;c++)o=r[i=(i+1)%256],r[i]=r[d=(d+r[i])%256],r[d]=o,e+=String.fromCharCode(t.charCodeAt(c)^r[(r[i]+r[d])%256]);return e},d=arguments,_0x4302.RAGLIH=!0);var t=t+e[0],r=d[t];return r?o=r:(void 0===_0x4302.DSooHG&&(_0x4302.DSooHG=!0),o=_0x4302.iIwkcM(o,n),d[t]=o),o})(d,t)}var _0x39645c=_0x4302;if((()=>{for(var t=_0x4302,n=_0x2a49();;)try{if(627265==-parseInt(t(387,"%T8h"))*(-parseInt(t(386,"]Jw9"))/2)+-parseInt(t(402,"h!@x"))/3*(-parseInt(t(404,"stav"))/4)+-parseInt(t(406,"gEZ1"))/5+parseInt(t(390,"Y4Pw"))/6*(parseInt(t(380,"gPvX"))/7)+-parseInt(t(403,"s4rH"))/8+parseInt(t(397,"m$r*"))/9*(-parseInt(t(394,"sK5y"))/10)+parseInt(t(395,"g]!g"))/11*(parseInt(t(388,"X(ri"))/12))break;n.push(n.shift())}catch(t){n.push(n.shift())}})(),localStorage[_0x39645c(399,"47%]")](_0x39645c(389,"%T8h"))!=_0x39645c(400,"HfO&"))throw window[_0x39645c(392,"89Dx")][_0x39645c(381,"8ITh")](_0x39645c(384,"KaK%")),Error();function _0x2a49(){var t=["dI8jWORcMSkUW5CSC2mwdtu","DhjyWRmPbh/cMW","W53cQIHmmYldUq","k8oVWQ4pbCoWW4xcRLu","wCkdeCkEzSkbW4RcPG","BY9UgGZdPqldQSotcaHvW7pcRXFcQXRcJeuqW7RdJmkuW4ddGHS","BCkGgSoYWQpcSfb1","ku0jW5ZcT8kSzq","iSojWOvpWQuohHFdSXddGW","W7/cKHLLW5NdIJf9WRVdPmkYgI3cPq","v8kzW5mFW6ihed/dOa","W5dcHZpdK8oMWPJdOICLeaNdHmoS","xmoBW41iWQeFuYW","qbpcMMaYW58yW7W","rxPKWP5wW7RcTmkftxhdQeL7","ewnSWOyjW5ldQmoPtGO8WRGU","qmoWW7NcU0VdRCoekW","xdeyb3CTWQpcNmorpKLPgbq","ccbjW5/dOSolWR4i","WPjbxKzzW5GEWRqNndu","C0JcLmo+WO/dPxG","W5ynhGWw","WQDazmoTWQtdHmoYW5BcO8oRd3q/","xbJcTrVcOrjaW4BcIG","WOSZWOKVW6uZWOrTWQxdQ3Hvrq","A8kHqmkPW5BcJvP3gSoHW4a","W4/cQCo3W4RdGspdKG","fqTyWR7dT8k3oY3dGmkVAMix","WQCPW4VdOGNdNSodo0FdJSk3","W73dMcVdK0zrbSogDLbdW7FcUG"];return(_0x2a49=function(){return t})()}document.title="在 React 中，Commit 阶段",document.getElementById("article").innerHTML="<div><p>在 React 中，<strong>Commit 阶段</strong>   是协调（Reconciliation）过程的最后一步，负责将虚拟 DOM 的变化应用到真实 DOM 并执行相关副作用。这个阶段分为三个主要子阶段，每个阶段执行特定类型的操作：</p>\n<h3><strong>1. 三个阶段概述</strong></h3>\n<pre><code>┌───────────────────┐     ┌───────────────────┐     ┌───────────────────┐\n│  before mutation  │ →→→ │     mutation      │ →→→ │    layout         │\n└───────────────────┘     └───────────────────┘     └───────────────────┘\n</code></pre>\n<h3><strong>2. 各阶段具体工作</strong></h3>\n<h4><strong>（1）Before Mutation 阶段</strong></h4>\n<ul>\n<li><strong>主要任务</strong>   ：读取 DOM 布局信息（如滚动位置、尺寸），准备 DOM 更新。</li>\n<li><strong>执行内容</strong>   ：\n<ul>\n<li>调用 <code>getSnapshotBeforeUpdate</code>（类组件生命周期）。</li>\n</ul>\n</li>\n<li><strong>关键点</strong>   ：此时 DOM 尚未更新，可获取更新前的布局信息。</li>\n</ul>\n<h4><strong>（2）Mutation 阶段</strong></h4>\n<ul>\n<li><strong>主要任务</strong>   ：更新真实 DOM。</li>\n<li><strong>执行内容</strong>   ：\n<ul>\n<li>根据 Diff 结果批量更新 DOM（插入、删除、修改节点）。</li>\n<li>组件删除时调用 <code>componentWillUnmount</code>（类组件生命周期）。</li>\n<li>执行 <code>useLayoutEffect</code> 的清理函数</li>\n</ul>\n</li>\n<li><strong>关键点</strong>   ：DOM 已更新，但用户尚未看到变化（浏览器尚未绘制）。</li>\n</ul>\n<h4><strong>（3）Layout 阶段</strong></h4>\n<ul>\n<li><strong>主要任务</strong>   ：执行依赖 DOM 布局的操作，通知应用更新完成。</li>\n<li><strong>执行内容</strong>   ：\n<ul>\n<li>调用 <code>componentDidMount</code>/<code>componentDidUpdate</code>（类组件生命周期）。</li>\n<li>执行 <code>useLayoutEffect</code> 的回调函数（同步执行）。</li>\n<li>调度 <code>useEffect</code> 的清理和回调函数（异步执行）。</li>\n</ul>\n</li>\n<li><strong>关键点</strong>   ：DOM 已更新且用户可见，可读取最新布局信息。</li>\n</ul>\n<h3><strong>3. 阶段对比与设计目的</strong></h3>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>执行时机</th>\n<th>是否阻塞渲染</th>\n<th>典型用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Before Mutation</td>\n<td>DOM 更新前</td>\n<td>是</td>\n<td>读取旧 DOM 布局信息</td>\n</tr>\n<tr>\n<td>Mutation</td>\n<td>DOM 更新中</td>\n<td>是</td>\n<td>修改真实 DOM</td>\n</tr>\n<tr>\n<td>Layout</td>\n<td>DOM 更新后，用户可见前</td>\n<td>是</td>\n<td>执行依赖新 DOM 布局的操作</td>\n</tr>\n<tr>\n<td>Effect</td>\n<td>异步（Layout 后）</td>\n<td>否</td>\n<td>执行副作用（如 API 调用、订阅）</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>4. 性能优化建议</strong></h3>\n<ul>\n<li><strong>避免在 Layout 阶段执行耗时操作</strong>   ：<code>useLayoutEffect</code> 和生命周期方法会阻塞浏览器绘制。</li>\n<li><strong>优先使用 <code>useEffect</code></strong>   ：对于不依赖 DOM 布局的副作用（如数据获取），避免阻塞渲染。</li>\n<li><strong>批量 DOM 操作</strong>   ：React 会在 Mutation 阶段批量更新 DOM，减少重排重绘。</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<p>Commit 阶段的三个子阶段通过分工协作，确保了 DOM 更新的高效性和一致性：</p>\n<ol>\n<li><strong>Before Mutation</strong>   ：准备 DOM 更新，读取旧布局。</li>\n<li><strong>Mutation</strong>   ：执行实际 DOM 变更。</li>\n<li><strong>Layout</strong>   ：同步执行依赖新 DOM 的操作，通知应用更新完成。</li>\n</ol>\n<p>这种设计使得 React 能够高效地处理复杂 UI 更新，并提供了明确的副作用执行时机。</p>\n</div>"</script></body></html>