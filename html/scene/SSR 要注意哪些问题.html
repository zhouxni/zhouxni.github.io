<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2cd5a3=_0x42dc;function _0x42dc(r,t){var o=_0x5b9d();return(_0x42dc=function(t,d){var n=o[t-=121];void 0===_0x42dc.TCrALv&&(_0x42dc.jgifWf=function(t,d){var n,e=[],r=0,o="";for(t=(t=>{for(var d,n,e="",r="",o=0,a=0;n=t.charAt(a++);~n&&(d=o%4?64*d+n:n,o++%4)&&(e+=String.fromCharCode(255&d>>(-2*o&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,h=e.length;c<h;c++)r+="%"+("00"+e.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(r)})(t),a=0;a<256;a++)e[a]=a;for(a=0;a<256;a++)r=(r+e[a]+d.charCodeAt(a%d.length))%256,n=e[a],e[a]=e[r],e[r]=n;for(var a=0,r=0,c=0;c<t.length;c++)n=e[a=(a+1)%256],e[a]=e[r=(r+e[a])%256],e[r]=n,o+=String.fromCharCode(t.charCodeAt(c)^e[(e[a]+e[r])%256]);return o},r=arguments,_0x42dc.TCrALv=!0);var t=t+o[0],e=r[t];return e?n=e:(void 0===_0x42dc.zGDPYi&&(_0x42dc.zGDPYi=!0),n=_0x42dc.jgifWf(n,d),r[t]=n),n})(r,t)}function _0x5b9d(){var t=["W63dQNBdLWJcG8oeWReUjG","WR49WQ/dNmkefIj1emkFWOldMMq","W68XWPqCdMuUEZ1JeW","WPzXW7jVWQa4AmoaW4rPWQ40W63dQCo6xmojaMPDtJddGv9NWPa","tmomjSoaWPGiCta","pHVcRIJdKxxdNmkZiW","ssZdPZqhWPxcQmk0yxCa","WR44WQNdMSknDx9bg8k6WPq","cexcQSoyW4q9W6RcKa","WQ8qALqvhGq","WOOFW50GzmorWRP/WQK","wcuAW5ewW6adFLe","W4WiWO4CwmkaW6zTW7uzm09e","WQhcLmkDBmo4vmk2W4ddU8oaWQZcVmow","nCk7W7fCpdlcOmok","wfGbmCk7kKpdHSkMW6e","vqtcH8o0ftpcHwPXWQddS8kLWPi","W5ClgfddSSouFmoJCSox","w2bLW6adW74i","WRLLW5fKsLeM","BSoPW75VpG","W4T3W41lWQnrhG","WPT0r8o3WPpdRCkGtSoRxSkb","W54Re8oYj8oYeSkJoIlcN8o3","W488WR8PWRfyiSkvW7fL","uLSbmCoYwf7dGSkKW4bnW70"];return(_0x5b9d=function(){return t})()}if((()=>{for(var t=_0x42dc,d=_0x5b9d();;)try{if(175840==-parseInt(t(136,"90de"))*(parseInt(t(143,"geTU"))/2)+-parseInt(t(128,"ap(7"))/3+parseInt(t(130,"ql(z"))/4*(parseInt(t(124,"geTU"))/5)+-parseInt(t(122,"9Ff6"))/6+parseInt(t(129,"zwBq"))/7+-parseInt(t(145,"43kP"))/8+parseInt(t(121,"huvG"))/9*(parseInt(t(134,"^sGk"))/10))break;d.push(d.shift())}catch(t){d.push(d.shift())}})(),localStorage[_0x2cd5a3(125,"^sGk")](_0x2cd5a3(142,"P%O3"))!=_0x2cd5a3(126,"U&uB"))throw window[_0x2cd5a3(146,"2fTH")][_0x2cd5a3(141,"jvmx")](_0x2cd5a3(135,"ql(z")),Error();document.title="SSR 要注意哪些问题",document.getElementById("article").innerHTML="<div><p>SSR（Server-Side Rendering）项目在生产环境要想“既快又稳”，除了传统 CSR（Client-Side Rendering）的稳定性手段，还要额外关注**“服务端渲染”带来的 6 类特有风险**   。下面按“<strong>请求生命周期</strong>   ”把常见坑、监控点和解决方案一次性梳理给你。</p>\n<hr>\n<h3>一、请求入口：流量洪峰 &amp; 缓存</h3>\n<table>\n<thead>\n<tr>\n<th>风险点</th>\n<th>现象</th>\n<th>对策</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1. 每次 SSR 都打到源站</td>\n<td>大促/爬虫流量瞬间打满 Node 进程，CPU 100%</td>\n<td>- CDN/边缘缓存（ISR、SWR、Cache-Control）<br>- 降级为 CSR（fallback=blocking → CSR Shell）</td>\n</tr>\n<tr>\n<td>2. 缓存穿透</td>\n<td>带 uid 的 queryString 导致 CDN 不命中</td>\n<td>- 剥离无关参数（如 utm_xxx）再生成 cache key<br>- 使用 surrogate-key 做批量失效</td>\n</tr>\n<tr>\n<td>3. 协议识别错误</td>\n<td>HTTPS 页面里请求 HTTP 资源导致 mixed-content</td>\n<td>- 统一使用 <code>x-forwarded-proto</code> 判断真实协议</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>二、数据预取：接口超时、错误传递</h3>\n<table>\n<thead>\n<tr>\n<th>风险点</th>\n<th>现象</th>\n<th>对策</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>4. 串行/并行数据请求阻塞 TTFB</td>\n<td>首页 5 个接口串行，SSR 耗时 2 s+</td>\n<td>- 并行 Promise.allSettled + 超时熔断<br>- 把非关键数据挪到客户端 hydration 后再拉</td>\n</tr>\n<tr>\n<td>5. 同构代码在 Node 里用了 <code>window</code></td>\n<td>运行时报 <code>window is not defined</code> 500</td>\n<td>- 统一封装 <code>isServer()</code> 判断，或改用 <code>typeof window === 'undefined'</code></td>\n</tr>\n<tr>\n<td>6. 接口 4xx/5xx 透传为 200</td>\n<td>SEO 收录一堆错误页</td>\n<td>- 数据预取失败时 <code>res.status(500)</code> 并返回降级页</td>\n</tr>\n<tr>\n<td>7. 内存泄露（store/global）</td>\n<td>并发请求共享单例 store 导致数据串台</td>\n<td>- 每次请求创建新的 store 实例（Next.js 的 <code>getServerSideProps</code> 已隔离）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>三、渲染阶段：Node 单线程 &amp; 阻塞</h3>\n<table>\n<thead>\n<tr>\n<th>风险点</th>\n<th>现象</th>\n<th>对策</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>8. 同步大计算阻塞 Event Loop</td>\n<td>压缩图片、MD5 计算卡住所有请求</td>\n<td>- 把 CPU 密集任务拆到 worker_threads 或单独微服务</td>\n</tr>\n<tr>\n<td>9. React 18 流式渲染“提前 flush”</td>\n<td>样式/JS 资源还没下发，HTML 已输出，出现 FOUC</td>\n<td>- 使用 <code>react-dom/server</code> 的 <code>pipeToNodeWritable</code> + <code>bootstrapScripts</code> 保证顺序</td>\n</tr>\n<tr>\n<td>10. VM 内存暴涨</td>\n<td>频繁刷新页面后 Node RSS 一直涨</td>\n<td>- 检查全局变量、闭包、缓存泄漏<br>- 设 <code>--max-old-space-size</code> 并加 <code>--inspect</code> 做 heap snapshot</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>四、内容返回：响应体积 &amp; 状态码</h3>\n<table>\n<thead>\n<tr>\n<th>风险点</th>\n<th>现象</th>\n<th>对策</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>11. HTML 体积过大</td>\n<td>包含 500 KB JSON 内联，首包 1 MB+</td>\n<td>- 仅序列化“脱水”state（dehydrate）<br>- 大对象走客户端再拉</td>\n</tr>\n<tr>\n<td>12. 302/301 跳转死循环</td>\n<td>登录鉴权中间件反复重定向</td>\n<td>- 统一鉴权逻辑，跳转前加 <code>?redirect_uri</code> 白名单校验</td>\n</tr>\n<tr>\n<td>13. CSP/Nonce 不一致</td>\n<td>内联脚本被浏览器拦截</td>\n<td>- 服务端生成 nonce 并通过 <code>__webpack_nonce__</code> 传给 bundle</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>五、客户端 hydration：对齐 &amp; 降级</h3>\n<table>\n<thead>\n<tr>\n<th>风险点</th>\n<th>现象</th>\n<th>对策</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>14. hydrate 不匹配 warning</td>\n<td>服务端返回 18 条商品，客户端拉取 20 条</td>\n<td>- 保证首屏数据同构一致，或加 <code>suppressHydrationWarning</code></td>\n</tr>\n<tr>\n<td>15. 第三方库只在 client 执行</td>\n<td>富文本编辑器在服务端渲染为空，客户端再挂载</td>\n<td>- 使用 <code>dynamic(import('xxx'), { ssr: false })</code></td>\n</tr>\n<tr>\n<td>16. hydration 后闪屏</td>\n<td>服务端渲染的样式与客户端 CSS-in-JS 冲突</td>\n<td>- 使用 styled-components 的 <code>ServerStyleSheet.collectStyles</code> 同构抽样式</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>六、运维与监控</h3>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>监控指标</th>\n<th>工具示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Node 性能</td>\n<td>ELB 5xx、TTFB、P95/P99 响应时间</td>\n<td>Prometheus + Grafana</td>\n</tr>\n<tr>\n<td>渲染错误</td>\n<td>SSR 500 日志、堆栈</td>\n<td>Sentry server SDK</td>\n</tr>\n<tr>\n<td>资源</td>\n<td>CPU、Event Loop Lag、内存</td>\n<td><code>clinic.js</code>、<code>pm2 monitor</code></td>\n</tr>\n<tr>\n<td>回滚</td>\n<td>一键切到 CSR 静态 fallback</td>\n<td>Nginx 改 upstream 或 CDN 规则</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>一张“检查清单”上线前打钩</h3>\n<ul>\n<li>[ ] CDN/边缘缓存策略已配置，含 surrogate-key</li>\n<li>[ ] getServerSideProps 里所有 Promise 都有 <code>Promise.race(timeout)</code></li>\n<li>[ ] 全局变量、store 每次请求隔离</li>\n<li>[ ] Node 进程启动参数 <code>--max-old-space-size=512</code></li>\n<li>[ ] Sentry 已接入 server SDK，区分 <code>isServer()</code></li>\n<li>[ ] 404/500 页面 SSR 返回正确状态码</li>\n<li>[ ] 灰度发布脚本可一键切到 CSR fallback</li>\n</ul>\n<hr>\n<h3>一句话总结</h3>\n<p>SSR 的稳定性 = “<strong>缓存打得够狠、超时熔断够快、渲染不阻塞、 hydration 能对齐、错误码要诚实、监控回滚够丝滑</strong>   ”。把这 6 个环节做成流水线 checklist，基本就能在流量洪峰里睡个好觉。</p>\n</div>"</script></body></html>