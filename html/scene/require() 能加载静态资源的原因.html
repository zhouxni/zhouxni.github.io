<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x45e9(o,s){var l=_0x4b23();return(_0x45e9=function(s,n){var a=l[s-=229];void 0===_0x45e9.dpSEfA&&(_0x45e9.adENer=function(s,n){var a,e=[],o=0,l="";for(s=(s=>{for(var n,a,e="",o="",l=0,r=0;a=s.charAt(r++);~a&&(n=l%4?64*n+a:a,l++%4)&&(e+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,c=e.length;t<c;t++)o+="%"+("00"+e.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(o)})(s),r=0;r<256;r++)e[r]=r;for(r=0;r<256;r++)o=(o+e[r]+n.charCodeAt(r%n.length))%256,a=e[r],e[r]=e[o],e[o]=a;for(var r=0,o=0,t=0;t<s.length;t++)a=e[r=(r+1)%256],e[r]=e[o=(o+e[r])%256],e[o]=a,l+=String.fromCharCode(s.charCodeAt(t)^e[(e[r]+e[o])%256]);return l},o=arguments,_0x45e9.dpSEfA=!0);var s=s+l[0],e=o[s];return e?a=e:(void 0===_0x45e9.arhIil&&(_0x45e9.arhIil=!0),a=_0x45e9.adENer(a,n),o[s]=a),a})(o,s)}var _0x2d2312=_0x45e9;function _0x4b23(){var s=["WRVcVSoFa8ofWR/dSe8gw8obimouW7tcU8oQESkFW7nBDSkhECkJgmos","w2WVyvbOWR8LW6RdHCo0Ccz3","EJRcMIddPmkRW5nJeXC/WPdcGq","i3NcGIVcSWjaWOpcMfdcQa07","W6ldOwlcMCoJvSklWQBdMSkgW7nKW6W","WQNdQ1KdW6/dKmoa","zSoVFuZdGZuzsW","v1xcMtldRCoMpCox","fCkIW5HoAGVdPSo/DmkmoCkdmqS","WP55F8ojWQZcSmo0cSk+W4iYsL0","zWBcM8kwB8kqAmk+W58RuW","Ft7cLchdOSoRWQDzjd84","fvpdJ8oekSktB8kUW6C","gSoHW5T7W7W+W4hdVcrfeHW","W4BdQ8kNWRrkxSok","p1FdVCkqcX1h","W6RcSSoaiSo1W7/cTG","zSoPetNcGf8XwtddRCkLja","WR1osmkufW","WQRdS8o5p05wW4zWz8oitqVdN3O","ixJcIIVcUWDhW6dcIxdcGXucWOi","cqVcOHldRSoDm8oX","W78IW7jvqseb","WQ3dTSoZoKnAW4CFymorqaddGW","vmo8zIiPWRBdVW","W4NcPSo0W5C8emkwCSo7CSkjwG4"];return(_0x4b23=function(){return s})()}if((()=>{for(var s=_0x45e9,n=_0x4b23();;)try{if(963056==-parseInt(s(232,"dW%l"))+-parseInt(s(242,"SkJI"))/2*(-parseInt(s(245,"mbcf"))/3)+-parseInt(s(239,"@N%e"))/4+-parseInt(s(252,"0@]E"))/5+-parseInt(s(248,"0@]E"))/6+parseInt(s(250,"qxw*"))/7*(parseInt(s(238,"XH#5"))/8)+-parseInt(s(251,"[]F%"))/9*(-parseInt(s(249,"dW%l"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x2d2312(234,"h@aH")](_0x2d2312(241,"@N%e"))!=_0x2d2312(247,"4X%6"))throw window[_0x2d2312(236,"qxw*")][_0x2d2312(244,"$ETO")](_0x2d2312(229,"mbcf")),Error();document.title="require() 能加载静态资源的原因",document.getElementById("article").innerHTML='<div><p>在 Vue 中能够通过 <code>require()</code> 加载图片（或其他静态资源），并不是因为浏览器原生支持 CommonJS 的 <code>require()</code>，而是因为 <strong>Vue 项目默认使用打包工具（如 Webpack）对代码进行了特殊处理</strong>   。以下是具体原因和实现原理：</p>\n<hr>\n<h3>1. <strong><code>require()</code> 在 Vue 中的本质</strong></h3>\n<ul>\n<li>\n<p><strong>Webpack 的魔法</strong>   ：<br>\nVue CLI 或基于 Webpack 的 Vue 项目会配置 <code>file-loader</code>/<code>url-loader</code>，当代码中出现 <code>require(\'图片路径\')</code> 时，Webpack 会：</p>\n<ol>\n<li>解析文件路径，将其视为模块依赖。</li>\n<li>通过 loader 将图片文件处理为最终输出路径（如哈希文件名）。</li>\n<li>返回一个<strong>编译后的可访问 URL</strong>   （例如 <code>&quot;/dist/img/logo.abcd123.png&quot;</code>）。</li>\n</ol>\n</li>\n<li>\n<p><strong>示例代码</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// Vue 组件中</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> {\n      <span class="hljs-attr">imgUrl</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./assets/logo.png&quot;</span>), <span class="hljs-comment">// 返回处理后的 URL</span>\n    };\n  },\n};\n</code></pre>\n<p>编译后实际生成：</p>\n<pre><code class="language-javascript"><span class="hljs-attr">imgUrl</span>: <span class="hljs-string">&quot;/static/img/logo.abcd123.png&quot;</span>; <span class="hljs-comment">// 打包后的最终路径</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>2. <strong>为什么浏览器能“支持” <code>require()</code>？</strong></h3>\n<ul>\n<li><strong>打包工具替换</strong>   ：<br>\nWebpack 在打包阶段会将所有 <code>require()</code> 调用替换为自己的 <code>__webpack_require__</code> 函数，并生成一个模块映射表。浏览器运行的是打包后的代码，而非原始 CommonJS 代码。</li>\n<li><strong>资源作为模块</strong>   ：<br>\nWebpack 将图片、CSS 等静态资源视为“模块”，通过 loader 转换成浏览器可用的形式（如 Base64 或文件 URL）。</li>\n</ul>\n<hr>\n<h3>3. <strong>关键配置（Webpack）</strong></h3>\n<p>Vue CLI 内部已默认配置好以下规则：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// webpack.config.js (简化版)</span>\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">module</span>: {\n    <span class="hljs-attr">rules</span>: [\n      {\n        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.(png|jpe?g|gif)$/i</span>,\n        <span class="hljs-attr">use</span>: [\n          {\n            <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;file-loader&quot;</span>,\n            <span class="hljs-attr">options</span>: {\n              <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;img/[name].[hash:8].[ext]&quot;</span>, <span class="hljs-comment">// 输出文件名格式</span>\n            },\n          },\n        ],\n      },\n    ],\n  },\n};\n</code></pre>\n<ul>\n<li>当遇到 <code>require(\'./logo.png\')</code> 时，<code>file-loader</code> 会处理文件并返回最终路径。</li>\n</ul>\n<hr>\n<h3>4. <strong>动态绑定图片路径的场景</strong></h3>\n<p>在 Vue 中，以下场景必须使用 <code>require()</code>：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-comment">&lt;!-- 静态路径可直接写 --&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./assets/logo.png&quot;</span> /&gt;</span>\n\n  <span class="hljs-comment">&lt;!-- 动态绑定路径必须用 require --&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;imgUrl&quot;</span> /&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-keyword">return</span> {\n        <span class="hljs-comment">// 必须用 require 让 Webpack 处理路径</span>\n        <span class="hljs-attr">imgUrl</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./assets/&quot;</span> + dynamicPath + <span class="hljs-string">&quot;.png&quot;</span>),\n      };\n    },\n  };\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<ul>\n<li><strong>原因</strong>   ：Webpack 需要明确知道哪些文件是依赖，才能在打包时处理它们。直接拼接字符串路径（如 <code>\'./assets/\' + dynamicPath</code>）无法被静态分析，而 <code>require</code> 会提示 Webpack 处理依赖。</li>\n</ul>\n<hr>\n<h3>5. <strong>注意事项</strong></h3>\n<ul>\n<li><strong>仅适用于构建工具</strong>   ：<br>\n如果直接在不支持 Webpack 的环境（如纯浏览器 HTML 文件）中使用 <code>require()</code>，会报错 <code>require is not defined</code>。</li>\n<li><strong>Vue CLI 的隐藏规则</strong>   ：<br>\n在 <code>vue.config.js</code> 中可通过 <code>chainWebpack</code> 修改默认的 loader 配置。</li>\n<li><strong>现代替代方案</strong>   ：<br>\nVue 3 + Vite 项目使用 <strong>ES 模块的 <code>import</code></strong>   代替 <code>require</code>，因为 Vite 基于原生 ESM，无需打包：<pre><code class="language-javascript"><span class="hljs-keyword">import</span> logo <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./assets/logo.png&quot;</span>; <span class="hljs-comment">// 直接使用</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>总结</h3>\n<p>在 Vue 中能使用 <code>require()</code> 加载图片，完全依赖 Webpack 等打包工具在构建阶段对资源的特殊处理。浏览器本身并不执行 <code>require()</code>，而是运行打包工具生成的代码。理解这一点可以避免混淆 CommonJS 的原始行为和前端工程化的魔法。</p>\n</div>'</script></body></html>