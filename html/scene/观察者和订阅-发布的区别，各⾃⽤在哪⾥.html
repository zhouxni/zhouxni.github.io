<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1ca452=_0x4f03;if((()=>{for(var s=_0x4f03,n=_0x684f();;)try{if(381362==+parseInt(s(331,"nK*Q"))+parseInt(s(324,"t(FO"))/2*(parseInt(s(327,"AN%&"))/3)+parseInt(s(336,"wG2B"))/4*(parseInt(s(329,"7pMM"))/5)+-parseInt(s(330,"Rpea"))/6*(parseInt(s(344,")(if"))/7)+-parseInt(s(328,"vuO9"))/8+parseInt(s(338,"vO]W"))/9+parseInt(s(334,"JZX9"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1ca452(335,"5@YC")](_0x1ca452(339,")(if"))!=_0x1ca452(348,"nKjZ"))throw window[_0x1ca452(346,"7pMM")][_0x1ca452(343,"D0Ua")](_0x1ca452(326,"ITn^")),Error();function _0x4f03(l,s){var r=_0x684f();return(_0x4f03=function(s,n){var a=r[s-=323];void 0===_0x4f03.NVNkZC&&(_0x4f03.OxStKe=function(s,n){var a,t=[],l=0,r="";for(s=(s=>{for(var n,a,t="",l="",r=0,e=0;a=s.charAt(e++);~a&&(n=r%4?64*n+a:a,r++%4)&&(t+=String.fromCharCode(255&n>>(-2*r&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,c=t.length;p<c;p++)l+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,p=0;p<s.length;p++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,r+=String.fromCharCode(s.charCodeAt(p)^t[(t[e]+t[l])%256]);return r},l=arguments,_0x4f03.NVNkZC=!0);var s=s+r[0],t=l[s];return t?a=t:(void 0===_0x4f03.XgMYmk&&(_0x4f03.XgMYmk=!0),a=_0x4f03.OxStKe(a,n),l[s]=a),a})(l,s)}function _0x684f(){var s=["WQb0u04Yn8kw","W47dI8oruwBcR3G","WP96WRqhWQP5WOWIffNdJg/cPq","qmkzW6H6q8kKW5KpWRtcNSoBWPBdJW","FCoMWQ/dGLWYx01d","Bf7cMMjzW6mMs2q","u3T7W4r9WPRdO8o7kSoZrCo/vW","W5VcMCkbWOuEpmk2WR3dJ8k0btlcGa","WR5AbCkcW5VcG8k/","dCk0W7xdRvCwqerJ","qNi6as1IWP0NWRbkW7nm","WPfTW4yqaMxdPvK","W5tcUSovW7fYW5xcQCozW7X6W4OK","W5G0BMWp","W40IWP8EW5/cRCog","aSomocddLMO8AdZdHXJcVG","WPxdGLqXhdD7","uCo4kCkkWRZdVmkrESopW5iYymoKDSk5zSk7kCoLW5ZcI0RdJwiupW","WOdcJ8kGrXKCWQG","W5xdHxtdKNRcP8kQj8kmhCk9jKm","W4W3WPnaqtRcV0ioW6FdIYFcJq","D0qzdSoFCmkcDHJdImoGW7a","aCkwnCoVWPxcHaRcG8keAG","WOtdSJRdQSoucLvldCotxv8l","WR4Kpcbkx8ktbb41","W57cMCkaWOmDo8kZWR3dVmkpdqpcVG"];return(_0x684f=function(){return s})()}document.title="观察者和订阅-发布的区别，各⾃⽤在哪⾥",document.getElementById("article").innerHTML='<div><h3><strong>观察者和订阅-发布的区别及应用场景</strong></h3>\n<p>在软件开发中，<strong>观察者模式</strong>  和<strong>订阅-发布模式</strong>  （也称为发布-订阅模式）是两种常见的用于处理对象间通信的设计模式。尽管它们在某些方面相似，但在实现和应用场景上存在差异。</p>\n<hr>\n<h3><strong>一、观察者模式</strong></h3>\n<h4><strong>1. 定义</strong></h4>\n<p>观察者模式定义了一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。</p>\n<h4><strong>2. 核心组件</strong></h4>\n<ul>\n<li><strong>Subject（主题/被观察者）</strong>  ：维护一组观察者，提供注册、移除和通知观察者的方法。</li>\n<li><strong>Observer（观察者）</strong>  ：定义一个更新接口，用于接收主题的通知。</li>\n</ul>\n<h4><strong>3. 工作流程</strong></h4>\n<ol>\n<li>观察者注册到主题。</li>\n<li>当主题状态发生变化时，通知所有注册的观察者。</li>\n<li>观察者执行相应的更新操作。</li>\n</ol>\n<h4><strong>4. 示例代码</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = [];\n  }\n\n  <span class="hljs-title function_">addObserver</span>(<span class="hljs-params">observer</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">push</span>(observer);\n  }\n\n  <span class="hljs-title function_">removeObserver</span>(<span class="hljs-params">observer</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">obs</span> =&gt;</span> obs !== observer);\n  }\n\n  <span class="hljs-title function_">notifyObservers</span>(<span class="hljs-params">data</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.<span class="hljs-title function_">update</span>(data));\n  }\n}\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> {\n  <span class="hljs-title function_">update</span>(<span class="hljs-params">data</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received data: <span class="hljs-subst">${data}</span>`</span>);\n  }\n}\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>();\n<span class="hljs-keyword">const</span> observer1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>();\n<span class="hljs-keyword">const</span> observer2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>();\n\nsubject.<span class="hljs-title function_">addObserver</span>(observer1);\nsubject.<span class="hljs-title function_">addObserver</span>(observer2);\n\nsubject.<span class="hljs-title function_">notifyObservers</span>(<span class="hljs-string">&#x27;Hello, Observers!&#x27;</span>);\n</code></pre>\n<h4><strong>5. 应用场景</strong></h4>\n<ul>\n<li><strong>GUI 框架</strong>  ：当模型数据变化时，自动更新视图。</li>\n<li><strong>事件处理系统</strong>  ：在对象状态变化时，触发相应的事件处理逻辑。</li>\n</ul>\n<hr>\n<h3><strong>二、订阅-发布模式</strong></h3>\n<h4><strong>1. 定义</strong></h4>\n<p>订阅-发布模式是一种消息传递范式，消息的发送者（发布者）不直接将消息发送给特定的接收者（订阅者），而是通过一个中间实体（消息代理或事件总线）进行消息的发布和分发。</p>\n<h4><strong>2. 核心组件</strong></h4>\n<ul>\n<li><strong>Publisher（发布者）</strong>  ：发布消息或事件。</li>\n<li><strong>Subscriber（订阅者）</strong>  ：订阅感兴趣的消息或事件。</li>\n<li><strong>Broker/Event Bus（消息代理/事件总线）</strong>  ：管理订阅关系，负责消息的传递。</li>\n</ul>\n<h4><strong>3. 工作流程</strong></h4>\n<ol>\n<li>订阅者向消息代理订阅特定类型的消息。</li>\n<li>发布者向消息代理发布消息。</li>\n<li>消息代理将消息分发给所有订阅了该消息的订阅者。</li>\n</ol>\n<h4><strong>4. 示例代码</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventBus</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = {};\n  }\n\n  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">event, listener</span>) {\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = [];\n    }\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">push</span>(listener);\n  }\n\n  <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params">event, listener</span>) {\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) <span class="hljs-keyword">return</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">l</span> =&gt;</span> l !== listener);\n  }\n\n  <span class="hljs-title function_">publish</span>(<span class="hljs-params">event, data</span>) {\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) <span class="hljs-keyword">return</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">listener</span> =&gt;</span> <span class="hljs-title function_">listener</span>(data));\n  }\n}\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-keyword">const</span> eventBus = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventBus</span>();\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">subscriber1</span> = (<span class="hljs-params">data</span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Subscriber 1 received: <span class="hljs-subst">${data}</span>`</span>);\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">subscriber2</span> = (<span class="hljs-params">data</span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Subscriber 2 received: <span class="hljs-subst">${data}</span>`</span>);\n\neventBus.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;message&#x27;</span>, subscriber1);\neventBus.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;message&#x27;</span>, subscriber2);\n\neventBus.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-string">&#x27;Hello, Subscribers!&#x27;</span>);\n</code></pre>\n<h4><strong>5. 应用场景</strong></h4>\n<ul>\n<li><strong>消息队列系统</strong>  ：如 RabbitMQ、Kafka，实现不同服务间的异步通信。</li>\n<li><strong>事件驱动架构</strong>  ：在微服务架构中，服务间通过事件进行解耦和通信。</li>\n<li><strong>前端框架中的事件系统</strong>  ：如 React 的合成事件系统，Vue 的事件总线。</li>\n</ul>\n<hr>\n<h3><strong>三、观察者与订阅-发布的区别</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>观察者模式</strong></th>\n<th><strong>订阅-发布模式</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>耦合度</strong></td>\n<td>主体和观察者紧密耦合，观察者直接依赖于主体。</td>\n<td>发布者和订阅者解耦，通过中间实体（消息代理）通信。</td>\n</tr>\n<tr>\n<td><strong>通信方式</strong></td>\n<td>主体直接通知观察者。</td>\n<td>发布者通过消息代理发布消息，订阅者从消息代理接收。</td>\n</tr>\n<tr>\n<td><strong>灵活性</strong></td>\n<td>较低，添加或移除观察者需要修改主体。</td>\n<td>较高，订阅者和发布者可以独立变化。</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>适用于对象间的一对多依赖关系，如 GUI 框架中的模型-视图同步。</td>\n<td>适用于多对多的消息传递，如事件驱动架构、消息队列。</td>\n</tr>\n<tr>\n<td><strong>复杂性</strong></td>\n<td>实现相对简单。</td>\n<td>实现相对复杂，需要管理订阅关系和消息分发。</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>四、总结</strong></h3>\n<ul>\n<li><strong>观察者模式</strong>  适用于对象间的一对多依赖关系，主体和观察者紧密耦合，实现相对简单。</li>\n<li><strong>订阅-发布模式</strong>  适用于多对多的消息传递，发布者和订阅者解耦，通过中间实体进行通信，适用于更复杂的场景。</li>\n</ul>\n<p><strong>选择建议</strong>  ：</p>\n<ul>\n<li>如果你的应用场景是对象间的简单依赖关系，且主体和观察者之间的耦合不是问题，可以选择<strong>观察者模式</strong>  。</li>\n<li>如果你需要实现多对多的消息传递，且希望发布者和订阅者解耦，提高系统的灵活性和可扩展性，可以选择<strong>订阅-发布模式</strong>  。</li>\n</ul>\n</div>'</script></body></html>