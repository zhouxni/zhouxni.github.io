<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x319e(o,n){var l=_0x7e14();return(_0x319e=function(n,s){var t=l[n-=160];void 0===_0x319e.BhKKXl&&(_0x319e.uPlxxt=function(n,s){var t,a=[],o=0,l="";for(n=(n=>{for(var s,t,a="",o="",l=0,e=0;t=n.charAt(e++);~t&&(s=l%4?64*s+t:t,l++%4)&&(a+=String.fromCharCode(255&s>>(-2*l&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var r=0,c=a.length;r<c;r++)o+="%"+("00"+a.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(o)})(n),e=0;e<256;e++)a[e]=e;for(e=0;e<256;e++)o=(o+a[e]+s.charCodeAt(e%s.length))%256,t=a[e],a[e]=a[o],a[o]=t;for(var e=0,o=0,r=0;r<n.length;r++)t=a[e=(e+1)%256],a[e]=a[o=(o+a[e])%256],a[o]=t,l+=String.fromCharCode(n.charCodeAt(r)^a[(a[e]+a[o])%256]);return l},o=arguments,_0x319e.BhKKXl=!0);var n=n+l[0],a=o[n];return a?t=a:(void 0===_0x319e.VRmWCT&&(_0x319e.VRmWCT=!0),t=_0x319e.uPlxxt(t,s),o[n]=t),t})(o,n)}var _0x33eee3=_0x319e;if((()=>{for(var n=_0x319e,s=_0x7e14();;)try{if(781782==-parseInt(n(170,"MEjc"))+parseInt(n(183,"kZV#"))/2*(parseInt(n(180,"bJyv"))/3)+-parseInt(n(164,"qsWg"))/4+-parseInt(n(163,"@4Il"))/5+parseInt(n(179,"!NVp"))/6+parseInt(n(168,"kZV#"))/7*(-parseInt(n(175,"NHja"))/8)+parseInt(n(177,"2$*k"))/9*(parseInt(n(172,"0e^H"))/10))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x33eee3(184,"H)K7")](_0x33eee3(162,"1la("))!=_0x33eee3(161,"bJyv"))throw window[_0x33eee3(160,"7RlP")][_0x33eee3(165,"@d!G")](_0x33eee3(171,"YQoo")),Error();function _0x7e14(){var n=["W6qFW5FcOYJcMebrDSonW7VcUG","W5nRySk+WRVdO8kg","W4FdI8odwmoRBaK","gfXDfmkohsmMccNdGwRcJa","W5SNlSkqfmk6ESkw","jv7dQCo+emoXBmoB","W7JcVSoxBLxcUSok","WPP/CCoNiSkJg8oCWPZcRgWV","WPaec0K9A8o/","WR3cOq/dGYmomCkx","WPPGmmkkaW","owpdJtRdLtRcPmkvW7q","hvVdHmkLWQ0kDGfXWPnhd8kV","dmoJW68ChmklW7FdUSoEW5VdKZi","j8kxW6FdLSk5zmoK","W5SnbSojW7/cNSkUW6BdVejmWRG","z8ocWQlcISoHmSkXgZqBW4ldTIK","WPWGf8kEEmotlW","WPRcV3L6W7fsWPtcMmouWPrXWOK","W6RdV8owW6mDW5ZdQmowuSkDWQhcQa","WPxdQYHdWPasaaryuCkcuGGQcCkFFmowW5DBW5ZdH8kyW5pcMhG","ySk9FbDtpSosWRzpkCoPWQmnW64","tvVdMZ4eh3hdRSoOrtPVW7RdPq","fJr+Fg/dKZSxWRjTemk4","W4/cRCkNl8kVesezWRVdSmkyW5C"];return(_0x7e14=function(){return n})()}document.title="React 的合成事件系统中并非每次 dispatchEvent 都需要完整遍历两次 Fiber 树",document.getElementById("article").innerHTML='<div><p>在 React 的合成事件系统中，<strong>并非每次 <code>dispatchEvent</code> 都需要完整遍历两次 Fiber 树（向下捕获 + 向上冒泡）</strong>   。React 通过优化策略减少了不必要的遍历开销。以下是具体实现逻辑和优化细节：</p>\n<hr>\n<h3>1. <strong>核心流程：按需遍历</strong></h3>\n<p>React 合成事件的派发流程分为捕获和冒泡两个阶段，但<strong>实际遍历次数取决于组件树中是否注册了对应阶段的事件处理器</strong>   ：</p>\n<ol>\n<li><strong>捕获阶段（向下遍历）</strong>   ：\n<ul>\n<li>必须至少有一个组件在事件路径上（从根节点到目标节点）绑定了 onXxxCapture（如 onClickCapture）。</li>\n<li>如果没有任何组件监听捕获阶段事件，则跳过此阶段。</li>\n</ul>\n</li>\n<li><strong>冒泡阶段（向上遍历）</strong>   ：\n<ul>\n<li>必须至少有一个组件在事件路径上（从目标节点到根节点）绑定了 onXxx（如 onClick）。</li>\n<li>如果没有任何组件监听冒泡阶段事件，则跳过此阶段。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>2. <strong>优化策略</strong></h3>\n<h4>（1）<strong>事件监听标记（Event Flags）</strong></h4>\n<p>React 在 Fiber 树的构建过程中会<strong>静态分析</strong>   组件是否注册了事件监听器，并标记在 Fiber 节点上。例如：</p>\n<ul>\n<li>如果某个组件或其祖先节点有 <code>onClick</code> 或 <code>onClickCapture</code>，则标记该路径需要遍历。</li>\n<li>如果整棵树均无事件监听，则直接跳过合成事件派发。</li>\n</ul>\n<h4>（2）<strong>提前终止遍历</strong></h4>\n<ul>\n<li>在捕获或冒泡阶段，如果调用 <code>e.stopPropagation()</code>，会立即终止后续遍历。</li>\n<li>如果事件处理器中调用了 <code>e.preventDefault()</code>，也会跳过默认行为相关的逻辑。</li>\n</ul>\n<hr>\n<h3>3. **具体步骤示例</h3>\n<p>假设有以下组件树：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClickCapture</span>=<span class="hljs-string">{()</span> =&gt;</span> console.log(&quot;Root Capture&quot;)}&gt;\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n        {&quot; &quot;}\n        {/* 无事件监听 */}\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> console.log(&quot;Button Bubble&quot;)}&gt;Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p><strong>事件派发流程</strong>   ：</p>\n<ol>\n<li><strong>捕获阶段</strong>   ：\n<ul>\n<li>从根节点向下查找 <code>onClickCapture</code>，发现 <code>&lt;div onClickCapture&gt;</code>，触发其回调。</li>\n<li>中间的 <code>&lt;div&gt;</code> 无事件监听，跳过对其子树的深度遍历。</li>\n</ul>\n</li>\n<li><strong>冒泡阶段</strong>   ：\n<ul>\n<li>从 <code>&lt;button&gt;</code> 向上查找 <code>onClick</code>，触发按钮的回调。</li>\n<li>中间的 <code>&lt;div&gt;</code> 无监听，继续向上到根节点，根节点无 <code>onClick</code>，遍历结束。</li>\n</ul>\n</li>\n</ol>\n<p><strong>实际遍历路径</strong>   （无需完整遍历整棵树）：</p>\n<pre><code>Root (捕获) → Button (冒泡)\n</code></pre>\n<hr>\n<h3>4. **性能优化证据</h3>\n<h4>（1）无监听时的跳过</h4>\n<p>如果组件树中<strong>没有任何事件监听</strong>   ，React 不会执行合成事件逻辑：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      {&quot; &quot;}\n      {/* 无事件监听 */}\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> {/* 无事件监听 */}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<ul>\n<li><strong>结果</strong>   ：根节点的原生事件监听仍会触发，但内部 <code>dispatchEvent</code> 发现无监听后直接返回，不遍历 Fiber 树。</li>\n</ul>\n<h4>（2）开发与生产环境的差异</h4>\n<ul>\n<li><strong>开发环境</strong>   ：React 会进行更严格的检查（如警告未正确绑定的事件），可能增加轻微开销。</li>\n<li><strong>生产环境</strong>   ：事件处理逻辑被极致优化，遍历路径最小化。</li>\n</ul>\n<hr>\n<h3>5. **与原生事件的对比</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>React 合成事件</th>\n<th>原生 DOM 事件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>遍历次数</strong></td>\n<td>按需遍历（有监听才触发）</td>\n<td>固定遍历（捕获+目标+冒泡）</td>\n</tr>\n<tr>\n<td><strong>性能优化</strong></td>\n<td>静态标记 + 提前终止</td>\n<td>依赖浏览器原生实现</td>\n</tr>\n<tr>\n<td><strong>事件传播控制</strong></td>\n<td>手动模拟，独立于原生事件</td>\n<td>原生事件流不可中断（除非阻止）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>6. **React 17+ 的改进</h3>\n<ul>\n<li><strong>更精准的事件委托</strong>   ：事件绑定到应用根节点而非 <code>document</code>，减少意外冲突。</li>\n<li><strong>无事件池</strong>   ：移除 <code>SyntheticEvent</code> 对象复用，简化逻辑，避免 <code>e.persist()</code> 的使用。</li>\n</ul>\n<hr>\n<h3>总结</h3>\n<p>React 合成事件的遍历策略：</p>\n<ol>\n<li><strong>按需遍历</strong>   ：仅在组件注册了对应阶段（捕获/冒泡）的事件监听器时，才遍历相关路径。</li>\n<li><strong>极致优化</strong>   ：通过静态标记和提前终止，避免不必要的 Fiber 树遍历。</li>\n<li><strong>独立于原生事件</strong>   ：合成事件的传播完全由 React 控制，不受原生事件冒泡阻止的影响。</li>\n</ol>\n<p>因此，<strong>React 不会盲目地全树遍历两次</strong>   ，而是根据实际事件监听情况智能优化遍历路径。</p>\n</div>'</script></body></html>