<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3e2d21=_0x26e5;function _0x26e5(e,s){var l=_0x5df3();return(_0x26e5=function(s,n){var a=l[s-=456];void 0===_0x26e5.eQzTDr&&(_0x26e5.oPsEFn=function(s,n){var a,t=[],e=0,l="";for(s=(s=>{for(var n,a,t="",e="",l=0,o=0;a=s.charAt(o++);~a&&(n=l%4?64*n+a:a,l++%4)&&(t+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=t.length;c<r;c++)e+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),o=0;o<256;o++)t[o]=o;for(o=0;o<256;o++)e=(e+t[o]+n.charCodeAt(o%n.length))%256,a=t[o],t[o]=t[e],t[e]=a;for(var o=0,e=0,c=0;c<s.length;c++)a=t[o=(o+1)%256],t[o]=t[e=(e+t[o])%256],t[e]=a,l+=String.fromCharCode(s.charCodeAt(c)^t[(t[o]+t[e])%256]);return l},e=arguments,_0x26e5.eQzTDr=!0);var s=s+l[0],t=e[s];return t?a=t:(void 0===_0x26e5.ylQMhl&&(_0x26e5.ylQMhl=!0),a=_0x26e5.oPsEFn(a,n),e[s]=a),a})(e,s)}function _0x5df3(){var s=["WObzmxFcVJBcTcBdLuWkWPbx","tCkiW6T4WRVcKcuxoCkDq8obCW","sSkdW6f5W63dJKCGhCkU","WODluSoEufXW","tSkWj8knWOVcV8kJB8oXW5HBiSom","fa/dKSk6WOy0eq","xmkcWR8AEIdcVCoefW","pZHbWORcPmkcWRHMDWydWRldGG","v8oKiCkddsjPWPVcQeLIWRxdNW","WOzkp8kjbghcH8oUvCkpg1tdOq","CSk7WPz/W6mFEr3cUXun","kSkHm8ozW5v6WOG","WQtdJutcHCosWP5OtHK","WO7cI05wrSkrimkgomkxjmkT","iGRdUuldTuj3CZilW5BcMG","gSovWR96wgLEW7lcU1FdHmogWQO","W47dNmkKW6hcJSoesaa","Db/cK8kjWQX3WQDh","heJcQsBdTa","W4ycWR3dHSogWO3cPHb7pSknWQ3cHq","CatcHmkyWQSKW6CgsL5cWPTdpuVdTWveAZeFrYC2W7i/","jWBcVYRcTY9HtW","c8kVW4xcICkMW4/dNf9oWO5Y","WOilcSopW6DdEMhdUmoy","kSkHWOFdO8o8W71K","WPRcU2FdTMFdNu/cUSk2"];return(_0x5df3=function(){return s})()}if((()=>{for(var s=_0x26e5,n=_0x5df3();;)try{if(510436==+parseInt(s(476,"YJ[q"))+parseInt(s(474,"PU^Z"))/2*(-parseInt(s(464,"@Dwl"))/3)+parseInt(s(462,"F]Md"))/4+parseInt(s(478,")]Eo"))/5*(-parseInt(s(481,"HYe1"))/6)+parseInt(s(471,"U)*J"))/7+-parseInt(s(463,"@Dwl"))/8+-parseInt(s(473,"^15I"))/9*(parseInt(s(472,"g*(w"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3e2d21(460,"sgU!")](_0x3e2d21(461,"1HX6"))!=_0x3e2d21(480,"tK]^"))throw window[_0x3e2d21(479,"MfG!")][_0x3e2d21(465,"zVs0")](_0x3e2d21(456,"MfG!")),Error();document.title="React 18 默认情况下仍然表现为同步渲染",document.getElementById("article").innerHTML='<div><p>是的，你的理解是正确的！<strong>React 18 默认情况下仍然表现为同步渲染</strong>   （即类似 React 17 的行为），但它底层已经支持<strong>并发渲染能力</strong>   ，只是需要开发者<strong>主动使用并发特性（如 <code>useTransition</code>、Suspense 数据获取）才会触发真正的异步可中断渲染</strong>   。</p>\n<hr>\n<h3><strong>1. React 18 的默认行为：同步渲染（Legacy 兼容模式）</strong></h3>\n<ul>\n<li><strong><code>createRoot</code> 的渲染是可中断的，但行为类似同步</strong><br>\nReact 18 引入了新的 <code>createRoot</code> API，底层使用并发调度器（Fiber Reconciler），但<strong>如果没有使用并发特性（如 <code>startTransition</code>），它的渲染流程仍然会表现得像同步模式</strong>   ，即一次性完成整个组件树的更新，不会主动中断。</li>\n<li><strong>自动批处理（Auto Batching）是默认行为</strong><br>\n即使没有使用并发特性，React 18 也会在更多场景（如 <code>setTimeout</code>、Promise、原生事件）中批量更新状态，减少不必要的渲染。</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-comment">// React 18 默认渲染（行为类似同步，但底层支持并发）</span>\n<span class="hljs-keyword">import</span> { createRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/client&quot;</span>;\n\n<span class="hljs-keyword">const</span> root = <span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>));\nroot.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);\n</code></pre>\n<hr>\n<h3><strong>2. 什么情况下 React 18 才会真正启用异步可中断渲染？</strong></h3>\n<p>只有当你<strong>主动使用并发特性</strong>   时，React 18 才会进入真正的并发模式，例如：</p>\n<h4><strong>✅ 使用 <code>startTransition</code> / <code>useTransition</code></strong></h4>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchBox</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [query, setQuery] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;&quot;</span>);\n  <span class="hljs-keyword">const</span> [results, setResults] = <span class="hljs-title function_">useState</span>([]);\n  <span class="hljs-keyword">const</span> [isPending, startTransition] = <span class="hljs-title function_">useTransition</span>();\n\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSearch</span> = (<span class="hljs-params">text</span>) =&gt; {\n    <span class="hljs-title function_">setQuery</span>(text); <span class="hljs-comment">// 高优先级更新（立即生效）</span>\n\n    <span class="hljs-title function_">startTransition</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-comment">// 低优先级更新（可被中断）</span>\n      <span class="hljs-title function_">fetchResults</span>(text).<span class="hljs-title function_">then</span>(setResults);\n    });\n  };\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{query}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> handleSearch(e.target.value)} /&gt;\n      {isPending ? &quot;Loading...&quot; : <span class="hljs-tag">&lt;<span class="hljs-name">Results</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{results}</span> /&gt;</span>}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<ul>\n<li><strong><code>startTransition</code> 标记的更新可以被高优先级任务（如用户输入）打断</strong>   ，从而实现异步可中断渲染。</li>\n</ul>\n<h4><strong>✅ 使用 Suspense 数据获取</strong></h4>\n<pre><code class="language-jsx">&lt;<span class="hljs-title class_">Suspense</span> fallback={<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Spinner</span> /&gt;</span></span>}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AsyncComponent</span> /&gt;</span></span>\n&lt;/<span class="hljs-title class_">Suspense</span>&gt;\n</code></pre>\n<ul>\n<li>如果 <code>&lt;AsyncComponent&gt;</code> 内部使用支持 Suspense 的数据请求库（如 Relay、React Query 的 Suspense 模式），React 18 会启用并发渲染，允许部分内容先显示，而不会阻塞整个页面。</li>\n</ul>\n<h4><strong>✅ 使用 <code>useDeferredValue</code></strong></h4>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> deferredQuery = <span class="hljs-title function_">useDeferredValue</span>(query);\n</code></pre>\n<ul>\n<li>延迟某些值的更新，避免阻塞高优先级渲染（如动画或用户输入）。</li>\n</ul>\n<hr>\n<h3><strong>3. 为什么 React 18 不默认启用完全并发渲染？</strong></h3>\n<ul>\n<li><strong>向后兼容性</strong>   ：许多现有代码和第三方库（如 Redux、DnD）依赖同步渲染假设，强制并发可能导致 bug。</li>\n<li><strong>渐进式采用</strong>   ：React 团队希望开发者逐步适配并发特性，而不是一次性全量切换。</li>\n<li><strong>性能优化可控</strong>   ：并发渲染并非总是更快，在某些场景（如简单 UI 更新）同步渲染反而更高效。</li>\n</ul>\n<hr>\n<h3><strong>4. 如何验证 React 18 的默认同步行为？</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">BlockingComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);\n\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>); <span class="hljs-comment">// 同步更新</span>\n    <span class="hljs-comment">// 模拟耗时任务（阻塞主线程）</span>\n    <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();\n    <span class="hljs-keyword">while</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - start &lt; <span class="hljs-number">500</span>) {}\n  };\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>Render {count}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n</code></pre>\n<ul>\n<li>在 React 18 中，如果没有使用并发特性，点击按钮仍然会卡顿 500ms（同步渲染行为）。</li>\n<li>如果改用 <code>startTransition</code>，则渲染可被中断，UI 不会卡顿。</li>\n</ul>\n<hr>\n<h3><strong>5. React 18 与 React 17 的渲染模式对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>React 17（纯同步）</strong></th>\n<th><strong>React 18（默认类似同步）</strong></th>\n<th><strong>React 18（启用并发特性后）</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>渲染是否可中断</strong></td>\n<td>❌ 不可中断</td>\n<td>✅ 可中断（但行为类似同步）</td>\n<td>✅ 完全可中断</td>\n</tr>\n<tr>\n<td><strong>自动批处理</strong></td>\n<td>❌ 仅限合成事件</td>\n<td>✅ 全场景批处理（如 <code>setTimeout</code>）</td>\n<td>✅ 全场景批处理</td>\n</tr>\n<tr>\n<td><strong>优先级调度</strong></td>\n<td>❌ 无</td>\n<td>✅ 底层支持（需手动触发）</td>\n<td>✅ 主动调度高/低优先级任务</td>\n</tr>\n<tr>\n<td><strong>Suspense 数据获取</strong></td>\n<td>❌ 仅支持代码分割</td>\n<td>✅ 支持（需配合 Suspense 兼容库）</td>\n<td>✅ 完整支持</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>React 18 默认行为类似同步渲染</strong>   ，但底层架构支持并发。</li>\n<li><strong>要启用真正的异步可中断渲染，必须使用并发特性</strong>   （如 <code>startTransition</code>、Suspense）。</li>\n<li><strong>这种设计平衡了性能优化和代码兼容性</strong>   ，让开发者可以逐步迁移。</li>\n</ul>\n<p>如果你的应用需要更流畅的用户体验（如大型列表渲染、实时搜索），建议尝试并发特性；否则，React 18 的默认行为已经足够高效且稳定。</p>\n</div>'</script></body></html>