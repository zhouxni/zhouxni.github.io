<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x7c2914=_0x448a;function _0x448a(r,n){var e=_0x46d1();return(_0x448a=function(n,s){var a=e[n-=338];void 0===_0x448a.vAHdps&&(_0x448a.vVpJIH=function(n,s){var a,t=[],r=0,e="";for(n=(n=>{for(var s,a,t="",r="",e=0,o=0;a=n.charAt(o++);~a&&(s=e%4?64*s+a:a,e++%4)&&(t+=String.fromCharCode(255&s>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var l=0,p=t.length;l<p;l++)r+="%"+("00"+t.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(r)})(n),o=0;o<256;o++)t[o]=o;for(o=0;o<256;o++)r=(r+t[o]+s.charCodeAt(o%s.length))%256,a=t[o],t[o]=t[r],t[r]=a;for(var o=0,r=0,l=0;l<n.length;l++)a=t[o=(o+1)%256],t[o]=t[r=(r+t[o])%256],t[r]=a,e+=String.fromCharCode(n.charCodeAt(l)^t[(t[o]+t[r])%256]);return e},r=arguments,_0x448a.vAHdps=!0);var n=n+e[0],t=r[n];return t?a=t:(void 0===_0x448a.gjlJWu&&(_0x448a.gjlJWu=!0),a=_0x448a.vVpJIH(a,s),r[n]=a),a})(r,n)}if((()=>{for(var n=_0x448a,s=_0x46d1();;)try{if(104516==-parseInt(n(359,"P5)6"))+-parseInt(n(362,"nwSg"))/2*(parseInt(n(355,"l&Hl"))/3)+-parseInt(n(350,"W@1]"))/4+parseInt(n(357,"jsi!"))/5*(parseInt(n(348,"p4gT"))/6)+-parseInt(n(352,"Yk)I"))/7*(parseInt(n(340,"qmXy"))/8)+parseInt(n(344,"[sIa"))/9+-parseInt(n(356,"8R^0"))/10*(-parseInt(n(353,"BwDu"))/11))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x7c2914(351,"P5)6")](_0x7c2914(347,"[sIa"))!=_0x7c2914(341,"!zup"))throw window[_0x7c2914(365,"O#oL")][_0x7c2914(343,"ZCVj")](_0x7c2914(354,"]L*a")),Error();function _0x46d1(){var n=["WPTpW7XrW6aKuLJcJMnKW7i","W5NdMc/dRfO9W4VcNrXIq8o/","W6Stnmo6WRdcMcddTfm","W4WYWQ3dLCobvSkcWRG","FSoEWRLLW4pcT8oCWR3dHWTzWPS","kZueFwVdNmoJzCoyW5rQW5i","c8o3v8ktxrbW","mqDWW6myW7exrqFdNHmg","WQ02aSklrWRcQg4tWQZcRcrB","FCo/WRqLoxzEW4BdOWtdLumvWRZdOsZdNu7cIxfCWPNdKte2W6u","WOBcSSkntslcGSo1","WPhdK8kImmoGWO1kW7C","W6PMW6hcTXzICCoAWPnis8ko","WPHjW75qW6aHpuRcI399W7/dSa","xCkRf8oQgeD5WQK0kCkLW4K","WQNcLITFBmk9W5n/","WQZcLaL1rSk7W7jA","vJHhaCoxWO7cRCkUW75rvNO","iCopkhNdO8k+W4y","WPtdLCk9iSoPWRvlW6e","F1BdSCkyBCkTWRfY","Fmk4qfZcJrbEfSkFE8kTW5C","v0zmWQStWR5iWQHcWRa3W6G","W67cIdvCW5JcP8k5W5q","omoCdSkufa","lZqhE2FdMSolzmozW71iW5a","WRZdICo1uu1mza","WPXdzSkUW7ldNtRdMK/dLCo6Bq"];return(_0x46d1=function(){return n})()}document.title="前端监听页面崩溃",document.getElementById("article").innerHTML='<div><p>在前端开发中，监听页面崩溃（即页面因某些原因无法正常运行或加载）并不像监听普通用户交互事件那样直接，因为页面一旦崩溃，JavaScript 环境可能已经不可用，导致常规的事件监听机制失效。不过，仍然有一些间接的方法可以检测或“监听”页面崩溃的情况，主要包括以下几种方式：</p>\n<hr>\n<h2>一、使用 <code>window</code> 对象的 <code>error</code> 事件（有限作用）</h2>\n<p><code>window.onerror</code> 可以捕获页面中的 JavaScript 运行时错误，但它<strong>无法捕获导致页面完全崩溃的严重错误</strong>   （如内存溢出、C++ 层崩溃等）。</p>\n<pre><code class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">message, source, lineno, colno, error</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;捕获到错误:&quot;</span>, message, <span class="hljs-string">&quot;发生在&quot;</span>, source, <span class="hljs-string">&quot;行号:&quot;</span>, lineno);\n  <span class="hljs-comment">// 可以发送错误日志到服务器</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 阻止默认错误处理</span>\n};\n</code></pre>\n<p>⚠️ <strong>局限性</strong>   ：<code>window.onerror</code> 无法捕获导致页面完全崩溃的底层错误（如浏览器渲染引擎崩溃）。</p>\n<hr>\n<h2>二、使用 <code>navigator.sendBeacon</code> + <code>beforeunload</code> / <code>unload</code> 事件（间接检测）</h2>\n<p>由于页面崩溃时 JavaScript 可能已经不可用，我们无法在崩溃发生时直接“感知”。但可以通过在页面即将卸载前发送一个“心跳”或“状态报告”到服务器，如果服务器在一定时间内没有收到这个信号，可以推测页面可能崩溃了。</p>\n<h3>实现思路：</h3>\n<ol>\n<li>页面加载时，启动一个定时器，定期向服务器发送“我还活着”的信号（比如每 10 秒一次）。</li>\n<li>在 <code>beforeunload</code> 或 <code>unload</code> 事件中，发送一个特殊的“页面即将关闭”的信号。</li>\n<li>服务器端如果发现某个用户在一段时间内既没有收到“我还活着”的信号，也没有收到“页面关闭”的信号，就可以推测该用户的页面可能崩溃了。</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// 页面加载时启动心跳</span>\n<span class="hljs-keyword">let</span> heartbeatInterval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {\n  navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&quot;/api/heartbeat&quot;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;alive&quot;</span> }));\n}, <span class="hljs-number">10000</span>); <span class="hljs-comment">// 每10秒发送一次</span>\n\n<span class="hljs-comment">// 页面即将卸载时发送关闭信号</span>\n<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;beforeunload&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  navigator.<span class="hljs-title function_">sendBeacon</span>(\n    <span class="hljs-string">&quot;/api/page-close&quot;</span>,\n    <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;closing&quot;</span> }),\n  );\n});\n\n<span class="hljs-comment">// 注意：如果页面崩溃，beforeunload 和 unload 不会被触发，heartbeat 也会停止</span>\n</code></pre>\n<p>✅ <strong>优点</strong>   ：这是一种间接但相对可靠的检测页面崩溃的方法。</p>\n<p>❌ <strong>缺点</strong>   ：无法实时感知崩溃，只能通过服务器端推测；存在一定的延迟和误判可能。</p>\n<hr>\n<h2>三、使用 Service Worker 监听页面状态（高级）</h2>\n<p>Service Worker 运行在浏览器后台，即使页面关闭或崩溃，它仍然可能在一定时间内存活。因此，可以利用 Service Worker 来监听页面的状态变化，比如页面是否响应、是否崩溃等。</p>\n<p>不过，Service Worker <strong>无法直接感知页面是否崩溃</strong>   ，但可以通过以下方式间接推测：</p>\n<ul>\n<li>页面与 Service Worker 之间的通信是否中断。</li>\n<li>定期向 Service Worker 发送“心跳”，如果心跳停止，可能意味着页面崩溃或网络断开。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在页面中定期向 Service Worker 发送消息</span>\n<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">if</span> (navigator.<span class="hljs-property">serviceWorker</span> &amp;&amp; navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-property">controller</span>) {\n    navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-property">controller</span>.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;heartbeat&quot;</span> });\n  }\n}, <span class="hljs-number">10000</span>);\n</code></pre>\n<p>在 Service Worker 中接收并记录这些心跳，如果一段时间内没有收到心跳，可以推测页面可能已崩溃或离线。</p>\n<p>✅ <strong>优点</strong>   ：可以在后台持续运行，适合做离线检测和状态管理。</p>\n<p>❌ <strong>缺点</strong>   ：无法 100% 确定页面崩溃，因为网络问题也可能导致心跳中断；实现较为复杂。</p>\n<hr>\n<h2>四、使用 <code>PerformanceObserver</code> 监控页面性能（辅助手段）</h2>\n<p>虽然 <code>PerformanceObserver</code> 不能直接检测页面崩溃，但它可以监控页面的性能指标，比如长任务、页面加载时间等。如果页面出现严重性能问题，可能间接提示页面即将崩溃或已经不可用。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> {\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> list.<span class="hljs-title function_">getEntries</span>()) {\n    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">duration</span> &gt; <span class="hljs-number">5000</span>) {\n      <span class="hljs-comment">// 假设任务执行时间超过5秒</span>\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;长任务 detected:&quot;</span>, entry);\n    }\n  }\n});\n\nobserver.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">&quot;longtask&quot;</span>] });\n</code></pre>\n<p>✅ <strong>优点</strong>   ：有助于发现潜在的性能问题，可能提前预警页面不稳定。</p>\n<p>❌ <strong>缺点</strong>   ：不能直接检测崩溃，只能作为辅助监控手段。</p>\n<hr>\n<h2>五、结合前端监控系统（如 Sentry、Bugsnag 等）</h2>\n<p>许多前端错误监控平台（如 <a href="https://sentry.io/" target="_blank">Sentry</a>、<a href="https://www.bugsnag.com/" target="_blank">Bugsnag</a>）提供了页面崩溃检测的功能。它们通常通过以下方式实现：</p>\n<ul>\n<li>捕获 JavaScript 运行时错误。</li>\n<li>监控页面生命周期事件（如 <code>beforeunload</code>、<code>unload</code>）。</li>\n<li>使用 <code>sendBeacon</code> 在页面卸载前发送状态。</li>\n<li>结合心跳机制和服务器端分析，推测页面是否崩溃。</li>\n</ul>\n<p>✅ <strong>优点</strong>   ：功能强大，开箱即用，适合生产环境使用。</p>\n<p>❌ <strong>缺点</strong>   ：可能需要接入第三方服务，存在隐私和数据安全方面的考虑。</p>\n<hr>\n<h2>总结</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>能否直接监听崩溃</th>\n<th>实现难度</th>\n<th>可靠性</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>window.onerror</code></td>\n<td>❌ 不能</td>\n<td>低</td>\n<td>低</td>\n<td>捕获普通 JS 错误</td>\n</tr>\n<tr>\n<td><code>beforeunload</code> + <code>sendBeacon</code>（心跳机制）</td>\n<td>⚠️ 间接</td>\n<td>中</td>\n<td>中高</td>\n<td>推测页面崩溃</td>\n</tr>\n<tr>\n<td>Service Worker 监听</td>\n<td>⚠️ 间接</td>\n<td>高</td>\n<td>中</td>\n<td>高级场景、离线检测</td>\n</tr>\n<tr>\n<td><code>PerformanceObserver</code></td>\n<td>❌ 不能</td>\n<td>中</td>\n<td>低</td>\n<td>性能监控、辅助手段</td>\n</tr>\n<tr>\n<td>前端监控平台（如 Sentry）</td>\n<td>✅ 可以</td>\n<td>低（接入简单）</td>\n<td>高</td>\n<td>生产环境推荐</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>如果你需要<strong>在生产环境中可靠地检测页面崩溃</strong>   ，推荐使用<strong>前端错误监控平台（如 Sentry）</strong>   或 <strong>结合 <code>sendBeacon</code> 的心跳机制</strong>   来实现。这两种方式相对成熟且易于集成，能够满足大部分场景的需求。</p>\n</div>'</script></body></html>