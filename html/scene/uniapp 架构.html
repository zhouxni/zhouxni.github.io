<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1fb0(){var n=["W5JcGCoOW53dJ2ldMXFdIKtdOCkx","aSoMn8keWPhdVJzv","FmoxuItcMmouWRbZW7pcNmki","WOtdGSkMWQNcRWlcHxCiWOlcVCkn","W6NdVmoykMCDa8kQ","rCoGnSkNW4HZlxO9W5tdS0lcPf4","hLmXWOBdNSoxuKNcOgvBwmoe","W79sq8obWQeDW4hcPG99iCoMW7ldSW","WQ3cMSknaLZcI2Xu","sCkAW6/cTG7dOLn5la","W7v4D8o5W6zfW6/dT2O9zCk0BW","W5zZWPbyW7rIdgBcLW","W6NdVmkaB0WokmkoW6BcSq","bSoFWOOxffjgxINdNX8","W6DLWOboW74","k8kMWR5gl3XdWQaElmk/DG","W7u5WOKxD8oXEW","jL3dHgPMcCooWOVdLxbWWPJcII7dUCkmdCo9WPTgDh0vW4rrFa","gvq4W5ZcP8kWmflcMq","WPrgESoUW6pcTxLZ","gLmWWOxdNSosv2BcKefHE8oO","W4yHwmkjWPxcP8oTCI0HW6rQeG","lmkUW7mFyGrDWR8","fConnGPhWRpcKCkkW7iV","WRSrW4T7FM1ssq","rCkcW4PnqN92","FXNcIsWNb8kVW6pdPhzjWQ4","W4W5fSoRc0JdVCoQ","bcJcKSkIW6XsW4ZcLHtcJ18","asdcK8kGW6HKW6NcPsBcTfG"];return(_0x1fb0=function(){return n})()}var _0x1c0166=_0x32a4;function _0x32a4(a,n){var l=_0x1fb0();return(_0x32a4=function(n,s){var t=l[n-=267];void 0===_0x32a4.sXeShV&&(_0x32a4.eYeJQX=function(n,s){var t,r=[],a=0,l="";for(n=(n=>{for(var s,t,r="",a="",l=0,o=0;t=n.charAt(o++);~t&&(s=l%4?64*s+t:t,l++%4)&&(r+=String.fromCharCode(255&s>>(-2*l&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var e=0,c=r.length;e<c;e++)a+="%"+("00"+r.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(a)})(n),o=0;o<256;o++)r[o]=o;for(o=0;o<256;o++)a=(a+r[o]+s.charCodeAt(o%s.length))%256,t=r[o],r[o]=r[a],r[a]=t;for(var o=0,a=0,e=0;e<n.length;e++)t=r[o=(o+1)%256],r[o]=r[a=(a+r[o])%256],r[a]=t,l+=String.fromCharCode(n.charCodeAt(e)^r[(r[o]+r[a])%256]);return l},a=arguments,_0x32a4.sXeShV=!0);var n=n+l[0],r=a[n];return r?t=r:(void 0===_0x32a4.YBTkWj&&(_0x32a4.YBTkWj=!0),t=_0x32a4.eYeJQX(t,s),a[n]=t),t})(a,n)}if((()=>{for(var n=_0x32a4,s=_0x1fb0();;)try{if(827468==+parseInt(n(267,"npJE"))*(parseInt(n(284,"9m8t"))/2)+parseInt(n(273,"gb%1"))/3*(-parseInt(n(268,"iRrC"))/4)+-parseInt(n(271,"L0%@"))/5+-parseInt(n(288,"xBxA"))/6*(-parseInt(n(278,"zAKr"))/7)+parseInt(n(274,"Zsqs"))/8*(-parseInt(n(295,"0[M3"))/9)+-parseInt(n(286,"O5Qq"))/10+parseInt(n(289,"JBWR"))/11*(parseInt(n(272,"aF[z"))/12))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x1c0166(281,"Yw]o")](_0x1c0166(276,"etR$"))!=_0x1c0166(279,"etR$"))throw window[_0x1c0166(296,"]4kG")][_0x1c0166(290,"zAKr")](_0x1c0166(282,"QF4F")),Error();document.title="uniapp 架构",document.getElementById("article").innerHTML='<div><p>UniApp <strong>同时采用编译时适配和运行时适配</strong>  ，但两者的分工与 Taro 3 有本质不同。以下是 UniApp 架构的深度解析：</p>\n<hr>\n<h3>一、UniApp 的混合适配策略</h3>\n<h4>1. <strong>编译时适配（主导）</strong></h4>\n<ul>\n<li><strong>模板/样式</strong>  ：通过条件编译静态替换<pre><code class="language-html"><span class="hljs-comment">&lt;!-- #ifdef MP-WEIXIN --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;weapp-view&quot;</span>&gt;</span>小程序专属<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span>\n<span class="hljs-comment">&lt;!-- #endif --&gt;</span>\n</code></pre>\n</li>\n<li><strong>文件隔离</strong>  ：支持 <code>page.weapp.vue</code> 和 <code>page.h5.vue</code></li>\n<li><strong>构建产物</strong>  ：直接生成各平台专属代码（如 <code>.wxml</code>/<code>.html</code>）</li>\n</ul>\n<h4>2. <strong>运行时适配（辅助）</strong></h4>\n<ul>\n<li><strong>API 层</strong>  ：<code>uni.request</code> 等统一 API 内部动态分发<pre><code class="language-javascript"><span class="hljs-comment">// 运行时判断</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">UNI_PLATFORM</span> === <span class="hljs-string">&#x27;mp-weixin&#x27;</span>) {\n    <span class="hljs-keyword">return</span> wx.<span class="hljs-title function_">request</span>();\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>();\n  }\n}\n</code></pre>\n</li>\n<li><strong>基础组件</strong>  ：如 <code>&lt;uni-button&gt;</code> 内部有平台判断逻辑</li>\n</ul>\n<hr>\n<h3>二、与 Taro 3 的本质区别</h3>\n<table>\n<thead>\n<tr>\n<th><strong>维度</strong></th>\n<th>UniApp</th>\n<th>Taro 3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>核心架构</strong></td>\n<td>基于 Vue 的模板编译</td>\n<td>基于虚拟 DOM 的运行时抽象</td>\n</tr>\n<tr>\n<td><strong>条件编译</strong></td>\n<td>主导（文件/代码块级）</td>\n<td>辅助（仅性能优化）</td>\n</tr>\n<tr>\n<td><strong>运行时能力</strong></td>\n<td>仅 API 和基础组件动态适配</td>\n<td>全量虚拟 DOM 动态渲染</td>\n</tr>\n<tr>\n<td><strong>开发体验</strong></td>\n<td>需显式写条件编译</td>\n<td>一套代码自动适配</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>三、UniApp 架构图示解析</h3>\n<pre><code class="language-mermaid">graph TD\n    A[UniApp代码] --&gt; B{条件编译预处理}\n    B --&gt;|MP-WEIXIN| C[生成WXML/WXSS]\n    B --&gt;|H5| D[生成HTML/CSS]\n    A --&gt; E(uni API统一层)\n    E --&gt; F[运行时平台判断]\n    F --&gt;|MP-WEIXIN| G[调用wx.xxx]\n    F --&gt;|H5| H[调用Web API]\n</code></pre>\n<hr>\n<h3>四、UniApp 运行时适配的局限性</h3>\n<ol>\n<li><strong>组件行为差异</strong>\n<ul>\n<li><code>&lt;scroll-view&gt;</code> 在小程序和 H5 的滚动事件参数不同</li>\n<li>需要开发者手动兼容（而 Taro 3 通过虚拟 DOM 统一事件对象）</li>\n</ul>\n</li>\n<li><strong>样式隔离问题</strong><pre><code class="language-css"><span class="hljs-comment">/* 小程序需要 -webkit- 前缀 */</span>\n<span class="hljs-comment">/* #ifdef MP-WEIXIN */</span>\n<span class="hljs-selector-class">.box</span> { -webkit-<span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>; }\n<span class="hljs-comment">/* #endif */</span>\n</code></pre>\n</li>\n<li><strong>动态能力较弱</strong>\n<ul>\n<li>无法实现类似 Taro 3 的 <code>window.__TARO_ENV__ = \'h5\'</code> 动态切换</li>\n<li>条件编译分支在构建后已被移除</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>五、为什么 UniApp 不采用纯运行时？</h3>\n<ol>\n<li><strong>性能优先</strong>\n<ul>\n<li>直接编译为平台代码比虚拟 DOM 渲染更快</li>\n<li>小程序场景对包体积敏感（移除无用代码）</li>\n</ul>\n</li>\n<li><strong>开发习惯</strong>\n<ul>\n<li>小程序开发者更熟悉模板语法（WXML）</li>\n<li>降低从原生小程序迁移的成本</li>\n</ul>\n</li>\n<li><strong>技术栈限制</strong>\n<ul>\n<li>基于 Vue 的模板编译难以实现深度运行时抽象</li>\n<li>Vue 2 的响应式系统对虚拟 DOM 优化有限</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>六、总结：UniApp 的定位</h3>\n<ul>\n<li><strong>适用场景</strong>  ：快速构建以小程序为主的多端应用</li>\n<li><strong>优势</strong>  ：<br>\n✅ 更接近原生性能<br>\n✅ 小程序生态无缝接入</li>\n<li><strong>代价</strong>  ：<br>\n❌ 多端一致性较弱<br>\n❌ 动态能力受限</li>\n</ul>\n<p><strong>最终结论</strong>  ：<br>\nUniApp 是 <strong>以编译时为主、运行时为辅</strong>   的框架，与 Taro 3 的纯运行时适配是两种不同的技术路线选择，各有适用场景。</p>\n</div>'</script></body></html>