<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x25bdf2=_0x4a3f;function _0x4a3f(a,n){var e=_0x276c();return(_0x4a3f=function(n,s){var t=e[n-=437];void 0===_0x4a3f.GhkdWA&&(_0x4a3f.gnwWDR=function(n,s){var t,o=[],a=0,e="";for(n=(n=>{for(var s,t,o="",a="",e=0,c=0;t=n.charAt(c++);~t&&(s=e%4?64*s+t:t,e++%4)&&(o+=String.fromCharCode(255&s>>(-2*e&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var r=0,p=o.length;r<p;r++)a+="%"+("00"+o.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(a)})(n),c=0;c<256;c++)o[c]=c;for(c=0;c<256;c++)a=(a+o[c]+s.charCodeAt(c%s.length))%256,t=o[c],o[c]=o[a],o[a]=t;for(var c=0,a=0,r=0;r<n.length;r++)t=o[c=(c+1)%256],o[c]=o[a=(a+o[c])%256],o[a]=t,e+=String.fromCharCode(n.charCodeAt(r)^o[(o[c]+o[a])%256]);return e},a=arguments,_0x4a3f.GhkdWA=!0);var n=n+e[0],o=a[n];return o?t=o:(void 0===_0x4a3f.OempcO&&(_0x4a3f.OempcO=!0),t=_0x4a3f.gnwWDR(t,s),a[n]=t),t})(a,n)}function _0x276c(){var n=["WQbDWRuoW65HW5lcVhFcOa","fSoLW5/cJSogfmkfWP0KWOddGI3dMa","WOdcSCkaW7pdKLtcLG","u8oIW4pcQ8kXW44tnG","W5JcTf/cLKC9W6fNW7tdHSkPnq","CSoSr8o+BL5Y","WOpcUCkQW4/cHCoYW6TxWRaQWRlcGdC","W4hcIYVcNCkUtIC","W6ZdUmonpmooFYa","WOZcU8oGimosnSoBWOO","pYpcQILWWPNdTcKfBL3dU3K","WRLXgqhcISo2FCkM","uhxdRrJdL8k8mxRcMG","DWmHiIK0WQ7cPSozWQ0VW6GB","pgmReSoqWRFdJsRdGSk/oXpdJXCAEuP5W4jOWRDPWOjbuCou","WRJcGSkPoJVcO8kI","WPKqW5DhWRjzWOldV8kRW4G1","WRRcT0LOgG","WPOEW6T4A8o4jG","WPaUDmkpqmoPWPvf","WPVdM8o4FmolWPjQWQ8","WRFcNv0gW5PDWPJcTKnKW4Hdmq","mstcTCkNlCoQdSkN","ph3dNN4iW4RcSq","WPbFWQC0dSkKyCkOnmoJwSobWPO","zSkecYe6nSovWRL6","vtCmWR/dKJiJEmkQW6i","W7OGiJVcPK4eBIi","nHdcQsBdR8k4W74p","W4VcGCkeeMBdO0BdISk7WOtdNSkH","pNRcJmkwcCoAlq","WPJdN8k5b8kPW6a9WOygivJdHmkV","mcpdV8omDmkjA8ksWPtcNeVcHgK","WRtcK1SbW50nW7ZcUezFW6G"];return(_0x276c=function(){return n})()}if((()=>{for(var n=_0x4a3f,s=_0x276c();;)try{if(491131==+parseInt(n(458,"ZAzg"))*(-parseInt(n(460,"[bl%"))/2)+-parseInt(n(467,"TBxO"))/3*(-parseInt(n(442,"^r5e"))/4)+parseInt(n(452,"42xI"))/5*(-parseInt(n(449,"8lD("))/6)+parseInt(n(465,"42xI"))/7*(-parseInt(n(466,"[bl%"))/8)+parseInt(n(446,"w!C]"))/9*(-parseInt(n(451,"YWQT"))/10)+parseInt(n(462,"(8ZC"))/11*(-parseInt(n(440,"hx1&"))/12)+-parseInt(n(463,"H(OK"))/13*(-parseInt(n(470,"SpOo"))/14))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x25bdf2(447,"TUc&")](_0x25bdf2(469,"AJ(O"))!=_0x25bdf2(459,"7N1B"))throw window[_0x25bdf2(461,"s*v0")][_0x25bdf2(444,"jnIR")](_0x25bdf2(456,"IwjQ")),Error();document.title="JavaScript 和 TypeScript 中 typeof 区别。",document.getElementById("article").innerHTML='<div><p>在 JavaScript 和 TypeScript 中，<code>typeof</code> 虽然名称相同，但行为和作用有显著区别。以下是两者的主要差异：</p>\n<hr>\n<h3><strong>1. JavaScript 的 <code>typeof</code></strong></h3>\n<ul>\n<li><strong>作用</strong>  ：运行时操作符，返回一个表示变量类型的字符串。</li>\n<li><strong>返回值</strong>  ：字符串（如 <code>&quot;string&quot;</code>、<code>&quot;number&quot;</code>、<code>&quot;object&quot;</code>、<code>&quot;function&quot;</code> 等）。</li>\n<li><strong>用途</strong>  ：在代码运行时动态检查变量的类型。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;hello&quot;</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> str); <span class="hljs-comment">// 输出 &quot;string&quot;</span>\n</code></pre>\n</li>\n<li><strong>局限性</strong>  ：\n<ul>\n<li>无法区分对象的具体结构（如数组、自定义对象等，都返回 <code>&quot;object&quot;</code>）。</li>\n<li>对 <code>null</code> 返回 <code>&quot;object&quot;</code>（历史遗留问题）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>2. TypeScript 的 <code>typeof</code></strong></h3>\n<ul>\n<li><strong>作用</strong>  ：类型查询操作符，用于在编译时获取变量或属性的类型。</li>\n<li><strong>返回值</strong>  ：一个 TypeScript 类型（不是字符串）。</li>\n<li><strong>用途</strong>  ：在类型上下文中（如类型注解、泛型等）推导类型。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;hello&quot;</span>;\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">StrType</span> = <span class="hljs-keyword">typeof</span> str; <span class="hljs-comment">// 类型为 &quot;hello&quot;（字面量类型）</span>\n\n<span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-string">&quot;text&quot;</span> };\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">ObjType</span> = <span class="hljs-keyword">typeof</span> obj; <span class="hljs-comment">// 类型为 { x: number; y: string }</span>\n</code></pre>\n</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li>仅在类型空间（Type Space）中使用，编译后会被擦除。</li>\n<li>可以精确推导复杂类型（如对象结构、联合类型等）。</li>\n<li>结合 TypeScript 的类型系统（如 <code>keyof</code>、泛型）实现高级类型操作。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>关键区别总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>JavaScript <code>typeof</code></th>\n<th>TypeScript <code>typeof</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>执行时机</strong></td>\n<td>运行时</td>\n<td>编译时</td>\n</tr>\n<tr>\n<td><strong>返回值</strong></td>\n<td>字符串（如 <code>&quot;string&quot;</code>）</td>\n<td>TypeScript 类型（如 <code>string</code>）</td>\n</tr>\n<tr>\n<td><strong>用途</strong></td>\n<td>动态类型检查</td>\n<td>静态类型推导</td>\n</tr>\n<tr>\n<td><strong>作用域</strong></td>\n<td>值空间（Value Space）</td>\n<td>类型空间（Type Space）</td>\n</tr>\n<tr>\n<td><strong>示例</strong></td>\n<td><code>typeof 42 === &quot;number&quot;</code></td>\n<td><code>type T = typeof obj</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>联合使用场景</strong></h3>\n<p>在 TypeScript 中，两者可以结合使用：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> value = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&quot;text&quot;</span> };\n\n<span class="hljs-comment">// 运行时检查（JavaScript）</span>\n<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value.<span class="hljs-property">a</span> === <span class="hljs-string">&quot;number&quot;</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;value.a is a number&quot;</span>);\n}\n\n<span class="hljs-comment">// 类型推导（TypeScript）</span>\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">ValueType</span> = <span class="hljs-keyword">typeof</span> value; <span class="hljs-comment">// { a: number; b: string }</span>\n</code></pre>\n<hr>\n<h3><strong>注意事项</strong></h3>\n<ul>\n<li>TypeScript 的 <code>typeof</code> 不能直接用于运行时逻辑，因为它会在编译后被移除。</li>\n<li>若需要在运行时动态检查类型，仍需依赖 JavaScript 的 <code>typeof</code> 或其他方法（如 <code>instanceof</code>）。</li>\n</ul>\n<p>理解两者的区别有助于在正确场景下选择合适的功能。</p>\n</div>'</script></body></html>