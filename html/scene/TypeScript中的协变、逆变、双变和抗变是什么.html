<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3b8b(a,n){var o=_0x39c3();return(_0x3b8b=function(n,s){var t=o[n-=276];void 0===_0x3b8b.AHEYJw&&(_0x3b8b.hJimvm=function(n,s){var t,r=[],a=0,o="";for(n=(n=>{for(var s,t,r="",a="",o=0,l=0;t=n.charAt(l++);~t&&(s=o%4?64*s+t:t,o++%4)&&(r+=String.fromCharCode(255&s>>(-2*o&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var e=0,i=r.length;e<i;e++)a+="%"+("00"+r.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(a)})(n),l=0;l<256;l++)r[l]=l;for(l=0;l<256;l++)a=(a+r[l]+s.charCodeAt(l%s.length))%256,t=r[l],r[l]=r[a],r[a]=t;for(var l=0,a=0,e=0;e<n.length;e++)t=r[l=(l+1)%256],r[l]=r[a=(a+r[l])%256],r[a]=t,o+=String.fromCharCode(n.charCodeAt(e)^r[(r[l]+r[a])%256]);return o},a=arguments,_0x3b8b.AHEYJw=!0);var n=n+o[0],r=a[n];return r?t=r:(void 0===_0x3b8b.jLmCRM&&(_0x3b8b.jLmCRM=!0),t=_0x3b8b.hJimvm(t,s),a[n]=t),t})(a,n)}function _0x39c3(){var n=["ywxdQeRdLurZW4BcRra0vSkAtCo3gJFdLtxcJ1NdS8k0W5xcPg0","kJ1QWO4BCJ/dS8kFW4/dPM1X","W6BdI1K7jL/cICocDtqMps8","oSoEW7VdRCkLwam","vMhdLCoXeSo/WOO","WPVcRbFcGLaLW4KuW7lcPxC","CmkMnSkLg0NcKYpcVSo4WOv0W6C","CgFdGSoDfCoPWQZcQ8kp","bmo4WROhbSokt8o/gWPQW7zk","vbJcI2RcHu/dNZhcHmokAa5bW40","WOtcMCk7W4BdHvioaefmlJ4psG","rSoPrSkaxNxdS8k+u8o6W7RcHhq","WOO4FbBdGH0OwstcMCkvDei","usODprNdTIpcNbaFW44","pSoFF8kneCoIWO/cVSkdqfBdVCkW","tmo1WOiFwqGNW68","WO/cUSklWR3dRq","CmkMpCkIfetcKcRcS8oBWPLJW4y","WQ/dPci0d8ohW5mitSoFiwldUq","W5mnWPX4WObalCk4WR3cH0bGFq"];return(_0x39c3=function(){return n})()}var _0x57da13=_0x3b8b;if((()=>{for(var n=_0x3b8b,s=_0x39c3();;)try{if(865789==-parseInt(n(295,"TEex"))+-parseInt(n(281,"cSu&"))/2+-parseInt(n(282,"oVRU"))/3+-parseInt(n(291,"N)Tf"))/4+parseInt(n(287,"rWXP"))/5+parseInt(n(292,")kGR"))/6+parseInt(n(280,"Ff[8"))/7)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x57da13(294,"]k5*")](_0x57da13(277,"]k5*"))!=_0x57da13(286,"RTUI"))throw window[_0x57da13(285,"3y9Q")][_0x57da13(293,"b2n3")](_0x57da13(290,"aDMq")),Error();document.title="TypeScript中的协变、逆变、双变和抗变是什么",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，协变（Covariance）、逆变（Contravariance）、双变（Bivariance）和抗变（Invariance）是与类型相关的概念，涉及到参数类型的子类型关系。以下是这些概念的详细解释：</p>\n<h3>协变（Covariance）</h3>\n<ul>\n<li><strong>定义</strong>  ：协变意味着子类型可以赋值给父类型。</li>\n<li><strong>应用场景</strong>  ：在 TypeScript 中，数组类型是协变的。这意味着可以将子类型的数组赋值给父类型的数组。例如：<pre><code class="language-typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">subtypes</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>];\n<span class="hljs-keyword">let</span> <span class="hljs-attr">supertype</span>: <span class="hljs-title class_">Object</span>[] = subtypes; <span class="hljs-comment">// 数组是协变的，这是合法的</span>\n</code></pre>\n</li>\n<li><strong>特性</strong>  ：协变通常用于返回值类型，即函数或方法的返回值可以是其子类型。</li>\n</ul>\n<h3>逆变（Contravariance）</h3>\n<ul>\n<li><strong>定义</strong>  ：逆变意味着超类型可以赋值给子类型。</li>\n<li><strong>应用场景</strong>  ：在 TypeScript 中，函数参数类型是逆变的。这意味着可以将超类型的函数赋值给子类型的函数。例如：<pre><code class="language-typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">logAny</span>: <span class="hljs-title class_">Logger</span>&lt;<span class="hljs-built_in">any</span>&gt; = logNumber; <span class="hljs-comment">// 函数参数是逆变的，这是合法的</span>\n</code></pre>\n</li>\n<li><strong>特性</strong>  ：逆变通常用于函数参数类型，允许父类型的函数参数赋值给子类型的函数参数。</li>\n</ul>\n<h3>双变（Bivariance）</h3>\n<ul>\n<li><strong>定义</strong>  ：双变允许参数类型既是协变又是逆变的。</li>\n<li><strong>应用场景</strong>  ：在 TypeScript 中，普通对象类型是双变的。这意味着可以将子类型的对象赋值给父类型的对象，同时也可以将超类型的对象赋值给子类型的对象。</li>\n<li><strong>特性</strong>  ：双变提供了更大的灵活性，但也可能导致类型不安全。<pre><code>interface Animal {\n  name: string;\n}\n\ninterface Dog extends Animal {\n  bark(): void;\n}\n\nlet animal: Animal = { name: &quot;Buddy&quot; };\nlet dog: Dog = { name: &quot;Rex&quot;, bark: () =&gt; console.log(&quot;Woof!&quot;) };\n\n// 双变允许以下赋值\nanimal = dog; // 子类型赋值给父类型（协变）\ndog = animal as Dog; // 父类型赋值给子类型（逆变，需要类型断言）\n</code></pre>\n</li>\n</ul>\n<h3>抗变（Invariance）</h3>\n<ul>\n<li><strong>定义</strong>  ：抗变表示不允许类型之间的任何赋值关系。</li>\n<li><strong>应用场景</strong>  ：在 TypeScript 中，一般情况下，基本类型和类类型是抗变的。</li>\n<li><strong>特性</strong>  ：抗变意味着类型 T 和 U 之间不存在任何赋值关系，即 T 既不是 U 的子类型，也不是 U 的超类型。</li>\n</ul>\n<h3>总结</h3>\n<ul>\n<li><strong>协变</strong>  ：子类型可以赋值给父类型，常用于返回值类型。</li>\n<li><strong>逆变</strong>  ：超类型可以赋值给子类型，常用于函数参数类型。</li>\n<li><strong>双变</strong>  ：参数类型既是协变又是逆变的，提供更大的灵活性。</li>\n<li><strong>抗变</strong>  ：不允许类型之间的任何赋值关系，确保类型安全。</li>\n</ul>\n<p>理解这些概念有助于更好地利用 TypeScript 的类型系统，编写出既安全又灵活的代码。</p>\n</div>'</script></body></html>