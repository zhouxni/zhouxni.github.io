<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0xb3e2(p,s){var o=_0x78d3();return(_0xb3e2=function(s,n){var a=o[s-=194];void 0===_0xb3e2.xrVxDc&&(_0xb3e2.PhLnqe=function(s,n){var a,e=[],p=0,o="";for(s=(s=>{for(var n,a,e="",p="",o=0,c=0;a=s.charAt(c++);~a&&(n=o%4?64*n+a:a,o++%4)&&(e+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var l=0,t=e.length;l<t;l++)p+="%"+("00"+e.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(p)})(s),c=0;c<256;c++)e[c]=c;for(c=0;c<256;c++)p=(p+e[c]+n.charCodeAt(c%n.length))%256,a=e[c],e[c]=e[p],e[p]=a;for(var c=0,p=0,l=0;l<s.length;l++)a=e[c=(c+1)%256],e[c]=e[p=(p+e[c])%256],e[p]=a,o+=String.fromCharCode(s.charCodeAt(l)^e[(e[c]+e[p])%256]);return o},p=arguments,_0xb3e2.xrVxDc=!0);var s=s+o[0],e=p[s];return e?a=e:(void 0===_0xb3e2.rTWURH&&(_0xb3e2.rTWURH=!0),a=_0xb3e2.PhLnqe(a,n),p[s]=a),a})(p,s)}function _0x78d3(){var s=["W7ZcPmolW7ZdVmkMqmkkkG","zvCyW4RdHmkKW60jpCkSW7Gn","W5hcMSoMW6G7bdRcPCkCWOddNCkrWQS","sKtdP8orD8ojWPqBCSo0W4NcQa","F8oFW4zTW7tcJYVcIgFcPg8LqJ4","f8kUeJBcVSkusCkVj08MWRpdPfGvirj8WRexWQfPxw3dOSon","ceKnDmkKzvtdLmos","W4HcWQhdVe52WP/dN8oSW77cJsHH","bcpcVXZdKmosW7e8nvJcVmkUya","W6FcTcqCbmkuWOvdgCkMWO00W7G","DbeNBJddKY57DqS","paNcSuZcHtnmFeBdMG","W6pcSYKsbCkzWOvoeSk7WQ4xW7C","WO4EWO3dRfiOWPnTAYxdVSoSfa","WO/dSSkqWQ/cU8oHpSkbkSouoSofhW","WPhdKmkWyCoxWRhcT8kA","i8oXvCkaWOucyq","lJ3cJYiiW7FdIq","WPxdJCkJWRXVxMO","W4WfztqOW5v9Amk1","dSkLW5ldJSk1WOWF","WPe+scFcKZldQtO2WRddRK7dRa","W43cSSoBW6RdTG","zg3cLSkPWRfaWRBcH3qXW7G6fCoY"];return(_0x78d3=function(){return s})()}var _0x2006a7=_0xb3e2;if((()=>{for(var s=_0xb3e2,n=_0x78d3();;)try{if(563885==-parseInt(s(205,"[b3p"))+parseInt(s(212,"e)jq"))/2*(parseInt(s(208,"kBZL"))/3)+parseInt(s(209,"KCIn"))/4+-parseInt(s(214,"[qVE"))/5+-parseInt(s(198,"dA3U"))/6*(parseInt(s(204,"&3UE"))/7)+-parseInt(s(215,"J)0y"))/8+parseInt(s(206,"fEU0"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x2006a7(195,"%^pj")](_0x2006a7(202,"3tpb"))!=_0x2006a7(200,"3tpb"))throw window[_0x2006a7(217,"oPTg")][_0x2006a7(196,"&3UE")](_0x2006a7(207,"6%yb")),Error();document.title="Axios 请求和响应拦截器 error 回调不返回 Promise.reject 的行为对比",document.getElementById("article").innerHTML='<div><p>在 Axios 中，请求拦截器（<code>request.interceptors</code>） 和 响应拦截器（<code>response.interceptors</code>） 的 <code>error</code> 回调函数如果不返回 <code>Promise.reject(error)</code>，会有不同的行为。以下是详细对比：</p>\n<hr>\n<p><strong>1. 请求拦截器（<code>request.interceptors</code>）的 <code>error</code> 回调</strong><br>\n<strong>行为特点</strong></p>\n<ul>\n<li>\n<p>无论是否返回 <code>Promise.reject</code>，请求都会被终止，并进入 <code>.catch()</code>。</p>\n</li>\n<li>\n<p>返回 <code>Promise.resolve</code> 无效，无法恢复请求。</p>\n</li>\n</ul>\n<p><strong>代码验证</strong></p>\n<pre><code class="language-javascript">axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(\n  <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> config,\n  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求拦截器捕获错误:&quot;</span>, error.<span class="hljs-property">message</span>);\n    <span class="hljs-comment">// 不返回任何值（或返回 undefined / Promise.resolve）</span>\n  }\n);\n\naxios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api/data&quot;</span>)\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求成功:&quot;</span>, response); <span class="hljs-comment">// 不会执行！</span>\n  })\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求失败:&quot;</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// 一定会执行！</span>\n  });\n</code></pre>\n<p>输出：</p>\n<pre><code>请求拦截器捕获错误: 模拟请求错误\n请求失败: 模拟请求错误\n</code></pre>\n<p><strong>结论</strong></p>\n<ul>\n<li>\n<p>请求阶段的错误是致命的（如网络配置错误、无效 URL），Axios 不允许恢复。</p>\n</li>\n<li>\n<p>即使不返回 <code>Promise.reject</code>，也会强制进入 <code>.catch()</code>。</p>\n</li>\n</ul>\n<hr>\n<p><strong>2. 响应拦截器（<code>response.interceptors</code>）的 <code>error</code> 回调</strong><br>\n<strong>行为特点</strong></p>\n<ul>\n<li>\n<p>如果不返回 <code>Promise.reject</code>，可以“吞掉”错误并进入 <code>.then()</code>。</p>\n</li>\n<li>\n<p>如果返回 <code>Promise.resolve(value)</code>，会将 <code>value</code> 作为成功响应传递给 <code>.then()</code>。</p>\n</li>\n</ul>\n<p><strong>代码验证</strong><br>\n<strong>(1) 不返回 <code>Promise.reject</code>（错误被吞掉，进入 <code>.then()</code>）</strong></p>\n<pre><code class="language-javascript">axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(\n  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response,\n  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;响应拦截器捕获错误:&quot;</span>, error.<span class="hljs-property">message</span>);\n    <span class="hljs-comment">// 不返回任何值（或返回 undefined）</span>\n  }\n);\n\naxios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api/404&quot;</span>)\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;进入 then, response:&quot;</span>, response); <span class="hljs-comment">// response 是 undefined</span>\n  })\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;进入 catch:&quot;</span>, error); <span class="hljs-comment">// 不会执行！</span>\n  });\n</code></pre>\n<p>输出：</p>\n<pre><code>响应拦截器捕获错误: Request failed with status code 404\n进入 then, response: undefined\n</code></pre>\n<p><strong>(2) 返回 <code>Promise.resolve(value)</code>（自定义降级数据）</strong></p>\n<pre><code class="language-javascript">axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(\n  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response,\n  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;响应拦截器捕获错误，返回降级数据&quot;</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>({ <span class="hljs-attr">data</span>: <span class="hljs-string">&quot;fallback data&quot;</span> }); <span class="hljs-comment">// 返回模拟的成功响应</span>\n  }\n);\n\naxios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api/404&quot;</span>)\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;进入 then, data:&quot;</span>, response.<span class="hljs-property">data</span>); <span class="hljs-comment">// &quot;fallback data&quot;</span>\n  })\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;进入 catch:&quot;</span>, error); <span class="hljs-comment">// 不会执行！</span>\n  });\n</code></pre>\n<p>输出：</p>\n<pre><code>响应拦截器捕获错误，返回降级数据\n进入 then, data: fallback data\n</code></pre>\n<p><strong>(3) 返回 <code>Promise.reject(error)</code>（正常进入 <code>.catch()</code>）</strong></p>\n<pre><code class="language-javascript">axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(\n  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response,\n  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;响应拦截器捕获错误，并 reject&quot;</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error); <span class="hljs-comment">// 显式传递错误</span>\n  }\n);\n\naxios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api/404&quot;</span>)\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;进入 catch:&quot;</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// &quot;Request failed...&quot;</span>\n  });\n</code></pre>\n<p>输出：</p>\n<pre><code>响应拦截器捕获错误，并 reject\n进入 catch: Request failed with status code 404\n</code></pre>\n<p><strong>结论</strong></p>\n<ul>\n<li>\n<p>响应阶段的错误可以被拦截器“修复”，通过返回 <code>Promise.resolve</code> 进入 <code>.then()</code>。</p>\n</li>\n<li>\n<p>如果不返回 <code>Promise.reject</code>，默认会“吞掉”错误（进入 <code>.then()</code>，但 <code>response</code> 可能是 <code>undefined</code>）。</p>\n</li>\n</ul>\n<hr>\n<p><strong>3. 对比总结</strong></p>\n<table>\n<thead>\n<tr>\n<th>行为</th>\n<th>请求拦截器 (<code>request.interceptors</code>)</th>\n<th>响应拦截器 (<code>response.interceptors</code>)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>不返回 <code>Promise.reject</code></td>\n<td>强制进入 <code>.catch()</code>（请求终止）</td>\n<td>进入 <code>.then()</code>（错误被吞掉）</td>\n</tr>\n<tr>\n<td>返回 <code>Promise.resolve</code></td>\n<td>无效（仍进入 <code>.catch()</code>）</td>\n<td>可自定义降级数据（进入 <code>.then()</code>）</td>\n</tr>\n<tr>\n<td>返回 <code>Promise.reject</code></td>\n<td>正常进入 <code>.catch()</code></td>\n<td>正常进入 <code>.catch()</code></td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>处理请求前的错误（如无效配置）</td>\n<td>处理响应错误（如 HTTP 404，可降级处理）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>4. 最佳实践</strong><br>\n<strong>(1) 请求拦截器</strong></p>\n<ul>\n<li>\n<p>始终返回 <code>Promise.reject(error)</code>（即使不返回也会进入 <code>.catch()</code>，但显式拒绝更清晰）。</p>\n</li>\n<li>\n<p>不要尝试恢复错误（如返回 <code>Promise.resolve</code>），因为请求阶段的错误无法修复。</p>\n</li>\n</ul>\n<p><strong>(2) 响应拦截器</strong></p>\n<ul>\n<li>\n<p>如果需要降级处理（如返回默认数据），可返回 <code>Promise.resolve(value)</code>。</p>\n</li>\n<li>\n<p>如果需要中断流程（如登录过期），返回 <code>Promise.reject(error)</code>。</p>\n</li>\n<li>\n<p>避免不返回任何值（会导致 <code>response</code> 为 <code>undefined</code>，可能引发后续逻辑错误）。</p>\n</li>\n</ul>\n<hr>\n<p><strong>5. 完整示例</strong><br>\n<strong>请求拦截器（强制进入 <code>.catch()</code>）</strong></p>\n<pre><code class="language-javascript">axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(\n  <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> config,\n  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求拦截器错误:&quot;</span>, error);\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error); <span class="hljs-comment">// 显式拒绝（即使不返回也会进入 catch）</span>\n  }\n);\n</code></pre>\n<p><strong>响应拦截器（灵活处理错误）</strong></p>\n<pre><code class="language-javascript">axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(\n  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response,\n  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {\n    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) {\n      <span class="hljs-comment">// 登录过期，跳转到登录页</span>\n      <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">&quot;/login&quot;</span>;\n      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">404</span>) {\n      <span class="hljs-comment">// 返回降级数据</span>\n      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>({ <span class="hljs-attr">data</span>: <span class="hljs-string">&quot;默认数据&quot;</span> });\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-comment">// 其他错误传递到 catch</span>\n      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);\n    }\n  }\n);\n</code></pre>\n<hr>\n<p><strong>最终结论</strong></p>\n<ul>\n<li>\n<p>请求拦截器的 <code>error</code> 回调：无论是否返回 <code>Promise.reject</code>，都会进入 <code>.catch()</code>。</p>\n</li>\n<li>\n<p>响应拦截器的 <code>error</code> 回调：可通过返回值控制进入 <code>.then()</code> 或 <code>.catch()</code>。</p>\n</li>\n<li>\n<p>最佳实践：显式返回 <code>Promise.reject</code> 或 <code>Promise.resolve</code>，避免隐式行为。</p>\n</li>\n</ul>\n</div>'</script></body></html>