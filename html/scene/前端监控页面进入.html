<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5eba(l,s){var e=_0x3da2();return(_0x5eba=function(s,n){var a=e[s-=334];void 0===_0x5eba.SclTZz&&(_0x5eba.BdiDLu=function(s,n){var a,t=[],l=0,e="";for(s=(s=>{for(var n,a,t="",l="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=t.length;o<c;o++)l+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)l=(l+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[l],t[l]=a;for(var p=0,l=0,o=0;o<s.length;o++)a=t[p=(p+1)%256],t[p]=t[l=(l+t[p])%256],t[l]=a,e+=String.fromCharCode(s.charCodeAt(o)^t[(t[p]+t[l])%256]);return e},l=arguments,_0x5eba.SclTZz=!0);var s=s+e[0],t=l[s];return t?a=t:(void 0===_0x5eba.LzvIIE&&(_0x5eba.LzvIIE=!0),a=_0x5eba.BdiDLu(a,n),l[s]=a),a})(l,s)}var _0x42db65=_0x5eba;function _0x3da2(){var s=["WQKsWQJdSSoyW7pdT2y","WR3dHHySWQjLWRrhW6HfW7OV","WQxdOmo1W5j2W6vJW4pcHqnpW4i","cmk+WRpcLCkMk1K","WQexWONdKSoIvCkcp8km","mstdMePNDCk0CCk2gCo3pW","W7RcL15WW7y1WPa","W4DeW71WFfRdQhBdPu3cNZSi","WOdcSCo3W5DdWOyAWQldNCkB","sCkIWQFcGci4vSoquCowaSojtrddN8oOWOb4W5y4W4e6WRRcVCoxwW","CbyrWRDHW7pdLSoUvG","WRL5W7mvFSkqWO0dtva","W4vXWPBdK3HVWO/cGCkWd8oGWRO","WOZdUSoFWOpcQG1IW4O","iCkyB1FcVmoJW7ZdO8oP","iSkAAbVcPSohW73dQCoxWOi","WQ0NW7JcL8kIW7zG","ztBdUCoPWQzPtc1Oy8kQWPO","WPJdS8k0W69QoaKJ","W5RcM2XYWPtdRHGHW6q","qqabWQfR","W5NcLgKQW6dcQvWGW41kW6xcGw8","WO/cPCkLzSoAzrHSWR5A","qCoFgSk4WORcU8oCbCoj","W47dOvrrWQ44W5xdHKu","x8kXDabWvSoIqCkaWPaiWR8","WP/cMCo6WQaqfXWDrt7dOgNdUW","o0JcTtu/pmk+","hSofWRJdRrhdGeufuv3dHCoAWOS"];return(_0x3da2=function(){return s})()}if((()=>{for(var s=_0x5eba,n=_0x3da2();;)try{if(172305==-parseInt(s(341,"lMQq"))*(parseInt(s(357,"Ve2h"))/2)+parseInt(s(344,"Djg!"))/3*(-parseInt(s(347,"vC)0"))/4)+parseInt(s(362,"LAMK"))/5*(parseInt(s(358,"g@qF"))/6)+-parseInt(s(338,"iJR0"))/7+parseInt(s(349,"4&Jg"))/8*(-parseInt(s(354,"qnN#"))/9)+parseInt(s(361,"F!ma"))/10+parseInt(s(350,"i8J["))/11*(parseInt(s(356,"5i4i"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x42db65(336,"I3$w")](_0x42db65(343,"3yX%"))!=_0x42db65(353,"3yX%"))throw window[_0x42db65(346,"x3f4")][_0x42db65(339,"XQTb")](_0x42db65(342,"[q$X")),Error();document.title="前端监控页面进入",document.getElementById("article").innerHTML='<div><p>前端监控页面进入（Page Enter）是用户行为分析的重要组成部分，通常用于统计用户访问量、来源、停留时间等。以下是完整的 <strong>前端监控页面进入的方法</strong>   ，涵盖不同场景和最佳实践：</p>\n<hr>\n<h2><strong>1. 核心方法：监听页面加载事件</strong></h2>\n<p>页面进入的核心事件是 <code>DOMContentLoaded</code> 和 <code>load</code>，它们分别表示 DOM 就绪和页面完全加载。</p>\n<h3><strong>(1) <code>DOMContentLoaded</code>（DOM 就绪）</strong></h3>\n<ul>\n<li><strong>触发时机</strong>   ：HTML 文档完全解析，DOM 树构建完成（无需等待样式表、图片等资源加载）。</li>\n<li><strong>适用场景</strong>   ：需要尽早统计用户进入页面（如计算停留时间）。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;DOM 已加载，页面进入&quot;</span>);\n  <span class="hljs-comment">// 记录页面进入时间</span>\n  <span class="hljs-variable language_">window</span>.<span class="hljs-property">pageEnterTime</span> = performance.<span class="hljs-title function_">now</span>();\n});\n</code></pre>\n<h3><strong>(2) <code>load</code>（页面完全加载）</strong></h3>\n<ul>\n<li><strong>触发时机</strong>   ：页面所有资源（图片、样式表、脚本等）加载完成。</li>\n<li><strong>适用场景</strong>   ：需要确保所有资源加载后再执行统计（如依赖图片尺寸的分析）。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;load&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;页面所有资源已加载&quot;</span>);\n  <span class="hljs-comment">// 可以在这里发送页面进入事件（但可能延迟）</span>\n});\n</code></pre>\n<p><strong>推荐</strong>   ：</p>\n<ul>\n<li>大多数情况下，<strong><code>DOMContentLoaded</code> 已足够</strong>   ，因为用户感知的“页面进入”通常是 DOM 可交互时。</li>\n<li>如果需要精确统计资源加载时间（如广告曝光），再结合 <code>load</code> 事件。</li>\n</ul>\n<hr>\n<h2><strong>2. 监听路由变化（SPA 单页应用）</strong></h2>\n<p>在单页应用（SPA）中，页面切换是通过前端路由实现的，不会触发完整的页面加载。此时需监听框架的路由事件。</p>\n<h3><strong>(1) Vue Router 示例</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在路由入口文件（如 main.js）中监听路由变化</span>\nrouter.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> {\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span>.<span class="hljs-property">path</span> !== to.<span class="hljs-property">path</span>) {\n    <span class="hljs-comment">// 排除同一路由参数变化</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;SPA 页面进入:&quot;</span>, to.<span class="hljs-property">path</span>);\n    <span class="hljs-comment">// 记录进入时间或发送数据</span>\n    <span class="hljs-variable language_">window</span>.<span class="hljs-property">pageEnterTime</span> = performance.<span class="hljs-title function_">now</span>();\n  }\n});\n</code></pre>\n<h3><strong>(2) React Router 示例</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 使用 useEffect 监听路由变化（React Router v6）</span>\n<span class="hljs-keyword">import</span> { useLocation } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">usePageEnterTracking</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> location = <span class="hljs-title function_">useLocation</span>();\n  <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;SPA 页面进入:&quot;</span>, location.<span class="hljs-property">pathname</span>);\n    <span class="hljs-variable language_">window</span>.<span class="hljs-property">pageEnterTime</span> = performance.<span class="hljs-title function_">now</span>();\n  }, [location.<span class="hljs-property">pathname</span>]); <span class="hljs-comment">// 依赖路径变化</span>\n}\n</code></pre>\n<p><strong>注意</strong>   ：</p>\n<ul>\n<li>SPA 中需区分“同一路由参数变化”（如 <code>/user/1</code> → <code>/user/2</code>）和“真正页面切换”。</li>\n<li>可通过比较 <code>from.path</code> 和 <code>to.path</code> 避免重复统计。</li>\n</ul>\n<hr>\n<h2><strong>3. 结合 <code>performance.now()</code> 记录精确时间</strong></h2>\n<p>为了统计用户从进入页面到其他行为（如点击、离开）的时间，需记录页面进入的精确时间戳。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在 DOMContentLoaded 或路由变化时记录</span>\n<span class="hljs-variable language_">window</span>.<span class="hljs-property">pageEnterTime</span> = performance.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 高精度时间戳（毫秒）</span>\n\n<span class="hljs-comment">// 后续可通过 performance.now() - pageEnterTime 计算停留时间</span>\n</code></pre>\n<p><strong>优势</strong>   ：</p>\n<ul>\n<li><code>performance.now()</code> 比 <code>Date.now()</code> 更精确，适合性能分析。</li>\n<li>避免受系统时间修改的影响。</li>\n</ul>\n<hr>\n<h2><strong>4. 监听页面可见性变化（<code>visibilitychange</code>）</strong></h2>\n<p>如果用户切换标签页或最小化浏览器，页面可能进入后台。此时需结合 <code>visibilitychange</code> 监听“真正可见的页面进入”。</p>\n<pre><code class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;visibilitychange&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">visibilityState</span> === <span class="hljs-string">&quot;visible&quot;</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;页面重新变为可见（用户切换回标签页）&quot;</span>);\n    <span class="hljs-comment">// 可以视为一次新的“页面进入”</span>\n    <span class="hljs-variable language_">window</span>.<span class="hljs-property">pageEnterTime</span> = performance.<span class="hljs-title function_">now</span>();\n  }\n});\n</code></pre>\n<p><strong>适用场景</strong>   ：</p>\n<ul>\n<li>统计用户实际浏览页面的时间（排除后台停留）。</li>\n<li>避免因标签页切换导致的数据误差。</li>\n</ul>\n<hr>\n<h2><strong>5. 数据上报：如何发送页面进入事件？</strong></h2>\n<h3><strong>(1) 使用 <code>navigator.sendBeacon</code>（推荐）</strong></h3>\n<p>在页面进入时立即上报数据，确保即使用户快速关闭页面也能成功发送。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendPageEnterEvent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>(\n    [\n      <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({\n        <span class="hljs-attr">event</span>: <span class="hljs-string">&quot;page_enter&quot;</span>,\n        <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(),\n        <span class="hljs-attr">url</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>,\n        <span class="hljs-attr">referrer</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-property">referrer</span>,\n      }),\n    ],\n    { <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;application/json&quot;</span> },\n  );\n\n  navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&quot;/api/log-page-enter&quot;</span>, data);\n}\n\n<span class="hljs-comment">// 在 DOMContentLoaded 中调用</span>\n<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">sendPageEnterEvent</span>();\n});\n</code></pre>\n<p><strong>优势</strong>   ：</p>\n<ul>\n<li>浏览器会保证请求完成，即使页面卸载。</li>\n<li>适合关键事件上报（如 PV 统计）。</li>\n</ul>\n<h3><strong>(2) 使用 <code>Image</code> 对象（兼容旧浏览器）</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendPageEnterEvent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();\n  img.<span class="hljs-property">src</span> = <span class="hljs-string">`/api/log-page-enter?timestamp=<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>&amp;url=<span class="hljs-subst">${<span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-variable language_">window</span>.location.href)}</span>`</span>;\n}\n</code></pre>\n<p><strong>注意</strong>   ：</p>\n<ul>\n<li>可能被浏览器拦截（如跨域限制）。</li>\n<li>不如 <code>sendBeacon</code> 可靠。</li>\n</ul>\n<hr>\n<h2><strong>6. 完整代码示例（综合方案）</strong></h2>\n<pre><code class="language-javascript"><span class="hljs-comment">// 1. 记录页面进入时间</span>\n<span class="hljs-keyword">let</span> pageEnterTime = <span class="hljs-number">0</span>;\n\n<span class="hljs-comment">// 2. 监听 DOM 加载完成（非 SPA）</span>\n<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  pageEnterTime = performance.<span class="hljs-title function_">now</span>();\n  <span class="hljs-title function_">sendPageEnterEvent</span>();\n});\n\n<span class="hljs-comment">// 3. 监听路由变化（SPA）</span>\n<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">router</span> !== <span class="hljs-string">&quot;undefined&quot;</span>) {\n  <span class="hljs-comment">// 假设已初始化路由</span>\n  router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> {\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span>.<span class="hljs-property">path</span> !== to.<span class="hljs-property">path</span>) {\n      pageEnterTime = performance.<span class="hljs-title function_">now</span>();\n      <span class="hljs-title function_">sendPageEnterEvent</span>();\n    }\n  });\n}\n\n<span class="hljs-comment">// 4. 监听页面可见性变化</span>\n<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;visibilitychange&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">visibilityState</span> === <span class="hljs-string">&quot;visible&quot;</span>) {\n    pageEnterTime = performance.<span class="hljs-title function_">now</span>();\n    <span class="hljs-title function_">sendPageEnterEvent</span>();\n  }\n});\n\n<span class="hljs-comment">// 5. 上报函数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">sendPageEnterEvent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>(\n    [\n      <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({\n        <span class="hljs-attr">event</span>: <span class="hljs-string">&quot;page_enter&quot;</span>,\n        <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(),\n        <span class="hljs-attr">url</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>,\n        <span class="hljs-attr">referrer</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-property">referrer</span>,\n        <span class="hljs-attr">enterTime</span>: pageEnterTime,\n      }),\n    ],\n    { <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;application/json&quot;</span> },\n  );\n\n  navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&quot;/api/log-page-enter&quot;</span>, data);\n}\n</code></pre>\n<hr>\n<h2><strong>7. 特殊场景处理</strong></h2>\n<h3><strong>(1) 移动端兼容性</strong></h3>\n<ul>\n<li>iOS Safari 对 <code>visibilitychange</code> 的支持可能不一致，需测试目标设备。</li>\n<li>部分安卓浏览器可能限制 <code>sendBeacon</code>，可降级为 <code>Image</code> 对象。</li>\n</ul>\n<h3><strong>(2) 广告拦截器干扰</strong></h3>\n<ul>\n<li>某些广告拦截插件会屏蔽 <code>sendBeacon</code> 请求，需：\n<ul>\n<li>使用隐蔽的 URL 路径（如 <code>/log</code> 而非 <code>/beacon</code>）。</li>\n<li>提供降级方案（如本地存储 + 定时上报）。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>(3) bfcache（Back-Forward Cache）</strong></h3>\n<ul>\n<li>当用户通过后退按钮返回页面时，浏览器可能从缓存恢复页面，此时：\n<ul>\n<li><code>DOMContentLoaded</code> 和 <code>load</code> 不会再次触发。</li>\n<li>需监听 <code>pageshow</code> 事件：<pre><code class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;pageshow&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">persisted</span>) {\n    <span class="hljs-comment">// 从 bfcache 恢复</span>\n    pageEnterTime = performance.<span class="hljs-title function_">now</span>();\n    <span class="hljs-title function_">sendPageEnterEvent</span>();\n  }\n});\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2><strong>8. 总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐方法</th>\n<th>关键事件/API</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>传统多页应用</strong></td>\n<td><code>DOMContentLoaded</code> + <code>sendBeacon</code></td>\n<td><code>performance.now()</code></td>\n</tr>\n<tr>\n<td><strong>单页应用（SPA）</strong></td>\n<td>路由变化监听（<code>beforeEach</code> 或 <code>useEffect</code>）</td>\n<td>Vue Router / React Router</td>\n</tr>\n<tr>\n<td><strong>标签页切换</strong></td>\n<td><code>visibilitychange</code></td>\n<td><code>document.visibilityState</code></td>\n</tr>\n<tr>\n<td><strong>bfcache 恢复</strong></td>\n<td><code>pageshow</code> 事件</td>\n<td><code>event.persisted</code></td>\n</tr>\n<tr>\n<td><strong>数据上报</strong></td>\n<td><code>navigator.sendBeacon</code></td>\n<td>异步、可靠</td>\n</tr>\n</tbody>\n</table>\n<p><strong>最佳实践</strong>   ：</p>\n<ol>\n<li><strong>优先使用 <code>DOMContentLoaded</code></strong>   监听页面进入（SPA 需结合路由）。</li>\n<li><strong>通过 <code>visibilitychange</code> 统计用户实际浏览时间</strong>   （排除后台停留）。</li>\n<li><strong>用 <code>sendBeacon</code> 上报数据</strong>   ，确保可靠性。</li>\n<li><strong>处理 bfcache 和移动端兼容性</strong>   ，避免数据遗漏。</li>\n</ol>\n<p>这样可以全面、准确地监控用户进入页面的行为！ 🚀</p>\n</div>'</script></body></html>