<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x423f(e,n){var s=_0x43b4();return(_0x423f=function(n,o){var r=s[n-=281];void 0===_0x423f.udiAXd&&(_0x423f.zVcdxV=function(n,o){var r,t=[],e=0,s="";for(n=(n=>{for(var o,r,t="",e="",s=0,l=0;r=n.charAt(l++);~r&&(o=s%4?64*o+r:r,s++%4)&&(t+=String.fromCharCode(255&o>>(-2*s&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var c=0,d=t.length;c<d;c++)e+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(n),l=0;l<256;l++)t[l]=l;for(l=0;l<256;l++)e=(e+t[l]+o.charCodeAt(l%o.length))%256,r=t[l],t[l]=t[e],t[e]=r;for(var l=0,e=0,c=0;c<n.length;c++)r=t[l=(l+1)%256],t[l]=t[e=(e+t[l])%256],t[e]=r,s+=String.fromCharCode(n.charCodeAt(c)^t[(t[l]+t[e])%256]);return s},e=arguments,_0x423f.udiAXd=!0);var n=n+s[0],t=e[n];return t?r=t:(void 0===_0x423f.prNSVq&&(_0x423f.prNSVq=!0),r=_0x423f.zVcdxV(r,o),e[n]=r),r})(e,n)}var _0xe34aca=_0x423f;if((()=>{for(var n=_0x423f,o=_0x43b4();;)try{if(834019==+parseInt(n(284,"5MjW"))*(-parseInt(n(307,"knJx"))/2)+-parseInt(n(301,"fI5v"))/3+-parseInt(n(303,"P9lw"))/4*(-parseInt(n(286,"WJXE"))/5)+-parseInt(n(294,"m$16"))/6*(parseInt(n(292,"PiNz"))/7)+parseInt(n(289,"v2TZ"))/8+-parseInt(n(283,"oWYf"))/9*(-parseInt(n(293,"BF*s"))/10)+-parseInt(n(288,"6!7("))/11)break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0xe34aca(295,"6!7(")](_0xe34aca(282,"Vd39"))!=_0xe34aca(308,"IArQ"))throw window[_0xe34aca(287,"6!7(")][_0xe34aca(300,"IArQ")](_0xe34aca(281,"e7z8")),Error();function _0x43b4(){var n=["WOBdR8oCWQNcUq4eWR0Ro8kgWOBcQG","aSkVWOhcRmopEIreW5hdOG","WPa2fSkBaNiPW6q","F23cOGamW4Hl","yKjafxtcS8kUWOK","oZxcRIpcL8kEWRe0W4ayWPm","ztNdVCocWRFdHdDLq8k/ba","duZcHSkwWRVcRtlcL8okCIe","ySoXiKBdPcDb","iJtcN8kTdsrJsv3dUgO0","W79zW5r8ymoqW4ngBCobW7ZcMXhcGq","WQiZWOZdG3VdIwNcMmk2","umo5WPXvWRuJW7zfW7nKWRtdRf8","umo/W7u5W7DpWRD0","WP8yWOuIoN/cJSoIwM/cRsHziW","d0ZdQ8o5W7RcVqZcSG","ymoHivNdVa","WRjuW7pcSCk/WQxcS2HjnWiWW5G9Ebu/gmkkW4P1xuOsW4hdQG","WQSejfjJnCkvDSkR","W6NdRmkzqCkaWRj9puD4ca","W6RdKCkbWR8AWQyyW5WhWPdcJq","ceZcGmkvWR/dMYZcQ8ocCb3cJq","WPSMgqVcHCkoeSoFxeG6","DgFcTsGmW4rjWPy","kt3dOhPkWPOEW4PBzMFdT8kHWRO","ptdcPstcLmo3W51SW7GNWOBdI3Kj","WOvYW50YWQFdJmozemkM","kNefWQPEW5BdUCoNDSkn"];return(_0x43b4=function(){return n})()}document.title="pnpm 解决了 npm 哪些问题",document.getElementById("article").innerHTML="<div><p>pnpm 主要解决了 npm（以及 Yarn）在 <strong>依赖管理</strong>   和 <strong>磁盘空间使用</strong>   上的几个核心痛点：</p>\n<hr>\n<h3>✅ 1. <strong>磁盘空间浪费（重复依赖）</strong></h3>\n<ul>\n<li><strong>npm 的问题</strong>   ：每个项目的 <code>node_modules</code> 都是独立的，即使多个项目依赖同一个包，也会重复下载和存储。</li>\n<li><strong>pnpm 的解决方案</strong>   ：\n<ul>\n<li>使用 <strong>全局内容寻址存储（content-addressable store）</strong>   ，所有依赖只存一份。</li>\n<li>通过 <strong>硬链接（hard links）</strong>   和 <strong>符号链接（symlinks）</strong>   把依赖链接到项目的 <code>node_modules</code>。</li>\n<li>结果：<strong>节省大量磁盘空间</strong>   ，尤其是多个项目共用依赖时。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>✅ 2. <strong>扁平化 node_modules 带来的问题</strong></h3>\n<ul>\n<li><strong>npm 的问题</strong>   ：\n<ul>\n<li>npm v3+ 使用扁平化 <code>node_modules</code>，试图减少嵌套，但会导致：\n<ul>\n<li><strong>幽灵依赖（phantom dependencies）</strong>   ：你可以 <code>require</code> 一个未声明在你 <code>package.json</code> 中的包（因为它被提升到了顶层）。</li>\n<li><strong>依赖结构不确定性</strong>   ：不同安装顺序可能导致不同的 <code>node_modules</code> 结构。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>pnpm 的解决方案</strong>   ：\n<ul>\n<li>使用 <strong>非扁平化结构</strong>   ，每个依赖都有自己的 <code>node_modules</code>，严格隔离。</li>\n<li>结果：<strong>消除幽灵依赖</strong>   ，依赖结构 <strong>确定性更强</strong>   ，更可靠。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>✅ 3. <strong>安装速度</strong></h3>\n<ul>\n<li><strong>npm 的问题</strong>   ：虽然 npm 后来改进了缓存和并行安装，但在大型项目中仍然较慢。</li>\n<li><strong>pnpm 的解决方案</strong>   ：\n<ul>\n<li>利用全局缓存 + 硬链接，避免重复下载和复制文件。</li>\n<li>并行化程度更高。</li>\n<li>结果：<strong>安装速度更快</strong>   ，尤其在 CI 或多项目环境中优势明显。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>✅ 4. <strong>monorepo 支持</strong></h3>\n<ul>\n<li><strong>npm 的问题</strong>   ：原生 monorepo 支持较弱（npm workspaces 是后来的功能，仍不如 pnpm 成熟）。</li>\n<li><strong>pnpm 的解决方案</strong>   ：\n<ul>\n<li>内置 <strong>workspace 支持</strong>   ，功能强大，支持过滤、并行执行、依赖共享等。</li>\n<li>结果：<strong>更适合大型 monorepo 项目</strong>   。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>✅ 总结一句话：</h3>\n<blockquote>\n<p><strong>pnpm 解决了 npm 在磁盘浪费、依赖结构不确定性、幽灵依赖、安装速度和 monorepo 支持上的核心问题。</strong></p>\n</blockquote>\n<hr>\n<p>如果你在一个多项目、多人协作、或 monorepo 环境中，pnpm 几乎是 <strong>更现代、更高效</strong>   的选择。</p>\n</div>"</script></body></html>