<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x599c74=_0x27d2;function _0x282c(){var n=["W5/dR2hcQeNdSGldQNtdV8oCWO1hWPm","W4dcUapcTCkKc8oqBX/dJLtcMG","W71fWR86W7ldHLu","W7xdUCkCth1/sH/dGchcSYO","yvaGWQCnW57dHxiia8kdmq","bCoSW6LNWOtcVqnGx8ozteC","WRLAWQGiW6W","WOvel8krwLBdH18","W4ryW6PUx8kzbYhdNxqyeW","W4FdUmkPWOLsrSodWOpcMZblyW","WOxcGLP8j8kKFSkF","b8kYWRuqW5hdQJ8","WOlcIvfhaCkvt8ku","DCkcf8kUW7PKW5RdMCoLqCoUW74+fa","eSoFnuTLW71xW73dVWDE","lXyQWPhcVSkieSoLmsddKG","w8kOW7pcO8kOW7JcGadcVmkcFmkNW5u","W69xWPPEWRm3WOi","WQldJmold1ddVaj/","W5O+iCo+Bmk/W6VcLa","emkfW6ldRmo9d8knWRC","fCoEo09VWOjUW7xdTqHbma","WQ3dHr/dVIBcV8kOWQW","bSo1WQddTSoLWQpdMGe","W5xcN8oYb0RdMZH3Aq","W7vgWP5cWQfUW4GxyN0eW5ywWRbHWOvmWORdR3mbyCkBgH7dGq","W6GFld1GW6RdM8orW5CAWR9u","jLxdNCoRW6KHsGhcIXBdPqVdTa","fCkhW6NdSCo8k8kzWOS","W7pcMCoLk03dJr4"];return(_0x282c=function(){return n})()}function _0x27d2(t,n){var o=_0x282c();return(_0x27d2=function(n,l){var i=o[n-=369];void 0===_0x27d2.jkHfnQ&&(_0x27d2.qUwkwE=function(n,l){var i,r=[],t=0,o="";for(n=(n=>{for(var l,i,r="",t="",o=0,s=0;i=n.charAt(s++);~i&&(l=o%4?64*l+i:i,o++%4)&&(r+=String.fromCharCode(255&l>>(-2*o&6))))i="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(i);for(var e=0,u=r.length;e<u;e++)t+="%"+("00"+r.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(n),s=0;s<256;s++)r[s]=s;for(s=0;s<256;s++)t=(t+r[s]+l.charCodeAt(s%l.length))%256,i=r[s],r[s]=r[t],r[t]=i;for(var s=0,t=0,e=0;e<n.length;e++)i=r[s=(s+1)%256],r[s]=r[t=(t+r[s])%256],r[t]=i,o+=String.fromCharCode(n.charCodeAt(e)^r[(r[s]+r[t])%256]);return o},t=arguments,_0x27d2.jkHfnQ=!0);var n=n+o[0],r=t[n];return r?i=r:(void 0===_0x27d2.JPkEwx&&(_0x27d2.JPkEwx=!0),i=_0x27d2.qUwkwE(i,l),t[n]=i),i})(t,n)}if((()=>{for(var n=_0x27d2,l=_0x282c();;)try{if(751208==-parseInt(n(397,"Z]dh"))+parseInt(n(383,"EfqN"))/2*(parseInt(n(384,"mNns"))/3)+-parseInt(n(395,"EG)%"))/4*(parseInt(n(388,"Rl]f"))/5)+parseInt(n(377,"ySP("))/6*(-parseInt(n(370,"L^3d"))/7)+-parseInt(n(391,"*[AU"))/8*(-parseInt(n(389,"TP[S"))/9)+parseInt(n(369,"8cS5"))/10*(-parseInt(n(372,"EG)%"))/11)+parseInt(n(394,"A)9A"))/12)break;l.push(l.shift())}catch(n){l.push(l.shift())}})(),localStorage[_0x599c74(380,"8cS5")](_0x599c74(375,"8cS5"))!=_0x599c74(387,"EfqN"))throw window[_0x599c74(374,"Z]dh")][_0x599c74(398,"bYa%")](_0x599c74(376,"bYa%")),Error();document.title="flux 思想",document.getElementById("article").innerHTML="<div><h3><strong>Flux 思想简述</strong></h3>\n<p>Flux 是一种应用架构思想，最初由 Facebook 提出，用于构建大型、复杂的前端应用。它的核心目标是解决传统 MVC 架构中数据流混乱的问题，通过单向数据流和集中式调度，使应用的状态管理更加清晰和可预测。</p>\n<hr>\n<h3><strong>1. 核心思想</strong></h3>\n<ul>\n<li><strong>单向数据流</strong>  ：\n<ul>\n<li>数据在应用中只能沿着一个方向流动，即从外部（如用户交互）到 Dispatcher，再到 Stores，最后到 Views。</li>\n<li>这种单向流动使得数据的变化更加可预测，便于调试和维护。</li>\n</ul>\n</li>\n<li><strong>集中式调度</strong>  ：\n<ul>\n<li>Dispatcher 是 Flux 架构的核心，负责接收所有的动作（Actions）并将其分发到相应的 Stores。</li>\n<li>Dispatcher 确保每个动作都被正确处理，并且 Stores 的更新是同步的。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>2. 主要组件</strong></h3>\n<p>Flux 架构主要由四个部分组成：</p>\n<ul>\n<li><strong>Dispatcher</strong>  ：\n<ul>\n<li>中央调度器，接收 Actions 并将其分发到相应的 Stores。</li>\n<li>确保每个 Action 都被正确处理，并且 Stores 的更新是同步的。</li>\n</ul>\n</li>\n<li><strong>Stores</strong>  ：\n<ul>\n<li>存储应用的状态和数据。</li>\n<li>监听 Dispatcher 分发的 Actions，并根据 Actions 更新自身的状态。</li>\n<li>当状态发生变化时，通知 Views 进行更新。</li>\n</ul>\n</li>\n<li><strong>Views（React Components）</strong>  ：\n<ul>\n<li>负责渲染用户界面。</li>\n<li>从 Stores 中获取数据，并在数据发生变化时重新渲染。</li>\n<li>用户交互（如点击按钮）会触发 Actions。</li>\n</ul>\n</li>\n<li><strong>Actions</strong>  ：\n<ul>\n<li>描述应用中的事件或用户交互。</li>\n<li>通常是简单的 JavaScript 对象，包含类型（type）和可选的数据（payload）。</li>\n<li>通过 Dispatcher 发送，触发 Stores 的更新。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>3. 数据流过程</strong></h3>\n<ol>\n<li><strong>用户交互</strong>  ：\n<ul>\n<li>用户在 View 上进行交互（如点击按钮）。</li>\n</ul>\n</li>\n<li><strong>触发 Action</strong>  ：\n<ul>\n<li>View 调用 Action Creator 创建一个 Action，并通过 Dispatcher 发送。</li>\n</ul>\n</li>\n<li><strong>Dispatcher 分发 Action</strong>  ：\n<ul>\n<li>Dispatcher 接收 Action，并将其分发到所有注册的 Stores。</li>\n</ul>\n</li>\n<li><strong>Stores 更新状态</strong>  ：\n<ul>\n<li>Stores 监听 Dispatcher 分发的 Actions，根据 Action 的类型更新自身的状态。</li>\n</ul>\n</li>\n<li><strong>通知 Views</strong>  ：\n<ul>\n<li>当 Stores 的状态发生变化时，通知 Views 进行更新。</li>\n<li>Views 从 Stores 中获取最新的数据，并重新渲染。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>4. Flux 的优点</strong></h3>\n<ul>\n<li><strong>清晰的数据流</strong>  ：\n<ul>\n<li>单向数据流使得数据的变化更加可预测，便于调试和维护。</li>\n</ul>\n</li>\n<li><strong>集中式调度</strong>  ：\n<ul>\n<li>Dispatcher 确保 Actions 的处理是同步的，避免了数据不一致的问题。</li>\n</ul>\n</li>\n<li><strong>可预测的状态管理</strong>  ：\n<ul>\n<li>Stores 负责管理应用的状态，使得状态的变化更加集中和可控。</li>\n</ul>\n</li>\n<li><strong>易于扩展</strong>  ：\n<ul>\n<li>Flux 架构的模块化设计使得应用易于扩展和维护。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>5. Flux 的缺点</strong></h3>\n<ul>\n<li><strong>代码冗余</strong>  ：\n<ul>\n<li>Flux 架构需要编写大量的样板代码，如 Dispatcher 的注册、Stores 的监听等。</li>\n</ul>\n</li>\n<li><strong>复杂性</strong>  ：\n<ul>\n<li>对于小型应用，Flux 架构可能显得过于复杂，增加了开发成本。</li>\n</ul>\n</li>\n<li><strong>学习曲线</strong>  ：\n<ul>\n<li>Flux 的概念和架构对于初学者来说可能较难理解。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>6. Flux 的变体</strong></h3>\n<p>为了简化 Flux 的实现和减少样板代码，社区出现了许多 Flux 的变体，如：</p>\n<ul>\n<li><strong>Redux</strong>  ：\n<ul>\n<li>最流行的 Flux 变体，简化了 Store 的管理，引入了单一 Store 和纯函数 Reducer 的概念。</li>\n</ul>\n</li>\n<li><strong>MobX</strong>  ：\n<ul>\n<li>通过可观察的状态和自动追踪依赖，简化了状态管理。</li>\n</ul>\n</li>\n<li><strong>Alt</strong>  ：\n<ul>\n<li>提供了更简洁的 API 和更好的开发体验。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>Flux 是一种应用架构思想，通过单向数据流和集中式调度，解决了传统 MVC 架构中数据流混乱的问题。它的核心组件包括 Dispatcher、Stores、Views 和 Actions，通过清晰的数据流过程，使得应用的状态管理更加可预测和可控。虽然 Flux 架构在小型应用中可能显得过于复杂，但对于大型、复杂的前端应用，它提供了一种有效的状态管理方案。随着技术的发展，Flux 的变体（如 Redux）进一步简化了状态管理，使得 Flux 思想得到了更广泛的应用。</p>\n</div>"</script></body></html>