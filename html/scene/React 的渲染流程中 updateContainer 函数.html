<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1fc94e=_0x5b31;function _0x4b02(){var n=["v8knW5jgxmoin8of","w1DpDSofz8oKW6G1fmkkW7hdP3y","v27dRSkKvHKnW7FcJbiZ","s8o2wCkeW7ihWQiv","W73cP3XYxa","eSkjkGddNM4+W4euWO9IWOmCsa","WRxdUmkdWPZdKCoCdCkIWRy1WPu7","W63dQGmvfCksxMlcVWmyW78","WO1hW7qoWQnwW78KWPJcQmkMW6m","uCoAyLJcHJ9O","F8kpoWWkBw1OWRS","tc7cPhiBu2ddIq","WOZdRmo/WQaad2quWOpcG0/cHvG","W6hcR8oeW6dcNCkjbq","w1DeDSofBCoLWRyxaCkPW4NdGW","eYpcR8kcpSklW78YW6TmjmkO","zmk4oCkgW5NcUSkGjCkKfrjZ","kt3cPmkwFSoMW7lcONayo8k2","vInCDSkkW6fHW4OCWOpcKSku","g8kHW4ldRCkcnmoGfa","ocpdKSkOW4C8rCopaW","WRpdU8kaWPJdMSoEhSkeWRC4WP0P","fM3cLNCVlZZcLaBdNKqtbf/dSKz+W77cMmk5DwJcJe0MWQO","aSkAWR3dQJ1CACo4ia","W4tdVe4noColWQpdLa","W43dVbnxrmorWOhdQSoQWQtdSq"];return(_0x4b02=function(){return n})()}function _0x5b31(o,n){var a=_0x4b02();return(_0x5b31=function(n,e){var s=a[n-=138];void 0===_0x5b31.aNOAHA&&(_0x5b31.KTOzqH=function(n,e){var s,t=[],o=0,a="";for(n=(n=>{for(var e,s,t="",o="",a=0,l=0;s=n.charAt(l++);~s&&(e=a%4?64*e+s:s,a++%4)&&(t+=String.fromCharCode(255&e>>(-2*a&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var r=0,c=t.length;r<c;r++)o+="%"+("00"+t.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(o)})(n),l=0;l<256;l++)t[l]=l;for(l=0;l<256;l++)o=(o+t[l]+e.charCodeAt(l%e.length))%256,s=t[l],t[l]=t[o],t[o]=s;for(var l=0,o=0,r=0;r<n.length;r++)s=t[l=(l+1)%256],t[l]=t[o=(o+t[l])%256],t[o]=s,a+=String.fromCharCode(n.charCodeAt(r)^t[(t[l]+t[o])%256]);return a},o=arguments,_0x5b31.aNOAHA=!0);var n=n+a[0],t=o[n];return t?s=t:(void 0===_0x5b31.TRaqRv&&(_0x5b31.TRaqRv=!0),s=_0x5b31.KTOzqH(s,e),o[n]=s),s})(o,n)}if((()=>{for(var n=_0x5b31,e=_0x4b02();;)try{if(290663==-parseInt(n(163,"Zy^i"))+-parseInt(n(157,"0Bp&"))/2*(parseInt(n(155,"D5l8"))/3)+-parseInt(n(161,"T9FC"))/4*(parseInt(n(153,"EYBe"))/5)+parseInt(n(141,"#*T("))/6+-parseInt(n(150,"T9FC"))/7+-parseInt(n(145,"vyp6"))/8*(parseInt(n(139,"HmXQ"))/9)+parseInt(n(156,"Bkzc"))/10)break;e.push(e.shift())}catch(n){e.push(e.shift())}})(),localStorage[_0x1fc94e(142,"T9FC")](_0x1fc94e(152,"WS$!"))!=_0x1fc94e(159,"hRMF"))throw window[_0x1fc94e(148,"s0Bl")][_0x1fc94e(138,"2wmG")](_0x1fc94e(151,"3(IH")),Error();document.title="React 的渲染流程中 updateContainer 函数",document.getElementById("article").innerHTML='<div><p>在 React 的渲染流程中，<code>updateContainer</code> 是一个关键函数，负责调度和触发组件的更新。它通常在以下场景被调用：</p>\n<ol>\n<li><strong>首次渲染</strong>  （如 <code>ReactDOM.render</code> 或 <code>createRoot().render()</code>）。</li>\n<li><strong>状态更新</strong>  （如 <code>setState</code>、<code>useState</code> 触发的重新渲染）。</li>\n<li><strong>外部触发更新</strong>  （如 <code>forceUpdate</code> 或 Context 变化）。</li>\n</ol>\n<hr>\n<h3><strong><code>updateContainer</code> 的核心流程</strong></h3>\n<p><code>updateContainer</code> 的主要作用是：</p>\n<ol>\n<li><strong>计算更新优先级</strong>  （基于事件的优先级，如用户交互 vs 后台渲染）。</li>\n<li><strong>创建更新对象</strong>  （<code>Update</code>），描述需要渲染的内容。</li>\n<li><strong>将更新加入队列</strong>  ，并调度渲染任务。</li>\n</ol>\n<h4><strong>1. 调用链路</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// ReactDOM.render 或类似 API 触发</span>\n<span class="hljs-title function_">legacyRenderSubtreeIntoContainer</span>()\n  → <span class="hljs-title function_">updateContainer</span>(children, fiberRoot, parentComponent, callback)\n    → <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiberRoot, lane) <span class="hljs-comment">// 调度更新</span>\n      → <span class="hljs-title function_">ensureRootIsScheduled</span>(root, lane)    <span class="hljs-comment">// 确保根节点被调度</span>\n</code></pre>\n<h4><strong>2. 关键步骤</strong></h4>\n<h5><strong>(1) 计算优先级（Lane）</strong></h5>\n<ul>\n<li>React 使用 <strong>Lane 模型</strong>  （React 17+）或 <strong>ExpirationTime</strong>  （旧版）标记更新的优先级。</li>\n<li>例如：\n<ul>\n<li>用户点击事件 → <strong>同步优先级（SyncLane）</strong>  。</li>\n<li>普通状态更新 → <strong>默认优先级（DefaultLane）</strong>  。</li>\n</ul>\n</li>\n</ul>\n<h5><strong>(2) 创建更新对象（Update）</strong></h5>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> update = {\n  lane,          <span class="hljs-comment">// 优先级</span>\n  <span class="hljs-attr">payload</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 更新的内容（如新的 ReactElement）</span>\n  callback,      <span class="hljs-comment">// 渲染完成后的回调</span>\n  <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,    <span class="hljs-comment">// 指向下一个更新（链表结构）</span>\n};\n</code></pre>\n<ul>\n<li>更新会被添加到 <code>Fiber</code> 节点的 <code>updateQueue</code> 链表中（批处理多个更新）。</li>\n</ul>\n<h5><strong>(3) 调度更新（scheduleUpdateOnFiber）</strong></h5>\n<ul>\n<li>标记从当前 <code>Fiber</code> 到 <code>FiberRoot</code> 的所有父节点为“需要更新”。</li>\n<li>调用 <code>ensureRootIsScheduled</code> 安排任务：\n<ul>\n<li><strong>同步模式</strong>  ：立即执行 <code>performSyncWorkOnRoot</code>。</li>\n<li><strong>并发模式</strong>  ：通过 <code>Scheduler</code> 调度 <code>performConcurrentWorkOnRoot</code>（可中断）。</li>\n</ul>\n</li>\n</ul>\n<h5><strong>(4) 进入渲染流程</strong></h5>\n<ul>\n<li>根据优先级进入 <strong>Render 阶段</strong>  （构建 Fiber 树）和 <strong>Commit 阶段</strong>  （更新 DOM）。</li>\n</ul>\n<hr>\n<h3><strong>3. 源码关键片段（简化版）</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateContainer</span>(<span class="hljs-params">\n  element: ReactNodeList,\n  container: OpaqueRoot,\n  parentComponent: ?React$Component&lt;any, any&gt;,\n  callback: ?<span class="hljs-built_in">Function</span>,\n</span>): <span class="hljs-title class_">Lane</span> {\n  <span class="hljs-keyword">const</span> current = container.<span class="hljs-property">current</span>; <span class="hljs-comment">// 当前 RootFiber</span>\n  <span class="hljs-keyword">const</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(current); <span class="hljs-comment">// 计算优先级</span>\n\n  <span class="hljs-comment">// 创建更新对象</span>\n  <span class="hljs-keyword">const</span> update = {\n    lane,\n    <span class="hljs-attr">payload</span>: { element }, <span class="hljs-comment">// 要渲染的新元素</span>\n    callback,\n    <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,\n  };\n\n  <span class="hljs-comment">// 将更新加入队列</span>\n  <span class="hljs-title function_">enqueueUpdate</span>(current, update);\n\n  <span class="hljs-comment">// 调度更新</span>\n  <span class="hljs-title function_">scheduleUpdateOnFiber</span>(current, lane);\n  <span class="hljs-keyword">return</span> lane;\n}\n</code></pre>\n<hr>\n<h3><strong>4. 与 Fiber 架构的关系</strong></h3>\n<ul>\n<li><code>updateContainer</code> 是 <strong>触发协调（Reconciliation）的入口</strong>  。</li>\n<li>它不直接操作 DOM，而是通过 Fiber 树的调度机制：\n<ul>\n<li><strong>Render 阶段</strong>  ：生成新的 Fiber 树并标记副作用（如 <code>Placement</code>、<code>Update</code>）。</li>\n<li><strong>Commit 阶段</strong>  ：应用副作用到 DOM。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>5. 特殊场景处理</strong></h3>\n<ul>\n<li><strong>批量更新</strong>  ：多个 <code>setState</code> 会被合并为一个更新（通过 <code>updateQueue</code> 链表）。</li>\n<li><strong>高优先级打断</strong>  ：在并发模式下，高优先级任务（如用户输入）可以中断低优先级渲染。</li>\n<li><strong>服务端渲染（SSR）</strong>  ：<code>updateContainer</code> 在客户端注水（Hydration）时触发。</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<p><code>updateContainer</code> 的核心作用：</p>\n<ol>\n<li><strong>封装更新信息</strong>  （优先级、新内容、回调）。</li>\n<li><strong>触发调度</strong>  ，推动 Fiber 树的协调和提交。</li>\n<li><strong>衔接 React 的渲染机制</strong>  （同步/并发模式、优先级调度）。</li>\n</ol>\n<p>它是连接“应用代码”和“React 底层渲染引擎”的桥梁。</p>\n</div>'</script></body></html>