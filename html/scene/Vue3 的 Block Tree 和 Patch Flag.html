<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5070(t,s){var p=_0x3131();return(_0x5070=function(s,n){var a=p[s-=182];void 0===_0x5070.BFchGw&&(_0x5070.VPcraz=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,c=0;a=s.charAt(c++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,o=l.length;e<o;e++)t+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)t=(t+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[t],l[t]=a;for(var c=0,t=0,e=0;e<s.length;e++)a=l[c=(c+1)%256],l[c]=l[t=(t+l[c])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(e)^l[(l[c]+l[t])%256]);return p},t=arguments,_0x5070.BFchGw=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x5070.Wxycbr&&(_0x5070.Wxycbr=!0),a=_0x5070.VPcraz(a,n),t[s]=a),a})(t,s)}function _0x3131(){var s=["eCkdr8kWWQRdS8o8WR9mWRFdJmkRWRW","h8kZWOddT8o+W7yngLxdUmoXCN4","WQ3dMqHAWQHOrmoDWOyczx/dKaC","vrdcRdbudCkaW5tdKb7dOCoXtSkKW7CqkIJdMmkdW4dcQwe5z8kh","WPuDWRu8W6BdJ8o1WQ3cKG","iMdcI8opicHTW4tdPSohWPhcH8kr","W5BcL2RcNSoSeSo1W6ivW7NcO8od","fZOXW5BdHID1WO01W4pcH8ojtG","n1ruWQxcTG","BmkOWP7cPXlcUNu","W5Pwp27dQtRdVsZcQCo5W4/dV8kF","W7ldJrNdPtCKtuS","hSkdrmk7WQVdTmkDWPnqWO7dLCkl","WOOYW7flW6KmWQVdHCo5ySokkW","W4VcJSoBjCk5WOmD","k8o0W5FdUKddQ2NdH8oLna7dQq","vCkDW47cNY9AdSkqpCkJDSkAy8kS","WPSLW5WCWPLeW7HhWPuqamoC","W61kW6zTWQhcJCkmWRhcSSkWWRW1W6W","WQZcM0VcSNf/uvWMW5dcSwW"];return(_0x3131=function(){return s})()}var _0x3be58c=_0x5070;if((()=>{for(var s=_0x5070,n=_0x3131();;)try{if(903301==+parseInt(s(188,"htwR"))+parseInt(s(195,"YilH"))/2+-parseInt(s(199,"nU^%"))/3+-parseInt(s(182,"l[84"))/4+-parseInt(s(183,"@vSZ"))/5+parseInt(s(200,"qYU&"))/6+parseInt(s(198,"EyWv"))/7)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3be58c(196,"*p(@")](_0x3be58c(186,"qYU&"))!=_0x3be58c(190,"dj[!"))throw window[_0x3be58c(193,"Z1JT")][_0x3be58c(191,"@x&O")](_0x3be58c(185,"5fpN")),Error();document.title="Vue3 的 Block Tree 和 Patch Flag",document.getElementById("article").innerHTML='<div><p>Vue3 的 <strong>Block Tree</strong>   和 <strong>Patch Flag</strong>   是提升虚拟 DOM 性能的核心优化手段，通过<strong>减少 diff 范围</strong>  和<strong>标记动态节点</strong>  ，显著提高了渲染效率。以下是这两个特性的详细解析：</p>\n<h3><strong>1. Patch Flag（补丁标记）</strong></h3>\n<h4><strong>核心作用</strong></h4>\n<ul>\n<li><strong>标记动态节点</strong>  ：在编译阶段，Vue3 编译器会分析模板，为动态节点添加特定标记（如文本内容变化、属性变化等）。</li>\n<li><strong>跳过静态节点</strong>  ：渲染时，只对有标记的动态节点进行 diff 比较，静态节点直接跳过，减少计算量。</li>\n</ul>\n<h4><strong>常见 Patch Flag 类型</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 部分 Patch Flag 常量示例</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> enum <span class="hljs-title class_">PatchFlags</span> {\n  <span class="hljs-variable constant_">TEXT</span> = <span class="hljs-number">1</span>,           <span class="hljs-comment">// 动态文本节点</span>\n  <span class="hljs-variable constant_">CLASS</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>,     <span class="hljs-comment">// 动态 class</span>\n  <span class="hljs-variable constant_">STYLE</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>,     <span class="hljs-comment">// 动态 style</span>\n  <span class="hljs-variable constant_">PROPS</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>,     <span class="hljs-comment">// 动态属性（非 class/style）</span>\n  <span class="hljs-variable constant_">FULL_PROPS</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>,<span class="hljs-comment">// 需完整比较的动态属性</span>\n  <span class="hljs-variable constant_">HYDRATE_EVENTS</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>, <span class="hljs-comment">// 有事件监听器</span>\n  <span class="hljs-variable constant_">STABLE_FRAGMENT</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>, <span class="hljs-comment">// 稳定片段（子节点顺序不变）</span>\n  <span class="hljs-variable constant_">KEYED_FRAGMENT</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>,  <span class="hljs-comment">// 有 key 的片段</span>\n  <span class="hljs-variable constant_">UNKEYED_FRAGMENT</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>, <span class="hljs-comment">// 无 key 的片段</span>\n  <span class="hljs-variable constant_">NEED_PATCH</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">9</span>, <span class="hljs-comment">// 需手动 patch 的节点</span>\n  <span class="hljs-variable constant_">DYNAMIC_SLOTS</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>, <span class="hljs-comment">// 动态插槽</span>\n  <span class="hljs-comment">// ... 其他标记</span>\n}\n</code></pre>\n<h4><strong>示例代码</strong></h4>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>静态文本<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-comment">&lt;!-- 无标记，跳过 diff --&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-comment">&lt;!-- 标记为 TEXT(1)，只比较文本内容 --&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;{ active: isActive }&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-comment">&lt;!-- 标记为 CLASS(2) --&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n<h4><strong>编译后效果</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 简化后的渲染函数示例</span>\n<span class="hljs-keyword">import</span> { createVNode <span class="hljs-keyword">as</span> _createVNode, toDisplayString <span class="hljs-keyword">as</span> _toDisplayString } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">_ctx, _cache</span>) {\n  <span class="hljs-keyword">return</span> (<span class="hljs-title function_">_openBlock</span>(), <span class="hljs-title function_">_createBlock</span>(<span class="hljs-string">&quot;div&quot;</span>, <span class="hljs-literal">null</span>, [\n    <span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;静态文本&quot;</span>), <span class="hljs-comment">// 无标记，静态节点</span>\n    <span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-title function_">_toDisplayString</span>(_ctx.<span class="hljs-property">message</span>), <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>), <span class="hljs-comment">// 标记为 TEXT</span>\n    <span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;button&quot;</span>, {\n      <span class="hljs-attr">class</span>: { <span class="hljs-attr">active</span>: _ctx.<span class="hljs-property">isActive</span> }\n    }, <span class="hljs-string">&quot;按钮&quot;</span>, <span class="hljs-number">2</span> <span class="hljs-comment">/* CLASS */</span>) <span class="hljs-comment">// 标记为 CLASS</span>\n  ]))\n}\n</code></pre>\n<h3><strong>2. Block Tree（区块树）</strong></h3>\n<h4><strong>核心作用</strong></h4>\n<ul>\n<li><strong>层级化管理动态节点</strong>  ：将虚拟 DOM 树划分为多个“区块”，每个区块包含一个根节点和其所有动态子节点。</li>\n<li><strong>深度优先遍历优化</strong>  ：只对区块的根节点和标记节点进行 diff，忽略区块内的静态结构。</li>\n</ul>\n<h4><strong>关键概念</strong></h4>\n<ul>\n<li><strong>Block</strong>  ：包含动态节点的特殊虚拟节点，其内部动态子节点会被记录到 <code>dynamicChildren</code> 数组中。</li>\n<li><strong>openBlock() / createBlock()</strong>  ：创建区块的函数，用于包裹动态节点。</li>\n</ul>\n<h4><strong>示例代码</strong></h4>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span> <span class="hljs-comment">&lt;!-- 静态节点 --&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-comment">&lt;!-- 动态节点 --&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>{{ item.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <span class="hljs-comment">&lt;!-- 动态列表 --&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>版权信息<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-comment">&lt;!-- 静态节点 --&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n<h4><strong>编译后 Block Tree 结构</strong></h4>\n<pre><code>div (Block)\n├─ header (静态，跳过)\n├─ main (Block)\n│  ├─ p (TEXT 标记)\n│  └─ ul (KEYED_FRAGMENT 标记)\n│     └─ 动态列表项\n└─ footer (静态，跳过)\n</code></pre>\n<h3><strong>3. 性能对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>Vue2（全量 diff）</th>\n<th>Vue3（Block Tree + Patch Flag）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>大型静态结构</td>\n<td>逐节点比较</td>\n<td>直接跳过，不参与 diff</td>\n</tr>\n<tr>\n<td>动态文本更新</td>\n<td>比较整个节点</td>\n<td>只比较 TEXT 标记的文本内容</td>\n</tr>\n<tr>\n<td>列表更新</td>\n<td>比较所有列表项</td>\n<td>只比较有变化的列表项（依赖 key）</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>4. 手动优化提示</strong></h3>\n<ul>\n<li><strong>使用 key</strong>  ：为列表项添加唯一 <code>key</code>，Vue3 会生成 <code>KEYED_FRAGMENT</code> 标记，优化列表更新。</li>\n<li><strong>减少动态绑定</strong>  ：尽量将静态内容提取到模板外部，减少动态节点数量。</li>\n<li><strong>避免不必要的动态表达式</strong>  ：如 <code>:class=&quot;isActive ? \'active\' : \'\'&quot;</code> 可简化为 <code>:class=&quot;{ active }&quot;</code>。</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>Patch Flag</strong>   通过标记动态节点，让 diff 过程只需关注变化的部分。</li>\n<li><strong>Block Tree</strong>   将虚拟 DOM 划分为区块，进一步减少需要遍历的节点数量。</li>\n<li>两者结合使 Vue3 在复杂场景下的渲染性能显著提升，尤其是包含大量静态内容的组件。</li>\n</ul>\n<p>这些优化是 Vue3 编译器的“黑盒”能力，开发者只需编写常规模板，编译器会自动生成高效的渲染代码。</p>\n</div>'</script></body></html>