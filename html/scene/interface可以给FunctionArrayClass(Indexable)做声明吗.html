<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5f1f98=_0x5eba;function _0xe539(){var s=["E8koj2tcKLJdI8k2","WQ7cTmktWPzjW645WQZcLmoQlmovWRe","ySkwW5j8W7lcNt7dL0Wtowu","W73dL8k/WRFcKSo6dve","pWhdQK9ItCkZm8oaWRZdJ8o6WPW","wSkUWOa2oCk1wmksjCkgWQ/cLCo2","zrLEneZdMmo0WPxcG0tcJCkf","CLddGIDFfHhcGa","W4NcIhr5W4yFW4S","lmojWPawWP/dMq4","wZytlbWZv19a","WPK2yr0kdgy1","wmkQWOaZomkYvCkNbmkSWQlcRSoi","iSk+W7rSW7VcMYWvW53cS8omrW","pxfpa1ZdGstcIL3dKhxcHaa","WPS1l2vmnxSikN7cTa","lSkJkWVdIJ/dPmoa","WRVdJchcM3mJzCkbqu9RFq","k8kBp8kTW43cSem","W60NwmojWOlcSSkOWPZcLwZcKHG+","WP/dRSo7lsLFWQZcTJK","lmoFyCoJWQm7W71HW5NdLSkhW47cIa","WP52dmkEW4xdS8oBWP3cUq","W4DEW5PQtbjUnGrJtW","Eu3cOqOS","W6udWRm2kJujDmoRmmkxWRZdRW","y23dVbldNmk6es14W67cVCk9bW3cMCojBHVdUYJdKe4YWQGvqq","WRbuW7bnAMjC"];return(_0xe539=function(){return s})()}function _0x5eba(t,s){var p=_0xe539();return(_0x5eba=function(s,n){var a=p[s-=375];void 0===_0x5eba.ThzRNe&&(_0x5eba.ehNMsU=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,r=0;a=s.charAt(r++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,e=l.length;c<e;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),r=0;r<256;r++)l[r]=r;for(r=0;r<256;r++)t=(t+l[r]+n.charCodeAt(r%n.length))%256,a=l[r],l[r]=l[t],l[t]=a;for(var r=0,t=0,c=0;c<s.length;c++)a=l[r=(r+1)%256],l[r]=l[t=(t+l[r])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[r]+l[t])%256]);return p},t=arguments,_0x5eba.ThzRNe=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x5eba.ndIAMm&&(_0x5eba.ndIAMm=!0),a=_0x5eba.ehNMsU(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x5eba,n=_0xe539();;)try{if(899871==-parseInt(s(392,"Z@@X"))*(-parseInt(s(380,"ybe("))/2)+parseInt(s(383,"q9c!"))/3+-parseInt(s(382,"3DY@"))/4*(-parseInt(s(388,"Z@@X"))/5)+parseInt(s(402,"]Lfk"))/6+-parseInt(s(386,")t!X"))/7*(-parseInt(s(381,"%4$0"))/8)+-parseInt(s(389,"3DY@"))/9+-parseInt(s(387,"GIVJ"))/10*(parseInt(s(390,")t!X"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5f1f98(376,"]Lfk")](_0x5f1f98(399,"vQPM"))!=_0x5f1f98(401,"%4$0"))throw window[_0x5f1f98(384,"Ys5T")][_0x5f1f98(385,"@xL^")](_0x5f1f98(375,"dx8V")),Error();document.title="interface可以给FunctionArrayClass(Indexable)做声明吗",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>interface</code> 是一种强大的工具，用于定义对象的结构。它不仅可以用于定义普通对象的类型，还可以用于声明函数、数组以及类的索引签名等。以下是关于如何使用 <code>interface</code> 为函数、数组和类（索引签名）做声明的详细说明：</p>\n<hr>\n<h3><strong>1. 为函数声明接口</strong></h3>\n<ul>\n<li><strong>函数类型接口</strong>  ：可以使用 <code>interface</code> 来定义函数的形状，包括参数类型和返回值类型。</li>\n<li><strong>调用签名</strong>  ：在接口中定义一个调用签名，用于描述函数的参数和返回值。</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">AddFunction</span> {\n  (<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">add</span>: <span class="hljs-title class_">AddFunction</span> = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出：5</span>\n</code></pre>\n<hr>\n<h3><strong>2. 为数组声明接口</strong></h3>\n<ul>\n<li><strong>数组类型</strong>  ：虽然 TypeScript 提供了内置的数组类型（如 <code>number[]</code> 或 <code>Array&lt;number&gt;</code>），但也可以使用 <code>interface</code> 来描述数组的行为，尤其是在需要自定义方法时。</li>\n<li><strong>索引签名</strong>  ：可以使用索引签名来描述数组元素的类型。</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">StringArray</span> {\n  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 数组元素必须是字符串</span>\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>: <span class="hljs-title class_">StringArray</span> = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>];\n<span class="hljs-comment">// arr.push(123); // 错误：数字类型不符合字符串类型</span>\n</code></pre>\n<hr>\n<h3><strong>3. 为类（或索引签名对象）声明接口</strong></h3>\n<ul>\n<li><strong>索引签名</strong>  ：接口可以定义索引签名，用于描述对象的属性类型。这对于需要动态添加属性的对象非常有用。</li>\n<li><strong>适用场景</strong>  ：当对象的属性名在编写代码时未知，但属性的类型已知时，可以使用索引签名。</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">StringDictionary</span> {\n  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 对象的键是字符串，值也是字符串</span>\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">dict</span>: <span class="hljs-title class_">StringDictionary</span> = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>,\n  <span class="hljs-attr">age</span>: <span class="hljs-string">&quot;25&quot;</span>, <span class="hljs-comment">// 虽然值是字符串，但通常建议使用更精确的类型</span>\n};\n\n<span class="hljs-comment">// dict[42] = &quot;forty-two&quot;; // 错误：键必须是字符串</span>\n</code></pre>\n<hr>\n<h3><strong>4. 混合类型接口</strong></h3>\n<ul>\n<li><strong>函数与索引签名混合</strong>  ：接口可以同时包含函数签名和索引签名，以描述更复杂的结构。</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MixedType</span> {\n  (<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 函数签名</span>\n  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>; <span class="hljs-comment">// 索引签名，允许添加任意属性</span>\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">mixed</span>: <span class="hljs-title class_">MixedType</span> = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y;\nmixed.<span class="hljs-property">property</span> = <span class="hljs-string">&quot;value&quot;</span>; <span class="hljs-comment">// 可以添加属性</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">mixed</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出：5</span>\n</code></pre>\n<hr>\n<h3><strong>5. 使用接口扩展内置类型</strong></h3>\n<ul>\n<li><strong>扩展数组或函数类型</strong>  ：可以通过接口扩展内置类型（如数组或函数），以添加额外的方法或属性。</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CustomArray</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Array</span>&lt;T&gt; {\n  <span class="hljs-title function_">first</span>(): T | <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 添加自定义方法</span>\n}\n\n<span class="hljs-comment">// 实现自定义方法（通常在运行时需要额外处理）</span>\n<span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>: <span class="hljs-title class_">CustomArray</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];\n(arr <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">first</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[<span class="hljs-number">0</span>];\n};\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">first</span>()); <span class="hljs-comment">// 输出：1</span>\n</code></pre>\n<hr>\n<h3><strong>6. 类的实现与接口</strong></h3>\n<ul>\n<li><strong>类实现接口</strong>  ：类可以实现接口，以确保类符合接口定义的契约。</li>\n<li><strong>索引签名在类中的使用</strong>  ：类可以实现具有索引签名的接口，以允许动态属性。</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Indexable</span> {\n  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Indexable</span> {\n  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>;\n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>[<span class="hljs-string">&quot;someKey&quot;</span>] = <span class="hljs-number">42</span>;\n  }\n}\n\n<span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[<span class="hljs-string">&quot;someKey&quot;</span>]); <span class="hljs-comment">// 输出：42</span>\n</code></pre>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>函数接口</strong>  ：使用调用签名定义函数的参数和返回值类型。</li>\n<li><strong>数组接口</strong>  ：使用索引签名描述数组元素的类型。</li>\n<li><strong>索引签名对象</strong>  ：使用索引签名描述对象的动态属性。</li>\n<li><strong>混合类型接口</strong>  ：结合函数签名和索引签名，描述更复杂的结构。</li>\n<li><strong>扩展内置类型</strong>  ：通过接口扩展内置类型，添加自定义方法或属性。</li>\n<li><strong>类实现接口</strong>  ：类可以实现接口，确保符合接口定义的契约。</li>\n</ul>\n<p>通过理解这些用法，可以更灵活地利用 <code>interface</code> 来定义各种类型结构，提高 TypeScript 代码的可读性和可维护性。</p>\n</div>'</script></body></html>