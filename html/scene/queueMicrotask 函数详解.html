<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x47bd(){var s=["WPFcSSojqmoRWPjQ","d8kBl8kwjSoLWOdcIq","W7RcOSo+qmogW6hcHdxcSSk5pSkLWPW","WPFcUmoZs8koWRxcOmkKWOldQH0iFmk6gmkbW4/dTSoXW6ypW4tcSCkvo1C","WQryW54uWO0lWQC","W5xcLtJcOSkOqhL3DCk2bN8","fGbpk8oUhCkMpmoSWRVcQCkiW6u","nCktqGVdMvHf","W43dUmkXDCknW7ZdNmofWOG","WQxdTW3cK8krW5/cVSk9WRxcVvfRxa","W7BdV2hcKZLDoetcQmkCF8kRWP8","WO3dJCopw38pW7WAaa","WRBdMCoKW4pcKb7dVmo+q3/dMhm","WOPPW4KGuhDSWQuqvSkmsNC","ACktW77dGMRcJqnHwW","W7n3WRC/lSkarG","gmkGWPbZCmoPlCoCBmoSi8oRmq","WQJcQx7dLmoEWQ3dRq","BufJiNlcGCkGfrDagSkInq","WR/cUX3cHe/dI1zwWOddGYbICtW","n8kdqrtdGq","WR/cN8kvWRJdSuhdSW","WRZdNSoNW43cNXFdI8oaq27dPM0","ruvvhSolh8oikSo6WOZcICo0","WOtcOXDiDe1NjmkcitxcJW7cNG","o8oNW5tdVv9GWRfqWRRcIexdP8kn"];return(_0x47bd=function(){return s})()}var _0x135220=_0x2afd;function _0x2afd(l,s){var e=_0x47bd();return(_0x2afd=function(s,n){var a=e[s-=323];void 0===_0x2afd.GlNdSo&&(_0x2afd.uqJXUn=function(s,n){var a,t=[],l=0,e="";for(s=(s=>{for(var n,a,t="",l="",e=0,c=0;a=s.charAt(c++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,p=t.length;o<p;o++)l+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)l=(l+t[c]+n.charCodeAt(c%n.length))%256,a=t[c],t[c]=t[l],t[l]=a;for(var c=0,l=0,o=0;o<s.length;o++)a=t[c=(c+1)%256],t[c]=t[l=(l+t[c])%256],t[l]=a,e+=String.fromCharCode(s.charCodeAt(o)^t[(t[c]+t[l])%256]);return e},l=arguments,_0x2afd.GlNdSo=!0);var s=s+e[0],t=l[s];return t?a=t:(void 0===_0x2afd.mcOkls&&(_0x2afd.mcOkls=!0),a=_0x2afd.uqJXUn(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x2afd,n=_0x47bd();;)try{if(983508==+parseInt(s(335,"5MxO"))*(-parseInt(s(332,")XEB"))/2)+-parseInt(s(323,"PMuj"))/3+parseInt(s(324,"W2[o"))/4+parseInt(s(336,"5MxO"))/5*(-parseInt(s(325,"cp5c"))/6)+parseInt(s(345,"3b(j"))/7*(parseInt(s(331,"PMuj"))/8)+parseInt(s(339,"K6*T"))/9+parseInt(s(333,"JOsX"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x135220(340,"vE$L")](_0x135220(328,"0dJg"))!=_0x135220(334,"bR0W"))throw window[_0x135220(341,"SUPP")][_0x135220(347,"bR0W")](_0x135220(343,"rurE")),Error();document.title="queueMicrotask 函数详解",document.getElementById("article").innerHTML='<div><p><code>queueMicrotask</code> 是 JavaScript 中用于调度微任务（microtask）的原生 API，它允许你将一个函数推迟到当前调用栈完成后、UI 渲染前执行。这一机制在现代前端框架（如 React、Vue）中被广泛用于优化渲染性能。</p>\n<h3><strong>1. 微任务（Microtask）与事件循环</strong></h3>\n<p>JavaScript 的事件循环（Event Loop）将任务分为两种类型：</p>\n<ul>\n<li><strong>宏任务（Macrotask）</strong>  ：如 <code>setTimeout</code>、<code>setInterval</code>、<code>requestAnimationFrame</code>、I/O 操作</li>\n<li><strong>微任务（Microtask）</strong>  ：如 <code>Promise.then</code>、<code>MutationObserver</code>、<code>queueMicrotask</code></li>\n</ul>\n<p><strong>执行顺序</strong>  ：</p>\n<ol>\n<li>执行主线程中的同步代码</li>\n<li>清空微任务队列（直到队列为空）</li>\n<li>执行一个宏任务</li>\n<li>再次清空微任务队列</li>\n<li>重复步骤 3-4</li>\n</ol>\n<h3><strong>2. <code>queueMicrotask</code> 的基本用法</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Start&#x27;</span>);\n\n<span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Microtask&#x27;</span>);\n});\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;End&#x27;</span>);\n\n<span class="hljs-comment">// 输出顺序：</span>\n<span class="hljs-comment">// Start</span>\n<span class="hljs-comment">// End</span>\n<span class="hljs-comment">// Microtask</span>\n</code></pre>\n<h4><strong>核心特性</strong>  ：</h4>\n<ul>\n<li><strong>异步执行</strong>  ：回调函数不会立即执行，而是在当前调用栈清空后执行</li>\n<li><strong>高优先级</strong>  ：微任务会在宏任务（如 <code>setTimeout</code>）之前执行</li>\n<li><strong>原子性</strong>  ：多个微任务会按顺序执行，不会被其他宏任务打断</li>\n</ul>\n<h3><strong>3. 与其他异步方法的对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th><strong>任务类型</strong></th>\n<th><strong>执行时机</strong></th>\n<th><strong>延迟</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>queueMicrotask</code></td>\n<td>微任务</td>\n<td>当前调用栈完成后、UI 渲染前</td>\n<td>极小（亚毫秒级）</td>\n</tr>\n<tr>\n<td><code>Promise.then</code></td>\n<td>微任务</td>\n<td>当前调用栈完成后、UI 渲染前</td>\n<td>极小（亚毫秒级）</td>\n</tr>\n<tr>\n<td><code>setTimeout(fn, 0)</code></td>\n<td>宏任务</td>\n<td>当前事件循环结束后，至少 4ms 延迟</td>\n<td>至少 4ms</td>\n</tr>\n<tr>\n<td><code>requestAnimationFrame</code></td>\n<td>宏任务</td>\n<td>下一帧渲染前</td>\n<td>约 16ms（60fps）</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>4. 实际应用场景</strong></h3>\n<h4><strong>4.1 批量 DOM 更新</strong></h4>\n<p>在需要多次修改 DOM 的场景中，使用 <code>queueMicrotask</code> 可以将所有修改合并为一次渲染：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateDOM</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 第一次 DOM 修改（不会立即渲染）</span>\n  element.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">&#x27;100px&#x27;</span>;\n  \n  <span class="hljs-comment">// 第二次 DOM 修改（不会立即渲染）</span>\n  element.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">&#x27;200px&#x27;</span>;\n  \n  <span class="hljs-comment">// 在微任务中执行依赖于 DOM 变化的操作</span>\n  <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-comment">// 此时两个修改已合并，只触发一次重排/重绘</span>\n    <span class="hljs-keyword">const</span> { width, height } = element.<span class="hljs-title function_">getBoundingClientRect</span>();\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Width: <span class="hljs-subst">${width}</span>, Height: <span class="hljs-subst">${height}</span>`</span>);\n  });\n}\n</code></pre>\n<h4><strong>4.2 异步批处理</strong></h4>\n<p>类似 React 的批处理机制，将多个状态更新合并：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> updateQueue = [];\n<span class="hljs-keyword">let</span> isProcessing = <span class="hljs-literal">false</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">enqueueUpdate</span>(<span class="hljs-params">update</span>) {\n  updateQueue.<span class="hljs-title function_">push</span>(update);\n  \n  <span class="hljs-keyword">if</span> (!isProcessing) {\n    isProcessing = <span class="hljs-literal">true</span>;\n    <span class="hljs-title function_">queueMicrotask</span>(processUpdates);\n  }\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">processUpdates</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-comment">// 批量处理所有更新</span>\n    updateQueue.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">update</span> =&gt;</span> <span class="hljs-title function_">update</span>());\n  } <span class="hljs-keyword">finally</span> {\n    updateQueue.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;\n    isProcessing = <span class="hljs-literal">false</span>;\n  }\n}\n</code></pre>\n<h4><strong>4.3 避免同步递归溢出</strong></h4>\n<p>将递归转换为异步迭代，防止调用栈过深：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processLargeArray</span>(<span class="hljs-params">arr</span>) {\n  <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;\n  \n  <span class="hljs-comment">// 处理一部分数据</span>\n  <span class="hljs-keyword">const</span> batch = arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>);\n  batch.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-title function_">processItem</span>(item));\n  \n  <span class="hljs-comment">// 使用微任务继续处理剩余数据</span>\n  <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">processLargeArray</span>(arr));\n}\n</code></pre>\n<h3><strong>5. 兼容性与降级方案</strong></h3>\n<p><code>queueMicrotask</code> 在现代浏览器中已广泛支持（Chrome 61+、Firefox 59+、Safari 11.3+），但在旧版浏览器中需要降级：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> queueMicrotask = \n  <span class="hljs-variable language_">window</span>.<span class="hljs-property">queueMicrotask</span> ||\n  <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) {\n    <span class="hljs-comment">// 使用 Promise.then 作为降级方案</span>\n    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(callback).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> \n      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> { <span class="hljs-keyword">throw</span> err; }, <span class="hljs-number">0</span>)\n    );\n  };\n</code></pre>\n<h3><strong>6. 注意事项</strong></h3>\n<ol>\n<li><strong>避免阻塞渲染</strong>  ：<br>\n微任务会在 UI 渲染前执行，如果微任务耗时过长，可能导致页面卡顿。</li>\n<li><strong>错误处理</strong>  ：<br>\n微任务中的错误不会被捕获，建议在回调中添加 <code>try...catch</code>：<pre><code class="language-javascript"><span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-comment">// 可能抛出错误的代码</span>\n  } <span class="hljs-keyword">catch</span> (error) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Microtask error:&#x27;</span>, error);\n  }\n});\n</code></pre>\n</li>\n<li><strong>不要滥用</strong>  ：<br>\n微任务适用于需要在当前事件循环内完成的轻量级操作，复杂计算应使用 <code>requestIdleCallback</code> 或 Web Workers。</li>\n</ol>\n<h3><strong>总结</strong></h3>\n<p><code>queueMicrotask</code> 是一个强大的工具，用于调度需要在当前调用栈完成后、UI 渲染前执行的异步操作。它在以下场景中特别有用：</p>\n<ul>\n<li>批量 DOM 更新，减少重排/重绘</li>\n<li>实现高效的批处理机制（如 React 的状态更新合并）</li>\n<li>避免同步递归导致的调用栈溢出</li>\n</ul>\n<p>通过合理使用 <code>queueMicrotask</code>，可以显著提升应用的响应性和性能。</p>\n</div>'</script></body></html>