<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3a8953=_0x4fc9;if((()=>{for(var s=_0x4fc9,n=_0x2076();;)try{if(744735==+parseInt(s(274,"q^xS"))+parseInt(s(289,"]2Fg"))/2+-parseInt(s(275,"wi43"))/3*(-parseInt(s(290,"Yk@B"))/4)+-parseInt(s(279,"]5^r"))/5+parseInt(s(283,"wSi*"))/6*(parseInt(s(286,"1tFB"))/7)+parseInt(s(282,"d6uM"))/8*(-parseInt(s(281,"eBTi"))/9)+parseInt(s(280,"(N6V"))/10*(-parseInt(s(278,"TDp$"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3a8953(287,"y9NY")](_0x3a8953(288,"hz3y"))!=_0x3a8953(267,"wiK2"))throw window[_0x3a8953(272,"FjeI")][_0x3a8953(291,"RJ$f")](_0x3a8953(294,"mSy&")),Error();function _0x4fc9(e,s){var o=_0x2076();return(_0x4fc9=function(s,n){var a=o[s-=267];void 0===_0x4fc9.ARaAKe&&(_0x4fc9.sdYoOk=function(s,n){var a,t=[],e=0,o="";for(s=(s=>{for(var n,a,t="",e="",o=0,r=0;a=s.charAt(r++);~a&&(n=o%4?64*n+a:a,o++%4)&&(t+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,l=t.length;p<l;p++)e+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(s),r=0;r<256;r++)t[r]=r;for(r=0;r<256;r++)e=(e+t[r]+n.charCodeAt(r%n.length))%256,a=t[r],t[r]=t[e],t[e]=a;for(var r=0,e=0,p=0;p<s.length;p++)a=t[r=(r+1)%256],t[r]=t[e=(e+t[r])%256],t[e]=a,o+=String.fromCharCode(s.charCodeAt(p)^t[(t[r]+t[e])%256]);return o},e=arguments,_0x4fc9.ARaAKe=!0);var s=s+o[0],t=e[s];return t?a=t:(void 0===_0x4fc9.zekVqe&&(_0x4fc9.zekVqe=!0),a=_0x4fc9.sdYoOk(a,n),e[s]=a),a})(e,s)}function _0x2076(){var s=["dmknf8k/W64xWP0","FxHIWRzWjN87WOBdGSkRW4lcJa","E8kLW5uZyCoIW59U","WOOnvWpdOhyUWRFdQLxdHmoMDZOqhWmoW7RcLmk1BeRcLJ3dTa","oCoOW4CcBq","Cc/cKueGimk2W4e","WRXDW74JBq8OWOO8WPHDeYC","W5rjeWldUGfSW6/dVW","qCofWRFcSGhdUhhcRKHOrmorW5S","kJ3cHrbix2/cJa","W5efWOFdP8oslf0aW7Wtd8ondq","ExPVWRvZjWuxWPJdICkyW7W","DsNdPXuAaSkrW54ppW","khfCBtKQxqJdIWy","WRldP3pdJ8oGW77dK8kYWQddPw1X","pM8jdNXmW4zfW7KChItdRq","WRddQNpdISoMW7ZcPCkLWRtdTuPjWQ4","W5qmW7ZcSSkZDICM","WO/dJ8k6DSo8CJD1WOldQ8kuW4FdTa","W7JdGXfHWQz3ea","mmk+tquMW7FdMNhdGmoUFIVcJq","W7/cIMZdPCkMlWeMWRFdUhtcUxO","mCo4WQFdUd1uWQ8","W6KQzL5TWR8+jG","EYiqfcmcwa","W6hcSWZdNCovW7lcT3vY","mZRdKZ7cImkxEZPCW77cJYqj","W7VcI2NcOCo9v1GBWOe"];return(_0x2076=function(){return s})()}document.title="Vuex 3 必须将 store 挂载到 Vue 实例的 this.$store",document.getElementById("article").innerHTML='<div><p>在 Vuex 3（配合 Vue 2）中，必须将 store 挂载到 Vue 实例的 <code>this.$store</code>，<strong>核心原因是 Vue 2 的响应式系统依赖“上下文感知”的依赖收集机制</strong>   。以下是深度解析：</p>\n<hr>\n<h3>一、Vue 2 响应式系统的底层原理</h3>\n<p>Vue 2 的响应式基于 <strong>依赖追踪（Dependency Tracking）</strong>   ：</p>\n<ol>\n<li><strong>依赖收集</strong>   ：当组件渲染时，任何被访问的响应式属性（如 <code>data</code>、<code>computed</code>）会触发 <code>getter</code>，将当前组件实例（Watcher）注册为依赖。</li>\n<li><strong>派发更新</strong>   ：当属性变化时，通过 <code>setter</code> 通知所有依赖的组件重新渲染。</li>\n</ol>\n<p><strong>关键限制</strong>   ：<br>\nVue 2 的响应式系统必须通过 <strong>组件实例上下文</strong>   （即 <code>this</code>）访问属性，才能建立依赖关系。</p>\n<hr>\n<h3>二、为什么 <code>this.$store</code> 是必须的？</h3>\n<h4>1. <strong>Vuex 的响应式绑定依赖于 Vue 实例</strong></h4>\n<ul>\n<li>\n<p>Vuex 3 内部使用 <code>Vue.util.defineReactive</code> 将 state 转为响应式对象，但 <strong>仅限通过 Vue 实例代理的访问</strong>   。</p>\n</li>\n<li>\n<p>当通过 <code>this.$store.state.xxx</code> 访问时：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 伪代码：Vuex 初始化时的逻辑</span>\n<span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$store</span> = store; <span class="hljs-comment">// 将 store 挂载到 Vue 原型链</span>\n</code></pre>\n<ul>\n<li>Vue 能感知到 <code>this.$store</code> 的访问，从而正确收集依赖。</li>\n</ul>\n</li>\n</ul>\n<h4>2. <strong>直接导入 store 文件的问题</strong></h4>\n<p>如果直接导入 store（而非通过 <code>this.$store</code>）：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/store&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">computed</span>: {\n    <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-keyword">return</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>; <span class="hljs-comment">// ❌ 脱离 Vue 实例上下文</span>\n    },\n  },\n};\n</code></pre>\n<ul>\n<li><strong>问题</strong>   ：<code>store.state.count</code> 的访问发生在组件外部，Vue 无法追踪到是哪个组件依赖了这个状态。</li>\n<li><strong>结果</strong>   ：state 变化时，组件不会自动更新。</li>\n</ul>\n<hr>\n<h3>三、技术实现对比</h3>\n<h4>1. <strong>挂载到 <code>this.$store</code>（正确方式）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({\n  store, <span class="hljs-comment">// 注入 store</span>\n  <span class="hljs-attr">computed</span>: {\n    <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>; <span class="hljs-comment">// ✅ Vue 能追踪 this.$store 的依赖</span>\n    },\n  },\n});\n</code></pre>\n<ul>\n<li><strong>依赖收集流程</strong>   ：\n<ol>\n<li>组件渲染时访问 <code>this.$store.state.count</code>。</li>\n<li>Vue 识别 <code>this.$store</code> 是响应式对象，记录当前组件为依赖。</li>\n<li>当 <code>state.count</code> 变化时，触发组件更新。</li>\n</ol>\n</li>\n</ul>\n<h4>2. <strong>直接导入 store（错误方式）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/store&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">computed</span>: {\n    <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-keyword">return</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>; <span class="hljs-comment">// ❌ Vue 不知道谁依赖了 store</span>\n    },\n  },\n};\n</code></pre>\n<ul>\n<li><strong>依赖丢失</strong>   ：<code>store</code> 是独立模块，与 Vue 实例无关联，Vue 无法建立依赖关系。</li>\n</ul>\n<hr>\n<h3>四、例外情况的验证</h3>\n<h4>1. <strong>手动强制响应式（不推荐）</strong></h4>\n<p>若强行直接使用 store，需用 <code>Vue.set</code> 或 <code>computed</code> 包装：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/store&quot;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">computed</span>: {\n    <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>); <span class="hljs-comment">// ✅ 手动创建响应式引用</span>\n    },\n  },\n};\n</code></pre>\n<ul>\n<li><strong>缺点</strong>   ：违背 Vuex 设计初衷，增加复杂度。</li>\n</ul>\n<h4>2. <strong>Vuex 4（Vue 3）的改进</strong></h4>\n<p>Vue 3 的 Composition API 解除了对 <code>this</code> 的依赖：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useStore } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>(); <span class="hljs-comment">// ✅ 不依赖 this，仍能响应式</span>\n    <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>) };\n  },\n};\n</code></pre>\n<ul>\n<li><strong>原理</strong>   ：Vue 3 的响应式系统（Proxy）支持跨模块依赖追踪。</li>\n</ul>\n<hr>\n<h3>五、总结：Vuex 3 的设计约束</h3>\n<table>\n<thead>\n<tr>\n<th>关键点</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>依赖收集需上下文</strong></td>\n<td>Vue 2 只能通过 <code>this</code> 访问的属性才能建立响应式关联。</td>\n</tr>\n<tr>\n<td><strong>原型链挂载</strong></td>\n<td><code>Vue.prototype.$store</code> 确保所有组件通过统一接口访问 store。</td>\n</tr>\n<tr>\n<td><strong>模块化隔离</strong></td>\n<td>直接导入的 store 是独立模块，与 Vue 实例无关联。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>结论</strong>   ：<br>\n在 Vuex 3 中，<code>this.$store</code> 是 Vue 2 响应式系统的必要桥梁。若跳过它，Vue 无法知道“谁在何时依赖了哪些状态”，导致响应式失效。这是 Vue 2 架构的设计限制，在 Vue 3 中得以改进。</p>\n</div>'</script></body></html>