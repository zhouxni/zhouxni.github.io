<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x338e27=_0x6f7a;function _0x6f7a(l,n){var a=_0x1703();return(_0x6f7a=function(n,s){var t=a[n-=253];void 0===_0x6f7a.dQBVbA&&(_0x6f7a.gqsJHf=function(n,s){var t,o=[],l=0,a="";for(n=(n=>{for(var s,t,o="",l="",a=0,e=0;t=n.charAt(e++);~t&&(s=a%4?64*s+t:t,a++%4)&&(o+=String.fromCharCode(255&s>>(-2*a&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var r=0,c=o.length;r<c;r++)l+="%"+("00"+o.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(n),e=0;e<256;e++)o[e]=e;for(e=0;e<256;e++)l=(l+o[e]+s.charCodeAt(e%s.length))%256,t=o[e],o[e]=o[l],o[l]=t;for(var e=0,l=0,r=0;r<n.length;r++)t=o[e=(e+1)%256],o[e]=o[l=(l+o[e])%256],o[l]=t,a+=String.fromCharCode(n.charCodeAt(r)^o[(o[e]+o[l])%256]);return a},l=arguments,_0x6f7a.dQBVbA=!0);var n=n+a[0],o=l[n];return o?t=o:(void 0===_0x6f7a.mKJtmO&&(_0x6f7a.mKJtmO=!0),t=_0x6f7a.gqsJHf(t,s),l[n]=t),t})(l,n)}function _0x1703(){var n=["gcJcRg1fW7T2C3tcKW","WPhdR8oYdcC","FHbGW7RdVh3cVmkz","WQmQwsRcPCkeEmk1W6Gf","vw/cGCkSECkvW6zkqre","WRPyuSoadhODW6bfaSo5W6W","oSk6egRcIu3cO8kgWQJcKCkvyYW","WQ/cKSo1uSoBqeBcJetdSW","WPuxWPqAWPz/ga","m8oXjCoVttyVWQPtW7X6W5C","W5VcSmoZW4afWRZdUSkRW5K","zCkkaeebh0K","x3PyW7JcLdNcOSkGW6KeW5W","a8kGjs/dImoBoG","tqFcQSowWORcHH18W6K","WOycDSk+WRpdGgORexaAbq","WO3cRCkLW5VdVKlcSb5SmhC","fIVdRSk+tSoBFmkGwwNcOSoK","wWHTgmo9WRKrwXVcO8kVpmkBgaWyW65gaCk3cCkfWRO3sx0","W7FcGceRWQGqWQBdRmoMW5D6CG","jey6W4ZdQwtcSSkVWPG","nmoWi8oMsJzXWO9fW7DZW7eE","qSkKW5VcKmo9W5NdI0FcONVdNW","zXZdUSoeW4XgWPi","CuxcLGaFW63dLWHOcdK","eJWEW5rhoCkGW4pcJCksgeO"];return(_0x1703=function(){return n})()}if((()=>{for(var n=_0x6f7a,s=_0x1703();;)try{if(166480==-parseInt(n(263,"*d@K"))+parseInt(n(256,"b&dd"))/2+-parseInt(n(255,"9oNw"))/3*(-parseInt(n(271,"$6qx"))/4)+parseInt(n(254,"&Dmj"))/5*(parseInt(n(272,"(sPi"))/6)+parseInt(n(262,"moc0"))/7+parseInt(n(266,"FX#L"))/8+-parseInt(n(274,"uU0x"))/9*(parseInt(n(265,"H0jh"))/10))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x338e27(264,"#qmE")](_0x338e27(277,"L#$p"))!=_0x338e27(268,"aB*1"))throw window[_0x338e27(269,"7[E@")][_0x338e27(275,"qZW*")](_0x338e27(259,"sSww")),Error();document.title="浏览器渲染原理",document.getElementById("article").innerHTML='<div><p>浏览器渲染原理是指浏览器将HTML、CSS、JavaScript等代码转换为可视化页面的过程。这一过程涉及多个复杂步骤，下面从核心流程、关键阶段和优化方向三个层面详细解析：</p>\n<h3><strong>一、核心渲染流程：从代码到像素</strong></h3>\n<p>浏览器渲染的本质是“构建渲染树并绘制像素”，其核心流程可分为以下7个阶段：</p>\n<h4><strong>1. 浏览器解析资源</strong></h4>\n<ul>\n<li><strong>HTML解析</strong>  ：浏览器将HTML字符串转换为<strong>DOM树（Document Object Model）</strong>  ，解析过程中遇到CSS、JS等外部资源会异步或同步加载。\n<ul>\n<li>示例：<code>&lt;div&gt;&lt;p&gt;内容&lt;/p&gt;&lt;/div&gt;</code>会被解析为包含<code>div</code>和<code>p</code>节点的树形结构。</li>\n</ul>\n</li>\n<li><strong>CSS解析</strong>  ：将CSS代码（包括内联、内部样式表、外部样式表）转换为<strong>CSSOM树（CSS Object Model）</strong>  ，定义每个元素的样式规则。</li>\n<li><strong>JS解析与执行</strong>  ：JS代码会阻塞渲染（除非标记为<code>async</code>或<code>defer</code>），执行时可能修改DOM或CSSOM，触发重排/重绘。</li>\n</ul>\n<h4><strong>2. 构建渲染树（Render Tree）</strong></h4>\n<ul>\n<li><strong>合并DOM与CSSOM</strong>  ：浏览器将DOM树和CSSOM树合并为<strong>渲染树</strong>  ，仅包含可视元素（如<code>display: none</code>的元素会被排除）。</li>\n<li><strong>示例</strong>  ：DOM中的<code>&lt;div&gt;</code>节点与CSSOM中<code>div { color: red; }</code>规则结合，形成带样式的渲染树节点。</li>\n</ul>\n<h4><strong>3. 布局（Layout/Reflow）</strong></h4>\n<ul>\n<li><strong>计算元素几何位置</strong>  ：根据渲染树中每个节点的样式，计算其在页面中的位置、尺寸（宽高、边距、边框等）。</li>\n<li><strong>触发场景</strong>  ：首次渲染、元素尺寸/位置改变（如JS修改<code>width</code>）、字体加载完成等。</li>\n<li><strong>性能影响</strong>  ：布局是高成本操作，需遍历整个渲染树计算几何属性。</li>\n</ul>\n<h4><strong>4. 分层（Layerization）</strong></h4>\n<ul>\n<li><strong>创建图层</strong>  ：浏览器将具有复杂样式（如3D变换、透明度、视频）的元素分配到独立图层，优化绘制效率。</li>\n<li><strong>常见分层场景</strong>  ：<code>position: fixed</code>元素、使用<code>will-change</code>属性的元素、视频标签等。</li>\n</ul>\n<h4><strong>5. 绘制（Painting）</strong></h4>\n<ul>\n<li><strong>填充像素</strong>  ：在每个图层上，浏览器根据元素的样式（颜色、背景、边框、文字等）绘制像素内容。</li>\n<li><strong>绘制顺序</strong>  ：按图层堆叠顺序（z-index）从下到上绘制，复杂样式（如阴影、渐变）需更多计算资源。</li>\n</ul>\n<h4><strong>6. 合成（Compositing）</strong></h4>\n<ul>\n<li><strong>合并图层</strong>  ：将多个图层的绘制结果合并为最终的屏幕像素输出，图层的移动或变换（如滚动、动画）可直接在合成阶段处理，避免重复布局和绘制。</li>\n<li><strong>硬件加速</strong>  ：现代浏览器利用GPU加速合成，提升动画和滚动性能。</li>\n</ul>\n<h4><strong>7. 显示（Display）</strong></h4>\n<ul>\n<li><strong>输出到屏幕</strong>  ：合成后的像素数据通过显卡渲染到显示器，完成页面显示。</li>\n</ul>\n<h3><strong>二、关键阶段详解：布局、绘制与合成</strong></h3>\n<h4><strong>1. 布局（Layout）</strong></h4>\n<ul>\n<li><strong>盒模型计算</strong>  ：每个元素遵循CSS盒模型（content+padding+border+margin）计算尺寸，例如：<pre><code class="language-css"><span class="hljs-selector-tag">div</span> {\n  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;       <span class="hljs-comment">/* 内容区宽度 */</span>\n  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;      <span class="hljs-comment">/* 内边距 */</span>\n  <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid; <span class="hljs-comment">/* 边框 */</span>\n  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;       <span class="hljs-comment">/* 外边距 */</span>\n  <span class="hljs-comment">/* 总宽度：200+20*2+10*2=260px */</span>\n}\n</code></pre>\n</li>\n<li><strong>回流（Reflow）</strong>  ：当元素尺寸、位置或隐藏状态改变时，会触发局部或全局布局更新，例如：\n<ul>\n<li>修改<code>width</code>、<code>padding</code>等几何属性；</li>\n<li>添加或删除DOM节点；</li>\n<li>字体加载导致文本尺寸变化。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>2. 绘制（Painting）</strong></h4>\n<ul>\n<li><strong>绘制内容分类</strong>  ：\n<ul>\n<li><strong>背景与边框</strong>  ：处理<code>background-color</code>、<code>border</code>等样式；</li>\n<li><strong>文本</strong>  ：计算字体、字号、颜色并绘制字符；</li>\n<li><strong>阴影与效果</strong>  ：处理<code>box-shadow</code>、<code>text-shadow</code>等效果；</li>\n<li><strong>渐变与图片</strong>  ：渲染<code>linear-gradient</code>、<code>background-image</code>等。</li>\n</ul>\n</li>\n<li><strong>重绘（Repaint）</strong>  ：当元素样式改变但不影响布局时（如<code>color</code>、<code>background-color</code>），仅触发绘制阶段更新，成本低于回流。</li>\n</ul>\n<h4><strong>3. 合成（Compositing）</strong></h4>\n<ul>\n<li><strong>图层优化</strong>  ：独立图层可单独处理变换（如滚动时固定定位元素），避免影响其他图层。例如：<pre><code class="language-css"><span class="hljs-selector-class">.floating</span> {\n  <span class="hljs-attribute">will-change</span>: transform; <span class="hljs-comment">/* 提示浏览器创建独立图层 */</span>\n  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">/* 强制GPU加速 */</span>\n}\n</code></pre>\n</li>\n<li><strong>合成流程</strong>  ：\n<ol>\n<li>各图层绘制为位图（Bitmap）；</li>\n<li>图层变换（如平移、缩放）在GPU中处理；</li>\n<li>按z-index顺序合并图层，输出到屏幕。</li>\n</ol>\n</li>\n</ul>\n<h3><strong>三、渲染性能优化：避免重排与重绘</strong></h3>\n<h4><strong>1. 减少布局操作</strong></h4>\n<ul>\n<li><strong>批量修改样式</strong>  ：使用<code>classList</code>或一次性修改<code>cssText</code>，避免多次触发回流。<pre><code class="language-javascript"><span class="hljs-comment">// 差示例：多次修改触发多次回流</span>\nelement.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">&#x27;100px&#x27;</span>;\nelement.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">&#x27;100px&#x27;</span>;\nelement.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;red&#x27;</span>;\n\n<span class="hljs-comment">// 好示例：使用class或cssText批量修改</span>\nelement.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>); <span class="hljs-comment">// CSS中定义所有样式</span>\n<span class="hljs-comment">// 或</span>\nelement.<span class="hljs-property">style</span>.<span class="hljs-property">cssText</span> = <span class="hljs-string">&#x27;width: 100px; height: 100px; background-color: red;&#x27;</span>;\n</code></pre>\n</li>\n<li><strong>使用<code>transform</code>替代<code>left/top</code></strong>  ：<code>transform</code>仅触发合成阶段，不影响布局。<pre><code class="language-css"><span class="hljs-comment">/* 差：触发回流 */</span>\n<span class="hljs-selector-class">.move</span> { <span class="hljs-attribute">left</span>: <span class="hljs-number">10px</span>; <span class="hljs-attribute">top</span>: <span class="hljs-number">10px</span>; }\n\n<span class="hljs-comment">/* 好：仅触发合成 */</span>\n<span class="hljs-selector-class">.move</span> { <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">10px</span>, <span class="hljs-number">10px</span>); }\n</code></pre>\n</li>\n</ul>\n<h4><strong>2. 优化绘制与合成</strong></h4>\n<ul>\n<li><strong>减少重绘区域</strong>  ：使用<code>opacity</code>或<code>transform</code>替代<code>visibility</code>（<code>visibility: hidden</code>仍需绘制）。</li>\n<li><strong>利用图层分离动画元素</strong>  ：对频繁动画的元素（如轮播图）添加<code>will-change</code>或<code>transform: translateZ(0)</code>，使其独立成层。</li>\n<li><strong>避免复杂样式</strong>  ：如大量阴影、滤镜（<code>filter</code>）等会增加绘制成本，可尝试用图片替代。</li>\n</ul>\n<h4><strong>3. 资源加载优化</strong></h4>\n<ul>\n<li><strong>优先加载关键资源</strong>  ：使用<code>link rel=&quot;stylesheet&quot;</code>同步加载CSS（阻塞渲染但确保样式正确），用<code>defer</code>或<code>async</code>异步加载JS。</li>\n<li><strong>懒加载非关键资源</strong>  ：对图片、非首屏JS使用<code>loading=&quot;lazy&quot;</code>或动态加载。</li>\n</ul>\n<h3><strong>四、浏览器渲染引擎对比</strong></h3>\n<p>不同浏览器的渲染引擎实现略有差异：</p>\n<table>\n<thead>\n<tr>\n<th>浏览器</th>\n<th>渲染引擎</th>\n<th>核心特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Chrome/Edge</td>\n<td>Blink</td>\n<td>基于WebKit分支，性能优化强，支持GPU加速合成</td>\n</tr>\n<tr>\n<td>Firefox</td>\n<td>Gecko</td>\n<td>注重布局精确性，使用自己的排版引擎（Servo项目）</td>\n</tr>\n<tr>\n<td>Safari</td>\n<td>WebKit</td>\n<td>苹果自研引擎，优化移动端渲染，对CSS特性支持激进</td>\n</tr>\n<tr>\n<td>Internet Explorer</td>\n<td>Trident</td>\n<td>已淘汰，仅支持旧版渲染机制，性能较差</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>总结</strong></h3>\n<p>浏览器渲染是一个多阶段协作的过程，从代码解析到像素显示，每个环节都可能影响性能。优化的核心在于：</p>\n<ul>\n<li>减少布局（回流）和绘制（重绘）次数；</li>\n<li>利用图层和GPU加速合成；</li>\n<li>合理管理资源加载顺序。<br>\n理解渲染原理有助于开发者写出更高效的前端代码，提升用户体验。</li>\n</ul>\n</div>'</script></body></html>