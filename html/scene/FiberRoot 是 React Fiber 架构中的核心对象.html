<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0xa9d45a=_0x4518;function _0x88b9(){var n=["W7XfWRhdN8oHWPXFzx8","ACoqzmovtXNcNwHPWRhdGCoB","W7LCyMeYlCkLWPOTW6neW7e6","EIRdGG/cQmkSW4Kefq","umkMWOLdfKC/cCoOqMFcHmoL","w8oyW6WTqbTQ","h8oLkmkuWQO","WPeoWOKOESkaWOv3W6VcQ8kY","q8o0A8koW7qRqmoqWRNdHmoErG","WPFcTJpcVfmmWRJdPmoAWR5VrG","W7TnWR7cVSkgWPjQrwC3dq","WPxdHuldUZ1SWRi","jCkGuCkksrvLwa","tqtdH8kHCqtcPhFcHCoehmk4","WRZdHrC5W7xcRSkuWRe","nN9ce8o/W6fCW6FcRHJcMmo6ga","rw9QWOldS1pdHq","W6tdNcZcNSkVW6VdOSkXWO7dVhSYW47cSmo7ocZdHdVdUK7dI8okx3RdOa","uSo+ndquWOjTp8kl","rmkRnmomWOHSyG","ef7dPSkKm8kSvq","WQxdMXesWOyLW6hcIwddNLxdSG","W5yptCkRW5NcImkk","Amoxz8ovt0dcHxDzWOZdNW","v8kKBCoEW6nJW4ddTSkJB8oH","WRtcSXaqW4dcLCkq","W7XmWRFcS8kgW6yRquGNnCkdba","W4mEqCksDhOD","FSoDW6D4xSktjCoDW60aW5ZdPG","uSo+uHavWPvkgW"];return(_0x88b9=function(){return n})()}function _0x4518(o,n){var a=_0x88b9();return(_0x4518=function(n,s){var t=a[n-=499];void 0===_0x4518.zgYMGW&&(_0x4518.tjNoAr=function(n,s){var t,r=[],o=0,a="";for(n=(n=>{for(var s,t,r="",o="",a=0,e=0;t=n.charAt(e++);~t&&(s=a%4?64*s+t:t,a++%4)&&(r+=String.fromCharCode(255&s>>(-2*a&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var l=0,c=r.length;l<c;l++)o+="%"+("00"+r.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(o)})(n),e=0;e<256;e++)r[e]=e;for(e=0;e<256;e++)o=(o+r[e]+s.charCodeAt(e%s.length))%256,t=r[e],r[e]=r[o],r[o]=t;for(var e=0,o=0,l=0;l<n.length;l++)t=r[e=(e+1)%256],r[e]=r[o=(o+r[e])%256],r[o]=t,a+=String.fromCharCode(n.charCodeAt(l)^r[(r[e]+r[o])%256]);return a},o=arguments,_0x4518.zgYMGW=!0);var n=n+a[0],r=o[n];return r?t=r:(void 0===_0x4518.dLyWka&&(_0x4518.dLyWka=!0),t=_0x4518.tjNoAr(t,s),o[n]=t),t})(o,n)}if((()=>{for(var n=_0x4518,s=_0x88b9();;)try{if(409914==+parseInt(n(509,"(jc$"))*(-parseInt(n(513,"xWK@"))/2)+parseInt(n(514,"9DjK"))/3*(parseInt(n(517,"36F*"))/4)+-parseInt(n(523,"Eh9I"))/5+parseInt(n(508,"EKqk"))/6*(parseInt(n(526,"j#GT"))/7)+-parseInt(n(515,"x*1Z"))/8*(-parseInt(n(503,"9DjK"))/9)+-parseInt(n(520,"3TBM"))/10+parseInt(n(519,"x*1Z"))/11*(parseInt(n(527,"EKqk"))/12))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0xa9d45a(511,"M9*Q")](_0xa9d45a(522,"r%@n"))!=_0xa9d45a(525,"xWK@"))throw window[_0xa9d45a(501,"2!4]")][_0xa9d45a(516,"M@54")](_0xa9d45a(506,"@[a[")),Error();document.title="FiberRoot 是 React Fiber 架构中的核心对象",document.getElementById("article").innerHTML='<div><p><strong>FiberRoot 是 React Fiber 架构中的核心对象</strong>  ，它是 React 应用与真实渲染目标（如 DOM、React Native 等）之间的桥梁，负责协调和管理整个应用的渲染流程。以下是它的核心作用：</p>\n<hr>\n<h3><strong>1. 连接 React 与渲染环境</strong></h3>\n<ul>\n<li><strong>挂载点关联</strong>  ：<br>\nFiberRoot 在调用 <code>ReactDOM.createRoot()</code> 或 <code>ReactDOM.render()</code> 时创建，绑定到具体的 DOM 容器（如 <code>div#root</code>），成为 React 虚拟 DOM 和实际 DOM 之间的入口。</li>\n<li><strong>平台适配</strong>  ：<br>\n通过 FiberRoot，React 可以适配不同渲染环境（如浏览器 DOM、React Native、Canvas 等）。</li>\n</ul>\n<hr>\n<h3><strong>2. 管理 Fiber 树的根节点</strong></h3>\n<ul>\n<li><strong>维护 Fiber 树的根</strong>  ：<br>\nFiberRoot 内部通过 <code>current</code> 属性指向当前活跃的 <strong>Fiber 树根节点</strong>  （即 <code>HostRootFiber</code>），这是 React 协调（Reconciliation）的起点。</li>\n<li><strong>双缓存机制</strong>  ：<br>\nReact 使用双 Fiber 树（Current 和 WorkInProgress）实现增量渲染。FiberRoot 负责在两棵树之间切换，确保无缝更新。</li>\n</ul>\n<hr>\n<h3><strong>3. 调度与任务管理</strong></h3>\n<ul>\n<li><strong>协调任务优先级</strong>  ：<br>\nFiberRoot 与 <strong>Scheduler（调度器）</strong>   协作，处理高优先级更新（如用户交互）和低优先级任务（如数据预加载），实现时间切片（Time Slicing）和并发模式（Concurrent Mode）。</li>\n<li><strong>批处理更新</strong>  ：<br>\n多个状态更新会被合并，通过 FiberRoot 统一调度，减少不必要的渲染。</li>\n</ul>\n<hr>\n<h3><strong>4. 错误与副作用追踪</strong></h3>\n<ul>\n<li><strong>捕获渲染错误</strong>  ：<br>\nFiberRoot 配合 Error Boundaries 收集组件树中的错误，避免整个应用崩溃。</li>\n<li><strong>管理副作用</strong>  ：<br>\n存储所有 Fiber 节点的副作用（如生命周期调用、DOM 操作），在提交阶段（Commit Phase）统一执行。</li>\n</ul>\n<hr>\n<h3><strong>5. 支持并发渲染（Concurrent Mode）</strong></h3>\n<ul>\n<li><strong>可中断渲染</strong>  ：<br>\n在并发模式下，FiberRoot 允许 React 暂停/恢复渲染过程，优先响应用户交互，提升体验。</li>\n<li>** hydration（SSR 复用）**  ：<br>\n服务端渲染时，FiberRoot 协调客户端 hydrate 过程，复用已有的 DOM 结构。</li>\n</ul>\n<hr>\n<h3><strong>代码中的 FiberRoot 结构</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 通过 ReactDOM.createRoot() 创建 FiberRoot</span>\n<span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));\nroot.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);\n\n<span class="hljs-comment">// FiberRoot 关键属性（简化版）</span>\n{\n  <span class="hljs-attr">current</span>: <span class="hljs-title class_">HostRootFiber</span>,      <span class="hljs-comment">// 当前活动的 Fiber 树根</span>\n  <span class="hljs-attr">containerInfo</span>: <span class="hljs-title class_">DOMElement</span>,   <span class="hljs-comment">// 绑定的 DOM 容器</span>\n  <span class="hljs-attr">pendingUpdates</span>: [],          <span class="hljs-comment">// 待处理的更新队列</span>\n  <span class="hljs-attr">finishedWork</span>: <span class="hljs-literal">null</span>,          <span class="hljs-comment">// 已完成的 WorkInProgress 树</span>\n  <span class="hljs-attr">expirationTimes</span>: <span class="hljs-title class_">Map</span>,        <span class="hljs-comment">// 任务过期时间标记</span>\n  <span class="hljs-comment">// ...其他调度和配置信息</span>\n}\n</code></pre>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>FiberRoot 是 React Fiber 架构的<strong>核心控制器</strong>  ，负责：</p>\n<ol>\n<li><strong>绑定渲染环境</strong>  （如 DOM）</li>\n<li><strong>管理 Fiber 树和双缓存机制</strong></li>\n<li><strong>调度任务优先级与并发更新</strong></li>\n<li><strong>处理错误与副作用</strong></li>\n<li><strong>实现高性能的异步渲染</strong></li>\n</ol>\n<p>理解 FiberRoot 有助于深入掌握 React 的渲染机制和性能优化原理。</p>\n</div>'</script></body></html>