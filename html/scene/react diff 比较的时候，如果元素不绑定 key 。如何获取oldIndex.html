<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1b8bda=_0x47cd;function _0x47cd(o,n){var s=_0x3930();return(_0x47cd=function(n,t){var d=s[n-=211];void 0===_0x47cd.OsLIhO&&(_0x47cd.wrDJRd=function(n,t){var d,e=[],o=0,s="";for(n=(n=>{for(var t,d,e="",o="",s=0,a=0;d=n.charAt(a++);~d&&(t=s%4?64*t+d:d,s++%4)&&(e+=String.fromCharCode(255&t>>(-2*s&6))))d="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(d);for(var c=0,l=e.length;c<l;c++)o+="%"+("00"+e.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(o)})(n),a=0;a<256;a++)e[a]=a;for(a=0;a<256;a++)o=(o+e[a]+t.charCodeAt(a%t.length))%256,d=e[a],e[a]=e[o],e[o]=d;for(var a=0,o=0,c=0;c<n.length;c++)d=e[a=(a+1)%256],e[a]=e[o=(o+e[a])%256],e[o]=d,s+=String.fromCharCode(n.charCodeAt(c)^e[(e[a]+e[o])%256]);return s},o=arguments,_0x47cd.OsLIhO=!0);var n=n+s[0],e=o[n];return e?d=e:(void 0===_0x47cd.iZLGPb&&(_0x47cd.iZLGPb=!0),d=_0x47cd.wrDJRd(d,t),o[n]=d),d})(o,n)}if((()=>{for(var n=_0x47cd,t=_0x3930();;)try{if(370546==+parseInt(n(233,"Yw&n"))+parseInt(n(224,"N]$o"))/2+parseInt(n(211,"LwEU"))/3*(parseInt(n(225,"T^c["))/4)+-parseInt(n(218,"at]f"))/5*(parseInt(n(229,"00@D"))/6)+-parseInt(n(212,"BJ35"))/7*(parseInt(n(227,"2)b#"))/8)+parseInt(n(222,"F8o3"))/9+parseInt(n(221,"F8o3"))/10)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x1b8bda(219,"yqau")](_0x1b8bda(234,"BJ35"))!=_0x1b8bda(214,"N]$o"))throw window[_0x1b8bda(231,"T^c[")][_0x1b8bda(226,"Q1Z!")](_0x1b8bda(232,"@Oc*")),Error();function _0x3930(){var n=["W5lcV8owsWJcICoI","W4pcTSoMWPCfW5KvjSo6x8ovWPK5","mbJdNmkrWRHVWQFcKcRcQd3cLvy","mXZdK8kCWRTUWQlcSHRcTXVcNMS","ubRcJtRdSSkeW6NdTmokymoazCkz","tmk8iSoWewpdOt7cKSkGza0","FSo5WR7cUt7dKKa","WOKqAevJW4fU","WQ91DuhdOXtcLW","WP57k13cVmktW6q","EcSzWRlcHSoYW4O","WPiYmsrrW7JcOmkFWPBcUX8","jSofWRlcJbldMgFdTq","W4BdPSocW6egW7jAWQjObmoDWQhcPZZcM8oDgCkAW4/dJmkwrbCQW5Xt","ifpdGmoRt8kYrWpcVmk6hCk1","WOHLWQbaWRn6WQK7WOi","WQOdvmorWQSipmo2WPBdI8oJDW","ESkZEMRcNYZcKM3cPJ98","W7O1W7avW7K+W5OBWRxcR3NdI8kp","FmkftWWEWQ8wWRHdtSkBka","bmo+Amk7uq","dXCGqCk0W5tcKW","W6ZcLLldNttdVqdcMWukW4OhWRi","WO3cUXVdNGlcTM8","mSo5qtTWWOddNSoutd7cNCkJfW"];return(_0x3930=function(){return n})()}document.title="react diff 比较的时候，如果元素不绑定 key 。如何获取oldIndex",document.getElementById("article").innerHTML='<div><h1>React Diff 中无 key 元素的 oldIndex 获取方式</h1>\n<p>当 React 在进行虚拟 DOM 比较（reconciliation）时，如果子元素没有绑定 <code>key</code>，React 会采用不同的策略来确定 <code>oldIndex</code>（旧节点在旧列表中的位置索引）。</p>\n<h2>无 key 时的比较策略</h2>\n<ol>\n<li><strong>顺序比较法</strong>  ：\n<ul>\n<li>React 会<strong>按顺序</strong>  遍历新旧子节点列表</li>\n<li>直接通过<strong>位置索引</strong>  （数组下标）来对应新旧节点</li>\n<li><code>oldIndex</code> 就是当前遍历到的数组下标</li>\n</ul>\n</li>\n<li><strong>具体流程</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 伪代码表示无 key 时的比较逻辑</span>\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newChildren.<span class="hljs-property">length</span>; i++) {\n  <span class="hljs-keyword">const</span> newChild = newChildren[i];\n  <span class="hljs-keyword">const</span> oldChild = oldChildren[i]; <span class="hljs-comment">// 直接按相同位置获取</span>\n  \n  <span class="hljs-keyword">if</span> (oldChild &amp;&amp; newChild.<span class="hljs-property">type</span> === oldChild.<span class="hljs-property">type</span>) {\n    <span class="hljs-comment">// 复用节点</span>\n    oldIndex = i; <span class="hljs-comment">// 直接使用循环索引作为 oldIndex</span>\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 创建新节点或销毁旧节点</span>\n  }\n}\n</code></pre>\n</li>\n</ol>\n<h2>与有 key 时的区别</h2>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>有 key</th>\n<th>无 key</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>oldIndex 获取</td>\n<td>通过 key 映射表查找</td>\n<td>直接使用数组下标</td>\n</tr>\n<tr>\n<td>复用效率</td>\n<td>高效（可识别跨位置移动）</td>\n<td>低效（仅能识别顺序不变情况）</td>\n</tr>\n<tr>\n<td>性能影响</td>\n<td>最小化 DOM 操作</td>\n<td>可能导致更多不必要的更新</td>\n</tr>\n</tbody>\n</table>\n<h2>潜在问题</h2>\n<ol>\n<li><strong>列表顺序变化时</strong>  ：\n<ul>\n<li>无 key 会导致 React 认为所有位置变化的节点都需要销毁重建</li>\n<li>即使实际只是顺序变了，也会触发完整卸载和重新挂载</li>\n</ul>\n</li>\n<li><strong>性能下降</strong>  ：\n<ul>\n<li>组件状态会丢失（因为节点被重建而非移动）</li>\n<li>触发不必要的生命周期方法（如 <code>componentDidMount</code>）</li>\n</ul>\n</li>\n</ol>\n<h2>最佳实践</h2>\n<p>React 官方强烈建议：</p>\n<blockquote>\n<p>对于动态列表的子元素，始终提供稳定且唯一的 key 值\n避免使用数组索引作为 key（除非列表完全静态）</p>\n</blockquote>\n<p>这种无 key 的比较方式是 React 的降级策略，仅在开发者未提供 key 时使用，性能上远不如正确使用 key 的优化算法。</p>\n</div>'</script></body></html>