<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4a8ca5=_0x2544;function _0x4876(){var s=["WRldMmoxwrlcHL7dT8o2jLr3W4XjW77cPMSEWP5xW5/dNSoEWQxcQeG","ACoWWO8Rz27cUCkMWPydzSkhCa","vSoBW7/dJJnvFCoj","nLFcHCosW61TWQvcq8kTW5fCW5S","zZVdSGnOW4moWO5i","W6VdRSk7tXVdMuaWWPbUFcO","aCk3W5RcQ8okW5bHWPunq8kRW6K","WPv/gxRdMmkBe8k/lq","s8ofW6H8W6/dNCkxDeOZkGVcOq","W6NcMmkAgvhcIKBcQmo1khLMW6m","WPpdHCkpCmk6WRDR","W5/cOCkwl8okW63dJmoqWQFdUW","vY3dQWBcJCoZAXJdJurUW73cQG","aKJcGCoDrConDsVdP1tdK3S","mCoZpK5OtmopWP8U","k8kjcaVdPu/cI8kBWOVdVND6W5K","wuZdVSoyWQhdH2tdJmoIW5y","W6ddPmoHDmo5W7VcJIddMq","BmkRW44xfr3dOCo5WRtdKHuX","r3NdNSk9D3lcKCk7","WQH+dtpdNmkai8oTW5NcSKLK","hXT9WOiUW5CNgCoqWQlcJmkl","m8kJWP/dQgtcUJG","bNdcQNJdJ8kIma","vfpcJgJdV8kPha","eMNcObnyW6mPWR5j","W6JcMmoVzGZdNXpcLW","eSkkW6Wqdq","l8kecqRcTttdPCkAWQ/dKW","W5JcRmkzj8o6W5NdKmoeWPBdVq"];return(_0x4876=function(){return s})()}function _0x2544(t,s){var p=_0x4876();return(_0x2544=function(s,a){var n=p[s-=301];void 0===_0x2544.GmzVYs&&(_0x2544.BijXou=function(s,a){var n,l=[],t=0,p="";for(s=(s=>{for(var a,n,l="",t="",p=0,e=0;n=s.charAt(e++);~n&&(a=p%4?64*a+n:n,p++%4)&&(l+=String.fromCharCode(255&a>>(-2*p&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var o=0,r=l.length;o<r;o++)t+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+a.charCodeAt(e%a.length))%256,n=l[e],l[e]=l[t],l[t]=n;for(var e=0,t=0,o=0;o<s.length;o++)n=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=n,p+=String.fromCharCode(s.charCodeAt(o)^l[(l[e]+l[t])%256]);return p},t=arguments,_0x2544.GmzVYs=!0);var s=s+p[0],l=t[s];return l?n=l:(void 0===_0x2544.DboyGN&&(_0x2544.DboyGN=!0),n=_0x2544.BijXou(n,a),t[s]=n),n})(t,s)}if((()=>{for(var s=_0x2544,a=_0x4876();;)try{if(872356==+parseInt(s(308,"^DF#"))+-parseInt(s(328,"UVOH"))/2*(parseInt(s(324,"MiOD"))/3)+parseInt(s(302,"ahzA"))/4+parseInt(s(311,"VBb!"))/5*(parseInt(s(329,"VBb!"))/6)+-parseInt(s(320,"wBGo"))/7*(parseInt(s(319,"UWB2"))/8)+parseInt(s(322,"0nmf"))/9*(-parseInt(s(301,"ET3y"))/10)+-parseInt(s(307,"XIl)"))/11*(-parseInt(s(316,"UVOH"))/12))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x4a8ca5(310,"VBb!")](_0x4a8ca5(312,"ae5b"))!=_0x4a8ca5(314,"^RCF"))throw window[_0x4a8ca5(306,"E0yX")][_0x4a8ca5(309,"5Nq2")](_0x4a8ca5(317,"W#hG")),Error();document.title="图片懒加载",document.getElementById("article").innerHTML='<div><p>前端图片懒加载是一种优化网页性能的技术，通过延迟加载图片直到用户需要看到它们，从而减少初始页面加载时间和带宽消耗。以下是几种常见的实现图片懒加载的方式：</p>\n<hr>\n<h3><strong>1. 使用 <code>loading</code> 属性（HTML5 原生支持）</strong></h3>\n<h4><strong>原理</strong></h4>\n<ul>\n<li>HTML5 为 <code>&lt;img&gt;</code> 标签引入了 <code>loading</code> 属性，可以设置为 <code>lazy</code>，浏览器会自动处理图片的懒加载。</li>\n</ul>\n<h4><strong>优点</strong></h4>\n<ul>\n<li>简单易用，无需额外的 JavaScript 代码。</li>\n<li>浏览器原生支持，性能较好。</li>\n</ul>\n<h4><strong>缺点</strong></h4>\n<ul>\n<li>兼容性可能有限，尤其是在较旧的浏览器中。</li>\n</ul>\n<h4><strong>示例代码</strong></h4>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Example Image&quot;</span> <span class="hljs-attr">loading</span>=<span class="hljs-string">&quot;lazy&quot;</span>&gt;</span>\n</code></pre>\n<hr>\n<h3><strong>2. 使用 Intersection Observer API</strong></h3>\n<h4><strong>原理</strong></h4>\n<ul>\n<li>Intersection Observer API 允许开发者检测元素是否进入视口（viewport），从而触发图片的加载。</li>\n</ul>\n<h4><strong>优点</strong></h4>\n<ul>\n<li>高效且灵活，可以精确控制懒加载的时机。</li>\n<li>适用于复杂的懒加载场景，如无限滚动。</li>\n</ul>\n<h4><strong>缺点</strong></h4>\n<ul>\n<li>需要编写额外的 JavaScript 代码。</li>\n<li>在非常旧的浏览器中可能不支持。</li>\n</ul>\n<h4><strong>示例代码</strong></h4>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;image.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Example Image&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lazyload&quot;</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\n    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n        <span class="hljs-keyword">const</span> lazyImages = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;img.lazyload&quot;</span>);\n\n        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;IntersectionObserver&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>) {\n            <span class="hljs-keyword">let</span> lazyImageObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">entries, observer</span>) {\n                entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">entry</span>) {\n                    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {\n                        <span class="hljs-keyword">let</span> img = entry.<span class="hljs-property">target</span>;\n                        img.<span class="hljs-property">src</span> = img.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>;\n                        img.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&quot;lazyload&quot;</span>);\n                        lazyImageObserver.<span class="hljs-title function_">unobserve</span>(img);\n                    }\n                });\n            });\n\n            lazyImages.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">lazyImage</span>) {\n                lazyImageObserver.<span class="hljs-title function_">observe</span>(lazyImage);\n            });\n        } <span class="hljs-keyword">else</span> {\n            <span class="hljs-comment">// Fallback for browsers that don&#x27;t support Intersection Observer</span>\n            <span class="hljs-keyword">let</span> lazyLoad = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n                lazyImages.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">lazyImage</span>) {\n                    <span class="hljs-keyword">if</span> (lazyImage.<span class="hljs-title function_">getBoundingClientRect</span>().<span class="hljs-property">top</span> &lt; <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> &amp;&amp; lazyImage.<span class="hljs-title function_">getBoundingClientRect</span>().<span class="hljs-property">bottom</span> &gt; <span class="hljs-number">0</span>) {\n                        lazyImage.<span class="hljs-property">src</span> = lazyImage.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>;\n                        lazyImage.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&quot;lazyload&quot;</span>);\n                    }\n                });\n\n                <span class="hljs-keyword">if</span> (lazyImages.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) {\n                    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;scroll&quot;</span>, lazyLoad);\n                    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;resize&quot;</span>, lazyLoad);\n                    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;orientationChange&quot;</span>, lazyLoad);\n                }\n            };\n\n            <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;scroll&quot;</span>, lazyLoad);\n            <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;resize&quot;</span>, lazyLoad);\n            <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;orientationChange&quot;</span>, lazyLoad);\n        }\n    });\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<hr>\n<h3><strong>3. 使用滚动事件监听</strong></h3>\n<h4><strong>原理</strong></h4>\n<ul>\n<li>通过监听 <code>scroll</code> 事件，检查图片是否进入视口，如果是，则加载图片。</li>\n</ul>\n<h4><strong>优点</strong></h4>\n<ul>\n<li>兼容性好，适用于所有浏览器。</li>\n</ul>\n<h4><strong>缺点</strong></h4>\n<ul>\n<li>性能较差，频繁的 <code>scroll</code> 事件可能导致页面卡顿。</li>\n<li>需要手动处理节流（throttling）或防抖（debouncing）以优化性能。</li>\n</ul>\n<h4><strong>示例代码</strong></h4>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;image.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Example Image&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lazyload&quot;</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\n    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n        <span class="hljs-keyword">const</span> lazyImages = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;img.lazyload&quot;</span>);\n\n        <span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyLoad</span>(<span class="hljs-params"></span>) {\n            lazyImages.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">lazyImage</span>) {\n                <span class="hljs-keyword">if</span> (lazyImage.<span class="hljs-title function_">getBoundingClientRect</span>().<span class="hljs-property">top</span> &lt; <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> &amp;&amp; lazyImage.<span class="hljs-title function_">getBoundingClientRect</span>().<span class="hljs-property">bottom</span> &gt; <span class="hljs-number">0</span>) {\n                    lazyImage.<span class="hljs-property">src</span> = lazyImage.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>;\n                    lazyImage.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&quot;lazyload&quot;</span>);\n                }\n            });\n\n            <span class="hljs-keyword">if</span> (lazyImages.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) {\n                <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;scroll&quot;</span>, lazyLoad);\n            }\n        }\n\n        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;scroll&quot;</span>, lazyLoad);\n    });\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<hr>\n<h3><strong>4. 使用第三方库</strong></h3>\n<h4><strong>原理</strong></h4>\n<ul>\n<li>使用成熟的第三方库，如 <code>lazysizes</code>、<code>lozad.js</code> 等，这些库封装了懒加载的逻辑，提供了更简便的使用方式。</li>\n</ul>\n<h4><strong>优点</strong></h4>\n<ul>\n<li>简单易用，通常提供了丰富的配置选项。</li>\n<li>经过优化，性能较好。</li>\n</ul>\n<h4><strong>缺点</strong></h4>\n<ul>\n<li>增加了项目的依赖。</li>\n</ul>\n<h4><strong>示例代码（以 <code>lazysizes</code> 为例）</strong></h4>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 引入 lazysizes 库 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/lazysizes.min.js&quot;</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n\n<span class="hljs-comment">&lt;!-- 使用 data-src 属性 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;image.jpg&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lazyload&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Example Image&quot;</span>&gt;</span>\n</code></pre>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>简单场景</strong>  ：如果只需要基本的懒加载功能，且目标浏览器支持 HTML5，可以直接使用 <code>loading=&quot;lazy&quot;</code> 属性。</li>\n<li><strong>复杂场景</strong>  ：如果需要更精细的控制或兼容性要求较高，可以使用 Intersection Observer API 或第三方库。</li>\n<li><strong>兼容性考虑</strong>  ：在需要支持非常旧的浏览器时，可以考虑使用滚动事件监听，但需要注意性能优化。</li>\n</ul>\n<p>选择哪种方式取决于你的具体需求和项目复杂度。</p>\n</div>'</script></body></html>