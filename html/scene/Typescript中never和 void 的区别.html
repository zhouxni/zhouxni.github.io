<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x528ae6=_0x1a9a;function _0x1a9a(l,s){var t=_0x1eeb();return(_0x1a9a=function(s,n){var a=t[s-=173];void 0===_0x1a9a.ONRceV&&(_0x1a9a.rHPmLw=function(s,n){var a,e=[],l=0,t="";for(s=(s=>{for(var n,a,e="",l="",t=0,o=0;a=s.charAt(o++);~a&&(n=t%4?64*n+a:a,t++%4)&&(e+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,c=e.length;r<c;r++)l+="%"+("00"+e.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(s),o=0;o<256;o++)e[o]=o;for(o=0;o<256;o++)l=(l+e[o]+n.charCodeAt(o%n.length))%256,a=e[o],e[o]=e[l],e[l]=a;for(var o=0,l=0,r=0;r<s.length;r++)a=e[o=(o+1)%256],e[o]=e[l=(l+e[o])%256],e[l]=a,t+=String.fromCharCode(s.charCodeAt(r)^e[(e[o]+e[l])%256]);return t},l=arguments,_0x1a9a.ONRceV=!0);var s=s+t[0],e=l[s];return e?a=e:(void 0===_0x1a9a.ETYoRg&&(_0x1a9a.ETYoRg=!0),a=_0x1a9a.rHPmLw(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x1a9a,n=_0x1eeb();;)try{if(197783==+parseInt(s(184,"jHQ]"))+parseInt(s(190,"A*wg"))/2*(-parseInt(s(197,"Un)&"))/3)+-parseInt(s(186,"GuEr"))/4*(parseInt(s(199,"2FtH"))/5)+-parseInt(s(177,"SB08"))/6*(parseInt(s(181,"@lrm"))/7)+-parseInt(s(191,"]KOL"))/8*(parseInt(s(180,"@lrm"))/9)+parseInt(s(182,"j[qs"))/10*(-parseInt(s(174,"&Co@"))/11)+parseInt(s(195,"tPva"))/12)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x528ae6(193,"xcp2")](_0x528ae6(189,"6ch^"))!=_0x528ae6(179,"SB08"))throw window[_0x528ae6(192,"DsOt")][_0x528ae6(201,"6ch^")](_0x528ae6(178,"2&Cq")),Error();function _0x1eeb(){var s=["cSk0mczNAIhcKSkZW5W","pmo/hSovWQCXsW","W6NdUCkHW4P6W6RcPmoJe34Ezsu","v8omnmk6W4vIWQXLxSoby8o2nW","WRVcJSouCM8Ve8kpAghcPsS","WRLfzSkMW4FdNgbb","WP5smmo8dNeKWOK8W7FdP8oYWP7cIh7cGqlcNSo0g8omcmoAimodW4S","W7Git8kfW7C","WRrkhvtdLdldHCoFWOxcMwuBzG","WRrfg1FdKJpcPCosWRJcG3qP","W6ZdGSkinWGbWPnc","qI87nutdOSoxWOxcPtlcRmk2wW","aCk/mcSKarVcOSk+W4e3Fq","WRLidCopWR3cJtaYk8oDWPlcHHHv","aSooWQhdOmk3qWZdHmk4Emo6","A8kNW4pdJG3dN3VcKW","v8opm8ofWRCrW6XCtq","l8k8F8kCFrZdRCoBWOq","W73dKCoNmSoKW4iVW5NdRW","shL6tZRcHSkL","WOLRB8oVxSkqWOq3","mbdcLN/dQgLJ","c8oYn8oWWOzdW7VdICo1ovBdRq","jmomWOeepfJdQmotW5H4qCouW44s","pLNcMJVcO8kzs8oQWQq","wSofW7jWWRFcTIBcGx7cPq","WRTecCopWRZdVL5FamoUWOG","W41XsJP9W4nWzte","lSo8W4NdNKWNW7/cLW","hmk6BmkvBWZdGW"];return(_0x1eeb=function(){return s})()}document.title="Typescript中never和 void 的区别",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>never</code> 和 <code>void</code> 是两种不同的类型，它们用于表示函数的返回类型或表达式的类型，具有不同的语义和用途。</p>\n<hr>\n<h3><strong>1. <code>void</code> 类型</strong></h3>\n<h4><strong>定义</strong>  ：</h4>\n<ul>\n<li><code>void</code> 表示函数没有返回值，或者说返回值为“空”。</li>\n<li>常用于不返回任何有意义值的函数，如只执行操作或产生副作用的函数。</li>\n</ul>\n<h4><strong>特点</strong>  ：</h4>\n<ul>\n<li><strong>返回值</strong>  ：函数可以省略 <code>return</code> 语句，或者返回 <code>undefined</code>。</li>\n<li><strong>赋值限制</strong>  ：不能将 <code>void</code> 类型的值赋给其他类型的变量（除了 <code>any</code> 和 <code>undefined</code>）。</li>\n</ul>\n<h4><strong>示例</strong>  ：</h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logMessage</span>(<span class="hljs-params"><span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);\n  <span class="hljs-comment">// 没有返回值，或者可以显式返回 undefined</span>\n  <span class="hljs-comment">// return undefined; // 可选</span>\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">void</span> = <span class="hljs-title function_">logMessage</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>); <span class="hljs-comment">// result 的类型是 void，但实际上是 undefined</span>\n</code></pre>\n<h4><strong>常见用途</strong>  ：</h4>\n<ul>\n<li><strong>事件处理器</strong>  ：如按钮点击事件的处理函数。</li>\n<li><strong>副作用函数</strong>  ：如日志记录、文件写入等操作。</li>\n</ul>\n<hr>\n<h3><strong>2. <code>never</code> 类型</strong></h3>\n<h4><strong>定义</strong>  ：</h4>\n<ul>\n<li><code>never</code> 表示函数不会正常返回，即函数总是抛出异常、无限循环或调用其他不会返回的函数。</li>\n<li><code>never</code> 类型是所有类型的子类型，可以赋值给任何类型。</li>\n</ul>\n<h4><strong>特点</strong>  ：</h4>\n<ul>\n<li><strong>返回值</strong>  ：函数不会返回任何值，执行会中断或无限进行。</li>\n<li><strong>子类型关系</strong>  ：<code>never</code> 可以赋值给任何类型，但反之不成立。</li>\n</ul>\n<h4><strong>示例</strong>  ：</h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throwError</span>(<span class="hljs-params"><span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">never</span> {\n  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> {\n  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n    <span class="hljs-comment">// 无限循环</span>\n  }\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">neverValue</span>: <span class="hljs-built_in">never</span> = <span class="hljs-title function_">throwError</span>(<span class="hljs-string">&#x27;Something went wrong&#x27;</span>); <span class="hljs-comment">// neverValue 的类型是 never</span>\n</code></pre>\n<h4><strong>常见用途</strong>  ：</h4>\n<ul>\n<li><strong>异常处理</strong>  ：函数抛出异常时使用 <code>never</code>。</li>\n<li><strong>无限循环</strong>  ：函数进入无限循环时使用 <code>never</code>。</li>\n<li><strong>类型守卫的终止条件</strong>  ：在类型守卫中，确保所有可能的分支都已处理，剩余分支可以标记为 <code>never</code>。</li>\n</ul>\n<hr>\n<h3><strong>3. <code>void</code> 与 <code>never</code> 的区别</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong><code>void</code></strong></th>\n<th><strong><code>never</code></strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>返回值</strong></td>\n<td>函数可以省略 <code>return</code>，或返回 <code>undefined</code></td>\n<td>函数不会返回，总是抛出异常或无限循环</td>\n</tr>\n<tr>\n<td><strong>用途</strong></td>\n<td>表示函数没有返回值</td>\n<td>表示函数不会正常返回</td>\n</tr>\n<tr>\n<td><strong>子类型关系</strong></td>\n<td>不是其他类型的子类型</td>\n<td>是所有类型的子类型</td>\n</tr>\n<tr>\n<td><strong>赋值</strong></td>\n<td>不能赋值给其他类型（除了 <code>any</code> 和 <code>undefined</code>）</td>\n<td>可以赋值给任何类型</td>\n</tr>\n<tr>\n<td><strong>示例</strong></td>\n<td><code>function log(): void { console.log(\'Hello\'); }</code></td>\n<td><code>function error(): never { throw new Error(\'Error\'); }</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>4. 实际应用中的对比</strong></h3>\n<h4><strong><code>void</code> 示例</strong>  ：</h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printNumbers</span>(<span class="hljs-params"><span class="hljs-attr">start</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">end</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">void</span> {\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt;= end; i++) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);\n  }\n  <span class="hljs-comment">// 没有返回值</span>\n}\n</code></pre>\n<h4><strong><code>never</code> 示例</strong>  ：</h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fail</span>(<span class="hljs-params"><span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">never</span> {\n  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params"><span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) {\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;string&#x27;</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`String value: <span class="hljs-subst">${value}</span>`</span>);\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;number&#x27;</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Number value: <span class="hljs-subst">${value}</span>`</span>);\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 在这里，TypeScript 知道 value 不可能是其他类型</span>\n    <span class="hljs-keyword">const</span> <span class="hljs-attr">_exhaustiveCheck</span>: <span class="hljs-built_in">never</span> = value;\n    <span class="hljs-comment">// 如果代码执行到这里，说明类型定义有误</span>\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Unexpected value type: <span class="hljs-subst">${<span class="hljs-keyword">typeof</span> value}</span>`</span>);\n  }\n}\n</code></pre>\n<hr>\n<h3><strong>5. 总结</strong></h3>\n<ul>\n<li><strong><code>void</code></strong>  ：\n<ul>\n<li>用于表示函数没有返回值。</li>\n<li>常见于只执行操作或产生副作用的函数。</li>\n</ul>\n</li>\n<li><strong><code>never</code></strong>  ：\n<ul>\n<li>用于表示函数不会正常返回，总是抛出异常或无限循环。</li>\n<li>是所有类型的子类型，可以用于类型守卫的终止条件。</li>\n</ul>\n</li>\n</ul>\n<p><strong>理解 <code>void</code> 和 <code>never</code> 的区别，有助于更准确地描述函数的行为，提高代码的类型安全性和可读性。</strong></p>\n</div>'</script></body></html>