<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5b190d=_0x242d;function _0x6fb3(){var s=["WQjxW75EWOPpjgS","WO3dNmoTcSoVFSoDWQ4","bdS/WQWpW5lcMCk2Emk5WP7dTq","jayCW7yuvwTwjCkvorpdVa","x8kljSoIz8kOW4BdGq","dazuW7iEjCo0WPO","aHNcK8k5W5eIeKH1AWKt","W4pdP8kJWQS3teLSW7VdGJC7W60","W6qOq2xdHG","bSoni8oFuSoaWQlcJCo+W6CHWOabkaZdKaXdWQlcPIWRWRqjkmor","W5VcI8oOdSoDsCo7","W6reWOnaW6aTkWdcHSkLnCo9xG","bSkVoSojsN3cGHpdL8kZWPn5W7m","x8kUWR3dPCoyWQ3cJa","xCoPh8khyuCK","WQ1CrSoJW4eDWRldSG","vN8EWRZdUmkceSklcqhdNJFcJq","oLL2W7SXWQu4","a8kWhWRdLWJcRaFcKG9upwK","W7dcUGFdSvtdLCkIvmky","ybZdQmklW7JdKSkIgmofWR3cQvG","r8kwWQ7dNwtcQ8oDWOKiW5Hha8k+","WR3cQfKSWP9IwSolx8odiK0N","F8kpW6VdTmkVW7RdMNTHWRRcSh/cNW","yvm9px1xW7lcG8o7ECokWQO","WO7cGh8MWP/cNCo9W7pdOCoAbmkyWPO"];return(_0x6fb3=function(){return s})()}function _0x242d(e,s){var l=_0x6fb3();return(_0x242d=function(s,n){var a=l[s-=349];void 0===_0x242d.wrCFqG&&(_0x242d.aliQIW=function(s,n){var a,t=[],e=0,l="";for(s=(s=>{for(var n,a,t="",e="",l=0,o=0;a=s.charAt(o++);~a&&(n=l%4?64*n+a:a,l++%4)&&(t+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,p=t.length;c<p;c++)e+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),o=0;o<256;o++)t[o]=o;for(o=0;o<256;o++)e=(e+t[o]+n.charCodeAt(o%n.length))%256,a=t[o],t[o]=t[e],t[e]=a;for(var o=0,e=0,c=0;c<s.length;c++)a=t[o=(o+1)%256],t[o]=t[e=(e+t[o])%256],t[e]=a,l+=String.fromCharCode(s.charCodeAt(c)^t[(t[o]+t[e])%256]);return l},e=arguments,_0x242d.wrCFqG=!0);var s=s+l[0],t=e[s];return t?a=t:(void 0===_0x242d.yOBAab&&(_0x242d.yOBAab=!0),a=_0x242d.aliQIW(a,n),e[s]=a),a})(e,s)}if((()=>{for(var s=_0x242d,n=_0x6fb3();;)try{if(470007==+parseInt(s(354,"1NQR"))*(parseInt(s(366,"DVgo"))/2)+-parseInt(s(358,"JEXm"))/3+parseInt(s(363,"NU6W"))/4+parseInt(s(368,"6!Jj"))/5*(parseInt(s(356,"z8XO"))/6)+parseInt(s(374,"%LDi"))/7+-parseInt(s(349,"*a1u"))/8+-parseInt(s(373,"S*Wx"))/9*(parseInt(s(367,"jwFB"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5b190d(362,"fR2i")](_0x5b190d(371,"21Ar"))!=_0x5b190d(360,"hipC"))throw window[_0x5b190d(357,"^hEb")][_0x5b190d(365,"Nbvh")](_0x5b190d(361,"z8XO")),Error();document.title="说说你对 React Hook的闭包陷阱的理解,有哪些解决方案",document.getElementById("article").innerHTML='<div><p><strong>React Hook的闭包陷阱</strong>  是指在使用 React Hooks 时，由于闭包特性导致在某些函数或异步操作中无法正确访问到更新后的状态或 prop 的值，而仍旧使用了旧值。闭包陷阱的本质原因是 JavaScript 闭包特性与 Hooks 执行机制的相互作用。</p>\n<h3>闭包陷阱的具体表现</h3>\n<ol>\n<li><strong>useState闭包陷阱</strong>  ：在异步回调中（如 <code>setTimeout</code> 或 <code>Promise</code>）获取不到最新的 state 状态值。例如，在 <code>setTimeout</code> 中访问 <code>useState</code> 的状态值时，总是获取到初始值，而非更新后的值。</li>\n<li><strong>useEffect闭包陷阱</strong>  ：当 <code>useEffect</code> 的依赖数组为空时，effect 只在组件挂载时执行一次，此时回调函数捕获的是当时的 state。当 state 更新后，由于 effect 没有重新执行，回调函数仍然引用旧的 state。</li>\n</ol>\n<h3>闭包陷阱的解决方案</h3>\n<ol>\n<li><strong>正确声明依赖项</strong>  ：\n<ul>\n<li>在 <code>useEffect</code> 的依赖数组中添加所有相关的 state 和 props，确保当它们变化时，effect 会重新执行。</li>\n<li>优点：简单直观，符合 React 数据流。</li>\n<li>缺点：频繁变更的依赖会导致副作用反复销毁/重建（如定时器重启）。</li>\n</ul>\n</li>\n<li><strong>使用 <code>useRef</code> 保存最新值</strong>  ：\n<ul>\n<li><code>useRef</code> 是一个简单的解决方案，它不会随着组件的重新渲染而改变，可以用来存储最新的 state 值。</li>\n<li>原理：<code>useRef</code> 的 <code>.current</code> 属性可变且跨渲染周期持久化。</li>\n<li>适用场景：需在异步回调中访问最新状态，但不想触发副作用重建。</li>\n</ul>\n</li>\n<li><strong>函数式更新</strong>  ：\n<ul>\n<li>使用 <code>setState</code> 的函数形式，从参数拿到上一次的 state，这样就不会形成闭包。</li>\n<li>优点：<code>setState(c =&gt; c + 1)</code> 直接基于最新状态更新，无需手动跟踪。</li>\n<li>局限：仅适用于 <code>setState</code> 场景，无法直接获取其他状态的最新值。</li>\n</ul>\n</li>\n<li><strong>使用 <code>useReducer</code> 集中状态逻辑</strong>  ：\n<ul>\n<li><code>useReducer</code> 总是能访问最新状态，适合复杂逻辑。</li>\n<li>机制：更新逻辑集中在 reducer 中，与闭包解耦。</li>\n</ul>\n</li>\n<li><strong>封装自定义 Hook</strong>  ：\n<ul>\n<li>为了复用逻辑并减少出错，可以封装一个自定义 Hook 来处理异步操作，确保其始终使用最新的 state。</li>\n</ul>\n</li>\n<li><strong>清理副作用</strong>  ：\n<ul>\n<li>在组件卸载或依赖变化时，确保清理副作用（如清除定时器、取消网络请求等），避免内存泄漏或不必要的副作用。</li>\n</ul>\n</li>\n</ol>\n<h3>示例代码</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useEffect, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);\n  <span class="hljs-keyword">const</span> countRef = <span class="hljs-title function_">useRef</span>(count);\n\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    countRef.<span class="hljs-property">current</span> = count; <span class="hljs-comment">// 实时同步最新值</span>\n  }, [count]);\n\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(countRef.<span class="hljs-property">current</span>); <span class="hljs-comment">// 使用最新的值</span>\n    }, <span class="hljs-number">1000</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);\n  }, []);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(c =&gt; c + 1)}&gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Counter</span>;\n</code></pre>\n<h3>总结</h3>\n<p>闭包陷阱是 React Hooks 使用中常见的痛点，但通过正确声明依赖项、使用 <code>useRef</code> 保存最新值、函数式更新、<code>useReducer</code> 集中状态逻辑以及封装自定义 Hook 等解决方案，可以有效避免闭包陷阱带来的问题。在实际开发中，应根据具体情况选择合适的解决方案，确保组件的状态和副作用管理正确无误。</p>\n</div>'</script></body></html>