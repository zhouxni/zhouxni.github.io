<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x312f48=_0x1554;if((()=>{for(var n=_0x1554,s=_0x22bd();;)try{if(413918==+parseInt(n(126,"NSqn"))+-parseInt(n(132,"OADf"))/2*(-parseInt(n(137,"A2ja"))/3)+-parseInt(n(138,"6eYN"))/4*(parseInt(n(121,"K%5*"))/5)+parseInt(n(128,"Ju@k"))/6*(-parseInt(n(116,"Fm0r"))/7)+-parseInt(n(134,"pNkq"))/8*(-parseInt(n(125,"v]Iw"))/9)+-parseInt(n(115,"Atv^"))/10*(-parseInt(n(112,"QTkN"))/11)+-parseInt(n(131,"6eYN"))/12)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x312f48(120,"!b$)")](_0x312f48(122,"3*bg"))!=_0x312f48(133,"i6A6"))throw window[_0x312f48(127,"xUWk")][_0x312f48(113,"b%LP")](_0x312f48(140,"b%LP")),Error();function _0x1554(e,n){var c=_0x22bd();return(_0x1554=function(n,s){var a=c[n-=111];void 0===_0x1554.SEZJLI&&(_0x1554.eqCzOG=function(n,s){var a,t=[],e=0,c="";for(n=(n=>{for(var s,a,t="",e="",c=0,d=0;a=n.charAt(d++);~a&&(s=c%4?64*s+a:a,c++%4)&&(t+=String.fromCharCode(255&s>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,r=t.length;p<r;p++)e+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(n),d=0;d<256;d++)t[d]=d;for(d=0;d<256;d++)e=(e+t[d]+s.charCodeAt(d%s.length))%256,a=t[d],t[d]=t[e],t[e]=a;for(var d=0,e=0,p=0;p<n.length;p++)a=t[d=(d+1)%256],t[d]=t[e=(e+t[d])%256],t[e]=a,c+=String.fromCharCode(n.charCodeAt(p)^t[(t[d]+t[e])%256]);return c},e=arguments,_0x1554.SEZJLI=!0);var n=n+c[0],t=e[n];return t?a=t:(void 0===_0x1554.CmMMmD&&(_0x1554.CmMMmD=!0),a=_0x1554.eqCzOG(a,s),e[n]=a),a})(e,n)}function _0x22bd(){var n=["cmovWP55W5VdQW5A","W7zmW5e3nSoUfCoM","mwRcVIzNvSkOW4ZdSCkrra","W6OQvCkUW7lcMY46W59IfW","cmkFW5xdGmkTWPaNymkRumk9","W6CxqMGirw7dJbFdK8ovhMC","WQK7WQ0ipmo7WPq","wCoMjhldVKVcLW","EsGrx8oWzxhcTdK","W7qlWRicAspcVCoyWQRdIG","ywWmx8k9mf7dKG","WQtdT8opW6nNA8onnM8dqG","W5aFthrmgLD3W6pcNNu","WOxdMmkzzd0aWRRcMG","CSoBacVdJdWtoW","WQtdSCodW6nNfSkaieC4wYRdKa","WRBcLbVdO2hdLCkJW5n5h3vJW6q","cmkyW53dHmkQW6DKj8kVsSkYWRSCWPS","WRS/imkKWRvAAW","f8o4W4qpW5a","hSkpqCkMW5P9WQhdNgRcNa","muSSWPKwW5FcIa","W79UW6H2EmkSW48EW58wW6ycs8kt","WPeaW4GEe8oiWRtcQwBcPwaAwG","c8krW5tdI8kTW61QxmkTr8kJWQia","gmoViSoQW4z7WOK","oCktzvP5gfpdQCoAAwZdGwfyWOL7W4yrzCoVWPJcSCoPzmkdWP8","W6bxgLZdGu7cOtldHXb5","W60+kwORW6CueSovW5SnyJO","i8kcyuzRqrK"];return(_0x22bd=function(){return n})()}document.title="canvas 位图是物理像素",document.getElementById("article").innerHTML='<div><p>Canvas 的位图（Bitmap）本质上是基于物理像素的，但它的实际显示效果取决于 Canvas 的像素分辨率（<code>width</code>/<code>height</code> 属性）和 设备像素比（DPR）。以下是详细解析：</p>\n<hr>\n<p><strong>1. Canvas 位图的本质</strong><br>\n<strong>(1) Canvas 的 <code>width</code> 和 <code>height</code> 决定位图像素</strong></p>\n<ul>\n<li>Canvas 的 <code>width</code> 和 <code>height</code>（HTML 属性或 JS 设置） 定义了它的像素分辨率（即画布内部位图的物理像素数量）。</li>\n</ul>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;800&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;600&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span>\n</code></pre>\n<pre><code class="language-javascript">canvas.<span class="hljs-property">width</span> = <span class="hljs-number">800</span>;  <span class="hljs-comment">// 位图像素宽度（物理像素）</span>\ncanvas.<span class="hljs-property">height</span> = <span class="hljs-number">600</span>; <span class="hljs-comment">// 位图像素高度（物理像素）</span>\n</code></pre>\n<ul>\n<li>绘制操作（如 <code>fillRect()</code>、<code>drawImage()</code>）直接作用于这些像素，不受 CSS 缩放影响。</li>\n</ul>\n<p><strong>(2) 位图像素 ≠ CSS 像素</strong></p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Canvas 位图像素</th>\n<th>CSS 像素</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>控制方式</td>\n<td><code>canvas.width/height</code></td>\n<td><code>style.width/height</code></td>\n</tr>\n<tr>\n<td>本质</td>\n<td>物理像素（位图存储）</td>\n<td>逻辑像素（显示尺寸）</td>\n</tr>\n<tr>\n<td>缩放影响</td>\n<td>无（固定分辨率）</td>\n<td>可能被浏览器缩放</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>2. 设备像素比（DPR）的影响</strong><br>\n<code>window.devicePixelRatio</code>（DPR）表示 1 CSS 像素对应多少物理像素：</p>\n<ul>\n<li>\n<p>普通屏幕（DPR = 1）：1 CSS 像素 = 1 物理像素。</p>\n</li>\n<li>\n<p>Retina 屏（DPR = 2）：1 CSS 像素 = 2×2 物理像素。</p>\n</li>\n</ul>\n<p><strong>Canvas 在高 DPR 设备上的问题</strong><br>\n如果 Canvas 的 <code>width</code>/<code>height</code> 未适配 DPR：</p>\n<ul>\n<li>\n<p>位图像素不足 → 被拉伸显示，导致模糊。</p>\n</li>\n<li>\n<p>解决方案：根据 DPR 缩放 Canvas 分辨率：</p>\n</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;canvas&#x27;</span>);\n<span class="hljs-keyword">const</span> dpr = <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span> || <span class="hljs-number">1</span>;\n\n<span class="hljs-comment">// 获取 CSS 显示尺寸</span>\n<span class="hljs-keyword">const</span> rect = canvas.<span class="hljs-title function_">getBoundingClientRect</span>();\n\n<span class="hljs-comment">// 设置 Canvas 位图像素 = CSS 尺寸 × DPR</span>\ncanvas.<span class="hljs-property">width</span> = rect.<span class="hljs-property">width</span> * dpr;\ncanvas.<span class="hljs-property">height</span> = rect.<span class="hljs-property">height</span> * dpr;\n\n<span class="hljs-comment">// 缩放绘图上下文，确保绘制逻辑匹配 CSS 尺寸</span>\n<span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&#x27;2d&#x27;</span>);\nctx.<span class="hljs-title function_">scale</span>(dpr, dpr);\n</code></pre>\n<p>效果：</p>\n<ul>\n<li>\n<p>位图分辨率提高（如 <code>800×600</code> → <code>1600×1200</code>），适配 Retina 屏。</p>\n</li>\n<li>\n<p>绘图时仍使用 CSS 像素单位（<code>ctx.fillRect(10, 10, 100, 50)</code>），但实际渲染为高清物理像素。</p>\n</li>\n</ul>\n<hr>\n<p><strong>3. 总结</strong></p>\n<table>\n<thead>\n<tr>\n<th>问题</th>\n<th>答案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Canvas 位图是物理像素吗？</td>\n<td>是的，<code>canvas.width/height</code> 定义的位图像素是物理像素。</td>\n</tr>\n<tr>\n<td>是否会受 DPR 影响？</td>\n<td>是，未适配 DPR 时，位图会被拉伸，可能模糊。</td>\n</tr>\n<tr>\n<td>如何保证高清显示？</td>\n<td>根据 <code>devicePixelRatio</code> 缩放 <code>canvas.width/height</code>，并调整绘图上下文。</td>\n</tr>\n</tbody>\n</table>\n<p>关键结论：</p>\n<ul>\n<li>\n<p>Canvas 位图本质是物理像素，但需结合 DPR 优化显示。</p>\n</li>\n<li>\n<p>CSS 像素仅影响 Canvas 的显示尺寸，不改变位图分辨率。</p>\n</li>\n<li>\n<p>适配高 DPR 设备需主动缩放 Canvas 分辨率，避免模糊。</p>\n</li>\n</ul>\n</div>'</script></body></html>