<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x177719=_0x547f;function _0x547f(a,n){var o=_0x1771();return(_0x547f=function(n,s){var t=o[n-=333];void 0===_0x547f.krXXYa&&(_0x547f.EpftXw=function(n,s){var t,e=[],a=0,o="";for(n=(n=>{for(var s,t,e="",a="",o=0,l=0;t=n.charAt(l++);~t&&(s=o%4?64*s+t:t,o++%4)&&(e+=String.fromCharCode(255&s>>(-2*o&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var r=0,c=e.length;r<c;r++)a+="%"+("00"+e.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(a)})(n),l=0;l<256;l++)e[l]=l;for(l=0;l<256;l++)a=(a+e[l]+s.charCodeAt(l%s.length))%256,t=e[l],e[l]=e[a],e[a]=t;for(var l=0,a=0,r=0;r<n.length;r++)t=e[l=(l+1)%256],e[l]=e[a=(a+e[l])%256],e[a]=t,o+=String.fromCharCode(n.charCodeAt(r)^e[(e[l]+e[a])%256]);return o},a=arguments,_0x547f.krXXYa=!0);var n=n+o[0],e=a[n];return e?t=e:(void 0===_0x547f.EmOSqB&&(_0x547f.EmOSqB=!0),t=_0x547f.EpftXw(t,s),a[n]=t),t})(a,n)}function _0x1771(){var n=["W5NdLwlcHxZcG3pdUG","WOyXodZcRmopkW","tgysW4ZdTCkIW6XxW6bYWOPvBW","wNqGW4/dVhRdSq","WOSXDHa0WRPAx8kSwGxcICkUoeFcI8oBtmoThSoAW4JcTCkWou8","W4dcSuTnWRBdJMBdPJHjWPuHzG","kmkCz8o3wK7cQWG","iqL3D8ojWRZdKmk5WOldG8onfhddLa","gCo3emkXW7PdW5PLWP3cGbhcNa","oCoSW6WEnCk3WOtdUmkkW6hcOSkdW7as","W73cPCopfbn0WPVdLbXT","WQ7cICkVWO5yWOBdO1TBimkeW5K","WQCcW4/dJmkcW5JcS8ojWQtdUq","WQNcI8kLWO1FWORcLLDppCkvW5xdGa","tSk3W6KwpmoYWRRcLSkdW4K","W4BcSuboWRpdJ27dGrnoWQa8za","W4G8WOtcSCoCW7ldNH1AzW","fmkPqu3cHCoqhH/dNq","FCkbbSkkomkoWQzcW5dcSYSt","xCkunIajyxL1xW","W4dcS0XlW5hcNq/dUdLk","fmkrqmorWO8qW4W","v8k/eIhcVq","WOpcIMFcNL/cNhVdUq","j8ozFSklW5JcMsO","CSoKW5rmWRxcV0dcUSoHW6e","W4FcT0TaWRhdHJNdVbPyWOOK","WOXqAJpcH8oxht3cQa"];return(_0x1771=function(){return n})()}if((()=>{for(var n=_0x547f,s=_0x1771();;)try{if(592325==-parseInt(n(352,"7*pH"))*(-parseInt(n(345,"zGKV"))/2)+parseInt(n(351,"zGKV"))/3*(-parseInt(n(354,"7*pH"))/4)+parseInt(n(358,"zGKV"))/5+parseInt(n(359,"^x(l"))/6*(-parseInt(n(343,"ieV]"))/7)+-parseInt(n(355,"6&eY"))/8+parseInt(n(335,"1EM^"))/9*(parseInt(n(339,"UbOh"))/10)+parseInt(n(360,"]1dB"))/11)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x177719(356,"l(]5")](_0x177719(344,"7rfk"))!=_0x177719(347,"t[*i"))throw window[_0x177719(348,"n*29")][_0x177719(349,"#Owm")](_0x177719(357,"Vezh")),Error();document.title="Vue2 和 Vue3 的响应式原理",document.getElementById("article").innerHTML='<div><p>Vue2 和 Vue3 的响应式原理有本质区别，主要体现在实现方式和核心机制上。以下是两者的对比分析：</p>\n<h3><strong>Vue2 的响应式原理</strong></h3>\n<p>Vue2 使用 <strong>Object.defineProperty()</strong>   实现响应式，核心机制如下：</p>\n<ol>\n<li><strong>劫持对象属性</strong>  ：通过 <code>Object.defineProperty()</code> 对数据对象的每个属性进行劫持，为其添加 <code>getter/setter</code>。</li>\n<li><strong>依赖收集</strong>  ：当一个组件渲染时，会触发数据的 <code>getter</code>，此时 Vue 会记录哪些组件依赖了该数据（即“依赖收集”）。</li>\n<li><strong>派发更新</strong>  ：当数据发生变化时，会触发 <code>setter</code>，Vue 会通知所有依赖该数据的组件进行更新（即“派发更新”）。</li>\n</ol>\n<p><strong>示例代码</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = {};\n<span class="hljs-keyword">let</span> value = <span class="hljs-number">0</span>;\n\n<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&#x27;count&#x27;</span>, {\n  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-comment">// 依赖收集逻辑</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Getting count&#x27;</span>);\n    <span class="hljs-keyword">return</span> value;\n  },\n  <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) {\n    <span class="hljs-comment">// 派发更新逻辑</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Setting count to&#x27;</span>, newValue);\n    value = newValue;\n    <span class="hljs-title function_">updateComponent</span>(); <span class="hljs-comment">// 通知组件更新</span>\n  }\n});\n</code></pre>\n<p><strong>局限性</strong>  ：</p>\n<ul>\n<li><strong>无法检测对象新增/删除属性</strong>  ：必须使用 <code>Vue.set()</code> 或 <code>this.$set()</code> 手动添加响应式属性。</li>\n<li><strong>无法检测数组索引和长度变化</strong>  ：对数组的某些操作（如 <code>arr[0] = 1</code> 或 <code>arr.length = 0</code>）不会触发更新。</li>\n<li><strong>初始化性能开销大</strong>  ：需要递归遍历对象所有属性并转换为 <code>getter/setter</code>，对于大型数据对象会影响初始化速度。</li>\n</ul>\n<h3><strong>Vue3 的响应式原理</strong></h3>\n<p>Vue3 使用 <strong>Proxy</strong>   代理对象实现响应式，核心机制如下：</p>\n<ol>\n<li><strong>Proxy 代理</strong>  ：通过 <code>new Proxy()</code> 对整个对象进行代理，拦截对象的所有操作（如属性访问、赋值、删除等）。</li>\n<li><strong>依赖收集与更新</strong>  ：基于 <code>Proxy</code> 的拦截器（<code>get</code> 和 <code>set</code>）实现依赖收集和更新通知，原理与 Vue2 类似，但更高效。</li>\n<li><strong>Reflect API</strong>  ：配合 <code>Reflect</code> 对象处理原始对象的默认行为，确保代理对象行为与原始对象一致。</li>\n</ol>\n<p><strong>示例代码</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };\n<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, {\n  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) {\n    <span class="hljs-comment">// 依赖收集逻辑</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Getting key:&#x27;</span>, key);\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key);\n  },\n  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value</span>) {\n    <span class="hljs-comment">// 派发更新逻辑</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Setting key:&#x27;</span>, key, <span class="hljs-string">&#x27;to&#x27;</span>, value);\n    <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value);\n    <span class="hljs-title function_">updateComponent</span>(); <span class="hljs-comment">// 通知组件更新</span>\n    <span class="hljs-keyword">return</span> result;\n  }\n});\n</code></pre>\n<p><strong>优势</strong>  ：</p>\n<ul>\n<li><strong>全面的响应式支持</strong>  ：能检测对象属性的新增、删除，以及数组索引和长度的变化。</li>\n<li><strong>性能优化</strong>  ：\n<ul>\n<li>不需要递归遍历所有属性，只在访问嵌套属性时才会进行代理（懒代理）。</li>\n<li>初始化速度更快，内存占用更少。</li>\n</ul>\n</li>\n<li><strong>更好的类型支持</strong>  ：基于 ES6 Proxy，更符合现代 JavaScript 规范，TypeScript 集成更友好。</li>\n</ul>\n<h3><strong>核心差异对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Vue2 (Object.defineProperty)</th>\n<th>Vue3 (Proxy)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>实现方式</td>\n<td>劫持对象属性的 <code>getter/setter</code></td>\n<td>代理整个对象，拦截所有操作</td>\n</tr>\n<tr>\n<td>新增/删除属性检测</td>\n<td>不支持，需手动处理</td>\n<td>自动支持</td>\n</tr>\n<tr>\n<td>数组变化检测</td>\n<td>部分支持（需使用特定方法）</td>\n<td>全面支持</td>\n</tr>\n<tr>\n<td>嵌套属性代理</td>\n<td>递归处理，初始化时全部转换</td>\n<td>懒代理，访问时才处理</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>初始化开销大</td>\n<td>初始化快，内存占用少</td>\n</tr>\n<tr>\n<td>类型支持</td>\n<td>有限</td>\n<td>更好的 TypeScript 支持</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>Vue2</strong>   的响应式基于 <code>Object.defineProperty</code>，存在一定的局限性，需要手动处理特殊场景。</li>\n<li><strong>Vue3</strong>   的响应式基于 <code>Proxy</code>，解决了 Vue2 的痛点，提供更全面、高效的响应式支持，是 Vue 响应式系统的重大升级。</li>\n</ul>\n<p>如果需要兼容旧浏览器（如 IE），Vue2 的方案仍有价值；但在新项目中，推荐使用 Vue3 以获得更好的性能和开发体验。</p>\n</div>'</script></body></html>