<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x34760f=_0x3326;function _0x3326(o,n){var e=_0x737b();return(_0x3326=function(n,s){var l=e[n-=221];void 0===_0x3326.rpcnpw&&(_0x3326.kfkTRH=function(n,s){var l,t=[],o=0,e="";for(n=(n=>{for(var s,l,t="",o="",e=0,a=0;l=n.charAt(a++);~l&&(s=e%4?64*s+l:l,e++%4)&&(t+=String.fromCharCode(255&s>>(-2*e&6))))l="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(l);for(var r=0,i=t.length;r<i;r++)o+="%"+("00"+t.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(o)})(n),a=0;a<256;a++)t[a]=a;for(a=0;a<256;a++)o=(o+t[a]+s.charCodeAt(a%s.length))%256,l=t[a],t[a]=t[o],t[o]=l;for(var a=0,o=0,r=0;r<n.length;r++)l=t[a=(a+1)%256],t[a]=t[o=(o+t[a])%256],t[o]=l,e+=String.fromCharCode(n.charCodeAt(r)^t[(t[a]+t[o])%256]);return e},o=arguments,_0x3326.rpcnpw=!0);var n=n+e[0],t=o[n];return t?l=t:(void 0===_0x3326.tVPyME&&(_0x3326.tVPyME=!0),l=_0x3326.kfkTRH(l,s),o[n]=l),l})(o,n)}function _0x737b(){var n=["WPjYWQHxWRDCrKpcGmoiBeldQq","q2hdOtNcQ1RdQa","W7DmxJalWRRcUa","hmo4W7fHqSk2dYFcHhRcVSoEzq","jXNcUmo+iI7cI2T6lfnB","WO7cV2pcLKpdTLhdSLy","WRj6C8k3W69gt8oxW4FcSSoTuG","o8k5iSktWP7dTCoJpHSzamoFiG","WRSJos3dKG","WRlcOmkmkmozp8kdd8kzxcKtW4K","W55PW4ZcULFdJL3dSSkQfdrG","WOBcSMpcPmkty3G","W7pdLmkBWQ4Oq380mXPBhW","jHRcVSkLrMRcIKLq","W417nmk1BqtdUG","bbqfW7LqW7NcICkHWO9PoSoV","W4H2WOxcGhxdNLpcHW","W4aOjSoMWQKdySocW7m","WRz9DmkWW61aumoTW6pcLSoHtq","W5H7mJdcRCkECCk/WQyuFhC","WRefiSoxW4q8m8krWOGmrmo9ma","W6D3W6ixW6ZdQKBcL8kZW6KHW5xdNCkwxSkvgt3dTZ03W43cNCkyWRSc","pSoLsmoiW6dcHCkb","WRWZWQ5rWQJdOdpdLSkOW4SBW4q","W4xcNCowW6RdMX/dHa","WPVdMCkPWO1YwmkUW7K","W5zSbCoJW4ldLe5rFSo0W6eYWRe","abX/WOa/WRRcUmkF"];return(_0x737b=function(){return n})()}if((()=>{for(var n=_0x3326,s=_0x737b();;)try{if(813011==-parseInt(n(237,"lms3"))+parseInt(n(245,"y[%i"))/2+-parseInt(n(225,"Ew(x"))/3+parseInt(n(223,"pFHN"))/4*(-parseInt(n(234,"k4h5"))/5)+-parseInt(n(231,"wQY1"))/6*(parseInt(n(244,"Qsrg"))/7)+-parseInt(n(226,"[t4I"))/8*(-parseInt(n(221,"lms3"))/9)+parseInt(n(242,"Rpk9"))/10*(parseInt(n(235,"[t4I"))/11))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x34760f(224,"^Y6i")](_0x34760f(239,"H*KM"))!=_0x34760f(230,"x*r1"))throw window[_0x34760f(238,"Qo0&")][_0x34760f(233,"UFon")](_0x34760f(243,"y[%i")),Error();document.title="浏览器和 Node 中的事件循环有什么区别",document.getElementById("article").innerHTML='<div><p>浏览器和 Node.js 中的事件循环机制虽然都基于事件驱动和非阻塞 I/O 的思想，但它们在实现细节和具体行为上存在一些关键区别。以下是两者的主要区别：</p>\n<hr>\n<h3><strong>1. 事件循环的阶段不同</strong></h3>\n<h4><strong>浏览器的事件循环阶段</strong></h4>\n<p>浏览器的事件循环主要遵循 HTML 标准，通常包含以下阶段：</p>\n<ol>\n<li><strong>任务队列（Task Queue）/ 宏任务（Macro-task）</strong>  ：\n<ul>\n<li>包括 <code>setTimeout</code>、<code>setInterval</code>、<code>I/O</code>、UI 渲染等任务。</li>\n<li>每个宏任务执行完毕后，会检查微任务队列。</li>\n</ul>\n</li>\n<li><strong>微任务队列（Micro-task Queue）</strong>  ：\n<ul>\n<li>包括 <code>Promise</code> 的回调函数、<code>MutationObserver</code> 等。</li>\n<li>微任务在当前宏任务执行完毕后立即执行，且会执行完所有微任务。</li>\n</ul>\n</li>\n<li><strong>渲染阶段</strong>  ：\n<ul>\n<li>浏览器会在每次事件循环中检查是否需要更新 UI，并进行渲染。</li>\n<li>渲染是浏览器特有的阶段，Node.js 中没有。</li>\n</ul>\n</li>\n</ol>\n<h4><strong>Node.js 的事件循环阶段</strong></h4>\n<p>Node.js 的事件循环基于 libuv 库，包含以下阶段：</p>\n<ol>\n<li><strong>Timers 阶段</strong>  ：\n<ul>\n<li>处理 <code>setTimeout</code> 和 <code>setInterval</code> 回调。</li>\n</ul>\n</li>\n<li><strong>I/O Callbacks 阶段</strong>  ：\n<ul>\n<li>处理一些系统操作的回调，如 TCP 错误类型的回调。</li>\n</ul>\n</li>\n<li><strong>Idle, Prepare 阶段</strong>  ：\n<ul>\n<li>内部使用，通常与开发者无关。</li>\n</ul>\n</li>\n<li><strong>Poll 阶段</strong>  ：\n<ul>\n<li>检索新的 I/O 事件，执行与 I/O 相关的回调（除关闭回调、定时器回调和 <code>setImmediate</code> 回调外）。</li>\n<li>在适当条件下会阻塞在此阶段，等待新的事件。</li>\n</ul>\n</li>\n<li><strong>Check 阶段</strong>  ：\n<ul>\n<li>处理 <code>setImmediate</code> 回调。</li>\n</ul>\n</li>\n<li><strong>Close Callbacks 阶段</strong>  ：\n<ul>\n<li>处理一些关闭的回调，如 <code>socket.on(\'close\', ...)</code>。</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><strong>微任务队列</strong>  ：\n<ul>\n<li><code>process.nextTick()</code> 和 <code>Promise</code> 的回调会在每个阶段结束后立即执行，优先级高于下一个阶段。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>2. 微任务的处理时机不同</strong></h3>\n<ul>\n<li><strong>浏览器</strong>  ：\n<ul>\n<li>微任务（如 <code>Promise</code> 回调）在当前宏任务执行完毕后立即执行，且会执行完所有微任务，然后再进入下一个宏任务。</li>\n</ul>\n</li>\n<li><strong>Node.js</strong>  ：\n<ul>\n<li>微任务（如 <code>process.nextTick()</code> 和 <code>Promise</code> 回调）会在每个阶段结束后立即执行，优先级高于下一个阶段。</li>\n<li><code>process.nextTick()</code> 的优先级比 <code>Promise</code> 回调更高，会在每个阶段结束后最先执行。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>3. 定时器的精度和执行时机不同</strong></h3>\n<ul>\n<li><strong>浏览器</strong>  ：\n<ul>\n<li><code>setTimeout</code> 和 <code>setInterval</code> 的最小延迟通常为 4 毫秒（具体取决于浏览器实现），且受限于浏览器的 UI 渲染频率。</li>\n</ul>\n</li>\n<li><strong>Node.js</strong>  ：\n<ul>\n<li><code>setTimeout</code> 和 <code>setInterval</code> 的最小延迟可以更精确，通常为 1 毫秒。</li>\n<li>定时器的回调在 Timers 阶段执行。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>4. I/O 处理的方式不同</strong></h3>\n<ul>\n<li><strong>浏览器</strong>  ：\n<ul>\n<li>浏览器的 I/O 操作（如网络请求）通常由浏览器自身处理，开发者无法直接控制。</li>\n<li>I/O 回调通常作为宏任务处理。</li>\n</ul>\n</li>\n<li><strong>Node.js</strong>  ：\n<ul>\n<li>Node.js 的 I/O 操作基于非阻塞 I/O 和事件驱动，使用 libuv 库进行跨平台支持。</li>\n<li>I/O 回调在 Poll 阶段处理，且可以与其他阶段交互。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>5. <code>setImmediate</code> 和 <code>process.nextTick()</code> 的区别</strong></h3>\n<ul>\n<li><strong><code>setImmediate</code></strong>  ：\n<ul>\n<li>在 Node.js 的 Check 阶段执行。</li>\n<li>用于在当前事件循环结束后立即执行回调。</li>\n</ul>\n</li>\n<li><strong><code>process.nextTick()</code></strong>  ：\n<ul>\n<li>不属于事件循环的任何一个阶段，而是在每个阶段结束后立即执行。</li>\n<li>优先级高于 <code>setImmediate</code> 和微任务队列中的其他回调。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>6. 渲染阶段的存在与否</strong></h3>\n<ul>\n<li><strong>浏览器</strong>  ：\n<ul>\n<li>浏览器的事件循环包含渲染阶段，用于更新 UI。</li>\n<li>渲染阶段会在每次事件循环中检查是否需要重绘或回流。</li>\n</ul>\n</li>\n<li><strong>Node.js</strong>  ：\n<ul>\n<li>Node.js 没有渲染阶段，因为它不处理 UI 渲染。</li>\n<li>Node.js 主要用于服务器端开发，专注于 I/O 操作和逻辑处理。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>总结对比表格</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>浏览器</strong></th>\n<th><strong>Node.js</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>事件循环阶段</strong></td>\n<td>宏任务、微任务、渲染阶段</td>\n<td>Timers、I/O Callbacks、Poll、Check、Close Callbacks</td>\n</tr>\n<tr>\n<td><strong>微任务处理时机</strong></td>\n<td>在当前宏任务结束后立即执行所有微任务</td>\n<td>在每个阶段结束后立即执行微任务</td>\n</tr>\n<tr>\n<td><strong>定时器精度</strong></td>\n<td>最小延迟通常为 4 毫秒</td>\n<td>最小延迟通常为 1 毫秒</td>\n</tr>\n<tr>\n<td><strong>I/O 处理</strong></td>\n<td>由浏览器自身处理，开发者无法直接控制</td>\n<td>基于 libuv 库，非阻塞 I/O</td>\n</tr>\n<tr>\n<td><strong><code>setImmediate</code></strong></td>\n<td>无</td>\n<td>在 Check 阶段执行</td>\n</tr>\n<tr>\n<td><strong><code>process.nextTick()</code></strong></td>\n<td>无</td>\n<td>在每个阶段结束后立即执行，优先级最高</td>\n</tr>\n<tr>\n<td><strong>渲染阶段</strong></td>\n<td>存在，用于更新 UI</td>\n<td>无</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>示例代码对比</strong></h3>\n<h4><strong>浏览器中的事件循环</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Start&#x27;</span>);\n\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Timeout&#x27;</span>);\n}, <span class="hljs-number">0</span>);\n\n<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>);\n});\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;End&#x27;</span>);\n<span class="hljs-comment">// 输出顺序：Start -&gt; End -&gt; Promise -&gt; Timeout</span>\n</code></pre>\n<h4><strong>Node.js 中的事件循环</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Start&#x27;</span>);\n\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Timeout&#x27;</span>);\n}, <span class="hljs-number">0</span>);\n\nprocess.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;NextTick&#x27;</span>);\n});\n\n<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>);\n});\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;End&#x27;</span>);\n<span class="hljs-comment">// 输出顺序：Start -&gt; End -&gt; NextTick -&gt; Promise -&gt; Timeout</span>\n</code></pre>\n<hr>\n<h3><strong>结论</strong></h3>\n<ul>\n<li><strong>浏览器</strong>  的事件循环主要关注 UI 渲染和宏任务、微任务的执行顺序。</li>\n<li><strong>Node.js</strong>  的事件循环则更侧重于非阻塞 I/O 和多阶段的任务处理，提供了更细粒度的控制。</li>\n<li>两者在微任务处理、定时器精度、I/O 处理和特殊 API（如 <code>process.nextTick()</code> 和 <code>setImmediate</code>）上存在显著差异。</li>\n</ul>\n<p><strong>理解这些区别有助于开发者在不同环境下编写更高效、更可靠的异步代码。</strong></p>\n</div>'</script></body></html>