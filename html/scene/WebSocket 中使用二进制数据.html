<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1d5e(e,s){var p=_0x4384();return(_0x1d5e=function(s,n){var a=p[s-=436];void 0===_0x1d5e.rhxXJg&&(_0x1d5e.hcEhoJ=function(s,n){var a,l=[],e=0,p="";for(s=(s=>{for(var n,a,l="",e="",p=0,c=0;a=s.charAt(c++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,o=l.length;t<o;t++)e+="%"+("00"+l.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(e)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)e=(e+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[e],l[e]=a;for(var c=0,e=0,t=0;t<s.length;t++)a=l[c=(c+1)%256],l[c]=l[e=(e+l[c])%256],l[e]=a,p+=String.fromCharCode(s.charCodeAt(t)^l[(l[c]+l[e])%256]);return p},e=arguments,_0x1d5e.rhxXJg=!0);var s=s+p[0],l=e[s];return l?a=l:(void 0===_0x1d5e.oNbdxB&&(_0x1d5e.oNbdxB=!0),a=_0x1d5e.hcEhoJ(a,n),e[s]=a),a})(e,s)}function _0x4384(){var s=["D2BcVCk7WRVcO3JcIapdRbyInW","iKqOCYOfia","WRaCfmo/eG","A8oByh1ilmkBW6ldNmolhCoqoG","WOddGI/dHLlcN14","WO/dKSosm0lcV8kp","W5LhECoBqmo/W5y","e2bWW5JdPsWeWPyHie7dImoIW4S","W7vDv8k9wxToWOeWWPmPWOhcKq","W55DfK8fW4JdLHj/WPVcHIVcIa","WP0xnXGQWP4QtmkywSojW5dcVq","n8oelmoAW6iIW51rwM7cTSkunq","c8osWOxdJYWfqun8WPpdPmkFEmoTdYjrzConfh/cSSojbSoFW6K","v8kYlghcTSolu8kSW5xcQXdcHmklpG","mc/cUSkNhYJdLa","W4ldQ3qXCmovmG","sHbwpMPCWOyaW4pcMIT2DW","W7frv8k7u3LoWQODWRyQWRRcPW","W47cJ8kBBbhdQCoyW4ZdPmkdl8kBWPS","sbLyp29BWOunW4tcPZPQsW","W5BcLMZcVrhdIalcVe4czSk6WR0","W6LnyuTQW5Pxw8kS","urqFo8k+WRZdJZPTWRmMu8kG","lIHKW6SqW6FcV8o0"];return(_0x4384=function(){return s})()}var _0x26dccc=_0x1d5e;if((()=>{for(var s=_0x1d5e,n=_0x4384();;)try{if(905732==-parseInt(s(436,"rmB@"))+parseInt(s(453,"ujx!"))/2*(-parseInt(s(445,"[BTz"))/3)+parseInt(s(439,"rmB@"))/4+parseInt(s(442,"tvS7"))/5+-parseInt(s(444,"5l5t"))/6*(parseInt(s(450,"KTvi"))/7)+-parseInt(s(455,"8^ga"))/8+parseInt(s(457,"dgIk"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x26dccc(448,"Z4(n")](_0x26dccc(441,"pTdA"))!=_0x26dccc(446,"YYWn"))throw window[_0x26dccc(443,"QzmD")][_0x26dccc(449,"9FeO")](_0x26dccc(456,"(5d[")),Error();document.title="WebSocket 中使用二进制数据",document.getElementById("article").innerHTML='<div><p>在 WebSocket 中使用二进制数据可以显著提升传输效率，尤其适合传输图片、音频、视频或结构化数据。以下是完整的实现指南：</p>\n<h3><strong>1. 基本二进制数据类型</strong></h3>\n<p>WebSocket 支持两种二进制格式：</p>\n<ul>\n<li><strong>ArrayBuffer</strong>  ：原始二进制数据的固定长度缓冲区。</li>\n<li><strong>Blob</strong>  ：表示不可变的类文件二进制数据，可包含类型信息。</li>\n</ul>\n<h3><strong>2. 客户端发送二进制数据</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://example.com&#x27;</span>);\n\n<span class="hljs-comment">// 发送 ArrayBuffer</span>\nsocket.<span class="hljs-property">onopen</span> = <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 示例1：从字符串创建 ArrayBuffer</span>\n  <span class="hljs-keyword">const</span> text = <span class="hljs-string">&#x27;Hello, WebSocket!&#x27;</span>;\n  <span class="hljs-keyword">const</span> encoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEncoder</span>();\n  <span class="hljs-keyword">const</span> buffer = encoder.<span class="hljs-title function_">encode</span>(text); <span class="hljs-comment">// Uint8Array</span>\n  socket.<span class="hljs-title function_">send</span>(buffer);\n\n  <span class="hljs-comment">// 示例2：发送图片（假设已有 Image 对象）</span>\n  <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;canvas&#x27;</span>);\n  <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&#x27;2d&#x27;</span>);\n  ctx.<span class="hljs-title function_">drawImage</span>(image, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\n  canvas.<span class="hljs-title function_">toBlob</span>(<span class="hljs-function"><span class="hljs-params">blob</span> =&gt;</span> {\n    socket.<span class="hljs-title function_">send</span>(blob); <span class="hljs-comment">// 发送 Blob 对象</span>\n  });\n};\n\n<span class="hljs-comment">// 接收二进制数据</span>\nsocket.<span class="hljs-property">binaryType</span> = <span class="hljs-string">&#x27;arraybuffer&#x27;</span>; <span class="hljs-comment">// 设置接收类型</span>\nsocket.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ArrayBuffer</span>) {\n    <span class="hljs-keyword">const</span> buffer = event.<span class="hljs-property">data</span>;\n    <span class="hljs-comment">// 处理 ArrayBuffer...</span>\n  }\n};\n</code></pre>\n<h3><strong>3. 服务端接收二进制数据（Node.js 示例）</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">WebSocket</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ws&#x27;</span>);\n<span class="hljs-keyword">const</span> wss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>.<span class="hljs-title class_">Server</span>({ <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span> });\n\nwss.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">ws</span>) =&gt;</span> {\n  ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> {\n    <span class="hljs-comment">// 判断是否为二进制数据</span>\n    <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Buffer</span>) {\n      <span class="hljs-comment">// 处理 ArrayBuffer（Node.js 中为 Buffer）</span>\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received binary data:&#x27;</span>, message.<span class="hljs-property">length</span>);\n      \n      <span class="hljs-comment">// 转换为 Uint8Array</span>\n      <span class="hljs-keyword">const</span> uint8Array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(message);\n      \n      <span class="hljs-comment">// 转换为字符串（如果原始是文本）</span>\n      <span class="hljs-keyword">const</span> decoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>();\n      <span class="hljs-keyword">const</span> text = decoder.<span class="hljs-title function_">decode</span>(uint8Array);\n      \n      <span class="hljs-comment">// 或直接处理二进制数据...</span>\n    }\n  });\n});\n</code></pre>\n<h3><strong>4. 二进制协议设计（重点）</strong></h3>\n<p>对于复杂场景，建议设计自定义二进制协议：</p>\n<h4><strong>示例：固定长度协议</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 客户端发送</span>\n<span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">12</span>); <span class="hljs-comment">// 固定长度：12字节</span>\n<span class="hljs-keyword">const</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataView</span>(buffer);\n\n<span class="hljs-comment">// 写入数据</span>\nview.<span class="hljs-title function_">setUint8</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);    <span class="hljs-comment">// 消息类型（1字节）</span>\nview.<span class="hljs-title function_">setUint32</span>(<span class="hljs-number">1</span>, <span class="hljs-number">123</span>); <span class="hljs-comment">// 消息ID（4字节）</span>\nview.<span class="hljs-title function_">setFloat64</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3.14</span>); <span class="hljs-comment">// 数据（8字节）</span>\n\nsocket.<span class="hljs-title function_">send</span>(buffer);\n\n<span class="hljs-comment">// 服务端解析</span>\nws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataView</span>(message);\n  <span class="hljs-keyword">const</span> type = view.<span class="hljs-title function_">getUint8</span>(<span class="hljs-number">0</span>);\n  <span class="hljs-keyword">const</span> id = view.<span class="hljs-title function_">getUint32</span>(<span class="hljs-number">1</span>);\n  <span class="hljs-keyword">const</span> data = view.<span class="hljs-title function_">getFloat64</span>(<span class="hljs-number">5</span>);\n});\n</code></pre>\n<h4><strong>示例：可变长度协议</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 消息格式：[4字节长度][1字节类型][N字节数据]</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params">type, data</span>) {\n  <span class="hljs-keyword">const</span> length = <span class="hljs-number">5</span> + data.<span class="hljs-property">length</span>; <span class="hljs-comment">// 头部长度 + 数据长度</span>\n  <span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(length);\n  <span class="hljs-keyword">const</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataView</span>(buffer);\n  \n  view.<span class="hljs-title function_">setUint32</span>(<span class="hljs-number">0</span>, length); <span class="hljs-comment">// 总长度</span>\n  view.<span class="hljs-title function_">setUint8</span>(<span class="hljs-number">4</span>, type);    <span class="hljs-comment">// 消息类型</span>\n  \n  <span class="hljs-comment">// 复制数据到缓冲区</span>\n  <span class="hljs-keyword">const</span> dataArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(data);\n  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(buffer, <span class="hljs-number">5</span>).<span class="hljs-title function_">set</span>(dataArray);\n  \n  socket.<span class="hljs-title function_">send</span>(buffer);\n}\n</code></pre>\n<h3><strong>5. 性能优化技巧</strong></h3>\n<ol>\n<li><strong>使用 <code>Uint8Array</code> 操作二进制数据</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 高效操作 ArrayBuffer</span>\n<span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">1024</span>);\n<span class="hljs-keyword">const</span> uint8Array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(buffer);\nuint8Array[<span class="hljs-number">0</span>] = <span class="hljs-number">255</span>;\n</code></pre>\n</li>\n<li><strong>压缩二进制数据</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 使用 pako 库压缩数据（需先安装）</span>\n<span class="hljs-keyword">import</span> pako <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pako&#x27;</span>;\n\n<span class="hljs-keyword">const</span> text = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;large payload&#x27;</span> });\n<span class="hljs-keyword">const</span> compressed = pako.<span class="hljs-title function_">deflate</span>(text);\nsocket.<span class="hljs-title function_">send</span>(compressed);\n</code></pre>\n</li>\n<li><strong>批量发送数据</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 合并多个小消息为一个大消息</span>\n<span class="hljs-keyword">const</span> messages = [msg1, msg2, msg3];\n<span class="hljs-keyword">const</span> combined = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(messages.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">len, m</span>) =&gt;</span> len + m.<span class="hljs-property">length</span>, <span class="hljs-number">0</span>));\n<span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>;\nmessages.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span> {\n  combined.<span class="hljs-title function_">set</span>(msg, offset);\n  offset += msg.<span class="hljs-property">length</span>;\n});\nsocket.<span class="hljs-title function_">send</span>(combined);\n</code></pre>\n</li>\n</ol>\n<h3><strong>6. 注意事项</strong></h3>\n<ul>\n<li><strong>类型一致性</strong>  ：客户端和服务端必须使用相同的二进制格式和协议。</li>\n<li><strong>大文件处理</strong>  ：对于大文件（如视频），建议分片传输并实现断点续传。</li>\n<li><strong>浏览器兼容性</strong>  ：所有现代浏览器都支持 <code>ArrayBuffer</code>，但旧版浏览器（如 IE10-）可能需要 polyfill。</li>\n<li><strong>调试困难</strong>  ：二进制数据难以直接调试，建议在开发阶段添加日志或可视化工具。</li>\n</ul>\n<h3><strong>7. 工具推荐</strong></h3>\n<ul>\n<li><strong>协议缓冲区</strong>  ：如 <a href="https://developers.google.com/protocol-buffers" target="_blank">Protobuf</a>、<a href="https://msgpack.org/" target="_blank">MessagePack</a>，用于高效序列化结构化数据。</li>\n<li><strong>WebSocket 库</strong>  ：\n<ul>\n<li>客户端：<code>ws</code>（Node.js）、<code>socket.io</code>（支持二进制）。</li>\n<li>服务端：<code>ws</code>（Node.js）、<code>netty</code>（Java）、<code>SignalR</code>（.NET）。</li>\n</ul>\n</li>\n</ul>\n<p>通过合理设计二进制协议和优化传输方式，可以显著提升 WebSocket 在复杂场景下的性能和可靠性。</p>\n</div>'</script></body></html>