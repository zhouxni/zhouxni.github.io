<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5231(o,n){var a=_0x2080();return(_0x5231=function(n,l){var e=a[n-=371];void 0===_0x5231.sorukS&&(_0x5231.RPfgsz=function(n,l){var e,s=[],o=0,a="";for(n=(n=>{for(var l,e,s="",o="",a=0,i=0;e=n.charAt(i++);~e&&(l=a%4?64*l+e:e,a++%4)&&(s+=String.fromCharCode(255&l>>(-2*a&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var t=0,r=s.length;t<r;t++)o+="%"+("00"+s.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(o)})(n),i=0;i<256;i++)s[i]=i;for(i=0;i<256;i++)o=(o+s[i]+l.charCodeAt(i%l.length))%256,e=s[i],s[i]=s[o],s[o]=e;for(var i=0,o=0,t=0;t<n.length;t++)e=s[i=(i+1)%256],s[i]=s[o=(o+s[i])%256],s[o]=e,a+=String.fromCharCode(n.charCodeAt(t)^s[(s[i]+s[o])%256]);return a},o=arguments,_0x5231.sorukS=!0);var n=n+a[0],s=o[n];return s?e=s:(void 0===_0x5231.fmlSkX&&(_0x5231.fmlSkX=!0),e=_0x5231.RPfgsz(e,l),o[n]=e),e})(o,n)}var _0x32689c=_0x5231;function _0x2080(){var n=["bSoZna0ioYJcG8omwby0W6DKy8oqWOxcT0yHDSosW7JdTZjU","bYJcISkZwCk1W5u","W7SXWOZcT8kwdYbqW4VdJhtcQG","A2OyC8oqqmk4WQOSWPmx","l8oKiXGiCKZdICop","k0BcJ1PXW5zCpq","xgeBFCkxWQpdO8klWOxcShWu","WPzOBgCye8ok","rLyQW700W4ujW4JdLCkUlsuI","WQSvAfDNWOpdRW","lmoTWR0JWQy","W5LeWOejW4aiWPiYtCoGW5Xo","cw7dQmoNuGDK","ugRdLWTmW5JdKW","tCkjkCoUWPyQW5apW5CCr8kTW6G","W7K4WOpcTCkwaxfwW4/dU2RcPSkd","AmkHW7HPW68Yq8oSemkbW5/cH8o0","cMFdJmofimkRW6bNBmoGea","W5j+WRSNjeJdTCk5W6pcTCkWaSoX","WPTBcaDBwexcHwmWD8oV","mNu2FwFdOadcIa","aadcSCkmzSksW4O","DsP5W4/cGSkjtMy","WQaJbCkmW4queSoCzMPbW6q","q14LW7e0W4igW7hdVmkllIOA","yM8zD8owmmkxWPGGWOiuW7G"];return(_0x2080=function(){return n})()}if((()=>{for(var n=_0x5231,l=_0x2080();;)try{if(105706==+parseInt(n(392,"mv%!"))*(parseInt(n(377,"YHK!"))/2)+-parseInt(n(371,"lrTU"))/3+parseInt(n(382,"&C%y"))/4*(-parseInt(n(393,"Ta5Q"))/5)+-parseInt(n(395,"&C%y"))/6+-parseInt(n(394,"(zCz"))/7+-parseInt(n(391,"PV9F"))/8+parseInt(n(388,"K(B&"))/9*(parseInt(n(374,"qTP("))/10))break;l.push(l.shift())}catch(n){l.push(l.shift())}})(),localStorage[_0x32689c(389,"N4Id")](_0x32689c(384,"XYLX"))!=_0x32689c(390,"r$[t"))throw window[_0x32689c(376,"NWvE")][_0x32689c(387,"UQQG")](_0x32689c(380,"XYLX")),Error();document.title="Vue 3 组件首次渲染的完整流程",document.getElementById("article").innerHTML='<div><p>Vue 3 组件的首次渲染流程是一个精心设计的响应式系统与虚拟 DOM 渲染相结合的过程。以下是详细的步骤分析：</p>\n<h2>1. 初始化阶段</h2>\n<h3>1.1 创建组件实例</h3>\n<ul>\n<li>调用 <code>createComponentInstance</code> 创建组件实例对象</li>\n<li>初始化实例属性：<code>props</code>, <code>attrs</code>, <code>slots</code>, <code>emit</code> 等</li>\n<li>执行 <code>setup</code> 函数（如果存在）</li>\n</ul>\n<h3>1.2 响应式系统初始化</h3>\n<ul>\n<li>通过 <code>reactive</code> 或 <code>ref</code> 创建响应式数据</li>\n<li>建立响应式依赖关系图</li>\n<li>执行 <code>setup</code> 函数中的代码，收集依赖</li>\n</ul>\n<h2>2. 模板编译阶段（仅运行时+编译器版本）</h2>\n<h3>2.1 模板解析</h3>\n<ul>\n<li>将模板字符串解析为 AST (抽象语法树)</li>\n<li>进行静态分析，标记静态节点</li>\n</ul>\n<h3>2.2 代码生成</h3>\n<ul>\n<li>将 AST 转换为渲染函数代码</li>\n<li>生成优化后的虚拟 DOM 创建代码</li>\n</ul>\n<h2>3. 渲染阶段</h2>\n<h3>3.1 执行渲染函数</h3>\n<ul>\n<li>调用 <code>render</code> 函数生成虚拟 DOM (VNode)</li>\n<li>在渲染过程中访问响应式数据，建立依赖关系</li>\n</ul>\n<h3>3.2 虚拟 DOM 创建</h3>\n<pre><code class="language-typescript"><span class="hljs-comment">// 伪代码示例</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, { <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;container&#x27;</span> }, [\n    <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>),\n    <span class="hljs-title function_">h</span>(<span class="hljs-title class_">ChildComponent</span>, { <span class="hljs-attr">prop</span>: someValue })\n  ])\n}\n</code></pre>\n<h2>4. 挂载阶段</h2>\n<h3>4.1 Patch 过程</h3>\n<ul>\n<li>将虚拟 DOM 转换为真实 DOM</li>\n<li>执行 DOM 创建和插入操作</li>\n<li>处理组件、指令、事件等</li>\n</ul>\n<h3>4.2 子组件处理</h3>\n<ul>\n<li>递归处理子组件的创建和挂载</li>\n<li>建立父子组件关系</li>\n</ul>\n<h2>5. 生命周期钩子调用顺序</h2>\n<ol>\n<li><code>setup()</code> - Composition API 入口</li>\n<li><code>onBeforeMount</code> - 挂载前</li>\n<li><code>render</code> - 生成虚拟 DOM</li>\n<li><code>onMounted</code> - 挂载完成</li>\n</ol>\n<h2>6. 关键优化点</h2>\n<ul>\n<li><strong>静态提升</strong>  ：静态节点在编译阶段被提升，避免重复创建</li>\n<li><strong>补丁标志</strong>  ：通过 PatchFlags 标记动态内容，实现精准更新</li>\n<li><strong>树结构优化</strong>  ：基于模板分析跳过静态子树</li>\n</ul>\n<h2>完整流程图</h2>\n<pre><code>创建组件实例 → 初始化Props/State → 执行setup → \n编译模板(如需要) → 执行render生成VNode → \n调用beforeMount → 执行patch → 创建真实DOM → \n处理子组件 → 调用mounted\n</code></pre>\n<h2>与 Vue 2 的主要区别</h2>\n<ol>\n<li>使用 Proxy 替代 Object.defineProperty 实现响应式</li>\n<li>引入 Composition API 和 setup 函数</li>\n<li>更细粒度的虚拟 DOM 差异算法</li>\n<li>更好的 TypeScript 支持</li>\n<li>更灵活的组件复用方式</li>\n</ol>\n<p>这个流程展示了 Vue 3 如何高效地将组件从声明式模板转换为最终渲染的 DOM，同时建立了完整的响应式依赖关系，为后续的更新奠定了基础。</p>\n</div>'</script></body></html>