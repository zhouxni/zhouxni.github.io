<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2bd0(){var _0x2f37c6=['lSoaW7vjzqxcNW','rmohDSktpSoWq0rggb5i','AmoXBSkPWPdcQSoaW5JdSNBdTCkY','tcGHwCoAW7e9vSoOmmov','FCkvW6XUubRcHdC','cSoKWPpdGdWYW68','W4KyWQxcVXxdVcONWQddOweDWPa','qCoiCmodtSkOt01d','qSodWRdcUHyYuua','w2/cSCkAW7GMCW','qSojCSksxSk3t2vFlG','W4LXpSowW41EWOzbWPm','WOVcGCkVWRK5W5DIWPFcPsG','kIZcMmoSW6q/WQJcKdBcLZ0xW48lvSoNW4ddQCocsmoLumk6eLTP','WO3cImkPWRWSW7vcWQ/cLcO','f8o2rXFdPcJcJSklW655W7jk','nmoWWPlcUmoQBgG','W64FW4FdGmo+','WQ/dQ8kjW4y7oCogW6TklSkE','gCofEJfJzsRdHCkTW7K','W6z0r8kIWRFdGmokz3ddNq','WPzHW73dIhNdHCoLpSkj','b8obas7dIZ4lW7Tjoa','WOjsW4GzW7H0eCkjiXrPWRa','s3L+vdrrW7RcJmk+WPRcT3a','EmolWRJdOCkdDKC5W6G','r8odW6ZdPMn9CuClmSkAWPi','mCkFWQutqSoobmkijmokaqdcGq','W7uzWO8UvSkbW4jeW44','WQjvW5bRvmk/uva'];_0x2bd0=function(){return _0x2f37c6;};return _0x2bd0();}var _0x8f353d=_0x104f;function _0x104f(_0x38b05a,_0x10dc23){var _0x2bd08c=_0x2bd0();return _0x104f=function(_0x104f0f,_0x25efbf){_0x104f0f=_0x104f0f-0x199;var _0x690026=_0x2bd08c[_0x104f0f];if(_0x104f['eivtwT']===undefined){var _0x4c0bb6=function(_0x450149){var _0x287c59='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=';var _0x432014='',_0x5204b0='';for(var _0x423bf9=0x0,_0x4e5c70,_0x40e494,_0x5786c3=0x0;_0x40e494=_0x450149['charAt'](_0x5786c3++);~_0x40e494&&(_0x4e5c70=_0x423bf9%0x4?_0x4e5c70*0x40+_0x40e494:_0x40e494,_0x423bf9++%0x4)?_0x432014+=String['fromCharCode'](0xff&_0x4e5c70>>(-0x2*_0x423bf9&0x6)):0x0){_0x40e494=_0x287c59['indexOf'](_0x40e494);}for(var _0x11f21c=0x0,_0x42649a=_0x432014['length'];_0x11f21c<_0x42649a;_0x11f21c++){_0x5204b0+='%'+('00'+_0x432014['charCodeAt'](_0x11f21c)['toString'](0x10))['slice'](-0x2);}return decodeURIComponent(_0x5204b0);};var _0x2810fa=function(_0x5ab93b,_0x1a63c7){var _0x5d8e84=[],_0x2b0f26=0x0,_0x536a20,_0x46f927='';_0x5ab93b=_0x4c0bb6(_0x5ab93b);var _0x16126a;for(_0x16126a=0x0;_0x16126a<0x100;_0x16126a++){_0x5d8e84[_0x16126a]=_0x16126a;}for(_0x16126a=0x0;_0x16126a<0x100;_0x16126a++){_0x2b0f26=(_0x2b0f26+_0x5d8e84[_0x16126a]+_0x1a63c7['charCodeAt'](_0x16126a%_0x1a63c7['length']))%0x100,_0x536a20=_0x5d8e84[_0x16126a],_0x5d8e84[_0x16126a]=_0x5d8e84[_0x2b0f26],_0x5d8e84[_0x2b0f26]=_0x536a20;}_0x16126a=0x0,_0x2b0f26=0x0;for(var _0x5d674a=0x0;_0x5d674a<_0x5ab93b['length'];_0x5d674a++){_0x16126a=(_0x16126a+0x1)%0x100,_0x2b0f26=(_0x2b0f26+_0x5d8e84[_0x16126a])%0x100,_0x536a20=_0x5d8e84[_0x16126a],_0x5d8e84[_0x16126a]=_0x5d8e84[_0x2b0f26],_0x5d8e84[_0x2b0f26]=_0x536a20,_0x46f927+=String['fromCharCode'](_0x5ab93b['charCodeAt'](_0x5d674a)^_0x5d8e84[(_0x5d8e84[_0x16126a]+_0x5d8e84[_0x2b0f26])%0x100]);}return _0x46f927;};_0x104f['QaJcwM']=_0x2810fa,_0x38b05a=arguments,_0x104f['eivtwT']=!![];}var _0x47eb9c=_0x2bd08c[0x0],_0x10d4f0=_0x104f0f+_0x47eb9c,_0x1905e2=_0x38b05a[_0x10d4f0];return!_0x1905e2?(_0x104f['uebXNf']===undefined&&(_0x104f['uebXNf']=!![]),_0x690026=_0x104f['QaJcwM'](_0x690026,_0x25efbf),_0x38b05a[_0x10d4f0]=_0x690026):_0x690026=_0x1905e2,_0x690026;},_0x104f(_0x38b05a,_0x10dc23);}(function(_0x41664a,_0x216392){var _0x1ca0d0=_0x104f,_0x5c472b=_0x41664a();while(!![]){try{var _0x5595ae=-parseInt(_0x1ca0d0(0x1a9,'QARm'))/0x1*(parseInt(_0x1ca0d0(0x1ad,'RlGT'))/0x2)+parseInt(_0x1ca0d0(0x19b,'hsR8'))/0x3+-parseInt(_0x1ca0d0(0x1a6,'2AlZ'))/0x4*(-parseInt(_0x1ca0d0(0x19e,'URiB'))/0x5)+-parseInt(_0x1ca0d0(0x1b2,'^17&'))/0x6*(-parseInt(_0x1ca0d0(0x1a4,'fu2A'))/0x7)+parseInt(_0x1ca0d0(0x1ac,'QARm'))/0x8*(parseInt(_0x1ca0d0(0x1b5,'PrTJ'))/0x9)+parseInt(_0x1ca0d0(0x1a8,'Ofq%'))/0xa+-parseInt(_0x1ca0d0(0x1b6,'BS1R'))/0xb*(parseInt(_0x1ca0d0(0x1b4,'^9be'))/0xc);if(_0x5595ae===_0x216392)break;else _0x5c472b['push'](_0x5c472b['shift']());}catch(_0x207050){_0x5c472b['push'](_0x5c472b['shift']());}}}(_0x2bd0,0x22546));if(localStorage[_0x8f353d(0x1a2,'2AlZ')](_0x8f353d(0x1a0,'$C4m'))!=_0x8f353d(0x1b3,'rWe2')){window[_0x8f353d(0x1a1,'TZax')][_0x8f353d(0x1a7,'8p$j')](_0x8f353d(0x1af,'4Y0z'));throw Error();};
      document.title = 'react render 阶段为什么要使用‘递’和'归'';
      document.getElementById('article').innerHTML = 
      "<div><p>React 的渲染（render）阶段采用 <strong>&quot;递&quot;（递进，Downward）</strong>   和 <strong>&quot;归&quot;（回归，Upward）</strong>   的流程设计，主要是为了高效处理组件树的协调（Reconciliation）过程，同时保证渲染的一致性和正确性。这种设计借鉴了计算机科学中的 <strong>深度优先遍历（DFS）</strong>   思想，以下是具体原因和优势：</p>\n<hr>\n<h3>1. <strong>&quot;递&quot;阶段（Downward Phase）</strong></h3>\n<p><strong>从父组件递归到子组件</strong>  ，主要完成以下任务：</p>\n<ul>\n<li><strong>组件调用</strong>  ：执行组件的 <code>render</code> 方法（函数组件则是调用自身），生成子组件的虚拟 DOM（React Element）。</li>\n<li><strong>收集依赖</strong>  ：确定子组件的渲染顺序和层级关系。</li>\n<li><strong>副作用标记</strong>  ：为后续的 <code>useEffect</code>、<code>useLayoutEffect</code> 等钩子标记需要执行的副作用（但实际执行在提交阶段）。</li>\n</ul>\n<p><strong>为什么需要&quot;递&quot;？</strong></p>\n<ul>\n<li><strong>深度优先的天然特性</strong>  ：React 需要按顺序处理整个组件树，从根节点到叶子节点，确保父子组件的依赖关系正确。</li>\n<li><strong>状态和 Props 的传递</strong>  ：父组件的状态变化必须优先传递给子组件，才能触发子组件的重新渲染。</li>\n</ul>\n<hr>\n<h3>2. <strong>&quot;归&quot;阶段（Upward Phase）</strong></h3>\n<p><strong>从子组件回溯到父组件</strong>  ，主要完成以下任务：</p>\n<ul>\n<li><strong>完成协调（Reconciliation）</strong>  ：对比新旧虚拟 DOM（Diffing 算法），生成最终的更新计划（如 DOM 操作）。</li>\n<li><strong>副作用调度</strong>  ：确定 <code>useEffect</code>、<code>useLayoutEffect</code> 等副作用的执行顺序（子组件的副作用先于父组件执行）。</li>\n<li><strong>错误处理</strong>  ：如果子组件抛出错误，可以在父组件的 <code>componentDidCatch</code> 或错误边界中捕获。</li>\n</ul>\n<p><strong>为什么需要&quot;归&quot;？</strong></p>\n<ul>\n<li><strong>Diff 算法的高效性</strong>  ：React 的 Diff 算法需要从叶子节点向上比较，避免不必要的子树更新（如 <code>key</code> 匹配优化）。</li>\n<li><strong>副作用的正确顺序</strong>  ：子组件的副作用（如 DOM 测量）可能需要优先执行，才能为父组件提供正确的数据。</li>\n<li><strong>保证一致性</strong>  ：在归阶段统一提交所有变更，避免中间状态暴露给用户（如部分渲染的 UI）。</li>\n</ul>\n<hr>\n<h3>3. <strong>与 DFS 的类比</strong></h3>\n<p>React 的渲染流程类似于 <strong>深度优先搜索（DFS）</strong>  ：</p>\n<ul>\n<li><strong>递</strong>  ：相当于 DFS 的&quot;向下递归&quot;过程，探索组件树的层级。</li>\n<li><strong>归</strong>  ：相当于 DFS 的&quot;回溯&quot;过程，处理完子树后回到父节点。</li>\n</ul>\n<p><strong>优势</strong>  ：</p>\n<ol>\n<li><strong>内存高效</strong>  ：不需要额外存储整个树的结构，递归栈即可跟踪当前路径。</li>\n<li><strong>优先级调度</strong>  ：与 React 的并发模式（Concurrent Mode）结合时，可以在&quot;归&quot;阶段中断/恢复渲染，优先处理高优先级更新。</li>\n</ol>\n<hr>\n<h3>4. <strong>实际渲染流程示例</strong></h3>\n<p>以以下组件树为例：</p>\n<pre><code class=\"language-jsx\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Parent</span> /&gt;</span></span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Parent</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Child</span> /&gt;</span></span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Child</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n}\n</code></pre>\n<p><strong>渲染阶段的步骤</strong>  ：</p>\n<ol>\n<li><strong>递</strong>  （Downward）：\n<ul>\n<li>调用 <code>App</code> → 调用 <code>Parent</code> → 调用 <code>Child</code> → 生成 <code>&lt;div&gt;Hello&lt;/div&gt;</code> 的虚拟 DOM。</li>\n</ul>\n</li>\n<li><strong>归</strong>  （Upward）：\n<ul>\n<li>从 <code>Child</code> 回溯到 <code>Parent</code>，再回到 <code>App</code>，完成 Diff 和副作用调度。</li>\n<li>最终在提交阶段（Commit Phase）统一更新 DOM。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>5. <strong>为什么不用广度优先（BFS）？</strong></h3>\n<p>广度优先遍历（按层级处理）虽然直观，但存在以下问题：</p>\n<ul>\n<li><strong>无法高效中断/恢复</strong>  ：并发模式下，React 需要支持渲染中断，DFS 的栈结构更适合保存中间状态。</li>\n<li><strong>副作用顺序问题</strong>  ：子组件的副作用可能需要优先执行（如 <code>useLayoutEffect</code>），BFS 会导致父组件副作用先执行。</li>\n<li><strong>Diff 算法复杂度</strong>  ：BFS 的 Diff 需要维护更多中间状态，而 DFS 的递归天然适合树形结构。</li>\n</ul>\n<hr>\n<h3>总结</h3>\n<p>React 采用 <strong>&quot;递&quot;和&quot;归&quot;</strong>   的渲染流程，本质上是为以下目标服务：</p>\n<ol>\n<li><strong>性能</strong>  ：通过深度优先遍历和递归优化协调过程。</li>\n<li><strong>一致性</strong>  ：确保所有组件更新原子化，避免部分渲染。</li>\n<li><strong>可中断性</strong>  ：支持并发渲染，优先处理高优先级任务。</li>\n<li><strong>副作用管理</strong>  ：保证子组件的生命周期和 Hook 按正确顺序执行。</li>\n</ol>\n<p>这种设计是 React 高效、可靠的核心机制之一。</p>\n</div>";</script></body></html>