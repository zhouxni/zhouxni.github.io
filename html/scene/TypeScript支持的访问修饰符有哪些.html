<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x505ee5=_0x554c;function _0x1580(){var s=["WOKpW6dcVCk9W6fv","W6nVW7DSeGFdM8oR","W5lcHCoJWQjuW4XUiCk+fCkaxwm","W4dcUM0FhKxcHmoMWOKjWQ/cPa","pSkgWRz1mSklW4OoW5RcJmobf8k7aaNdKtldV2RcUCkdWOOXWPdcUCkY","WPfGWPNdPCkrW6SYtCoPW6zH","bvldNSkSW5xdQIfECG","WRJcGSoQW4CPW6xcIsfBWP8F","z8odW7SZDCkbW51pW4hcPSoAl8kU","WQ5KB8kSBtmvWOn5","fLBdOGy1nmkd","y3iJWP8lWQ9zlI4","W4Xhr8ofW71TW7TCw3dcI3S","W6KbWQizWPurtWm","ig7dOSojW6NdPbbGWOCZWOW1","vSkzW4pdLCo5WPvoWP8","iwRcPSk1WOlcLc9D","WQ9VAmoclu83WOXMW4SNWO4","iSkYt8kuwmkqW6yuWQGivdu","cbmshx1IW7vL","xCkNsmkSkgdcJSoE","W53dHb/dKSoPWPnEW55etmoi","wmkHdmoUEKlcV8ojfffS","iadcTmkjWOFcLry","fYGhv8oZWP9SWQzbiCoifa","W6zkkX5gW6xcLb1pWPGk","yI/cO8koWQG","nLtdJCkLW4FdUG8","W6biAv8DW5ZcLtG"];return(_0x1580=function(){return s})()}function _0x554c(t,s){var p=_0x1580();return(_0x554c=function(s,n){var a=p[s-=288];void 0===_0x554c.HHvBGK&&(_0x554c.uXtctG=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,c=0;a=s.charAt(c++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,o=l.length;e<o;e++)t+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)t=(t+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[t],l[t]=a;for(var c=0,t=0,e=0;e<s.length;e++)a=l[c=(c+1)%256],l[c]=l[t=(t+l[c])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(e)^l[(l[c]+l[t])%256]);return p},t=arguments,_0x554c.HHvBGK=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x554c.iGJNVe&&(_0x554c.iGJNVe=!0),a=_0x554c.uXtctG(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x554c,n=_0x1580();;)try{if(128192==+parseInt(s(297,"70Cq"))*(parseInt(s(301,"aQ4E"))/2)+parseInt(s(289,"mp&e"))/3+parseInt(s(292,"FzZd"))/4*(-parseInt(s(294,"FzZd"))/5)+parseInt(s(316,"wqdr"))/6*(-parseInt(s(296,"(we@"))/7)+parseInt(s(309,"S]IK"))/8+-parseInt(s(315,"Bkoc"))/9*(parseInt(s(302,"Zo)z"))/10)+parseInt(s(312,"HK9p"))/11*(parseInt(s(306,"U5ha"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x505ee5(311,"2Ro[")](_0x505ee5(307,"O*t)"))!=_0x505ee5(298,"Bkoc"))throw window[_0x505ee5(291,"AmXu")][_0x505ee5(299,"O*t)")](_0x505ee5(305,"S]IK")),Error();document.title="TypeScript支持的访问修饰符有哪些",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，访问修饰符（Access Modifiers）用于控制类成员（属性、方法）的可见性和访问权限。TypeScript 支持以下三种主要的访问修饰符：</p>\n<hr>\n<h3><strong>1. <code>public</code>（公共访问修饰符）</strong></h3>\n<ul>\n<li><strong>定义</strong>  ：<code>public</code> 是默认的访问修饰符，表示类成员可以被任何地方访问，包括类的内部、子类和外部代码。</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li>如果没有显式指定访问修饰符，类成员默认为 <code>public</code>。</li>\n<li>适用于需要广泛访问的成员。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;\n  }\n\n  <span class="hljs-keyword">public</span> <span class="hljs-title function_">move</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> is moving.`</span>);\n  }\n}\n\n<span class="hljs-keyword">const</span> animal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;Lion&quot;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(animal.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出：Lion</span>\nanimal.<span class="hljs-title function_">move</span>();            <span class="hljs-comment">// 输出：Lion is moving.</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>2. <code>private</code>（私有访问修饰符）</strong></h3>\n<ul>\n<li><strong>定义</strong>  ：<code>private</code> 表示类成员只能在类的内部访问，不能在子类或外部代码中访问。</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li>提供了封装性，防止外部代码直接修改类的内部状态。</li>\n<li>适用于需要隐藏实现细节的成员。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-keyword">private</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;\n  }\n\n  <span class="hljs-keyword">public</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;\n  }\n}\n\n<span class="hljs-keyword">const</span> animal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;Lion&quot;</span>);\n<span class="hljs-comment">// console.log(animal.name); // 错误：属性 &#x27;name&#x27; 是私有的</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(animal.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// 输出：Lion</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>3. <code>protected</code>（受保护访问修饰符）</strong></h3>\n<ul>\n<li><strong>定义</strong>  ：<code>protected</code> 表示类成员可以在类的内部和子类中访问，但不能在外部代码中访问。</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li>提供了比 <code>private</code> 更宽松的访问权限，允许子类访问。</li>\n<li>适用于需要在子类中访问但不希望外部代码访问的成员。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {\n  <span class="hljs-keyword">protected</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;\n  }\n\n  <span class="hljs-keyword">public</span> <span class="hljs-title function_">move</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> is moving.`</span>);\n  }\n}\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> {\n  <span class="hljs-keyword">public</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> is barking.`</span>);\n  }\n}\n\n<span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;Buddy&quot;</span>);\n<span class="hljs-comment">// console.log(dog.name); // 错误：属性 &#x27;name&#x27; 是受保护的</span>\ndog.<span class="hljs-title function_">bark</span>(); <span class="hljs-comment">// 输出：Buddy is barking.</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>访问修饰符对比表</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>修饰符</strong></th>\n<th><strong>访问范围</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>public</code></td>\n<td>类的内部、子类、外部代码</td>\n<td>需要广泛访问的成员，如公共接口</td>\n</tr>\n<tr>\n<td><code>private</code></td>\n<td>仅类的内部</td>\n<td>需要隐藏实现细节的成员，如内部状态</td>\n</tr>\n<tr>\n<td><code>protected</code></td>\n<td>类的内部和子类</td>\n<td>需要在子类中访问但不希望外部访问的成员</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>使用建议</strong></h3>\n<ul>\n<li><strong><code>public</code></strong>  ：用于定义类的公共接口，如方法、属性等，允许外部代码访问。</li>\n<li><strong><code>private</code></strong>  ：用于隐藏类的内部实现细节，防止外部代码直接修改类的状态。</li>\n<li><strong><code>protected</code></strong>  ：用于允许子类访问但不希望外部代码访问的成员，适用于继承场景。</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>TypeScript 支持 <code>public</code>、<code>private</code> 和 <code>protected</code> 三种访问修饰符，分别用于控制类成员的可见性和访问权限。选择合适的访问修饰符可以提高代码的封装性和可维护性，确保类的内部状态不被外部代码随意修改。</p>\n</div>'</script></body></html>