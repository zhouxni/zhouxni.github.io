<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1695(r,n){var t=_0x1c22();return(_0x1695=function(n,o){var e=t[n-=158];void 0===_0x1695.sjwUua&&(_0x1695.hKlkib=function(n,o){var e,s=[],r=0,t="";for(n=(n=>{for(var o,e,s="",r="",t=0,c=0;e=n.charAt(c++);~e&&(o=t%4?64*o+e:e,t++%4)&&(s+=String.fromCharCode(255&o>>(-2*t&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var l=0,d=s.length;l<d;l++)r+="%"+("00"+s.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(r)})(n),c=0;c<256;c++)s[c]=c;for(c=0;c<256;c++)r=(r+s[c]+o.charCodeAt(c%o.length))%256,e=s[c],s[c]=s[r],s[r]=e;for(var c=0,r=0,l=0;l<n.length;l++)e=s[c=(c+1)%256],s[c]=s[r=(r+s[c])%256],s[r]=e,t+=String.fromCharCode(n.charCodeAt(l)^s[(s[c]+s[r])%256]);return t},r=arguments,_0x1695.sjwUua=!0);var n=n+t[0],s=r[n];return s?e=s:(void 0===_0x1695.hInhYt&&(_0x1695.hInhYt=!0),e=_0x1695.hKlkib(e,o),r[n]=e),e})(r,n)}var _0xd089a0=_0x1695;function _0x1c22(){var n=["W5dcM3PtW6TiymkiW6DCWQNdKCkN","xCksW6NdPmkFWOuVma","WQSPWQ0iWRmPFmkeCG","WPhcOmoQfxf7W4/dNSohW6rd","WOpcIaDbwK/cMq","btaVWPRcRJOKf2OiWQWpvSoB","W4CTwmoUpmkfW6jhWQBcIG","ChXxW6FcJmk0xLBcOSoPW7ylW7K","ySoAW4FdNCkN","WP4dWOveqGHEWOnTnaJcH8oPgG","WP3cJJ7dUSkYnCk/A8o1x8o5nulcHg4YWRaGgeRcPmkYWOzuiNC","iCoAW7pdHHiXW73dOH5rWRXFW6q","Dwn/W4JdRhHAq18","WRNcJ8k6yWO+WOy","jSkWWOhdNcvsWOtdLcf2BSoHW60","WP4YA1CCnMuelCkZCSoxW4W","Ch9zW63cICk+uKpcNComW7ipW6u","W4ldJhlcUSo3BCoaiCo4wCo1","W4ddR8k3W5JdNCorW5JcQ8kU","WP0cWOflraTFW75mfsdcVCoQ","W5aCW73cN8o7W7VdSW","W4ddNKqvaX/dJ8kCp8kzW6rtW5e","o8oTW490WOxcGby"];return(_0x1c22=function(){return n})()}if((()=>{for(var n=_0x1695,o=_0x1c22();;)try{if(942199==+parseInt(n(168,"Bv1#"))+-parseInt(n(175,"smUx"))/2*(-parseInt(n(164,"2Kn#"))/3)+-parseInt(n(160,"I^Gv"))/4+parseInt(n(159,"T$yu"))/5*(parseInt(n(178,"OiZO"))/6)+-parseInt(n(162,"a&O7"))/7+-parseInt(n(169,"I^Gv"))/8+parseInt(n(170,"Q4hZ"))/9)break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0xd089a0(173,"l5hR")](_0xd089a0(165,"Lh)6"))!=_0xd089a0(161,"xrE7"))throw window[_0xd089a0(177,"TgZk")][_0xd089a0(180,"*LFk")](_0xd089a0(163,"Q4hZ")),Error();document.title="vite 依赖预构建",document.getElementById("article").innerHTML='<div><p>是的！Vite 在<strong>首次启动开发服务器</strong>  时，会执行一个关键步骤：<strong>依赖预构建（Dependency Pre-Bundling）</strong>  。这一过程的核心目标之一正是将 <code>node_modules</code> 中的 CommonJS 或 UMD 格式的依赖项转换为 <strong>ESM 格式</strong>  ，并缓存结果以提升后续性能。以下是详细解析：</p>\n<hr>\n<h3>1. <strong>为什么需要预构建？</strong></h3>\n<ul>\n<li><strong>ESM 兼容性</strong>  ：浏览器只能直接运行 ESM 模块，但许多第三方库仍使用 CommonJS（如 <code>require/exports</code>），需转换。</li>\n<li><strong>性能优化</strong>  ：避免浏览器逐个请求 <code>node_modules</code> 中的大量小文件（如 <code>lodash</code> 的数百个子模块）。</li>\n<li><strong>一致性</strong>  ：统一依赖的模块格式，避免混合使用 ESM 和 CommonJS 导致的运行时问题。</li>\n</ul>\n<hr>\n<h3>2. <strong>预构建的具体行为</strong></h3>\n<ul>\n<li><strong>首次启动时</strong>  ：\n<ul>\n<li>Vite 扫描项目代码中的 <code>import</code> 语句，识别出所有依赖的第三方库。</li>\n<li>使用 <strong>esbuild</strong>  （极快的 JS 打包工具）将这些依赖从 CommonJS/UMD 转换为 ESM 格式。</li>\n<li>将转换后的代码和依赖的静态资源（如 CSS）合并为单个或多个 ESM 文件（如 <code>vue.js</code>、<code>react.js</code>）。</li>\n<li>结果缓存到 <code>node_modules/.vite</code> 目录中。</li>\n</ul>\n</li>\n<li><strong>后续启动</strong>  ：\n<ul>\n<li>检查 <code>package.json</code> 的 <code>dependencies</code> 是否变化（如版本更新）。</li>\n<li>若无变化，直接使用缓存，跳过预构建，启动速度极快。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>3. <strong>缓存机制的优势</strong></h3>\n<ul>\n<li><strong>开发体验</strong>  ：二次启动时无需重复转换，冷启动时间从几秒降至毫秒级。</li>\n<li><strong>稳定性</strong>  ：避免因依赖格式不一致导致的运行时错误（如 <code>process.env</code> 未定义）。</li>\n<li><strong>网络优化</strong>  ：合并依赖后，浏览器只需加载少数预构建文件，而非数百个小模块。</li>\n</ul>\n<hr>\n<h3>4. <strong>如何触发重新预构建？</strong></h3>\n<ul>\n<li><strong>手动触发</strong>  ：删除 <code>node_modules/.vite</code> 目录或运行 <code>vite --force</code>。</li>\n<li><strong>自动触发</strong>  ：\n<ul>\n<li><code>package.json</code> 的 <code>dependencies</code> 发生变更。</li>\n<li>检测到锁文件（如 <code>package-lock.json</code>）变化。</li>\n<li>修改了 <code>vite.config.js</code> 中的 <code>optimizeDeps</code> 配置。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>5. <strong>自定义预构建行为</strong></h3>\n<p>在 <code>vite.config.js</code> 中可通过 <code>optimizeDeps</code> 配置：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">optimizeDeps</span>: {\n    <span class="hljs-comment">// 强制包含或排除特定依赖</span>\n    <span class="hljs-attr">include</span>: [<span class="hljs-string">&#x27;lodash-es&#x27;</span>],\n    <span class="hljs-attr">exclude</span>: [<span class="hljs-string">&#x27;some-cjs-only-package&#x27;</span>],\n    <span class="hljs-comment">// 禁用预构建（不推荐）</span>\n    <span class="hljs-attr">disabled</span>: <span class="hljs-literal">false</span>,\n  },\n}\n</code></pre>\n<hr>\n<h3>6. <strong>生产环境的处理</strong></h3>\n<ul>\n<li><strong>生产构建</strong>  ：Vite 使用 Rollup 打包，所有依赖会被 Tree-shaken 并合并到最终的 chunk 中，无需预构建步骤。</li>\n<li><strong>与开发的差异</strong>  ：生产环境不依赖浏览器 ESM，而是生成优化后的静态文件。</li>\n</ul>\n<hr>\n<h3>常见问题</h3>\n<ul>\n<li><strong>Q：为什么修改 <code>node_modules</code> 后有时不生效？</strong><br>\nA：可能缓存未更新，尝试 <code>--force</code> 或删除 <code>.vite</code> 目录。</li>\n<li><strong>Q：如何调试预构建过程？</strong><br>\nA：运行 <code>DEBUG=&quot;vite:deps&quot; vite</code> 查看详细日志。</li>\n</ul>\n<hr>\n<h3>总结</h3>\n<p>Vite 的预构建将 CommonJS 依赖转为 ESM 并缓存，是开发环境下实现<strong>快速启动</strong>  和<strong>模块兼容性</strong>  的关键。这一设计结合了 esbuild 的速度和浏览器原生 ESM 的优势，同时保持了配置的灵活性。</p>\n</div>'</script></body></html>