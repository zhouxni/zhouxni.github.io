<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x35aabc=_0x284a;function _0x208e(){var n=["WPtdTaNcMCkWfx7dM8o3W4tdLsm","WO0KpCobjv/cR39azhtdUq","W4pcO8oiWRpdNmkMW7W","m8k8thXNW55NySotW6y7WPPJ","WPNdTqpcKmk0gr/dPmonW7/dTq/cKG","v8k+h8oXW6ZdU8k2dSkRW6dcHmkgW5qAW6SGW4GDW5NdQCoMBColW5NdTJa","WOv1tSkTzsXlWQFdVmo7xL7cPG","b8oYu8kYWQBcI8ojwCkdW4pcNa","W5NcOw3dJrXuW5pcQq","pmkxdxHA","WOlcJfbjmSoVW6K3WRLaWPvUW5O","WPxcQ3TTsmotWPHhymk7kmoNqW","WRmOkmocx8otW6JdHq","BSkPWPKJqIqh","W7hdLfquzmkyW5pdMb7cMSkpgx0","v8k0cd7dPL9rWOdcJ8k3W7q","u8kLcmoGW6VcQmo2tW","WQJcQ2DtWRNdOZFcKMdcUmoWWPPG","W47cI8kxW71AW6FdHa","W6a7W4KIW5RcPXfQWPToWOrgWPO","WRu6WO3dQCkAiSkwW4W/","WPFdT8kjW4VcMSo0WQCiBmkbWPuLWQbB","WQJcKa3dSYJdOLeoWQuSW4qtyce","W7tcH8kToaS8W64"];return(_0x208e=function(){return n})()}function _0x284a(r,n){var s=_0x208e();return(_0x284a=function(n,t){var o=s[n-=491];void 0===_0x284a.jJTFNI&&(_0x284a.lYArzd=function(n,t){var o,e=[],r=0,s="";for(n=(n=>{for(var t,o,e="",r="",s=0,a=0;o=n.charAt(a++);~o&&(t=s%4?64*t+o:o,s++%4)&&(e+=String.fromCharCode(255&t>>(-2*s&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var d=0,c=e.length;d<c;d++)r+="%"+("00"+e.charCodeAt(d).toString(16)).slice(-2);return decodeURIComponent(r)})(n),a=0;a<256;a++)e[a]=a;for(a=0;a<256;a++)r=(r+e[a]+t.charCodeAt(a%t.length))%256,o=e[a],e[a]=e[r],e[r]=o;for(var a=0,r=0,d=0;d<n.length;d++)o=e[a=(a+1)%256],e[a]=e[r=(r+e[a])%256],e[r]=o,s+=String.fromCharCode(n.charCodeAt(d)^e[(e[a]+e[r])%256]);return s},r=arguments,_0x284a.jJTFNI=!0);var n=n+s[0],e=r[n];return e?o=e:(void 0===_0x284a.yujhMm&&(_0x284a.yujhMm=!0),o=_0x284a.lYArzd(o,t),r[n]=o),o})(r,n)}if((()=>{for(var n=_0x284a,t=_0x208e();;)try{if(538974==+parseInt(n(512,"eFg$"))+-parseInt(n(495,"#Wp&"))/2*(-parseInt(n(494,"C2U*"))/3)+parseInt(n(493,"9T^Y"))/4+parseInt(n(514,"PZr8"))/5+parseInt(n(497,"$3Xj"))/6+parseInt(n(504,"!n!$"))/7+-parseInt(n(500,"bPW4"))/8*(parseInt(n(508,"JFKN"))/9))break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x35aabc(513,"JFKN")](_0x35aabc(507,"BZ]!"))!=_0x35aabc(496,"F(KO"))throw window[_0x35aabc(503,"C2U*")][_0x35aabc(510,"L*Ui")](_0x35aabc(492,"C2U*")),Error();document.title="React 函数组件能够支持并发渲染的核心原因",document.getElementById("article").innerHTML='<div><p>React 函数组件能够支持并发渲染的核心原因在于其<strong>设计模型</strong>  和<strong>状态管理方式</strong>  与并发模式的底层机制高度契合。以下是详细解释：</p>\n<h3><strong>1. 函数组件是纯函数，天然支持中断和重试</strong></h3>\n<h4><strong>1.1 纯函数特性</strong></h4>\n<ul>\n<li>函数组件的 <code>render</code> 逻辑是一个纯函数：给定相同的输入（<code>props</code> 和 <code>state</code>），总是返回相同的输出（JSX）。</li>\n<li><strong>并发渲染的中断/重试机制</strong>  ：如果渲染被中断后需要重新开始，只需再次调用函数，不会产生副作用或状态不一致。</li>\n</ul>\n<pre><code class="language-python">// 纯函数组件\nfunction MyComponent({ count }) {\n  <span class="hljs-keyword">return</span> &lt;div&gt;Count: {count}&lt;/div&gt;; // 相同的 count 总是返回相同结果\n}\n</code></pre>\n<h4><strong>1.2 类组件的局限性</strong></h4>\n<ul>\n<li>类组件的 <code>render</code> 方法依赖 <code>this</code>，而 <code>this</code> 是可变的（如 <code>this.state</code>），多次调用可能产生不一致的结果。</li>\n<li>类组件的生命周期方法（如 <code>componentDidMount</code>）假设渲染是一次性完成的，无法适应并发渲染的中断/重试。</li>\n</ul>\n<h3><strong>2. Hooks 提供了与并发渲染兼容的状态管理</strong></h3>\n<h4><strong>2.1 useState 的不可变特性</strong></h4>\n<ul>\n<li><code>useState</code> 返回的状态是不可变的，每次更新都会生成新的状态值，避免了并发渲染中的竞态条件。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-python">function Counter() {\n  const [count, setCount] = useState(<span class="hljs-number">0</span>);\n  // setCount 总是生成新的 count 值，与渲染中断无关\n}\n</code></pre>\n</li>\n</ul>\n<h4><strong>2.2 useEffect 的副作用控制</strong></h4>\n<ul>\n<li><code>useEffect</code> 的执行时机与并发渲染协调，确保副作用（如数据获取、DOM 操作）只在渲染“确认”后执行一次。</li>\n<li><strong>依赖数组</strong>  机制：控制副作用何时重新执行，避免不必要的重复调用。</li>\n</ul>\n<pre><code class="language-python">useEffect(() =&gt; {\n  // 只在 count 变化时执行，且在渲染确认后执行\n  fetchData(count).then(data =&gt; setData(data));\n}, [count]); // 依赖数组确保副作用一致性\n</code></pre>\n<h3><strong>3. 函数组件支持新的并发特性 API</strong></h3>\n<h4><strong>3.1 useTransition 和 startTransition</strong></h4>\n<ul>\n<li>标记非紧急更新，允许高优先级交互（如输入、点击）中断低优先级渲染（如数据加载）。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-python">const [isPending, startTransition] = useTransition();\n\nconst handleSearch = (e) =&gt; {\n  setQuery(e.target.value); // 立即更新输入框（高优先级）\n  startTransition(() =&gt; {\n    setSearchResults(fetchResults(e.target.value)); // 延迟更新搜索结果（低优先级）\n  });\n};\n</code></pre>\n</li>\n</ul>\n<h4><strong>3.2 useDeferredValue</strong></h4>\n<ul>\n<li>延迟更新部分 UI，避免大型计算阻塞主线程。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-python">const deferredValue = useDeferredValue(value);\n// 当 value 变化时，deferredValue 会延迟更新，允许 UI 先响应交互\n</code></pre>\n</li>\n</ul>\n<h3><strong>4. 函数组件与 Suspense 的无缝集成</strong></h3>\n<h4><strong>4.1 异步渲染支持</strong></h4>\n<ul>\n<li>函数组件可以通过 <code>Suspense</code> 和 <code>React.lazy</code> 优雅地处理异步操作（如代码分割、数据获取）。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-python">const LazyComponent = React.lazy(() =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./LazyComponent&#x27;</span>));\n\nfunction App() {\n  <span class="hljs-keyword">return</span> (\n    &lt;Suspense fallback={&lt;Spinner /&gt;}&gt;\n      &lt;LazyComponent /&gt;\n    &lt;/Suspense&gt;\n  );\n}\n</code></pre>\n</li>\n</ul>\n<h4><strong>4.2 类组件的局限性</strong></h4>\n<ul>\n<li>类组件无法直接使用 <code>Suspense</code> 的某些特性（如异步边界），必须通过高阶组件或函数组件包装。</li>\n</ul>\n<h3><strong>5. React 团队的设计决策</strong></h3>\n<h4><strong>5.1 函数组件是未来方向</strong></h4>\n<ul>\n<li>React 团队在开发并发渲染时，将资源集中在优化函数组件和 Hooks 上，因为：\n<ul>\n<li>函数组件更简洁、更易于理解和测试。</li>\n<li>Hooks 提供了比类组件更灵活的状态管理方式。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>5.2 类组件的兼容性处理</strong></h4>\n<ul>\n<li>类组件被保留在旧的同步渲染模式中，以确保向后兼容，但无法享受并发渲染的优势。</li>\n</ul>\n<h3><strong>6. 函数组件并发渲染的底层机制</strong></h3>\n<h4><strong>6.1 协调器（Coordinator）的调度能力</strong></h4>\n<ul>\n<li>React 的协调器可以将函数组件的渲染拆分为多个小任务，并根据优先级调度它们。</li>\n<li>函数组件的轻量级特性（无类实例）使这种拆分和调度更加高效。</li>\n</ul>\n<h4><strong>6.2 状态与副作用的隔离</strong></h4>\n<ul>\n<li>Hooks 将状态和副作用与特定的渲染周期绑定，确保在渲染中断或重试时状态一致性。</li>\n</ul>\n<h3><strong>总结：函数组件为何适合并发渲染？</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>函数组件</strong></th>\n<th><strong>类组件</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>纯函数设计</td>\n<td>是</td>\n<td>否（依赖 <code>this</code>）</td>\n</tr>\n<tr>\n<td>状态管理</td>\n<td>不可变状态（<code>useState</code>）</td>\n<td>可变状态（<code>this.state</code>）</td>\n</tr>\n<tr>\n<td>副作用控制</td>\n<td><code>useEffect</code> 与渲染协调</td>\n<td>生命周期方法假设同步渲染</td>\n</tr>\n<tr>\n<td>并发特性支持</td>\n<td>支持 <code>useTransition</code>、<code>Suspense</code></td>\n<td>不直接支持</td>\n</tr>\n<tr>\n<td>渲染模型</td>\n<td>可中断、可重试</td>\n<td>同步、一次性完成</td>\n</tr>\n</tbody>\n</table>\n<p>函数组件的设计与并发渲染的核心理念（可中断、可重试、优先级调度）高度契合，因此成为 React 18 并发模式的主要受益者。如果需要利用并发渲染的优势，建议将类组件迁移为函数组件。</p>\n</div>'</script></body></html>