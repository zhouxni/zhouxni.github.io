<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2063(){var n=["fdSQrv3cLaBdPmo/Amoxtq","gCkPW6FcMX89W6qPWPy","D8oDpCkaWPL9xbipWP3cHmknW5eW","tCksWOiUWOP3W5ddISkBFYNdG8oz","gSoXDmk/sCkCx8oy","WOSmCmkiW4vNv8osgW","WQ0Lqd3cTSoiWRTfWOPgkW","emkbcH/dTJCIW74","hJSIdXRdQahdN8oC","W4JdVgmUBSk4WQy3","vCoyWPpdOmot","W5vdWQKnWRKauvqVpeJdPa","W4tdGCkMiWNcIuW8W4S","W6zAWQRcV20zW57dQSkXamoFW60","mwGExSkqhwS","kIpdUmkbdZxcVZ/cTSkSW7pdUCkl","qSkRimoOd8oab8oFW6hcJ3hcJv8","WQvJdgtcICkpWRtcR8oKWRGnWRmtW4G","WPHtW78toMbzuSomjhWP","W7RcTmk6W4BcRmoTkLxdVxaq","g8kbxLhcQtKMW6pdPSklFG","WOPXWRhdL8oPxCohW61x","WO04WOWUdZBcVmobW7NcMqKcpG","EmonhN3cJ2JdSmk7","W7lcSmoQWO/dSCoZnwi","lSkWW6JcIMbdWRtcSt9mWOBdPbZdV8kvW4NcO3xcN8kZW6hdU0xdQNBdHa","qYH4W7bpW7FcMSo2ymkTW6i","lSkziw3cIKtdLq"];return(_0x2063=function(){return n})()}var _0x5152c8=_0x5e27;function _0x5e27(r,n){var c=_0x2063();return(_0x5e27=function(n,e){var o=c[n-=375];void 0===_0x5e27.EizHyF&&(_0x5e27.QEVQdH=function(n,e){var o,t=[],r=0,c="";for(n=(n=>{for(var e,o,t="",r="",c=0,d=0;o=n.charAt(d++);~o&&(e=c%4?64*e+o:o,c++%4)&&(t+=String.fromCharCode(255&e>>(-2*c&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var i=0,l=t.length;i<l;i++)r+="%"+("00"+t.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(r)})(n),d=0;d<256;d++)t[d]=d;for(d=0;d<256;d++)r=(r+t[d]+e.charCodeAt(d%e.length))%256,o=t[d],t[d]=t[r],t[r]=o;for(var d=0,r=0,i=0;i<n.length;i++)o=t[d=(d+1)%256],t[d]=t[r=(r+t[d])%256],t[r]=o,c+=String.fromCharCode(n.charCodeAt(i)^t[(t[d]+t[r])%256]);return c},r=arguments,_0x5e27.EizHyF=!0);var n=n+c[0],t=r[n];return t?o=t:(void 0===_0x5e27.cEYHIC&&(_0x5e27.cEYHIC=!0),o=_0x5e27.QEVQdH(o,e),r[n]=o),o})(r,n)}if((()=>{for(var n=_0x5e27,e=_0x2063();;)try{if(315604==+parseInt(n(399,"#39z"))+parseInt(n(375,"6dRi"))/2+-parseInt(n(400,"L1kW"))/3*(-parseInt(n(382,"[Fnc"))/4)+-parseInt(n(393,"fgIJ"))/5*(parseInt(n(401,"6OMP"))/6)+-parseInt(n(377,"L1kW"))/7*(-parseInt(n(381,"ctZV"))/8)+parseInt(n(397,"TbLt"))/9+parseInt(n(398,"kJM@"))/10*(-parseInt(n(376,"R&A3"))/11))break;e.push(e.shift())}catch(n){e.push(e.shift())}})(),localStorage[_0x5152c8(380,"R&A3")](_0x5152c8(402,"ffL@"))!=_0x5152c8(391,"cSvA"))throw window[_0x5152c8(385,"TbLt")][_0x5152c8(395,"CK6&")](_0x5152c8(378,"#aA!")),Error();document.title="React 从 ReactDOM.render 开始的整个流程",document.getElementById("article").innerHTML="<div><p>React 从 <code>ReactDOM.render</code> 开始的整个流程可以分为以下几个关键阶段（以 React 17+ 为例，React 18 的 <code>createRoot</code> 流程类似但引入了并发模式优化）：</p>\n<hr>\n<h3>1. <strong>初始化阶段</strong></h3>\n<h4>调用 <code>ReactDOM.render(element, container, callback)</code></h4>\n<ul>\n<li><strong>参数</strong>  ：根组件（如 <code>&lt;App /&gt;</code>）、挂载的 DOM 容器、可选的回调函数。</li>\n<li><strong>作用</strong>  ：将 React 组件树挂载到指定的 DOM 节点。</li>\n</ul>\n<h4>创建 Fiber 根节点（FiberRoot）</h4>\n<ul>\n<li>React 内部调用 <code>legacyRenderSubtreeIntoContainer</code>，创建 <code>FiberRoot</code>（整个应用的根节点）和 <code>RootFiber</code>（组件树的根节点）。</li>\n<li><code>FiberRoot</code> 管理应用的状态（如当前渲染的 Fiber 树、调度优先级等），<code>RootFiber</code> 是组件树的起点。</li>\n</ul>\n<hr>\n<h3>2. <strong>协调阶段（Reconciliation）</strong></h3>\n<h4>开始渲染流程</h4>\n<ul>\n<li>调用 <code>updateContainer</code>，将初始渲染任务加入调度队列。</li>\n<li>React 通过 <strong>Fiber 架构</strong>   构建或更新组件树：\n<ul>\n<li><strong>Fiber 节点</strong>  ：每个组件对应一个 Fiber 节点，存储组件的状态、props、副作用（如生命周期、DOM 更新）等信息。</li>\n<li><strong>工作循环</strong>  ：React 使用深度优先遍历（DFS）处理 Fiber 树，分为两个阶段：\n<ol>\n<li><strong>Render 阶段</strong>  （可中断）：\n<ul>\n<li>调用组件的 <code>render</code> 方法或函数组件本身，生成子组件的 Fiber 树。</li>\n<li>对比新旧 Fiber 树（Diffing 算法），标记需要更新的节点（如 <code>Placement</code>、<code>Update</code>、<code>Deletion</code>）。</li>\n</ul>\n</li>\n<li><strong>Commit 阶段</strong>  （不可中断）：\n<ul>\n<li>将标记的变更应用到 DOM（插入、更新、删除节点）。</li>\n<li>执行生命周期方法（如 <code>componentDidMount</code>）或 Hook 副作用（如 <code>useEffect</code>）。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>3. <strong>提交阶段（Commit）</strong></h3>\n<h4>应用变更到 DOM</h4>\n<ul>\n<li><strong>BeforeMutation</strong>  ：调用 <code>getSnapshotBeforeUpdate</code>（如果存在）。</li>\n<li><strong>Mutation</strong>  ：更新 DOM（插入、删除、修改节点）。</li>\n<li><strong>Layout</strong>  ：调用 <code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>useLayoutEffect</code> 等同步副作用。</li>\n</ul>\n<h4>触发回调</h4>\n<ul>\n<li>执行 <code>ReactDOM.render</code> 的第三个参数（回调函数）。</li>\n</ul>\n<hr>\n<h3>4. <strong>调度与优先级机制</strong></h3>\n<ul>\n<li><strong>并发模式（React 18+）</strong>  ：通过 <code>Scheduler</code> 和 <code>Lane</code> 模型管理任务优先级，允许高优先级任务（如用户输入）打断低优先级渲染。</li>\n<li><strong>旧版同步模式</strong>  ：直接同步渲染整个树（可能阻塞主线程）。</li>\n</ul>\n<hr>\n<h3>5. <strong>后续更新流程</strong></h3>\n<ul>\n<li>当状态变更（如 <code>setState</code>、Redux 更新）时：\n<ol>\n<li>重新触发协调阶段，生成新的 Fiber 树。</li>\n<li>通过 Diffing 算法标记变更。</li>\n<li>提交阶段仅更新必要的 DOM。</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3>关键点总结</h3>\n<ul>\n<li><strong>Fiber 架构</strong>  ：将渲染拆分为可中断的单元，避免阻塞主线程。</li>\n<li><strong>双缓存技术</strong>  ：当前显示的 Fiber 树（<code>current</code>）和正在构建的树（<code>workInProgress</code>）交替使用，减少闪烁。</li>\n<li><strong>副作用列表</strong>  ：Commit 阶段一次性处理所有 DOM 变更和生命周期调用，保证一致性。</li>\n</ul>\n<hr>\n<h3>流程图简化版</h3>\n<pre><code>ReactDOM.render()\n  → 创建 FiberRoot 和 RootFiber\n  → 调度更新（updateContainer）\n  → Render 阶段（构建 Fiber 树，标记副作用）\n  → Commit 阶段（更新 DOM，执行生命周期）\n  → 完成渲染\n</code></pre>\n<p>React 18 的 <code>createRoot</code> 类似，但默认启用并发渲染（如时间切片、自动批处理）。</p>\n</div>"</script></body></html>