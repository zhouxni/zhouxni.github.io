<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3c1596=_0x49e1;function _0x25f6(){var s=["W63dRXn0W5euvtxcTmkpzCkn","W4P9m8owW4a","W547W6WDW7KwWRy","WPtcISo/W4hcUZvKeYzCf2a","CXNdHYhcJsXIWOLEDG9Z","AHVcL8kIW7FcUmkgfaBdUsP7","WPFcISo8W4/cSZuZkWr5fgjK","W7tcRSkoDWLDWR7cTSoI","WOtdVSoCj0WDWPNcVCobW71Wva","oCk0lu9Nvvu","FbddGIpcIh9EWRTvyHa","WOG8CSktWOa7eGCZWRtcLra","sY/cImkmu1nstCkHW5S2WQq","W6iKW4/cRmoVW4vQWP57WPBcV8oYWOy","W4HTmmojW5HSfa","WObMWQ9MWRWyWPtcJ8okFNS","WPdcJ8o/W4FcTJL0oGXFgLm","WOGmW7rdgCoPWQhcSmo5WRibsG","cW0agmoeWQHkzvdcRCowv8kJW4u2pCksWPv1WQ1MW5tdGSobW5aN","W5zNi8oeW41MhGi","WOpdJmkkeCotWPuCWPqRWPanW7q","BhDsWPNcTCkCbG"];return(_0x25f6=function(){return s})()}function _0x49e1(c,s){var e=_0x25f6();return(_0x49e1=function(s,n){var a=e[s-=478];void 0===_0x49e1.pKCStQ&&(_0x49e1.WELXuO=function(s,n){var a,t=[],c=0,e="";for(s=(s=>{for(var n,a,t="",c="",e=0,l=0;a=s.charAt(l++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,p=t.length;o<p;o++)c+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(c)})(s),l=0;l<256;l++)t[l]=l;for(l=0;l<256;l++)c=(c+t[l]+n.charCodeAt(l%n.length))%256,a=t[l],t[l]=t[c],t[c]=a;for(var l=0,c=0,o=0;o<s.length;o++)a=t[l=(l+1)%256],t[l]=t[c=(c+t[l])%256],t[c]=a,e+=String.fromCharCode(s.charCodeAt(o)^t[(t[l]+t[c])%256]);return e},c=arguments,_0x49e1.pKCStQ=!0);var s=s+e[0],t=c[s];return t?a=t:(void 0===_0x49e1.pYlTLE&&(_0x49e1.pYlTLE=!0),a=_0x49e1.WELXuO(a,n),c[s]=a),a})(c,s)}if((()=>{for(var s=_0x49e1,n=_0x25f6();;)try{if(124684==-parseInt(s(489,"9dz$"))+parseInt(s(479,"V(1&"))/2+-parseInt(s(486,"A9fW"))/3+parseInt(s(485,"]NM)"))/4+parseInt(s(480,"Ai8V"))/5*(-parseInt(s(484,"ly)7"))/6)+parseInt(s(496,"Miq)"))/7+parseInt(s(494,"aGvX"))/8)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3c1596(483,"Miq)")](_0x3c1596(488,"9dz$"))!=_0x3c1596(482,"&FEy"))throw window[_0x3c1596(478,"&FEy")][_0x3c1596(495,"&FEy")](_0x3c1596(499,"V]j@")),Error();document.title="React 批处理在不同版本的区别",document.getElementById("article").innerHTML='<div><p>React 的 <strong>批处理（batching）</strong>   确实是 <strong>异步的</strong>   ，但需要注意不同版本 React 的行为差异：</p>\n<hr>\n<h3><strong>React 18 之前（同步批处理）</strong></h3>\n<ul>\n<li><strong>只在 React 事件处理函数和生命周期函数中</strong>   批处理更新（如 <code>onClick</code>、<code>onChange</code>、<code>componentDidMount</code>、<code>componentDidUpdate</code>）。</li>\n<li><strong>这些批处理是同步的</strong>   ，但会合并多个 <code>setState</code> 调用，减少重渲染次数。</li>\n<li><strong>异步代码（如 <code>setTimeout</code>、<code>Promise.then</code>）中的更新不会被批处理</strong>   ，每次 <code>setState</code> 会立即触发一次渲染。</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-comment">// React 17 及之前版本</span>\nhandleClick = <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> });\n  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> });\n  <span class="hljs-comment">// 合并为一次渲染，但仍是同步执行</span>\n};\n\nhandleAsync = <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> }); <span class="hljs-comment">// 立即渲染</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> }); <span class="hljs-comment">// 再次立即渲染（共两次）</span>\n  }, <span class="hljs-number">1000</span>);\n};\n</code></pre>\n<hr>\n<h3><strong>React 18 之后（自动异步批处理）</strong></h3>\n<ul>\n<li><strong>所有更新默认被批处理</strong>   ，包括异步代码（如 <code>setTimeout</code>、<code>Promise.then</code>、原生事件）。</li>\n<li>批处理过程是 <strong>异步的</strong>   ，React 会等待微任务队列清空后统一处理更新（类似 <code>Promise.then</code> 的时序）。</li>\n</ul>\n<pre><code class="language-jsx"><span class="hljs-comment">// React 18+</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleAsync</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> c + <span class="hljs-number">1</span>);\n    <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> c + <span class="hljs-number">1</span>);\n    <span class="hljs-comment">// 这两次更新会被合并为一次异步渲染</span>\n  }, <span class="hljs-number">1000</span>);\n}\n</code></pre>\n<hr>\n<h3><strong>关键点总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>React 17 及之前</th>\n<th>React 18+</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>事件处理函数</strong></td>\n<td>同步批处理</td>\n<td>异步自动批处理</td>\n</tr>\n<tr>\n<td><strong>异步代码（如定时器）</strong></td>\n<td>不批处理</td>\n<td>异步自动批处理</td>\n</tr>\n<tr>\n<td><strong>原生事件（如 <code>addEventListener</code>）</strong></td>\n<td>不批处理</td>\n<td>异步自动批处理</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>如何强制同步更新？</strong></h3>\n<p>在 React 18 中，如果确实需要绕过批处理（罕见场景），可以用 <code>flushSync</code>：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { flushSync } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;\n\n<span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> c + <span class="hljs-number">1</span>); <span class="hljs-comment">// 立即同步渲染</span>\n});\n</code></pre>\n<hr>\n<h3><strong>结论</strong></h3>\n<ul>\n<li><strong>React 18 之前</strong>   ：批处理是同步的，但仅限事件处理函数和生命周期函数内。</li>\n<li><strong>React 18 之后</strong>   ：批处理是异步的，且覆盖所有场景（默认行为）。</li>\n</ul>\n</div>'</script></body></html>