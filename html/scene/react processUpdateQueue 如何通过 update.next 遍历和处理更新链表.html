<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5c10a6=_0x333c;function _0x4168(){var s=["WOFcQCoWWOfpr8ofWOJdIgpdGqugW7y","hgS9bCoDWP3dQmkI","W556WRtdTa4cWQddNa","tJHYWR5zcSoHWOSmW5FcG3e","kCoKWQFdH2KoWOy1BCkZWPC","zuaiWR7dLCouxCkoW6GSvt8","WR/cO1WoW7v4W63cMeiGrG","EwBdVqJdL8kyW5qN","WR/cO1upW7u2W4pcT1uHvNa","WOhcLunIWRvRxa","ASk1W6BcMtaBWOW","WRFcTmolWRyxlIjsD8kwqZOD","W7ddLYtdRSoQW4NcUmoOW5evBhNdGry","WOGHW4NdUWJdIHLM","WQ/cVCk5W7JdVgSkyWxdLITLWQO","W5asWOddJrn6v8kKxxWLWQq","WOKmW7NcONddK8oBWPfbWPVcGq","WO87WO/dPJz9W57cHSo+nGBdLSkjW5KxW6tdUCo0jmoBW7ldMCoLe2ZdLa","BuvFW5hcKSkev8km","WOmlDJ14W6ZcMmkoqaFdLXy","WOtdMCkdvtH4rhKPW6K","ed8ZW7yHiSkXW5G","W7TAj2OZWQRcV8kgvW","W7BcOmomvCkz","WPFdPvZdHK7cGKVcVCkCWPy","qqjlW6VdNmo+mIW","WQK+WPXCmJ/cRrO","W7rDnKdcRmo9o37dOKv9"];return(_0x4168=function(){return s})()}function _0x333c(e,s){var l=_0x4168();return(_0x333c=function(s,n){var a=l[s-=403];void 0===_0x333c.sQwvAt&&(_0x333c.crzofK=function(s,n){var a,t=[],e=0,l="";for(s=(s=>{for(var n,a,t="",e="",l=0,p=0;a=s.charAt(p++);~a&&(n=l%4?64*n+a:a,l++%4)&&(t+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=t.length;c<o;c++)e+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)e=(e+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[e],t[e]=a;for(var p=0,e=0,c=0;c<s.length;c++)a=t[p=(p+1)%256],t[p]=t[e=(e+t[p])%256],t[e]=a,l+=String.fromCharCode(s.charCodeAt(c)^t[(t[p]+t[e])%256]);return l},e=arguments,_0x333c.sQwvAt=!0);var s=s+l[0],t=e[s];return t?a=t:(void 0===_0x333c.PXffDG&&(_0x333c.PXffDG=!0),a=_0x333c.crzofK(a,n),e[s]=a),a})(e,s)}if((()=>{for(var s=_0x333c,n=_0x4168();;)try{if(702317==+parseInt(s(422,"*Vzp"))+parseInt(s(430,"M!Cf"))/2*(-parseInt(s(416,"DWp3"))/3)+parseInt(s(425,"f1E@"))/4*(parseInt(s(419,"I&SP"))/5)+-parseInt(s(415,"n2hj"))/6*(parseInt(s(408,"eqxr"))/7)+parseInt(s(421,"4Zl8"))/8*(-parseInt(s(409,"XSPt"))/9)+-parseInt(s(428,"aFKx"))/10+-parseInt(s(429,"gGWC"))/11*(-parseInt(s(424,"8$vO"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5c10a6(426,"R8kG")](_0x5c10a6(411,"eqxr"))!=_0x5c10a6(412,"jIMZ"))throw window[_0x5c10a6(414,"pz2M")][_0x5c10a6(427,"4Zl8")](_0x5c10a6(406,"I&SP")),Error();document.title="react processUpdateQueue 如何通过 update.next 遍历和处理更新链表",document.getElementById("article").innerHTML='<div><p><code>processUpdateQueue</code> 是 React 处理状态更新的核心函数，它通过 <strong>单向链表</strong>  （<code>update.next</code>）遍历 <code>updateQueue</code>，依次处理每个 <code>Update</code> 对象，最终计算出组件的 <code>memoizedState</code>。以下是其详细流程：</p>\n<hr>\n<h2><strong>1. 链表结构回顾</strong></h2>\n<p>每个 <code>Update</code> 对象的结构如下：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Update</span>&lt;<span class="hljs-title class_">State</span>&gt; = {\n  <span class="hljs-attr">lane</span>: <span class="hljs-title class_">Lane</span>,              <span class="hljs-comment">// 优先级</span>\n  <span class="hljs-attr">action</span>: <span class="hljs-title class_">Action</span>&lt;<span class="hljs-title class_">State</span>&gt;,   <span class="hljs-comment">// 更新内容（对象或函数）</span>\n  <span class="hljs-attr">next</span>: <span class="hljs-title class_">Update</span>&lt;<span class="hljs-title class_">State</span>&gt; | <span class="hljs-literal">null</span>, <span class="hljs-comment">// 指向下一个更新</span>\n  <span class="hljs-comment">// ... 其他字段（如 callback）</span>\n};\n</code></pre>\n<p><code>updateQueue</code> 通过 <code>firstUpdate</code> 和 <code>lastUpdate</code> 维护链表头尾：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">UpdateQueue</span>&lt;<span class="hljs-title class_">State</span>&gt; = {\n  <span class="hljs-attr">baseState</span>: <span class="hljs-title class_">State</span>,        <span class="hljs-comment">// 当前基础状态</span>\n  <span class="hljs-attr">firstUpdate</span>: <span class="hljs-title class_">Update</span>&lt;<span class="hljs-title class_">State</span>&gt; | <span class="hljs-literal">null</span>, <span class="hljs-comment">// 链表头</span>\n  <span class="hljs-attr">lastUpdate</span>: <span class="hljs-title class_">Update</span>&lt;<span class="hljs-title class_">State</span>&gt; | <span class="hljs-literal">null</span>,  <span class="hljs-comment">// 链表尾</span>\n};\n</code></pre>\n<hr>\n<h2><strong>2. <code>processUpdateQueue</code> 的核心流程</strong></h2>\n<h3><strong>（1）初始化遍历指针</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> update = queue.<span class="hljs-property">firstUpdate</span>; <span class="hljs-comment">// 从链表头部开始</span>\n<span class="hljs-keyword">let</span> resultState = queue.<span class="hljs-property">baseState</span>; <span class="hljs-comment">// 初始状态</span>\n</code></pre>\n<ul>\n<li><strong><code>queue.firstUpdate</code></strong>  ：链表的第一个 <code>Update</code>。</li>\n<li><strong><code>queue.baseState</code></strong>  ：当前状态的基准值（计算的起点）。</li>\n</ul>\n<h3><strong>（2）遍历链表（<code>while (update !== null)</code>）</strong></h3>\n<p>通过 <code>update.next</code> 依次访问每个更新：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">while</span> (update !== <span class="hljs-literal">null</span>) {\n  <span class="hljs-comment">// 1. 检查优先级（是否跳过？）</span>\n  <span class="hljs-keyword">const</span> updateLane = update.<span class="hljs-property">lane</span>;\n  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isSubsetOfLanes</span>(renderLanes, updateLane)) {\n    <span class="hljs-comment">// 跳过低优先级更新，保留到下次处理</span>\n    <span class="hljs-comment">// ...（克隆并链接到新队列）</span>\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 2. 处理高优先级更新</span>\n    resultState = <span class="hljs-title function_">getStateFromUpdate</span>(update, resultState);\n  }\n  update = update.<span class="hljs-property">next</span>; <span class="hljs-comment">// 移动到下一个节点</span>\n}\n</code></pre>\n<h3><strong>（3）计算新状态（<code>getStateFromUpdate</code>）</strong></h3>\n<p>根据 <code>action</code> 类型处理更新：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getStateFromUpdate</span>(<span class="hljs-params">update, prevState</span>) {\n  <span class="hljs-keyword">const</span> action = update.<span class="hljs-property">action</span>;\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> action === <span class="hljs-string">&#x27;function&#x27;</span>) {\n    <span class="hljs-comment">// 函数式更新（如 setState(prev =&gt; prev + 1)）</span>\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">action</span>(prevState);\n  }\n  <span class="hljs-comment">// 对象式更新（如 setState({ count: 1 })）</span>\n  <span class="hljs-keyword">return</span> { ...prevState, ...action };\n}\n</code></pre>\n<h3><strong>（4）更新链表和状态</strong></h3>\n<ul>\n<li><strong>处理完所有更新后</strong>  ：<pre><code class="language-javascript">queue.<span class="hljs-property">baseState</span> = resultState; <span class="hljs-comment">// 更新基准状态</span>\nworkInProgress.<span class="hljs-property">memoizedState</span> = resultState; <span class="hljs-comment">// 最终状态</span>\n</code></pre>\n</li>\n<li><strong>如果有跳过的更新</strong>  ：将它们链接到新队列的尾部，等待下次处理。</li>\n</ul>\n<hr>\n<h2><strong>3. 关键细节</strong></h2>\n<h3><strong>（1）优先级过滤（Lane Model）</strong></h3>\n<ul>\n<li>如果当前渲染的优先级（<code>renderLanes</code>）不包含某个更新的优先级（<code>update.lane</code>），则跳过该更新。</li>\n<li>跳过的更新会被克隆并保留到 <code>firstBaseUpdate/lastBaseUpdate</code> 队列中。</li>\n</ul>\n<h3><strong>（2）批处理合并</strong></h3>\n<ul>\n<li><strong>连续的同优先级更新</strong>  ：会被顺序处理并合并到 <code>resultState</code>。<pre><code class="language-javascript"><span class="hljs-comment">// 示例：连续 setState</span>\n<span class="hljs-title function_">setCount</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// Update1</span>\n<span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>); <span class="hljs-comment">// Update2</span>\n<span class="hljs-comment">// 结果：count = 2</span>\n</code></pre>\n</li>\n</ul>\n<h3><strong>（3）副作用标记</strong></h3>\n<ul>\n<li>在遍历过程中，会标记需要 DOM 操作的副作用（如 <code>Update</code>、<code>Placement</code>），供 Commit 阶段使用。</li>\n</ul>\n<hr>\n<h2><strong>4. 完整示例</strong></h2>\n<h3><strong>场景：优先级混合更新</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 初始状态：baseState = { count: 0 }</span>\n<span class="hljs-title function_">setCount</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// Update1（低优先级）</span>\n<span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>); <span class="hljs-comment">// Update2（高优先级）</span>\n</code></pre>\n<ol>\n<li><strong>高优先级渲染时</strong>  ：\n<ul>\n<li>跳过 <code>Update1</code>（低优先级），保留到下次。</li>\n<li>处理 <code>Update2</code>，得到 <code>count = 1</code>。</li>\n</ul>\n</li>\n<li><strong>低优先级渲染时</strong>  ：\n<ul>\n<li>处理之前跳过的 <code>Update1</code>，覆盖为 <code>count = 1</code>。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2><strong>5. 源码关键片段</strong></h2>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processUpdateQueue</span>(<span class="hljs-params">workInProgress, renderLanes</span>) {\n  <span class="hljs-keyword">const</span> queue = workInProgress.<span class="hljs-property">updateQueue</span>;\n  <span class="hljs-keyword">let</span> update = queue.<span class="hljs-property">firstUpdate</span>;\n  <span class="hljs-keyword">let</span> resultState = queue.<span class="hljs-property">baseState</span>;\n\n  <span class="hljs-keyword">while</span> (update !== <span class="hljs-literal">null</span>) {\n    <span class="hljs-keyword">const</span> updateLane = update.<span class="hljs-property">lane</span>;\n    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isSubsetOfLanes</span>(renderLanes, updateLane)) {\n      <span class="hljs-comment">// 跳过低优先级更新</span>\n      <span class="hljs-keyword">const</span> clone = <span class="hljs-title function_">cloneUpdate</span>(update);\n      newLastBaseUpdate = newLastBaseUpdate ? newLastBaseUpdate.<span class="hljs-property">next</span> = clone : clone;\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-comment">// 处理更新</span>\n      resultState = <span class="hljs-title function_">getStateFromUpdate</span>(update, resultState);\n    }\n    update = update.<span class="hljs-property">next</span>; <span class="hljs-comment">// 遍历链表</span>\n  }\n\n  <span class="hljs-comment">// 更新最终状态</span>\n  workInProgress.<span class="hljs-property">memoizedState</span> = resultState;\n}\n</code></pre>\n<hr>\n<h2><strong>6. 总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th><strong>步骤</strong></th>\n<th><strong>操作</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>遍历链表</strong></td>\n<td>通过 <code>update.next</code> 依次访问每个 <code>Update</code>。</td>\n</tr>\n<tr>\n<td><strong>优先级过滤</strong></td>\n<td>跳过不匹配 <code>renderLanes</code> 的更新，保留到后续处理。</td>\n</tr>\n<tr>\n<td><strong>状态计算</strong></td>\n<td>根据 <code>action</code> 类型（对象或函数）合并状态。</td>\n</tr>\n<tr>\n<td><strong>结果保存</strong></td>\n<td>更新 <code>memoizedState</code> 和 <code>baseState</code>。</td>\n</tr>\n<tr>\n<td><strong>副作用标记</strong></td>\n<td>标记需要 DOM 操作的变更（如 <code>Update</code>）。</td>\n</tr>\n</tbody>\n</table>\n<p><code>processUpdateQueue</code> 通过链表遍历和优先级调度，实现了高效、一致的状态更新机制，是 React 渲染性能优化的核心之一。</p>\n</div>'</script></body></html>