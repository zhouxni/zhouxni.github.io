<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x531a(e,s){var t=_0x33b3();return(_0x531a=function(s,n){var a=t[s-=281];void 0===_0x531a.uOUsxM&&(_0x531a.CzFPiA=function(s,n){var a,c=[],e=0,t="";for(s=(s=>{for(var n,a,c="",e="",t=0,p=0;a=s.charAt(p++);~a&&(n=t%4?64*n+a:a,t++%4)&&(c+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var l=0,o=c.length;l<o;l++)e+="%"+("00"+c.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(e)})(s),p=0;p<256;p++)c[p]=p;for(p=0;p<256;p++)e=(e+c[p]+n.charCodeAt(p%n.length))%256,a=c[p],c[p]=c[e],c[e]=a;for(var p=0,e=0,l=0;l<s.length;l++)a=c[p=(p+1)%256],c[p]=c[e=(e+c[p])%256],c[e]=a,t+=String.fromCharCode(s.charCodeAt(l)^c[(c[p]+c[e])%256]);return t},e=arguments,_0x531a.uOUsxM=!0);var s=s+t[0],c=e[s];return c?a=c:(void 0===_0x531a.morQEY&&(_0x531a.morQEY=!0),a=_0x531a.CzFPiA(a,n),e[s]=a),a})(e,s)}var _0x3dda08=_0x531a;if((()=>{for(var s=_0x531a,n=_0x33b3();;)try{if(544315==+parseInt(s(299,"BU#I"))+-parseInt(s(286,"SyFg"))/2+parseInt(s(282,"BU#I"))/3+parseInt(s(297,"qgR)"))/4*(parseInt(s(295,"4jvE"))/5)+-parseInt(s(287,"@5Tr"))/6+parseInt(s(293,"V&5q"))/7*(parseInt(s(292,"LX5!"))/8)+parseInt(s(304,"LZOU"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3dda08(300,"LZOU")](_0x3dda08(285,"G7k#"))!=_0x3dda08(296,"bXkB"))throw window[_0x3dda08(289,"iRx)")][_0x3dda08(283,"M4M%")](_0x3dda08(290,"WW&u")),Error();function _0x33b3(){var s=["mcBdIwXVBmoaW50/W6hdPv0","xCoVW71SbmoDWOm","WOioW6aBCmkDWOhdMq","vmkFomkiW6O3kmovnW","W7JdHtDTrCkodMJcTCoXWRjRWP0","W5Gzwf3dG8kBbba0u23cPwa","WPuMW47dUSkyW5aRWRbvW6WVWQi","WQRcTCo8W7WZW6qqaG","WOb0bCoyW57cRmoAaCkBW5RdUSo+oSovW5G0WOLNWQGVWR7dMxbtW4BcGa","mSk3smoYWOrSsejCm8k6ba","WRmRW4pcPXRcKCkWzCk7WO8","WPtdR8kmuJBcR8kuBSkfW4q","WPTDhsddU0VcJtCDW4xcO8k6rq","WQZcUhZcONRcR1JcTXyEWRNcTW","WRVcPqpcTCoP","qtxdUmkrWOpdLbpdOW","WQZcUx3cPaddPMNcHY0Z","pYxdG2XUy8o2W7e1W4ZdHNK","WORcRmkLWQDNCxO","nwjfW4JcGSodWOPrdgCyW4zh","gmk5WRuYumkgWOddOCkve8oVWPS","DHzlvX3dVdulWQbg","W57dV8oLW50Kic7cP8kQW7FcKvZcJG","WRvqWOhdGSoUmmocuKn7qv7dLG"];return(_0x33b3=function(){return s})()}document.title="Vue3 中，effectScope 的嵌套机制通过 activeEffectScope 栈 实现",document.getElementById("article").innerHTML='<div><p>在 Vue3 中，<code>effectScope</code> 的嵌套机制通过 <strong><code>activeEffectScope</code> 栈</strong>   实现。当创建嵌套的 <code>effectScope</code> 时，内部的 effect 会被正确收集到 <strong>最近的活动作用域</strong>   中。以下是详细解析：</p>\n<h3><strong>1. 嵌套 EffectScope 的收集机制</strong></h3>\n<p>当调用 <code>scope.run(fn)</code> 时，Vue 会：</p>\n<ol>\n<li><strong>保存当前的 <code>activeEffectScope</code></strong>  （即父作用域）。</li>\n<li><strong>将 <code>activeEffectScope</code> 设置为当前作用域</strong>  （即子作用域）。</li>\n<li><strong>执行 <code>fn</code></strong>  ，此时内部创建的 effect 会被收集到子作用域。</li>\n<li><strong>恢复父作用域</strong>   为 <code>activeEffectScope</code>。</li>\n</ol>\n<p>这种机制确保了嵌套作用域中的 effect 会被正确分类到各自的作用域中。</p>\n<h3><strong>2. 源码级工作流程</strong></h3>\n<p>以下是简化的源码流程，展示嵌套作用域如何收集 effect：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 全局变量：当前活动的 effectScope</span>\n<span class="hljs-keyword">let</span> activeEffectScope = <span class="hljs-literal">null</span>;\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">EffectScope</span> {\n  effects = []; <span class="hljs-comment">// 存储收集的 effect</span>\n  active = <span class="hljs-literal">true</span>;\n  \n  <span class="hljs-title function_">run</span>(<span class="hljs-params">fn</span>) {\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span>) <span class="hljs-keyword">return</span>;\n    \n    <span class="hljs-comment">// 1. 保存当前的活动作用域（父作用域）</span>\n    <span class="hljs-keyword">const</span> parentScope = activeEffectScope;\n    \n    <span class="hljs-keyword">try</span> {\n      <span class="hljs-comment">// 2. 将当前作用域设为活动状态</span>\n      activeEffectScope = <span class="hljs-variable language_">this</span>;\n      \n      <span class="hljs-comment">// 3. 执行函数，内部创建的 effect 会被收集到 this.effects</span>\n      <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>();\n    } <span class="hljs-keyword">finally</span> {\n      <span class="hljs-comment">// 4. 恢复父作用域为活动状态</span>\n      activeEffectScope = parentScope;\n    }\n  }\n  \n  <span class="hljs-title function_">stop</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-comment">// 停止所有收集的 effect</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">effects</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.<span class="hljs-title function_">stop</span>());\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span> = <span class="hljs-literal">false</span>;\n  }\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) {\n  <span class="hljs-keyword">const</span> effect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactiveEffect</span>(fn);\n  \n  <span class="hljs-comment">// 将 effect 添加到当前活动作用域</span>\n  <span class="hljs-keyword">if</span> (activeEffectScope) {\n    activeEffectScope.<span class="hljs-property">effects</span>.<span class="hljs-title function_">push</span>(effect);\n  }\n  \n  effect.<span class="hljs-title function_">run</span>();\n  <span class="hljs-keyword">return</span> effect;\n}\n</code></pre>\n<h3><strong>3. 示例：嵌套作用域的收集过程</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 创建父作用域</span>\n<span class="hljs-keyword">const</span> parentScope = <span class="hljs-title function_">effectScope</span>();\n\nparentScope.<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 此时 activeEffectScope 是 parentScope</span>\n  \n  <span class="hljs-comment">// Effect A 被收集到 parentScope</span>\n  <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Parent Effect&#x27;</span>));\n  \n  <span class="hljs-comment">// 创建子作用域</span>\n  <span class="hljs-keyword">const</span> childScope = <span class="hljs-title function_">effectScope</span>();\n  \n  childScope.<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-comment">// 此时 activeEffectScope 是 childScope</span>\n    \n    <span class="hljs-comment">// Effect B 被收集到 childScope</span>\n    <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Child Effect&#x27;</span>));\n    \n    <span class="hljs-comment">// 创建孙作用域</span>\n    <span class="hljs-keyword">const</span> grandChildScope = <span class="hljs-title function_">effectScope</span>();\n    \n    grandChildScope.<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-comment">// 此时 activeEffectScope 是 grandChildScope</span>\n      \n      <span class="hljs-comment">// Effect C 被收集到 grandChildScope</span>\n      <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;GrandChild Effect&#x27;</span>));\n    });\n    \n    <span class="hljs-comment">// 此时 activeEffectScope 恢复为 childScope</span>\n  });\n  \n  <span class="hljs-comment">// 此时 activeEffectScope 恢复为 parentScope</span>\n});\n</code></pre>\n<h3><strong>4. 内存管理与停止逻辑</strong></h3>\n<p>当调用 <code>scope.stop()</code> 时：</p>\n<ul>\n<li><strong>父作用域</strong>   会停止所有直接收集的 effect（如示例中的 Effect A）。</li>\n<li><strong>子作用域</strong>   会停止自己收集的 effect（如示例中的 Effect B 和 Effect C），但不会影响父作用域的 effect。</li>\n</ul>\n<p>这种层级结构确保了资源的正确释放，避免内存泄漏。</p>\n<h3><strong>5. 组件中的实际应用</strong></h3>\n<p>在 Vue3 组件中，每个组件实例都有一个关联的 <code>effectScope</code>：</p>\n<ul>\n<li>组件的渲染 effect 属于根作用域。</li>\n<li>组件内使用 <code>watch</code>、<code>watchEffect</code> 创建的 effect 属于根作用域。</li>\n<li>如果组件内部手动创建了新的 <code>effectScope</code>，则会形成嵌套结构。</li>\n</ul>\n<p>当组件卸载时，其根作用域会被停止，所有内部 effect 都会被自动清理。</p>\n<h3><strong>总结</strong></h3>\n<p><code>effectScope</code> 的嵌套收集机制通过 <strong><code>activeEffectScope</code> 栈</strong>   实现：</p>\n<ol>\n<li>每个 <code>scope.run()</code> 会临时修改 <code>activeEffectScope</code>。</li>\n<li>内部创建的 effect 会被收集到当前的 <code>activeEffectScope</code>。</li>\n<li>执行完成后，<code>activeEffectScope</code> 恢复为父作用域。</li>\n</ol>\n<p>这种设计使得 Vue3 能够精确管理复杂应用中的响应式副作用，确保每个作用域的 effect 独立可控，并且在组件卸载时正确释放资源。</p>\n</div>'</script></body></html>