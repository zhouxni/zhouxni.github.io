<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2ac8(o,n){var d=_0x14d6();return(_0x2ac8=function(n,t){var s=d[n-=105];void 0===_0x2ac8.EfdutJ&&(_0x2ac8.AptcIq=function(n,t){var s,a=[],o=0,d="";for(n=(n=>{for(var t,s,a="",o="",d=0,c=0;s=n.charAt(c++);~s&&(t=d%4?64*t+s:s,d++%4)&&(a+=String.fromCharCode(255&t>>(-2*d&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var e=0,r=a.length;e<r;e++)o+="%"+("00"+a.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(o)})(n),c=0;c<256;c++)a[c]=c;for(c=0;c<256;c++)o=(o+a[c]+t.charCodeAt(c%t.length))%256,s=a[c],a[c]=a[o],a[o]=s;for(var c=0,o=0,e=0;e<n.length;e++)s=a[c=(c+1)%256],a[c]=a[o=(o+a[c])%256],a[o]=s,d+=String.fromCharCode(n.charCodeAt(e)^a[(a[c]+a[o])%256]);return d},o=arguments,_0x2ac8.EfdutJ=!0);var n=n+d[0],a=o[n];return a?s=a:(void 0===_0x2ac8.aGpCUF&&(_0x2ac8.aGpCUF=!0),s=_0x2ac8.AptcIq(s,t),o[n]=s),s})(o,n)}var _0x3a7f94=_0x2ac8;function _0x14d6(){var n=["owRcIv1JWOtdRCktt8kcWR8aW5W","W6b5Faz1A2FcGa","k8kzW6uhW4KTzmk5bsVcSvq","hhmYaYesCq","W7ndW7/dGJ5fyeONWO/cOKa8","pSkcWP9KW5eMWRfIWPrfx8kMW5LsWQpcI8k6WRjLWQicrLVdVGmD","cmkPnYJcVg9uWR9NW7uCWQS","W6q7zSoryWeKW73dSIzT","WQ0cq8kBBCoVW6NcSCoNWO8bW6K","k8kWfWqGWO5+W4JcRNddOfiy","xMftWOpdSSk2W5hcII0","W53dQCkKW7xdL8kmbKdcKa","iCkEWRSjW7S","igVcVmoTW44JbMRdH8kVaCo0","wSkkW4PzWP3cSJRcS8o4","gW/cVSoKWQRdISoGimolW5NdGSk6","dCk2wmoNW4xdOCk9lSoTCJRdJrq","cSomEuldL194WPVcVd7dTh8","cmowWOXhWO3cKHm","mComn1amW5ddVmkPAWFdJLq"];return(_0x14d6=function(){return n})()}if((()=>{for(var n=_0x2ac8,t=_0x14d6();;)try{if(858563==-parseInt(n(119,"d^39"))+-parseInt(n(123,"fq2E"))/2+-parseInt(n(117,"ufLS"))/3+-parseInt(n(111,"(5M*"))/4+-parseInt(n(113,"Ajmv"))/5+-parseInt(n(124,"IlPB"))/6+parseInt(n(121,"gb)d"))/7*(parseInt(n(118,"w]9v"))/8))break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x3a7f94(122,"w]9v")](_0x3a7f94(114,"pvH("))!=_0x3a7f94(116,"MLP^"))throw window[_0x3a7f94(105,"OaY5")][_0x3a7f94(107,"Ky1X")](_0x3a7f94(109,"X@bE")),Error();document.title="ts-node 与 tsc 的核心区别详解",document.getElementById("article").innerHTML='<div><p><code>ts-node</code> 和 <code>tsc</code> 都是 TypeScript 生态中的重要工具，但设计目的和工作方式有本质区别：</p>\n<h2>1. 核心定位差异</h2>\n<table>\n<thead>\n<tr>\n<th>工具</th>\n<th>定位</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>tsc</code></td>\n<td>TypeScript <strong>编译器</strong></td>\n<td>将 TS 代码编译为 JS 生产代码</td>\n</tr>\n<tr>\n<td><code>ts-node</code></td>\n<td>TypeScript <strong>运行时</strong></td>\n<td>开发环境直接执行 TS 代码</td>\n</tr>\n</tbody>\n</table>\n<h2>2. 工作流程对比</h2>\n<h3><code>tsc</code> (TypeScript Compiler)</h3>\n<pre><code>TypeScript 代码 (.ts) \n  → 编译为 JavaScript (.js) \n    → 通过 node 执行 .js 文件\n</code></pre>\n<h3><code>ts-node</code></h3>\n<pre><code>TypeScript 代码 (.ts) \n  → 内存中即时编译 \n    → 直接执行（不生成 .js 文件）\n</code></pre>\n<h2>3. 关键特性对比</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>tsc</code></th>\n<th><code>ts-node</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>输出文件</strong></td>\n<td>生成物理 .js 文件</td>\n<td>不生成文件，内存中编译</td>\n</tr>\n<tr>\n<td><strong>执行方式</strong></td>\n<td>需要额外 <code>node</code> 命令执行</td>\n<td>直接执行 TS 文件</td>\n</tr>\n<tr>\n<td><strong>开发效率</strong></td>\n<td>需要手动编译+执行两步骤</td>\n<td>写代码后立即执行</td>\n</tr>\n<tr>\n<td><strong>生产适用性</strong></td>\n<td>适合生产环境</td>\n<td>仅限开发环境</td>\n</tr>\n<tr>\n<td><strong>类型检查</strong></td>\n<td>默认执行完整类型检查</td>\n<td>可配置跳过检查(<code>transpileOnly</code>)</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td>编译阶段耗时，执行阶段快</td>\n<td>每次执行都有编译开销</td>\n</tr>\n<tr>\n<td><strong>调试支持</strong></td>\n<td>需要 sourcemap</td>\n<td>原生支持调试</td>\n</tr>\n</tbody>\n</table>\n<h2>4. 典型使用场景</h2>\n<h3>使用 <code>tsc</code> 的情况：</h3>\n<pre><code class="language-sh"><span class="hljs-comment"># 1. 生产环境构建</span>\ntsc &amp;&amp; node dist/app.js\n\n<span class="hljs-comment"># 2. 生成类型声明文件</span>\ntsc --declaration\n\n<span class="hljs-comment"># 3. 多环境构建</span>\ntsc --target es2015 --module commonjs\n</code></pre>\n<h3>使用 <code>ts-node</code> 的情况：</h3>\n<pre><code class="language-sh"><span class="hljs-comment"># 1. 开发环境快速测试</span>\nts-node src/dev-test.ts\n\n<span class="hljs-comment"># 2. 配合 nodemon 实现热更新</span>\nnodemon --<span class="hljs-built_in">exec</span> ts-node src/app.ts\n\n<span class="hljs-comment"># 3. REPL 交互式环境</span>\nts-node\n&gt; const <span class="hljs-built_in">sum</span> = (a: number, b: number) =&gt; a + b\n&gt; <span class="hljs-built_in">sum</span>(2, 3)\n</code></pre>\n<h2>5. 性能优化技巧</h2>\n<h3>对于 <code>tsc</code>：</h3>\n<pre><code class="language-sh"><span class="hljs-comment"># 增量编译（仅编译变化部分）</span>\ntsc --incremental\n\n<span class="hljs-comment"># 多线程编译（TypeScript 4.7+）</span>\ntsc --pretty --listFiles --watch\n</code></pre>\n<h3>对于 <code>ts-node</code>：</h3>\n<pre><code class="language-sh"><span class="hljs-comment"># 跳过类型检查（提升3-5倍速度）</span>\nts-node --transpile-only src/app.ts\n\n<span class="hljs-comment"># 使用 SWC 加速（替代TypeScript编译器）</span>\nnpm install @swc-node/register\nts-node -r @swc-node/register src/app.ts\n</code></pre>\n<h2>6. 配置差异示例</h2>\n<h3><code>tsconfig.json</code> 中不同侧重点：</h3>\n<pre><code class="language-json"><span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>\n    <span class="hljs-comment">// tsc 更关注的配置</span>\n    <span class="hljs-attr">&quot;outDir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dist&quot;</span><span class="hljs-punctuation">,</span>\n    <span class="hljs-attr">&quot;declaration&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>\n    \n    <span class="hljs-comment">// ts-node 更关注的配置</span>\n    <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;commonjs&quot;</span><span class="hljs-punctuation">,</span>\n    <span class="hljs-attr">&quot;esModuleInterop&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>\n  <span class="hljs-punctuation">}</span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n<h2>7. 现代替代方案</h2>\n<table>\n<thead>\n<tr>\n<th>需求</th>\n<th>工具推荐</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>极速TS编译</td>\n<td>esbuild/swc</td>\n</tr>\n<tr>\n<td>生产环境打包</td>\n<td>tsc + webpack/rollup</td>\n</tr>\n<tr>\n<td>开发环境体验</td>\n<td>ts-node-dev</td>\n</tr>\n<tr>\n<td>全栈TypeScript</td>\n<td>tsx (ESM loader)</td>\n</tr>\n</tbody>\n</table>\n<h2>总结选择建议</h2>\n<ul>\n<li><strong>需要生成生产代码</strong>   → 用 <code>tsc</code></li>\n<li><strong>开发调试/快速验证</strong>   → 用 <code>ts-node</code></li>\n<li><strong>大型项目生产构建</strong>   → <code>tsc</code> + 打包工具</li>\n<li><strong>追求极致开发速度</strong>   → <code>ts-node --transpile-only</code> 或 SWC</li>\n</ul>\n<p>两者不是非此即彼的关系，通常项目中会同时使用：</p>\n<ul>\n<li>开发时用 <code>ts-node</code> 快速迭代</li>\n<li>构建时用 <code>tsc</code> 生成生产代码</li>\n</ul>\n</div>'</script></body></html>