<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2424(t,s){var e=_0x4921();return(_0x2424=function(s,n){var a=e[s-=229];void 0===_0x2424.YEHWnS&&(_0x2424.nfcpFy=function(s,n){var a,o=[],t=0,e="";for(s=(s=>{for(var n,a,o="",t="",e=0,r=0;a=s.charAt(r++);~a&&(n=e%4?64*n+a:a,e++%4)&&(o+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var l=0,d=o.length;l<d;l++)t+="%"+("00"+o.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(t)})(s),r=0;r<256;r++)o[r]=r;for(r=0;r<256;r++)t=(t+o[r]+n.charCodeAt(r%n.length))%256,a=o[r],o[r]=o[t],o[t]=a;for(var r=0,t=0,l=0;l<s.length;l++)a=o[r=(r+1)%256],o[r]=o[t=(t+o[r])%256],o[t]=a,e+=String.fromCharCode(s.charCodeAt(l)^o[(o[r]+o[t])%256]);return e},t=arguments,_0x2424.YEHWnS=!0);var s=s+e[0],o=t[s];return o?a=o:(void 0===_0x2424.sIObwz&&(_0x2424.sIObwz=!0),a=_0x2424.nfcpFy(a,n),t[s]=a),a})(t,s)}var _0x9f6b76=_0x2424;function _0x4921(){var s=["WOZcMCokECkJl2GMyHi","W5lcPSk8W4KGEZlcU0y0W7hdUq","aa56WQbXsYf9EG","wLtdUJ7dISoufCk2oSkdfKSWja","vJKSW489W4XYvdBdKq","o2dcSCovW6uHfmoKA8kBW5y","WQvaWRdcUmkBawhdLuCbk2JcLW","CKf2WP1Cv8ohbCkHyq","urWPiqPLWPKCymkMWOhcGG","WRNdHKnhbmkUW64","rCk7wM3dQq","DSk6W6fsv8k6nmo6WRFdQSo5Fwy","WP0MWRldQCkgg8k3W4iqvq","vXvxAMqLWPqt","W55OWRuOWP/dKSoaW5GBfGS","fW/dScu8AxyZkSkrDspdPq","z8ojWOtdKqyEWONcRq","BmohvMDBW53dHSo+emodhf0","WRRcVWibiCkBW67dLd7dNa","zSklWPW/CuyZ","pmowpCkVq8o4zZ/dVCkyWPfIWQKeWQzIW6JdVfdcUuNdTGpcLmkrzq","vmo8W7mHW6VcUCoO","jCoEW5XRiHjUWQPuWPnsCZddPW","oM/cVhL1rMbuW6HdW6am","ymksb8kSz8k1exi","WOtdTmoXWRjMjJu","rCkcW7xdOrDkecHVW5i","BCkrECoOa8o6EhNdQmkCWO5HWOK"];return(_0x4921=function(){return s})()}if((()=>{for(var s=_0x2424,n=_0x4921();;)try{if(879178==-parseInt(s(248,"[@Dy"))*(-parseInt(s(249,"^NRq"))/2)+-parseInt(s(251,"T!#@"))/3+-parseInt(s(241,"mYdj"))/4*(parseInt(s(236,"qf9e"))/5)+parseInt(s(255,"mQJ["))/6+-parseInt(s(243,"DQOP"))/7+parseInt(s(240,"4OAP"))/8*(parseInt(s(247,"gwBg"))/9)+-parseInt(s(238,"Zpnk"))/10*(-parseInt(s(245,"*N[)"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x9f6b76(237,"mYdj")](_0x9f6b76(242,"cyRC"))!=_0x9f6b76(250,"*V^^"))throw window[_0x9f6b76(256,"UFSW")][_0x9f6b76(231,"e$Tf")](_0x9f6b76(232,"qf9e")),Error();document.title="CommonJS 的模块系统在语法和语义上都是“动态”的",document.getElementById("article").innerHTML='<div><p>一句话先回答：<strong>CommonJS 的模块系统在语法和语义上都是“动态”的，打包器无法在构建阶段静态地知道谁被用到、谁没被用到，因此无法做 tree-shaking。</strong></p>\n<hr>\n<h3>1. 语法层面：只能拿到“整个 <code>module.exports</code> 对象”</h3>\n<pre><code class="language-js"><span class="hljs-comment">// math.js (CommonJS)</span>\n<span class="hljs-built_in">exports</span>.<span class="hljs-property">add</span> = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;\n<span class="hljs-built_in">exports</span>.<span class="hljs-property">sub</span> = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b;\n</code></pre>\n<pre><code class="language-js"><span class="hljs-comment">// main.js</span>\n<span class="hljs-keyword">const</span> math = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./math.js&quot;</span>); <span class="hljs-comment">// 只能拿到整个对象</span>\nmath.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);\n</code></pre>\n<ul>\n<li>这里的 <code>require</code> <strong>返回一个对象</strong>   ，打包器看到的是<br>\n“你需要整个 <code>math.js</code> 产生的对象”，<strong>区分不出</strong>   你只用到 <code>add</code> 而没用到 <code>sub</code>。</li>\n<li>因此 <code>sub</code> 会被完整保留，无法被摇掉。</li>\n</ul>\n<hr>\n<h3>2. 语义层面：运行时可随意修改导出</h3>\n<pre><code class="language-js"><span class="hljs-comment">// math.js</span>\n<span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span>) {\n  <span class="hljs-built_in">exports</span>.<span class="hljs-property">add</span> = <span class="hljs-function">() =&gt;</span> {}; <span class="hljs-comment">// 运行时才决定导出了什么</span>\n}\n</code></pre>\n<ul>\n<li>CommonJS 的 <code>exports</code> 是一个<strong>可变对象</strong>   ，运行期间随时可以增删属性。</li>\n<li>这种<strong>动态可变性</strong>   让静态分析彻底失效：<br>\n打包器永远无法 100 % 确定某个属性“肯定不会被用到”。</li>\n</ul>\n<hr>\n<h3>3. 对比 ES Module：静态语法 + 不可变绑定</h3>\n<pre><code class="language-js"><span class="hljs-comment">// math.mjs</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">sub</span> = (<span class="hljs-params">a, b</span>) =&gt; a - b;\n</code></pre>\n<pre><code class="language-js"><span class="hljs-comment">// main.mjs</span>\n<span class="hljs-keyword">import</span> { add } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./math.mjs&quot;</span>;\n</code></pre>\n<ul>\n<li>ES Module 的 <code>import/export</code> 语法是<strong>静态声明</strong>   ，位置必须在顶层，且不能动态增删。</li>\n<li>每个导出都是一个<strong>只读绑定</strong>   （live binding），打包器可以在构建时明确知道 “只用到了 <code>add</code>”。</li>\n<li>因此未用到的 <code>sub</code> 可以安全地被 tree-shaking 掉。</li>\n</ul>\n<hr>\n<h3>4. 小结表格</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>CommonJS</th>\n<th>ES Module</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>导出形式</td>\n<td>一个可变的 <code>module.exports</code> 对象</td>\n<td>静态、不可变的绑定</td>\n</tr>\n<tr>\n<td>导入形式</td>\n<td>运行时 <code>require()</code> 返回整个对象</td>\n<td>静态 <code>import { x }</code> 只引入所需</td>\n</tr>\n<tr>\n<td>可否静态分析</td>\n<td>❌ 无法</td>\n<td>✅ 可以</td>\n</tr>\n<tr>\n<td>Tree shaking</td>\n<td>❌ 不支持</td>\n<td>✅ 支持</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>5. 动态 import 的特殊场景</h3>\n<pre><code class="language-js"><span class="hljs-comment">// 动态 import 一个 CommonJS 模块</span>\n<span class="hljs-keyword">const</span> mod = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./cjs-module.cjs&quot;</span>);\n</code></pre>\n<ul>\n<li>即使使用了 <code>import()</code>，得到的仍然是<strong>一个包裹着 <code>module.exports</code> 的命名空间对象</strong>   。</li>\n<li>打包器依旧无法区分你只用到了其中哪个属性，<strong>tree-shaking 仍然失效</strong>   。</li>\n</ul>\n<hr>\n<h3>结论</h3>\n<p>CommonJS 的“动态对象 + 运行时修改”这两个设计特征，决定了它在任何情况下都无法像 ES Module 那样被静态分析，因此<strong>无法做 tree-shaking</strong>   。</p>\n</div>'</script></body></html>