<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1b6177=_0x4213;function _0x30bb(){var s=["zIVcPJpdPmovW5VcQCoNoaBdRgDzbCkMWRJdItldQYzhd0O3WRC","WQXoWOj8W5engW","lSoxW4ZcVKbGWQRdGCovWQ0Z","zCkqfJZdQSovWPNcICkfESkXW60a","WRdcT3rlWOtdRbKGWQq","fCkxpCk+WQe0WRSIB8oSFSkj","WQKDW5qiWPnLAWuEWRiViSo2eW","BSozWQ5aW5/cJfmqW43cKq","EepdI8oDW5XQBXq","j8oMnu7dVSkTW4S","ibVcNSkmW717BYldUCoJ","hSoeWQ1qDhldPa","C0KilaZdMSooW47cV8oIW5hcK2WK","imoLigBdJSkKW5u","mcTGvmkHz8ojC8k/FsH8zG","W4RcQJHwiJqlWPnc","yCoxWPhdHJRcImoVWQhcHSoWW7FdSea","vSoxFSo+W6e","W4TvWRalz8oNiq","C8oawYtdGfHymcBcKmkjBW","W5aFtsPBW4zIW78PESkDWP3dVa","WRxcSNe9W4hcRuaAWQVcHWWwEW","ACotWPldHdZcGSoQWQZcPmoSW7pdOxq","W4hdGSo/WRvjwCkZWR/cPa","v1FdICkCWQxdLWi","WPiunmkcgSkcW7W8W6NdNdK","s8kzW6fnAwldVmo5rW","wvxcI13dMdnVWQ19"];return(_0x30bb=function(){return s})()}function _0x4213(e,s){var o=_0x30bb();return(_0x4213=function(s,n){var a=o[s-=256];void 0===_0x4213.WBTMcK&&(_0x4213.MUiOMW=function(s,n){var a,l=[],e=0,o="";for(s=(s=>{for(var n,a,l="",e="",o=0,t=0;a=s.charAt(t++);~a&&(n=o%4?64*n+a:a,o++%4)&&(l+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=l.length;c<r;c++)e+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)e=(e+l[t]+n.charCodeAt(t%n.length))%256,a=l[t],l[t]=l[e],l[e]=a;for(var t=0,e=0,c=0;c<s.length;c++)a=l[t=(t+1)%256],l[t]=l[e=(e+l[t])%256],l[e]=a,o+=String.fromCharCode(s.charCodeAt(c)^l[(l[t]+l[e])%256]);return o},e=arguments,_0x4213.WBTMcK=!0);var s=s+o[0],l=e[s];return l?a=l:(void 0===_0x4213.bJCxvz&&(_0x4213.bJCxvz=!0),a=_0x4213.MUiOMW(a,n),e[s]=a),a})(e,s)}if((()=>{for(var s=_0x4213,n=_0x30bb();;)try{if(747123==-parseInt(s(266,"t2Gg"))*(-parseInt(s(264,"^I$S"))/2)+parseInt(s(279,"k4X("))/3+-parseInt(s(278,"vm$A"))/4*(-parseInt(s(271,"bARH"))/5)+parseInt(s(261,"#Piw"))/6*(parseInt(s(270,"^I$S"))/7)+-parseInt(s(283,"^eVT"))/8*(-parseInt(s(274,"b1nZ"))/9)+parseInt(s(281,"sFAn"))/10+-parseInt(s(260,"RgMZ"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1b6177(259,"b1nZ")](_0x1b6177(275,"^S2q"))!=_0x1b6177(265,"sFAn"))throw window[_0x1b6177(256,"0(3p")][_0x1b6177(272,"xw$#")](_0x1b6177(276,"]]mE")),Error();document.title="如何解析⼆进制⾳频、视频",document.getElementById("article").innerHTML='<div><p>解析二进制音频和视频数据在前端开发中通常涉及多个步骤，包括获取二进制数据、解码数据以及将其渲染到页面上。以下是一个详细的解析和渲染过程：</p>\n<h3><strong>一、获取二进制音频/视频数据</strong></h3>\n<ol>\n<li><strong>通过 Fetch API</strong>  ：\n<ul>\n<li>使用 <code>fetch</code> 请求音频或视频资源，设置 <code>responseType</code> 为 <code>\'arraybuffer\'</code> 或 <code>\'blob\'</code>。</li>\n<li>示例代码：<pre><code class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;audio.wav&#x27;</span>)\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">arrayBuffer</span>())\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">buffer</span> =&gt;</span> {\n    <span class="hljs-comment">// 处理二进制音频数据</span>\n  });\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>通过 WebSocket</strong>  ：\n<ul>\n<li>如果音频或视频数据是通过 WebSocket 实时传输的，可以直接接收二进制数据（如 ArrayBuffer 或 Blob）。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>二、解析二进制音频数据</strong></h3>\n<ol>\n<li><strong>解码音频数据</strong>  ：\n<ul>\n<li>使用 <code>AudioContext</code> 解码音频数据。</li>\n<li>示例代码（假设音频格式为 WAV）：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> audioContext = <span class="hljs-keyword">new</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title class_">AudioContext</span>();\n<span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(binaryData); <span class="hljs-comment">// binaryData 是获取的二进制音频数据</span>\n<span class="hljs-keyword">const</span> offset = <span class="hljs-number">44</span>; <span class="hljs-comment">// 跳过 WAV 头部（假设前 44 字节是 WAV 头部）</span>\n<span class="hljs-keyword">const</span> pcmData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Int16Array</span>(buffer.<span class="hljs-property">buffer</span>, offset);\n\n<span class="hljs-keyword">const</span> audioBuffer = audioContext.<span class="hljs-title function_">createBuffer</span>(<span class="hljs-number">1</span>, pcmData.<span class="hljs-property">length</span>, <span class="hljs-number">44100</span>); <span class="hljs-comment">// 单声道，44100 Hz</span>\n<span class="hljs-keyword">const</span> channelData = audioBuffer.<span class="hljs-title function_">getChannelData</span>(<span class="hljs-number">0</span>);\n\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pcmData.<span class="hljs-property">length</span>; i++) {\n  channelData[i] = pcmData[i] / <span class="hljs-number">32768.0</span>; <span class="hljs-comment">// 将 PCM 数据归一化到 [-1, 1] 范围</span>\n}\n\n<span class="hljs-keyword">const</span> source = audioContext.<span class="hljs-title function_">createBufferSource</span>();\nsource.<span class="hljs-property">buffer</span> = audioBuffer;\nsource.<span class="hljs-title function_">connect</span>(audioContext.<span class="hljs-property">destination</span>);\nsource.<span class="hljs-title function_">start</span>();\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>处理不同音频格式</strong>  ：\n<ul>\n<li>如果音频格式不是 WAV，可能需要使用其他库（如 Web Audio API 的扩展库）来解码音频数据。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>三、解析二进制视频数据</strong></h3>\n<ol>\n<li><strong>使用 MediaSource API</strong>  ：\n<ul>\n<li>MediaSource API 允许你动态地构建媒体流，适用于处理流式视频数据。</li>\n<li>示例代码：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> video = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;video&#x27;</span>);\n<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(video);\n\n<span class="hljs-keyword">const</span> mediaSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MediaSource</span>();\nvideo.<span class="hljs-property">src</span> = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(mediaSource);\n\nmediaSource.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;sourceopen&#x27;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> sourceBuffer = mediaSource.<span class="hljs-title function_">addSourceBuffer</span>(<span class="hljs-string">&#x27;video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&#x27;</span>);\n\n  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;video.mp4&#x27;</span>)\n    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">arrayBuffer</span>())\n    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">buffer</span> =&gt;</span> {\n      sourceBuffer.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;updateend&#x27;</span>, <span class="hljs-function">() =&gt;</span> {\n        mediaSource.<span class="hljs-title function_">endOfStream</span>();\n        video.<span class="hljs-title function_">play</span>();\n      });\n      sourceBuffer.<span class="hljs-title function_">appendBuffer</span>(buffer);\n    });\n});\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>处理不同视频格式</strong>  ：\n<ul>\n<li>确保视频格式与 <code>addSourceBuffer</code> 方法中指定的 MIME 类型和编解码器匹配。</li>\n<li>如果需要支持多种格式，可能需要使用多个 <code>SourceBuffer</code>。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>四、渲染音频/视频到页面</strong></h3>\n<ol>\n<li><strong>音频渲染</strong>  ：\n<ul>\n<li>使用 <code>AudioContext</code> 创建 <code>AudioBufferSourceNode</code> 并连接到 <code>AudioContext.destination</code>，然后调用 <code>start()</code> 方法播放音频。</li>\n</ul>\n</li>\n<li><strong>视频渲染</strong>  ：\n<ul>\n<li>将 <code>&lt;video&gt;</code> 元素添加到页面中，并设置其 <code>src</code> 属性为 MediaSource 对象的 URL。</li>\n<li>调用 <code>video.play()</code> 方法播放视频。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>五、注意事项</strong></h3>\n<ol>\n<li><strong>跨域问题</strong>  ：\n<ul>\n<li>确保服务器设置正确的 CORS 头，允许跨域请求二进制音频/视频数据。</li>\n</ul>\n</li>\n<li><strong>性能优化</strong>  ：\n<ul>\n<li>对于大文件，考虑使用流式处理（如 <code>ReadableStream</code>）以减少内存占用。</li>\n<li>在处理音频数据时，尽量避免在主线程中进行大量计算，以免影响页面性能。</li>\n</ul>\n</li>\n<li><strong>错误处理</strong>  ：\n<ul>\n<li>处理网络请求和二进制解析时的异常，确保应用稳定性。</li>\n<li>对于音频和视频播放错误，可以监听相关事件（如 <code>error</code> 事件）并进行处理。</li>\n</ul>\n</li>\n</ol>\n</div>'</script></body></html>