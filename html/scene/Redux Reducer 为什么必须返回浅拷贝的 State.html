<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x39b46a=_0x6181;function _0x6181(t,n){var p=_0x2681();return(_0x6181=function(n,s){var a=p[n-=101];void 0===_0x6181.QusCAm&&(_0x6181.SHThPD=function(n,s){var a,e=[],t=0,p="";for(n=(n=>{for(var s,a,e="",t="",p=0,r=0;a=n.charAt(r++);~a&&(s=p%4?64*s+a:a,p++%4)&&(e+=String.fromCharCode(255&s>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var l=0,c=e.length;l<c;l++)t+="%"+("00"+e.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(t)})(n),r=0;r<256;r++)e[r]=r;for(r=0;r<256;r++)t=(t+e[r]+s.charCodeAt(r%s.length))%256,a=e[r],e[r]=e[t],e[t]=a;for(var r=0,t=0,l=0;l<n.length;l++)a=e[r=(r+1)%256],e[r]=e[t=(t+e[r])%256],e[t]=a,p+=String.fromCharCode(n.charCodeAt(l)^e[(e[r]+e[t])%256]);return p},t=arguments,_0x6181.QusCAm=!0);var n=n+p[0],e=t[n];return e?a=e:(void 0===_0x6181.cffioW&&(_0x6181.cffioW=!0),a=_0x6181.SHThPD(a,s),t[n]=a),a})(t,n)}function _0x2681(){var n=["BdbmWQddUCkmWOBcICo0W7TbxW","sCopW5mAW4SKfSkyW6NdOwpcKq","mZpdVgW0W6nOWRCmq8oouw0","smo6WR0ynWFdU8kWWQTkWRmxeG","m8o2DSkVASk6W7X2W73dNupdIG","WP7cMSkbvGjijd3dQ8o8W6hdICo1","W6ubW6FcOSobnmks","WP3dPmoka2u8uG","j8krWPJdKL9bWPm","W67dP1RcOGRdRmkUu8k9rra","WRVcSSkFhSkGWQVcQXVdVWqU","cCodW4ZcR2jhbW","WRjEBWrdWQ/dNZZdV2BdUJe","ECokW7xcJmoA","rSk0uSkjW54KnmkrpSkZlW","dCo6W5RcTeDGhW","ACoVqtizW7pdLq","W5iWm8kZaSosWRRdLSk6WQ3cIuOyW7SXF2NcTuhdHXBcJSorWOOtxa","W7zHCSoQWP7cRG7cMmkfW6JdRCobW58","WR8eWOj0WPDAmMabyqv3","eCkOW6ChxfNcRw8","oSkiWRFdJCkBmv/cUuyWECkW","aSk7WOBdUWnrmwRdVe3dOG","WPBcSqRdSe3dHCkDvmku"];return(_0x2681=function(){return n})()}if((()=>{for(var n=_0x6181,s=_0x2681();;)try{if(127475==+parseInt(n(117,"%A!8"))*(parseInt(n(104,"%A!8"))/2)+parseInt(n(103,"I7xH"))/3+parseInt(n(118,"Nf7]"))/4+-parseInt(n(101,"Po$o"))/5+-parseInt(n(121,"%A!8"))/6*(-parseInt(n(120,"GUz@"))/7)+parseInt(n(109,"&$7R"))/8+-parseInt(n(108,"r[N%"))/9)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x39b46a(122,"IRUJ")](_0x39b46a(105,"&@XH"))!=_0x39b46a(119,"I7xH"))throw window[_0x39b46a(102,"289u")][_0x39b46a(112,"jxNq")](_0x39b46a(123,"@mH(")),Error();document.title="Redux Reducer 为什么必须返回浅拷贝的 State",document.getElementById("article").innerHTML='<div><p>在 Redux 中，Reducer 必须返回一个新的状态对象（浅拷贝），而不是直接修改原 <code>state</code>。这一设计原则的核心原因如下：</p>\n<hr>\n<p><strong>1. 不可变性（Immutability）的核心要求</strong><br>\nRedux 的核心原则之一是 状态不可变（Immutable），即每次状态更新必须生成一个全新的对象。<br>\n为什么？</p>\n<ul>\n<li>\n<p>可预测性：</p>\n<p>Redux 通过比较新旧状态的引用（<code>oldState === newState</code>）来判断是否发生变化。如果直接修改原对象，引用不变，Redux 会误认为状态未更新。</p>\n</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// ❌ 错误：直接修改原 state（Redux 无法检测变化）</span>\nstate.<span class="hljs-property">value</span> = <span class="hljs-number">123</span>;\n<span class="hljs-keyword">return</span> state; <span class="hljs-comment">// 引用未变，UI 不会更新！</span>\n\n<span class="hljs-comment">// ✅ 正确：返回新对象</span>\n<span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">value</span>: <span class="hljs-number">123</span> }; <span class="hljs-comment">// 新引用触发更新</span>\n</code></pre>\n<ul>\n<li>\n<p>时间旅行调试：</p>\n<p>Redux DevTools 依赖不可变性记录状态快照，直接修改会破坏历史记录。</p>\n</li>\n</ul>\n<hr>\n<p><strong>2. 性能优化（浅比较）</strong><br>\nRedux 和 React-Redux 依赖 浅比较（Shallow Comparison） 来优化渲染性能：</p>\n<ul>\n<li><code>useSelector</code> 的默认比较逻辑：</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// React-Redux 内部逻辑</span>\n<span class="hljs-keyword">const</span> newSelectedState = <span class="hljs-title function_">selector</span>(newState);\n<span class="hljs-keyword">if</span> (newSelectedState === lastSelectedState.<span class="hljs-property">current</span>) {\n  <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 跳过组件渲染</span>\n}\n</code></pre>\n<p>如果直接修改原 <code>state</code>，引用未变，组件不会重新渲染。</p>\n<hr>\n<p><strong>3. 避免副作用（Side Effects）</strong><br>\nReducer 必须是 纯函数，即：</p>\n<ul>\n<li>\n<p>相同输入 → 相同输出。</p>\n</li>\n<li>\n<p>无副作用（不修改外部变量、不调用 API）。</p>\n</li>\n</ul>\n<p>直接修改 <code>state</code> 会引入副作用，破坏纯函数特性。</p>\n<hr>\n<p><strong>4. 如何正确返回新状态？</strong><br>\n<strong>(1) 浅拷贝（推荐）</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">key</span>: newValue }; <span class="hljs-comment">// 展开运算符（浅拷贝）</span>\n</code></pre>\n<p>适用场景：</p>\n<ul>\n<li>一级属性更新（嵌套不深时）。</li>\n</ul>\n<p><strong>(2) 深拷贝（谨慎使用）</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { cloneDeep } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;\n<span class="hljs-keyword">return</span> <span class="hljs-title function_">cloneDeep</span>(state); <span class="hljs-comment">// 深拷贝（性能较差）</span>\n</code></pre>\n<p>问题：</p>\n<ul>\n<li>\n<p>深拷贝成本高，可能引发性能问题。</p>\n</li>\n<li>\n<p>多数场景下只需更新部分数据，无需深拷贝。</p>\n</li>\n</ul>\n<p><strong>(3) 结构化拷贝（最佳实践）</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 更新嵌套属性</span>\n<span class="hljs-keyword">return</span> {\n  ...state,\n  <span class="hljs-attr">user</span>: {\n    ...state.<span class="hljs-property">user</span>,\n    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;New Name&#x27;</span>\n  }\n};\n</code></pre>\n<p>优化工具：</p>\n<ul>\n<li>使用 <code>immer</code> 简化不可变更新：</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> produce <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;immer&#x27;</span>;\n<span class="hljs-keyword">return</span> <span class="hljs-title function_">produce</span>(state, <span class="hljs-function"><span class="hljs-params">draft</span> =&gt;</span> {\n  draft.<span class="hljs-property">user</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;New Name&#x27;</span>; <span class="hljs-comment">// 直接修改 draft，但返回新对象</span>\n});\n</code></pre>\n<hr>\n<p><strong>5. 常见错误示例</strong><br>\n<strong>❌ 错误：直接修改原 state</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state, action</span>) {\n  state.<span class="hljs-property">value</span> = action.<span class="hljs-property">payload</span>; <span class="hljs-comment">// 直接修改！</span>\n  <span class="hljs-keyword">return</span> state; <span class="hljs-comment">// 引用未变，UI 不更新</span>\n}\n</code></pre>\n<p><strong>✅ 正确：返回新对象</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state, action</span>) {\n  <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">value</span>: action.<span class="hljs-property">payload</span> }; <span class="hljs-comment">// 新引用触发更新</span>\n}\n</code></pre>\n<hr>\n<p><strong>6. 为什么不是深拷贝？</strong></p>\n<ul>\n<li>\n<p>性能开销：深拷贝（如 <code>JSON.parse(JSON.stringify(state))</code>）对大型状态树效率极低。</p>\n</li>\n<li>\n<p>必要性不足：Redux 只需知道“状态是否变化”，浅拷贝足够满足需求。</p>\n</li>\n</ul>\n<hr>\n<p><strong>总结</strong></p>\n<table>\n<thead>\n<tr>\n<th>关键点</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>不可变性</td>\n<td>确保 Redux 能检测状态变化，支持时间旅行调试</td>\n</tr>\n<tr>\n<td>浅比较优化</td>\n<td>React-Redux 依赖引用比较决定是否重新渲染</td>\n</tr>\n<tr>\n<td>纯函数要求</td>\n<td>避免副作用，保证可预测性</td>\n</tr>\n<tr>\n<td>性能权衡</td>\n<td>浅拷贝平衡了不可变性和性能</td>\n</tr>\n</tbody>\n</table>\n<p>最佳实践：</p>\n<ul>\n<li>\n<p>优先使用 展开运算符（<code>...</code>）或 <code>immer</code>。</p>\n</li>\n<li>\n<p>避免直接修改 <code>state</code>，始终返回新对象。</p>\n</li>\n</ul>\n</div>'</script></body></html>