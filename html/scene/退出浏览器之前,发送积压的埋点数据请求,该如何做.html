<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2c31(c,s){var e=_0x3c8c();return(_0x2c31=function(s,n){var a=e[s-=221];void 0===_0x2c31.cJAede&&(_0x2c31.PWlSYd=function(s,n){var a,l=[],c=0,e="";for(s=(s=>{for(var n,a,l="",c="",e=0,t=0;a=s.charAt(t++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,o=l.length;p<o;p++)c+="%"+("00"+l.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(c)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)c=(c+l[t]+n.charCodeAt(t%n.length))%256,a=l[t],l[t]=l[c],l[c]=a;for(var t=0,c=0,p=0;p<s.length;p++)a=l[t=(t+1)%256],l[t]=l[c=(c+l[t])%256],l[c]=a,e+=String.fromCharCode(s.charCodeAt(p)^l[(l[t]+l[c])%256]);return e},c=arguments,_0x2c31.cJAede=!0);var s=s+e[0],l=c[s];return l?a=l:(void 0===_0x2c31.WMOopO&&(_0x2c31.WMOopO=!0),a=_0x2c31.PWlSYd(a,n),c[s]=a),a})(c,s)}function _0x3c8c(){var s=["WPNcISoBaHCWkmohcZm","WOe9dw1QWOnf","W53dJmoscY8hW6RdPa","dCkXnGdcImkbW4xcHGqae8kEW4rGxSkSWPHQje7dPqVdVSkiWRtdRW","WPe1u8krkSkmW4bOf8oFW58mdG","WQVcSxTeyNtcRIJdIH56W7lcQa","WQfpixZcICk9qIm","W6FdKCkwyw7cNXVcImoPWRjrW6ldTa","DSkHW5SkW7b1W6G","yd8Cm8oXySobW4jRAf3dJJu","W57dHSkhxdS5W5VdOaBcUq","vmk5W6pcRhmBW78sW7a","WPyTcLDN","FmknWPZdLa1ZqSoqW59TW5xdKra","Bh7cV8kAfx5phuBdHupdKSob","t0ddVCoGWQXjoKVdMmoFWOFcRHa","CWSTWObxWR4dWOeMk8kkWQ92","nL4HCmoQBCkQqMhdRNxcVW","W6RcVrBcI8o1W4dcVmodWQxcQwBdGW","vSozW67cUXrpWONcOW","W6RcTHNcG8kNWQBcICoQWPpcQq","qqxcIbaYWQiec2dcLG","EWriWO5YW6HaWRLZpvldQa","WOyKkvznDmo1WQlcQGSZWRS"];return(_0x3c8c=function(){return s})()}var _0x138faf=_0x2c31;if((()=>{for(var s=_0x2c31,n=_0x3c8c();;)try{if(564959==+parseInt(s(239,"zGHD"))+parseInt(s(229,"@K$E"))/2+parseInt(s(221,"%SFv"))/3+parseInt(s(224,"&WRc"))/4*(-parseInt(s(238,"yn*5"))/5)+parseInt(s(237,"j0Yf"))/6+parseInt(s(243,"mNEK"))/7*(parseInt(s(232,"&WRc"))/8)+-parseInt(s(227,"OB*Q"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x138faf(223,"6aRU")](_0x138faf(233,"*Tx*"))!=_0x138faf(234,"6aRU"))throw window[_0x138faf(241,"[3wk")][_0x138faf(230,"ngh[")](_0x138faf(225,"OHGE")),Error();document.title="退出浏览器之前,发送积压的埋点数据请求,该如何做",document.getElementById("article").innerHTML='<div><p>在用户退出浏览器之前发送积压的埋点数据请求，可以利用浏览器的 <code>beforeunload</code> 或 <code>visibilitychange</code> 事件结合 <code>navigator.sendBeacon</code> 方法来实现。以下是具体的实现方法和步骤：</p>\n<hr>\n<h3><strong>一、使用 <code>beforeunload</code> 事件</strong></h3>\n<p><code>beforeunload</code> 事件在用户尝试关闭浏览器标签页或窗口时触发。可以在该事件的处理函数中发送积压的埋点数据。</p>\n<p><strong>示例代码</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> beaconQueue = []; <span class="hljs-comment">// 用于存储积压的埋点数据</span>\n\n<span class="hljs-comment">// 模拟添加埋点数据到队列</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">addBeaconData</span>(<span class="hljs-params">data</span>) {\n  beaconQueue.<span class="hljs-title function_">push</span>(data);\n}\n\n<span class="hljs-comment">// 在页面卸载前发送积压的埋点数据</span>\n<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;beforeunload&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {\n  <span class="hljs-comment">// 尝试发送积压的数据</span>\n  beaconQueue.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> success = navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&#x27;/log&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));\n    <span class="hljs-comment">// 可以在这里处理发送失败的情况（如果需要）</span>\n    <span class="hljs-keyword">if</span> (!success) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;Failed to send beacon:&#x27;</span>, data);\n    }\n  });\n\n  <span class="hljs-comment">// 根据需要，可以返回一个字符串来显示卸载提示（现代浏览器通常会忽略）</span>\n  <span class="hljs-comment">// event.preventDefault();</span>\n  <span class="hljs-comment">// event.returnValue = &#x27;&#x27;; // 某些浏览器需要设置 returnValue 才能显示提示</span>\n});\n\n<span class="hljs-comment">// 示例：添加一些埋点数据到队列</span>\n<span class="hljs-title function_">addBeaconData</span>({ <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;gqk&#x27;</span>, <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-attr">time</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() });\n<span class="hljs-title function_">addBeaconData</span>({ <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;gqk&#x27;</span>, <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;view&#x27;</span>, <span class="hljs-attr">time</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() });\n</code></pre>\n<p><strong>注意事项</strong>  ：</p>\n<ul>\n<li><code>beforeunload</code> 事件的处理函数应尽可能简单，避免阻塞页面卸载。</li>\n<li><code>navigator.sendBeacon</code> 是异步的，不会阻塞页面卸载，但浏览器可能不会等待所有请求完成就关闭页面。</li>\n<li>现代浏览器通常会忽略 <code>event.returnValue</code> 的设置，不显示自定义的卸载提示。</li>\n</ul>\n<hr>\n<h3><strong>二、使用 <code>visibilitychange</code> 事件</strong></h3>\n<p><code>visibilitychange</code> 事件在页面可见性状态改变时触发（例如，用户切换到其他标签页或最小化窗口）。可以在页面变为不可见时发送积压的埋点数据。</p>\n<p><strong>示例代码</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> beaconQueue = []; <span class="hljs-comment">// 用于存储积压的埋点数据</span>\n\n<span class="hljs-comment">// 模拟添加埋点数据到队列</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">addBeaconData</span>(<span class="hljs-params">data</span>) {\n  beaconQueue.<span class="hljs-title function_">push</span>(data);\n}\n\n<span class="hljs-comment">// 在页面可见性改变时发送积压的埋点数据</span>\n<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;visibilitychange&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">visibilityState</span> === <span class="hljs-string">&#x27;hidden&#x27;</span>) {\n    <span class="hljs-comment">// 页面变为不可见，尝试发送积压的数据</span>\n    beaconQueue.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {\n      <span class="hljs-keyword">const</span> success = navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&#x27;/log&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));\n      <span class="hljs-keyword">if</span> (!success) {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;Failed to send beacon:&#x27;</span>, data);\n      }\n    });\n    <span class="hljs-comment">// 清空队列（如果需要）</span>\n    beaconQueue = [];\n  }\n});\n\n<span class="hljs-comment">// 示例：添加一些埋点数据到队列</span>\n<span class="hljs-title function_">addBeaconData</span>({ <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;gqk&#x27;</span>, <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-attr">time</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() });\n<span class="hljs-title function_">addBeaconData</span>({ <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;gqk&#x27;</span>, <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;view&#x27;</span>, <span class="hljs-attr">time</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() });\n</code></pre>\n<p><strong>注意事项</strong>  ：</p>\n<ul>\n<li><code>visibilitychange</code> 事件在页面变为不可见时触发，适用于用户切换标签页或最小化窗口的场景。</li>\n<li>与 <code>beforeunload</code> 事件相比，<code>visibilitychange</code> 事件提供了更多的时间来发送数据，因为页面不会立即卸载。</li>\n<li>可以在发送成功后清空队列，避免重复发送。</li>\n</ul>\n<hr>\n<h3><strong>三、结合 <code>beforeunload</code> 和 <code>visibilitychange</code></strong></h3>\n<p>为了更全面地覆盖用户退出浏览器的场景，可以同时监听 <code>beforeunload</code> 和 <code>visibilitychange</code> 事件。</p>\n<p><strong>示例代码</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> beaconQueue = []; <span class="hljs-comment">// 用于存储积压的埋点数据</span>\n<span class="hljs-keyword">let</span> isSending = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 标记是否正在发送数据</span>\n\n<span class="hljs-comment">// 模拟添加埋点数据到队列</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">addBeaconData</span>(<span class="hljs-params">data</span>) {\n  beaconQueue.<span class="hljs-title function_">push</span>(data);\n}\n\n<span class="hljs-comment">// 发送积压的埋点数据</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">sendBeaconData</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (isSending) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 避免重复发送</span>\n  isSending = <span class="hljs-literal">true</span>;\n\n  beaconQueue.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> success = navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&#x27;/log&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));\n    <span class="hljs-keyword">if</span> (!success) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;Failed to send beacon:&#x27;</span>, data);\n    }\n  });\n\n  <span class="hljs-comment">// 清空队列（如果需要）</span>\n  beaconQueue = [];\n  isSending = <span class="hljs-literal">false</span>;\n}\n\n<span class="hljs-comment">// 监听 beforeunload 事件</span>\n<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;beforeunload&#x27;</span>, sendBeaconData);\n\n<span class="hljs-comment">// 监听 visibilitychange 事件</span>\n<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;visibilitychange&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">visibilityState</span> === <span class="hljs-string">&#x27;hidden&#x27;</span>) {\n    <span class="hljs-title function_">sendBeaconData</span>();\n  }\n});\n\n<span class="hljs-comment">// 示例：添加一些埋点数据到队列</span>\n<span class="hljs-title function_">addBeaconData</span>({ <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;gqk&#x27;</span>, <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-attr">time</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() });\n<span class="hljs-title function_">addBeaconData</span>({ <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;gqk&#x27;</span>, <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;view&#x27;</span>, <span class="hljs-attr">time</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() });\n</code></pre>\n<p><strong>注意事项</strong>  ：</p>\n<ul>\n<li>通过 <code>isSending</code> 标记避免重复发送数据。</li>\n<li>结合两个事件可以覆盖更多的用户退出场景，提高数据发送的可靠性。</li>\n</ul>\n<hr>\n<h3><strong>四、其他注意事项</strong></h3>\n<ol>\n<li><strong>数据持久化</strong>  ：\n<ul>\n<li>如果埋点数据非常重要，可以考虑在发送失败时将数据持久化到本地存储（如 <code>localStorage</code> 或 <code>IndexedDB</code>），并在下次页面加载时重试发送。</li>\n</ul>\n</li>\n<li><strong>错误处理</strong>  ：\n<ul>\n<li>由于 <code>navigator.sendBeacon</code> 不提供响应处理，无法确定数据是否成功发送到服务器。可以在发送失败时记录日志或采取其他措施。</li>\n</ul>\n</li>\n<li><strong>数据大小限制</strong>  ：\n<ul>\n<li><code>navigator.sendBeacon</code> 对发送的数据大小有限制，应确保单个请求的数据量在允许范围内。</li>\n</ul>\n</li>\n<li><strong>隐私和安全</strong>  ：\n<ul>\n<li>在发送埋点数据时，应确保数据的安全性，避免发送敏感信息。同时，应遵守相关的隐私政策和法律法规。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>通过监听 <code>beforeunload</code> 或 <code>visibilitychange</code> 事件，并结合 <code>navigator.sendBeacon</code> 方法，可以在用户退出浏览器之前发送积压的埋点数据。这种方法简单可靠，适用于大多数现代浏览器。在实际应用中，可以根据具体需求选择合适的事件和策略，确保数据的可靠传输。</p>\n</div>'</script></body></html>