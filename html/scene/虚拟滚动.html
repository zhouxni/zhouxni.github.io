<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x45f671=_0x1a42;function _0x3149(){var s=["W7a5W5ZcKfmdW6j0WPpdHbBdO3K","WPelBx8/W59wkHqgxJtdTq","W7XjFCoTW7BcUmo0rW","W5zsW6NdTSoSoSot","WPelyNP7WOuqjrWy","W7ieWPZcIKysW5XEW5uIemk4","iKPbw8kaoSklWOeOpCotwrm","oCksEq0CWQJcIIOKWPZcMsJdGa","WQ3dQGrzWQqecHldOde","DmkxWPNcO8kmvfaKoa","W7LheSozWOiwlZJdTSkeWQGZ","g8oKWOSdWR7dOmkv","WR0luCkyW44","gSkgWOGQs2FdQ8kIWR7cMh3cTCkd","fmktf1TfsvGx","WR9jW47cNmofz8ocgG","iuLhxSkboCkpWOy7k8oAyH8","W79nfmoyWOesDqZdJCkWWOy6yG","oSo0dgbSW5ZdVW","WQddTIxcJexcSvZdSSosWRWAEmoBW7K","W7pdQ8k7iSkWvmomWPDYW54","gSkcWO4TsMVdQ8kVWRtcK1xcQCkf","iZ1HzM5Rl3HVcG","f8kursieocXnW7ZcJX/cUSomiq","q8ocW4XSd2NdSmolWQhcQNpcTSkCyK5uW7ldKcxcIXmnW7BcN8kxiq","WPzLW5RdGmokh8oZ"];return(_0x3149=function(){return s})()}function _0x1a42(t,s){var p=_0x3149();return(_0x1a42=function(s,n){var a=p[s-=188];void 0===_0x1a42.kmbybY&&(_0x1a42.ShgnhK=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,r=0;a=s.charAt(r++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,i=l.length;e<i;e++)t+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(s),r=0;r<256;r++)l[r]=r;for(r=0;r<256;r++)t=(t+l[r]+n.charCodeAt(r%n.length))%256,a=l[r],l[r]=l[t],l[t]=a;for(var r=0,t=0,e=0;e<s.length;e++)a=l[r=(r+1)%256],l[r]=l[t=(t+l[r])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(e)^l[(l[r]+l[t])%256]);return p},t=arguments,_0x1a42.kmbybY=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x1a42.HfgdyN&&(_0x1a42.HfgdyN=!0),a=_0x1a42.ShgnhK(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x1a42,n=_0x3149();;)try{if(302428==+parseInt(s(207,"xYQd"))*(parseInt(s(205,"%0B1"))/2)+parseInt(s(210,"pHT]"))/3*(parseInt(s(196,"k[IY"))/4)+parseInt(s(209,"j^S$"))/5+parseInt(s(193,"a6Vc"))/6+parseInt(s(197,"5T2G"))/7+parseInt(s(208,"5b)]"))/8*(-parseInt(s(190,"90Xe"))/9)+-parseInt(s(199,"90Xe"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x45f671(213,"]6fS")](_0x45f671(211,"3wgo"))!=_0x45f671(188,"a6Vc"))throw window[_0x45f671(191,"DziP")][_0x45f671(201,"%0B1")](_0x45f671(200,"5T2G")),Error();document.title="虚拟滚动",document.getElementById("article").innerHTML='<div><p><strong>虚拟滚动加载原理</strong></p>\n<p>虚拟滚动（Virtual Scrolling）是一种优化长列表渲染性能的技术，其核心思想是只渲染用户当前可视区域内的元素，而将不可见区域的元素延迟渲染或从 DOM 中移除。这种技术可以显著减少 DOM 节点的数量，降低浏览器的渲染压力，提高页面的响应速度和流畅度。</p>\n<hr>\n<h3><strong>虚拟滚动加载的基本原理</strong></h3>\n<ol>\n<li><strong>仅渲染可视区域</strong>\n<ul>\n<li><strong>原理</strong>  ：只渲染用户当前屏幕可见的部分元素，对于不可见的部分，不创建或渲染对应的 DOM 节点。</li>\n<li><strong>效果</strong>  ：减少了 DOM 节点的数量，降低了内存占用和渲染时间。</li>\n</ul>\n</li>\n<li><strong>动态计算可视区域</strong>\n<ul>\n<li><strong>原理</strong>  ：通过监听滚动事件，实时计算用户当前的可视区域，确定需要渲染的元素范围。</li>\n<li><strong>实现</strong>  ：根据滚动位置、容器高度和单个元素的高度，计算出起始和结束索引。</li>\n</ul>\n</li>\n<li><strong>占位符保持滚动条高度</strong>\n<ul>\n<li><strong>原理</strong>  ：为了保持滚动条的正常显示和滚动体验，使用占位符（如空的 <code>div</code>）来占据不可见元素的位置。</li>\n<li><strong>实现</strong>  ：设置容器的高度为所有元素的总高度，即使部分元素未渲染。</li>\n</ul>\n</li>\n<li><strong>懒加载和回收机制</strong>\n<ul>\n<li><strong>原理</strong>  ：当用户滚动时，动态加载新的元素到可视区域，同时回收不再可见的元素。</li>\n<li><strong>实现</strong>  ：通过池化技术（对象池）复用 DOM 节点，避免频繁的创建和销毁。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>虚拟滚动的实现步骤</strong></h3>\n<ol>\n<li><strong>初始化容器和参数</strong>\n<ul>\n<li>设置容器的高度和溢出滚动样式。</li>\n<li>确定单个元素的高度（假设所有元素高度相同）。</li>\n<li>计算总元素数量，设置容器的总高度。</li>\n</ul>\n</li>\n<li><strong>监听滚动事件</strong>\n<ul>\n<li>绑定滚动事件监听器，实时获取滚动位置。</li>\n</ul>\n</li>\n<li><strong>计算可视范围内的元素索引</strong>\n<ul>\n<li>根据滚动位置、容器高度和单个元素高度，计算起始和结束索引。</li>\n</ul>\n</li>\n<li><strong>渲染可视范围内的元素</strong>\n<ul>\n<li>清空容器，重新渲染计算出的可视范围内的元素。</li>\n<li>设置每个元素的 <code>top</code> 样式，定位到正确的位置。</li>\n</ul>\n</li>\n<li><strong>更新容器高度</strong>\n<ul>\n<li>设置容器的总高度为所有元素的总高度，确保滚动条正常显示。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>虚拟滚动的代码示例</strong></h3>\n<p>以下是一个简单的虚拟滚动实现示例：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;scroll-container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n<pre><code class="language-css"><span class="hljs-selector-class">.scroll-container</span> {\n  <span class="hljs-attribute">position</span>: relative;\n  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;\n  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>; <span class="hljs-comment">/* 可视区域高度 */</span>\n  <span class="hljs-attribute">overflow-y</span>: auto;\n}\n\n<span class="hljs-selector-class">.list-item</span> {\n  <span class="hljs-attribute">position</span>: absolute;\n  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;\n  <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>; <span class="hljs-comment">/* 单个元素高度 */</span>\n  <span class="hljs-attribute">box-sizing</span>: border-box;\n  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;\n}\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualScroll</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">container, itemHeight, totalItems</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span> = container;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemHeight</span> = itemHeight;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">totalItems</span> = totalItems;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">startIndex</span> = <span class="hljs-number">0</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">endIndex</span> = <span class="hljs-number">0</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bufferCount</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// 缓冲区元素数量，防止频繁渲染</span>\n\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.totalItems * <span class="hljs-variable language_">this</span>.itemHeight}</span>px`</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">onScroll</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>));\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">update</span>();\n  }\n\n  <span class="hljs-title function_">onScroll</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> scrollTop = <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-property">scrollTop</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">startIndex</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(scrollTop / <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemHeight</span>) - <span class="hljs-variable language_">this</span>.<span class="hljs-property">bufferCount</span>);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">endIndex</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">totalItems</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((scrollTop + <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-property">clientHeight</span>) / <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemHeight</span>) + <span class="hljs-variable language_">this</span>.<span class="hljs-property">bufferCount</span>);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">update</span>();\n  }\n\n  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&#x27;</span>; <span class="hljs-comment">// 清空容器</span>\n    <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();\n\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">startIndex</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">endIndex</span>; i++) {\n      <span class="hljs-keyword">const</span> item = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);\n      item.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;list-item&#x27;</span>;\n      item.<span class="hljs-property">innerText</span> = <span class="hljs-string">`Item <span class="hljs-subst">${i}</span>`</span>;\n      item.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = <span class="hljs-string">`<span class="hljs-subst">${i * <span class="hljs-variable language_">this</span>.itemHeight}</span>px`</span>;\n      fragment.<span class="hljs-title function_">appendChild</span>(item);\n    }\n\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-title function_">appendChild</span>(fragment);\n  }\n}\n\n<span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.scroll-container&#x27;</span>);\n<span class="hljs-keyword">const</span> virtualScroll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VirtualScroll</span>(container, <span class="hljs-number">30</span>, <span class="hljs-number">10000</span>);\n</code></pre>\n<hr>\n<h3><strong>关键点解析</strong></h3>\n<ul>\n<li><strong>性能优化</strong>  ：通过只渲染可视区域的元素，减少了 DOM 节点的数量，避免了浏览器渲染大量节点导致的性能瓶颈。</li>\n<li><strong>滚动体验</strong>  ：使用占位符保持滚动条的高度，确保用户滚动体验与渲染所有元素时一致。</li>\n<li><strong>动态更新</strong>  ：监听滚动事件，实时更新渲染内容，确保用户看到的始终是当前可视区域内的元素。</li>\n<li><strong>缓冲区设置</strong>  ：为了避免频繁的 DOM 操作，通常会设置一个缓冲区，提前渲染可视区域上下一定数量的元素。</li>\n</ul>\n<hr>\n<h3><strong>应用场景</strong></h3>\n<ul>\n<li><strong>长列表展示</strong>  ：如电商网站的商品列表、社交平台的动态流、文件管理器中的文件列表等。</li>\n<li><strong>大数据量渲染</strong>  ：当需要渲染成千上万条数据时，虚拟滚动可以显著提升性能。</li>\n<li><strong>无限滚动</strong>  ：结合懒加载技术，实现无限滚动加载，提升用户体验。</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>虚拟滚动加载通过只渲染用户当前可视区域的元素，显著减少了 DOM 节点的数量，降低了浏览器的渲染压力，提高了页面的响应速度和流畅度。其核心在于动态计算可视区域、懒加载和回收机制，以及占位符的使用。通过合理的实现和优化，虚拟滚动可以在大数据量渲染场景下提供出色的性能表现。</p>\n</div>'</script></body></html>