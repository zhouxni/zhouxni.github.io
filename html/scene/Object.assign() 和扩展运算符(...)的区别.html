<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5726(t,s){var p=_0x43c2();return(_0x5726=function(s,n){var a=p[s-=139];void 0===_0x5726.SIkhBc&&(_0x5726.XJADZt=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,c=0;a=s.charAt(c++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,o=l.length;e<o;e++)t+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)t=(t+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[t],l[t]=a;for(var c=0,t=0,e=0;e<s.length;e++)a=l[c=(c+1)%256],l[c]=l[t=(t+l[c])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(e)^l[(l[c]+l[t])%256]);return p},t=arguments,_0x5726.SIkhBc=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x5726.nbEuTA&&(_0x5726.nbEuTA=!0),a=_0x5726.XJADZt(a,n),t[s]=a),a})(t,s)}function _0x43c2(){var s=["z2ZcS3zbW7ba","W7VdGvdcLmo4W6uRW7bKWQBdJmoAW74","pt7dLKdcGgvoW4bQWPBdLSoGCmkAD8kzW5NdNmouqSkgW5W2u8ozhG","W7BdOghdISo1W4ncW5FdOSkx","uYhcS8oPWOBdSeBcO0mCW7z0WRS","WOVcKqVdImk8WQ9vW6n6","WR/cMCkEWOv0WP7dHLrHxG","t09hC8k5W4PqECktz8o7WRi","teLkDCo3WOLjy8kBFa","WOJdHCoGfmkRtCoTW6Wp","wKNdOCktzSoXWQSngCoNWR7cPq","wCk2W5RdMfNdTCoPWPFcLSkp","qmkpkr11aYBcUCkDirO","W7xdPMZdJmk7WObBW43dQSkmnd0","BI9/WQBdKSkOW7aT","yYVcVCkMuK5VCCkV","WPXUEmotW5tcPSol","mfebW40GW6GjW71PW7uG","wmobfCo5ACkbDSoewSk1W642","f2BcH8kjpfFcQG","zsRcVmoKrgjXAmk/W6q","WOFdTIHJrmkqW4GIwmofWRa","W74FhXWbWPHl","WOddTY9RrCo+W7ajxmoLWQpdTa","n3GRW7lcLmkSW7CfWPdcKdK","yhpcLqpdIM84WRv6WPVdTSoE","W4OnW7BcIaO","W77dHfNcMCkfWRPRW69wWQi"];return(_0x43c2=function(){return s})()}var _0x179fc2=_0x5726;if((()=>{for(var s=_0x5726,n=_0x43c2();;)try{if(798876==+parseInt(s(151,"yXK6"))+-parseInt(s(162,"9RZv"))/2+parseInt(s(156,"Y9Hp"))/3*(-parseInt(s(144,"ub76"))/4)+-parseInt(s(164,"%v9F"))/5*(parseInt(s(155,"R[8n"))/6)+parseInt(s(152,"yXK6"))/7*(parseInt(s(161,"Y8h4"))/8)+-parseInt(s(153,"j(NO"))/9*(-parseInt(s(154,"Pvqx"))/10)+-parseInt(s(148,"iY!l"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x179fc2(163,"(vwR")](_0x179fc2(149,"fu%1"))!=_0x179fc2(142,"&qpZ"))throw window[_0x179fc2(158,"[UuN")][_0x179fc2(166,"GJhG")](_0x179fc2(146,"AoDE")),Error();document.title="Object.assign() 和扩展运算符(...)的区别",document.getElementById("article").innerHTML='<div><p><code>Object.assign()</code> 和扩展运算符 <code>...</code> 都是 JavaScript 中用于对象合并的常用方法，但它们有一些重要的区别。</p>\n<h2>基本用法对比</h2>\n<h3>Object.assign()</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj1 = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };\n<span class="hljs-keyword">const</span> obj2 = { <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> };\n<span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, obj1, obj2);\n<span class="hljs-comment">// result: { a: 1, b: 2 }</span>\n</code></pre>\n<h3>扩展运算符</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj1 = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };\n<span class="hljs-keyword">const</span> obj2 = { <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> };\n<span class="hljs-keyword">const</span> result = { ...obj1, ...obj2 };\n<span class="hljs-comment">// result: { a: 1, b: 2 }</span>\n</code></pre>\n<h2>主要区别</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Object.assign()</th>\n<th>扩展运算符 (...)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>语法简洁性</strong></td>\n<td>较冗长</td>\n<td>更简洁</td>\n</tr>\n<tr>\n<td><strong>原型属性</strong></td>\n<td>会复制</td>\n<td>不会复制</td>\n</tr>\n<tr>\n<td><strong>Symbol属性</strong></td>\n<td>会复制</td>\n<td>会复制</td>\n</tr>\n<tr>\n<td><strong>不可枚举属性</strong></td>\n<td>不会复制</td>\n<td>不会复制</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td>通常更快</td>\n<td>通常稍慢</td>\n</tr>\n<tr>\n<td><strong>浏览器兼容性</strong></td>\n<td>ES5+</td>\n<td>ES2018+</td>\n</tr>\n<tr>\n<td><strong>空值处理</strong></td>\n<td>会忽略null/undefined</td>\n<td>会抛出TypeError</td>\n</tr>\n</tbody>\n</table>\n<h2>详细区别说明</h2>\n<h3>1. 原型链处理</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;\n  }\n}\n<span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>;\n\n<span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();\n\n<span class="hljs-comment">// Object.assign() - 只复制自身属性</span>\n<span class="hljs-keyword">const</span> assignCopy = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, obj);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(assignCopy); <span class="hljs-comment">// { a: 1 }</span>\n\n<span class="hljs-comment">// 扩展运算符 - 也只复制自身属性</span>\n<span class="hljs-keyword">const</span> spreadCopy = { ...obj };\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(spreadCopy); <span class="hljs-comment">// { a: 1 }</span>\n</code></pre>\n<h3>2. Symbol属性处理</h3>\n<p>两者都会复制Symbol属性：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> symbolKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;key&#x27;</span>);\n<span class="hljs-keyword">const</span> obj = { [symbolKey]: <span class="hljs-string">&#x27;value&#x27;</span> };\n\n<span class="hljs-keyword">const</span> assignCopy = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, obj);\n<span class="hljs-keyword">const</span> spreadCopy = { ...obj };\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(assignCopy[symbolKey]); <span class="hljs-comment">// &#x27;value&#x27;</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(spreadCopy[symbolKey]); <span class="hljs-comment">// &#x27;value&#x27;</span>\n</code></pre>\n<h3>3. 不可枚举属性处理</h3>\n<p>两者都不会复制不可枚举属性：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = {};\n<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&#x27;hidden&#x27;</span>, {\n  <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;secret&#x27;</span>,\n  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>\n});\n\n<span class="hljs-keyword">const</span> assignCopy = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, obj);\n<span class="hljs-keyword">const</span> spreadCopy = { ...obj };\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hidden&#x27;</span> <span class="hljs-keyword">in</span> assignCopy); <span class="hljs-comment">// false</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hidden&#x27;</span> <span class="hljs-keyword">in</span> spreadCopy); <span class="hljs-comment">// false</span>\n</code></pre>\n<h3>4. 空值处理差异</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// Object.assign() 会忽略null和undefined源对象</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// {}</span>\n\n<span class="hljs-comment">// 扩展运算符会抛出错误</span>\n<span class="hljs-keyword">try</span> {\n  <span class="hljs-keyword">const</span> obj = { ...<span class="hljs-literal">null</span>, ...<span class="hljs-literal">undefined</span> };\n} <span class="hljs-keyword">catch</span> (e) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e); <span class="hljs-comment">// TypeError: Cannot spread non-iterable objects</span>\n}\n</code></pre>\n<h3>5. 性能比较</h3>\n<p>在大多数JavaScript引擎中，<code>Object.assign()</code> 的性能略优于扩展运算符，特别是在处理大型对象时。</p>\n<h2>使用建议</h2>\n<ol>\n<li><strong>优先使用扩展运算符</strong>   - 语法更简洁，可读性更好（现代代码）</li>\n<li><strong>需要处理null/undefined时</strong>   - 使用<code>Object.assign()</code></li>\n<li><strong>需要支持旧浏览器时</strong>   - 使用<code>Object.assign()</code>或Babel转译</li>\n<li><strong>性能关键代码</strong>   - 考虑使用<code>Object.assign()</code></li>\n</ol>\n<h2>特殊用例</h2>\n<h3>深度合并</h3>\n<p>两者都只做浅拷贝，要实现深度合并需要递归或其他方法：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj1 = { <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> } };\n<span class="hljs-keyword">const</span> obj2 = { <span class="hljs-attr">a</span>: { <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> } };\n\n<span class="hljs-comment">// 浅合并</span>\n<span class="hljs-keyword">const</span> shallowMerge = { ...obj1, ...obj2 };\n<span class="hljs-comment">// { a: { c: 2 } } - obj1.a被完全覆盖</span>\n\n<span class="hljs-comment">// 需要手动深度合并</span>\n<span class="hljs-keyword">const</span> deepMerge = {\n  ...obj1,\n  <span class="hljs-attr">a</span>: {\n    ...obj1.<span class="hljs-property">a</span>,\n    ...obj2.<span class="hljs-property">a</span>\n  }\n};\n<span class="hljs-comment">// { a: { b: 1, c: 2 } }</span>\n</code></pre>\n<p>总之，在大多数现代JavaScript开发中，扩展运算符是更受欢迎的选择，但在特定情况下<code>Object.assign()</code>仍有其用途。</p>\n</div>'</script></body></html>