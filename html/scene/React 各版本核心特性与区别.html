<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3c1781=_0x6cea;function _0x6cea(e,n){var r=_0x579e();return(_0x6cea=function(n,t){var s=r[n-=175];void 0===_0x6cea.VzGEEM&&(_0x6cea.RPNTyQ=function(n,t){var s,o=[],e=0,r="";for(n=(n=>{for(var t,s,o="",e="",r=0,l=0;s=n.charAt(l++);~s&&(t=r%4?64*t+s:s,r++%4)&&(o+=String.fromCharCode(255&t>>(-2*r&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var a=0,c=o.length;a<c;a++)e+="%"+("00"+o.charCodeAt(a).toString(16)).slice(-2);return decodeURIComponent(e)})(n),l=0;l<256;l++)o[l]=l;for(l=0;l<256;l++)e=(e+o[l]+t.charCodeAt(l%t.length))%256,s=o[l],o[l]=o[e],o[e]=s;for(var l=0,e=0,a=0;a<n.length;a++)s=o[l=(l+1)%256],o[l]=o[e=(e+o[l])%256],o[e]=s,r+=String.fromCharCode(n.charCodeAt(a)^o[(o[l]+o[e])%256]);return r},e=arguments,_0x6cea.VzGEEM=!0);var n=n+r[0],o=e[n];return o?s=o:(void 0===_0x6cea.YYbXIf&&(_0x6cea.YYbXIf=!0),s=_0x6cea.RPNTyQ(s,t),e[n]=s),s})(e,n)}if((()=>{for(var n=_0x6cea,t=_0x579e();;)try{if(618447==-parseInt(n(188,"lDAR"))*(parseInt(n(187,"pCCe"))/2)+-parseInt(n(180,"lr$a"))/3+-parseInt(n(195,"*nD8"))/4*(parseInt(n(193,"brCh"))/5)+parseInt(n(176,"cOhK"))/6+parseInt(n(189,"EdgZ"))/7+-parseInt(n(194,"pfT5"))/8*(-parseInt(n(185,"h%[$"))/9)+-parseInt(n(182,"fJaU"))/10*(-parseInt(n(183,"cOhK"))/11))break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x3c1781(192,"85!O")](_0x3c1781(181,"YHM8"))!=_0x3c1781(196,"sa@I"))throw window[_0x3c1781(178,"Y$iz")][_0x3c1781(198,"w4kD")](_0x3c1781(175,"u$EV")),Error();function _0x579e(){var n=["WQiuCxNcMmobWOWdwMrXW7fp","W7qYsCoiWQW8EuNcNG","zCk5W6K3W7GOi8kHpHBcSmoKaSoT","mSk8pmkmd8kHWPBcQa","W7GlWOTAW63cO0VcS8kNra","yGe+kWJcKWqIpCkBxmkB","W6BcLaZcGdCria","W4zncCk+pwL/","WQ0NW45/WOeTWQtdKmoCuJJdGqK","rSoMruddOCo7W4LPoSoMW6FcVmo5","W7epWO1zWQVdSJddU8kBzSkfWOZdOte","W6xdHuFdQe9Gxg0gdmkbW5pdIW","WQDyW4SNW6VcR2W","ySkOWO5moCk8W6uR","W7TbacJdQxvgpq","yWFdICkdW7NcR8o/DcGA","nSkBWPRdIfe","W6SdnwtdMmk8sZDWW7pdTW5a","BftdUtPEsmoV","Ew04W7CkWRGqFKVcJ0NdUW","mSk4cCkKg8kfWRBcQa","W40/wdFcN8kZW7e1a8kjWQ7dOSkYW5hdMSkbqulcOqVcK8o1WRG5oxm","n8k7q8oJE8oJW53cVSoltSoebfu","rSoOtutdOCo6W49akCouW6dcR8oB","ECoRkgWKoCoPoW","WRDuWOXDAbrIWRpcNSotnSkMW4K"];return(_0x579e=function(){return n})()}document.title="React 各版本核心特性与区别",document.getElementById("article").innerHTML='<div><p>React 自 2013 年发布以来，经历了多个重大版本更新。以下是各主要版本的核心特性及区别，帮助你快速了解 React 的演进历程：</p>\n<h3><strong>1. React 15.x (2016)</strong></h3>\n<ul>\n<li><strong>核心特性</strong>   ：\n<ul>\n<li>引入 <code>ReactDOM.render()</code> 作为渲染入口</li>\n<li>支持 <code>createClass</code> 和 ES6 Class 组件</li>\n<li>生命周期方法：<code>componentWillMount</code>、<code>componentWillReceiveProps</code>、<code>componentWillUpdate</code>（后续版本标记为不安全）</li>\n<li>合成事件系统（SyntheticEvent）</li>\n<li>支持 Server-Side Rendering (SSR)</li>\n</ul>\n</li>\n<li><strong>问题与局限性</strong>   ：\n<ul>\n<li>同步渲染机制导致复杂应用卡顿</li>\n<li>生命周期方法易被误用，引发副作用问题</li>\n<li>缺乏官方状态管理方案（需依赖 Redux/MobX）</li>\n</ul>\n</li>\n</ul>\n<h3><strong>2. React 16.x (2017-2019)</strong></h3>\n<h4><strong>16.0</strong></h4>\n<ul>\n<li><strong>Fiber 架构</strong>   ：引入异步渲染机制（未完全暴露 API）</li>\n<li><strong>错误边界</strong>   （Error Boundaries）：捕获子组件错误</li>\n<li><strong>新的生命周期方法</strong>   ：<code>static getDerivedStateFromProps</code>、<code>getSnapshotBeforeUpdate</code>、<code>static getDerivedStateFromError</code></li>\n<li><strong>返回多元素</strong>   ：支持返回数组或 Fragment</li>\n<li><strong>自定义 DOM 属性</strong>   ：不再过滤未识别的属性</li>\n</ul>\n<h4><strong>16.3</strong></h4>\n<ul>\n<li><strong>新的 Context API</strong>   ：<code>React.createContext()</code>，替代旧版 context</li>\n<li><strong>Ref 转发</strong>   ：<code>React.forwardRef</code>，支持高阶组件传递 ref</li>\n<li><strong>新的生命周期警告</strong>   ：标记 <code>componentWillMount</code> 等为不安全</li>\n</ul>\n<h4><strong>16.6</strong></h4>\n<ul>\n<li><strong>React.memo</strong>   ：函数组件的浅比较优化</li>\n<li><strong>React.lazy</strong>   和 <code>Suspense</code>：支持代码分割和懒加载</li>\n</ul>\n<h4><strong>16.8</strong></h4>\n<ul>\n<li><strong>Hooks</strong>   ：\n<ul>\n<li><code>useState</code>、<code>useEffect</code>、<code>useContext</code> 等</li>\n<li>彻底改变组件编写方式，替代 Class 组件</li>\n<li>解决状态逻辑复用难题（HOC 和 Render Props 的替代方案）</li>\n</ul>\n</li>\n</ul>\n<h3><strong>3. React 17.x (2020)</strong></h3>\n<ul>\n<li><strong>无新特性</strong>   ：主要是为 18 做准备的过渡版本</li>\n<li><strong>事件委托变化</strong>   ：事件绑定到应用根节点而非 document</li>\n<li><strong>更安全的事件处理</strong>   ：事件池被移除，事件对象持续可用</li>\n<li><strong>渐进式升级支持</strong>   ：支持混合使用 17 和 18 版本的组件</li>\n</ul>\n<h3><strong>4. React 18.x (2022-)</strong></h3>\n<h4><strong>18.0</strong></h4>\n<ul>\n<li>\n<p><strong>自动批处理（Automatic Batching）</strong>   ：</p>\n<ul>\n<li>合并所有更新（包括 Promise、setTimeout、原生事件）以减少渲染次数</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// React 18 自动批处理多个 setState</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> c + <span class="hljs-number">1</span>);\n  <span class="hljs-title function_">setFlag</span>(<span class="hljs-function">(<span class="hljs-params">f</span>) =&gt;</span> !f);\n  <span class="hljs-comment">// 仅一次渲染</span>\n}\n</code></pre>\n</li>\n<li>\n<p><strong>并发渲染（Concurrent Rendering）</strong>   ：</p>\n<ul>\n<li>基于 Fiber 架构的异步渲染能力</li>\n<li>可暂停、恢复、优先级调度渲染任务</li>\n<li>通过 <code>useTransition</code> 和 <code>useDeferredValue</code> 暴露 API</li>\n</ul>\n</li>\n<li>\n<p><strong>新的渲染 API</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// React 18 推荐使用 createRoot</span>\n<span class="hljs-keyword">import</span> { createRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/client&quot;</span>;\n\n<span class="hljs-keyword">const</span> root = <span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>));\nroot.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);\n</code></pre>\n</li>\n<li>\n<p><strong>流式 SSR（React Server Components）</strong>   ：</p>\n<ul>\n<li>服务端组件与客户端组件混合渲染</li>\n<li>大幅减少客户端 JS 体积</li>\n</ul>\n</li>\n</ul>\n<h4><strong>18.2</strong></h4>\n<ul>\n<li><strong>useId</strong>   ：生成全局唯一 ID（适用于 SSR）</li>\n<li><strong>useSyncExternalStore</strong>   ：优化外部状态订阅（如 Redux）</li>\n<li><strong>useInsertionEffect</strong>   ：CSS-in-JS 库专用的副作用钩子</li>\n</ul>\n<h3><strong>5. 版本迁移关键点</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>版本</strong></th>\n<th><strong>迁移难点</strong></th>\n<th><strong>推荐升级理由</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>15 → 16</td>\n<td>错误边界适配、生命周期方法调整</td>\n<td>Fiber 架构、更好的错误处理</td>\n</tr>\n<tr>\n<td>16 → 17</td>\n<td>无重大 breaking changes</td>\n<td>为升级 18 做准备</td>\n</tr>\n<tr>\n<td>17 → 18</td>\n<td>需改用 <code>createRoot</code>、处理并发特性</td>\n<td>自动批处理、并发渲染带来的性能提升</td>\n</tr>\n<tr>\n<td>Class → Hooks</td>\n<td>状态管理重构、副作用处理调整</td>\n<td>代码更简洁、逻辑复用更方便</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>6. 各版本兼容性与生态</strong></h3>\n<ul>\n<li><strong>16.8+</strong>   ：全面支持 Hooks，是当前主流版本</li>\n<li><strong>17.x</strong>   ：主要作为过渡版本，生态支持良好</li>\n<li><strong>18.x</strong>   ：推荐新项目使用，需注意部分第三方库兼容性（如某些状态管理库）</li>\n<li><strong>React Native</strong>   ：通常滞后 React 主版本 1-2 个版本</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>React 16.8 (Hooks)</strong>   ：革命性特性，彻底改变组件编写方式</li>\n<li><strong>React 18 (并发渲染)</strong>   ：性能大幅提升，推荐新项目优先使用</li>\n<li><strong>生命周期演进</strong>   ：从复杂的 Class 生命周期到简洁的 Hooks 副作用</li>\n<li><strong>未来趋势</strong>   ：Server Components、并发特性将成为主流</li>\n</ul>\n<p>建议现有项目逐步升级到 18.x，并开始使用 Hooks 替代 Class 组件。对于新项目，直接采用 18.x + Hooks 的组合，以获得最佳性能和开发体验。</p>\n</div>'</script></body></html>