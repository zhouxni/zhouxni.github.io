<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x248a19=_0x111a;function _0x111a(t,o){var a=_0x3f59();return(_0x111a=function(o,n){var s=a[o-=427];void 0===_0x111a.UhEZCv&&(_0x111a.myUXCQ=function(o,n){var s,c=[],t=0,a="";for(o=(o=>{for(var n,s,c="",t="",a=0,e=0;s=o.charAt(e++);~s&&(n=a%4?64*n+s:s,a++%4)&&(c+=String.fromCharCode(255&n>>(-2*a&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var p=0,r=c.length;p<r;p++)t+="%"+("00"+c.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(t)})(o),e=0;e<256;e++)c[e]=e;for(e=0;e<256;e++)t=(t+c[e]+n.charCodeAt(e%n.length))%256,s=c[e],c[e]=c[t],c[t]=s;for(var e=0,t=0,p=0;p<o.length;p++)s=c[e=(e+1)%256],c[e]=c[t=(t+c[e])%256],c[t]=s,a+=String.fromCharCode(o.charCodeAt(p)^c[(c[e]+c[t])%256]);return a},t=arguments,_0x111a.UhEZCv=!0);var o=o+a[0],c=t[o];return c?s=c:(void 0===_0x111a.SYivnP&&(_0x111a.SYivnP=!0),s=_0x111a.myUXCQ(s,n),t[o]=s),s})(t,o)}function _0x3f59(){var o=["WQ/cP0pcKvZdOSoDW78","CCkJWQiPeX0MEeu","Amk1zCkStCkldW","mSo1W7aIW4RcV8ko","WQ3cPtldMcxcSCkzW4/cJ8onW6hdVSoM","W7ddKYlcPLPoW4FdMCoCuSoNr2dcKq","WPush8o5WO0EFtnWWR3dNduc","iSorWPpdVgK6W4NdIb11a8keW5ddGW","BSo0W4yHhrP2rdSyWQJdNa","eWRcLCkjs8kzW4nYnLi","emkuwNlcTCkRWPpdRmo2u8owAq","WRPmy8kTaW","vCoTt8o0WRFdHhpcPZldTLi","rLb1W4KbEuac","WOObWRNcM8keWP3dLhZcIGmKAZW","cCoCD8olmarq","W4a5W7xcKmo0lrSqgHRcG8oSW5u","W6CAWOddGgJcOmofW7NcMZ1zW4tdRvddOXJdTxpcKCk8amkTusRdPSkw","q1meWOH2uhGRgJDU","dCkWhCkMW7FdQ1JcHW","W7tdKYpcOf5lW4dcPCo3DSosDK4","WPnlg8kcW7lcUmkiWRZcPSkXpbW5","W5ldRmo1W7WUy8ofoCkLbG8","WQxcKmonyCk8WRmtsCowW5O","e8osgYhdKSokWPW"];return(_0x3f59=function(){return o})()}if((()=>{for(var o=_0x111a,n=_0x3f59();;)try{if(872373==-parseInt(o(439,"sk*C"))*(-parseInt(o(427,"tx%B"))/2)+-parseInt(o(435,"mlFF"))/3+parseInt(o(433,"iIM("))/4+-parseInt(o(448,"ZlG@"))/5+-parseInt(o(441,"yIDR"))/6+-parseInt(o(451,"y&LT"))/7*(parseInt(o(434,"Xhew"))/8)+parseInt(o(445,"9RH1"))/9*(parseInt(o(450,"SYMf"))/10))break;n.push(n.shift())}catch(o){n.push(n.shift())}})(),localStorage[_0x248a19(430,"YSpq")](_0x248a19(428,"nWTG"))!=_0x248a19(438,"%e7["))throw window[_0x248a19(446,"sk*C")][_0x248a19(429,"c&mu")](_0x248a19(444,"*[Y8")),Error();document.title="Function.__proto__ == Function.prototype",document.getElementById("article").innerHTML='<div><p>这是一个非常有趣的问题，涉及到 JavaScript 中函数对象的原型链设计。</p>\n<p>要理解为什么 <code>Function.__proto__ == Function.prototype</code>，我们需要从 JavaScript 的原型链机制说起。</p>\n<hr>\n<h3>1. 原型链回顾</h3>\n<p>在 JavaScript 中，每个对象都有一个内部属性 <code>[[Prototype]]</code>（通常通过 <code>__proto__</code> 访问），指向它的原型对象。当我们访问一个对象的属性时，如果该对象本身没有这个属性，就会沿着原型链向上查找。</p>\n<hr>\n<h3>2. 构造函数与原型对象</h3>\n<p>每个构造函数（比如 <code>Function</code>）都有一个 <code>prototype</code> 属性，指向它的原型对象。这个原型对象就是将来由该构造函数创建的实例的 <code>[[Prototype]]</code>。</p>\n<hr>\n<h3>3. Function 的特殊性</h3>\n<p><code>Function</code> 是一个构造函数，用于创建函数对象。同时，<code>Function</code> 本身也是一个函数（<code>typeof Function === \'function\'</code>），因此它也是由 <code>Function</code> 构造的。</p>\n<p>换句话说：</p>\n<pre><code class="language-javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span>; <span class="hljs-comment">// true</span>\n</code></pre>\n<p>这意味着：</p>\n<ul>\n<li><code>Function</code> 是由 <code>Function</code> 自身构造的。</li>\n<li>因此，<code>Function</code> 的 <code>[[Prototype]]</code> 就是 <code>Function.prototype</code>。</li>\n</ul>\n<hr>\n<h3>4. 结论</h3>\n<p>由于 <code>Function</code> 本身是一个函数，它的 <code>[[Prototype]]</code> 就是 <code>Function.prototype</code>，所以：</p>\n<pre><code class="language-javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span>\n</code></pre>\n<hr>\n<h3>5. 总结一句话</h3>\n<blockquote>\n<p><strong>因为 <code>Function</code> 是一个由自身构造的函数对象，所以它的原型链指向了它自己的 <code>prototype</code> 属性。</strong></p>\n</blockquote>\n<hr>\n<h3>6. 可视化结构（简化）</h3>\n<pre><code>Function\n├── constructor: Function\n├── __proto__ ─────┐\n└── prototype ─────┘\n</code></pre>\n<hr>\n<h3>7. 拓展：其他内置构造函数</h3>\n<p>类似地：</p>\n<pre><code class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span>\n<span class="hljs-title class_">Array</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span>\n<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span>\n</code></pre>\n<p>因为 <code>Object</code>、<code>Array</code>、<code>RegExp</code> 等都是由 <code>Function</code> 构造的函数对象。</p>\n</div>'</script></body></html>