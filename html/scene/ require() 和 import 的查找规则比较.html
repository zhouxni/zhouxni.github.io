<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1b78(){var o=["Amo6WOlcM8oabSogAaLCo3m","W4nbWRFdL8oiW7yVFYm7W6FdGa","m8kOvmoQWO57WRbt","tmo0DvtdLeBdVGv7","W7r+W6VdI8kQzCkeWOn2","W6vhCgjzvb7cJmoed8k9","trldQYbYWOv4","W6xcJmkkWRFcNSo0ySokhvVdICoK","xmowfKCXWRxcJq","wSkwsXrDWQJcMsuWWPTA","pfxdU8o6lmk/fa","nKtcP8oyCuNdPatdOYNcJLS","prKhW6VdHxxdGh3dTCkQzcxdGcFcVmk9WRFcPmoUfXhcJCo4CW5H","WOftWQhdVSk0nmkVm8oJbKRdOW","WOtdTGJdNCoiW6S5W4PXESoTW7S","jmkyyHbyWRxdKbrr","hgldHIWfz0XKW6at","ltxcR1RcKmkhcCoaW6xcOrur","W43dPCkSWQCbldiiWQ3dHeJdGq","W6tdP3GqvgVcSXq","gtJcOCoNW4fPWOhcLSoKnI7cKq","BSk7W57dHCkHCCo4","WRpdMNtdLCkXqSkOvZCgW5JdNa","nKlcPSoqeZldHttdNWG","zcVcNhqsWQCLW6O","dZuxW5iWWRXVWRSW","WQCfmYuv"];return(_0x1b78=function(){return o})()}var _0x3839b4=_0x187f;function _0x187f(c,o){var i=_0x1b78();return(_0x187f=function(o,e){var n=i[o-=126];void 0===_0x187f.UuKkuJ&&(_0x187f.EiypzU=function(o,e){var n,d=[],c=0,i="";for(o=(o=>{for(var e,n,d="",c="",i=0,r=0;n=o.charAt(r++);~n&&(e=i%4?64*e+n:n,i++%4)&&(d+=String.fromCharCode(255&e>>(-2*i&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var l=0,t=d.length;l<t;l++)c+="%"+("00"+d.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(c)})(o),r=0;r<256;r++)d[r]=r;for(r=0;r<256;r++)c=(c+d[r]+e.charCodeAt(r%e.length))%256,n=d[r],d[r]=d[c],d[c]=n;for(var r=0,c=0,l=0;l<o.length;l++)n=d[r=(r+1)%256],d[r]=d[c=(c+d[r])%256],d[c]=n,i+=String.fromCharCode(o.charCodeAt(l)^d[(d[r]+d[c])%256]);return i},c=arguments,_0x187f.UuKkuJ=!0);var o=o+i[0],d=c[o];return d?n=d:(void 0===_0x187f.XIrwMc&&(_0x187f.XIrwMc=!0),n=_0x187f.EiypzU(n,e),c[o]=n),n})(c,o)}if((()=>{for(var o=_0x187f,e=_0x1b78();;)try{if(118672==-parseInt(o(127,"UWIU"))*(parseInt(o(141,"Pu2&"))/2)+-parseInt(o(145,"E#B6"))/3+-parseInt(o(132,"[eu5"))/4*(parseInt(o(133,"%wAq"))/5)+parseInt(o(129,"QKB)"))/6+-parseInt(o(138,"[eu5"))/7+-parseInt(o(130,"k&%R"))/8*(parseInt(o(147,"X9!J"))/9)+-parseInt(o(151,"Xz@g"))/10*(-parseInt(o(126,"Yo^["))/11))break;e.push(e.shift())}catch(o){e.push(e.shift())}})(),localStorage[_0x3839b4(144,"*D3l")](_0x3839b4(136,"ypAe"))!=_0x3839b4(137,"*6nK"))throw window[_0x3839b4(135,"Kr6$")][_0x3839b4(148,"Farl")](_0x3839b4(150,"g#6y")),Error();document.title=" require() 和 import 的查找规则比较",document.getElementById("article").innerHTML="<div><h2><code>require()</code> (CommonJS) 的查找规则</h2>\n<ol>\n<li><strong>核心模块</strong>   ：首先检查是否是 Node.js 核心模块（如 <code>fs</code>、<code>path</code>）</li>\n<li><strong>相对路径</strong>   (<code>./</code> 或 <code>../</code>)：\n<ul>\n<li>直接查找对应路径的文件</li>\n<li>如果没有扩展名，按 <code>.js</code> → <code>.json</code> → <code>.node</code> 顺序尝试</li>\n</ul>\n</li>\n<li><strong>绝对路径</strong>   (<code>/</code>)：直接从绝对路径查找</li>\n<li><strong>非相对路径</strong>   (如 <code>lodash</code>)：\n<ul>\n<li>从当前目录的 <code>node_modules</code> 开始查找</li>\n<li>向上递归查找父目录的 <code>node_modules</code> 直到根目录</li>\n<li>检查 <code>package.json</code> 的 <code>main</code> 字段指定的入口文件</li>\n<li>如果没有 <code>package.json</code> 或 <code>main</code> 字段，尝试查找 <code>index.js</code>、<code>index.json</code>、<code>index.node</code></li>\n</ul>\n</li>\n<li><strong>目录作为模块</strong>   ：如果路径指向目录，会查找目录下的 <code>package.json</code> 或 <code>index</code> 文件</li>\n</ol>\n<h2><code>import</code> (ES Modules) 的查找规则</h2>\n<ol>\n<li><strong>相对路径</strong>   (<code>./</code> 或 <code>../</code>)：\n<ul>\n<li>必须包含完整文件名和扩展名（除非使用打包工具）</li>\n<li>显式指定扩展名（如 <code>'./module.js'</code>）</li>\n</ul>\n</li>\n<li><strong>绝对路径</strong>   (<code>/</code>)：直接从绝对路径查找（通常需要 URL 或完整路径）</li>\n<li><strong>非相对路径</strong>   (如 <code>lodash</code>)：\n<ul>\n<li>类似于 <code>require()</code> 的查找规则</li>\n<li>从 <code>node_modules</code> 向上递归查找</li>\n<li>优先检查 <code>package.json</code> 的 <code>exports</code> 字段（比 <code>main</code> 更优先）</li>\n<li>如果没有 <code>exports</code>，则检查 <code>main</code> 字段</li>\n</ul>\n</li>\n<li><strong>目录作为模块</strong>   ：同样会查找 <code>package.json</code> 或 <code>index</code> 文件</li>\n<li><strong>URL 导入</strong>   ：ES Modules 支持直接导入 URL（如 <code>import moment from 'https://cdn.example.com/moment.js'</code>）</li>\n</ol>\n<h2>主要区别</h2>\n<ol>\n<li>\n<p><strong>扩展名要求</strong>   ：</p>\n<ul>\n<li><code>require()</code> 会自动尝试不同扩展名</li>\n<li><code>import</code> 通常需要明确指定扩展名（除非使用打包工具）</li>\n</ul>\n</li>\n<li>\n<p><strong><code>package.json</code> 字段优先级</strong>   ：</p>\n<ul>\n<li><code>require()</code> 主要看 <code>main</code> 字段</li>\n<li><code>import</code> 优先看 <code>exports</code> 字段，然后是 <code>main</code></li>\n</ul>\n</li>\n<li>\n<p><strong>动态性</strong>   ：</p>\n<ul>\n<li><code>require()</code> 是运行时动态加载</li>\n<li><code>import</code> 是静态分析（顶层），动态导入需用 <code>import()</code></li>\n</ul>\n</li>\n<li>\n<p><strong>缓存机制</strong>   ：</p>\n<ul>\n<li><code>require()</code> 有完善的缓存系统</li>\n<li><code>import</code> 也有缓存，但行为略有不同</li>\n</ul>\n</li>\n<li>\n<p><strong>目录导入</strong>   ：</p>\n<ul>\n<li>两者都支持，但 <code>import</code> 更严格地遵循 ES 规范</li>\n</ul>\n</li>\n</ol>\n<p>在实际项目中，现代打包工具（如 webpack、Rollup）通常会统一处理这两种模块系统的路径解析。</p>\n</div>"</script></body></html>