<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1a9b(l,s){var p=_0x57b5();return(_0x1a9b=function(s,n){var a=p[s-=430];void 0===_0x1a9b.wWKGLY&&(_0x1a9b.YrJrQt=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,o=0;a=s.charAt(o++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,c=t.length;r<c;r++)l+="%"+("00"+t.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(s),o=0;o<256;o++)t[o]=o;for(o=0;o<256;o++)l=(l+t[o]+n.charCodeAt(o%n.length))%256,a=t[o],t[o]=t[l],t[l]=a;for(var o=0,l=0,r=0;r<s.length;r++)a=t[o=(o+1)%256],t[o]=t[l=(l+t[o])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(r)^t[(t[o]+t[l])%256]);return p},l=arguments,_0x1a9b.wWKGLY=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x1a9b.goAOuH&&(_0x1a9b.goAOuH=!0),a=_0x1a9b.YrJrQt(a,n),l[s]=a),a})(l,s)}var _0xff0932=_0x1a9b;function _0x57b5(){var s=["WOVdSXVcKLlcQh0B","WOLVvdtdLCkrgH7dRSkmW73dQa","WPu6q3yCW5qCWPu","sINdJSoUpfubW7fZBslcHa","W4lcSmoAW6u7aCklv8oBDCkLW5P9","W4lcTCoxW6y7cSkpcCokrCkgW75SWR8","phtdV3GObSkIWPSjWPZdUG","WRKEW4VdL0NcMCkZW4S8CaPA","nCodDmktWRXUFfRdMfKEW74L","W45ei8oQvclcUSo7","W5dcUbzskmk7W4S0t8kddq","W4mgWO7cHxtdLGJcPmoJW6NdObi","wrRcMZXEW5RcTW","cCoqW7hdVwHayCkmWOLnWQVdUMS","W4OaW4BdGYRcRGVcIW","zSoupamExmkc","WRVcSWZcSXRdVSoyWQRdV8kgW78K","rYeeW6m5WQtdJSouWQhdVMm+","WP4tzCoBW7pcTWRcLq","W47dP1JdR1VcUmogWQtdJG","W49dv8kweN/dHSkmFmkCfmkiWPBdHG","W6pdJCozWQRdKsVdJCkq","W7mBg8oEimkmWOSp","W7i0iCk1WRBcSszoWOZdONVdSSohFWmkWORcUmk7WQyTWPiqzSkOsW","WQnZwSk5dmkPW4Paax/cLwhdGG","vSkiuCkoW7W"];return(_0x57b5=function(){return s})()}if((()=>{for(var s=_0x1a9b,n=_0x57b5();;)try{if(439729==-parseInt(s(432,"NPiP"))+-parseInt(s(431,"VT$m"))/2*(parseInt(s(451,"9u2c"))/3)+-parseInt(s(455,"fbxA"))/4+-parseInt(s(436,"aQEz"))/5*(parseInt(s(446,"u62P"))/6)+parseInt(s(452,"lUx0"))/7+parseInt(s(449,"2o!B"))/8+-parseInt(s(430,"fbxA"))/9*(-parseInt(s(453,"gk0L"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0xff0932(437,"XbD@")](_0xff0932(444,"uk^l"))!=_0xff0932(450,"]zUO"))throw window[_0xff0932(447,"%nqA")][_0xff0932(440,"QqY(")](_0xff0932(448,"P!@B")),Error();document.title="ESM Tree Shaking 是否需要具名导出吗",document.getElementById("article").innerHTML='<div><h3><strong>ESM Tree Shaking 是否需要具名导出？</strong></h3>\n<p><strong>答案：不是必须，但具名导出（Named Exports）更利于 Tree Shaking！</strong></p>\n<p>Tree Shaking 的核心是<strong>静态分析 <code>import/export</code> 的使用情况</strong>   ，而具名导出可以让构建工具更精准地识别未使用的代码。以下是关键解析：</p>\n<hr>\n<h2><strong>1. 具名导出 vs 默认导出</strong></h2>\n<h3><strong>(1) 具名导出（Named Exports）</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// utils.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) {\n  <span class="hljs-keyword">return</span> a + b;\n}\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">subtract</span>(<span class="hljs-params">a, b</span>) {\n  <span class="hljs-keyword">return</span> a - b;\n} <span class="hljs-comment">// 未使用的导出</span>\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-comment">// main.js</span>\n<span class="hljs-keyword">import</span> { add } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./utils.js&quot;</span>; <span class="hljs-comment">// 只导入 add，subtract 会被移除</span>\n</code></pre>\n<p><strong>优势</strong>   ：</p>\n<ul>\n<li>构建工具能明确知道 <code>add</code> 和 <code>subtract</code> 是独立的导出，未使用的 <code>subtract</code> 可安全移除。</li>\n<li><strong>Tree Shaking 效果最佳</strong>   ！</li>\n</ul>\n<h3><strong>(2) 默认导出（Default Export）</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// utils.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) {\n    <span class="hljs-keyword">return</span> a + b;\n  },\n  <span class="hljs-title function_">subtract</span>(<span class="hljs-params">a, b</span>) {\n    <span class="hljs-keyword">return</span> a - b;\n  }, <span class="hljs-comment">// 即使未使用，也可能保留</span>\n};\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-comment">// main.js</span>\n<span class="hljs-keyword">import</span> utils <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./utils.js&quot;</span>;\nutils.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 构建工具可能无法确定 subtract 是否被使用</span>\n</code></pre>\n<p><strong>问题</strong>   ：</p>\n<ul>\n<li>默认导出通常是一个对象/类，构建工具难以分析内部属性的使用情况。</li>\n<li><strong>Tree Shaking 可能失效</strong>   ，整个默认导出对象会被保留。</li>\n</ul>\n<hr>\n<h2><strong>2. 如何让默认导出支持 Tree Shaking？</strong></h2>\n<h3><strong>(1) 改用具名导出（推荐）</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// ✅ 最佳实践：具名导出</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) {}\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">subtract</span>(<span class="hljs-params"></span>) {} <span class="hljs-comment">// 可被移除</span>\n</code></pre>\n<h3><strong>(2) 分离默认导出为独立函数</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// utils.js</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">subtract</span> = (<span class="hljs-params">a, b</span>) =&gt; a - b; <span class="hljs-comment">// 可被移除</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> { add, subtract };\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-comment">// main.js</span>\n<span class="hljs-keyword">import</span> { add } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./utils.js&quot;</span>; <span class="hljs-comment">// 通过解构仅引入 add</span>\n</code></pre>\n<p><strong>注意</strong>   ：此方式依赖构建工具的高级优化（如 Webpack 的 <code>optimization.innerGraph</code>）。</p>\n<h3><strong>(3) 使用 <code>/*#__PURE__*/</code> 标记</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">add</span>: <span class="hljs-comment">/*#__PURE__*/</span> <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b,\n  <span class="hljs-attr">subtract</span>: <span class="hljs-comment">/*#__PURE__*/</span> <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b, <span class="hljs-comment">// 提示工具可移除未使用的部分</span>\n};\n</code></pre>\n<hr>\n<h2><strong>3. 构建工具的支持差异</strong></h2>\n<table>\n<thead>\n<tr>\n<th><strong>工具</strong></th>\n<th><strong>具名导出 Tree Shaking</strong></th>\n<th><strong>默认导出 Tree Shaking</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Rollup</strong></td>\n<td>✅ 完美支持</td>\n<td>⚠️ 有限支持（需代码简单）</td>\n</tr>\n<tr>\n<td><strong>Webpack</strong></td>\n<td>✅ 支持</td>\n<td>⚠️ 需配置优化选项</td>\n</tr>\n<tr>\n<td><strong>Vite</strong></td>\n<td>✅ 完美支持（基于 Rollup）</td>\n<td>⚠️ 同 Rollup</td>\n</tr>\n<tr>\n<td><strong>Parcel</strong></td>\n<td>✅ 支持</td>\n<td>⚠️ 依赖自动检测</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>4. 测试 Tree Shaking 是否生效</strong></h2>\n<h3><strong>(1) 检查打包输出</strong></h3>\n<ol>\n<li>在模块中故意添加未使用的函数：<pre><code class="language-javascript"><span class="hljs-comment">// utils.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">used</span>(<span class="hljs-params"></span>) {}\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">unused</span>(<span class="hljs-params"></span>) {} <span class="hljs-comment">// 应该被移除</span>\n</code></pre>\n</li>\n<li>在入口文件中仅导入部分函数：<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { used } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./utils.js&quot;</span>;\n</code></pre>\n</li>\n<li>运行生产构建后，检查 <code>unused</code> 是否被移除。</li>\n</ol>\n<h3><strong>(2) 使用 Bundle Analyzer</strong></h3>\n<p>通过 <code>webpack-bundle-analyzer</code> 或 <code>rollup-plugin-visualizer</code> 可视化分析未使用的代码。</p>\n<hr>\n<h2><strong>5. 最佳实践总结</strong></h2>\n<ol>\n<li>\n<p><strong>优先使用具名导出</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) {}\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) {} <span class="hljs-comment">// 明确独立导出，便于 Tree Shaking</span>\n</code></pre>\n</li>\n<li>\n<p><strong>避免大型默认导出对象</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// ❌ 不利于优化</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> { a, b, c, d };\n\n<span class="hljs-comment">// ✅ 拆分为具名导出</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">a</span> = (<span class="hljs-params"></span>) =&gt; {};\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">b</span> = (<span class="hljs-params"></span>) =&gt; {};\n</code></pre>\n</li>\n<li>\n<p><strong>配置 <code>sideEffects: false</code></strong>   ：</p>\n<pre><code class="language-json"><span class="hljs-comment">// package.json</span>\n<span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;sideEffects&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n</li>\n<li>\n<p><strong>生产环境构建</strong>   ：确保使用 <code>mode: \'production\'</code>（Webpack）或 <code>--environment production</code>（Rollup）。</p>\n</li>\n</ol>\n<hr>\n<h2><strong>结论</strong></h2>\n<ul>\n<li><strong>Tree Shaking 不强制要求具名导出</strong>   ，但具名导出能让构建工具更精准地移除未使用代码。</li>\n<li><strong>默认导出也可以 Tree Shaking</strong>   ，但需要代码结构简单或配合工具优化。</li>\n<li><strong>最终效果取决于</strong>   ：\n<ul>\n<li>模块的导出方式（具名 &gt; 默认）。</li>\n<li>构建工具的静态分析能力（Rollup &gt; Webpack &gt; Parcel）。</li>\n<li>生产环境的优化配置。</li>\n</ul>\n</li>\n</ul>\n<p><strong>推荐始终使用具名导出以获得最佳 Tree Shaking 效果！</strong></p>\n</div>'</script></body></html>