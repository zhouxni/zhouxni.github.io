<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2fb902=_0xf2e3;if((()=>{for(var n=_0xf2e3,s=_0x4424();;)try{if(942618==-parseInt(n(237,"G7&!"))+parseInt(n(226,"yCf9"))/2+parseInt(n(234,"5j7b"))/3+-parseInt(n(223,"sEG("))/4+parseInt(n(235,"py8m"))/5*(-parseInt(n(236,"G7&!"))/6)+-parseInt(n(239,"&1m3"))/7+parseInt(n(231,"mWrz"))/8*(parseInt(n(238,"dBEj"))/9))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x2fb902(229,"o9hM")](_0x2fb902(220,"5j7b"))!=_0x2fb902(221,"6VlE"))throw window[_0x2fb902(219,"9@3&")][_0x2fb902(217,"hxYP")](_0x2fb902(218,"sEG(")),Error();function _0xf2e3(r,n){var a=_0x4424();return(_0xf2e3=function(n,s){var t=a[n-=216];void 0===_0xf2e3.XWTvLg&&(_0xf2e3.nErEMD=function(n,s){var t,o=[],r=0,a="";for(n=(n=>{for(var s,t,o="",r="",a=0,e=0;t=n.charAt(e++);~t&&(s=a%4?64*s+t:t,a++%4)&&(o+=String.fromCharCode(255&s>>(-2*a&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var c=0,l=o.length;c<l;c++)r+="%"+("00"+o.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(r)})(n),e=0;e<256;e++)o[e]=e;for(e=0;e<256;e++)r=(r+o[e]+s.charCodeAt(e%s.length))%256,t=o[e],o[e]=o[r],o[r]=t;for(var e=0,r=0,c=0;c<n.length;c++)t=o[e=(e+1)%256],o[e]=o[r=(r+o[e])%256],o[r]=t,a+=String.fromCharCode(n.charCodeAt(c)^o[(o[e]+o[r])%256]);return a},r=arguments,_0xf2e3.XWTvLg=!0);var n=n+a[0],o=r[n];return o?t=o:(void 0===_0xf2e3.ehjSec&&(_0xf2e3.ehjSec=!0),t=_0xf2e3.nErEMD(t,s),r[n]=t),t})(r,n)}function _0x4424(){var n=["WOXOAmo3nKursapcNvFdHNm","W5uGW7RdN8kdsHxcSfWunG","cSkfyIdcLWfSW4byW6C","cSkmAsxdG2u4W5XaW5nce14","bGxcG8kIzJzC","xIySWPvvdqGdW4jWWQLsfa","W6b9eSkQCZJdVSk3pCkpEa","r2xcLwOApgK","smoPW5jOW4P3WOldR8kBDNHyn8o1ASk9WOpcJ8khycGxiwOJyG","rmoXmdZdU8oRW6ZdTG","W74ZpmkRDG9Szsi","WOO8W6rNka","gSkSyw/cV8k2WRpcOgXFWRywbtu","eSkPWPaHWO19WP3cG8kJvNL9ja","BttcSSoGlKFcGmk6cHpcKJS4","fMffva3dRLChxHqfW48M","BmoTW7PMWQrhc2akbXFdRSkE","W6GvrwJcJdXW","WO8ai8oWWRddHfNcMmo5WPZcN8kYW54","W44rW4VcHmkNe3u","WQVdOCozWOmBWO/dGqNcIYZcSu/dOa","W47cOWNcMSkkwMlcIConkCkwW5xcVMa","WO5HzSo6yYHbrrdcMW","xsKjkhVdTmoQW4KiW7pdH2xcLW"];return(_0x4424=function(){return n})()}document.title="React 的并发模式（Concurrent Mode）中，即使高优先级任务完成了协调（Reconciliation），React 也不会立即更新 DOM",document.getElementById("article").innerHTML='<div><p>是的，你的理解完全正确！在 React 的并发模式（Concurrent Mode）中，<strong>即使高优先级任务完成了协调（Reconciliation），React 也不会立即更新 DOM</strong>  。所有对 DOM 的更新都会等到 <strong>整个 Fiber 树的协调阶段完成</strong>  ，并在 <strong>提交阶段（Commit Phase）一次性替换 Current 树</strong>  ，然后统一应用到 DOM。这是 React Fiber 架构的核心设计之一，目的是保证 UI 的一致性和渲染的高效性。</p>\n<hr>\n<h2><strong>详细流程解析</strong></h2>\n<h3><strong>1. Fiber 架构的双缓冲机制</strong></h3>\n<p>React 使用 <strong>双缓冲技术（Double Buffering）</strong>   来管理 Fiber 树：</p>\n<ul>\n<li><strong><code>Current</code> 树</strong>  ：当前正在屏幕上显示的 Fiber 树。</li>\n<li><strong><code>WorkInProgress</code> 树</strong>  ：正在内存中构建的新 Fiber 树（协调阶段生成）。</li>\n</ul>\n<p><strong>关键点</strong>  ：</p>\n<ul>\n<li><strong>协调阶段（Reconciliation）</strong>   只修改 <code>WorkInProgress</code> 树，不会影响 <code>Current</code> 树。</li>\n<li><strong>提交阶段（Commit）</strong>   会 <strong>原子性（Atomic）</strong>   地替换 <code>Current</code> 树为 <code>WorkInProgress</code> 树，并更新 DOM。</li>\n</ul>\n<hr>\n<h3><strong>2. 高优先级任务的执行流程</strong></h3>\n<p>假设有一个 <strong>高优先级任务（如 <code>SyncLane</code>）</strong>   和一个 <strong>低优先级任务（如 <code>TransitionLane</code>）</strong>  ：</p>\n<h4><strong>(1) 调度阶段（Scheduler）</strong></h4>\n<ul>\n<li>高优先级任务（如用户点击）会 <strong>抢占</strong>   低优先级任务（如数据加载）。</li>\n<li>React 会 <strong>暂停</strong>   低优先级任务的协调，优先处理高优先级任务。</li>\n</ul>\n<h4><strong>(2) 协调阶段（Reconciliation）</strong></h4>\n<ul>\n<li><strong>高优先级任务</strong>   在 <code>WorkInProgress</code> 树上完成协调（Diffing + 副作用标记）。</li>\n<li><strong>低优先级任务</strong>   可能被 <strong>部分丢弃</strong>   或 <strong>重新调度</strong>  。</li>\n</ul>\n<h4><strong>(3) 提交阶段（Commit）</strong></h4>\n<ul>\n<li><strong>不会立即提交</strong>  ：即使高优先级任务完成了协调，React 也不会立即更新 DOM。</li>\n<li><strong>等待所有协调完成</strong>  ：React 会确保当前批次的所有协调工作完成（可能包含多个优先级任务）。</li>\n<li><strong>原子性替换</strong>  ：\n<ul>\n<li>将 <code>WorkInProgress</code> 树 <strong>一次性替换</strong>   为 <code>Current</code> 树。</li>\n<li><strong>同步执行 DOM 更新</strong>  （不可中断），确保 UI 一致性。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>3. 为什么 React 不立即更新 DOM？</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>原因</strong></th>\n<th><strong>解释</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>避免视觉撕裂</strong></td>\n<td>如果高优先级任务直接更新 DOM，而低优先级任务还在协调，可能导致 UI 不一致（如按钮状态更新了，但列表还没变）。</td>\n</tr>\n<tr>\n<td><strong>批量更新优化</strong></td>\n<td>React 会合并多个状态更新，减少不必要的 DOM 操作，提高性能。</td>\n</tr>\n<tr>\n<td><strong>并发模式安全</strong></td>\n<td>确保高优先级任务不会破坏低优先级任务的中间状态。</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>4. 特殊情况：<code>flushSync</code> 强制同步更新</strong></h3>\n<p>如果确实需要 <strong>立即更新 DOM</strong>  （极少情况），可以使用 <code>ReactDOM.flushSync</code>：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { flushSync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;\n\n<span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">setState</span>(newState); <span class="hljs-comment">// 强制同步协调 + 同步提交</span>\n});\n</code></pre>\n<p><strong>影响</strong>  ：</p>\n<ul>\n<li>会 <strong>打断并发模式</strong>   的优化，可能导致性能下降。</li>\n<li>仅用于极端情况（如测量 DOM 布局）。</li>\n</ul>\n<hr>\n<h3><strong>5. 代码示例</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);\n\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;回调立即执行&quot;</span>);\n    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>); <span class="hljs-comment">// 高优先级更新（SyncLane）</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;协调完成，但 DOM 还未更新&quot;</span>);\n  };\n\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;DOM 已更新（Commit Phase）&quot;</span>);\n  }, [count]);\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>Count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n</code></pre>\n<p><strong>输出顺序</strong>  ：</p>\n<ol>\n<li><code>回调立即执行</code>（同步）</li>\n<li><code>协调完成，但 DOM 还未更新</code>（协调阶段完成）</li>\n<li><code>DOM 已更新（Commit Phase）</code>（提交阶段）</li>\n</ol>\n<hr>\n<h2><strong>总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th><strong>阶段</strong></th>\n<th><strong>行为</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>协调阶段</strong></td>\n<td>高优先级任务可以抢占低优先级任务，但只修改 <code>WorkInProgress</code> 树，不影响 DOM。</td>\n</tr>\n<tr>\n<td><strong>提交阶段</strong></td>\n<td>所有协调完成后，React <strong>一次性替换 <code>Current</code> 树</strong>  ，并同步更新 DOM。</td>\n</tr>\n<tr>\n<td><strong>DOM 更新</strong></td>\n<td>不会因高优先级任务而立即更新，必须等待提交阶段完成。</td>\n</tr>\n</tbody>\n</table>\n<p>这种设计确保了：\n✅ <strong>UI 一致性</strong>  （无视觉撕裂）<br>\n✅ <strong>高性能渲染</strong>  （批量更新）<br>\n✅ <strong>并发模式安全</strong>  （可中断渲染）</p>\n<p>所以，<strong>即使高优先级任务完成了协调，React 也不会立即更新 DOM，而是等待整个 Fiber 树协调完成，再在提交阶段统一替换并渲染</strong>  。</p>\n</div>'</script></body></html>