<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x491333=_0x538b;function _0x538b(r,n){var l=_0x4f4d();return(_0x538b=function(n,t){var e=l[n-=455];void 0===_0x538b.leufHP&&(_0x538b.Qcfjyg=function(n,t){var e,o=[],r=0,l="";for(n=(n=>{for(var t,e,o="",r="",l=0,i=0;e=n.charAt(i++);~e&&(t=l%4?64*t+e:e,l++%4)&&(o+=String.fromCharCode(255&t>>(-2*l&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var c=0,d=o.length;c<d;c++)r+="%"+("00"+o.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(r)})(n),i=0;i<256;i++)o[i]=i;for(i=0;i<256;i++)r=(r+o[i]+t.charCodeAt(i%t.length))%256,e=o[i],o[i]=o[r],o[r]=e;for(var i=0,r=0,c=0;c<n.length;c++)e=o[i=(i+1)%256],o[i]=o[r=(r+o[i])%256],o[r]=e,l+=String.fromCharCode(n.charCodeAt(c)^o[(o[i]+o[r])%256]);return l},r=arguments,_0x538b.leufHP=!0);var n=n+l[0],o=r[n];return o?e=o:(void 0===_0x538b.hWpXPG&&(_0x538b.hWpXPG=!0),e=_0x538b.Qcfjyg(e,t),r[n]=e),e})(r,n)}function _0x4f4d(){var n=["WRXghJC9WQxcJszFee3cUvq","tColxmo7waRdUxRcPbBcUmoc","i8kbpfBdUJtdOmkQW4BdIY9dWQ0","C07dMCk7WQVcH8oQW7RcOdRdHwZcOW","k8kVo30oWP/dOSo4WQT6W7K4WPq","h03dVSkLvCkyW7u","WQmcoHtcOCkOWOXE","W6HRzuXJWRCe","pMddKcyMWOVcUG","W7CNlWpcVmkTWOG","WO9WW6RdIbe4j1aQW459xSos","gCopFaubWR5o","t8ksohXaW6HkkqhcQeBdTa","mGLwBSkToxJdQ8osWQrDlCkU","Ab3cKMxdRSkrmq","C8kNsutdUX7dV0VdUb7cUCo6","wmokW5aVW48","W7eRWRVcUJCJwmoXcK8HsSksW65UjmkgyCoTWOasdCkjW5BdTXq","WRzTW45hWQ7cNCoOW63dUMhcVSoHAa","W5lcQCkWqItcGmkpcNWvEWij","bCofWOdcJM5fWOK","W5BcMSkTCXjhWQ7dUmkrzCoqW6JdTG","bSorWRRcTvf1WOy","WPfcCf95WQGKW4hdRq","WObZW6OJuZDfW6JcLttcTCkxgG"];return(_0x4f4d=function(){return n})()}if((()=>{for(var n=_0x538b,t=_0x4f4d();;)try{if(876114==-parseInt(n(465,"sekL"))*(-parseInt(n(471,"&X^0"))/2)+-parseInt(n(479,"tpX2"))/3*(-parseInt(n(461,"!%)f"))/4)+-parseInt(n(468,"SZwI"))/5+parseInt(n(477,"Dpc]"))/6*(-parseInt(n(469,"2ysC"))/7)+parseInt(n(463,"]!oW"))/8+parseInt(n(466,"Fv7P"))/9+parseInt(n(467,"J@sE"))/10)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x491333(475,"QVAJ")](_0x491333(462,"&X^0"))!=_0x491333(455,"Ma89"))throw window[_0x491333(470,"CyDc")][_0x491333(478,"d2s7")](_0x491333(456,"*APG")),Error();document.title="Vite 的热模块更新",document.getElementById("article").innerHTML="<div><p>是的，Vite 的热模块更新（HMR，Hot Module Replacement）确实是通过 <strong>WebSocket 与浏览器建立通信</strong>   来实现的。以下是其实现原理、工作流程及相关细节的详细说明：</p>\n<h3>一、Vite HMR 的通信基础：WebSocket</h3>\n<h4>1. <strong>WebSocket 的作用</strong></h4>\n<p>Vite 的开发服务器（<code>vite dev</code>）启动时会创建一个 WebSocket 服务器，与浏览器建立持久化连接。这个连接用于：</p>\n<ul>\n<li>向浏览器推送文件变更通知（如代码修改、配置更新）。</li>\n<li>接收浏览器的模块状态反馈（如模块是否已更新、是否需要重新加载）。</li>\n</ul>\n<h4>2. <strong>与传统轮询的区别</strong></h4>\n<ul>\n<li><strong>轮询（Polling）</strong>  ：浏览器定时向服务器请求更新，效率低且浪费资源。</li>\n<li><strong>WebSocket</strong>  ：双向实时通信，服务器可主动推送消息，无需浏览器频繁请求，性能更优。</li>\n</ul>\n<h3>二、Vite HMR 的工作流程（基于 WebSocket）</h3>\n<ol>\n<li><strong>初始化连接</strong>\n<ul>\n<li>浏览器加载页面时，Vite 注入的客户端脚本（<code>vite/client</code>）会自动与服务器建立 WebSocket 连接。</li>\n<li>连接成功后，服务器会向浏览器发送当前项目的模块信息（如文件路径、依赖关系）。</li>\n</ul>\n</li>\n<li><strong>文件变更触发更新</strong>\n<ul>\n<li>当开发者修改代码并保存时，Vite 会检测到文件变更：\n<ul>\n<li>若为 CSS、图片等资源，直接通过 WebSocket 推送更新后的内容到浏览器，无需刷新页面。</li>\n<li>若为 JavaScript 模块，Vite 会重新编译该模块，并通过 WebSocket 通知浏览器“需要更新特定模块”。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>模块热更新执行</strong>\n<ul>\n<li>浏览器接收到 WebSocket 消息后，会根据模块类型执行不同操作：\n<ul>\n<li><strong>无状态模块（如样式）</strong>  ：直接替换样式表，界面实时更新。</li>\n<li><strong>有状态模块（如 React 组件）</strong>  ：通过 HMR API（如 <code>module.hot.accept</code>）触发组件更新，保留页面状态（如表单输入）。</li>\n</ul>\n</li>\n<li>若模块更新导致依赖链断裂（如删除了某个导出），则会通过 WebSocket 通知浏览器刷新整个页面。</li>\n</ul>\n</li>\n</ol>\n<h3>三、Vite HMR 与 Webpack HMR 的对比</h3>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>Vite HMR（WebSocket）</th>\n<th>Webpack HMR（WebSocket 或轮询）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>通信方式</strong></td>\n<td>仅使用 WebSocket（默认）</td>\n<td>支持 WebSocket（需配置）或轮询（默认）</td>\n</tr>\n<tr>\n<td><strong>更新粒度</strong></td>\n<td>更精细（模块级更新优先级更高）</td>\n<td>依赖配置，可能需要更多插件支持</td>\n</tr>\n<tr>\n<td><strong>性能表现</strong></td>\n<td>启动快、更新响应迅速（无冗余打包）</td>\n<td>冷启动慢，更新时需重新构建部分模块</td>\n</tr>\n<tr>\n<td><strong>配置复杂度</strong></td>\n<td>开箱即用，无需额外配置</td>\n<td>需手动配置 HMR 插件（如 <code>HotModuleReplacementPlugin</code>）</td>\n</tr>\n</tbody>\n</table>\n<h3>四、Vite HMR 的优化与特点</h3>\n<ol>\n<li><strong>基于 ESBuild 的快速编译</strong>\n<ul>\n<li>文件变更时，Vite 利用 ESBuild（Go 语言编写）快速编译更新的模块，再通过 WebSocket 推送结果，减少等待时间。</li>\n</ul>\n</li>\n<li><strong>模块缓存与依赖优化</strong>\n<ul>\n<li>Vite 会缓存已编译的模块依赖，仅重新编译变更的文件，通过 WebSocket 精准通知浏览器更新对应模块，避免全量刷新。</li>\n</ul>\n</li>\n<li><strong>框架集成优化</strong>\n<ul>\n<li>对主流框架（如 React、Vue）提供专属 HMR 支持：\n<ul>\n<li>Vue：通过 WebSocket 推送组件更新，保留组件状态。</li>\n<li>React：配合 <code>react-refresh</code> 插件，通过 WebSocket 实现组件热更新。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3>五、如何验证 Vite HMR 的 WebSocket 通信？</h3>\n<ol>\n<li><strong>浏览器开发者工具</strong>\n<ul>\n<li>打开 Chrome 开发者工具，切换到 <strong>Network</strong>   标签，筛选 <strong>WebSocket</strong>   类型，可看到 <code>ws://localhost:3000/@vite/client</code> 连接（端口号可能不同）。</li>\n<li>修改代码时，会看到该 WebSocket 连接发送 <code>update</code> 或 <code>reload</code> 消息。</li>\n</ul>\n</li>\n<li><strong>查看 Vite 日志</strong>\n<ul>\n<li>终端运行 <code>vite dev</code> 时，控制台会输出 <code>WebSocket server running at ws://...</code>，表明 WebSocket 已启动。</li>\n</ul>\n</li>\n</ol>\n<h3>六、总结</h3>\n<p>Vite 的 HMR 功能依托 WebSocket 实现了高效的客户端-服务器通信，结合 ESBuild 的快速编译和模块级更新策略，显著提升了开发体验。相比传统打包工具，其“实时推送变更”的机制避免了频繁刷新页面，尤其适合需要快速迭代的中大型项目。如果需要自定义 HMR 行为（如忽略特定文件变更），可通过 Vite 的 <code>server.hmr</code> 配置项或框架专属插件进行调整。</p>\n</div>"</script></body></html>