<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x55503f=_0x1656;function _0xb583(){var n=["lqZcI8k0WP/dVCouveu3g8oE","W5xdNCk8a8kUW7RdKG","WRRcVY04W6rBBIb2","WR3cHqxcIeFcNqCac3yCW4iJ","smkcwmkVwhZdUCkheSkrWQxdRv8qyxjcqJmWW4VcHqNdHmk7xq","WPRcV3CSFvmmesdcMWpdJmoT","W64bW59NA8kEvG","fvCXy8kuW4ldUvNdKCkk","W59ZnSoRWPNcQCoZWRxcLtO","WOLWDSksoCoTWR4gW6VcPa","W5r/WRHWcvtdOMz7vSkAWR7cVq","WOBcRt8DpHWpW49TpCkJW5FcKW","nMJcNxFdJmkVFt7cJSkFzGhcQq","wSonzdJcLComu8ocjG","v1G6AILxW4xdJ8k2nSkvqG","p8k+kutdOCk1ud90imoNcNu","k2j4W6jmW5VcNsalW6W","WRHqWPKCjSkQyt48r8kh","W7RdKhbmW6ddUt8","b8kWWONcKvFcP8on","WPNcUNmMCtrJnHRcSYG","FmoyWPDWW4Xckr7cUHddOCk0","tmkzt8k+xY/cUCog","rqGHkSoa","j8oppvJdQmkIds9J","rmktbSkuw2tcNeGNaSo2uq"];return(_0xb583=function(){return n})()}function _0x1656(l,n){var o=_0xb583();return(_0x1656=function(n,s){var t=o[n-=188];void 0===_0x1656.VPUHVn&&(_0x1656.GYiOVV=function(n,s){var t,a=[],l=0,o="";for(n=(n=>{for(var s,t,a="",l="",o=0,r=0;t=n.charAt(r++);~t&&(s=o%4?64*s+t:t,o++%4)&&(a+=String.fromCharCode(255&s>>(-2*o&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var c=0,e=a.length;c<e;c++)l+="%"+("00"+a.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(n),r=0;r<256;r++)a[r]=r;for(r=0;r<256;r++)l=(l+a[r]+s.charCodeAt(r%s.length))%256,t=a[r],a[r]=a[l],a[l]=t;for(var r=0,l=0,c=0;c<n.length;c++)t=a[r=(r+1)%256],a[r]=a[l=(l+a[r])%256],a[l]=t,o+=String.fromCharCode(n.charCodeAt(c)^a[(a[r]+a[l])%256]);return o},l=arguments,_0x1656.VPUHVn=!0);var n=n+o[0],a=l[n];return a?t=a:(void 0===_0x1656.YKrqDg&&(_0x1656.YKrqDg=!0),t=_0x1656.GYiOVV(t,s),l[n]=t),t})(l,n)}if((()=>{for(var n=_0x1656,s=_0xb583();;)try{if(477551==-parseInt(n(188,"Bzge"))+parseInt(n(198,"y%ry"))/2*(parseInt(n(190,"3iO%"))/3)+parseInt(n(212,"8Jc#"))/4*(parseInt(n(193,"xWqV"))/5)+parseInt(n(203,"R4hR"))/6+-parseInt(n(205,"diN("))/7+-parseInt(n(200,"&zvT"))/8+parseInt(n(191,"k%ec"))/9*(-parseInt(n(207,"teR$"))/10))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x55503f(206,"k%ec")](_0x55503f(202,"G1#n"))!=_0x55503f(197,"$RLL"))throw window[_0x55503f(196,"zv4J")][_0x55503f(201,"$&O%")](_0x55503f(204,"zv4J")),Error();document.title="React 的协调（Reconciliation）过程中，核心的比较逻辑主要在“归”阶段完成",document.getElementById("article").innerHTML='<div><p>在 React 的协调（Reconciliation）过程中，<strong>Diff 比较发生在“递”和“归”两个阶段</strong>  ，但核心的比较逻辑主要在**“归”阶段**  完成。这是由 React 的递归遍历算法和 Diff 策略决定的。</p>\n<h3><strong>1. React 协调的递归遍历过程</strong></h3>\n<p>React 使用<strong>深度优先搜索（DFS）</strong>  遍历虚拟 DOM 树，这个过程分为两个阶段：</p>\n<ul>\n<li><strong>递（Traverse Down）</strong>  ：从根节点开始，递归进入每个子节点。</li>\n<li><strong>归（Traverse Up）</strong>  ：处理完所有子节点后，返回当前节点进行最终处理。</li>\n</ul>\n<pre><code>// 简化的递归遍历伪代码\nfunction reconcile(node) {\n  // 递：进入子节点\n  reconcileChildren(node);\n  \n  // 归：处理当前节点（包括 Diff）\n  return processCurrentNode(node);\n}\n</code></pre>\n<h3><strong>2. 为什么在“归”阶段进行核心 Diff？</strong></h3>\n<h4><strong>（1）需要子节点信息</strong></h4>\n<p>Diff 算法需要知道<strong>子节点的变化</strong>  才能正确处理当前节点。例如：</p>\n<ul>\n<li><strong>列表重排序</strong>  ：需要对比子节点的 key 和类型。</li>\n<li><strong>组件更新</strong>  ：需要子树的整体差异来决定是否复用组件实例。</li>\n</ul>\n<p>这些信息只有在<strong>遍历完所有子节点后</strong>  （即“归”阶段）才能获取。</p>\n<h4><strong>（2）复用组件实例的判断</strong></h4>\n<p>当比较两个组件时，React 需要决定是：</p>\n<ul>\n<li><strong>更新现有实例</strong>  （保留状态）</li>\n<li><strong>销毁并重建实例</strong>  （丢失状态）</li>\n</ul>\n<p>这个判断依赖于子树的整体结构，因此需要在“归”阶段汇总子节点信息后进行。</p>\n<h4><strong>（3）优化性能</strong></h4>\n<p>在“归”阶段进行 Diff 可以：</p>\n<ul>\n<li><strong>批量处理副作用</strong>  ：将子节点的变更合并，减少 DOM 操作次数。</li>\n<li><strong>避免重复计算</strong>  ：利用子节点的比较结果优化当前节点的处理。</li>\n</ul>\n<h3><strong>3. 示例：列表 Diff 过程</strong></h3>\n<p>假设有以下组件更新：</p>\n<pre><code class="language-jsx"><span class="hljs-comment">// 旧列表</span>\n&lt;ul&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>\n&lt;/ul&gt;\n\n<span class="hljs-comment">// 新列表</span>\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>\n</code></pre>\n<p>Diff 过程：</p>\n<ol>\n<li><strong>递阶段</strong>  ：\n<ul>\n<li>进入 <code>&lt;ul&gt;</code> 节点。</li>\n<li>递归处理子节点 <code>&lt;li key=&quot;a&quot;&gt;</code> 和 <code>&lt;li key=&quot;b&quot;&gt;</code>。</li>\n</ul>\n</li>\n<li><strong>归阶段</strong>  ：\n<ul>\n<li>比较新旧子节点列表：\n<ul>\n<li>发现 <code>key=&quot;a&quot;</code> 的节点被移除。</li>\n<li><code>key=&quot;b&quot;</code> 的节点位置变化。</li>\n<li>新增 <code>key=&quot;c&quot;</code> 的节点。</li>\n</ul>\n</li>\n<li>生成最小 DOM 操作序列（移动 <code>b</code>，删除 <code>a</code>，插入 <code>c</code>）。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>4. 特殊情况：提前终止 Diff</strong></h3>\n<p>在某些情况下，React 会在“递”阶段提前终止 Diff：</p>\n<ul>\n<li><strong>节点类型不同</strong>  （如 <code>&lt;div&gt;</code> → <code>&lt;span&gt;</code>），直接替换整个子树。</li>\n<li><strong>组件类型不同</strong>  ，销毁旧组件实例。</li>\n</ul>\n<p>但这些都是基于当前节点的信息，无需等待子节点处理完成。而复杂的比较（如列表重排序）仍需在“归”阶段完成。</p>\n<h3><strong>总结</strong></h3>\n<p>React 在“归”阶段进行核心 Diff 比较，是因为：</p>\n<ol>\n<li>需要子节点的完整信息来决定当前节点的处理方式。</li>\n<li>复用组件实例和列表 Diff 等逻辑依赖子树的整体结构。</li>\n<li>可以优化性能，批量处理变更。</li>\n</ol>\n<p>这是深度优先遍历算法和 React Diff 策略的自然结果，确保了高效且正确的虚拟 DOM 比较。</p>\n</div>'</script></body></html>