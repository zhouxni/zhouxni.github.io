<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x592855=_0x3ffb;function _0x3ffb(e,s){var l=_0x3c55();return(_0x3ffb=function(s,n){var a=l[s-=375];void 0===_0x3ffb.nRBlQl&&(_0x3ffb.rXFBNs=function(s,n){var a,t=[],e=0,l="";for(s=(s=>{for(var n,a,t="",e="",l=0,c=0;a=s.charAt(c++);~a&&(n=l%4?64*n+a:a,l++%4)&&(t+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,o=t.length;p<o;p++)e+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(s),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)e=(e+t[c]+n.charCodeAt(c%n.length))%256,a=t[c],t[c]=t[e],t[e]=a;for(var c=0,e=0,p=0;p<s.length;p++)a=t[c=(c+1)%256],t[c]=t[e=(e+t[c])%256],t[e]=a,l+=String.fromCharCode(s.charCodeAt(p)^t[(t[c]+t[e])%256]);return l},e=arguments,_0x3ffb.nRBlQl=!0);var s=s+l[0],t=e[s];return t?a=t:(void 0===_0x3ffb.WsatPH&&(_0x3ffb.WsatPH=!0),a=_0x3ffb.rXFBNs(a,n),e[s]=a),a})(e,s)}function _0x3c55(){var s=["WOr/W4BdOrZdJdBdVa","pGJdPr/dMNurpSobW5ddVSkyWOq","pqNdOXZdNNytESoSW6xdQ8kQWODs","WRxcGSknW6SmWQ3dNCopW4RdVa","WRhcGSkUw8k/","W7pdJSoOeCoZWRzlkmklW54iw8om","k8kMW53dI8oDW6qWwG","ECklW5uAA8kmW63dVmksWQq","pGJdSqhcGSowW7FdV8oRW5BdJdWIWOW","W4xcOu1tW4tcJ3GnWOZdUt9IbvtdNItcHCkTWP54ASkYsSoKW6bV","W5hdMX3cTItcGCoDWQ1oka","DxRdJSkfW4hdR8kFff0","WPxcKCoJjH7dQtRcJ8kOW7K","DSogAmkIWRRdV8kRc0BdKW","WRxcP8kFehRcOvK","W7lcJSkXtCoSCmoUC8kqC8kj","W5dcJSoDW4pcOXVcPG","W7fbW57cJmorW7tcKmkFimk3","o1hcKehdNSkaWO8","jaTQW7RcIHtcMCkuW7/cUghcT8oU","vCkwCSoujsBdSh1UlG","lmkzomo1WQddMCkolW","bWRdH8o4CLT8","W7ddUSozsc7cPKG0kMjm","fcnauK3cN8kE","W5/dLCkDWRZdH0ZcK8o/b8odE8k3","W7pcO8k8cNxcP3C","W7hcHmkWtSkGCSoFtmkgBa","W4FcHq7cHmkcdSkaW5pdGZFdKSotWPW","W4mKWOZcUfpcImojaCkNtSovWRC"];return(_0x3c55=function(){return s})()}if((()=>{for(var s=_0x3ffb,n=_0x3c55();;)try{if(940300==-parseInt(s(400,"^wfB"))*(parseInt(s(389,"[!o)"))/2)+parseInt(s(376,"aEO9"))/3+-parseInt(s(377,"O98G"))/4*(-parseInt(s(386,"1nZD"))/5)+-parseInt(s(383,"@7Ci"))/6*(parseInt(s(391,"6wBp"))/7)+parseInt(s(387,"$#vF"))/8*(-parseInt(s(402,"05XK"))/9)+parseInt(s(403,"05XK"))/10+parseInt(s(378,"$C%L"))/11*(parseInt(s(404,"hJhM"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x592855(395,"u%wc")](_0x592855(382,"t$G4"))!=_0x592855(375,"aEO9"))throw window[_0x592855(392,"zKBz")][_0x592855(385,"6CXr")](_0x592855(380,"h$It")),Error();document.title="vue router 嵌套层级的识别原理",document.getElementById("article").innerHTML='<div><p>在 Vue Router 中，<code>&lt;router-view&gt;</code> 组件能够正确识别嵌套层级并渲染对应的路由组件，是通过 <strong>组件实例的父子关系</strong>   和 <strong>路由匹配的深度</strong>   共同实现的。以下是其核心机制：</p>\n<hr>\n<h3><strong>1. 嵌套层级的识别原理</strong></h3>\n<h4><strong>(1) 依赖组件的渲染上下文</strong></h4>\n<p>每个 <code>&lt;router-view&gt;</code> 在渲染时，会通过 Vue 的 <strong>组件树结构</strong>   自动确定自己的嵌套层级：</p>\n<ul>\n<li><strong>父级 <code>&lt;router-view&gt;</code></strong>   先渲染，提供渲染上下文。</li>\n<li><strong>子级 <code>&lt;router-view&gt;</code></strong>   在父级渲染完成后，基于父级的路由匹配结果继续匹配更深层级的子路由。</li>\n</ul>\n<h4><strong>(2) 路由匹配的深度（<code>matched</code> 数组）</strong></h4>\n<p>Vue Router 在匹配路由时，会生成一个 <code>matched</code> 数组，按嵌套顺序存储所有匹配的路由记录。例如：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> routes = [\n  {\n    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/parent&#x27;</span>,\n    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Parent</span>,       <span class="hljs-comment">// 外层 &lt;router-view&gt; 渲染</span>\n    <span class="hljs-attr">children</span>: [\n      {\n        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;child&#x27;</span>,\n        <span class="hljs-attr">component</span>: <span class="hljs-title class_">Child</span>,    <span class="hljs-comment">// 内层 &lt;router-view&gt; 渲染</span>\n      }\n    ]\n  }\n];\n</code></pre>\n<p>当访问 <code>/parent/child</code> 时，<code>matched</code> 数组为：</p>\n<pre><code class="language-javascript">[\n  { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/parent&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Parent</span> },\n  { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/parent/child&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Child</span> }\n]\n</code></pre>\n<p><code>&lt;router-view&gt;</code> 根据自身的嵌套深度（<code>depth</code>）从 <code>matched</code> 数组中取出对应的组件渲染。</p>\n<hr>\n<h3><strong>2. 源码中的关键实现（简化版）</strong></h3>\n<p>Vue Router 通过以下逻辑确定层级：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 伪代码：&lt;router-view&gt; 的核心逻辑</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">RouterView</span> = <span class="hljs-title function_">defineComponent</span>({\n  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, { parent }</span>) {\n    <span class="hljs-comment">// 1. 获取当前路由实例</span>\n    <span class="hljs-keyword">const</span> router = <span class="hljs-title function_">inject</span>(routerKey);\n\n    <span class="hljs-comment">// 2. 计算当前嵌套深度</span>\n    <span class="hljs-keyword">let</span> depth = <span class="hljs-number">0</span>;\n    <span class="hljs-keyword">let</span> current = parent;\n    <span class="hljs-keyword">while</span> (current) {\n      <span class="hljs-comment">// 向上遍历父组件，统计遇到的 &lt;router-view&gt; 数量</span>\n      <span class="hljs-keyword">if</span> (current.<span class="hljs-property">type</span> === <span class="hljs-title class_">RouterView</span>) {\n        depth++;\n      }\n      current = current.<span class="hljs-property">parent</span>;\n    }\n\n    <span class="hljs-comment">// 3. 根据深度从 matched 数组中选择组件</span>\n    <span class="hljs-keyword">const</span> matchedRoute = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> router.<span class="hljs-property">currentRoute</span>.<span class="hljs-property">matched</span>[depth]);\n\n    <span class="hljs-comment">// 4. 渲染对应组件</span>\n    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">h</span>(matchedRoute.<span class="hljs-property">value</span>.<span class="hljs-property">components</span>?.<span class="hljs-property">default</span>);\n  }\n});\n</code></pre>\n<hr>\n<h3><strong>3. 实际场景示例</strong></h3>\n<h4><strong>场景 1：一级路由</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> routes = [\n  { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span> }  <span class="hljs-comment">// 深度 0</span>\n];\n</code></pre>\n<ul>\n<li>只有一个 <code>&lt;router-view&gt;</code>，渲染 <code>Home</code> 组件。</li>\n</ul>\n<h4><strong>场景 2：嵌套路由</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> routes = [\n  {\n    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>,\n    <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserLayout</span>,  <span class="hljs-comment">// 深度 0</span>\n    <span class="hljs-attr">children</span>: [\n      {\n        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;profile&#x27;</span>,\n        <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserProfile</span>,  <span class="hljs-comment">// 深度 1</span>\n        <span class="hljs-attr">children</span>: [\n          { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;settings&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Settings</span> }  <span class="hljs-comment">// 深度 2</span>\n        ]\n      }\n    ]\n  }\n];\n</code></pre>\n<ul>\n<li><strong>外层 <code>&lt;router-view&gt;</code></strong>  （深度 0） → 渲染 <code>UserLayout</code>。</li>\n<li><strong>内层 <code>&lt;router-view&gt;</code></strong>  （深度 1） → 在 <code>UserLayout</code> 内部渲染 <code>UserProfile</code>。</li>\n<li><strong>最内层 <code>&lt;router-view&gt;</code></strong>  （深度 2） → 在 <code>UserProfile</code> 内部渲染 <code>Settings</code>。</li>\n</ul>\n<hr>\n<h3><strong>4. 开发者注意事项</strong></h3>\n<h4><strong>(1) 确保层级匹配</strong></h4>\n<ul>\n<li>嵌套路由的组件模板中必须包含 <code>&lt;router-view&gt;</code>，否则子路由无法渲染：<pre><code class="language-html"><span class="hljs-comment">&lt;!-- UserLayout.vue --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>User Layout<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 子路由在此渲染 --&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n</li>\n</ul>\n<h4><strong>(2) 命名视图的层级</strong></h4>\n<p>如果使用命名视图（如 <code>&lt;router-view name=&quot;sidebar&quot;&gt;</code>），需在路由配置中明确指定：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> routes = [\n  {\n    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,\n    <span class="hljs-attr">components</span>: {\n      <span class="hljs-attr">default</span>: <span class="hljs-title class_">Home</span>,      <span class="hljs-comment">// &lt;router-view&gt;</span>\n      <span class="hljs-attr">sidebar</span>: <span class="hljs-title class_">Sidebar</span>    <span class="hljs-comment">// &lt;router-view name=&quot;sidebar&quot;&gt;</span>\n    }\n  }\n];\n</code></pre>\n<h4><strong>(3) 动态路由的深度</strong></h4>\n<p>动态路由（如 <code>path: \'/user/:id\'</code>）的嵌套层级规则与静态路由一致。</p>\n<hr>\n<h3><strong>5. 常见问题解答</strong></h3>\n<h4><strong>Q1: 为什么子路由不渲染？</strong></h4>\n<p>A: 检查父组件模板是否包含 <code>&lt;router-view&gt;</code>，且路由配置的 <code>children</code> 正确嵌套。</p>\n<h4><strong>Q2: 如何跳过某些层级？</strong></h4>\n<p>A: 直接访问深层路由（如 <code>/user/profile/settings</code>）会自动按深度匹配，无需手动跳过。</p>\n<h4><strong>Q3: 能否手动控制层级？</strong></h4>\n<p>A: 一般不推荐，但可通过 <code>provide/inject</code> 覆盖默认的 <code>depth</code> 计算逻辑（高级用法）。</p>\n<hr>\n<h3><strong>总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th>机制</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>组件树遍历</strong></td>\n<td><code>&lt;router-view&gt;</code> 通过父组件链统计嵌套深度。</td>\n</tr>\n<tr>\n<td><strong><code>matched</code> 数组</strong></td>\n<td>路由匹配结果按层级存储，<code>&lt;router-view&gt;</code> 根据深度选择对应记录。</td>\n</tr>\n<tr>\n<td><strong>命名视图</strong></td>\n<td>通过 <code>name</code> 属性匹配路由配置中的命名组件，不影响层级计算。</td>\n</tr>\n</tbody>\n</table>\n<p>通过这种设计，Vue Router 实现了灵活的嵌套路由支持，开发者只需关注路由配置和组件结构即可。</p>\n</div>'</script></body></html>