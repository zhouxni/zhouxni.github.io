<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x69129e=_0x23c3;function _0x23c3(l,s){var o=_0x5786();return(_0x23c3=function(s,n){var t=o[s-=473];void 0===_0x23c3.VEwLHo&&(_0x23c3.YqbqkR=function(s,n){var t,a=[],l=0,o="";for(s=(s=>{for(var n,t,a="",l="",o=0,r=0;t=s.charAt(r++);~t&&(n=o%4?64*n+t:t,o++%4)&&(a+=String.fromCharCode(255&n>>(-2*o&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var e=0,p=a.length;e<p;e++)l+="%"+("00"+a.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(l)})(s),r=0;r<256;r++)a[r]=r;for(r=0;r<256;r++)l=(l+a[r]+n.charCodeAt(r%n.length))%256,t=a[r],a[r]=a[l],a[l]=t;for(var r=0,l=0,e=0;e<s.length;e++)t=a[r=(r+1)%256],a[r]=a[l=(l+a[r])%256],a[l]=t,o+=String.fromCharCode(s.charCodeAt(e)^a[(a[r]+a[l])%256]);return o},l=arguments,_0x23c3.VEwLHo=!0);var s=s+o[0],a=l[s];return a?t=a:(void 0===_0x23c3.ZycBlb&&(_0x23c3.ZycBlb=!0),t=_0x23c3.YqbqkR(t,n),l[s]=t),t})(l,s)}function _0x5786(){var s=["WRqTW5pcVGmjjCkM","W7SHWPRdR0BcG8kHWRaQWQ9EWOa","D8kQWR9dWR8mwtjyW45aW5JdUW","W7vdW7XbBtLYevS","eColwIyuW4aDW6xdOgK","W6vUWO0eWQZdNSk0W5m9W7PB","tSktd3ioW6uvW6u","W6RdH2pdVbxcVCkDcG","DmkXuqG7uCo8","wfyroCkFjNjMWQxcSG8vlmoW","eCojxse5W7KtW5/dLvK","FJ4Bh8knEYlcJG","ECkidSktW6bwmSoKW6lcGMuMW5FdRa","WRBcNJ/cIqDbi8oHWOO","W7ZcMsvWoSohAa/cPWVcJW","yuFcQSkUW5FcVCotAa","uSkjh2ad","W7KKWP7dQKVcG8odW4GpWRzPWQpcRYi","ac3cUSoeWP05W4FdTK/dOCkeW7zpWQ8","W5xdOtXGW7jqW60pW71tbxyu","jam/xSoIfmkXW7NcQCoDfCo9dq","jhGQlmkUexVdQmkPWOZcHu9QW4erW6mzWR7dNmkTWQi7W6SCW7RcJq","WRtcGmoNW7CnW5a+echcPW","w15QFxKpW4hdMCkjWPrlbq","WR5bEmoSbwddOCoeW6BcQW","ia05w8oMhCk1W7hcVmoAl8opnW","W60/kSkxhmk5xLJcIa","WRe+W418W6ddI8k6"];return(_0x5786=function(){return s})()}if((()=>{for(var s=_0x23c3,n=_0x5786();;)try{if(872595==-parseInt(s(493,"Gfh]"))*(parseInt(s(487,"n98S"))/2)+parseInt(s(490,"N&zS"))/3*(-parseInt(s(482,"mS1O"))/4)+-parseInt(s(489,"^!Tz"))/5*(parseInt(s(500,"B8Fs"))/6)+-parseInt(s(477,"N30%"))/7+parseInt(s(483,"oJ^r"))/8+-parseInt(s(476,"#Skz"))/9+parseInt(s(475,"n98S"))/10*(parseInt(s(473,"YJLR"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x69129e(485,"L9sh")](_0x69129e(484,"Zm9r"))!=_0x69129e(474,"N&zS"))throw window[_0x69129e(492,"N&zS")][_0x69129e(494,"y4XA")](_0x69129e(479,"zuH1")),Error();document.title="TypeScript 中命名空间与模块的区别",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<strong>命名空间（Namespace）</strong>   和 <strong>模块（Module）</strong>   是两种用于组织代码的机制，它们各自有不同的用途和适用场景。以下是它们之间的详细区别：</p>\n<hr>\n<h3><strong>1. 定义与语法</strong></h3>\n<h4><strong>命名空间（Namespace）</strong></h4>\n<ul>\n<li><strong>定义</strong>  ：使用 <code>namespace</code> 关键字定义。</li>\n<li><strong>语法</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">MyNamespace</span> {\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> value = <span class="hljs-number">42</span>;\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello from namespace!&quot;</span>);\n  }\n}\n</code></pre>\n</li>\n<li><strong>特点</strong>  ：命名空间内的成员默认是私有的，只有使用 <code>export</code> 导出的成员才能被外部访问。</li>\n</ul>\n<h4><strong>模块（Module）</strong></h4>\n<ul>\n<li><strong>定义</strong>  ：使用 <code>import</code> 和 <code>export</code> 关键字定义和使用。</li>\n<li><strong>语法</strong>  ：\n<ul>\n<li><strong>导出</strong>  ：<pre><code class="language-typescript"><span class="hljs-comment">// greeter.ts</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello from module!&quot;</span>);\n}\n</code></pre>\n</li>\n<li><strong>导入</strong>  ：<pre><code class="language-typescript"><span class="hljs-comment">// app.ts</span>\n<span class="hljs-keyword">import</span> { greet } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./greeter&#x27;</span>;\n<span class="hljs-title function_">greet</span>();\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>特点</strong>  ：模块内的成员默认是私有的，只有导出的成员才能被其他模块访问。</li>\n</ul>\n<hr>\n<h3><strong>2. 作用域与可访问性</strong></h3>\n<h4><strong>命名空间</strong></h4>\n<ul>\n<li><strong>作用域</strong>  ：全局作用域。命名空间内的成员在全局作用域内可用，但需要通过命名空间名称访问。</li>\n<li><strong>可访问性</strong>  ：未导出的成员是私有的，导出的成员可以在全局范围内通过命名空间名称访问。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">MyNamespace</span> {\n  <span class="hljs-keyword">const</span> privateVar = <span class="hljs-string">&quot;I am private&quot;</span>; <span class="hljs-comment">// 私有成员</span>\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> publicVar = <span class="hljs-string">&quot;I am public&quot;</span>; <span class="hljs-comment">// 导出成员</span>\n}\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">MyNamespace</span>.<span class="hljs-property">publicVar</span>); <span class="hljs-comment">// 输出：I am public</span>\n<span class="hljs-comment">// console.log(MyNamespace.privateVar); // 错误：属性 &#x27;privateVar&#x27; 是私有的</span>\n</code></pre>\n</li>\n</ul>\n<h4><strong>模块</strong></h4>\n<ul>\n<li><strong>作用域</strong>  ：局部作用域。模块内的成员默认是私有的，只有导出的成员才能被其他模块访问。</li>\n<li><strong>可访问性</strong>  ：模块之间的访问通过 <code>import</code> 和 <code>export</code> 实现，支持模块间的依赖管理。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-comment">// greeter.ts</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello from module!&quot;</span>);\n}\n\n<span class="hljs-comment">// app.ts</span>\n<span class="hljs-keyword">import</span> { greet } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./greeter&#x27;</span>;\n<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出：Hello from module!</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>3. 适用场景</strong></h3>\n<h4><strong>命名空间</strong></h4>\n<ul>\n<li><strong>适用场景</strong>  ：\n<ul>\n<li><strong>全局脚本</strong>  ：在浏览器环境中，使用命名空间可以避免全局变量冲突。</li>\n<li><strong>快速原型</strong>  ：在小型项目或快速原型中，命名空间提供了一种简单的代码组织方式。</li>\n<li><strong>与现有代码集成</strong>  ：在需要与大量现有全局代码集成的项目中，命名空间可能更合适。</li>\n</ul>\n</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li>不支持 ES6 模块的静态分析和树摇优化。</li>\n<li>适用于简单的代码组织，但在大型项目中可能导致命名冲突。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>模块</strong></h4>\n<ul>\n<li><strong>适用场景</strong>  ：\n<ul>\n<li><strong>大型项目</strong>  ：在大型应用中，模块提供了更好的代码组织和可维护性。</li>\n<li><strong>现代开发</strong>  ：使用现代框架和构建工具时，模块是首选的代码组织方式。</li>\n<li><strong>类型安全</strong>  ：需要更好的类型检查和错误检测时，模块提供了更强的类型安全。</li>\n</ul>\n</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li>支持 ES6 模块的静态分析和树摇优化。</li>\n<li>与构建工具（如 Webpack、Rollup）兼容，支持代码分割和懒加载。</li>\n<li>提供了更好的类型安全和错误检测。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>4. 与构建工具的兼容性</strong></h3>\n<h4><strong>命名空间</strong></h4>\n<ul>\n<li><strong>兼容性</strong>  ：命名空间不是 ES6 标准的一部分，不支持现代构建工具的静态分析和优化。</li>\n<li><strong>使用限制</strong>  ：在大型项目中，命名空间可能导致命名冲突和代码难以维护。</li>\n</ul>\n<h4><strong>模块</strong></h4>\n<ul>\n<li><strong>兼容性</strong>  ：模块是 ES6 标准的一部分，与现代构建工具（如 Webpack、Rollup）兼容。</li>\n<li><strong>优势</strong>  ：支持代码分割、懒加载和树摇优化，提高了应用的性能和加载速度。</li>\n</ul>\n<hr>\n<h3><strong>5. 代码组织方式</strong></h3>\n<h4><strong>命名空间</strong></h4>\n<ul>\n<li><strong>组织方式</strong>  ：通过命名空间将相关的代码逻辑分组，避免全局变量冲突。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">Utils</span> {\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">formatDate</span>(<span class="hljs-params"><span class="hljs-attr">date</span>: <span class="hljs-title class_">Date</span></span>): <span class="hljs-built_in">string</span> {\n    <span class="hljs-keyword">return</span> date.<span class="hljs-title function_">toISOString</span>();\n  }\n}\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Utils</span>.<span class="hljs-title function_">formatDate</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));\n</code></pre>\n</li>\n</ul>\n<h4><strong>模块</strong></h4>\n<ul>\n<li><strong>组织方式</strong>  ：通过模块将代码分割成独立的单元，支持模块间的依赖管理。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-comment">// utils.ts</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">formatDate</span>(<span class="hljs-params"><span class="hljs-attr">date</span>: <span class="hljs-title class_">Date</span></span>): <span class="hljs-built_in">string</span> {\n  <span class="hljs-keyword">return</span> date.<span class="hljs-title function_">toISOString</span>();\n}\n\n<span class="hljs-comment">// app.ts</span>\n<span class="hljs-keyword">import</span> { formatDate } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils&#x27;</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">formatDate</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>6. 总结与对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>命名空间</strong></th>\n<th><strong>模块</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>定义方式</strong></td>\n<td>使用 <code>namespace</code> 关键字</td>\n<td>使用 <code>import</code> 和 <code>export</code> 关键字</td>\n</tr>\n<tr>\n<td><strong>作用域</strong></td>\n<td>全局作用域，成员默认全局可访问</td>\n<td>局部作用域，成员默认私有</td>\n</tr>\n<tr>\n<td><strong>代码组织</strong></td>\n<td>逻辑分组，避免全局变量冲突</td>\n<td>物理分组，支持代码分割和懒加载</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>小型项目、全局脚本、快速原型</td>\n<td>大型项目、现代开发、与构建工具集成</td>\n</tr>\n<tr>\n<td><strong>与构建工具兼容性</strong></td>\n<td>不支持，需要手动管理依赖</td>\n<td>支持，与 Webpack、Rollup 等兼容</td>\n</tr>\n<tr>\n<td><strong>类型安全</strong></td>\n<td>较弱，依赖全局作用域</td>\n<td>较强，提供更好的类型检查和错误检测</td>\n</tr>\n<tr>\n<td><strong>ES6 标准</strong></td>\n<td>不是 ES6 标准的一部分</td>\n<td>是 ES6 标准的一部分，原生支持</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>推荐实践</strong></h3>\n<ul>\n<li><strong>在大型项目和现代开发中，推荐使用模块</strong>   来组织代码，以获得更好的可维护性、类型安全和与构建工具的兼容性。</li>\n<li><strong>在小型项目或需要与现有全局代码集成的场景中，可以考虑使用命名空间</strong>  ，但应谨慎使用以避免命名冲突。</li>\n</ul>\n<p>理解命名空间和模块的区别，可以帮助你根据项目的需求和规模选择合适的代码组织方式，从而提高代码的可维护性和可扩展性。</p>\n</div>'</script></body></html>