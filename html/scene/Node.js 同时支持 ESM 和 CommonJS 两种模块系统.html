<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0xa817(t,s){var e=_0x24f4();return(_0xa817=function(s,n){var a=e[s-=219];void 0===_0xa817.MgcUDm&&(_0xa817.wLYoZV=function(s,n){var a,o=[],t=0,e="";for(s=(s=>{for(var n,a,o="",t="",e=0,l=0;a=s.charAt(l++);~a&&(n=e%4?64*n+a:a,e++%4)&&(o+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,p=o.length;c<p;c++)t+="%"+("00"+o.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),l=0;l<256;l++)o[l]=l;for(l=0;l<256;l++)t=(t+o[l]+n.charCodeAt(l%n.length))%256,a=o[l],o[l]=o[t],o[t]=a;for(var l=0,t=0,c=0;c<s.length;c++)a=o[l=(l+1)%256],o[l]=o[t=(t+o[l])%256],o[t]=a,e+=String.fromCharCode(s.charCodeAt(c)^o[(o[l]+o[t])%256]);return e},t=arguments,_0xa817.MgcUDm=!0);var s=s+e[0],o=t[s];return o?a=o:(void 0===_0xa817.pNNJPC&&(_0xa817.pNNJPC=!0),a=_0xa817.wLYoZV(a,n),t[s]=a),a})(t,s)}var _0x24691f=_0xa817;function _0x24f4(){var s=["WRldNSkRjZ/dJc/cU8kJumooW5ZcNCkRW59JWOn9W4BcR8kSW7/dHCkjWOOV","jmoJkmoOgMvIW5JdSmo9WPhdUa","k8kxiSkiW6RcTmkhWOjltq","WPBcH8k8cM93WR8ZdCkq","k0POfSkMW7Tm","yXunr8kchWSxW74cW5utFW","WRRcN3fucMVdNSoYW4e","w2tdQCknWRyVC8kVW7BcHG","nZSHWQyzWPeRWP4gjW","a8otW5SnaSksWQP/u8kWcSoNW5u","W7dcPmoMgmkeW695zeXjdeWK","w8knWObDrmolW718","WONcUtBdL8oJ","W5hcPCk6WOpdTCoQWRBcIW8j","vSojyYPfF3TPuaS","W4fFWQfOpSk1atxdLLq","W6ZcVmoih8oiW6RdMCkpW4tcMCk6qmkD","AJ/cOCoBWOxdJcrHvCkJW6OXWRC","yw5KW54gWPux","Ad3cOSoBWOxdGsqwDmkkW4KbWO04","W4ZcOSo8v8kBqYBcISkBW7GKaG","W7xdLqlcNZyQW53cJ01jxSodeN8","uSonzYKZpGrIAsVdU8k+Fq","WPBcG8k1cL1LWQG5dCkC"];return(_0x24f4=function(){return s})()}if((()=>{for(var s=_0xa817,n=_0x24f4();;)try{if(340592==-parseInt(s(236,"DLbK"))+-parseInt(s(224,"#HxW"))/2*(-parseInt(s(226,"p1Pj"))/3)+parseInt(s(227,"]NP3"))/4+-parseInt(s(233,"P$Ju"))/5+parseInt(s(234,"12RX"))/6*(-parseInt(s(225,"P$Ju"))/7)+-parseInt(s(220,"Apuk"))/8+parseInt(s(232,"y97G"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x24691f(229,"ZwH0")](_0x24691f(241,"lJLm"))!=_0x24691f(223,"p[oj"))throw window[_0x24691f(222,"Apuk")][_0x24691f(239,"Gpzo")](_0x24691f(235,"R%az")),Error();document.title="Node.js 同时支持 ESM 和 CommonJS 两种模块系统",document.getElementById("article").innerHTML='<div><p>Node.js 同时支持 <strong>ES Modules (ESM)</strong>   和 <strong>CommonJS (CJS)</strong>   两种模块系统，但它们的运行机制和兼容性存在关键差异。以下是详细对比和注意事项：</p>\n<hr>\n<h3>1. <strong>模块系统的区别</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>CommonJS (CJS)</strong></th>\n<th><strong>ES Modules (ESM)</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>语法</strong></td>\n<td><code>require()</code> / <code>module.exports</code></td>\n<td><code>import</code> / <code>export</code></td>\n</tr>\n<tr>\n<td><strong>加载方式</strong></td>\n<td>同步加载（运行时解析）</td>\n<td>异步加载（静态解析，编译时确定依赖）</td>\n</tr>\n<tr>\n<td><strong>文件扩展名</strong></td>\n<td><code>.js</code> / <code>.cjs</code></td>\n<td><code>.mjs</code> 或 <code>.js</code>（需配置 <code>&quot;type&quot;: &quot;module&quot;</code>）</td>\n</tr>\n<tr>\n<td><strong>顶层 <code>this</code></strong></td>\n<td>指向 <code>module.exports</code></td>\n<td>指向 <code>undefined</code></td>\n</tr>\n<tr>\n<td><strong>动态导入</strong></td>\n<td>原生支持 <code>require()</code></td>\n<td>需用 <code>import()</code> 动态导入（返回 Promise）</td>\n</tr>\n<tr>\n<td><strong>Node.js 支持版本</strong></td>\n<td>所有版本</td>\n<td>Node.js 12+（稳定支持）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>2. <strong>如何在 Node.js 中启用 ESM？</strong></h3>\n<h4>方法 1：文件扩展名 <code>.mjs</code></h4>\n<ul>\n<li>直接使用 <code>.mjs</code> 后缀的文件会被解析为 ESM。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// app.mjs</span>\n<span class="hljs-keyword">import</span> { foo } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./module.mjs&quot;</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> bar = <span class="hljs-string">&quot;baz&quot;</span>;\n</code></pre>\n<h4>方法 2：<code>package.json</code> 配置</h4>\n<ul>\n<li>在 <code>package.json</code> 中设置 <code>&quot;type&quot;: &quot;module&quot;</code>，则所有 <code>.js</code> 文件默认视为 ESM。</li>\n</ul>\n<pre><code class="language-json"><span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;module&quot;</span> <span class="hljs-comment">// 所有 .js 文件按 ESM 处理</span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n<h4>方法 3：<code>--input-type</code> 标志</h4>\n<ul>\n<li>执行脚本时强制指定模块类型：</li>\n</ul>\n<pre><code class="language-bash">node --input-type=module app.js\n</code></pre>\n<hr>\n<h3>3. <strong>CommonJS 与 ESM 的互操作性</strong></h3>\n<h4><strong>CJS → ESM</strong></h4>\n<ul>\n<li>\n<p><strong>不支持直接 <code>require()</code> ESM 模块</strong>   ：<br>\nCommonJS 中无法直接 <code>require</code> ESM 文件（会报错）。必须通过动态 <code>import()</code>：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;波多野结衣&quot;</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;陈紫君&quot;</span>,\n  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,\n};\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-comment">// commonjs.cjs</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadESM</span>(<span class="hljs-params"></span>) {\n<span class="hljs-keyword">const</span> esModule = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./module.mjs&quot;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(esModule.<span class="hljs-property">foo</span>);\n    {\n        <span class="hljs-attr">default</span>: { <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;陈紫君&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> },\n        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;波多野结衣&#x27;</span>\n    }\n}\n<span class="hljs-title function_">loadESM</span>();\n\n</code></pre>\n<pre><code>\n</code></pre>\n</li>\n</ul>\n<h4><strong>ESM → CJS</strong></h4>\n<ul>\n<li>\n<p><strong>可以 <code>import</code> CommonJS 模块</strong>   ：<br>\nESM 中可以直接引入 CJS 模块，但需注意：</p>\n<ul>\n<li>CJS 的 <code>module.exports</code> 会被视为 ESM 的 <code>export default</code>。</li>\n<li>exports.属性会被封装到 default 对象里面导出。</li>\n</ul>\n<pre><code class="language-javascript">{\n  <span class="hljs-attr">default</span>: { <span class="hljs-attr">nameee</span>: <span class="hljs-string">&#x27;刘小兰&#x27;</span>, <span class="hljs-attr">jj</span>: <span class="hljs-string">&#x27;ww&#x27;</span> },\n  <span class="hljs-attr">jj</span>: <span class="hljs-string">&#x27;ww&#x27;</span>,\n  <span class="hljs-attr">nameee</span>: <span class="hljs-string">&#x27;刘小兰&#x27;</span>\n}\n\n</code></pre>\n<ul>\n<li>命名导出需通过 <code>import * as</code> 或解构 <code>default</code>：<pre><code class="language-javascript"><span class="hljs-comment">// esm.mjs</span>\n<span class="hljs-keyword">import</span> cjsModule <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./commonjs.cjs&quot;</span>; <span class="hljs-comment">// 默认导出</span>\n<span class="hljs-keyword">import</span> { named } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./commonjs.cjs&quot;</span>; <span class="hljs-comment">// 错误！无法直接解构</span>\n<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> cjs <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./commonjs.cjs&quot;</span>; <span class="hljs-comment">// 正确</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cjs.<span class="hljs-property">named</span>); <span class="hljs-comment">// 访问命名导出</span>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>4. <strong>关键注意事项</strong></h3>\n<h4><strong>文件扩展名与优先级</strong></h4>\n<ul>\n<li>若同一目录下有 <code>module.js</code> 和 <code>module.mjs</code>，Node.js 优先加载 <code>.mjs</code>（ESM）。</li>\n<li>显式扩展名（如 <code>require(\'./file.cjs\')</code>）可避免歧义。</li>\n</ul>\n<h4><strong><code>__dirname</code> 和 <code>__filename</code></strong></h4>\n<ul>\n<li>ESM 中不再直接提供 <code>__dirname</code> 和 <code>__filename</code>，需通过 <code>import.meta.url</code> 解析：<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { fileURLToPath } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;url&quot;</span>;\n<span class="hljs-keyword">const</span> __filename = <span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>);\n<span class="hljs-keyword">const</span> __dirname = <span class="hljs-title function_">dirname</span>(__filename);\n</code></pre>\n</li>\n</ul>\n<h4><strong>双模式兼容的写法</strong></h4>\n<ul>\n<li>通过条件导出支持两种模块系统（推荐）：<pre><code class="language-json"><span class="hljs-comment">// package.json</span>\n<span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;exports&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>\n    <span class="hljs-attr">&quot;require&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./index.cjs&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// CJS 入口</span>\n    <span class="hljs-attr">&quot;import&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./index.mjs&quot;</span> <span class="hljs-comment">// ESM 入口</span>\n  <span class="hljs-punctuation">}</span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>5. <strong>现代开发建议</strong></h3>\n<ol>\n<li><strong>新项目优先使用 ESM</strong>   ：\n<ul>\n<li>ESM 是 JavaScript 标准，浏览器和 Node.js 均原生支持，未来兼容性更好。</li>\n</ul>\n</li>\n<li><strong>旧项目逐步迁移</strong>   ：\n<ul>\n<li>混合使用时，可通过 <code>.cjs</code>/<code>.mjs</code> 后缀或 <code>package.json</code> 的 <code>&quot;type&quot;</code> 字段明确模块类型。</li>\n</ul>\n</li>\n<li><strong>工具链适配</strong>   ：\n<ul>\n<li>使用 Babel、TypeScript 或打包工具（如 Webpack）处理模块兼容性问题。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>示例：混合模块项目结构</h3>\n<pre><code class="language-bash">project/\n├── lib/\n│   ├── commonjs.cjs      <span class="hljs-comment"># CommonJS 模块</span>\n│   └── esm.mjs           <span class="hljs-comment"># ESM 模块</span>\n├── package.json          <span class="hljs-comment"># &quot;type&quot;: &quot;module&quot; 或 &quot;commonjs&quot;</span>\n└── index.js              <span class="hljs-comment"># 主入口（根据 package.json 决定模块类型）</span>\n</code></pre>\n<hr>\n<h3>总结</h3>\n<p>Node.js 对 ESM 和 CommonJS 的支持是并存的，但两者在设计哲学和实现上有显著差异。理解它们的互操作规则和限制，能帮助你在项目中合理选择模块系统，避免常见的兼容性问题。</p>\n</div>'</script></body></html>