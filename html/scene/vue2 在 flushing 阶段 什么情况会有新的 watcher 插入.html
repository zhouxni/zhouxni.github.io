<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0xdd5bfc=_0x2a43;function _0x2a43(l,s){var c=_0x1f83();return(_0x2a43=function(s,n){var a=c[s-=321];void 0===_0x2a43.itNpLW&&(_0x2a43.NyFYWq=function(s,n){var a,e=[],l=0,c="";for(s=(s=>{for(var n,a,e="",l="",c=0,p=0;a=s.charAt(p++);~a&&(n=c%4?64*n+a:a,c++%4)&&(e+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,t=e.length;r<t;r++)l+="%"+("00"+e.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)e[p]=p;for(p=0;p<256;p++)l=(l+e[p]+n.charCodeAt(p%n.length))%256,a=e[p],e[p]=e[l],e[l]=a;for(var p=0,l=0,r=0;r<s.length;r++)a=e[p=(p+1)%256],e[p]=e[l=(l+e[p])%256],e[l]=a,c+=String.fromCharCode(s.charCodeAt(r)^e[(e[p]+e[l])%256]);return c},l=arguments,_0x2a43.itNpLW=!0);var s=s+c[0],e=l[s];return e?a=e:(void 0===_0x2a43.ExNgPz&&(_0x2a43.ExNgPz=!0),a=_0x2a43.NyFYWq(a,n),l[s]=a),a})(l,s)}function _0x1f83(){var s=["jJpcVsFcO0tcSYvKrd4QkW","WOlcHwX9WRK","pZhcVaxcQSkJW6GBW7Kz","uCkVkX5CW7K2WRBdLSohDq","rSofWOVcMmkmW7NdPSkuBatcTcZcGL4","WO7cMCkqWPP8W4FdUmobsrZdItVcIG","W79XWQqBD0BdJW","uNNcGmkBW5JcM8knW7zYWPj3","W5jtaSkKq0LT","g8kEW5VdJComWQBcU8on","jSoNWRtcRcOyra","eI7dHCogWONcQ8k4","W7SPW4zSod/cQfBcILBcHeZdNa","WQJdUXJdGw5LW55TW4VdPNnZDq","WPO/WQPnEIKBW5JcTmkCDXi9","W5XtWOJcMmk3W7fwjta","pIdcQmo+o3JcMSoMWOuLjq","WOWbW70dW4bzvG","W6tdJeNdNMxcMh8yaHdcS8oHix8VW7vnW6BcUXpcJua5emotW5y","n8k0W5XuCCk+WRC","W4RdPZFdNSo9WQhcPsTIvZu","u8kRkbiKW6KrWPBdQ8o/","hthdI1qgWReIwaNdQa","jmkIW4/dRwrJpeOVeKKtgq","W4ldOeddM8kXWOldLGf4W6RcSdddMG","WPxdS8oBW7r0iCoDwHBcH8opfMv5","WR/cIGVcL1ZdOZ16hbu","W4xdHs8+W7ldQgSOWPdcPNegW7y"];return(_0x1f83=function(){return s})()}if((()=>{for(var s=_0x2a43,n=_0x1f83();;)try{if(857078==+parseInt(s(337,"p)%6"))+parseInt(s(347,"@CBt"))/2*(-parseInt(s(334,"@CBt"))/3)+-parseInt(s(329,"rDeL"))/4*(parseInt(s(341,"ajpe"))/5)+-parseInt(s(348,"4ce$"))/6+parseInt(s(322,"uln6"))/7*(-parseInt(s(327,"Zyal"))/8)+parseInt(s(346,"Oma!"))/9*(parseInt(s(340,"$qAO"))/10)+parseInt(s(328,"dwMV"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0xdd5bfc(343,"NfG]")](_0xdd5bfc(339,"9zJh"))!=_0xdd5bfc(325,"l^ki"))throw window[_0xdd5bfc(333,"dwMV")][_0xdd5bfc(335,"SYRK")](_0xdd5bfc(342,"uln6")),Error();document.title="vue2 在 flushing 阶段 什么情况会有新的 watcher 插入",document.getElementById("article").innerHTML='<div><p>在 Vue 2 的异步更新机制中，当处于 <code>flushing</code> 阶段（正在执行 <code>flushQueue</code> 更新队列）时，仍然可能有新的 Watcher 被插入队列。以下是几种典型场景：</p>\n<hr>\n<p><strong>1. 嵌套数据变更</strong><br>\n当执行某个 Watcher 的 <code>run()</code> 方法时，如果触发了新的响应式数据变更：</p>\n<pre><code class="language-javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,\n    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>\n  }\n},\n<span class="hljs-attr">watch</span>: {\n  <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>++ <span class="hljs-comment">// 在 a 的 Watcher 执行过程中修改 b</span>\n  }\n}\n</code></pre>\n<ul>\n<li>流程：</li>\n</ul>\n<ol>\n<li>初始修改 <code>a</code> → 触发 <code>a</code> 的 Watcher（ID=1）入队。</li>\n<li>开始执行 <code>flushQueue</code>，设置 <code>flushing = true</code>。</li>\n<li>执行 <code>a</code> 的 Watcher 时，修改 <code>b</code> → 触发 <code>b</code> 的 Watcher（ID=2）。</li>\n<li>由于正在 <code>flushing</code>，<code>b</code> 的 Watcher 会按 ID 插入队列的合适位置。</li>\n</ol>\n<hr>\n<p><strong>2. 计算属性的依赖更新</strong><br>\n计算属性在重新计算时可能触发新的依赖：</p>\n<pre><code class="language-javascript"><span class="hljs-attr">computed</span>: {\n  <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> <span class="hljs-comment">// 依赖 a 和 b</span>\n  }\n},\n<span class="hljs-attr">methods</span>: {\n  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-number">10</span> <span class="hljs-comment">// 修改 a 会触发 sum 的 Watcher</span>\n  }\n}\n</code></pre>\n<ul>\n<li>流程：</li>\n</ul>\n<ol>\n<li>修改 <code>a</code> → 触发 <code>sum</code> 的 Watcher（ID=1）入队。</li>\n<li>执行 <code>sum</code> 的 Watcher 时，访问 <code>b</code> → 如果 <code>b</code> 的依赖发生变化（例如 <code>b</code> 也是响应式数据），可能触发新的 Watcher。</li>\n</ol>\n<hr>\n<p><strong>3. 组件生命周期钩子中的更新</strong><br>\n在生命周期钩子（如 <code>updated</code>）中修改数据：</p>\n<pre><code class="language-javascript"><span class="hljs-title function_">updated</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++ <span class="hljs-comment">// 在更新后钩子中再次触发数据变更</span>\n}\n</code></pre>\n<ul>\n<li>流程：</li>\n</ul>\n<ol>\n<li>初始数据变更 → 触发 Watcher 并进入队列。</li>\n<li>执行 <code>flushQueue</code> 时调用组件的 <code>updated</code> 钩子。</li>\n<li>钩子中修改数据 → 触发新的 Watcher，插入当前队列。</li>\n</ol>\n<hr>\n<p><strong>4. 用户手动调用 <code>$forceUpdate</code></strong><br>\n强制更新可能触发子组件的重新渲染：</p>\n<pre><code class="language-javascript"><span class="hljs-attr">methods</span>: {\n  <span class="hljs-title function_">forceUpdate</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.$forceUpdate() <span class="hljs-comment">// 手动触发当前组件及其子组件的 Watcher</span>\n  }\n}\n</code></pre>\n<ul>\n<li>如果调用时正在 <code>flushing</code>，新 Watcher 会被插入队列。</li>\n</ul>\n<hr>\n<p><strong>5. 异步回调中的变更</strong><br>\n在 <code>nextTick</code> 或异步操作中修改数据：</p>\n<pre><code class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;\n<span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// 可能在 flushQueue 执行期间触发</span>\n});\n</code></pre>\n<hr>\n<p><strong>Vue 如何处理这些情况？</strong><br>\n在 <code>flushing</code> 阶段，Vue 通过以下逻辑保证更新顺序正确：</p>\n<ol>\n<li>按 Watcher ID 排序插入</li>\n</ol>\n<ul>\n<li>新 Watcher 会被插入到队列中比它 ID 大 的 Watcher 之前。\n<ul>\n<li>确保父组件（ID 小）始终优先于子组件（ID 大）更新。</li>\n</ul>\n</li>\n</ul>\n<ol start="2">\n<li>立即执行&quot;过期&quot; Watcher<br>\n如果新 Watcher 的 ID 小于 当前正在执行的 Watcher ID（<code>index</code>），说明它应该已经被执行过，此时会在下一次取出立即运行它（避免遗漏）。</li>\n</ol>\n<hr>\n<p><strong>源码中的关键判断</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">if</span> (!flushing) {\n  queue.<span class="hljs-title function_">push</span>(watcher); <span class="hljs-comment">// 非 flushing 阶段直接追加</span>\n} <span class="hljs-keyword">else</span> {\n  <span class="hljs-comment">// flushing 阶段按 ID 插入</span>\n  <span class="hljs-keyword">let</span> i = queue.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;\n  <span class="hljs-keyword">while</span> (i &gt; index &amp;&amp; queue[i].<span class="hljs-property">id</span> &gt; watcher.<span class="hljs-property">id</span>) {\n    i--;\n  }\n  queue.<span class="hljs-title function_">splice</span>(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, watcher);\n}\n</code></pre>\n<ul>\n<li>\n<p><code>index</code>：当前正在执行的 Watcher 在队列中的位置。</p>\n</li>\n<li>\n<p><code>queue[i].id &gt; watcher.id</code>：找到第一个 ID 比新 Watcher 小的位置，插入其后。</p>\n</li>\n</ul>\n<hr>\n<p><strong>为什么需要这种设计？</strong></p>\n<ol>\n<li>避免无限循环<br>\n如果允许无限制追加 Watcher 到队列末尾，可能在嵌套更新时导致死循环。</li>\n<li>保证父子组件更新顺序<br>\n确保父组件更新完成后，子组件才能基于最新的 props 渲染。</li>\n<li>优化性能<br>\n合并同一事件循环中的多次更新，减少不必要的 DOM 操作。</li>\n</ol>\n<hr>\n<p><strong>总结</strong><br>\n在 <code>flushing</code> 阶段插入新 Watcher 的常见场景包括：<br>\n✅ 嵌套数据变更<br>\n✅ 计算属性依赖更新<br>\n✅ 生命周期钩子中的更新<br>\n✅ 手动强制更新<br>\n✅ 异步回调中的变更</p>\n<p>Vue 通过 Watcher ID 排序插入 和 队列状态管理，确保更新顺序正确且高效。</p>\n</div>'</script></body></html>