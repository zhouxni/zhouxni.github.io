<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1ae5(){var n=["bSoxWOe4qIjmWP3dNq","WRiLW7SSWOiGdWRcRrew","oqVcM1FdS8kQCmoRcq","a8otjmkkWRRdPNOEnKXTW7Ky","fH1uwSoMWO7cMSoHd8k/s8kTWOS","W7FdMmocW6/dHSk7qcP+","ESoYWOdcKXu9WOhdG8kLW5tcHs4KtCocmZhcGmkrFauPW4hcHbBcQW","WRTHc8oZC1fT","W4VdKmo9r11qcCosWPm","W5ldGahdQNmGi3i2W7VcRSkLWQVcQa","aCoHWORdSmkeBmkbv1OvdSkad8o+","rfnoDCkyirG","rCoVvSonW6BcU8kwWP47pG","xexcG8oDCSk8m8kPW5dcQxbY","WRuJW7XjW7CRfcFcKW","i8k3W4xdKvbjW5FcOSkiW5NcKa","W5SzdNJcKmkLW43dNmo6Ba","WQ9KmmkmaNLKFgxcJmoXWOWs","EgGSW6RdPeemffi","yCk1W5tcQt4","tvNdICkaWRmYW7hdQsZdS8keWQyM","fCk9s27cVrRdLrRcHq","WR3cVCkxW7tcMunxW7bwWQ7cT8kXvSkA","WPJcSmotvYxcTCo1yc3cT8knW6tdILK","WPZcLLqUWR5Cy8kX","WRVcU8kyW7/cNKarWO5vWQZcP8kb"];return(_0x1ae5=function(){return n})()}function _0x1bcc(r,n){var c=_0x1ae5();return(_0x1bcc=function(n,s){var t=c[n-=177];void 0===_0x1bcc.axOLer&&(_0x1bcc.WhcdLn=function(n,s){var t,a=[],r=0,c="";for(n=(n=>{for(var s,t,a="",r="",c=0,o=0;t=n.charAt(o++);~t&&(s=c%4?64*s+t:t,c++%4)&&(a+=String.fromCharCode(255&s>>(-2*c&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var l=0,p=a.length;l<p;l++)r+="%"+("00"+a.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(r)})(n),o=0;o<256;o++)a[o]=o;for(o=0;o<256;o++)r=(r+a[o]+s.charCodeAt(o%s.length))%256,t=a[o],a[o]=a[r],a[r]=t;for(var o=0,r=0,l=0;l<n.length;l++)t=a[o=(o+1)%256],a[o]=a[r=(r+a[o])%256],a[r]=t,c+=String.fromCharCode(n.charCodeAt(l)^a[(a[o]+a[r])%256]);return c},r=arguments,_0x1bcc.axOLer=!0);var n=n+c[0],a=r[n];return a?t=a:(void 0===_0x1bcc.HtvyYR&&(_0x1bcc.HtvyYR=!0),t=_0x1bcc.WhcdLn(t,s),r[n]=t),t})(r,n)}var _0x2f6c06=_0x1bcc;if((()=>{for(var n=_0x1bcc,s=_0x1ae5();;)try{if(887473==+parseInt(n(188,"hXQX"))*(-parseInt(n(179,"D]b0"))/2)+-parseInt(n(186,"MN7H"))/3+parseInt(n(195,"%a@I"))/4*(-parseInt(n(199,"Bqjf"))/5)+parseInt(n(191,"QYDj"))/6+parseInt(n(196,"yG!i"))/7+-parseInt(n(183,"MN7H"))/8+parseInt(n(181,"@jw$"))/9*(parseInt(n(192,"[QQw"))/10))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x2f6c06(194,"7QKQ")](_0x2f6c06(189,"pg7a"))!=_0x2f6c06(180,"2iln"))throw window[_0x2f6c06(185,"D0]b")][_0x2f6c06(198,"08I@")](_0x2f6c06(193,"5[t2")),Error();document.title="Rollup 的 input 数组和 Webpack 的 entry 数组",document.getElementById("article").innerHTML='<div><p>是的，Rollup 的 <code>input</code> 数组和 Webpack 的 <code>entry</code> 数组在概念上类似（都支持多入口打包），但在具体行为和底层机制上有显著区别。以下是两者的关键差异：</p>\n<hr>\n<h3><strong>1. 输出方式不同</strong></h3>\n<h4><strong>Rollup（<code>input: [...]</code>）</strong></h4>\n<ul>\n<li>\n<p><strong>必须配合 <code>output.dir</code></strong>  ：<br>\nRollup 的数组输入 <strong>必须</strong>   使用目录输出（<code>output.dir</code>），不能直接输出到单个文件（<code>output.file</code>）。<br>\n每个入口会生成独立的文件，文件名默认与入口名相同（可通过 <code>output.entryFileNames</code> 自定义）。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// rollup.config.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">input</span>: [<span class="hljs-string">&#x27;src/a.js&#x27;</span>, <span class="hljs-string">&#x27;src/b.js&#x27;</span>], <span class="hljs-comment">// 多入口</span>\n  <span class="hljs-attr">output</span>: {\n    <span class="hljs-attr">dir</span>: <span class="hljs-string">&#x27;dist&#x27;</span>,     <span class="hljs-comment">// 必须指定目录</span>\n    <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;esm&#x27;</span>,\n  },\n};\n</code></pre>\n<p><strong>输出结果</strong>  ：</p>\n<pre><code>dist/\n  ├── a.js  # 对应 src/a.js\n  └── b.js  # 对应 src/b.js\n</code></pre>\n</li>\n</ul>\n<h4><strong>Webpack（<code>entry: [...]</code>）</strong></h4>\n<ul>\n<li>\n<p><strong>默认合并为单一 bundle</strong>  ：<br>\nWebpack 的数组形式 <code>entry</code> 会将所有入口文件 <strong>合并到一个 bundle</strong>   中（除非配置 <code>splitChunks</code> 或动态导入）。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// webpack.config.js</span>\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">entry</span>: [<span class="hljs-string">&#x27;src/a.js&#x27;</span>, <span class="hljs-string">&#x27;src/b.js&#x27;</span>], <span class="hljs-comment">// 多入口数组</span>\n  <span class="hljs-attr">output</span>: {\n    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;main.js&#x27;</span>, <span class="hljs-comment">// 所有入口合并到 main.js</span>\n  },\n};\n</code></pre>\n<p><strong>输出结果</strong>  ：</p>\n<pre><code>dist/\n  └── main.js  # 包含 a.js 和 b.js 的代码\n</code></pre>\n</li>\n<li>\n<p><strong>多入口独立输出需用对象形式</strong>  ：<br>\n如果希望每个入口生成独立文件，需改用对象语法：</p>\n<pre><code class="language-javascript"><span class="hljs-attr">entry</span>: {\n  <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;src/a.js&#x27;</span>,\n  <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;src/b.js&#x27;</span>,\n},\n<span class="hljs-attr">output</span>: {\n  <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span>, <span class="hljs-comment">// 输出 a.js 和 b.js</span>\n},\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>2. 代码共享机制不同</strong></h3>\n<h4><strong>Rollup</strong></h4>\n<ul>\n<li><strong>自动优化共享依赖</strong>  ：<br>\nRollup 会分析入口之间的共享模块，并自动提取为公共 chunk（需启用代码分割）。<pre><code class="language-javascript"><span class="hljs-attr">output</span>: {\n  <span class="hljs-attr">dir</span>: <span class="hljs-string">&#x27;dist&#x27;</span>,\n  <span class="hljs-attr">chunkFileNames</span>: <span class="hljs-string">&#x27;shared-[hash].js&#x27;</span>, <span class="hljs-comment">// 共享代码块命名</span>\n},\n</code></pre>\n</li>\n</ul>\n<h4><strong>Webpack</strong></h4>\n<ul>\n<li><strong>依赖显式配置 <code>splitChunks</code></strong>  ：<br>\nWebpack 默认不会拆分入口之间的公共代码，除非通过 <code>optimization.splitChunks</code> 手动配置。<pre><code class="language-javascript"><span class="hljs-attr">optimization</span>: {\n  <span class="hljs-attr">splitChunks</span>: {\n    <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>, <span class="hljs-comment">// 强制提取公共模块</span>\n  },\n},\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>3. 设计哲学差异</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>Rollup</strong></th>\n<th><strong>Webpack</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>核心目标</strong></td>\n<td>生成高效、扁平化的 ES 模块 bundle</td>\n<td>处理复杂应用依赖（如静态资源、HMR）</td>\n</tr>\n<tr>\n<td><strong>多入口行为</strong></td>\n<td>每个入口独立输出 + 自动共享优化</td>\n<td>默认合并，需配置才能分离</td>\n</tr>\n<tr>\n<td><strong>代码分割</strong></td>\n<td>原生支持，自动优化</td>\n<td>需手动配置 <code>splitChunks</code></td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>库开发、ES 模块优先项目</td>\n<td>大型应用（如 SPA 或多页面应用）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>Rollup 数组输入</strong>  ：<br>\n每个入口生成独立文件，自动处理共享代码，适合输出多个独立模块（如库的子包）。</li>\n<li><strong>Webpack 数组输入</strong>  ：<br>\n默认合并代码，需额外配置才能分离入口或提取公共依赖，适合复杂应用的多入口需求。</li>\n</ul>\n<p><strong>选择建议</strong>  ：</p>\n<ul>\n<li>用 Rollup 打包库或需要精细控制 ES 模块时，优先使用 <code>input</code> 数组。</li>\n<li>用 Webpack 构建应用时，若需多入口，建议使用对象形式的 <code>entry</code> 而非数组。</li>\n</ul>\n</div>'</script></body></html>