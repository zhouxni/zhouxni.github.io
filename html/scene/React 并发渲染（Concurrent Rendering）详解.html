<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3816ec=_0x3213;function _0x3213(l,s){var p=_0x1281();return(_0x3213=function(s,n){var a=p[s-=348];void 0===_0x3213.LynwIJ&&(_0x3213.HWdBMH=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,c=t.length;r<c;r++)l+="%"+("00"+t.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,r=0;r<s.length;r++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(r)^t[(t[e]+t[l])%256]);return p},l=arguments,_0x3213.LynwIJ=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x3213.PDwNGy&&(_0x3213.PDwNGy=!0),a=_0x3213.HWdBMH(a,n),l[s]=a),a})(l,s)}function _0x1281(){var s=["WPqWWPu+uH/cGW","nSo0WOhcT8oWW60wW7JcUa","WRNdISkcWPNcOmofdwhcOw7cH8oBW6m","WQHHWRNdOCo5","truZxr/cV8o9WOLYzCkYdmoG","W6HsW4TVC8k2o2JdR23dUK4uma","WPP/E1xdPIfdW5FdL8kvbq","ymofWQ0JW6RcLdeLWQFcTmk8","WR/dI8koWP3cOmoicNlcP1BcSSoDW5a","WQ52Eh0tW5/dNCo/WR5mk8ksd0e","WRi7tqyWlCkreZFdTqpcHG","W6DFW4BdKSo7W7lcKZe","W5tcMCkRhM7dHYXKWRxdRahcPW","eL7cLmoFB3RdM8oai8oOW5VcKmow","WPJdM8oNtSksbfJdSXpdMmk8W4vE","W5xcN8kKhgRdGgbzWQpdOJhcRLu","W5bNW5u6wqxcTmoaWQK","W7/cU8oSjLbjWR/cLt/dNCkuocRcGh3dS8otdh8KW7ZcGmkaxCkPBq","pMWRmYbAyCkWWRa","WPnUW6ddHSo6WROFW7edWPimhG","WP/dMSoRsSkubZNdOaZdQSk7W4q","W4LwwapdPSkhrG"];return(_0x1281=function(){return s})()}if((()=>{for(var s=_0x3213,n=_0x1281();;)try{if(606826==-parseInt(s(349,"W8W1"))+parseInt(s(352,"W8W1"))/2+-parseInt(s(363,"*Io("))/3+parseInt(s(366,"Dq5z"))/4*(-parseInt(s(353,"f*R2"))/5)+-parseInt(s(357,"fOrL"))/6+-parseInt(s(350,"[KPx"))/7+parseInt(s(368,"mG58"))/8)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3816ec(358,"pTc]")](_0x3816ec(360,"uq3F"))!=_0x3816ec(362,"xSWd"))throw window[_0x3816ec(348,"5$CE")][_0x3816ec(359,"f*R2")](_0x3816ec(354,"i)R[")),Error();document.title="React 并发渲染（Concurrent Rendering）详解",document.getElementById("article").innerHTML='<div><p>React 并发渲染是 React 18 引入的核心特性，它基于 Fiber 架构实现，允许应用同时处理多个版本的 UI，以提高响应性和用户体验。以下是其核心概念和工作原理：</p>\n<h3><strong>1. 并发渲染的核心思想</strong></h3>\n<ul>\n<li><strong>可中断的渲染</strong>  ：React 可以暂停、继续或放弃渲染任务，优先处理更紧急的更新（如用户输入）。</li>\n<li><strong>多版本 UI</strong>  ：在内存中同时保留多个渲染版本，根据优先级选择最优版本展示。</li>\n<li><strong>非阻塞 UI</strong>  ：即使渲染大型组件树，用户界面仍能保持响应，不会出现卡顿。</li>\n</ul>\n<h3><strong>2. 与传统同步渲染的对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>传统同步渲染</strong></th>\n<th><strong>并发渲染</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>渲染过程</strong></td>\n<td>一次性完成，不可中断</td>\n<td>可暂停、恢复、重新排序</td>\n</tr>\n<tr>\n<td><strong>用户交互响应</strong></td>\n<td>渲染期间界面冻结</td>\n<td>高优先级任务（如点击）可立即响应</td>\n</tr>\n<tr>\n<td><strong>状态更新处理</strong></td>\n<td>按顺序同步执行</td>\n<td>低优先级更新可被高优先级更新打断</td>\n</tr>\n<tr>\n<td><strong>典型卡顿场景</strong></td>\n<td>大型列表渲染、复杂计算</td>\n<td>显著减少卡顿</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>3. 关键 API 与概念</strong></h3>\n<h4><strong>3.1 startTransition</strong></h4>\n<p>将低优先级更新标记为“过渡”（Transition），允许被高优先级更新中断：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { startTransition } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchBar</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [inputValue, setInputValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);\n  <span class="hljs-keyword">const</span> [results, setResults] = <span class="hljs-title function_">useState</span>([]);\n\n  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">e</span>) {\n    <span class="hljs-keyword">const</span> value = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;\n    <span class="hljs-title function_">setInputValue</span>(value); <span class="hljs-comment">// 高优先级：立即更新输入框</span>\n    \n    <span class="hljs-comment">// 低优先级：搜索结果更新可被中断</span>\n    <span class="hljs-title function_">startTransition</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-title function_">setResults</span>(<span class="hljs-title function_">fetchResults</span>(value));\n    });\n  }\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{inputValue}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleChange}</span> /&gt;</span></span>\n  );\n}\n</code></pre>\n<h4><strong>3.2 useTransition</strong></h4>\n<p>获取过渡状态（pending），可用于显示加载指示器：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> [isPending, startTransition] = <span class="hljs-title function_">useTransition</span>();\n\n<span class="hljs-comment">// 显示加载状态</span>\nisPending ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Spinner</span> /&gt;</span></span> : <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Results</span> /&gt;</span></span>\n</code></pre>\n<h4><strong>3.3 useDeferredValue</strong></h4>\n<p>延迟更新非关键值，保持 UI 响应性：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> deferredValue = <span class="hljs-title function_">useDeferredValue</span>(value, { <span class="hljs-attr">timeoutMs</span>: <span class="hljs-number">500</span> });\n\n<span class="hljs-comment">// 使用延迟值渲染复杂组件</span>\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ExpensiveComponent</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{deferredValue}</span> /&gt;</span></span>\n</code></pre>\n<h3><strong>4. 实际应用场景</strong></h3>\n<h4><strong>4.1 搜索框实时搜索</strong></h4>\n<ul>\n<li><strong>高优先级</strong>  ：输入框响应（即时反馈）</li>\n<li><strong>低优先级</strong>  ：搜索结果更新（可延迟）</li>\n</ul>\n<h4><strong>4.2 大型列表渲染</strong></h4>\n<ul>\n<li>使用 <code>startTransition</code> 分批渲染列表项，避免长时间阻塞：</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">LargeList</span>(<span class="hljs-params">{ items }</span>) {\n  <span class="hljs-keyword">const</span> [visibleItems, setVisibleItems] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">10</span>);\n\n  <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadMore</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-title function_">startTransition</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-title function_">setVisibleItems</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">10</span>);\n    });\n  }\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>\n      {items.slice(0, visibleItems).map(item =&gt; (\n        <span class="hljs-tag">&lt;<span class="hljs-name">Item</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span> {<span class="hljs-attr">...item</span>} /&gt;</span>\n      ))}\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{loadMore}</span>&gt;</span>加载更多<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/&gt;</span></span>\n  );\n}\n</code></pre>\n<h4><strong>4.3 路由切换动画</strong></h4>\n<ul>\n<li>新路由内容作为过渡任务，旧页面保持可交互直到新内容准备好。</li>\n</ul>\n<h3><strong>5. 并发渲染的底层机制</strong></h3>\n<ol>\n<li><strong>Fiber 架构</strong>  ：<br>\n将渲染任务拆分为多个“工作单元”（Fiber），每个单元可独立暂停和恢复。</li>\n<li><strong>优先级调度</strong>  ：\n<ul>\n<li>用户输入（如点击）：最高优先级（150ms 内响应）</li>\n<li>过渡动画：中等优先级（500ms 内响应）</li>\n<li>数据获取/非关键更新：低优先级（5s 内响应）</li>\n</ul>\n</li>\n<li><strong>选择性 hydration</strong>  （针对 SSR）：<br>\n服务端渲染的 HTML 可立即交互，React 后续再“hydrate”复杂组件。</li>\n</ol>\n<h3><strong>6. 与 Suspense 的协同工作</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 懒加载组件</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">Profile</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./Profile&#x27;</span>));\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Spinner</span> /&gt;</span>}&gt;\n      <span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<ul>\n<li>Suspense 可与并发渲染结合，优雅处理加载状态</li>\n<li>并发渲染允许在等待懒加载组件时保持页面响应</li>\n</ul>\n<h3><strong>7. 注意事项</strong></h3>\n<ol>\n<li><strong>副作用管理</strong>  ：\n<ul>\n<li>使用 <code>useEffect</code> 而非 <code>useLayoutEffect</code>，避免阻塞渲染</li>\n<li>确保副作用函数幂等（可重复执行）</li>\n</ul>\n</li>\n<li><strong>状态更新合并</strong>  ：<br>\n并发渲染可能导致多次调用相同的状态更新函数，需使用函数式更新：<pre><code class="language-javascript"><span class="hljs-comment">// 正确：函数式更新</span>\n<span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);\n\n<span class="hljs-comment">// 错误：依赖 previous state</span>\n<span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);\n</code></pre>\n</li>\n<li><strong>向后兼容</strong>  ：<br>\n并发渲染是渐进式增强，旧版组件仍能正常工作</li>\n</ol>\n<h3><strong>总结</strong></h3>\n<p>React 并发渲染通过 <strong>可中断的渲染流程</strong>   和 <strong>优先级调度</strong>  ，让应用在处理复杂任务时保持响应性，显著提升用户体验。核心 API（<code>startTransition</code>、<code>useDeferredValue</code>）为开发者提供了控制渲染优先级的工具，使 React 能够更好地应对现代 Web 应用的性能挑战。</p>\n</div>'</script></body></html>