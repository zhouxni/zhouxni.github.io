<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3de2f2=_0x3b2e;function _0xb075(){var s=["eIpcNX4zW7ZdPa","WObcW6xcNYGLtCk5W6C","W4nGWQKaW7VdOSkbkSoA","W5ycAKG+WP7dS8kIsa","WQRcVSkiW51StSkAawnLbby","m8ohs8kMW7hdVCoRWR04W7xcUdq","DH0SBuyKWPRcQ8kCeSoQWPdcJq","hu4PgSoiWQldMmovuIRcJSoJECkbW7BdSCkdzmouWORdUfipD1Ge","xhdcRt1xoSoxoW","W4rYdtRcV8oIdG","neFdJmkxWOveWO/dGmowtmoRwW","i8oIW7fYxCoiW4rdWRBdRq","vaFdScBdTYPjWRyXW4WzWR7cLW","kSkkW5xcTGpcLmoYWPD+WPCkAG","xahdMgGSWPpcTSokxeBdGG","WODQg8kHe0ddLKLKW6hcQG","hHtcVSk/WQekW4u7W7xdKW","FHSPmrzvW6hcICkY","W6jDWRaWqCo3WP3dMSoVW54","WQO/pCkQes7dLtm","WQmDW7jZFq","lgBdL8kefCoiW5BdOq","nCohq8kSWRNcMmorWRqCW5G","WRTGW4JcSmoVW4reWQeN","p8obs8kQWP7cS8oEWOSzW4K","WP7dK8o8W6KPkSkzo8kEWO8","WQrgr0RcIxNcKCoJWRddTL4","Cmk2rSkBnmoBWQJdNCk6BWC","DCkWrSkBsSoIWQ3dI8kVuG"];return(_0xb075=function(){return s})()}function _0x3b2e(e,s){var o=_0xb075();return(_0x3b2e=function(s,n){var a=o[s-=274];void 0===_0x3b2e.jzUClc&&(_0x3b2e.LdAbpD=function(s,n){var a,t=[],e=0,o="";for(s=(s=>{for(var n,a,t="",e="",o=0,l=0;a=s.charAt(l++);~a&&(n=o%4?64*n+a:a,o++%4)&&(t+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,c=t.length;p<c;p++)e+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(s),l=0;l<256;l++)t[l]=l;for(l=0;l<256;l++)e=(e+t[l]+n.charCodeAt(l%n.length))%256,a=t[l],t[l]=t[e],t[e]=a;for(var l=0,e=0,p=0;p<s.length;p++)a=t[l=(l+1)%256],t[l]=t[e=(e+t[l])%256],t[e]=a,o+=String.fromCharCode(s.charCodeAt(p)^t[(t[l]+t[e])%256]);return o},e=arguments,_0x3b2e.jzUClc=!0);var s=s+o[0],t=e[s];return t?a=t:(void 0===_0x3b2e.wgJjfy&&(_0x3b2e.wgJjfy=!0),a=_0x3b2e.LdAbpD(a,n),e[s]=a),a})(e,s)}if((()=>{for(var s=_0x3b2e,n=_0xb075();;)try{if(347587==+parseInt(s(290,"T]2s"))*(-parseInt(s(296,"jawq"))/2)+parseInt(s(286,"oKaf"))/3+parseInt(s(277,"*Q(K"))/4*(-parseInt(s(278,"*osg"))/5)+parseInt(s(275,"*Q(K"))/6*(-parseInt(s(281,"P@ur"))/7)+parseInt(s(279,"^i^X"))/8*(parseInt(s(299,"*yn3"))/9)+-parseInt(s(294,"8i3*"))/10+parseInt(s(285,"OMxO"))/11*(parseInt(s(295,"&qM4"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3de2f2(282,"QiuB")](_0x3de2f2(284,"^@5a"))!=_0x3de2f2(302,"5fJP"))throw window[_0x3de2f2(301,"2QNT")][_0x3de2f2(291,"ATGG")](_0x3de2f2(289,"zvWo")),Error();document.title="react hooks 是在渲染阶段调用的",document.getElementById("article").innerHTML='<div><p>答案：是的，React Hooks 必须在函数组件的渲染阶段（render phase）调用。<br>\n这是 React Hooks 设计的核心规则之一，目的是确保 Hooks 的状态管理逻辑与组件的渲染流程严格同步。</p>\n<hr>\n<p><strong>1. 什么是“渲染阶段”？</strong><br>\n在 React 的工作流程中，组件的渲染分为两个主要阶段：</p>\n<ol>\n<li>Render Phase（渲染阶段）</li>\n</ol>\n<ul>\n<li>\n<p>计算组件的输出（生成虚拟 DOM）。</p>\n<ul>\n<li>\n<p>执行函数组件的主体代码（包括 Hooks）。</p>\n</li>\n<li>\n<p>不可见副作用（不直接操作 DOM，只是生成变更计划）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<ol start="2">\n<li>Commit Phase（提交阶段）</li>\n</ol>\n<ul>\n<li>\n<p>将变更应用到真实 DOM。</p>\n<ul>\n<li>\n<p>执行副作用（如 <code>useEffect</code>、<code>useLayoutEffect</code>）。</p>\n</li>\n<li>\n<p>触发生命周期方法（如 <code>componentDidMount</code>）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>Hooks 的调用发生在 Render Phase，而 Hook 的副作用（如 <code>useEffect</code>）则在 Commit Phase 后执行。</p>\n<hr>\n<p><strong>2. 为什么 Hooks 必须在渲染阶段调用？</strong><br>\n<strong>(1) 状态与渲染的强绑定</strong><br>\nHooks（如 <code>useState</code>、<code>useReducer</code>）需要：</p>\n<ul>\n<li>\n<p>在渲染阶段获取最新状态。</p>\n</li>\n<li>\n<p>确保每次渲染的 Hook 调用顺序一致（通过 Fiber 的链表结构管理）。</p>\n</li>\n</ul>\n<p>如果 Hook 在非渲染阶段（如事件回调、<code>setTimeout</code>）调用，会导致状态不一致。</p>\n<p><strong>(2) 调用顺序的严格性</strong><br>\nReact 依赖 Hook 的调用顺序来匹配状态。例如：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [count] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);     <span class="hljs-comment">// Hook 1</span>\n  <span class="hljs-keyword">const</span> [name] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;&quot;</span>);     <span class="hljs-comment">// Hook 2</span>\n  <span class="hljs-comment">// React 通过调用顺序关联 `count` 和 `name` 的状态</span>\n}\n</code></pre>\n<p>如果在非渲染阶段调用 Hook，顺序可能错乱，导致状态错位。</p>\n<hr>\n<p><strong>3. 如何验证 Hooks 的调用时机？</strong><br>\nReact 通过全局变量 <code>ReactCurrentDispatcher.current</code> 标记当前是否允许调用 Hook：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// React 源码中的验证逻辑</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveDispatcher</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> dispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>.<span class="hljs-property">current</span>;\n  <span class="hljs-keyword">if</span> (dispatcher === <span class="hljs-literal">null</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(\n      <span class="hljs-string">&quot;Invalid hook call. Hooks can only be called inside a component.&quot;</span>\n    );\n  }\n  <span class="hljs-keyword">return</span> dispatcher;\n}\n</code></pre>\n<ul>\n<li>\n<p>合法调用：函数组件执行时，<code>ReactCurrentDispatcher.current</code> 会被设置为合法的 Hooks 调度器。</p>\n</li>\n<li>\n<p>非法调用：在事件处理函数、普通 JS 函数中调用 Hook 时，<code>dispatcher</code> 为 <code>null</code>，React 会抛出错误。</p>\n</li>\n</ul>\n<hr>\n<p><strong>4. 哪些场景会触发非法调用？</strong><br>\n<strong>❌ 错误示例</strong></p>\n<pre><code class="language-jsx"><span class="hljs-comment">// 1. 在事件回调中调用 Hook</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// ❌ 报错</span>\n}\n\n<span class="hljs-comment">// 2. 在 Class 组件中调用 Hook</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {\n  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> [count] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// ❌ 报错</span>\n    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n  }\n}\n\n<span class="hljs-comment">// 3. 在 setTimeout/Promise 中调用 Hook</span>\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {}); <span class="hljs-comment">// ❌ 报错</span>\n}, <span class="hljs-number">1000</span>);\n</code></pre>\n<p><strong>✅ 正确用法</strong></p>\n<pre><code class="language-jsx"><span class="hljs-comment">// 1. 在函数组件顶层调用</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// ✅ 合法</span>\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(c =&gt; c + 1)}&gt;{count}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n\n<span class="hljs-comment">// 2. 在自定义 Hook 中调用</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">useCustomHook</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [value] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// ✅ 合法</span>\n  <span class="hljs-keyword">return</span> value;\n}\n</code></pre>\n<hr>\n<p><strong>5. 特殊 Hook 的执行时机</strong></p>\n<table>\n<thead>\n<tr>\n<th>Hook 类型</th>\n<th>调用阶段</th>\n<th>副作用执行阶段</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>useState</code></td>\n<td>Render Phase</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>useEffect</code></td>\n<td>Render Phase</td>\n<td>Commit Phase 后异步执行</td>\n</tr>\n<tr>\n<td><code>useLayoutEffect</code></td>\n<td>Render Phase</td>\n<td>Commit Phase 同步执行</td>\n</tr>\n<tr>\n<td><code>useMemo</code></td>\n<td>Render Phase</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>6. 总结</strong></p>\n<table>\n<thead>\n<tr>\n<th>规则</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Hooks 必须在渲染阶段调用</td>\n<td>确保状态与渲染流程同步，避免顺序错乱。</td>\n</tr>\n<tr>\n<td>底层实现</td>\n<td>通过 <code>ReactCurrentDispatcher</code> 校验调用环境，开发环境会抛出详细错误。</td>\n</tr>\n<tr>\n<td>非法场景</td>\n<td>事件回调、Class 组件、异步代码中调用 Hook 均会报错。</td>\n</tr>\n<tr>\n<td>合法场景</td>\n<td>函数组件顶层、自定义 Hook 内部。</td>\n</tr>\n</tbody>\n</table>\n<p>核心结论：<br>\nReact Hooks 的设计强制要求它们在渲染阶段调用，这是保证状态管理和组件渲染一致性的基石。</p>\n</div>'</script></body></html>