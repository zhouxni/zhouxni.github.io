<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4203cc=_0x54c2;function _0x54c2(c,s){var l=_0xf847();return(_0x54c2=function(s,n){var a=l[s-=143];void 0===_0x54c2.QhwnmE&&(_0x54c2.iBAGRC=function(s,n){var a,e=[],c=0,l="";for(s=(s=>{for(var n,a,e="",c="",l=0,t=0;a=s.charAt(t++);~a&&(n=l%4?64*n+a:a,l++%4)&&(e+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,p=e.length;o<p;o++)c+="%"+("00"+e.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(c)})(s),t=0;t<256;t++)e[t]=t;for(t=0;t<256;t++)c=(c+e[t]+n.charCodeAt(t%n.length))%256,a=e[t],e[t]=e[c],e[c]=a;for(var t=0,c=0,o=0;o<s.length;o++)a=e[t=(t+1)%256],e[t]=e[c=(c+e[t])%256],e[c]=a,l+=String.fromCharCode(s.charCodeAt(o)^e[(e[t]+e[c])%256]);return l},c=arguments,_0x54c2.QhwnmE=!0);var s=s+l[0],e=c[s];return e?a=e:(void 0===_0x54c2.BxsMVv&&(_0x54c2.BxsMVv=!0),a=_0x54c2.iBAGRC(a,n),c[s]=a),a})(c,s)}if((()=>{for(var s=_0x54c2,n=_0xf847();;)try{if(953418==+parseInt(s(148,"@tmj"))*(-parseInt(s(160,"F3^k"))/2)+-parseInt(s(172,"UYAA"))/3*(parseInt(s(157,"VY8["))/4)+-parseInt(s(163,"d2(@"))/5*(-parseInt(s(146,"pEJ9"))/6)+parseInt(s(155,"ZA!!"))/7+-parseInt(s(170,"@tmj"))/8*(-parseInt(s(153,"JVaH"))/9)+parseInt(s(158,"b6@J"))/10*(parseInt(s(143,"ZNDw"))/11)+parseInt(s(164,"AAyr"))/12*(-parseInt(s(165,"]%QH"))/13))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x4203cc(144,"5k^U")](_0x4203cc(167,"F3^k"))!=_0x4203cc(150,"NX*o"))throw window[_0x4203cc(145,"]%QH")][_0x4203cc(168,"f]WH")](_0x4203cc(149,"KZPD")),Error();function _0xf847(){var s=["EZddOvOi","W6xdMSohc8klcmkqWRJdHwuqhq","WRZdVCkwW6BdTveBdG","W7ZdMuPEWPivy8kOW5FcKuLYcW","qSkCWOWduG4kW7O","jH0oWRmYWPGQCNlcTmkZqSka","WQeOrSk1Dmo3WQ/cUrRcHCoB","pmkQj2BdTCkBWOP/zCk4WQK","W71Hx8k4W6JcSmkicmoiWONdNW","W7zPw8k4WO7cN8kHeCoOWQq","W57cI29xyCoZwSoawu/dINS","W7FcH3icnCotjc8","W4pcGMXfWRJcRvfxtNu","WQpcPSovgCk7W5nTmw3dSupcGui","qhddJSoGAK7dSmk8W7HW","nZj7WRRdPSovsSkFWQFcTmkkW6u","bKDczSkhWO9/W7tcNhNcHmk2","WQ7dMJScjCk2zCoZuq","WRK4WQTJW4xcNXa","WRfym353fSkIASomW40i","W5RdGKKDWOqPhSkf","bKznBSkeWOK4W47cU1VcHCkbva","W4hcHq4qWRJcH2fP","WRmiwI7dJxPEW4aIWPLSFr0","WRPqn34roCklC8oSW6a","WPPOW6mheaa3","AgOQW6NcQSknymkt","W5aExmoHmvuVwa","WQuMhSoCjSofWQxcOa","W5/dG28jWQyPnCkP","WQ3cRSo0omkaWQNdHxJdLxhcLHlcUMFdMSktWRr8WQBcMCkbW78hWQpcT8oC"];return(_0xf847=function(){return s})()}document.title="Proxy 内部为什么要使用 Reflect 去操作",document.getElementById("article").innerHTML='<div><p>&quot;完整保留原生行为&quot;指的是在使用 <code>Proxy</code> 拦截对象操作时，通过 <code>Reflect</code> 确保被拦截的操作与<strong>未被代理时的原生行为完全一致</strong>   ，不会因为拦截逻辑而改变对象的基础功能和特性。</p>\n<h3>具体表现</h3>\n<ol>\n<li>\n<p><strong>行为一致性</strong><br>\n例如对对象属性赋值时，原生行为包含：</p>\n<ul>\n<li>触发对象自身的 <code>setter</code>（如果定义了）</li>\n<li>遵循原型链查找规则</li>\n<li>正确处理 <code>receiver</code>（确保 <code>this</code> 指向正确）</li>\n<li>返回操作是否成功的结果</li>\n</ul>\n<p>使用 <code>Reflect.set(target, prop, value, receiver)</code> 可以完整保留这些行为，而手动操作（如 <code>target[prop] = value</code>）可能破坏其中某些特性。</p>\n</li>\n<li>\n<p><strong>异常与返回值一致</strong><br>\n原生操作抛出的异常、返回的结果，通过 <code>Reflect</code> 转发后完全相同。例如：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span> }); <span class="hljs-comment">// 冻结对象，禁止修改</span>\n\n<span class="hljs-comment">// 原生操作：抛出错误</span>\n<span class="hljs-keyword">try</span> {\n  obj.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;李四&quot;</span>;\n} <span class="hljs-keyword">catch</span> (e) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;原生操作失败：&quot;</span>, e);\n}\n\n<span class="hljs-comment">// 使用 Proxy + Reflect 拦截</span>\n<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, {\n  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, prop, value</span>) {\n    <span class="hljs-comment">// 通过 Reflect 保留原生的错误行为</span>\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, prop, value);\n  },\n});\n\n<span class="hljs-keyword">try</span> {\n  proxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;李四&quot;</span>;\n} <span class="hljs-keyword">catch</span> (e) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;代理操作失败：&quot;</span>, e);\n} <span class="hljs-comment">// 与原生错误一致</span>\n</code></pre>\n</li>\n<li>\n<p><strong>上下文正确</strong><br>\n<code>Reflect</code> 会正确处理 <code>receiver</code> 参数，确保对象方法中的 <code>this</code> 指向代理对象而非原始对象，这对原型链继承等场景至关重要：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> parent = {\n  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>;\n  },\n};\n\n<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(\n  { <span class="hljs-attr">_value</span>: <span class="hljs-number">10</span> },\n  {\n    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop, receiver</span>) {\n      <span class="hljs-comment">// 使用 Reflect 确保 this 指向 proxy（receiver）</span>\n      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, prop, receiver);\n    },\n  },\n);\n\n<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(child, parent);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">value</span>); <span class="hljs-comment">// 10（正确，this 指向 child）</span>\n</code></pre>\n<p>如果改用 <code>return target[prop]</code>，<code>this</code> 会指向原始对象 <code>target</code>，导致结果错误。</p>\n</li>\n</ol>\n<h3>为什么重要？</h3>\n<p>如果不使用 <code>Reflect</code> 保留原生行为，代理对象可能出现：</p>\n<ul>\n<li>原型链断裂</li>\n<li><code>this</code> 指向错误</li>\n<li>特殊对象（如冻结对象、密封对象）的特性失效</li>\n<li>与原生 API 交互时出现异常</li>\n</ul>\n<p>因此，<code>Reflect</code> 是 <code>Proxy</code> 实现&quot;增强不破坏&quot;的核心保障，让开发者可以安全地在拦截逻辑中扩展功能，同时不影响对象的基础行为。</p>\n</div>'</script></body></html>