<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x16f879=_0xccba;function _0x1cd0(){var n=["W4K9nmoFjmogW5dcSCoK","WR9/gJSIWQ9yq8oV","WR0dE3RdTwOyW7ZdNSk/aW","W4yUsrusWPT2smoM","W5/cKSoSnwqtzCkKW4NcUGST","WO5PcI0O","pt7dNGe2mmomW50q","CI7cL8kqpmkzWRZdRZvgWR1jW5y","WPFdUYiUWRLlk1hcGbVdJc1XkG","W55ygmkaB8o2ad5bECozW60","xq5HWP8+WOu8k2j/jMGN","W5jIW7W8vGNcPSoU","WOxdVHxcUwpdG8ojpSkmfSoIW597","tCkmbuVcUN4QuWe6kCkFW6m","W5FdQmoWECoNxqtcMgZcI8k4vbC","Fc/dGCousmo2W6RdMa","W5LSWQ52iWtcKSoXW7qzWQG","W4tcRM5uW70ADW","WR55smomiCkTWOi","tCkdu1RcTZBcGLBdHgJcRxOvW4ZdM2fTWOJcPmkPW6ixW7FdQX5w","hCoff2hcH0VdIbFdJG","eCohhXNdTdJcNeNdIgpcTLOUW5S","W6pdTLRdHWVdImoGWRxdGSoBWRS","W51yfmkgz8kVjXbiumoE","qepcJvG1uHfRmqCSW7Dz","WPDNyCoVgmoRW5NcIW"];return(_0x1cd0=function(){return n})()}function _0xccba(t,n){var c=_0x1cd0();return(_0xccba=function(n,e){var s=c[n-=446];void 0===_0xccba.hEcQgn&&(_0xccba.CyScfL=function(n,e){var s,a=[],t=0,c="";for(n=(n=>{for(var e,s,a="",t="",c=0,o=0;s=n.charAt(o++);~s&&(e=c%4?64*e+s:s,c++%4)&&(a+=String.fromCharCode(255&e>>(-2*c&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var l=0,d=a.length;l<d;l++)t+="%"+("00"+a.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(t)})(n),o=0;o<256;o++)a[o]=o;for(o=0;o<256;o++)t=(t+a[o]+e.charCodeAt(o%e.length))%256,s=a[o],a[o]=a[t],a[t]=s;for(var o=0,t=0,l=0;l<n.length;l++)s=a[o=(o+1)%256],a[o]=a[t=(t+a[o])%256],a[t]=s,c+=String.fromCharCode(n.charCodeAt(l)^a[(a[o]+a[t])%256]);return c},t=arguments,_0xccba.hEcQgn=!0);var n=n+c[0],a=t[n];return a?s=a:(void 0===_0xccba.WKiAZa&&(_0xccba.WKiAZa=!0),s=_0xccba.CyScfL(s,e),t[n]=s),s})(t,n)}if((()=>{for(var n=_0xccba,e=_0x1cd0();;)try{if(615417==+parseInt(n(452,"RQP@"))*(parseInt(n(464,"O8Yr"))/2)+-parseInt(n(451,"0K1Z"))/3+parseInt(n(457,"RQP@"))/4*(-parseInt(n(470,"jPJE"))/5)+-parseInt(n(454,"X)Au"))/6+-parseInt(n(448,"aJRA"))/7+-parseInt(n(447,"^GIu"))/8*(parseInt(n(471,"VF5!"))/9)+parseInt(n(462,"NOuT"))/10)break;e.push(e.shift())}catch(n){e.push(e.shift())}})(),localStorage[_0x16f879(458,"d$7O")](_0x16f879(468,"jPJE"))!=_0x16f879(446,"jPJE"))throw window[_0x16f879(466,"DBc%")][_0x16f879(459,"$n1a")](_0x16f879(460,"NOuT")),Error();document.title="React 17 的同步批处理",document.getElementById("article").innerHTML='<div><p>React 17 的“同步批处理”并不是又造了一套新算法，而是把 <strong>16 中不慎扩大的批处理范围</strong>   砍回到 <strong>Legacy 模式</strong>   的批处理边界。<br>\n核心做法只有两步：</p>\n<ol>\n<li><strong>把“批量更新”的开关重新放回 React 合成事件</strong></li>\n<li><strong>在 Legacy Root 下，对所有非合成事件直接走「同步 Lane」</strong></li>\n</ol>\n<p>下面把这两步在源码里对应的实现片段全部指给你看（React 17.0.2 代码）。</p>\n<hr>\n<ol>\n<li>入口：事件分发<br>\npackages/react-dom/src/events/ReactDOMEventListener.js</li>\n</ol>\n<pre><code class="language-js"><span class="hljs-comment">// 合成事件（点击、input 等）会包一层 batchedUpdates</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchEvent</span>(<span class="hljs-params">\n  domEventName,\n  eventSystemFlags,\n  targetContainer,\n  nativeEvent,\n</span>) {\n  <span class="hljs-keyword">const</span> nativeEventTarget = <span class="hljs-title function_">getEventTarget</span>(nativeEvent);\n  <span class="hljs-comment">// 关键：batchedUpdates 会把本次回调包进一个“批量更新事务”</span>\n  <span class="hljs-title function_">batchedUpdates</span>(<span class="hljs-function">() =&gt;</span>\n    <span class="hljs-title function_">dispatchEventsForPlugins</span>(\n      domEventName,\n      eventSystemFlags,\n      nativeEvent,\n      nativeEventTarget,\n      targetContainer,\n    ),\n  );\n}\n</code></pre>\n<ul>\n<li><code>batchedUpdates</code> 内部只是 <code>unbatchedUpdates</code> 的反向调用——把 <code>executionContext</code> 打上 <code>BatchedContext</code> 标记。</li>\n<li>所有 setState 在 <code>scheduleUpdateOnFiber</code> 时看到 <code>BatchedContext</code> 就会把 update 推进 <strong>ConcurrentLanes → 批量 Lane</strong>   。</li>\n<li>一旦回调结束，<code>batchedUpdates</code> 会把 <code>executionContext</code> 恢复成 0，随后统一 flush。</li>\n</ul>\n<hr>\n<ol start="2">\n<li>Legacy Root：非合成事件直接走「同步 Lane」<br>\npackages/react-reconciler/src/ReactFiberWorkLoop.old.js</li>\n</ol>\n<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleUpdateOnFiber</span>(<span class="hljs-params">fiber, lane, eventTime</span>) {\n  <span class="hljs-comment">// Legacy Root 且当前 executionContext 没有 BatchedContext</span>\n  <span class="hljs-keyword">if</span> ((executionContext &amp; <span class="hljs-title class_">BatchedContext</span>) === <span class="hljs-title class_">NoContext</span>) {\n    <span class="hljs-comment">// 立即进入同步刷新（flushSyncCallbackQueue）</span>\n    <span class="hljs-title function_">flushSyncCallbackQueue</span>();\n    <span class="hljs-keyword">return</span>;\n  }\n\n  <span class="hljs-comment">// 否则把 lane 放进 root.pendingLanes，等待下一次 flush</span>\n}\n</code></pre>\n<ul>\n<li>Legacy Root（<code>ReactDOM.render</code> 创建的根）在 17 仍然默认启用。</li>\n<li>在 Legacy Root 下，只要 <code>executionContext</code> 没有 <code>BatchedContext</code>，<code>scheduleUpdateOnFiber</code> 会 <strong>立刻 <code>flushSyncCallbackQueue</code></strong>   ——意味着 setState → 立即 commit。</li>\n<li>合成事件由于外层包了 <code>batchedUpdates</code>，<code>executionContext</code> 有 <code>BatchedContext</code>，因此不会走 <code>flushSyncCallbackQueue</code>，而是把更新压到 root.pendingLanes 里，等事件循环结束统一 flush。</li>\n</ul>\n<hr>\n<ol start="3">\n<li>batchedUpdates 的实现<br>\npackages/react-reconciler/src/ReactFiberWorkLoop.old.js</li>\n</ol>\n<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> batchedUpdates&lt;A, R&gt;(<span class="hljs-attr">fn</span>: <span class="hljs-function"><span class="hljs-params">A</span> =&gt;</span> R, <span class="hljs-attr">a</span>: A): R {\n  <span class="hljs-keyword">const</span> prevExecutionContext = executionContext;\n  executionContext |= <span class="hljs-title class_">BatchedContext</span>;   <span class="hljs-comment">// 打上批处理标记</span>\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(a);                       <span class="hljs-comment">// 运行回调</span>\n  } <span class="hljs-keyword">finally</span> {\n    executionContext = prevExecutionContext;\n    <span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span>) {\n      <span class="hljs-title function_">flushSyncCallbackQueue</span>();         <span class="hljs-comment">// 统一 flush</span>\n    }\n  }\n}\n</code></pre>\n<hr>\n<p>一句话总结实现</p>\n<ul>\n<li><strong>React 17 并没有新增“同步批处理”算法</strong>   ，只是把 16 中 <strong>全局的 batchedUpdates</strong>   回退成 <strong>只在合成事件/生命周期里才开 batchedUpdates</strong>   。</li>\n<li>在 Legacy Root：\n<ol>\n<li>合成事件 → <code>batchedUpdates</code> → 走批量 Lane → 一次 commit</li>\n<li>其他同步代码 → 无 <code>BatchedContext</code> → 立即 <code>flushSyncCallbackQueue</code> → 多次 commit</li>\n</ol>\n</li>\n</ul>\n<p>这就是 17 的“同步批处理”实现机制。</p>\n</div>'</script></body></html>