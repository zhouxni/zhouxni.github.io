<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1dc11e=_0x1484;if((()=>{for(var n=_0x1484,s=_0x542d();;)try{if(750840==+parseInt(n(174,"P(g#"))+parseInt(n(162,"T6q)"))/2+parseInt(n(180,"40IY"))/3*(-parseInt(n(165,"a@&)"))/4)+parseInt(n(167,"Iw2H"))/5+-parseInt(n(178,"%i9@"))/6+parseInt(n(170,"9Tuf"))/7+-parseInt(n(181,"JPf7"))/8)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x1dc11e(169,"SFmo")](_0x1dc11e(179,"9WjU"))!=_0x1dc11e(175,"$O&@"))throw window[_0x1dc11e(182,"d%RS")][_0x1dc11e(168,"WGBa")](_0x1dc11e(172,"9#o5")),Error();function _0x1484(r,n){var e=_0x542d();return(_0x1484=function(n,s){var l=e[n-=162];void 0===_0x1484.nugAqX&&(_0x1484.Njorio=function(n,s){var l,a=[],r=0,e="";for(n=(n=>{for(var s,l,a="",r="",e=0,p=0;l=n.charAt(p++);~l&&(s=e%4?64*s+l:l,e++%4)&&(a+=String.fromCharCode(255&s>>(-2*e&6))))l="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(l);for(var o=0,t=a.length;o<t;o++)r+="%"+("00"+a.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(r)})(n),p=0;p<256;p++)a[p]=p;for(p=0;p<256;p++)r=(r+a[p]+s.charCodeAt(p%s.length))%256,l=a[p],a[p]=a[r],a[r]=l;for(var p=0,r=0,o=0;o<n.length;o++)l=a[p=(p+1)%256],a[p]=a[r=(r+a[p])%256],a[r]=l,e+=String.fromCharCode(n.charCodeAt(o)^a[(a[p]+a[r])%256]);return e},r=arguments,_0x1484.nugAqX=!0);var n=n+e[0],a=r[n];return a?l=a:(void 0===_0x1484.mJJYev&&(_0x1484.mJJYev=!0),l=_0x1484.Njorio(l,s),r[n]=l),l})(r,n)}function _0x542d(){var n=["dbdcMSocx0hdGCkKtSkHs189","uMHNW5mPfbZcU8kZW4FcGty","WQP7W4VcH097uSkhl1Lpv8kN","hveNnCojW5bqWRf1eSkmWOO8","du5GW4FcS8kQxW","DaVcNSkzW5PKva","dbBcMSoiv0hdG8k9zmkKrM8B","W5OkW7z6WRVcNCoxWQ9rWPq2tXi","W6eRkCoIuSo7cWBdL8ozWOjrxZdcGSoWcJfeW6epgNpdOmkpkG","WRZdT8kAWP53W7fRDCoXsmo3qXy","va/dRcNdRSoNudFcMCkVowi","kbbbW4Ke","W7tcPSoJW69kxSkw","WQ3cM8oMhCkoW7xdKmkjW4pcJ8kPFW","WQmVja7dO2vJfmkzW5BcV3ddIW","oSofBmo4pSkPjSksW7y","DmoNvMTVCJW","dYRcQJOqoSo2juHTnCkJn8oM","oZ4yA8kvWPdcRmoQ","WQFcM8oHgmkhW7tdISkxW6RcHSkGvq","ErWzW7WOW7WkWPtcNvpdLmkMWPq","AvCbWOTlW6e7bX/dKrzTwdW"];return(_0x542d=function(){return n})()}document.title="Webpack 并行构建",document.getElementById("article").innerHTML='<div><p>Webpack 并行构建通过利用多核 CPU 的能力，将构建任务分解为多个子任务，并在多个进程或线程中同时执行这些子任务，从而显著提高构建速度。以下是 Webpack 并行构建的工作原理及实现方式的详细说明：</p>\n<hr>\n<h3><strong>一、并行构建的基本原理</strong></h3>\n<ol>\n<li><strong>单线程限制</strong>  ：\n<ul>\n<li>Node.js 是单线程的，Webpack 的构建过程通常也是单线程的，这限制了 CPU 的利用率。</li>\n<li>在大型项目中，单线程构建可能导致较长的构建时间。</li>\n</ul>\n</li>\n<li><strong>并行化的思路</strong>  ：\n<ul>\n<li>将构建任务分解为多个独立的子任务。</li>\n<li>在多个进程或线程中同时执行这些子任务。</li>\n<li>合并子任务的结果，完成整个构建过程。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>二、Webpack 并行构建的实现方式</strong></h3>\n<ol>\n<li><strong>多线程/多进程处理</strong>  ：\n<ul>\n<li>使用子进程或线程来并行执行耗时的任务，如 Loader 处理、代码压缩等。</li>\n</ul>\n</li>\n<li><strong>工具支持</strong>  ：\n<ul>\n<li>Webpack 社区提供了多种工具来实现并行构建，如 <code>thread-loader</code>、<code>happypack</code>、<code>terser-webpack-plugin</code> 的并行模式等。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>三、具体实现工具及工作原理</strong></h3>\n<h4><strong>1. thread-loader</strong></h4>\n<ul>\n<li><strong>作用</strong>  ：\n<ul>\n<li>将耗时的 Loader 工作分配到子线程中执行，避免阻塞主线程。</li>\n</ul>\n</li>\n<li><strong>工作原理</strong>  ：\n<ul>\n<li><code>thread-loader</code> 会将 Loader 的执行放在一个独立的 worker 池中。</li>\n<li>当 Webpack 遇到被 <code>thread-loader</code> 包装的 Loader 时，会将任务分发给 worker 池中的空闲 worker。</li>\n<li>worker 完成任务后，将结果返回给主线程。</li>\n</ul>\n</li>\n<li><strong>配置示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">module</span>: {\n    <span class="hljs-attr">rules</span>: [\n      {\n        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.js$/</span>,\n        <span class="hljs-attr">use</span>: [\n          <span class="hljs-string">&#x27;thread-loader&#x27;</span>, <span class="hljs-comment">// 开启多线程</span>\n          <span class="hljs-string">&#x27;babel-loader&#x27;</span>,\n        ],\n        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,\n      },\n    ],\n  },\n};\n</code></pre>\n</li>\n</ul>\n<h4><strong>2. happypack</strong></h4>\n<ul>\n<li><strong>作用</strong>  ：\n<ul>\n<li>多进程并行运行 Loader，提高 Loader 处理速度。</li>\n</ul>\n</li>\n<li><strong>工作原理</strong>  ：\n<ul>\n<li><code>happypack</code> 会创建多个子进程，每个子进程负责处理一部分文件。</li>\n<li>主进程将文件分配给子进程，子进程并行处理文件，并将结果返回给主进程。</li>\n<li>主进程合并结果，完成构建。</li>\n</ul>\n</li>\n<li><strong>配置示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HappyPack</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;happypack&#x27;</span>);\n<span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;os&#x27;</span>);\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">module</span>: {\n    <span class="hljs-attr">rules</span>: [\n      {\n        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.js$/</span>,\n        <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;happypack/loader?id=js&#x27;</span>,\n        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,\n      },\n    ],\n  },\n  <span class="hljs-attr">plugins</span>: [\n    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HappyPack</span>({\n      <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;js&#x27;</span>,\n      <span class="hljs-attr">threads</span>: os.<span class="hljs-title function_">cpus</span>().<span class="hljs-property">length</span>, <span class="hljs-comment">// 使用 CPU 核心数</span>\n      <span class="hljs-attr">loaders</span>: [<span class="hljs-string">&#x27;babel-loader&#x27;</span>],\n    }),\n  ],\n};\n</code></pre>\n</li>\n</ul>\n<h4><strong>3. terser-webpack-plugin 的并行模式</strong></h4>\n<ul>\n<li><strong>作用</strong>  ：\n<ul>\n<li>在代码压缩阶段，使用多进程并行执行压缩任务。</li>\n</ul>\n</li>\n<li><strong>工作原理</strong>  ：\n<ul>\n<li><code>terser-webpack-plugin</code> 支持 <code>parallel</code> 选项，可以开启多进程压缩。</li>\n<li>Webpack 会将压缩任务分配给多个子进程，子进程并行压缩代码，并将结果返回给主进程。</li>\n</ul>\n</li>\n<li><strong>配置示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">TerserPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;terser-webpack-plugin&#x27;</span>);\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">optimization</span>: {\n    <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>,\n    <span class="hljs-attr">minimizer</span>: [\n      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>({\n        <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启多进程压缩</span>\n      }),\n    ],\n  },\n};\n</code></pre>\n</li>\n</ul>\n<h4><strong>4. Webpack 5 内置的并行化</strong></h4>\n<ul>\n<li><strong>作用</strong>  ：\n<ul>\n<li>Webpack 5 引入了对内置任务（如编译和压缩）的并行化支持。</li>\n</ul>\n</li>\n<li><strong>工作原理</strong>  ：\n<ul>\n<li>Webpack 5 可以通过配置 <code>parallelism</code> 选项，指定并行执行的任务数。</li>\n<li>Webpack 会自动将任务分配给多个线程，提高构建速度。</li>\n</ul>\n</li>\n<li><strong>配置示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">parallelism</span>: <span class="hljs-number">4</span>, <span class="hljs-comment">// 开启 4 个并行任务</span>\n};\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>四、并行构建的优势</strong></h3>\n<ol>\n<li><strong>提高构建速度</strong>  ：\n<ul>\n<li>通过并行执行耗时的任务，显著减少构建时间。</li>\n</ul>\n</li>\n<li><strong>充分利用多核 CPU</strong>  ：\n<ul>\n<li>突破了 Node.js 单线程的限制，提高了 CPU 利用率。</li>\n</ul>\n</li>\n<li><strong>提升开发效率</strong>  ：\n<ul>\n<li>更快的构建速度意味着更快的反馈，提升了开发体验。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>五、注意事项</strong></h3>\n<ol>\n<li><strong>资源消耗</strong>  ：\n<ul>\n<li>并行构建会增加 CPU 和内存的使用，需根据硬件资源合理配置。</li>\n</ul>\n</li>\n<li><strong>小项目的适用性</strong>  ：\n<ul>\n<li>在小型项目中，并行构建可能无法带来明显的性能提升，甚至可能因为进程切换的开销而降低构建速度。</li>\n</ul>\n</li>\n<li><strong>工具选择</strong>  ：\n<ul>\n<li>根据项目需求和 Webpack 版本选择合适的并行构建工具。</li>\n<li>Webpack 5 用户优先考虑使用内置的并行化支持。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>六、总结</strong></h3>\n<p>Webpack 并行构建通过利用多核 CPU 的能力，将构建任务分解为多个子任务，并在多个进程或线程中同时执行这些子任务，从而显著提高构建速度。常见的实现工具包括 <code>thread-loader</code>、<code>happypack</code>、<code>terser-webpack-plugin</code> 的并行模式以及 Webpack 5 内置的并行化支持。在实际项目中，应根据项目需求和硬件资源选择合适的并行构建方案，以达到最佳的构建性能。</p>\n</div>'</script></body></html>