<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2ae9e6=_0x94ce;function _0x94ce(l,s){var p=_0x4ed5();return(_0x94ce=function(s,n){var a=p[s-=142];void 0===_0x94ce.oQKuAz&&(_0x94ce.mngBid=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,c=0;a=s.charAt(c++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,o=t.length;e<o;e++)l+="%"+("00"+t.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(l)})(s),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)l=(l+t[c]+n.charCodeAt(c%n.length))%256,a=t[c],t[c]=t[l],t[l]=a;for(var c=0,l=0,e=0;e<s.length;e++)a=t[c=(c+1)%256],t[c]=t[l=(l+t[c])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(e)^t[(t[c]+t[l])%256]);return p},l=arguments,_0x94ce.oQKuAz=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x94ce.ywPEoa&&(_0x94ce.ywPEoa=!0),a=_0x94ce.mngBid(a,n),l[s]=a),a})(l,s)}function _0x4ed5(){var s=["W5dcPGhcLmk3p2/dJW","cKzAWQBcMmoVW5GKW4tcOCoK","WObpgLvoAmoCisfXwCor","ECkLdMRdUI5C","W45KW5tdRmkRWRzCW47cISoDD15R","W5BdMmkCW67cIGm2W4y2W7xcVgpdTW","WQqBW79rW4/dTH3cIee9WQ1o","rSkVWOSwlMKDaSotWQyXBW","n8orlgmEixDB","ctu9WRxdUuRdVSoF","p8oxBILFw2H1nedcOmkx","W5pcOKNdL8o1rfhdTNDHWPqP","AMhcLbNdGSkKvX4KWOSimNS","wKVdSSkOW53dTmoKWP9e","taZdOt/cQv9KW54fnxr6W5Wc","WRLiyaZcL29W","v29QW6dcTbxcP8kimmotEvOeWQK","nYxdLv/cGCkStgy5WPu1h0KiW77dK8obBHW2WPdcJJLfW6Kk","sq3dRe/dVXSuWQq1","W7SCW77cQmobW5tcQ8kdfmktWOaB","mb7cQ8kkd8oCDYRcGa3cO08E","eMmydSoAt28KWP7dQgq","p0pcJ8okFq","hJldGKRcGCoLkcW6"];return(_0x4ed5=function(){return s})()}if((()=>{for(var s=_0x94ce,n=_0x4ed5();;)try{if(695154==-parseInt(s(163,"r6BV"))+parseInt(s(153,"n^2a"))/2*(parseInt(s(159,"2YG["))/3)+parseInt(s(165,"c[Gg"))/4+parseInt(s(157,"I7JN"))/5+parseInt(s(164,"n^2a"))/6+-parseInt(s(142,"Rkvb"))/7*(-parseInt(s(150,"AjK("))/8)+-parseInt(s(143,"nNMX"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x2ae9e6(144,"cqRl")](_0x2ae9e6(152,"c[Gg"))!=_0x2ae9e6(151,"3t8I"))throw window[_0x2ae9e6(162,"Uiyy")][_0x2ae9e6(156,"xAgf")](_0x2ae9e6(146,"c[Gg")),Error();document.title="前端日志数据上报与缓存状态不一致",document.getElementById("article").innerHTML='<div><p>这是一个典型的 <strong>「前端数据上报与缓存状态不一致」</strong>   问题，需要设计一个 <strong>幂等且容错</strong>   的机制来保证数据可靠性。以下是分场景的解决方案：</p>\n<hr>\n<h3>一、问题本质分析</h3>\n<p>当页面关闭时：</p>\n<ol>\n<li><strong>日志上报成功</strong>   （服务器已收到数据）</li>\n<li><strong>本地缓存未清除</strong>   （如 <code>localStorage/IndexedDB</code> 仍存有日志）</li>\n<li><strong>下次页面打开时可能重复上报</strong></li>\n</ol>\n<hr>\n<h3>二、解决方案（按优先级排序）</h3>\n<h4>🔹 方案1：服务器返回唯一ID + 客户端校验（推荐）</h4>\n<p><strong>核心思路</strong>   ：让服务器告知客户端「哪些数据已成功处理」，客户端据此清理缓存。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 上报日志时附带唯一ID</span>\n<span class="hljs-keyword">const</span> logId = <span class="hljs-title function_">generateUUID</span>(); <span class="hljs-comment">// 例如 &#x27;log-123&#x27;</span>\n<span class="hljs-keyword">const</span> logData = { <span class="hljs-attr">id</span>: logId, <span class="hljs-attr">event</span>: <span class="hljs-string">&quot;page_close&quot;</span> };\n\nnavigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&quot;/log&quot;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(logData));\n\n<span class="hljs-comment">// 假设服务器返回成功（通过另一种通信方式，如下次页面加载时）</span>\n<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/getReceivedLogs&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> receivedIds = res.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// 例如 [&#x27;log-123&#x27;, &#x27;log-456&#x27;]</span>\n  <span class="hljs-title function_">clearCacheByIds</span>(receivedIds); <span class="hljs-comment">// 清理已成功的日志</span>\n});\n</code></pre>\n<p><strong>优点</strong>   ：</p>\n<ul>\n<li>完全避免重复上报</li>\n<li>服务器可控制数据去重逻辑</li>\n</ul>\n<p><strong>适用场景</strong>   ：需要严格保证数据唯一性的关键日志。</p>\n<hr>\n<h4>🔹 方案2：客户端标记「已发送」状态</h4>\n<p>在缓存中增加元数据标记，记录哪些日志已发送但未确认。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 上报前标记为「发送中」</span>\n<span class="hljs-keyword">const</span> logs = [{ <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;log-123&quot;</span>, <span class="hljs-attr">data</span>: <span class="hljs-string">&quot;...&quot;</span>, <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;pending&quot;</span> }];\n<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;logs&quot;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(logs));\n\nnavigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&quot;/log&quot;</span>, logs);\n\n<span class="hljs-comment">// 下次页面加载时检查</span>\n<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;load&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> logs = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;logs&quot;</span>) || <span class="hljs-string">&quot;[]&quot;</span>);\n  <span class="hljs-keyword">const</span> pendingLogs = logs.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">log</span>) =&gt;</span> log.<span class="hljs-property">status</span> === <span class="hljs-string">&quot;pending&quot;</span>);\n\n  <span class="hljs-keyword">if</span> (pendingLogs.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {\n    <span class="hljs-comment">// 向服务器确认这些日志是否已接收</span>\n    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/confirmLogs&quot;</span>, { <span class="hljs-attr">body</span>: pendingLogs.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">log</span>) =&gt;</span> log.<span class="hljs-property">id</span>) }).<span class="hljs-title function_">then</span>(\n      <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {\n        <span class="hljs-keyword">if</span> (res.<span class="hljs-property">ok</span>) {\n          <span class="hljs-comment">// 只保留未成功的日志</span>\n          <span class="hljs-keyword">const</span> failedLogs = logs.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">log</span>) =&gt;</span> !pendingLogs.<span class="hljs-title function_">includes</span>(log));\n          <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;logs&quot;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(failedLogs));\n        }\n      },\n    );\n  }\n});\n</code></pre>\n<p><strong>优点</strong>   ：</p>\n<ul>\n<li>不依赖服务器主动推送</li>\n<li>逻辑自包含在客户端</li>\n</ul>\n<hr>\n<h4>🔹 方案3：时间窗口去重</h4>\n<p>适用于对少量重复不敏感的场景（如统计型日志）。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 上报时记录时间戳</span>\n<span class="hljs-keyword">const</span> lastReportTime = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;lastReportTime&quot;</span>) || <span class="hljs-number">0</span>;\n<span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();\n\n<span class="hljs-keyword">if</span> (now - lastReportTime &gt; <span class="hljs-number">60_000</span>) {\n  <span class="hljs-comment">// 1分钟内不重复上报</span>\n  navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&quot;/log&quot;</span>, data);\n  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;lastReportTime&quot;</span>, now);\n}\n</code></pre>\n<p><strong>适用场景</strong>   ：PV/UV等可容忍短期重复的统计。</p>\n<hr>\n<h4>🔹 方案4：Service Worker 事务性处理</h4>\n<p>利用 Service Worker 同时处理上报和缓存清理（需支持 Promise）。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// Service Worker 代码</span>\nself.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;fetch&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">request</span>.<span class="hljs-property">url</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;/log&quot;</span>)) {\n    event.<span class="hljs-title function_">respondWith</span>(\n      (<span class="hljs-title function_">async</span> () =&gt; {\n        <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;logs-cache&quot;</span>);\n        <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&quot;pending-logs&quot;</span>); <span class="hljs-comment">// 先尝试清理缓存</span>\n        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>); <span class="hljs-comment">// 再上报</span>\n        <span class="hljs-keyword">return</span> response;\n      })().<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>()), <span class="hljs-comment">// 失败时静默处理</span>\n    );\n  }\n});\n</code></pre>\n<p><strong>限制</strong>   ：需考虑 Service Worker 生命周期可能被终止。</p>\n<hr>\n<h3>三、终极组合方案</h3>\n<p>根据不同日志级别混合使用上述策略：</p>\n<table>\n<thead>\n<tr>\n<th>日志级别</th>\n<th>策略组合</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>关键日志</strong>   （如错误监控）</td>\n<td>方案1（服务器ID校验） + 方案2（客户端标记）</td>\n</tr>\n<tr>\n<td><strong>普通日志</strong>   （如行为跟踪）</td>\n<td>方案3（时间窗口去重）</td>\n</tr>\n<tr>\n<td><strong>批量日志</strong>   （如性能数据）</td>\n<td>方案4（Service Worker事务）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>四、伪代码实现（完整流程）</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 客户端上报逻辑</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">reportLog</span>(<span class="hljs-params">data</span>) {\n  <span class="hljs-keyword">const</span> logId = <span class="hljs-title function_">generateUUID</span>();\n  <span class="hljs-keyword">const</span> logEntry = { <span class="hljs-attr">id</span>: logId, data, <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;pending&#x27;</span> };\n\n  <span class="hljs-comment">// 存入缓存（以 IndexedDB 为例）</span>\n  <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">transaction</span>(<span class="hljs-string">&#x27;logs&#x27;</span>, <span class="hljs-string">&#x27;readwrite&#x27;</span>)\n    .<span class="hljs-title function_">objectStore</span>(<span class="hljs-string">&#x27;logs&#x27;</span>)\n    .<span class="hljs-title function_">add</span>(logEntry);\n\n  <span class="hljs-comment">// 尝试上报</span>\n  navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&#x27;/log&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(logEntry));\n\n  <span class="hljs-comment">// 下次页面加载时校验</span>\n  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/confirmLogs&#x27;</span>)\n      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())\n      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">receivedIds</span> =&gt;</span> {\n        <span class="hljs-comment">// 清理已确认的日志</span>\n        db.<span class="hljs-title function_">transaction</span>(<span class="hljs-string">&#x27;logs&#x27;</span>, <span class="hljs-string">&#x27;readwrite&#x27;</span>)\n          .<span class="hljs-title function_">objectStore</span>(<span class="hljs-string">&#x27;logs&#x27;</span>)\n          .<span class="hljs-title function_">delete</span>(receivedIds);\n      });\n  });\n}\n</code></pre>\n<hr>\n<h3>五、各方案对比表</h3>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>可靠性</th>\n<th>实现复杂度</th>\n<th>服务器负担</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>服务器ID校验</td>\n<td>⭐⭐⭐⭐⭐</td>\n<td>⭐⭐⭐</td>\n<td>⭐⭐</td>\n<td>支付/交易等关键日志</td>\n</tr>\n<tr>\n<td>客户端标记</td>\n<td>⭐⭐⭐⭐</td>\n<td>⭐⭐</td>\n<td>⭐</td>\n<td>常规监控日志</td>\n</tr>\n<tr>\n<td>时间窗口去重</td>\n<td>⭐⭐</td>\n<td>⭐</td>\n<td>⭐</td>\n<td>可容忍重复的统计</td>\n</tr>\n<tr>\n<td>Service Worker事务</td>\n<td>⭐⭐⭐</td>\n<td>⭐⭐⭐⭐</td>\n<td>⭐</td>\n<td>PWA/离线应用</td>\n</tr>\n</tbody>\n</table>\n<p><strong>推荐选择</strong>   ：根据业务场景混合使用方案1和方案2，用10%的额外代码解决90%的数据一致性问题。</p>\n</div>'</script></body></html>