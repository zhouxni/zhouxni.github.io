<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4c2b(l,s){var e=_0x7c8e();return(_0x4c2b=function(s,n){var a=e[s-=409];void 0===_0x4c2b.ovLjgr&&(_0x4c2b.khtoMl=function(s,n){var a,t=[],l=0,e="";for(s=(s=>{for(var n,a,t="",l="",e=0,c=0;a=s.charAt(c++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,p=t.length;o<p;o++)l+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)l=(l+t[c]+n.charCodeAt(c%n.length))%256,a=t[c],t[c]=t[l],t[l]=a;for(var c=0,l=0,o=0;o<s.length;o++)a=t[c=(c+1)%256],t[c]=t[l=(l+t[c])%256],t[l]=a,e+=String.fromCharCode(s.charCodeAt(o)^t[(t[c]+t[l])%256]);return e},l=arguments,_0x4c2b.ovLjgr=!0);var s=s+e[0],t=l[s];return t?a=t:(void 0===_0x4c2b.qQDsXQ&&(_0x4c2b.qQDsXQ=!0),a=_0x4c2b.khtoMl(a,n),l[s]=a),a})(l,s)}var _0x1d2432=_0x4c2b;function _0x7c8e(){var s=["zXRcLaxcMSoPWOHKWPyFbgS","ENHBn8kcW7xcI0xdLa","W5FcIttdQcZdP8k7xSk2","gY9xW7ZcGu/cLW","W57dL13dRW7dHmkT","WOzvWOa8gMtdHSkLWR1PWRBdOW","W57dNNOeWP/cLmo7","EIKvxSkzW5G0Ea","W6rdWRaqW43cKYxcJNtcVJ3cG8kv","WOddTL5jWP9Mf8o/fmowW6b0sW","fSkFmCkLhM/dOSobrCkivmo8","ESokxatdLCkjFW","vmkUoNBdTqpdMW","rYy0fSoWW6KmWRRcRSk0WO7cGW","WQZcJeldUcVcSdq","WOFcGCkMaHXfW4XbnmkFWRz2lK3dTSkGWP8YmSkDu8klWQXntLa","q8k+puZdUa","aCoZEW3cTLBdLCkExmoCyKm","FwiEpuFcHSkVAmoD","WPrQW5bMWPryta","W7JcLCkYW5i2W5fzW4ampLGY","wwSabSkxbNC","lGKlW4uxW5FcLCoJtHPAW6JdVq","bLVcSmkDdx1xWPJdOSoGW6mpna","WR1tW7VcP8kVW5FdVshcJmkWWQD0WPW","Amo6vby+WQxcLSoOCtKerdS","bmo9DWZcSLddLCkbBSooxhW","WRBdOmkGWOpcPConn0/cVW","vXPUW7q/iZBcNSke","WPZcNmoiW68rFajYWOSfngC"];return(_0x7c8e=function(){return s})()}if((()=>{for(var s=_0x4c2b,n=_0x7c8e();;)try{if(803108==+parseInt(s(417,"^Qxn"))*(parseInt(s(432,"CbDu"))/2)+-parseInt(s(436,"fL6Z"))/3*(parseInt(s(409,"n5Mg"))/4)+-parseInt(s(434,"Crk8"))/5*(-parseInt(s(416,"v1#e"))/6)+-parseInt(s(431,"AjV("))/7*(-parseInt(s(412,"wGv9"))/8)+-parseInt(s(429,"1jE4"))/9+-parseInt(s(430,"qu!x"))/10+-parseInt(s(426,")k*h"))/11*(parseInt(s(424,"a@A5"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1d2432(418,"CbDu")](_0x1d2432(437,"&d&*"))!=_0x1d2432(422,"CbDu"))throw window[_0x1d2432(413,"Co&r")][_0x1d2432(420,"C2Qe")](_0x1d2432(421,"fhLd")),Error();document.title="Vue 3 中 toRaw 与 toValue 的区别解析",document.getElementById("article").innerHTML='<div><p><code>toRaw</code> 和 <code>toValue</code> 是 Vue 3 响应式系统中两个容易混淆的工具函数，它们都用于处理响应式对象，但用途和实现有本质区别。</p>\n<h2>核心区别对比</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>toRaw</code></th>\n<th><code>toValue</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>所属包</strong></td>\n<td><code>@vue/reactivity</code></td>\n<td><code>@vue/reactivity</code> (Vue 3.3+新增)</td>\n</tr>\n<tr>\n<td><strong>主要用途</strong></td>\n<td>获取响应式对象的原始非代理对象</td>\n<td>统一获取 ref/reactive 的原始值</td>\n</tr>\n<tr>\n<td><strong>处理类型</strong></td>\n<td>仅处理 reactive/proxy 对象</td>\n<td>处理 ref、getters、普通值等所有类型</td>\n</tr>\n<tr>\n<td><strong>返回值</strong></td>\n<td>原始非响应式对象</td>\n<td>解包后的基础值</td>\n</tr>\n<tr>\n<td><strong>Vue 版本</strong></td>\n<td>所有 Vue 3 版本</td>\n<td>Vue 3.3 及以上</td>\n</tr>\n</tbody>\n</table>\n<h2><code>toRaw</code> 深度解析</h2>\n<h3>源码实现 (vue-next/packages/reactivity/src/reactive.ts)</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> toRaw&lt;T&gt;(<span class="hljs-attr">observed</span>: T): T {\n  <span class="hljs-keyword">const</span> raw = observed &amp;&amp; (observed <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">__v_raw</span>;\n  <span class="hljs-keyword">return</span> raw ? <span class="hljs-title function_">toRaw</span>(raw) : observed;\n}\n</code></pre>\n<h3>使用场景</h3>\n<ol>\n<li>\n<p><strong>获取 reactive 的原始对象</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> };\n<span class="hljs-keyword">const</span> reactiveObj = <span class="hljs-title function_">reactive</span>(obj);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">toRaw</span>(reactiveObj) === obj); <span class="hljs-comment">// true</span>\n</code></pre>\n</li>\n<li>\n<p><strong>避免 Proxy 开销的性能优化</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> bigData = <span class="hljs-title function_">reactive</span>(<span class="hljs-comment">/* 大型数据集 */</span>);\n<span class="hljs-comment">// 性能敏感操作使用原始数据</span>\n<span class="hljs-title function_">processLargeData</span>(<span class="hljs-title function_">toRaw</span>(bigData));\n</code></pre>\n</li>\n<li>\n<p><strong>与不识别 Proxy 的库集成</strong></p>\n<pre><code class="language-javascript"><span class="hljs-title function_">thirdPartyLib</span>(<span class="hljs-title function_">toRaw</span>(reactiveObject));\n</code></pre>\n</li>\n</ol>\n<h3>注意事项</h3>\n<ul>\n<li>修改返回的原始对象不会触发响应式更新</li>\n<li>对 ref 无效（需要使用 <code>toRaw(ref.value)</code>）</li>\n</ul>\n<h2><code>toValue</code> 深度解析</h2>\n<h3>源码实现 (vue-next/packages/reactivity/src/toValue.ts)</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> toValue&lt;T&gt;(<span class="hljs-attr">source</span>: T): T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Ref</span>&lt;infer V&gt; ? V : T {\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">isRef</span>(source) ? source.<span class="hljs-property">value</span> : source;\n}\n</code></pre>\n<h3>使用场景</h3>\n<ol>\n<li>\n<p><strong>统一处理 ref 和 reactive</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span> });\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">toValue</span>(count)); <span class="hljs-comment">// 0 (解包 ref)</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">toValue</span>(state.<span class="hljs-property">foo</span>)); <span class="hljs-comment">// &#x27;bar&#x27; (直接返回值)</span>\n</code></pre>\n</li>\n<li>\n<p><strong>组合式函数返回值处理</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useFeature</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">count</span>: <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>),\n    <span class="hljs-attr">state</span>: <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span> }),\n  };\n}\n\n<span class="hljs-keyword">const</span> { count, state } = <span class="hljs-title function_">useFeature</span>();\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">toValue</span>(count), <span class="hljs-title function_">toValue</span>(state.<span class="hljs-property">foo</span>));\n</code></pre>\n</li>\n<li>\n<p><strong>响应式值作为参数传递</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processValue</span>(<span class="hljs-params">val</span>) {\n  <span class="hljs-keyword">const</span> actualValue = <span class="hljs-title function_">toValue</span>(val);\n  <span class="hljs-comment">// 处理基础值</span>\n}\n\n<span class="hljs-comment">// 可以接受 ref 或普通值</span>\n<span class="hljs-title function_">processValue</span>(<span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>));\n<span class="hljs-title function_">processValue</span>(<span class="hljs-number">2</span>);\n</code></pre>\n</li>\n</ol>\n<h3>注意事项</h3>\n<ul>\n<li>Vue 3.3+ 新增 API，低版本不可用</li>\n<li>设计目的是统一值访问方式</li>\n<li>对嵌套 ref 只会解包一层</li>\n</ul>\n<h2>典型场景对比</h2>\n<h3>场景 1：获取底层值</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> };\n<span class="hljs-keyword">const</span> refObj = <span class="hljs-title function_">ref</span>(obj);\n<span class="hljs-keyword">const</span> reactiveObj = <span class="hljs-title function_">reactive</span>(obj);\n\n<span class="hljs-comment">// toRaw 处理</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">toRaw</span>(reactiveObj) === obj); <span class="hljs-comment">// true</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">toRaw</span>(refObj) === refObj); <span class="hljs-comment">// true (对 ref 无效)</span>\n\n<span class="hljs-comment">// toValue 处理</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">toValue</span>(refObj) === obj); <span class="hljs-comment">// true</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">toValue</span>(reactiveObj) === reactiveObj); <span class="hljs-comment">// true (对 reactive 无效)</span>\n</code></pre>\n<h3>场景 2：函数参数处理</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params">param</span>) {\n  <span class="hljs-comment">// 如果 param 可能是 ref 或普通值</span>\n  <span class="hljs-keyword">const</span> raw = <span class="hljs-title function_">toRaw</span>(param); <span class="hljs-comment">// 错误方式：无法处理 ref</span>\n  <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">toValue</span>(param); <span class="hljs-comment">// 正确方式：统一处理</span>\n\n  <span class="hljs-comment">// 使用 value...</span>\n}\n</code></pre>\n<h2>设计哲学差异</h2>\n<ol>\n<li>\n<p><strong><code>toRaw</code></strong>   ：</p>\n<ul>\n<li>关注响应式对象的&quot;原始形态&quot;</li>\n<li>是响应式系统的逆向操作</li>\n<li>主要用于底层操作和性能优化</li>\n</ul>\n</li>\n<li>\n<p><strong><code>toValue</code></strong>   ：</p>\n<ul>\n<li>关注获取可用的&quot;工作值&quot;</li>\n<li>是响应式系统的辅助工具</li>\n<li>主要用于简化 API 设计和使用</li>\n</ul>\n</li>\n</ol>\n<h2>何时使用哪个？</h2>\n<ul>\n<li>需要操作<strong>非代理对象</strong>   时 → <code>toRaw</code></li>\n<li>需要获取<strong>最终使用的值</strong>   时 → <code>toValue</code></li>\n<li>编写通用工具函数时 → <code>toValue</code></li>\n<li>进行性能优化时 → <code>toRaw</code></li>\n</ul>\n<h2>总结</h2>\n<p><code>toRaw</code> 和 <code>toValue</code> 代表了 Vue 响应式系统中两种不同的值访问维度：</p>\n<ul>\n<li><code>toRaw</code> 是&quot;垂直&quot;访问，从代理层穿透到原始层</li>\n<li><code>toValue</code> 是&quot;水平&quot;访问，统一 ref 和非 ref 的值获取方式</li>\n</ul>\n<p>理解这两者的区别有助于在 Vue 3 开发中选择正确的工具，特别是在编写组合式函数和工具库时，能够更精确地控制值的访问层级。</p>\n</div>'</script></body></html>