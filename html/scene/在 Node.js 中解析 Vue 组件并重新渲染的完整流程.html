<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1eca(p,s){var t=_0x2678();return(_0x1eca=function(s,n){var a=t[s-=162];void 0===_0x1eca.eCRWox&&(_0x1eca.lNDfjZ=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,e=0;a=s.charAt(e++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=l.length;c<o;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[p],l[p]=a;for(var e=0,p=0,c=0;c<s.length;c++)a=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[p])%256]);return t},p=arguments,_0x1eca.eCRWox=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x1eca.eXuQNv&&(_0x1eca.eXuQNv=!0),a=_0x1eca.lNDfjZ(a,n),p[s]=a),a})(p,s)}var _0x4a9f8b=_0x1eca;function _0x2678(){var s=["cadcHvW9WRug","W7dcRMrglLNdQW","vCoSWPj2WRiWyG","W5pcUJVcI8o2jCkbCdbTngC6","vdSqbvtdO8ou","EwX7lCkkW7VdHG","WO0knY89wdyzW7JcQmkQW5ZdNJpcHKdcIxblWRBcUrO2WRRcUfC","tJLjWPBcIHytW4NcTa","ELRcGSk1cq","W5pcVJ/cJSo7jmkhxrPZb2Cl","W7dcL8kAd3tcSmoWpCkZWQPWfa","W5fmCML7wYLGW7dcSSkNW73dRW","pwbQWRZcK2VcHSkvWOtcOt/cPSks","W4BdNrxcKSkioSk6W6qll2e9","drpcK0u8WPyI","bgPrErBcSSo9pdlcLCk+WPq","WPX7W5n7W47cMGC/qwJdVCktWQi","n2mCW4pdJfmtW5xcPHicWOG","iw5LWOZcKSoSpq","pwtcJabAEZtcTaLdWOldNG","WPGKWPK/WOBdPL8","W4bli1nHmtqe","W6lcRbnxi2DrW7TpWO3cTG","W7pdUaGCDfFdG3uXmGy","Fs0nySosWOxdRqObsKJdOq","W4/dLbxcLSkjpCodW4OWlhW3W6e"];return(_0x2678=function(){return s})()}if((()=>{for(var s=_0x1eca,n=_0x2678();;)try{if(123714==-parseInt(s(166,")$Q6"))*(-parseInt(s(174,"@&c0"))/2)+parseInt(s(167,"@&c0"))/3+-parseInt(s(184,"H#A9"))/4*(parseInt(s(163,"HDV7"))/5)+parseInt(s(185,"HDV7"))/6+parseInt(s(169,"05YH"))/7*(parseInt(s(182,"$4J!"))/8)+parseInt(s(168,"$4J!"))/9+-parseInt(s(181,"$lZ7"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x4a9f8b(173,"H#A9")](_0x4a9f8b(176,"Y9Z3"))!=_0x4a9f8b(177,"@^dK"))throw window[_0x4a9f8b(164,"@T]*")][_0x4a9f8b(187,"T2vY")](_0x4a9f8b(175,"zWGY")),Error();document.title="在 Node.js 中解析 Vue 组件并重新渲染的完整流程",document.getElementById("article").innerHTML='<div><h1>在 Node.js 中解析 Vue 组件并重新渲染的完整流程</h1>\n<p>下面我将详细介绍如何在 Node.js 环境中解析 Vue 组件、获取其实例和方法，然后使用 <code>@vue/server-renderer</code> 进行服务器端渲染的完整实现方案。</p>\n<h2>完整实现方案</h2>\n<h3>1. 安装必要依赖</h3>\n<pre><code class="language-bash">npm install vue @vue/compiler-sfc @vue/server-renderer jsdom\n</code></pre>\n<h3>2. 实现代码</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);\n<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);\n<span class="hljs-keyword">const</span> { parse, compileScript } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@vue/compiler-sfc&quot;</span>);\n<span class="hljs-keyword">const</span> { compileTemplate } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@vue/compiler-dom&quot;</span>);\n<span class="hljs-keyword">const</span> { renderToString } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@vue/server-renderer&quot;</span>);\n<span class="hljs-keyword">const</span> { createSSRApp } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vue&quot;</span>);\n<span class="hljs-keyword">const</span> { <span class="hljs-variable constant_">JSDOM</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;jsdom&quot;</span>);\n\n<span class="hljs-comment">// 1. 设置JSDOM环境模拟浏览器环境</span>\n<span class="hljs-keyword">const</span> { <span class="hljs-variable language_">window</span> } = <span class="hljs-keyword">new</span> <span class="hljs-title function_">JSDOM</span>(<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;&quot;</span>, {\n  <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://localhost/&quot;</span>,\n});\n<span class="hljs-variable language_">global</span>.<span class="hljs-property">window</span> = <span class="hljs-variable language_">window</span>;\n<span class="hljs-variable language_">global</span>.<span class="hljs-property">document</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">document</span>;\n\n<span class="hljs-comment">// 2. 解析Vue组件文件的函数</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">parseVueComponent</span>(<span class="hljs-params">filePath</span>) {\n  <span class="hljs-comment">// 读取Vue文件内容</span>\n  <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(path.<span class="hljs-title function_">resolve</span>(filePath), <span class="hljs-string">&quot;utf-8&quot;</span>);\n\n  <span class="hljs-comment">// 解析SFC</span>\n  <span class="hljs-keyword">const</span> { descriptor } = <span class="hljs-title function_">parse</span>(content);\n\n  <span class="hljs-comment">// 编译脚本部分</span>\n  <span class="hljs-keyword">const</span> scriptResult = <span class="hljs-title function_">compileScript</span>(descriptor, {\n    <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;comp-id&quot;</span>,\n    <span class="hljs-attr">reactivityTransform</span>: <span class="hljs-literal">false</span>,\n  });\n\n  <span class="hljs-comment">// 编译模板部分</span>\n  <span class="hljs-keyword">const</span> templateResult = <span class="hljs-title function_">compileTemplate</span>({\n    <span class="hljs-attr">source</span>: descriptor.<span class="hljs-property">template</span>.<span class="hljs-property">content</span>,\n    <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;comp-id&quot;</span>,\n    <span class="hljs-attr">filename</span>: filePath,\n  });\n\n  <span class="hljs-comment">// 创建沙箱环境执行组件代码</span>\n  <span class="hljs-keyword">const</span> sandbox = {\n    <span class="hljs-attr">module</span>: { <span class="hljs-attr">exports</span>: {} },\n    <span class="hljs-attr">exports</span>: {},\n    <span class="hljs-built_in">require</span>,\n    <span class="hljs-variable language_">console</span>,\n    <span class="hljs-variable language_">window</span>,\n    <span class="hljs-variable language_">document</span>,\n  };\n\n  <span class="hljs-comment">// 执行编译后的脚本代码</span>\n  vm.<span class="hljs-title function_">runInNewContext</span>(scriptResult.<span class="hljs-property">content</span>, sandbox);\n\n  <span class="hljs-comment">// 获取组件选项对象</span>\n  <span class="hljs-keyword">const</span> componentOptions =\n    sandbox.<span class="hljs-property">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">default</span> || sandbox.<span class="hljs-property">module</span>.<span class="hljs-property">exports</span>;\n\n  <span class="hljs-comment">// 添加编译后的渲染函数</span>\n  componentOptions.<span class="hljs-property">render</span> = templateResult.<span class="hljs-property">code</span>;\n\n  <span class="hljs-keyword">return</span> componentOptions;\n}\n\n<span class="hljs-comment">// 3. 渲染组件的函数</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderComponent</span>(<span class="hljs-params">componentOptions, props = {}</span>) {\n  <span class="hljs-comment">// 创建SSR应用实例</span>\n  <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createSSRApp</span>({\n    ...componentOptions,\n    <span class="hljs-attr">props</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(props),\n  });\n\n  <span class="hljs-comment">// 创建容器元素</span>\n  <span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);\n\n  <span class="hljs-comment">// 渲染组件到字符串</span>\n  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> <span class="hljs-title function_">renderToString</span>(app, props);\n\n  <span class="hljs-keyword">return</span> {\n    html,\n    <span class="hljs-attr">instance</span>: app.<span class="hljs-property">_component</span>, <span class="hljs-comment">// 获取组件实例</span>\n    <span class="hljs-attr">methods</span>: componentOptions.<span class="hljs-property">methods</span> || {}, <span class="hljs-comment">// 获取组件方法</span>\n  };\n}\n\n<span class="hljs-comment">// 4. 使用示例</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-comment">// 解析Vue组件</span>\n    <span class="hljs-keyword">const</span> componentOptions = <span class="hljs-keyword">await</span> <span class="hljs-title function_">parseVueComponent</span>(<span class="hljs-string">&quot;./ExampleComponent.vue&quot;</span>);\n\n    <span class="hljs-comment">// 可以在这里访问组件选项和方法</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;组件选项:&quot;</span>, componentOptions);\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;组件方法:&quot;</span>, componentOptions.<span class="hljs-property">methods</span>);\n\n    <span class="hljs-comment">// 使用props渲染组件</span>\n    <span class="hljs-keyword">const</span> { html, instance } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">renderComponent</span>(componentOptions, {\n      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello from server!&quot;</span>,\n    });\n\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;渲染结果:&quot;</span>, html);\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;组件实例:&quot;</span>, instance);\n\n    <span class="hljs-comment">// 返回完整的HTML文档</span>\n    <span class="hljs-keyword">const</span> fullHtml = <span class="hljs-string">`\n      &lt;!DOCTYPE html&gt;\n      &lt;html&gt;\n        &lt;head&gt;\n          &lt;title&gt;Server Rendered Vue Component&lt;/title&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n          &lt;div id=&quot;app&quot;&gt;<span class="hljs-subst">${html}</span>&lt;/div&gt;\n          &lt;script&gt;\n            // 这里可以添加客户端hydration代码\n            window.__INITIAL_STATE__ = <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(instance.$data)}</span>;\n          &lt;/script&gt;\n        &lt;/body&gt;\n      &lt;/html&gt;\n    `</span>;\n\n    <span class="hljs-keyword">return</span> fullHtml;\n  } <span class="hljs-keyword">catch</span> (err) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;渲染失败:&quot;</span>, err);\n    <span class="hljs-keyword">throw</span> err;\n  }\n}\n\n<span class="hljs-comment">// 执行主函数</span>\n<span class="hljs-title function_">main</span>()\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">html</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;最终HTML:&quot;</span>, html);\n    <span class="hljs-comment">// 这里可以将html发送给客户端或保存到文件</span>\n  })\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);\n</code></pre>\n<h2>关键点解析</h2>\n<h3>1. 环境模拟</h3>\n<p>使用 <code>JSDOM</code> 创建浏览器环境，因为 Vue 的服务器端渲染仍然需要基本的 DOM API：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-variable constant_">JSDOM</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;jsdom&quot;</span>);\n<span class="hljs-keyword">const</span> { <span class="hljs-variable language_">window</span> } = <span class="hljs-keyword">new</span> <span class="hljs-title function_">JSDOM</span>(<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;&quot;</span>, {\n  <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://localhost/&quot;</span>,\n});\n<span class="hljs-variable language_">global</span>.<span class="hljs-property">window</span> = <span class="hljs-variable language_">window</span>;\n<span class="hljs-variable language_">global</span>.<span class="hljs-property">document</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">document</span>;\n</code></pre>\n<h3>2. 组件解析流程</h3>\n<ol>\n<li><strong>读取文件内容</strong>   ：使用 Node.js 的 <code>fs</code> 模块读取 <code>.vue</code> 文件</li>\n<li><strong>解析 SFC</strong>   ：使用 <code>@vue/compiler-sfc</code> 解析单文件组件</li>\n<li><strong>编译脚本</strong>   ：提取 <code>&lt;script&gt;</code> 部分并编译</li>\n<li><strong>编译模板</strong>   ：编译 <code>&lt;template&gt;</code> 部分生成渲染函数</li>\n<li><strong>执行组件代码</strong>   ：在沙箱环境中执行编译后的脚本</li>\n</ol>\n<h3>3. 服务器端渲染</h3>\n<ol>\n<li><strong>创建 SSR 应用</strong>   ：使用 <code>createSSRApp</code> 创建应用实例</li>\n<li><strong>渲染为字符串</strong>   ：使用 <code>renderToString</code> 渲染组件</li>\n<li><strong>处理 props</strong>   ：支持传入 props 数据</li>\n<li><strong>获取实例和方法</strong>   ：通过应用实例访问组件实例和方法</li>\n</ol>\n<h3>4. 客户端 Hydration 准备</h3>\n<p>在返回的 HTML 中包含初始状态，以便客户端可以 hydrate：</p>\n<pre><code class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">__INITIAL_STATE__</span> = ${<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(instance.<span class="hljs-property">$data</span>)};\n</code></pre>\n<h2>高级用法</h2>\n<h3>1. 支持 CSS</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在parseVueComponent函数中添加</span>\n<span class="hljs-keyword">if</span> (descriptor.<span class="hljs-property">styles</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {\n  <span class="hljs-keyword">const</span> style = descriptor.<span class="hljs-property">styles</span>[<span class="hljs-number">0</span>].<span class="hljs-property">content</span>;\n  componentOptions.<span class="hljs-property">style</span> = style;\n}\n\n<span class="hljs-comment">// 然后在渲染时添加到head中</span>\n<span class="hljs-keyword">const</span> styleTag = <span class="hljs-string">`&lt;style&gt;<span class="hljs-subst">${componentOptions.style}</span>&lt;/style&gt;`</span>;\n</code></pre>\n<h3>2. 自定义指令支持</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在创建app时注册全局指令</span>\n<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createSSRApp</span>({\n  ...componentOptions,\n  <span class="hljs-attr">directives</span>: {\n    <span class="hljs-comment">// 你的自定义指令</span>\n  },\n});\n</code></pre>\n<h3>3. 异步组件支持</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在组件选项中处理异步setup</span>\n<span class="hljs-keyword">if</span> (componentOptions.<span class="hljs-property">setup</span>) {\n  <span class="hljs-keyword">await</span> componentOptions.<span class="hljs-title function_">setup</span>();\n}\n</code></pre>\n<h2>性能优化</h2>\n<ol>\n<li><strong>缓存编译结果</strong>   ：对解析后的组件进行缓存</li>\n<li><strong>并行渲染</strong>   ：使用 Promise.all 并行渲染多个组件</li>\n<li><strong>流式渲染</strong>   ：对于大型组件，使用 <code>renderToStream</code></li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { renderToStream } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@vue/server-renderer&quot;</span>);\n\n<span class="hljs-comment">// 流式渲染示例</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">renderToStream</span>(<span class="hljs-params">app</span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> stream = <span class="hljs-title function_">renderToStream</span>(app);\n    <span class="hljs-keyword">let</span> html = <span class="hljs-string">&quot;&quot;</span>;\n\n    stream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {\n      html += chunk;\n    });\n\n    stream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(html));\n    stream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;error&quot;</span>, reject);\n  });\n}\n</code></pre>\n<h2>错误处理</h2>\n<ol>\n<li><strong>组件解析错误</strong>   ：捕获文件读取和编译错误</li>\n<li><strong>渲染错误</strong>   ：处理渲染过程中的错误</li>\n<li><strong>props验证</strong>   ：确保传入的props符合组件要求</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-keyword">try</span> {\n  <span class="hljs-comment">// 解析和渲染代码</span>\n} <span class="hljs-keyword">catch</span> (err) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;渲染错误:&quot;</span>, err);\n  <span class="hljs-comment">// 返回错误页面或回退内容</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;div&gt;渲染出错，请稍后再试&lt;/div&gt;&quot;</span>;\n}\n</code></pre>\n<p>这个完整方案提供了从解析 Vue 组件到服务器端渲染的完整流程，你可以根据需要进一步扩展或调整各个部分。</p>\n</div>'</script></body></html>