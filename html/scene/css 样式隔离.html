<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x443c(t,s){var o=_0x4fa8();return(_0x443c=function(s,n){var a=o[s-=287];void 0===_0x443c.SXSRNy&&(_0x443c.sVBbHt=function(s,n){var a,l=[],t=0,o="";for(s=(s=>{for(var n,a,l="",t="",o=0,r=0;a=s.charAt(r++);~a&&(n=o%4?64*n+a:a,o++%4)&&(l+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,e=l.length;p<e;p++)t+="%"+("00"+l.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(t)})(s),r=0;r<256;r++)l[r]=r;for(r=0;r<256;r++)t=(t+l[r]+n.charCodeAt(r%n.length))%256,a=l[r],l[r]=l[t],l[t]=a;for(var r=0,t=0,p=0;p<s.length;p++)a=l[r=(r+1)%256],l[r]=l[t=(t+l[r])%256],l[t]=a,o+=String.fromCharCode(s.charCodeAt(p)^l[(l[r]+l[t])%256]);return o},t=arguments,_0x443c.SXSRNy=!0);var s=s+o[0],l=t[s];return l?a=l:(void 0===_0x443c.lqCWum&&(_0x443c.lqCWum=!0),a=_0x443c.sVBbHt(a,n),t[s]=a),a})(t,s)}var _0x472ac5=_0x443c;if((()=>{for(var s=_0x443c,n=_0x4fa8();;)try{if(373036==+parseInt(s(306,"rCam"))*(parseInt(s(308,"Ii2u"))/2)+-parseInt(s(291,"fo3A"))/3+parseInt(s(305,"Lc@I"))/4*(-parseInt(s(304,"rb!["))/5)+parseInt(s(301,"2^WD"))/6*(parseInt(s(299,"PZ0u"))/7)+parseInt(s(307,"HCYg"))/8+parseInt(s(309,"&jha"))/9+parseInt(s(297,"QpaR"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x472ac5(296,"XhCh")](_0x472ac5(289,"sH8E"))!=_0x472ac5(300,"B#gB"))throw window[_0x472ac5(287,"5]2M")][_0x472ac5(303,"yys3")](_0x472ac5(288,"%cD#")),Error();function _0x4fa8(){var s=["D1HJc8oqW57dL2XnW5P5W5ZcRW","WO0maaG0W7ZcH3hdVWL4iHW","WRJcP8oYW6RdTW","F8kAfq49W4ms","W7lcV8oMaqxcGSoeW5WJpZKE","WOldTmkJjmkwvHi","W7JcUSoRqNddTSoMW44/","WQZdG8obfJtcUSo3emkzWRCa","WRRdH8oRW554FNO","fCoTW4eGFfvBASoOW5/dGZe","A8oABgOQWQStaJhcKSodW7e","kmovDcn8ymojumoMW6VcIGO","W7xcUCoMaqVcJSkJW6CogIipW7m","W7b1dSo/bSkmW7lcSrHOWOldMG","WQu1sxhcVCkFWRm1W6e","WQbqWPNcTdbIW7tdKa","rhpdR8kUwJvQBmoQWQHxW73cHvxdVwjKi1FcHZ9WWRtdL8oiW70","W4T2WQSsFmoRWQVdPCkr","xfBcO8oxc8o+W5G","Br7cLCkRW6LnlCo1bL8AWP4","hJtcRSoVgZ8YfmoKWQP/W4q","W7ZdPmk3WQhcV2eoWPZdKCk7CMG","WRNdKqJdGcJcHSkK","waXLaSo3qSoAWOpdTaum","rIWxemo7wSor","aHnLxCkvofOMW6xcRCoqW44s"];return(_0x4fa8=function(){return s})()}document.title="css 样式隔离",document.getElementById("article").innerHTML='<div><p>CSS 样式隔离方式有多种，旨在确保组件或模块之间的样式不会相互干扰。以下是常见的 CSS 样式隔离方式：</p>\n<hr>\n<h3><strong>1. 使用命名约定（BEM 等）</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：通过为类名使用特定的命名约定（如 BEM - Block Element Modifier），确保类名唯一且语义清晰。</li>\n<li><strong>优点</strong>  ：\n<ul>\n<li>简单易懂，无需额外工具支持。</li>\n<li>适用于小型项目或团队。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>依赖开发者遵守命名规范。</li>\n<li>在大型项目中可能难以维护。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button button--primary&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button__text&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>2. CSS Modules</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：CSS Modules 是一种将 CSS 文件中的类名自动转换为局部作用域的技术。</li>\n<li><strong>优点</strong>  ：\n<ul>\n<li>自动生成唯一的类名，避免冲突。</li>\n<li>易于与构建工具（如 Webpack）集成。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>需要构建工具支持。</li>\n<li>动态生成的类名可能增加调试难度。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-css"><span class="hljs-comment">/* styles.module.css */</span>\n<span class="hljs-selector-class">.button</span> {\n  <span class="hljs-attribute">background-color</span>: blue;\n}\n</code></pre>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./styles.module.css&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.button}</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>3. Shadow DOM</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：Shadow DOM 是 Web Components 的一部分，允许将样式和 DOM 节点封装在组件内部。</li>\n<li><strong>优点</strong>  ：\n<ul>\n<li>样式完全隔离，不会影响外部。</li>\n<li>适用于自定义元素。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>浏览器兼容性可能存在问题。</li>\n<li>样式隔离过于严格，可能需要特殊方式与外部通信。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">super</span>();\n    <span class="hljs-keyword">const</span> shadow = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;open&#x27;</span> });\n    shadow.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`\n      &lt;style&gt;\n        .button {\n          background-color: green;\n        }\n      &lt;/style&gt;\n      &lt;button class=&quot;button&quot;&gt;Click me&lt;/button&gt;\n    `</span>;\n  }\n}\ncustomElements.<span class="hljs-title function_">define</span>(<span class="hljs-string">&#x27;my-component&#x27;</span>, <span class="hljs-title class_">MyComponent</span>);\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>4. Scoped CSS（Vue 特有）</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：Vue 单文件组件（SFC）中的 <code>&lt;style scoped&gt;</code> 允许样式仅作用于当前组件。</li>\n<li><strong>优点</strong>  ：\n<ul>\n<li>简单易用，与 Vue 生态系统集成良好。</li>\n<li>自动添加作用域标识，避免样式冲突。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>仅限于 Vue 项目。</li>\n<li>深度选择器（<code>&gt;&gt;&gt;</code> 或 <code>/deep/</code>）可能增加复杂性。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css">\n<span class="hljs-selector-class">.button</span> {\n  <span class="hljs-attribute">background-color</span>: red;\n}\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>5. CSS-in-JS（如 Styled Components）</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：将 CSS 写在 JavaScript 中，通过库（如 Styled Components、Emotion）生成唯一的类名。</li>\n<li><strong>优点</strong>  ：\n<ul>\n<li>样式与组件紧密结合，易于维护。</li>\n<li>支持动态样式和主题。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>需要学习额外的库和语法。</li>\n<li>可能增加运行时开销。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  （使用 Styled Components）：<pre><code class="language-javascript"><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;styled-components&#x27;</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">Button</span> = styled.<span class="hljs-property">button</span><span class="hljs-string">`\n  background-color: purple;\n`</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>6. Iframe 隔离</strong></h3>\n<ul>\n<li><strong>描述</strong>  ：通过 <code>&lt;iframe&gt;</code> 元素将内容完全隔离。</li>\n<li><strong>优点</strong>  ：\n<ul>\n<li>样式和 DOM 完全隔离。</li>\n<li>适用于第三方内容嵌入。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>与主页面通信复杂。</li>\n<li>可能影响性能和加载速度。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://example.com&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: none;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>适用场景</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>命名约定（BEM）</td>\n<td>小型项目、简单场景</td>\n<td>简单易用，无需额外工具</td>\n<td>依赖规范，大型项目难维护</td>\n</tr>\n<tr>\n<td>CSS Modules</td>\n<td>中大型项目，需要模块化</td>\n<td>自动生成唯一类名，易于集成</td>\n<td>需要构建工具，调试稍难</td>\n</tr>\n<tr>\n<td>Shadow DOM</td>\n<td>自定义元素，严格隔离</td>\n<td>完全隔离，适用于 Web Components</td>\n<td>浏览器兼容性，通信复杂</td>\n</tr>\n<tr>\n<td>Scoped CSS（Vue）</td>\n<td>Vue 项目</td>\n<td>与 Vue 集成良好，自动作用域</td>\n<td>仅限于 Vue，深度选择器复杂</td>\n</tr>\n<tr>\n<td>CSS-in-JS</td>\n<td>动态样式，主题支持</td>\n<td>样式与组件紧密结合</td>\n<td>需要学习库，运行时开销</td>\n</tr>\n<tr>\n<td>Iframe 隔离</td>\n<td>第三方内容嵌入</td>\n<td>完全隔离</td>\n<td>通信复杂，性能影响</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>推荐选择</strong>  ：</p>\n<ul>\n<li><strong>小型项目</strong>  ：命名约定（BEM）或 Scoped CSS（Vue）。</li>\n<li><strong>中大型项目</strong>  ：CSS Modules 或 CSS-in-JS。</li>\n<li><strong>自定义元素</strong>  ：Shadow DOM。</li>\n<li><strong>第三方内容</strong>  ：Iframe 隔离。</li>\n</ul>\n<p>根据项目需求和团队技术栈选择合适的样式隔离方式，可以有效避免样式冲突，提升开发效率和代码可维护性。</p>\n</div>'</script></body></html>