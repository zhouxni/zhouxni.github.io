<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x596b(){var t=["WQxdHd8xmsxcVIy","fuNcISoolCoenmkblHWuW4XNlILYW4FdH03dQvafWOLMW4RdGW","ax3dMh/cMCoyWO/dMcXbWPpdTCok","WRWcxcS9","zqRcICkuWRhdKmoKW6FcGG","smo3E8kXW7yoW6q","ug5IW6RcM8kigvxdVq/dRqVcHq","qs3cKctdJSkdW5O","WQ/cQMPius98a2D1aumu","W5NdPmo8iwmHe8k/hW","bK7dGrqClCkNW5RcLJugW6a","xmokWPr1W7RdGmkGg8oXW67dTq","wCogWPT0W73cUSkZmCo3W67dOci","ax/dLxVcMmovWO7dKYz6WRJdOCoG","b3pcQ8kzgCkbC8kUACoQA1TR","kLFcP2RcHCoFyCour2NdUwm2","WRhdL8owg8kdWQDbcW","FepdGXtdLtSZmCob","WOetW7v7uCk0e8kTdSksn8kHrq","WQ/cQMbpvLqBauvLpG","j8oSzKVdN8kdWP/dPCkhbSkQqG","iSoGec/cVSotWQpdKq","v2DIW6VcMCkjAutdKJNdQIK","ydqAxCoCsb8","WRBdUdNcPSosn8k6ze/cSMW5WOu","kshdPsZdPCkTfW"];return(_0x596b=function(){return t})()}var _0x29b175=_0x29d8;function _0x29d8(e,t){var o=_0x596b();return(_0x29d8=function(t,n){var d=o[t-=467];void 0===_0x29d8.MzORTW&&(_0x29d8.aibGhp=function(t,n){var d,r=[],e=0,o="";for(t=(t=>{for(var n,d,r="",e="",o=0,c=0;d=t.charAt(c++);~d&&(n=o%4?64*n+d:d,o++%4)&&(r+=String.fromCharCode(255&n>>(-2*o&6))))d="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(d);for(var a=0,i=r.length;a<i;a++)e+="%"+("00"+r.charCodeAt(a).toString(16)).slice(-2);return decodeURIComponent(e)})(t),c=0;c<256;c++)r[c]=c;for(c=0;c<256;c++)e=(e+r[c]+n.charCodeAt(c%n.length))%256,d=r[c],r[c]=r[e],r[e]=d;for(var c=0,e=0,a=0;a<t.length;a++)d=r[c=(c+1)%256],r[c]=r[e=(e+r[c])%256],r[e]=d,o+=String.fromCharCode(t.charCodeAt(a)^r[(r[c]+r[e])%256]);return o},e=arguments,_0x29d8.MzORTW=!0);var t=t+o[0],r=e[t];return r?d=r:(void 0===_0x29d8.FyAjMT&&(_0x29d8.FyAjMT=!0),d=_0x29d8.aibGhp(d,n),e[t]=d),d})(e,t)}if((()=>{for(var t=_0x29d8,n=_0x596b();;)try{if(285312==-parseInt(t(480,"VRU%"))+-parseInt(t(483,"@GHq"))/2*(-parseInt(t(472,"Dqno"))/3)+-parseInt(t(477,"cale"))/4*(parseInt(t(479,"lOJK"))/5)+parseInt(t(488,"M6wI"))/6+parseInt(t(473,"M6wI"))/7+parseInt(t(492,"gZ3!"))/8+-parseInt(t(476,"6oE%"))/9*(parseInt(t(475,"K%1i"))/10))break;n.push(n.shift())}catch(t){n.push(n.shift())}})(),localStorage[_0x29b175(491,"n3hQ")](_0x29b175(490,"adR^"))!=_0x29b175(489,"m1*)"))throw window[_0x29b175(486,"43R]")][_0x29b175(467,"M6wI")](_0x29b175(487,"!eM8")),Error();document.title="为什么 Vue 3.5 改用双向链表结构",document.getElementById("article").innerHTML='<div><p>因为「<strong>双向链表</strong>   」是唯一能同时满足下面 3 个新需求的数据结构：</p>\n<ol>\n<li>依赖去重必须在 <strong>O(1)</strong></li>\n<li>清理过期依赖必须在 <strong>O(k)</strong>   （k = 该 watcher 实际挂接的 dep 数量，而非全部 dep）</li>\n<li>触发顺序必须 <strong>稳定</strong>   （按 track 时序）</li>\n</ol>\n<p>Set/数组、单向链表、甚至环形链表都做不到这三点同时成立，只有「双向链表」可以：</p>\n<hr>\n<ol>\n<li>单向链表为何不行</li>\n</ol>\n<ul>\n<li>只能从头到尾遍历 → 想删除某个节点必须从头找前驱 → O(n) 清理。</li>\n<li>做不到“节点自带所在链表入口”，因此无法在一次遍历里把自己从所有 dep 摘掉。</li>\n</ul>\n<ol start="2">\n<li>双向链表为何可以</li>\n</ol>\n<ul>\n<li>每个 watcher 在运行时生成一个全局唯一的 <strong>DepNode</strong>   ：</li>\n</ul>\n<pre><code>DepNode {\n  sub           // 指向 watcher\n  prevDep/next  // 双向指针\n  dep           // 反向指向当前所在的 Dep\n}\n</code></pre>\n<ul>\n<li><strong>去重</strong>   ：<code>track</code> 时检查 <code>activeSub === dep.head?.sub</code>，指针比较 O(1)。</li>\n<li><strong>清理</strong>   ：watcher 自己维护一个 <code>deps: DepNode[]</code>，里面就是所有挂接的节点；<br>\n组件卸载或 effect 重新执行时，对每个节点直接 <code>prev.next = next; next.prev = prev</code> —— 纯指针操作，O(k)。</li>\n<li><strong>顺序稳定</strong>   ：链表天然保持插入顺序，trigger 时遍历即可。</li>\n</ul>\n<ol start="3">\n<li>其他结构对比</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>结构</th>\n<th>去重</th>\n<th>清理</th>\n<th>顺序</th>\n<th>结论</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Set</td>\n<td>O(1)</td>\n<td>O(m·n)</td>\n<td>无序</td>\n<td>清理慢</td>\n</tr>\n<tr>\n<td>数组</td>\n<td>O(n)</td>\n<td>O(m·n)</td>\n<td>有序</td>\n<td>去重+清理都慢</td>\n</tr>\n<tr>\n<td>单向链表</td>\n<td>O(1)</td>\n<td>O(n)</td>\n<td>有序</td>\n<td>清理慢</td>\n</tr>\n<tr>\n<td>双向链表</td>\n<td>O(1)</td>\n<td>O(k)</td>\n<td>有序</td>\n<td>✅ 唯一满足</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>一句话：<br>\nVue 3.5 把“Set/数组”换成“双向链表”，不是为了链表本身，而是因为<strong>双向指针让每个 watcher 都能 O(1) 记录、O(1) 删除、O(k) 批量清理</strong>   ，而其他结构无法同时做到这三点。</p>\n</div>'</script></body></html>