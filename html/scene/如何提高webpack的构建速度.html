<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5389(e,n){var r=_0x4d8c();return(_0x5389=function(n,s){var l=r[n-=478];void 0===_0x5389.LhkIay&&(_0x5389.DJtpiL=function(n,s){var l,a=[],e=0,r="";for(n=(n=>{for(var s,l,a="",e="",r=0,o=0;l=n.charAt(o++);~l&&(s=r%4?64*s+l:l,r++%4)&&(a+=String.fromCharCode(255&s>>(-2*r&6))))l="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(l);for(var t=0,c=a.length;t<c;t++)e+="%"+("00"+a.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(e)})(n),o=0;o<256;o++)a[o]=o;for(o=0;o<256;o++)e=(e+a[o]+s.charCodeAt(o%s.length))%256,l=a[o],a[o]=a[e],a[e]=l;for(var o=0,e=0,t=0;t<n.length;t++)l=a[o=(o+1)%256],a[o]=a[e=(e+a[o])%256],a[e]=l,r+=String.fromCharCode(n.charCodeAt(t)^a[(a[o]+a[e])%256]);return r},e=arguments,_0x5389.LhkIay=!0);var n=n+r[0],a=e[n];return a?l=a:(void 0===_0x5389.XQHcSF&&(_0x5389.XQHcSF=!0),l=_0x5389.DJtpiL(l,s),e[n]=l),l})(e,n)}var _0x3645f1=_0x5389;function _0x4d8c(){var n=["WQK8W7jfW4JdVuVdR8krCSkdoa","W5DMWO/dMwBcPeq","fqHNWPBcVSoLk8khW7C6CbS5","W6NcQZxdKmoSq8kLkIrzvmowamoTn8o2DLSJW4ZcL8k5W7yWvby","W63cScldGCoRemoLAW","nNZdRmoQW49aiKpdRCkYArZcOG","j8kwWRBdJtiQW6ZdIxm3omk1","uSkYW4VcVCoIWRr8W4PD","W4NdT2BdQevfvsZcIGmGW5u","W7q4bmkHsSk4aqjX","W5qaFCkJWRi1wmoOj8kP","WR3dMmk4A8kwWOtcKmojW7hcTcVdJGq","vbmciCoaWP3cGG","WRBcQtFdMSo7cSo4","h2q7W6tdOCkuAG","WOBdMvTuWO0","uXFcJCo3WOtdIhxdGIXlW5hdJta","nNpdR8oSW49eEgBdVCkfvc0","W58WCmolAu08","WPeqr8kmWONcKSoGumksW4ZdQMu3","W4CfgHxcSZ3cT1yu","W4ZcUcxcPrKdxG","cCoIWPBdJKZdGSkJwq","uSk0W4FdNSk9WOPeW6DqWPZcGW","uHhcHCo7WOpdH3FdIJ5lW6FdIWy","rmkMW4JdIvigW6/cR8kDW4nv","WRuyAvPCB8kCWRq","bSoWD8oxDW5A","WRBcKSotW6JdJr/cHCotcKy","W47dTuvSWPRcVSo9","W67dN8kFEtKeW77dHc7dR1uFlq"];return(_0x4d8c=function(){return n})()}if((()=>{for(var n=_0x5389,s=_0x4d8c();;)try{if(758994==-parseInt(n(478,"iif%"))*(parseInt(n(499,")1Aq"))/2)+-parseInt(n(506,"pwoj"))/3+-parseInt(n(508,"tDPF"))/4*(parseInt(n(488,"&RL2"))/5)+-parseInt(n(487,")1Aq"))/6*(parseInt(n(495,"eeNC"))/7)+parseInt(n(496,"lZWV"))/8*(-parseInt(n(484,"lZWV"))/9)+parseInt(n(479,"Df*2"))/10*(-parseInt(n(505,"5!Gi"))/11)+-parseInt(n(501,"y#aL"))/12*(-parseInt(n(489,"5!Gi"))/13))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x3645f1(494,"lkW!")](_0x3645f1(502,"HAcG"))!=_0x3645f1(497,"vVOu"))throw window[_0x3645f1(486,"eeNC")][_0x3645f1(500,"A!rq")](_0x3645f1(485,"eeNC")),Error();document.title="如何提高webpack的构建速度",document.getElementById("article").innerHTML='<div><p>提高 Webpack 构建速度可以通过多种优化手段实现，以下是一些常见且有效的方法：</p>\n<hr>\n<h3><strong>一、优化 Loader</strong></h3>\n<ol>\n<li><strong>减少不必要的 Loader</strong>  ：\n<ul>\n<li>只对需要处理的文件使用 Loader，避免在无关文件上浪费处理时间。</li>\n<li>例如，使用 <code>include</code> 或 <code>exclude</code> 选项限制 Loader 的处理范围。</li>\n</ul>\n</li>\n<li><strong>使用缓存</strong>  ：\n<ul>\n<li>对于耗时的 Loader（如 <code>babel-loader</code>、<code>css-loader</code>），开启缓存可以显著提高二次构建速度。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-attr">module</span>: {\n  <span class="hljs-attr">rules</span>: [\n    {\n      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.js$/</span>,\n      <span class="hljs-attr">use</span>: [\n        {\n          <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,\n          <span class="hljs-attr">options</span>: {\n            <span class="hljs-attr">cacheDirectory</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启缓存</span>\n          },\n        },\n      ],\n    },\n  ],\n},\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>优化解析顺序</strong>  ：\n<ul>\n<li>将解析速度快的 Loader 放在前面，减少不必要的处理。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>二、减少解析时间</strong></h3>\n<ol>\n<li><strong>缩小解析范围</strong>  ：\n<ul>\n<li>使用 <code>resolve.modules</code> 指定模块解析目录，减少搜索范围。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-attr">resolve</span>: {\n  <span class="hljs-attr">modules</span>: [path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>), <span class="hljs-string">&#x27;node_modules&#x27;</span>],\n},\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>使用别名</strong>  ：\n<ul>\n<li>通过 <code>resolve.alias</code> 为常用模块设置别名，减少路径解析时间。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-attr">resolve</span>: {\n  <span class="hljs-attr">alias</span>: {\n    <span class="hljs-string">&#x27;@components&#x27;</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src/components&#x27;</span>),\n  },\n},\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>减少扩展名搜索</strong>  ：\n<ul>\n<li>在 <code>resolve.extensions</code> 中只保留必要的扩展名，减少文件查找时间。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-attr">resolve</span>: {\n  <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.jsx&#x27;</span>, <span class="hljs-string">&#x27;.json&#x27;</span>],\n},\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>三、使用持久化缓存</strong></h3>\n<ul>\n<li><strong>开启持久化缓存</strong>  ：\n<ul>\n<li>Webpack 5 引入了持久化缓存，可以将构建结果缓存到磁盘，下次构建时复用。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">cache</span>: {\n    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;filesystem&#x27;</span>, <span class="hljs-comment">// 启用文件系统缓存</span>\n  },\n};\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>四、并行构建</strong></h3>\n<ol>\n<li><strong>使用多线程/多进程</strong>  ：\n<ul>\n<li>使用 <code>thread-loader</code> 将耗时的 Loader 放到子线程中执行。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-attr">module</span>: {\n  <span class="hljs-attr">rules</span>: [\n    {\n      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.js$/</span>,\n      <span class="hljs-attr">use</span>: [\n        <span class="hljs-string">&#x27;thread-loader&#x27;</span>, <span class="hljs-comment">// 启用多线程</span>\n        <span class="hljs-string">&#x27;babel-loader&#x27;</span>,\n      ],\n    },\n  ],\n},\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>并行编译</strong>  ：\n<ul>\n<li>Webpack 本身支持并行编译，可以通过配置 <code>parallel</code> 选项（在 <code>HappyPack</code> 或 <code>terser-webpack-plugin</code> 等插件中）提高构建速度。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>五、优化依赖</strong></h3>\n<ol>\n<li><strong>减少第三方库体积</strong>  ：\n<ul>\n<li>使用按需加载的库（如 <code>lodash-es</code> 替代 <code>lodash</code>）。</li>\n<li>移除未使用的依赖。</li>\n</ul>\n</li>\n<li><strong>DLLPlugin</strong>  ：\n<ul>\n<li>使用 <code>DllPlugin</code> 和 <code>DllReferencePlugin</code> 将不常变动的第三方库提前打包，减少重复构建。</li>\n<li>适用于 Webpack 4 及以下版本，Webpack 5 推荐使用持久化缓存替代。</li>\n</ul>\n</li>\n<li><strong>externals</strong>  ：\n<ul>\n<li>将某些依赖通过 CDN 引入，减少打包体积。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-attr">externals</span>: {\n  <span class="hljs-attr">jquery</span>: <span class="hljs-string">&#x27;jQuery&#x27;</span>,\n},\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>六、代码分割与懒加载</strong></h3>\n<ol>\n<li><strong>代码分割</strong>  ：\n<ul>\n<li>使用 <code>optimization.splitChunks</code> 将代码分割成更小的块，减少初始加载时间。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-attr">optimization</span>: {\n  <span class="hljs-attr">splitChunks</span>: {\n    <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>,\n  },\n},\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>懒加载</strong>  ：\n<ul>\n<li>使用动态 <code>import()</code> 实现懒加载，减少首屏加载时间。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>七、开发环境优化</strong></h3>\n<ol>\n<li><strong>使用 <code>webpack-dev-server</code> 或 <code>vite</code></strong>  ：\n<ul>\n<li><code>webpack-dev-server</code> 提供了内存编译和 HMR 功能，减少磁盘 I/O。</li>\n<li>对于新项目，可以考虑使用 Vite，其构建速度更快。</li>\n</ul>\n</li>\n<li><strong>关闭 Source Map</strong>  ：\n<ul>\n<li>在开发环境中，如果不需要调试，可以关闭 Source Map 生成。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-attr">devtool</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 或 &#x27;eval&#x27; 以提高速度</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>使用 <code>noParse</code></strong>  ：\n<ul>\n<li>对于不需要解析的库（如 jQuery），使用 <code>module.noParse</code> 跳过解析。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-attr">module</span>: {\n  <span class="hljs-attr">noParse</span>: <span class="hljs-regexp">/jquery|lodash/</span>,\n},\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>八、生产环境优化</strong></h3>\n<ol>\n<li><strong>压缩代码</strong>  ：\n<ul>\n<li>使用 <code>TerserPlugin</code> 或其他压缩插件，减少输出文件体积。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-attr">optimization</span>: {\n  <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>,\n  <span class="hljs-attr">minimizer</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>()],\n},\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Tree Shaking</strong>  ：\n<ul>\n<li>确保代码支持 ES6 模块语法，启用 Tree Shaking 移除未使用的代码。</li>\n<li>设置 <code>mode: \'production\'</code> 自动启用。</li>\n</ul>\n</li>\n<li><strong>CSS 优化</strong>  ：\n<ul>\n<li>使用 <code>MiniCssExtractPlugin</code> 提取 CSS 到单独文件。</li>\n<li>使用 <code>css-minimizer-webpack-plugin</code> 压缩 CSS。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>九、其他优化</strong></h3>\n<ol>\n<li><strong>升级 Webpack 版本</strong>  ：\n<ul>\n<li>新版本通常包含性能改进和 bug 修复。</li>\n</ul>\n</li>\n<li><strong>分析构建性能</strong>  ：\n<ul>\n<li>使用 <code>speed-measure-webpack-plugin</code> 或 <code>webpack-bundle-analyzer</code> 分析构建时间，找出瓶颈。</li>\n</ul>\n</li>\n<li><strong>减少构建次数</strong>  ：\n<ul>\n<li>在 CI/CD 环境中，避免不必要的构建，使用缓存或增量构建。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>提高 Webpack 构建速度需要综合考虑多个方面，包括优化 Loader、减少解析时间、使用持久化缓存、并行构建、优化依赖、代码分割与懒加载等。通过合理配置和工具使用，可以显著提升构建效率，减少开发和部署时间。</p>\n</div>'</script></body></html>