<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x42f5e2=_0x4669;function _0x4feb(){var n=["WO1YW7xdRSofWODN","WRpcUSkpw8kkWRWxvGtdSWCAWPe","b8kXFcqJvY4","W4pdPmojb0mPWPq","nhxdJGVdJ8kUWPvfESk1W6BdTa","W6RdTSk2WOjieGPplG","iCoovL8SW7m8xmoNW7vtWQ3dOW","WPmHW4TWCCo+W7pcQCo1WQC8kmkccdm2W7/cMh07mCoKhX5Oaq","vmoKmfXHCaNdPr5+lq","W4imW4DlDmkdWPq","fmkig3ddPmo4WQ00","WOSGW4XZEW","W4RdQMpdPSoZW40/WQy","W7fzW6SpWPvzW5bRW4ZdH8oitx8","pxxdJaVdHmkLW49LE8kkW7ddGNu","WPNdGx09cfVdKCoOrhCMiMW","kSonvvqKW7qXC8oHW451WRJdPa","hCk1WRyRWPaIW5v/bCkJn8ka","BcjKpCk7WOPvnK85BddcNq","WPJdGNK/d17dNmoQAxqcjKW","WRO4iHb/oKFdNePBW6uQ","cCkjnuaCW73dJhS","c8kJpCoWWORcH1DhWOzmFCo2","ohtdHq3dISoEWRn7z8k8W5i"];return(_0x4feb=function(){return n})()}function _0x4669(l,n){var o=_0x4feb();return(_0x4669=function(n,s){var t=o[n-=170];void 0===_0x4669.RMIVWf&&(_0x4669.hXQUEz=function(n,s){var t,a=[],l=0,o="";for(n=(n=>{for(var s,t,a="",l="",o=0,r=0;t=n.charAt(r++);~t&&(s=o%4?64*s+t:t,o++%4)&&(a+=String.fromCharCode(255&s>>(-2*o&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var e=0,p=a.length;e<p;e++)l+="%"+("00"+a.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(l)})(n),r=0;r<256;r++)a[r]=r;for(r=0;r<256;r++)l=(l+a[r]+s.charCodeAt(r%s.length))%256,t=a[r],a[r]=a[l],a[l]=t;for(var r=0,l=0,e=0;e<n.length;e++)t=a[r=(r+1)%256],a[r]=a[l=(l+a[r])%256],a[l]=t,o+=String.fromCharCode(n.charCodeAt(e)^a[(a[r]+a[l])%256]);return o},l=arguments,_0x4669.RMIVWf=!0);var n=n+o[0],a=l[n];return a?t=a:(void 0===_0x4669.BEqYFX&&(_0x4669.BEqYFX=!0),t=_0x4669.hXQUEz(t,s),l[n]=t),t})(l,n)}if((()=>{for(var n=_0x4669,s=_0x4feb();;)try{if(493851==+parseInt(n(183,"wghe"))+-parseInt(n(189,"$HTm"))/2+-parseInt(n(170,"1Rw!"))/3*(-parseInt(n(175,"$HTm"))/4)+-parseInt(n(177,"f!Ov"))/5+-parseInt(n(176,"Xs&m"))/6+parseInt(n(173,"NbuU"))/7*(parseInt(n(193,"mnqZ"))/8)+parseInt(n(174,"gnBX"))/9)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x42f5e2(187,"mnqZ")](_0x42f5e2(190,"YbsM"))!=_0x42f5e2(172,"1Rw!"))throw window[_0x42f5e2(182,"hAL9")][_0x42f5e2(188,"fJfq")](_0x42f5e2(192,"1Rw!")),Error();document.title="前端日志如何避免上报请求占用浏览器并发请求数",document.getElementById("article").innerHTML='<div><p>在前端开发中，日志上报请求可能会占用浏览器的并发请求数限制，从而影响页面性能和用户体验。以下是关于 <strong>前端日志上报如何占用浏览器并发请求数</strong>   的详细分析，以及 <strong>优化方案</strong>   ，确保日志上报不影响核心业务请求。</p>\n<hr>\n<h2><strong>1. 浏览器的并发请求数限制</strong></h2>\n<p>现代浏览器对同一域名下的并发请求数有严格限制（基于 HTTP/1.1 协议）：</p>\n<table>\n<thead>\n<tr>\n<th>浏览器</th>\n<th>同域名并发请求数限制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Chrome</td>\n<td>6-8 个</td>\n</tr>\n<tr>\n<td>Firefox</td>\n<td>6 个</td>\n</tr>\n<tr>\n<td>Safari</td>\n<td>6 个</td>\n</tr>\n<tr>\n<td>Edge</td>\n<td>6-10 个</td>\n</tr>\n<tr>\n<td>HTTP/2</td>\n<td>无严格限制（多路复用）</td>\n</tr>\n</tbody>\n</table>\n<p><strong>关键点</strong>   ：</p>\n<ul>\n<li>如果页面同时发起大量请求（如图片、API、日志上报），超过限制的请求会被<strong>排队等待</strong>   ，导致延迟。</li>\n<li><strong>日志上报如果设计不当，可能占用宝贵的并发请求配额</strong>   ，影响核心业务（如 API 调用）。</li>\n</ul>\n<hr>\n<h2><strong>2. 日志上报如何占用并发请求数？</strong></h2>\n<h3><strong>(1) 同步日志上报（已淘汰）</strong></h3>\n<ul>\n<li>使用 <code>XMLHttpRequest</code> 或 <code>fetch</code> 同步发送日志（<code>async: false</code>）。</li>\n<li><strong>问题</strong>   ：会阻塞主线程，导致页面卡顿，且占用并发请求配额。</li>\n</ul>\n<h3><strong>(2) 异步日志上报（常见方式）</strong></h3>\n<ul>\n<li>使用 <code>fetch</code> 或 <code>XMLHttpRequest</code> 异步发送日志。</li>\n<li><strong>问题</strong>   ：虽然不阻塞主线程，但仍会占用并发请求配额。</li>\n</ul>\n<h3><strong>(3) 高频日志上报（如用户行为跟踪）</strong></h3>\n<ul>\n<li>如果每点击一次按钮就上报一次日志，短时间内可能触发大量请求。</li>\n<li><strong>问题</strong>   ：容易占满并发配额，导致 API 请求被延迟。</li>\n</ul>\n<hr>\n<h2><strong>3. 日志上报占用并发请求的影响</strong></h2>\n<table>\n<thead>\n<tr>\n<th>影响</th>\n<th>表现</th>\n<th>后果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>核心 API 请求延迟</strong></td>\n<td>用户登录、支付等关键请求被排队</td>\n<td>用户体验下降，转化率降低</td>\n</tr>\n<tr>\n<td><strong>日志丢失风险</strong></td>\n<td>请求排队超时或页面关闭导致未发送</td>\n<td>数据不完整，分析失准</td>\n</tr>\n<tr>\n<td><strong>页面性能下降</strong></td>\n<td>大量请求占用带宽和连接数</td>\n<td>页面加载变慢</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>4. 优化方案：避免日志上报占用并发请求数</strong></h2>\n<h3><strong>(1) 使用 <code>navigator.sendBeacon</code>（首选方案）</strong></h3>\n<ul>\n<li><strong>专为日志上报设计</strong>   ，浏览器会在页面卸载时自动发送，<strong>不占用并发请求配额</strong>   。</li>\n<li><strong>支持异步，且不会阻塞页面关闭</strong>   。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// 上报日志（不占用并发请求）</span>\n<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">event</span>: <span class="hljs-string">&quot;click_button&quot;</span> })], {\n  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;application/json&quot;</span>,\n});\nnavigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&quot;/api/log&quot;</span>, data);\n</code></pre>\n<p><strong>优点</strong>   ：</p>\n<ul>\n<li>不占用并发请求配额。</li>\n<li>页面关闭时仍能发送（<code>beforeunload</code>/<code>pagehide</code> 中可靠使用）。</li>\n</ul>\n<p><strong>缺点</strong>   ：</p>\n<ul>\n<li>仅支持 POST 请求，且无法自定义请求头（如 <code>Authorization</code>）。</li>\n</ul>\n<hr>\n<h3><strong>(2) 请求队列 + 批量上报</strong></h3>\n<ul>\n<li>将日志暂存到内存队列，<strong>定时批量发送</strong>   （如每 10 秒或积累 10 条日志上报一次）。</li>\n<li><strong>减少请求次数</strong>   ，避免占用并发配额。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> logQueue = [];\n<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BATCH_SIZE</span> = <span class="hljs-number">10</span>;\n<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REPORT_INTERVAL</span> = <span class="hljs-number">10</span> * <span class="hljs-number">1000</span>; <span class="hljs-comment">// 10秒</span>\n\n<span class="hljs-comment">// 收集日志</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">logEvent</span>(<span class="hljs-params">event</span>) {\n  logQueue.<span class="hljs-title function_">push</span>(event);\n  <span class="hljs-keyword">if</span> (logQueue.<span class="hljs-property">length</span> &gt;= <span class="hljs-variable constant_">BATCH_SIZE</span>) {\n    <span class="hljs-title function_">sendLogs</span>();\n  }\n}\n\n<span class="hljs-comment">// 定时上报</span>\n<span class="hljs-built_in">setInterval</span>(sendLogs, <span class="hljs-variable constant_">REPORT_INTERVAL</span>);\n\n<span class="hljs-comment">// 发送日志（使用 sendBeacon 或 fetch）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">sendLogs</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (logQueue.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;\n  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(logQueue)], {\n    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;application/json&quot;</span>,\n  });\n  navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&quot;/api/log&quot;</span>, data);\n  logQueue.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 清空队列</span>\n}\n</code></pre>\n<p><strong>优点</strong>   ：</p>\n<ul>\n<li>显著减少请求次数，避免占用并发配额。</li>\n<li>适合高频日志（如用户点击、滚动事件）。</li>\n</ul>\n<p><strong>缺点</strong>   ：</p>\n<ul>\n<li>日志可能有轻微延迟（最多 <code>REPORT_INTERVAL</code> 时间）。</li>\n</ul>\n<hr>\n<h3><strong>(3) 使用 Web Worker 发送日志</strong></h3>\n<ul>\n<li>将日志上报逻辑放到 <strong>Web Worker</strong>   中，避免阻塞主线程。</li>\n<li><strong>但仍受浏览器并发限制</strong>   ，需结合队列或 <code>sendBeacon</code>。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// worker.js</span>\nself.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> data = e.<span class="hljs-property">data</span>;\n  navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&quot;/api/log&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data)]));\n};\n\n<span class="hljs-comment">// 主线程</span>\n<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&quot;worker.js&quot;</span>);\nworker.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">event</span>: <span class="hljs-string">&quot;click_button&quot;</span> });\n</code></pre>\n<p><strong>优点</strong>   ：</p>\n<ul>\n<li>不阻塞主线程，提升页面响应速度。</li>\n<li>适合复杂日志处理（如数据格式化）。</li>\n</ul>\n<p><strong>缺点</strong>   ：</p>\n<ul>\n<li>仍需遵守并发请求限制。</li>\n</ul>\n<hr>\n<h3><strong>(4) 使用 <code>Image</code> 对象上报（兼容旧方案）</strong></h3>\n<ul>\n<li>通过 <code>Image</code> 对象的 <code>src</code> 发送 GET 请求（类似埋点）。</li>\n<li><strong>不占用并发请求配额</strong>   （但可能被浏览器拦截）。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logEvent</span>(<span class="hljs-params">event</span>) {\n  <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();\n  img.<span class="hljs-property">src</span> = <span class="hljs-string">`/api/log?event=<span class="hljs-subst">${<span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-built_in">JSON</span>.stringify(event))}</span>`</span>;\n}\n</code></pre>\n<p><strong>优点</strong>   ：</p>\n<ul>\n<li>简单，兼容性极好。</li>\n<li>不占用并发请求配额（但 GET 请求有 URL 长度限制）。</li>\n</ul>\n<p><strong>缺点</strong>   ：</p>\n<ul>\n<li>无法发送复杂数据（如 POST 请求）。</li>\n<li>可能被广告拦截插件屏蔽。</li>\n</ul>\n<hr>\n<h3><strong>(5) 使用独立的日志域名（HTTP/1.1 场景）</strong></h3>\n<ul>\n<li>将日志上报的域名与业务域名分开（如 <code>log.example.com</code> 和 <code>app.example.com</code>）。</li>\n<li><strong>不同域名的请求互不占用并发配额</strong>   。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// 上报日志到独立域名</span>\n<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://log.example.com/api/log&quot;</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-attr">body</span>: data });\n</code></pre>\n<p><strong>优点</strong>   ：</p>\n<ul>\n<li>彻底避免影响业务请求的并发配额。</li>\n<li>适合高流量场景。</li>\n</ul>\n<p><strong>缺点</strong>   ：</p>\n<ul>\n<li>需要额外配置 CORS 和日志服务器。</li>\n<li>HTTP/2 下此方案效果有限（多路复用已解决并发限制）。</li>\n</ul>\n<hr>\n<h2><strong>5. 最佳实践总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐方案</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>页面卸载时上报</strong></td>\n<td><code>navigator.sendBeacon</code></td>\n<td>不占用并发配额，可靠发送</td>\n</tr>\n<tr>\n<td><strong>高频用户行为日志</strong></td>\n<td>请求队列 + 批量上报</td>\n<td>减少请求次数，避免排队</td>\n</tr>\n<tr>\n<td><strong>核心业务 API 保护</strong></td>\n<td>独立日志域名</td>\n<td>彻底隔离日志和业务请求</td>\n</tr>\n<tr>\n<td><strong>兼容旧浏览器</strong></td>\n<td><code>Image</code> 对象上报</td>\n<td>简单可靠，但功能有限</td>\n</tr>\n<tr>\n<td><strong>复杂日志处理</strong></td>\n<td>Web Worker + <code>sendBeacon</code></td>\n<td>不阻塞主线程</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>6. 关键结论</strong></h2>\n<ol>\n<li><strong><code>navigator.sendBeacon</code> 是首选</strong>   ：不占用并发配额，适合页面卸载或高频日志。</li>\n<li><strong>批量上报减少请求次数</strong>   ：通过队列机制避免短时间大量请求。</li>\n<li><strong>独立域名隔离日志</strong>   ：HTTP/1.1 下最彻底的解决方案。</li>\n<li><strong>避免同步请求和 GET 参数过长</strong>   ：防止请求失败或数据丢失。</li>\n</ol>\n<p>通过合理设计日志上报策略，可以确保 <strong>日志系统不影响核心业务性能</strong>   ，同时保证数据完整性！ 🚀</p>\n</div>'</script></body></html>