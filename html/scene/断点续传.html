<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2031(p,s){var t=_0x30ba();return(_0x2031=function(s,n){var a=t[s-=290];void 0===_0x2031.fxUwNP&&(_0x2031.CDdReA=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,c=0;a=s.charAt(c++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,o=l.length;e<o;e++)p+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(p)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)p=(p+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[p],l[p]=a;for(var c=0,p=0,e=0;e<s.length;e++)a=l[c=(c+1)%256],l[c]=l[p=(p+l[c])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(e)^l[(l[c]+l[p])%256]);return t},p=arguments,_0x2031.fxUwNP=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x2031.doQRvW&&(_0x2031.doQRvW=!0),a=_0x2031.CDdReA(a,n),p[s]=a),a})(p,s)}var _0x5769c6=_0x2031;function _0x30ba(){var s=["fxOEvSkZWQ4ceZ0","WOqRBc4YW7JdJs7cP8kJxW","cHbbW4NdV8oKwaxcM8kLWQFdMW","WRxdLdldJSol","AmkbWPRcLw7cSmkAWOjG","WRiaW7G5WPZcJmkZWQz6W7WI","zSogpCo2WP3dLCkiq8kr","WOPaqhVcMW3dQW","E8orpSkcbmoecdqq","t8owWOtdNMDnnW","W7e9WOlcOHZcVSkAfmoRW4K2","WRJdUeddOSovBmkAB8kx","WRJcHCklymkEECoLidydrW","rCo3aq/dHmodD8oshW","s8oYb0FdH8oDDCoqcSon","W4rXCafLWR4mWQm/za","WRCfW7S6WP3cSSk3WOzfW68L","iCkJjK8TBWalvctdPe8","uvamWOVcV8oSgv3cJCkDWRNdGHKDWOVcSCkBWO7dUSk/rmo4gYdcOmon","W5/dSCoXvmkpW5agW4u","ArtcPwZdI0ZdGSkR","WRKfW7S7W77cRCkgWRnKW6W","ACouW5pcLCoxW6xcUmouvCksWOq","meldTL7dHuldVSkhWOK","pLXZWRxdPrHGp2Pe","D8ozp8oIkSogpdOyWRK","W6C9kJHfr2tcV8oKW5O","xwldPCkqwCo0W4v1","k8kIle9mkq86BXa","W4r2FqqbWPuGWP0oqsS","WOiQzsnMW6VdGJhcG8ki","x8o2WPVcTCkst8kRW7zldCkC"];return(_0x30ba=function(){return s})()}if((()=>{for(var s=_0x2031,n=_0x30ba();;)try{if(190478==-parseInt(s(310,"6^^T"))+-parseInt(s(312,"(eSW"))/2*(-parseInt(s(302,"z7e["))/3)+parseInt(s(290,"lMQ^"))/4*(-parseInt(s(319,"sC57"))/5)+-parseInt(s(295,"$v9v"))/6*(parseInt(s(292,"ltSz"))/7)+parseInt(s(300,"dExm"))/8*(-parseInt(s(305,"x@Jk"))/9)+-parseInt(s(299,"BNXP"))/10*(parseInt(s(309,"nU24"))/11)+-parseInt(s(320,"F$Es"))/12*(-parseInt(s(301,"@Td6"))/13))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5769c6(315,"$gQE")](_0x5769c6(308,"#K(^"))!=_0x5769c6(311,"j#!J"))throw window[_0x5769c6(296,"BNXP")][_0x5769c6(317,"*a7T")](_0x5769c6(294,"6^^T")),Error();document.title="断点续传",document.getElementById("article").innerHTML='<div><p>下面给出一份「浏览器端」+「Node.js 端」的完整可跑 Demo，演示如何用 <strong>分片 + 断点续传</strong>   把 1 个大文件可靠地传到服务器，并在刷新页面、网络掉线、浏览器崩溃后<strong>从中断处继续</strong>   ，而不是重新传整份。<br>\n核心思路：</p>\n<ol>\n<li>前端把文件按固定大小（如 2 MB）切片；</li>\n<li>每片上传时带「文件唯一标识 + 分片序号 + 分片总数」；</li>\n<li>服务器端把已收到的分片序号记到 Redis/文件/DB；</li>\n<li>前端每次启动上传前先问服务器「已收到哪些片」，只传缺失的片；</li>\n<li>所有片到齐后服务器再合并，返回最终 URL；</li>\n<li>前端可额外用 <code>localStorage</code> 做“本地断点记忆”，实现秒传/秒级恢复。</li>\n</ol>\n<hr>\n<h2>1. 前端代码（浏览器）</h2>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span> /&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;handleUpload()&quot;</span>&gt;</span>开始 / 续传<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CHUNK_SIZE</span> = <span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>; <span class="hljs-comment">// 2 MB</span>\n  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">API</span> = <span class="hljs-string">&quot;http://localhost:3000&quot;</span>; <span class="hljs-comment">// Node 服务地址</span>\n\n  <span class="hljs-keyword">let</span> file,\n    fileId,\n    uploadedList = [];\n\n  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleUpload</span>(<span class="hljs-params"></span>) {\n    file = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;fileInput&quot;</span>).<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];\n    <span class="hljs-keyword">if</span> (!file) <span class="hljs-keyword">return</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;先选文件&quot;</span>);\n\n    <span class="hljs-comment">// 1. 生成文件唯一标识（可用文件名+大小+时间戳的哈希）</span>\n    fileId = <span class="hljs-keyword">await</span> <span class="hljs-title function_">hashFile</span>(file);\n    <span class="hljs-keyword">const</span> chunkTotal = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(file.<span class="hljs-property">size</span> / <span class="hljs-variable constant_">CHUNK_SIZE</span>);\n\n    <span class="hljs-comment">// 2. 询问服务器已收到哪些片</span>\n    <span class="hljs-keyword">const</span> { <span class="hljs-attr">data</span>: list } = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`<span class="hljs-subst">${API}</span>/uploaded/<span class="hljs-subst">${fileId}</span>`</span>);\n    uploadedList = list || [];\n\n    <span class="hljs-comment">// 3. 计算需要重传的片</span>\n    <span class="hljs-keyword">const</span> needChunks = [...<span class="hljs-title class_">Array</span>(chunkTotal).<span class="hljs-title function_">keys</span>()].<span class="hljs-title function_">filter</span>(\n      <span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> !uploadedList.<span class="hljs-title function_">includes</span>(i),\n    );\n\n    <span class="hljs-comment">// 4. 并发上传缺失的分片（可限制并发数）</span>\n    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(needChunks.<span class="hljs-title function_">map</span>(uploadChunk));\n\n    <span class="hljs-comment">// 5. 通知服务器合并</span>\n    <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">`<span class="hljs-subst">${API}</span>/merge`</span>, { fileId, <span class="hljs-attr">fileName</span>: file.<span class="hljs-property">name</span> });\n    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;上传完成！&quot;</span>);\n  }\n\n  <span class="hljs-comment">// 上传单个分片</span>\n  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">uploadChunk</span>(<span class="hljs-params">index</span>) {\n    <span class="hljs-keyword">const</span> start = index * <span class="hljs-variable constant_">CHUNK_SIZE</span>;\n    <span class="hljs-keyword">const</span> end = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(file.<span class="hljs-property">size</span>, start + <span class="hljs-variable constant_">CHUNK_SIZE</span>);\n    <span class="hljs-keyword">const</span> chunk = file.<span class="hljs-title function_">slice</span>(start, end);\n\n    <span class="hljs-keyword">const</span> form = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();\n    form.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;fileId&quot;</span>, fileId);\n    form.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;index&quot;</span>, index);\n    form.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;total&quot;</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(file.<span class="hljs-property">size</span> / <span class="hljs-variable constant_">CHUNK_SIZE</span>));\n    form.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;chunk&quot;</span>, chunk);\n\n    <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">`<span class="hljs-subst">${API}</span>/upload`</span>, form);\n    uploadedList.<span class="hljs-title function_">push</span>(index);\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`片 <span class="hljs-subst">${index}</span> ok`</span>);\n  }\n\n  <span class="hljs-comment">// 简单的前端哈希（可用 SparkMD5 等库）</span>\n  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">hashFile</span>(<span class="hljs-params">f</span>) {\n    <span class="hljs-keyword">const</span> buf = <span class="hljs-keyword">await</span> f.<span class="hljs-title function_">arrayBuffer</span>();\n    <span class="hljs-keyword">const</span> hash = <span class="hljs-keyword">await</span> crypto.<span class="hljs-property">subtle</span>.<span class="hljs-title function_">digest</span>(<span class="hljs-string">&quot;SHA-256&quot;</span>, buf);\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(hash))\n      .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">b</span>) =&gt;</span> b.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>))\n      .<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);\n  }\n\n  <span class="hljs-comment">// 断网或刷新后自动续传：把 fileId 存 localStorage，页面加载时检查</span>\n  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;load&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-keyword">const</span> last = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;lastUpload&quot;</span>);\n    <span class="hljs-keyword">if</span> (last) {\n      <span class="hljs-keyword">const</span> { name, id } = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(last);\n      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">confirm</span>(<span class="hljs-string">`检测到未完成的上传「<span class="hljs-subst">${name}</span>」，是否继续？`</span>)) {\n        fileId = id;\n        <span class="hljs-title function_">handleUpload</span>();\n      }\n    }\n  });\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<hr>\n<h2>2. Node 服务器（Express）</h2>\n<pre><code class="language-bash">npm i express multer cors fs-extra\n</code></pre>\n<pre><code class="language-js"><span class="hljs-comment">// server.js</span>\n<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);\n<span class="hljs-keyword">const</span> multer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;multer&quot;</span>);\n<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);\n<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs-extra&quot;</span>);\n<span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;cors&quot;</span>);\n\n<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();\napp.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>());\n<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">UPLOAD_DIR</span> = path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;upload&quot;</span>);\n\n<span class="hljs-comment">// 记录已收到分片，简单用 JSON 文件，生产用 Redis</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">recordPath</span>(<span class="hljs-params">fileId</span>) {\n  <span class="hljs-keyword">return</span> path.<span class="hljs-title function_">join</span>(<span class="hljs-variable constant_">UPLOAD_DIR</span>, fileId + <span class="hljs-string">&quot;.json&quot;</span>);\n}\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">getUploaded</span>(<span class="hljs-params">fileId</span>) {\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">return</span> fs.<span class="hljs-title function_">readJsonSync</span>(<span class="hljs-title function_">recordPath</span>(fileId));\n  } <span class="hljs-keyword">catch</span> {\n    <span class="hljs-keyword">return</span> [];\n  }\n}\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">addUploaded</span>(<span class="hljs-params">fileId, index</span>) {\n  <span class="hljs-keyword">const</span> list = <span class="hljs-title function_">getUploaded</span>(fileId);\n  <span class="hljs-keyword">if</span> (!list.<span class="hljs-title function_">includes</span>(index)) list.<span class="hljs-title function_">push</span>(index);\n  fs.<span class="hljs-title function_">outputJsonSync</span>(<span class="hljs-title function_">recordPath</span>(fileId), list);\n}\n\n<span class="hljs-comment">// 处理分片</span>\n<span class="hljs-keyword">const</span> storage = multer.<span class="hljs-title function_">diskStorage</span>({\n  <span class="hljs-attr">destination</span>: <span class="hljs-function">(<span class="hljs-params">_, __, cb</span>) =&gt;</span> <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, <span class="hljs-variable constant_">UPLOAD_DIR</span>),\n  <span class="hljs-attr">filename</span>: <span class="hljs-function">(<span class="hljs-params">req, file, cb</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> { fileId, index } = req.<span class="hljs-property">body</span>;\n    <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">`<span class="hljs-subst">${fileId}</span>-<span class="hljs-subst">${index}</span>`</span>);\n  },\n});\n<span class="hljs-keyword">const</span> upload = <span class="hljs-title function_">multer</span>({ storage });\n\napp.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/upload&quot;</span>, upload.<span class="hljs-title function_">single</span>(<span class="hljs-string">&quot;chunk&quot;</span>), <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> { fileId, index } = req.<span class="hljs-property">body</span>;\n  <span class="hljs-title function_">addUploaded</span>(fileId, +index);\n  res.<span class="hljs-title function_">sendStatus</span>(<span class="hljs-number">200</span>);\n});\n\n<span class="hljs-comment">// 返回已上传片列表</span>\napp.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/uploaded/:fileId&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n  res.<span class="hljs-title function_">json</span>(<span class="hljs-title function_">getUploaded</span>(req.<span class="hljs-property">params</span>.<span class="hljs-property">fileId</span>));\n});\n\n<span class="hljs-comment">// 合并</span>\napp.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/merge&quot;</span>, <span class="hljs-title function_">async</span> (req, res) =&gt; {\n  <span class="hljs-keyword">const</span> { fileId, fileName } = req.<span class="hljs-property">body</span>;\n  <span class="hljs-keyword">const</span> list = <span class="hljs-title function_">getUploaded</span>(fileId).<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);\n  <span class="hljs-keyword">const</span> total = list.<span class="hljs-property">length</span>;\n  <span class="hljs-keyword">const</span> target = path.<span class="hljs-title function_">join</span>(<span class="hljs-variable constant_">UPLOAD_DIR</span>, fileName);\n  <span class="hljs-keyword">await</span> fs.<span class="hljs-title function_">ensureFile</span>(target);\n  <span class="hljs-keyword">const</span> write = fs.<span class="hljs-title function_">createWriteStream</span>(target);\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; total; i++) {\n    <span class="hljs-keyword">const</span> chunkPath = path.<span class="hljs-title function_">join</span>(<span class="hljs-variable constant_">UPLOAD_DIR</span>, <span class="hljs-string">`<span class="hljs-subst">${fileId}</span>-<span class="hljs-subst">${i}</span>`</span>);\n    <span class="hljs-keyword">const</span> buf = <span class="hljs-keyword">await</span> fs.<span class="hljs-title function_">readFile</span>(chunkPath);\n    write.<span class="hljs-title function_">write</span>(buf);\n  }\n  write.<span class="hljs-title function_">end</span>();\n  <span class="hljs-comment">// 清理临时片</span>\n  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(list.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> fs.<span class="hljs-title function_">remove</span>(<span class="hljs-string">`<span class="hljs-subst">${UPLOAD_DIR}</span>/<span class="hljs-subst">${fileId}</span>-<span class="hljs-subst">${i}</span>`</span>)));\n  <span class="hljs-keyword">await</span> fs.<span class="hljs-title function_">remove</span>(<span class="hljs-title function_">recordPath</span>(fileId));\n  res.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">url</span>: <span class="hljs-string">`http://localhost:3000/upload/<span class="hljs-subst">${fileName}</span>`</span> });\n});\n\napp.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;/upload&quot;</span>, express.<span class="hljs-title function_">static</span>(<span class="hljs-variable constant_">UPLOAD_DIR</span>));\napp.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Server on 3000&quot;</span>));\n</code></pre>\n<hr>\n<h2>3. 进阶优化</h2>\n<ol>\n<li><strong>并发控制</strong>   ：前端用 <code>p-limit</code> 限制同时上传片数，防止浏览器卡死。</li>\n<li><strong>秒传</strong>   ：文件哈希如果在服务器已存在，直接秒传。</li>\n<li><strong>进度持久化</strong>   ：<code>localStorage</code> 里再存一个 <code>{loaded: 已上传字节, total: 文件大小}</code>，实现刷新页面后继续显示正确进度条。</li>\n<li><strong>断点续下载</strong>   ：把思路反过来（HTTP Range），用 <code>fetch</code>/<code>XHR</code> 的 <code>Range</code> 头即可实现大文件下载断点续传。</li>\n<li><strong>安全/鉴权</strong>   ：给上传接口加 token、做文件类型校验、大小限制、合并前检查 SHA-256 是否匹配。</li>\n</ol>\n<hr>\n<p>这样，一个生产可用的 <strong>JS 断点续传</strong>   就完成了：</p>\n<ul>\n<li>网络中断、刷新页、浏览器崩溃 → 重启后只补缺失分片；</li>\n<li>后端记录已收到片 → 不浪费流量；</li>\n<li>前端可秒传、秒恢复 → 体验流畅。</li>\n</ul>\n</div>'</script></body></html>