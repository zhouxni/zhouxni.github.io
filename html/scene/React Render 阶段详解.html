<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5593fd=_0x4f43;function _0x2e6d(){var n=["emobWQldUJuRcbxdQSkAwq","WRzYz8k5WQuiWPigwci","d8kVWPWndmkqWONcSCotWQ0","WRuZBhuQWRZdMq","WR4/umoyn8kByq","W7WZW4ddTry4WQC","WPiWbwKeAmkdFCoeWORcSG","W7i+lmo/WO8","WPVcNfldK8ooeG/dL3VdQHCP","WQFdNColxCkNEvNdRq1pWRKXWQu","v8o5W4Dzk8ktWPFcKG","jSkQiar0WOyBWQpdKSkhW6vE","hCooW5JcOheljJe","W6BcISkpcmoWiW8","pSoZWPhdPhrLBmoa","p1PKkCoZW5FdVmoMoW","WPK3aZzhqCk5tCo/","jSk1oCkzWOJcSbZcSsXzee5Q","W6TFnmopmmoHFx5bDdFdN3PhreLLDmokfSkqW74aWR1aaG","WRXecheXWQpdIMZcQq","WPdcPCkYWPOGfSkoWRxcIbhcOW","WROyEmkgD8kvcd1XsIK","dCojFmoybdFcLMLi","Bmk4h8kZsYZdJHSSW4WIWOr7","W40cfCoKWRpdUKe3WOpdN8ojdW","bmkreCoioJCKxqS","W7m+WQtdHeNdVwLiWQrTW53dU3S","WPO/bg0domkxv8oeWOJcVCof"];return(_0x2e6d=function(){return n})()}function _0x4f43(o,n){var r=_0x2e6d();return(_0x4f43=function(n,l){var e=r[n-=201];void 0===_0x4f43.izlnnH&&(_0x4f43.BtBgOU=function(n,l){var e,i=[],o=0,r="";for(n=(n=>{for(var l,e,i="",o="",r=0,t=0;e=n.charAt(t++);~e&&(l=r%4?64*l+e:e,r++%4)&&(i+=String.fromCharCode(255&l>>(-2*r&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var s=0,d=i.length;s<d;s++)o+="%"+("00"+i.charCodeAt(s).toString(16)).slice(-2);return decodeURIComponent(o)})(n),t=0;t<256;t++)i[t]=t;for(t=0;t<256;t++)o=(o+i[t]+l.charCodeAt(t%l.length))%256,e=i[t],i[t]=i[o],i[o]=e;for(var t=0,o=0,s=0;s<n.length;s++)e=i[t=(t+1)%256],i[t]=i[o=(o+i[t])%256],i[o]=e,r+=String.fromCharCode(n.charCodeAt(s)^i[(i[t]+i[o])%256]);return r},o=arguments,_0x4f43.izlnnH=!0);var n=n+r[0],i=o[n];return i?e=i:(void 0===_0x4f43.sdruGW&&(_0x4f43.sdruGW=!0),e=_0x4f43.BtBgOU(e,l),o[n]=e),e})(o,n)}if((()=>{for(var n=_0x4f43,l=_0x2e6d();;)try{if(251894==+parseInt(n(210,"D[5W"))*(-parseInt(n(207,"c73J"))/2)+-parseInt(n(203,"D[5W"))/3+parseInt(n(220,"D[5W"))/4*(-parseInt(n(206,"vvMg"))/5)+-parseInt(n(224,"94YC"))/6*(-parseInt(n(216,"g&zk"))/7)+-parseInt(n(221,"k1mX"))/8+parseInt(n(213,"L^on"))/9+parseInt(n(228,"d%*]"))/10*(parseInt(n(223,"c73J"))/11))break;l.push(l.shift())}catch(n){l.push(l.shift())}})(),localStorage[_0x5593fd(208,"OnB9")](_0x5593fd(226,"#8Bh"))!=_0x5593fd(211,"935l"))throw window[_0x5593fd(214,"vvMg")][_0x5593fd(217,"L^on")](_0x5593fd(222,"y6Nt")),Error();document.title="React Render 阶段详解",document.getElementById("article").innerHTML='<div><p>React 的渲染流程分为两个主要阶段：<strong>Render 阶段</strong>  和<strong>Commit 阶段</strong>  。Render 阶段是 React 确定 UI 需要如何更新的关键过程，它负责计算变更但不直接操作 DOM。</p>\n<h2>1. Render 阶段概述</h2>\n<p>Render 阶段（也称为 Reconciliation 阶段）是 React 的核心工作流程，主要完成以下任务：</p>\n<ul>\n<li>调用组件渲染函数生成 React 元素树</li>\n<li>比较新旧虚拟 DOM（Diffing 算法）</li>\n<li>确定需要应用的变更（生成副作用列表）</li>\n</ul>\n<h2>2. Render 阶段的两个子阶段</h2>\n<p>Render 阶段本身又分为两个子阶段：</p>\n<h3>2.1 &quot;递&quot;阶段（Downward Phase）</h3>\n<p><strong>从父组件向子组件递归</strong>  ：</p>\n<ul>\n<li>执行组件的 <code>render</code> 方法（类组件）或函数组件本身</li>\n<li>生成子组件的 React 元素（虚拟 DOM）</li>\n<li>为每个组件创建/复用 Fiber 节点</li>\n</ul>\n<p>关键特点：</p>\n<ul>\n<li>深度优先遍历组件树</li>\n<li>纯计算过程，不产生副作用</li>\n<li>可中断（在并发模式下）</li>\n</ul>\n<h3>2.2 &quot;归&quot;阶段（Upward Phase）</h3>\n<p><strong>从子组件向父组件回溯</strong>  ：</p>\n<ul>\n<li>执行 Diff 算法比较新旧虚拟 DOM</li>\n<li>收集副作用（Effect List）</li>\n<li>标记需要更新的节点</li>\n</ul>\n<p>关键特点：</p>\n<ul>\n<li>完成协调（Reconciliation）过程</li>\n<li>确定哪些节点需要插入/更新/删除</li>\n<li>准备副作用列表供 Commit 阶段使用</li>\n</ul>\n<h2>3. Fiber 架构与 Render 阶段</h2>\n<p>React Fiber 架构使 Render 阶段具有以下特性：</p>\n<h3>3.1 增量渲染</h3>\n<ul>\n<li>将渲染工作分割成小块</li>\n<li>通过 <code>requestIdleCallback</code> 在浏览器空闲时执行</li>\n<li>允许高优先级更新中断低优先级渲染</li>\n</ul>\n<h3>3.2 双缓冲技术</h3>\n<ul>\n<li>当前树（Current Tree）：当前显示的 UI 状态</li>\n<li>工作树（WorkInProgress Tree）：正在构建的新状态</li>\n<li>两棵树交替使用，减少内存分配</li>\n</ul>\n<h2>4. 详细工作流程</h2>\n<ol>\n<li><strong>开始渲染</strong>  ：\n<ul>\n<li>从根 Fiber 节点开始</li>\n<li>创建 WorkInProgress 树</li>\n</ul>\n</li>\n<li><strong>递阶段工作</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">beginWork</span>(<span class="hljs-params">current, workInProgress</span>) {\n  <span class="hljs-comment">// 调用组件渲染函数</span>\n  <span class="hljs-comment">// 生成子 Fiber 节点</span>\n}\n</code></pre>\n</li>\n<li><strong>完成单元工作</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">completeWork</span>(<span class="hljs-params">current, workInProgress</span>) {\n  <span class="hljs-comment">// 处理 DOM 节点</span>\n  <span class="hljs-comment">// 收集副作用</span>\n}\n</code></pre>\n</li>\n<li><strong>副作用收集</strong>  ：\n<ul>\n<li>标记需要插入的节点（Placement）</li>\n<li>标记需要更新的节点（Update）</li>\n<li>标记需要删除的节点（Deletion）</li>\n</ul>\n</li>\n</ol>\n<h2>5. 并发模式下的 Render 阶段</h2>\n<p>在并发模式下，Render 阶段具有额外特性：</p>\n<ul>\n<li><strong>时间切片</strong>  ：将渲染工作分成5ms左右的小块</li>\n<li><strong>优先级调度</strong>  ：高优先级更新可以打断低优先级渲染</li>\n<li><strong>选择性水合</strong>  ：渐进式加载和渲染组件</li>\n</ul>\n<h2>6. 性能优化相关</h2>\n<p>React 在 Render 阶段采用多种优化策略：</p>\n<ol>\n<li><strong>Diffing 算法</strong>  ：\n<ul>\n<li>同级比较</li>\n<li>Key 值优化</li>\n<li>组件类型比较</li>\n</ul>\n</li>\n<li><strong>跳过不必要的渲染</strong>  ：\n<ul>\n<li><code>shouldComponentUpdate</code></li>\n<li><code>React.memo</code></li>\n<li><code>useMemo</code>/<code>useCallback</code></li>\n</ul>\n</li>\n<li><strong>批量更新</strong>  ：\n<ul>\n<li>自动批处理状态更新</li>\n<li>减少不必要的渲染次数</li>\n</ul>\n</li>\n</ol>\n<h2>7. 生命周期与 Render 阶段</h2>\n<p>Render 阶段涉及的生命周期方法：</p>\n<ul>\n<li><strong>类组件</strong>  ：\n<ul>\n<li><code>shouldComponentUpdate</code>（递阶段前）</li>\n<li><code>render</code>（递阶段）</li>\n<li><code>getDerivedStateFromProps</code>（递阶段前）</li>\n</ul>\n</li>\n<li><strong>函数组件</strong>  ：\n<ul>\n<li>函数体执行（递阶段）</li>\n<li>Hooks 逻辑执行（递阶段）</li>\n</ul>\n</li>\n</ul>\n<h2>8. 总结</h2>\n<p>React 的 Render 阶段是一个精心设计的协调过程，它：</p>\n<ol>\n<li>通过递归两阶段处理组件树</li>\n<li>使用 Fiber 架构实现增量渲染</li>\n<li>在并发模式下支持可中断渲染</li>\n<li>高效计算变更而不直接操作 DOM</li>\n</ol>\n<p>理解 Render 阶段的工作原理对于优化 React 应用性能和调试复杂问题至关重要。</p>\n</div>'</script></body></html>