<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x383936=_0x3bf5;function _0x3bf5(t,s){var c=_0x1912();return(_0x3bf5=function(s,n){var l=c[s-=232];void 0===_0x3bf5.hwbXWG&&(_0x3bf5.oMEFWo=function(s,n){var l,a=[],t=0,c="";for(s=(s=>{for(var n,l,a="",t="",c=0,e=0;l=s.charAt(e++);~l&&(n=c%4?64*n+l:l,c++%4)&&(a+=String.fromCharCode(255&n>>(-2*c&6))))l="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(l);for(var p=0,o=a.length;p<o;p++)t+="%"+("00"+a.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)a[e]=e;for(e=0;e<256;e++)t=(t+a[e]+n.charCodeAt(e%n.length))%256,l=a[e],a[e]=a[t],a[t]=l;for(var e=0,t=0,p=0;p<s.length;p++)l=a[e=(e+1)%256],a[e]=a[t=(t+a[e])%256],a[t]=l,c+=String.fromCharCode(s.charCodeAt(p)^a[(a[e]+a[t])%256]);return c},t=arguments,_0x3bf5.hwbXWG=!0);var s=s+c[0],a=t[s];return a?l=a:(void 0===_0x3bf5.zYudSh&&(_0x3bf5.zYudSh=!0),l=_0x3bf5.oMEFWo(l,n),t[s]=l),l})(t,s)}function _0x1912(){var s=["W6bCWOqAW4lcTh/dNHq","pCkmW5xcMSoZW7NcOetdRaO","W4zDpaNdK2pcICoyWPqh","W6CymSoZACk+eCoVxKJdOSk5","WPrdW4ZdHYpcTZFcK8oWWQLQW4VdPSomWQ/cPbFcPNOnWQfGW6Tip8oC","o8oxW7xcRSohWPrbW53cImkklCkQta","uur6vSoyWOhdPSoADW","jG/dMbtdSmkCpHa","mmonuuO9W5rYW4WDW5SAzrq","WO4VWRLQWOn6pSkYtKKGWP8u","W4hdMmk4W6yOW5JcHhmoW4vUgq","W4nCmaVcMfxcUmo3WR0TrG","BmkQxhZdTc7dKa","AvKjWRBcPq","xtnvxav3W7S","W40hW43dMWFdUNZdMG","W6LhlLNcLCoShq","W6uAmCo2Bmk4nCo/EMtdKSke","gmopW77cIdCIfqhcNCou","kmkgA0ddGWZdTW","ySk/sCkXWOikWQddUM9ZWOiM","E1ddJHNdK8kcnrG","W6bCW5zOW4ldQ2y3WQS","WPJdSSkAWRxdGmo8EtBcNmo0","CN5cW47cPs0QvCoaE8kJ","WOxcISk+BhNdTSo9uIJdQuW","WQeVhSobgmoKW4VcU8obW7fhCWq","l8o4gstcPaJdG8otWPFcVCk3"];return(_0x1912=function(){return s})()}if((()=>{for(var s=_0x3bf5,n=_0x1912();;)try{if(234628==+parseInt(s(253,"0m[)"))+-parseInt(s(247,"!Pr#"))/2+-parseInt(s(239,"0m[)"))/3+-parseInt(s(245,"H$gg"))/4*(parseInt(s(240,"ii!O"))/5)+parseInt(s(238,"AiZW"))/6*(parseInt(s(258,"2vXO"))/7)+parseInt(s(250,"@jxR"))/8*(-parseInt(s(233,"%niy"))/9)+-parseInt(s(237,"8O7W"))/10*(-parseInt(s(259,"M)ZH"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x383936(236,")sh6")](_0x383936(256,"0wh^"))!=_0x383936(235,"EyDJ"))throw window[_0x383936(243,"^9ZT")][_0x383936(234,"fQ0]")](_0x383936(254,"8O7W")),Error();document.title="检测网页的空闲状态",document.getElementById("article").innerHTML='<div><p>检测网页的空闲状态（即用户未与页面进行交互的状态）对于优化用户体验、执行后台任务或节省资源非常有用。以下是几种常见的方法来检测网页的空闲状态：</p>\n<hr>\n<h3><strong>1. 使用 <code>document.hidden</code> 和 <code>visibilitychange</code> 事件</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：\n<ul>\n<li><code>document.hidden</code> 属性表示页面是否处于隐藏状态（例如，用户切换到其他标签页）。</li>\n<li><code>visibilitychange</code> 事件在页面可见性发生变化时触发。</li>\n</ul>\n</li>\n<li><strong>实现步骤</strong>  ：\n<ol>\n<li>监听 <code>visibilitychange</code> 事件。</li>\n<li>检查 <code>document.hidden</code> 属性，判断页面是否隐藏。</li>\n</ol>\n</li>\n<li><strong>示例代码</strong>  ：<pre><code class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;visibilitychange&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">hidden</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面处于空闲状态（隐藏）&#x27;</span>);\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面处于活动状态（可见）&#x27;</span>);\n  }\n});\n</code></pre>\n</li>\n<li><strong>优点</strong>  ：\n<ul>\n<li>简单易用，适用于检测页面是否被用户切换到后台。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>只能检测页面是否隐藏，无法检测用户是否在页面上进行交互。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>2. 监听用户交互事件</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：\n<ul>\n<li>监听用户的交互事件（如鼠标移动、键盘输入、点击等），并记录最后一次交互的时间。</li>\n<li>如果超过一定时间没有交互，则认为页面处于空闲状态。</li>\n</ul>\n</li>\n<li><strong>实现步骤</strong>  ：\n<ol>\n<li>定义一个变量，记录最后一次交互的时间。</li>\n<li>监听用户的交互事件，更新最后一次交互的时间。</li>\n<li>使用 <code>setInterval</code> 定期检查当前时间与最后一次交互时间的差值，判断是否超过空闲阈值。</li>\n</ol>\n</li>\n<li><strong>示例代码</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">let</span> lastInteractionTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();\n<span class="hljs-keyword">const</span> idleThreshold = <span class="hljs-number">5000</span>; <span class="hljs-comment">// 空闲阈值，单位为毫秒</span>\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">resetTimer</span>(<span class="hljs-params"></span>) {\n  lastInteractionTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">checkIdle</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> currentTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();\n  <span class="hljs-keyword">if</span> (currentTime - lastInteractionTime &gt; idleThreshold) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面处于空闲状态&#x27;</span>);\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面处于活动状态&#x27;</span>);\n  }\n}\n\n<span class="hljs-comment">// 监听用户交互事件</span>\n[<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;scroll&#x27;</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">eventType</span> =&gt;</span> {\n  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(eventType, resetTimer);\n});\n\n<span class="hljs-comment">// 定期检查空闲状态</span>\n<span class="hljs-built_in">setInterval</span>(checkIdle, <span class="hljs-number">1000</span>); <span class="hljs-comment">// 每秒检查一次</span>\n</code></pre>\n</li>\n<li><strong>优点</strong>  ：\n<ul>\n<li>可以精确检测用户的交互行为，适用于需要实时响应的应用。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>需要监听多个事件，可能会增加一定的性能开销。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>3. 使用 <code>requestIdleCallback</code></strong></h3>\n<ul>\n<li><strong>原理</strong>  ：\n<ul>\n<li><code>requestIdleCallback</code> 允许在浏览器空闲时执行回调函数，适用于执行低优先级的后台任务。</li>\n<li>虽然不直接用于检测空闲状态，但可以结合其他方法，在空闲时执行特定任务。</li>\n</ul>\n</li>\n<li><strong>实现步骤</strong>  ：\n<ol>\n<li>使用 <code>requestIdleCallback</code> 注册一个空闲时执行的回调函数。</li>\n<li>在回调函数中执行后台任务或检查空闲状态。</li>\n</ol>\n</li>\n<li><strong>示例代码</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">idleCallback</span>(<span class="hljs-params">deadline</span>) {\n  <span class="hljs-keyword">while</span> (deadline.<span class="hljs-title function_">timeRemaining</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; tasks.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {\n    <span class="hljs-comment">// 执行后台任务</span>\n    <span class="hljs-keyword">const</span> task = tasks.<span class="hljs-title function_">shift</span>();\n    <span class="hljs-title function_">task</span>();\n  }\n  <span class="hljs-keyword">if</span> (tasks.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {\n    <span class="hljs-title function_">requestIdleCallback</span>(idleCallback);\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;所有后台任务已完成，页面可能处于空闲状态&#x27;</span>);\n  }\n}\n\n<span class="hljs-keyword">const</span> tasks = [\n  <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行任务 1&#x27;</span>),\n  <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行任务 2&#x27;</span>),\n  <span class="hljs-comment">// 添加更多任务</span>\n];\n\n<span class="hljs-comment">// 监听用户交互事件，重置任务队列</span>\n[<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;scroll&#x27;</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">eventType</span> =&gt;</span> {\n  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(eventType, <span class="hljs-function">() =&gt;</span> {\n    tasks.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;新任务：用户交互后添加&#x27;</span>));\n    <span class="hljs-keyword">if</span> (tasks.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) {\n      <span class="hljs-title function_">requestIdleCallback</span>(idleCallback);\n    }\n  });\n});\n\n<span class="hljs-comment">// 初始请求空闲回调</span>\n<span class="hljs-title function_">requestIdleCallback</span>(idleCallback);\n</code></pre>\n</li>\n<li><strong>优点</strong>  ：\n<ul>\n<li>适用于执行低优先级的后台任务，不会阻塞主线程。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>不直接用于检测空闲状态，需要结合其他方法。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>4. 使用第三方库</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：\n<ul>\n<li>一些第三方库封装了空闲检测的功能，提供了更简洁的 API 和更好的兼容性。</li>\n</ul>\n</li>\n<li><strong>示例库</strong>  ：\n<ul>\n<li><strong>Idle.js</strong>  ：一个轻量级的库，用于检测用户的空闲状态。</li>\n</ul>\n</li>\n<li><strong>示例代码（使用 Idle.js）</strong>  ：<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/idle.js/1.2.0/idle.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-keyword">const</span> idle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Idle</span>({\n    <span class="hljs-attr">onIdle</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面处于空闲状态&#x27;</span>);\n    },\n    <span class="hljs-attr">onActive</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面处于活动状态&#x27;</span>);\n    },\n    <span class="hljs-attr">idle</span>: <span class="hljs-number">5000</span> <span class="hljs-comment">// 空闲阈值，单位为毫秒</span>\n  });\n\n  idle.<span class="hljs-title function_">start</span>();\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n</li>\n<li><strong>优点</strong>  ：\n<ul>\n<li>简单易用，封装了复杂的逻辑。</li>\n<li>提供了丰富的配置选项和回调。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>需要引入额外的库，增加了项目的依赖。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>推荐方案</strong></h3>\n<ul>\n<li><strong>对于简单的空闲检测</strong>  ：\n<ul>\n<li><strong>推荐使用 <code>document.hidden</code> 和 <code>visibilitychange</code> 事件</strong>  ：适用于检测页面是否被切换到后台。</li>\n</ul>\n</li>\n<li><strong>对于需要精确检测用户交互的空闲状态</strong>  ：\n<ul>\n<li><strong>推荐使用监听用户交互事件的方法</strong>  ：可以实时响应用户的交互行为。</li>\n</ul>\n</li>\n<li><strong>对于需要在空闲时执行后台任务</strong>  ：\n<ul>\n<li><strong>推荐使用 <code>requestIdleCallback</code> 或第三方库</strong>  ：可以高效地利用浏览器的空闲时间。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>注意事项</strong></h3>\n<ul>\n<li><strong>性能考虑</strong>  ：监听多个用户交互事件可能会增加性能开销，应合理选择需要监听的事件。</li>\n<li><strong>兼容性</strong>  ：<code>requestIdleCallback</code> 在某些旧版浏览器中可能不被支持，需要使用 polyfill 或其他替代方案。</li>\n<li><strong>用户体验</strong>  ：在空闲时执行的任务不应影响用户的正常操作，避免造成卡顿或延迟。</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>检测网页的空闲状态有多种方法，选择哪种方法取决于具体的需求和场景。通过合理选择和组合这些方法，可以有效地检测网页的空闲状态，优化用户体验，执行后台任务或节省资源。</p>\n</div>'</script></body></html>