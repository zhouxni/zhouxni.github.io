<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4da7b0=_0x440a;function _0x440a(t,s){var p=_0x365d();return(_0x440a=function(s,a){var n=p[s-=128];void 0===_0x440a.gOnndT&&(_0x440a.jsaIGv=function(s,a){var n,l=[],t=0,p="";for(s=(s=>{for(var a,n,l="",t="",p=0,c=0;n=s.charAt(c++);~n&&(a=p%4?64*a+n:n,p++%4)&&(l+=String.fromCharCode(255&a>>(-2*p&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var e=0,o=l.length;e<o;e++)t+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)t=(t+l[c]+a.charCodeAt(c%a.length))%256,n=l[c],l[c]=l[t],l[t]=n;for(var c=0,t=0,e=0;e<s.length;e++)n=l[c=(c+1)%256],l[c]=l[t=(t+l[c])%256],l[t]=n,p+=String.fromCharCode(s.charCodeAt(e)^l[(l[c]+l[t])%256]);return p},t=arguments,_0x440a.gOnndT=!0);var s=s+p[0],l=t[s];return l?n=l:(void 0===_0x440a.IhMFRK&&(_0x440a.IhMFRK=!0),n=_0x440a.jsaIGv(n,a),t[s]=n),n})(t,s)}function _0x365d(){var s=["W5tdV8o/CmotrmoXWRCjlYJcV1O","W4GBW60Zd8otFapdUSkiWRHVW5hdOq","peihWQ7cG3XUW6GosvuDW7q","CCkOWPHCxYddIG","rHXKhCoomYK","WOXmWP3dVhhcOCkHh8k2W5GUDhO","D8orW68MaJJdPSk+b8o1WQG","WORdOhz4FLf3W5iqW6ShBmoBW7ebW43dIqvRAmoru3VcHWmy","hCohcZpdLtJcPCkww8ktWO3cHfS","WPhdICk2yxxcGmkHWQOLpqFcPmoR","t3lcLmoaW6lcJ8kPeSoGW4VcHwVdMq","WP5OW4r/W6FcSfVcUX/dLSkjWPiI","W6/dNCkNWONcSgzn","smkXW7KdWOP4FmoDySoiw8kzWPW","WP1kWQ1ptCkeja","FCo6aeZdVXZcT8kQvW","WQG2WQxcSCkZ","umoxW486r8o5BmkYyCoCtCkAWPu","dSkTvXZcUL3dICo5sSoTumoRBbG","WRhdUCkfWQhcOezJiW","WPBdLJldUuRcIM/dK8ovW5ao","WRZcRsBdOcytW4DthaJcT8olWOC"];return(_0x365d=function(){return s})()}if((()=>{for(var s=_0x440a,a=_0x365d();;)try{if(873192==-parseInt(s(132,"s]jW"))*(-parseInt(s(148,"&@Ih"))/2)+-parseInt(s(143,"thNJ"))/3+-parseInt(s(144,"*YpJ"))/4+parseInt(s(140,"LSBE"))/5+parseInt(s(133,"Xab["))/6+parseInt(s(128,"*Se@"))/7+-parseInt(s(141,"qvBr"))/8)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x4da7b0(137,"oneN")](_0x4da7b0(138,"qvBr"))!=_0x4da7b0(139,"N0Er"))throw window[_0x4da7b0(142,"Q*%(")][_0x4da7b0(149,"T1ri")](_0x4da7b0(130,"ABQj")),Error();document.title="Vue.config.async 配置",document.getElementById("article").innerHTML='<div><p>在Vue 2里，<code>Vue.config.async</code> 配置项默认值就是 <code>true</code> ，它控制着Vue的<strong>异步更新队列</strong>   特性 ，以下是关于它的详细介绍：</p>\n<h3>异步更新队列机制</h3>\n<p>当Vue检测到响应式数据发生变化时，并不会立即去更新DOM。而是将DOM更新操作缓冲到一个队列中，等到当前事件循环结束之后，在下一个 <code>nextTick</code> 时，统一执行队列中的更新任务。这就是Vue的异步更新队列机制， <code>Vue.config.async</code> 为 <code>true</code> 时开启这个机制，主要有以下好处：</p>\n<ul>\n<li><strong>提高性能</strong>   ：避免频繁操作DOM。例如在一个函数中多次修改了不同的响应式数据，如果每一次修改都立即更新DOM，会产生大量的重排与重绘操作。而通过异步更新队列，Vue可以把这些更新合并，只进行一次DOM更新，大大提升性能。</li>\n<li><strong>保证数据一致性</strong>   ：可以确保在数据变化之后，DOM更新之前，所有依赖该数据的计算属性和 <code>watch</code> 回调都能获取到最新的数据状态，避免因DOM更新顺序不一致导致的显示异常。</li>\n</ul>\n<h3>示例代码说明</h3>\n<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue Async Update<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n\n  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;updateMessage&quot;</span>&gt;</span>Update Message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\n      <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({\n        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,\n        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {\n          <span class="hljs-keyword">return</span> {\n            <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello&quot;</span>,\n          };\n        },\n        <span class="hljs-attr">methods</span>: {\n          <span class="hljs-title function_">updateMessage</span>(<span class="hljs-params"></span>) {\n            <span class="hljs-comment">// 多次修改数据</span>\n            <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-string">&quot;World&quot;</span>;\n            <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-string">&quot;Vue&quot;</span>;\n            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据已修改，此时DOM未更新&quot;</span>);\n            <span class="hljs-comment">// 可以使用this.$nextTick在DOM更新后执行回调</span>\n            <span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> {\n              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;DOM已更新&quot;</span>);\n            });\n          },\n        },\n      });\n    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n</code></pre>\n<p>在上述代码中，点击按钮后 <code>message</code> 数据被修改了两次 ，由于Vue的异步更新队列机制，这两次修改只会触发一次DOM更新。并且在修改数据后直接打印信息时，DOM还没有更新，而使用 <code>this.$nextTick</code> 可以确保在DOM更新完成后执行相应的回调函数。</p>\n<h3>如果设置 <code>Vue.config.async: false</code></h3>\n<p>当设置 <code>Vue.config.async = false</code> 时，会关闭Vue的异步更新队列机制。这意味着只要响应式数据发生变化，Vue就会立即更新DOM，这可能会带来一些问题：</p>\n<ul>\n<li><strong>性能下降</strong>   ：频繁触发DOM更新，可能导致大量的重排和重绘操作，降低应用的性能。</li>\n<li><strong>数据一致性问题</strong>   ：可能会出现计算属性、<code>watch</code> 回调等在DOM更新过程中获取到不一致的数据状态，导致逻辑错误。</li>\n</ul>\n<p>所以，在正常开发中，建议保持 <code>Vue.config.async</code> 为默认的 <code>true</code> 状态，充分利用Vue的异步更新队列机制带来的性能优化和数据一致性保障。</p>\n</div>'</script></body></html>