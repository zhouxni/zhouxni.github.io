<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x16b0b4=_0x590f;function _0x590f(p,s){var t=_0x65ba();return(_0x590f=function(s,n){var a=t[s-=209];void 0===_0x590f.LMSQXX&&(_0x590f.csDfFp=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,c=0;a=s.charAt(c++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,r=l.length;e<r;e++)p+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(p)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)p=(p+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[p],l[p]=a;for(var c=0,p=0,e=0;e<s.length;e++)a=l[c=(c+1)%256],l[c]=l[p=(p+l[c])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(e)^l[(l[c]+l[p])%256]);return t},p=arguments,_0x590f.LMSQXX=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x590f.GZGCtp&&(_0x590f.GZGCtp=!0),a=_0x590f.csDfFp(a,n),p[s]=a),a})(p,s)}if((()=>{for(var s=_0x590f,n=_0x65ba();;)try{if(520831==+parseInt(s(232,"rmXU"))+parseInt(s(212,"VP^e"))/2+parseInt(s(213,"&rY$"))/3+-parseInt(s(211,"cg^!"))/4+-parseInt(s(219,"4ccq"))/5*(-parseInt(s(217,"pzb!"))/6)+-parseInt(s(227,"KhFy"))/7*(parseInt(s(214,"a3Uu"))/8)+-parseInt(s(231,"J^(a"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x16b0b4(224,"JvMv")](_0x16b0b4(209,"ue$p"))!=_0x16b0b4(210,"av05"))throw window[_0x16b0b4(216,"Gn7A")][_0x16b0b4(228,"gyhU")](_0x16b0b4(229,"4ccq")),new Error;function _0x65ba(){var s=["nSkvvePHoSknWO1WqdmO","zSojedyLzSkl","WRmZrCodWQpcONFdUmo5vuVdRe4","xCkJwvfAWQdcGfi","WRVcMW3cHL46W6BcQ8oIWQ11Ca","fSoyqcRdPXnT","etbzBSkgzHWoBCk5nSkMECkjW5myehxdVMBcQHBdKCohqSoI","W7ldMLBcTZ5wW5hdSa","u0u/W71BfNxdL0eYW6/dLCkIW48","vCkbfSolixbiFCk8dv/dOq","W4/cVmkFlSkZuLiLeq","BCoqFM/cNa","WOpcU8kqW6pdKxhdJmokW5OLyG3cJa","WPfvhNBcGSkeW5vaW7npoIpdPa","WQZdRbZdUCkfWRCpk8kwqSoZW7xdQW","oCkShJTEW6ldRHi","rbjzkSkMW7nXW5H/W5lcINek","dmk5CrvocgJcGG","W5ldKwmWWR5uW67dMG","W7pcNgxdKSkSerH3W67dNSozqcBdHq","t3uvjSoaev13xSkgma","W7BdMZZdLvuJW6NdG8k8W4tcS8od","W5lcKXVdTCoBW6FcPMHEWQP8urO","WR/cNqBcJLjgW5lcImoCWRbq"];return(_0x65ba=function(){return s})()}document.title="React Server Components",document.getElementById("article").innerHTML='<div><p>React Server Components（RSC）是 React 18 引入的一项重大特性，它允许组件在服务器端渲染并直接发送 HTML 到客户端，无需打包和传输 JavaScript 代码。这一特性为 Next.js App Router 提供了核心支持，并带来以下显著优势：</p>\n<h3><strong>一、性能提升</strong></h3>\n<h4>1. <strong>减少客户端 JavaScript 体积</strong></h4>\n<ul>\n<li><strong>传统客户端组件</strong>   ：整个组件逻辑（包括状态管理、生命周期等）都需要打包并发送到客户端。</li>\n<li><strong>Server Components</strong>   ：组件在服务器执行，仅将渲染结果（HTML + 必要数据）发送到客户端，大幅减少客户端 JS 体积。</li>\n</ul>\n<p><strong>示例对比</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 传统客户端组件（需打包所有逻辑）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductList</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [products, setProducts] = <span class="hljs-title function_">useState</span>([]);\n\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/products&quot;</span>)\n      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>())\n      .<span class="hljs-title function_">then</span>(setProducts);\n  }, []);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      {products.map((p) =&gt; (\n        <span class="hljs-tag">&lt;<span class="hljs-name">Product</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{p.id}</span> {<span class="hljs-attr">...p</span>} /&gt;</span>\n      ))}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-comment">// Server Component（无需客户端 JS）</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductList</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> products = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/products&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>());\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      {products.map((p) =&gt; (\n        <span class="hljs-tag">&lt;<span class="hljs-name">Product</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{p.id}</span> {<span class="hljs-attr">...p</span>} /&gt;</span>\n      ))}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h4>2. <strong>更快的首屏加载（FCP/LCP）</strong></h4>\n<ul>\n<li>Server Components 可以在服务器预先渲染完整的 HTML，客户端只需直接显示，无需等待 JS 加载和执行。</li>\n<li>配合 <strong>流式渲染（Streaming）</strong>   ，可以先发送关键内容，非关键部分稍后加载：<pre><code class="language-javascript"><span class="hljs-comment">// 流式渲染示例</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Spinner</span> /&gt;</span>}&gt;\n      <span class="hljs-tag">&lt;<span class="hljs-name">CriticalContent</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">MoreSpinner</span> /&gt;</span>}&gt;\n        <span class="hljs-tag">&lt;<span class="hljs-name">NonCriticalContent</span> /&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">React.Suspense</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">React.Suspense</span>&gt;</span></span>\n  );\n}\n</code></pre>\n</li>\n</ul>\n<h3><strong>二、简化数据获取</strong></h3>\n<h4>1. <strong>直接在组件中获取数据</strong></h4>\n<ul>\n<li>无需 <code>useEffect</code> 或专门的数据获取库（如 React Query）：<pre><code class="language-javascript"><span class="hljs-comment">// Server Component 直接获取数据</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params">{ id }</span>) {\n  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/users/<span class="hljs-subst">${id}</span>`</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>());\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>User: {user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ul>\n<h4>2. <strong>避免客户端数据获取瀑布流</strong></h4>\n<ul>\n<li>\n<p>传统客户端渲染中，组件可能需要按顺序获取多个依赖数据，导致瀑布流延迟。</p>\n</li>\n<li>\n<p>Server Components 可以并行获取所有依赖数据：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Dashboard</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [user, posts, stats] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([\n    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/user&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>()),\n    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/posts&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>()),\n    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/stats&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>()),\n  ]);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">UserInfo</span> <span class="hljs-attr">user</span>=<span class="hljs-string">{user}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">PostList</span> <span class="hljs-attr">posts</span>=<span class="hljs-string">{posts}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">StatsDisplay</span> <span class="hljs-attr">stats</span>=<span class="hljs-string">{stats}</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n</li>\n</ul>\n<h3><strong>三、更好的安全性</strong></h3>\n<h4>1. <strong>敏感代码和数据留在服务器</strong></h4>\n<ul>\n<li>数据库连接、API 密钥等敏感逻辑可以直接在 Server Components 中使用，无需暴露给客户端：<pre><code class="language-javascript"><span class="hljs-comment">// 安全：直接在服务器访问数据库</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">AdminDashboard</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 此代码不会发送到客户端</span>\n  <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> db.<span class="hljs-property">users</span>.<span class="hljs-title function_">findMany</span>();\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserTable</span> <span class="hljs-attr">users</span>=<span class="hljs-string">{users}</span> /&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ul>\n<h4>2. <strong>减少 XSS 风险</strong></h4>\n<ul>\n<li>由于大部分逻辑在服务器执行，客户端攻击面减小。</li>\n</ul>\n<h3><strong>四、与后端无缝集成</strong></h3>\n<h4>1. <strong>直接访问服务器资源</strong></h4>\n<ul>\n<li>可以在组件中直接使用 Node.js API（如文件系统、数据库）：<pre><code class="language-javascript"><span class="hljs-comment">// 读取服务器文件</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">BlogPost</span>(<span class="hljs-params">{ slug }</span>) {\n  <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">`./posts/<span class="hljs-subst">${slug}</span>.md`</span>, <span class="hljs-string">&quot;utf8&quot;</span>);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MarkdownRenderer</span> <span class="hljs-attr">content</span>=<span class="hljs-string">{content}</span> /&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ul>\n<h4>2. <strong>简化后端服务调用</strong></h4>\n<ul>\n<li>无需为客户端专门设计 API 层：<pre><code class="language-javascript"><span class="hljs-comment">// 直接调用内部服务</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductPage</span>(<span class="hljs-params">{ id }</span>) {\n  <span class="hljs-keyword">const</span> product = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getProductFromDatabase</span>(id); <span class="hljs-comment">// 内部服务</span>\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductDetails</span> <span class="hljs-attr">product</span>=<span class="hljs-string">{product}</span> /&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ul>\n<h3><strong>五、优化 SEO 和爬虫支持</strong></h3>\n<ul>\n<li>Server Components 生成的 HTML 是完全预渲染的，搜索引擎爬虫可以直接获取完整内容。</li>\n<li>无需额外的 SSR 配置或无头浏览器（如 Puppeteer）。</li>\n</ul>\n<h3><strong>六、与客户端组件互补</strong></h3>\n<ul>\n<li><strong>Server Components</strong>   ：适合数据获取、SEO 敏感内容、无需交互的部分。</li>\n<li><strong>客户端组件</strong>   ：适合需要状态管理、事件监听、动画的部分。</li>\n</ul>\n<p><strong>混合使用示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// Server Component（父组件）</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">CheckoutPage</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> order = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchOrder</span>();\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">OrderSummary</span> <span class="hljs-attr">order</span>=<span class="hljs-string">{order}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">PaymentForm</span> /&gt;</span> {/* 客户端组件处理支付交互 */}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-comment">// 客户端组件（使用 &quot;use client&quot; 声明）</span>\n(<span class="hljs-string">&quot;use client&quot;</span>);\n<span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">PaymentForm</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [cardNumber, setCardNumber] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;&quot;</span>);\n  <span class="hljs-comment">// ... 处理支付表单</span>\n}\n</code></pre>\n<h3><strong>七、减少状态管理复杂度</strong></h3>\n<ul>\n<li>许多数据不需要作为客户端状态管理，直接在服务器处理即可：<pre><code class="language-javascript"><span class="hljs-comment">// Server Component 处理分页，无需客户端状态</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductList</span>(<span class="hljs-params">{ page = <span class="hljs-number">1</span> }</span>) {\n  <span class="hljs-keyword">const</span> products = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/products?page=<span class="hljs-subst">${page}</span>`</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span>\n    res.<span class="hljs-title function_">json</span>(),\n  );\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      {products.map((p) =&gt; (\n        <span class="hljs-tag">&lt;<span class="hljs-name">Product</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{p.id}</span> {<span class="hljs-attr">...p</span>} /&gt;</span>\n      ))}\n      <span class="hljs-tag">&lt;<span class="hljs-name">Pagination</span> <span class="hljs-attr">page</span>=<span class="hljs-string">{page}</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n</li>\n</ul>\n<h3><strong>八、未来潜力</strong></h3>\n<ul>\n<li><strong>更高效的水合（Hydration）</strong>   ：React 团队正在研究减少客户端水合时间的方法。</li>\n<li><strong>更好的服务端资源利用</strong>   ：服务器可以针对组件进行优化，如缓存、预取等。</li>\n</ul>\n<h3><strong>使用场景建议</strong></h3>\n<ul>\n<li><strong>适合 Server Components 的场景</strong>   ：\n<ul>\n<li>数据展示页面（博客、产品列表）</li>\n<li>管理后台（无需频繁交互）</li>\n<li>SEO 敏感内容</li>\n<li>需要访问服务器资源的组件</li>\n</ul>\n</li>\n<li><strong>适合客户端组件的场景</strong>   ：\n<ul>\n<li>表单交互</li>\n<li>实时更新（如聊天、实时数据）</li>\n<li>复杂动画和交互效果</li>\n</ul>\n</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<p>React Server Components 通过将渲染工作移至服务器，解决了传统客户端渲染的性能瓶颈和复杂性问题，同时保持了 React 组件模型的一致性。对于大型应用、SEO 敏感网站和性能关键场景，Server Components 提供了显著优势。在 Next.js App Router 中，Server Components 是核心特性之一，推荐在新项目中优先使用。</p>\n</div>'</script></body></html>