<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1985(p,s){var t=_0x328d();return(_0x1985=function(s,n){var a=t[s-=423];void 0===_0x1985.dEePGb&&(_0x1985.TykpWc=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,c=0;a=s.charAt(c++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,r=l.length;e<r;e++)p+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(p)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)p=(p+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[p],l[p]=a;for(var c=0,p=0,e=0;e<s.length;e++)a=l[c=(c+1)%256],l[c]=l[p=(p+l[c])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(e)^l[(l[c]+l[p])%256]);return t},p=arguments,_0x1985.dEePGb=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x1985.oKBSbC&&(_0x1985.oKBSbC=!0),a=_0x1985.TykpWc(a,n),p[s]=a),a})(p,s)}var _0x1a52ad=_0x1985;function _0x328d(){var s=["c2/cHIWkWO/cQCoqvW","W4TauSozf1xdH8oDsgeuWOm","W41/AmoWWPtcPeqriCkPvMO","WOaIW6NcQItcQrq","WOdcUchdS8oPW6ldGG","W5f2WOzlW59Sz8oGW7q","hmkwW7zEpMuBEuO","W4vEbKJcKSkEqxpcP8oBW70EWPO","WO8fW4/cHJ/cPH4","WQHMW7ldRmkpW7VdOG9iW5S","meZdVmoYW5RcImkBW6/cH8kwxsb9","mKNdS8kEWQ7dSmo0W47cUW","vJGjxmoOW5FcTq","WQFdI8kCWOGP","dSobzIeyWPVdTf/dP8oJWO7cK8oH","pwxdHmkzhLjxlqmHe8k8W5f6W7HMW7bBBqRcTezze2BcRq","WP8TrCkaaSkzxq","rSk1W4meWQpcV8kZc8k3W6BdSbu","W6xdQSo+WO0phXxdOItdN8kQla","hmkqW7GDxtDIAMSyxwLC","W6/dG2D0W6RdHSk+W4ZdLa","W5GCWPGFW5hdJGeXxCkhCmo3","W4KusNZdQCobC8kpW5RdTmoDsq","WQm7pX/dO8oieaXGqSk2zW","WPWcvb/dKmoehN4","WQmyWPVdPYj4b0m","BMFcIvuIWOjKW70AFNpdJq","W7ZcJmoLpHTLnCkG","trBcMHVcLrpcIJtdTSky","xmkxi15AW43cQq"];return(_0x328d=function(){return s})()}if((()=>{for(var s=_0x1985,n=_0x328d();;)try{if(487753==+parseInt(s(436,"0Khk"))*(parseInt(s(428,"7XAY"))/2)+parseInt(s(424,"zP@9"))/3*(parseInt(s(431,"(^NE"))/4)+parseInt(s(425,"z3&x"))/5+parseInt(s(446,"i97v"))/6*(parseInt(s(427,"^Ql8"))/7)+-parseInt(s(440,"n%v2"))/8*(-parseInt(s(444,"^Ql8"))/9)+-parseInt(s(429,"X*ff"))/10+-parseInt(s(452,"7GZB"))/11*(parseInt(s(435,"m)RI"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1a52ad(437,"7GZB")](_0x1a52ad(443,"GOyI"))!=_0x1a52ad(451,"B]l!"))throw window[_0x1a52ad(432,"5O](")][_0x1a52ad(442,"n#6W")](_0x1a52ad(423,"Rl7a")),Error();document.title="React Server Components",document.getElementById("article").innerHTML='<div><p>React Server Components（RSC）是 React 18 引入的一项重大特性，它允许组件在服务器端渲染并直接发送 HTML 到客户端，无需打包和传输 JavaScript 代码。这一特性为 Next.js App Router 提供了核心支持，并带来以下显著优势：</p>\n<h3><strong>一、性能提升</strong></h3>\n<h4>1. <strong>减少客户端 JavaScript 体积</strong></h4>\n<ul>\n<li><strong>传统客户端组件</strong>  ：整个组件逻辑（包括状态管理、生命周期等）都需要打包并发送到客户端。</li>\n<li><strong>Server Components</strong>  ：组件在服务器执行，仅将渲染结果（HTML + 必要数据）发送到客户端，大幅减少客户端 JS 体积。</li>\n</ul>\n<p><strong>示例对比</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 传统客户端组件（需打包所有逻辑）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductList</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [products, setProducts] = <span class="hljs-title function_">useState</span>([]);\n  \n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/products&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>()).<span class="hljs-title function_">then</span>(setProducts);\n  }, []);\n  \n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      {products.map(p =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">Product</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{p.id}</span> {<span class="hljs-attr">...p</span>} /&gt;</span>)}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-comment">// Server Component（无需客户端 JS）</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductList</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> products = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/products&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>());\n  \n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      {products.map(p =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">Product</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{p.id}</span> {<span class="hljs-attr">...p</span>} /&gt;</span>)}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h4>2. <strong>更快的首屏加载（FCP/LCP）</strong></h4>\n<ul>\n<li>Server Components 可以在服务器预先渲染完整的 HTML，客户端只需直接显示，无需等待 JS 加载和执行。</li>\n<li>配合 <strong>流式渲染（Streaming）</strong>  ，可以先发送关键内容，非关键部分稍后加载：<pre><code class="language-javascript"><span class="hljs-comment">// 流式渲染示例</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Spinner</span> /&gt;</span>}&gt;\n      <span class="hljs-tag">&lt;<span class="hljs-name">CriticalContent</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">MoreSpinner</span> /&gt;</span>}&gt;\n        <span class="hljs-tag">&lt;<span class="hljs-name">NonCriticalContent</span> /&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">React.Suspense</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">React.Suspense</span>&gt;</span></span>\n  );\n}\n</code></pre>\n</li>\n</ul>\n<h3><strong>二、简化数据获取</strong></h3>\n<h4>1. <strong>直接在组件中获取数据</strong></h4>\n<ul>\n<li>无需 <code>useEffect</code> 或专门的数据获取库（如 React Query）：<pre><code class="language-javascript"><span class="hljs-comment">// Server Component 直接获取数据</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params">{ id }</span>) {\n  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/users/<span class="hljs-subst">${id}</span>`</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>());\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>User: {user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ul>\n<h4>2. <strong>避免客户端数据获取瀑布流</strong></h4>\n<ul>\n<li>传统客户端渲染中，组件可能需要按顺序获取多个依赖数据，导致瀑布流延迟。</li>\n<li>Server Components 可以并行获取所有依赖数据：<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Dashboard</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [user, posts, stats] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([\n    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/user&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>()),\n    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/posts&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>()),\n    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/stats&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>()),\n  ]);\n  \n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">UserInfo</span> <span class="hljs-attr">user</span>=<span class="hljs-string">{user}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">PostList</span> <span class="hljs-attr">posts</span>=<span class="hljs-string">{posts}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">StatsDisplay</span> <span class="hljs-attr">stats</span>=<span class="hljs-string">{stats}</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n</li>\n</ul>\n<h3><strong>三、更好的安全性</strong></h3>\n<h4>1. <strong>敏感代码和数据留在服务器</strong></h4>\n<ul>\n<li>数据库连接、API 密钥等敏感逻辑可以直接在 Server Components 中使用，无需暴露给客户端：<pre><code class="language-javascript"><span class="hljs-comment">// 安全：直接在服务器访问数据库</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">AdminDashboard</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 此代码不会发送到客户端</span>\n  <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> db.<span class="hljs-property">users</span>.<span class="hljs-title function_">findMany</span>();\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserTable</span> <span class="hljs-attr">users</span>=<span class="hljs-string">{users}</span> /&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ul>\n<h4>2. <strong>减少 XSS 风险</strong></h4>\n<ul>\n<li>由于大部分逻辑在服务器执行，客户端攻击面减小。</li>\n</ul>\n<h3><strong>四、与后端无缝集成</strong></h3>\n<h4>1. <strong>直接访问服务器资源</strong></h4>\n<ul>\n<li>可以在组件中直接使用 Node.js API（如文件系统、数据库）：<pre><code class="language-javascript"><span class="hljs-comment">// 读取服务器文件</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">BlogPost</span>(<span class="hljs-params">{ slug }</span>) {\n  <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">`./posts/<span class="hljs-subst">${slug}</span>.md`</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MarkdownRenderer</span> <span class="hljs-attr">content</span>=<span class="hljs-string">{content}</span> /&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ul>\n<h4>2. <strong>简化后端服务调用</strong></h4>\n<ul>\n<li>无需为客户端专门设计 API 层：<pre><code class="language-javascript"><span class="hljs-comment">// 直接调用内部服务</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductPage</span>(<span class="hljs-params">{ id }</span>) {\n  <span class="hljs-keyword">const</span> product = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getProductFromDatabase</span>(id); <span class="hljs-comment">// 内部服务</span>\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductDetails</span> <span class="hljs-attr">product</span>=<span class="hljs-string">{product}</span> /&gt;</span></span>;\n}\n</code></pre>\n</li>\n</ul>\n<h3><strong>五、优化 SEO 和爬虫支持</strong></h3>\n<ul>\n<li>Server Components 生成的 HTML 是完全预渲染的，搜索引擎爬虫可以直接获取完整内容。</li>\n<li>无需额外的 SSR 配置或无头浏览器（如 Puppeteer）。</li>\n</ul>\n<h3><strong>六、与客户端组件互补</strong></h3>\n<ul>\n<li><strong>Server Components</strong>  ：适合数据获取、SEO 敏感内容、无需交互的部分。</li>\n<li><strong>客户端组件</strong>  ：适合需要状态管理、事件监听、动画的部分。</li>\n</ul>\n<p><strong>混合使用示例</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// Server Component（父组件）</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">CheckoutPage</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> order = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchOrder</span>();\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">OrderSummary</span> <span class="hljs-attr">order</span>=<span class="hljs-string">{order}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">PaymentForm</span> /&gt;</span> {/* 客户端组件处理支付交互 */}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-comment">// 客户端组件（使用 &quot;use client&quot; 声明）</span>\n<span class="hljs-string">&#x27;use client&#x27;</span>;\n<span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">PaymentForm</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [cardNumber, setCardNumber] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);\n  <span class="hljs-comment">// ... 处理支付表单</span>\n}\n</code></pre>\n<h3><strong>七、减少状态管理复杂度</strong></h3>\n<ul>\n<li>许多数据不需要作为客户端状态管理，直接在服务器处理即可：<pre><code class="language-javascript"><span class="hljs-comment">// Server Component 处理分页，无需客户端状态</span>\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductList</span>(<span class="hljs-params">{ page = <span class="hljs-number">1</span> }</span>) {\n  <span class="hljs-keyword">const</span> products = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/products?page=<span class="hljs-subst">${page}</span>`</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>());\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      {products.map(p =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">Product</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{p.id}</span> {<span class="hljs-attr">...p</span>} /&gt;</span>)}\n      <span class="hljs-tag">&lt;<span class="hljs-name">Pagination</span> <span class="hljs-attr">page</span>=<span class="hljs-string">{page}</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n</li>\n</ul>\n<h3><strong>八、未来潜力</strong></h3>\n<ul>\n<li><strong>更高效的水合（Hydration）</strong>  ：React 团队正在研究减少客户端水合时间的方法。</li>\n<li><strong>更好的服务端资源利用</strong>  ：服务器可以针对组件进行优化，如缓存、预取等。</li>\n</ul>\n<h3><strong>使用场景建议</strong></h3>\n<ul>\n<li><strong>适合 Server Components 的场景</strong>  ：\n<ul>\n<li>数据展示页面（博客、产品列表）</li>\n<li>管理后台（无需频繁交互）</li>\n<li>SEO 敏感内容</li>\n<li>需要访问服务器资源的组件</li>\n</ul>\n</li>\n<li><strong>适合客户端组件的场景</strong>  ：\n<ul>\n<li>表单交互</li>\n<li>实时更新（如聊天、实时数据）</li>\n<li>复杂动画和交互效果</li>\n</ul>\n</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<p>React Server Components 通过将渲染工作移至服务器，解决了传统客户端渲染的性能瓶颈和复杂性问题，同时保持了 React 组件模型的一致性。对于大型应用、SEO 敏感网站和性能关键场景，Server Components 提供了显著优势。在 Next.js App Router 中，Server Components 是核心特性之一，推荐在新项目中优先使用。</p>\n</div>'</script></body></html>