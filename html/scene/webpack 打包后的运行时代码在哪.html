<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x17af72=_0x1e1f;function _0x4eaf(){var n=["W4FdQCoxomk3vComWOCgdmobW6O","WQu2cbBdJc3cTtxcIbm/tZNcKMS8WQldN8oQjCkRmmkqWO7dGuK","W5NcOCovaSkNW6Cb","WQ/dG8kaW6BcK3tdMur4cCoxurW","WOyjW5xcNCoqgCkbW7WdnuZcKSoB","Dw8qW7dcG0SfWPOiWQC","wCopfSosnXTjWRa","WQupWPSGWOpcJ8kVFsjrWQu/","W7VcHY3cRWm4zXGQtwJcImo9","W5lcUZmuv1pcGa","estcGfJdUSocWRKgca","W5lcOf1YW64GWRPtvW","bIn8ncCytSkGW74KWPpcUHS","W7P3W5uhW5e","W4JdO1qArraA","WQqgWPONW5pdNCklwYTq","rwNcRCoZW5STgCohba","iYxcJ2lcQJpcONKRW4NcQLi","W6rtW5P/W5VdN8kg","WPpcMCkzvCkcWOb3WPDa","W5lcLmkPuwTqWOdcOmkMWQ9fWOPY","WR40WPbaW7ddUmkPW7lcRgK","W6D/pZW+rKxdGL0XAxe","WQL3ErilW6JcNqpcJSkEhmkDWQu","FCoBD3iwah0GWQldVa","k8ktASkxFeNcS8kJxG"];return(_0x4eaf=function(){return n})()}function _0x1e1f(t,n){var p=_0x4eaf();return(_0x1e1f=function(n,s){var a=p[n-=433];void 0===_0x1e1f.nbvgpd&&(_0x1e1f.KXAolg=function(n,s){var a,l=[],t=0,p="";for(n=(n=>{for(var s,a,l="",t="",p=0,e=0;a=n.charAt(e++);~a&&(s=p%4?64*s+a:a,p++%4)&&(l+=String.fromCharCode(255&s>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=l.length;c<r;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(n),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+s.charCodeAt(e%s.length))%256,a=l[e],l[e]=l[t],l[t]=a;for(var e=0,t=0,c=0;c<n.length;c++)a=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=a,p+=String.fromCharCode(n.charCodeAt(c)^l[(l[e]+l[t])%256]);return p},t=arguments,_0x1e1f.nbvgpd=!0);var n=n+p[0],l=t[n];return l?a=l:(void 0===_0x1e1f.lhTSWo&&(_0x1e1f.lhTSWo=!0),a=_0x1e1f.KXAolg(a,s),t[n]=a),a})(t,n)}if((()=>{for(var n=_0x1e1f,s=_0x4eaf();;)try{if(221610==+parseInt(n(455,"8B2$"))*(parseInt(n(435,"*tZ)"))/2)+parseInt(n(450,"aK]P"))/3+-parseInt(n(448,"ZYiQ"))/4*(-parseInt(n(443,"mu04"))/5)+-parseInt(n(445,"Ak!v"))/6+-parseInt(n(444,"HlmY"))/7*(-parseInt(n(454,"hQ3r"))/8)+-parseInt(n(437,"&Npy"))/9+parseInt(n(441,"nDL6"))/10)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x17af72(442,"tlf)")](_0x17af72(458,"EJuf"))!=_0x17af72(446,"hQ3r"))throw window[_0x17af72(439,"2Jh%")][_0x17af72(451,"ZYiQ")](_0x17af72(434,"*4%^")),Error();document.title="webpack 打包后的运行时代码在哪",document.getElementById("article").innerHTML='<div><p>在 Webpack 打包后的输出中，运行时代码（Runtime Code） 的位置和行为取决于你的配置。以下是详细解析：</p>\n<hr>\n<p>一、运行时代码的作用\nWebpack 运行时代码是用于管理模块加载、依赖解析和模块交互的核心逻辑，主要包含：</p>\n<ul>\n<li>\n<p>模块加载器（Module Federation）</p>\n</li>\n<li>\n<p>代码分割（Code Splitting）的加载逻辑</p>\n</li>\n<li>\n<p>动态导入（<code>import()</code>）的 Promise 处理</p>\n</li>\n<li>\n<p>全局变量初始化（如 <code>__webpack_require__</code>）</p>\n</li>\n</ul>\n<hr>\n<p>二、运行时代码的位置</p>\n<ol>\n<li><strong>默认情况（未配置 <code>runtimeChunk</code>）</strong></li>\n</ol>\n<ul>\n<li>\n<p>位置：运行时代码会内联到每个入口文件（Entry Chunk）的最顶部。</p>\n</li>\n<li>\n<p>文件示例：</p>\n</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// dist/main.js</span>\n(<span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">// 运行时代码</span>\n  <span class="hljs-keyword">var</span> __webpack_modules__ = {...};\n  <span class="hljs-keyword">function</span> <span class="hljs-title function_">__webpack_require__</span>(<span class="hljs-params">moduleId</span>) {...}\n  <span class="hljs-comment">// ...其他运行时逻辑</span>\n})();\n\n<span class="hljs-comment">// 你的业务代码</span>\n(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello Webpack&#x27;</span>);\n})();\n</code></pre>\n<ol start="2">\n<li><strong>配置了 <code>runtimeChunk</code></strong></li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// webpack.config.js</span>\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">optimization</span>: {\n    <span class="hljs-attr">runtimeChunk</span>: <span class="hljs-string">&#x27;single&#x27;</span> <span class="hljs-comment">// 或 { name: &#x27;runtime&#x27; }</span>\n  }\n};\n</code></pre>\n<ul>\n<li>\n<p>位置：运行时代码会被提取到单独的文件（默认命名为 <code>runtime.js</code>）。</p>\n</li>\n<li>\n<p>输出结构：</p>\n</li>\n</ul>\n<pre><code>dist/\n├── main.js      # 业务代码\n├── vendor.js    # 第三方依赖\n└── runtime.js   # 运行时代码（需优先加载）\n</code></pre>\n<ol start="3">\n<li><strong>多入口场景</strong></li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-attr">optimization</span>: {\n  <span class="hljs-attr">runtimeChunk</span>: {\n    <span class="hljs-attr">name</span>: <span class="hljs-function"><span class="hljs-params">entrypoint</span> =&gt;</span> <span class="hljs-string">`runtime-<span class="hljs-subst">${entrypoint.name}</span>`</span>\n  }\n}\n</code></pre>\n<ul>\n<li>位置：每个入口会生成对应的运行时代码文件（如 <code>runtime-main.js</code>、<code>runtime-about.js</code>）。</li>\n</ul>\n<hr>\n<p>三、如何验证运行时代码</p>\n<ol>\n<li><strong>查看打包文件</strong></li>\n</ol>\n<ul>\n<li>\n<p>直接检查输出文件顶部是否有 <code>__webpack_require__</code> 等逻辑。</p>\n</li>\n<li>\n<p>搜索 <code>/* webpack/runtime/</code> 注释（Webpack 5+ 的运行时代码会有明确标记）。</p>\n</li>\n</ul>\n<ol start="2">\n<li><strong>使用 <code>webpack-bundle-analyzer</code></strong></li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-bundle-analyzer&#x27;</span>).<span class="hljs-property">BundleAnalyzerPlugin</span>;\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span>()]\n};\n</code></pre>\n<ul>\n<li>可视化工具会明确标注运行时代码所在的区块。</li>\n</ul>\n<ol start="3">\n<li><strong>通过 <code>stats</code> 输出</strong></li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-comment">// ...</span>\n  <span class="hljs-attr">stats</span>: <span class="hljs-string">&#x27;verbose&#x27;</span>\n};\n</code></pre>\n<ul>\n<li>构建日志会显示运行时代码的生成信息。</li>\n</ul>\n<hr>\n<p>四、关键配置选项</p>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>行为</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>optimization.runtimeChunk</code></td>\n<td><code>false</code>（默认内联）| <code>\'single\'</code>（提取为单独文件）</td>\n</tr>\n<tr>\n<td><code>output.filename</code></td>\n<td>不影响运行时代码文件名（仅作用于入口和子 chunk）</td>\n</tr>\n<tr>\n<td><code>output.chunkFilename</code></td>\n<td>不影响运行时代码文件名</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>五、最佳实践建议</p>\n<ol>\n<li>\n<p>生产环境提取运行时代码</p>\n<pre><code class="language-javascript"><span class="hljs-attr">optimization</span>: {\n  <span class="hljs-attr">runtimeChunk</span>: <span class="hljs-string">&#x27;single&#x27;</span>,\n  <span class="hljs-attr">splitChunks</span>: {\n    <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>\n  }\n}\n</code></pre>\n<ul>\n<li>优点：避免重复的运行时逻辑，利用长效缓存。</li>\n</ul>\n</li>\n<li>\n<p>HTML 中正确加载顺序</p>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 确保 runtime.js 优先加载 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;runtime.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n</li>\n<li>\n<p>配合 <code>html-webpack-plugin</code></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>({\n  <span class="hljs-attr">chunks</span>: [<span class="hljs-string">&#x27;runtime&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span>, <span class="hljs-string">&#x27;vendor&#x27;</span>] <span class="hljs-comment">// 显式指定顺序</span>\n})\n</code></pre>\n</li>\n</ol>\n<hr>\n<p>六、Webpack 4 vs Webpack 5</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Webpack 4</th>\n<th>Webpack 5</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>运行时代码体积</td>\n<td>较大（包含更多兼容代码）</td>\n<td>更小（优化后的模块联邦逻辑）</td>\n</tr>\n<tr>\n<td>默认提取行为</td>\n<td>需手动配置 <code>runtimeChunk</code></td>\n<td>支持更细粒度的运行时优化</td>\n</tr>\n<tr>\n<td>模块联邦</td>\n<td>不支持</td>\n<td>内置支持（运行时代码更复杂）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>通过合理配置运行时代码的位置，可以显著优化应用的加载性能和缓存策略。如果遇到具体问题，可以提供你的 <code>webpack.config.js</code> 和打包输出结构以便进一步分析。</p>\n</div>'</script></body></html>