<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x295109=_0x552e;function _0x3877(){var n=["B3jxy8kPWPNcOSkOdbBdTmoPW6m","W55lB8oGh27cN1JcRa/dMq","WRJdQ8kXW7TGW5NdUHWL","WRJdOSoeW6DXW7xdKXy","WOiqW67cRM4NsvdcM8o5","WO9bk0b4W65+WPrD","FCoYwSoAjaXRFMWQeJDFjq","kZ1FWO3dLHvbxLdcHW","WPy0W7/cIs9gWQBdQaVdPdWI","osZcUHFdRKz/cCoXW4mitxm","WPq1W7dcGI5pW5FdTGVdJZa3WO8","nmkJF3VcLSktoSoplSoXW7xdLYG","f1yFW58kW5hdI8ki","ktnFWO3cQ0mEsM7cO8o9WRfr","WPy3W7hdR3iEWRZdLaa","ocZcVX3dRu16gSo0W7mlCea","xxXLbmkniJ8eW7StfCkejwddOmkctGLtW4BdKw4toN1k","Ch3dNCoLgCkIW55IWOu","W77cNhxcJ2BdUCoxnG","q8k1jComW5K","W40VuWvLWO7cKvzZmGS","p8o1W5C/n8kRkW","kKmnW5mhWPVcKd3dSM4","DbRcNmk+W7KwcCojaqP6WRCiW78","krVdMmoXuc47yYG","WP98f3OIWRlcVW","WRbFWRJdQeJdLx/cSJlcQ2yP","ltjsWO3dRXz2rxBcNa"];return(_0x3877=function(){return n})()}function _0x552e(e,n){var r=_0x3877();return(_0x552e=function(n,t){var s=r[n-=365];void 0===_0x552e.OucHoi&&(_0x552e.YwMOlC=function(n,t){var s,o=[],e=0,r="";for(n=(n=>{for(var t,s,o="",e="",r=0,a=0;s=n.charAt(a++);~s&&(t=r%4?64*t+s:s,r++%4)&&(o+=String.fromCharCode(255&t>>(-2*r&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var l=0,c=o.length;l<c;l++)e+="%"+("00"+o.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(e)})(n),a=0;a<256;a++)o[a]=a;for(a=0;a<256;a++)e=(e+o[a]+t.charCodeAt(a%t.length))%256,s=o[a],o[a]=o[e],o[e]=s;for(var a=0,e=0,l=0;l<n.length;l++)s=o[a=(a+1)%256],o[a]=o[e=(e+o[a])%256],o[e]=s,r+=String.fromCharCode(n.charCodeAt(l)^o[(o[a]+o[e])%256]);return r},e=arguments,_0x552e.OucHoi=!0);var n=n+r[0],o=e[n];return o?s=o:(void 0===_0x552e.kIuryy&&(_0x552e.kIuryy=!0),s=_0x552e.YwMOlC(s,t),e[n]=s),s})(e,n)}if((()=>{for(var n=_0x552e,t=_0x3877();;)try{if(937902==-parseInt(n(387,"ej86"))*(parseInt(n(380,"3K90"))/2)+parseInt(n(388,"y!R0"))/3+parseInt(n(382,"y!R0"))/4+parseInt(n(381,"ej86"))/5*(-parseInt(n(378,"J(lQ"))/6)+-parseInt(n(365,"B@%M"))/7*(-parseInt(n(372,"3K90"))/8)+parseInt(n(384,"TohY"))/9+parseInt(n(368,"roFr"))/10*(-parseInt(n(385,"h0z&"))/11))break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x295109(370,"B@%M")](_0x295109(369,"4vL3"))!=_0x295109(392,"d]5u"))throw window[_0x295109(391,"%l@(")][_0x295109(366,"!52F")](_0x295109(389,"F8wB")),Error();document.title="react 合成事件如何模拟捕获阶段和冒泡阶段",document.getElementById("article").innerHTML='<div><p>React 通过<strong>事件委托（Event Delegation）</strong>   和<strong>手动遍历 Fiber 树</strong>   来模拟事件的捕获和冒泡流程。以下是其核心实现原理和步骤：</p>\n<hr>\n<h3>1. <strong>事件绑定阶段（初始化）</strong></h3>\n<p>React 在应用启动时，会在<strong>根节点</strong>   （如 <code>ReactDOM.createRoot().render()</code> 的容器）上统一监听原生事件（如 <code>click</code>），并启用<strong>捕获阶段</strong>   （<code>capture: true</code>）：</p>\n<pre><code class="language-js"><span class="hljs-comment">// React 内部的简化逻辑</span>\nrootNode.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, dispatchEvent, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 捕获阶段监听</span>\n</code></pre>\n<ul>\n<li><strong>为什么用捕获阶段？</strong><br>\n确保即使子组件调用 <code>e.nativeEvent.stopPropagation()</code> 阻止原生事件冒泡，React 仍能优先捕获事件。</li>\n</ul>\n<hr>\n<h3>2. <strong>事件触发流程</strong></h3>\n<p>当用户触发事件（如点击按钮）时：</p>\n<h4><strong>阶段 1：原生事件捕获</strong></h4>\n<ol>\n<li>浏览器从 <code>window</code> → <code>document</code> → ... → 目标元素（<code>&lt;button&gt;</code>）触发原生事件的<strong>捕获阶段</strong>   。</li>\n<li>React 的根节点监听器在捕获阶段被触发，调用 <code>dispatchEvent</code>。</li>\n</ol>\n<h4><strong>阶段 2：合成事件派发</strong></h4>\n<p>React 通过 <code>dispatchEvent</code> 执行以下步骤：</p>\n<ol>\n<li>\n<p><strong>定位目标 Fiber 节点</strong></p>\n<ul>\n<li>通过原生事件的 <code>event.target</code> 找到实际点击的 DOM 元素。</li>\n<li>根据 DOM 元素对应的 Fiber 节点（虚拟 DOM 节点），开始向上/向下遍历 Fiber 树。</li>\n</ul>\n</li>\n<li>\n<p><strong>模拟捕获阶段</strong></p>\n<ul>\n<li>从根 Fiber 节点开始，<strong>向下</strong>   遍历到目标 Fiber 节点。</li>\n<li>如果某个 Fiber 节点有 <code>onClickCapture</code> 回调，则触发它：<pre><code class="language-js"><span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">props</span>.<span class="hljs-property">onClickCapture</span>) {\n  syntheticEvent.<span class="hljs-property">currentTarget</span> = fiber; <span class="hljs-comment">// 设置当前目标</span>\n  fiber.<span class="hljs-property">props</span>.<span class="hljs-title function_">onClickCapture</span>(syntheticEvent); <span class="hljs-comment">// 触发捕获回调</span>\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>模拟目标阶段</strong></p>\n<ul>\n<li>到达目标 Fiber 节点后，触发其 <code>onClick</code> 或 <code>onClickCapture</code>（取决于当前阶段）。</li>\n</ul>\n</li>\n<li>\n<p><strong>模拟冒泡阶段</strong></p>\n<ul>\n<li>从目标 Fiber 节点<strong>向上</strong>   遍历到根 Fiber 节点。</li>\n<li>如果某个 Fiber 节点有 <code>onClick</code> 回调，则触发它：<pre><code class="language-js"><span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">props</span>.<span class="hljs-property">onClick</span>) {\n  syntheticEvent.<span class="hljs-property">currentTarget</span> = fiber;\n  fiber.<span class="hljs-property">props</span>.<span class="hljs-title function_">onClick</span>(syntheticEvent);\n}\n</code></pre>\n</li>\n<li>如果调用 <code>e.stopPropagation()</code>，则停止向上遍历。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>3. <strong>关键设计点</strong></h3>\n<h4>（1）<strong>独立于原生事件的冒泡</strong></h4>\n<ul>\n<li>React 的合成事件冒泡是<strong>手动遍历 Fiber 树</strong>   实现的，与原生 DOM 事件冒泡无关。</li>\n<li>即使原生事件冒泡被 <code>e.nativeEvent.stopPropagation()</code> 阻止，合成事件仍会正常触发。</li>\n</ul>\n<h4>（2）<strong>事件对象的复用</strong></h4>\n<ul>\n<li>React 使用<strong>事件池</strong>   （React 17 之前）复用 <code>SyntheticEvent</code> 对象，减少内存分配。</li>\n<li>在 React 17+ 中，事件池被移除，<code>SyntheticEvent</code> 对象不再复用。</li>\n</ul>\n<h4>（3）<strong>性能优化</strong></h4>\n<ul>\n<li>React 通过<strong>统一监听根节点</strong>   + <strong>按需触发回调</strong>   ，避免了直接绑定大量 DOM 事件监听器。</li>\n</ul>\n<hr>\n<h3>4. **代码示例与流程验证</h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClickCapture</span>=<span class="hljs-string">{()</span> =&gt;</span> console.log(&quot;Root Capture&quot;)}&gt;\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClickCapture</span>=<span class="hljs-string">{()</span> =&gt;</span> console.log(&quot;Parent Capture&quot;)}&gt;\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>\n          <span class="hljs-attr">onClickCapture</span>=<span class="hljs-string">{()</span> =&gt;</span> console.log(&quot;Button Capture&quot;)}\n          onClick={() =&gt; console.log(&quot;Button Bubble&quot;)}\n        &gt;\n          Click Me\n        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n};\n</code></pre>\n<p><strong>输出顺序</strong>   ：</p>\n<pre><code>Root Capture        // 捕获阶段：根 → 父 → 按钮\nParent Capture\nButton Capture\nButton Bubble       // 冒泡阶段：按钮 → 父 → 根（未阻止情况下）\n</code></pre>\n<hr>\n<h3>5. **与原生事件对比</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>React 合成事件</th>\n<th>原生 DOM 事件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>事件绑定</strong></td>\n<td>统一监听根节点（捕获阶段）</td>\n<td>直接绑定到目标元素</td>\n</tr>\n<tr>\n<td><strong>捕获阶段</strong></td>\n<td>手动向下遍历 Fiber 树</td>\n<td>原生捕获阶段（<code>capture: true</code>）</td>\n</tr>\n<tr>\n<td><strong>冒泡阶段</strong></td>\n<td>手动向上遍历 Fiber 树</td>\n<td>原生冒泡阶段</td>\n</tr>\n<tr>\n<td><strong>停止传播</strong></td>\n<td><code>e.stopPropagation()</code> 中断遍历</td>\n<td><code>e.stopPropagation()</code> 阻止原生冒泡</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>6. **React 17+ 的变化</h3>\n<ul>\n<li><strong>事件委托节点</strong>   ：从 <code>document</code> 改为应用根容器，避免多版本 React 冲突。</li>\n<li><strong>移除事件池</strong>   ：<code>SyntheticEvent</code> 对象不再复用，无需调用 <code>e.persist()</code>。</li>\n<li><strong>机制不变</strong>   ：仍通过 Fiber 树遍历模拟捕获/冒泡。</li>\n</ul>\n<hr>\n<h3>总结</h3>\n<p>React 通过以下步骤模拟事件捕获和冒泡：</p>\n<ol>\n<li><strong>统一监听</strong>   ：在根节点捕获原生事件。</li>\n<li><strong>定位目标</strong>   ：通过 <code>event.target</code> 找到对应 Fiber 节点。</li>\n<li><strong>手动遍历</strong>   ：\n<ul>\n<li><strong>捕获阶段</strong>   ：从根 Fiber 向下遍历，触发 <code>onXxxCapture</code>。</li>\n<li><strong>冒泡阶段</strong>   ：从目标 Fiber 向上遍历，触发 <code>onXxx</code>。</li>\n</ul>\n</li>\n<li><strong>完全控制</strong>   ：合成事件流程独立于原生事件，不受 <code>e.nativeEvent.stopPropagation()</code> 影响。</li>\n</ol>\n</div>'</script></body></html>