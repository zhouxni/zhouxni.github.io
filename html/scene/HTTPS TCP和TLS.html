<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0xe926(){var n=["W6RdK8otWOFdLCo0BSkqpGP3W4y","BgzhWQ7dKZFcKSkiW7pcTSo4WRhcNa","E8k9WQ7cTSo+WRxcUWFcP8oPWOe","W7VcT1SCW6VdS1OD","ywHeWQRdKZxdKmkTW5/cHCoIWOG","W5JdR8kpteH/kCk9WRhdHIjW","WQu6DmkbW5CeW7vWAJ3dL0e","W7GniJGAWQddMW","W5S2a8olhmkSzw0","d1xcVt7cJCk8WRxcRW","C8kDwgyvyH5OWOVcLuW","W73cPCoSW7BcRY/cOmoD","CmopacjZsZK","W5pdV28xWRP+W6OUWRZdQmofW7ddOq","x8o0vKFcQ8oWF8oa","gtWtW7NcL3BdQmkmW7a","W54tnsBdGWhdKSkTqZxcNmo0Da","o8k4W5JdLCooW5ngdZhdU04","WOiPk37cIuqn","W5iAC1RcRKxcOmkz","BfRcOSkKWROrWPu","W7ldMx8Uka","W4tcMSkdwSowW7RdJSoOcSkYwwH+","kCoBWOuoWQH3W4RdVGtdTdP2","tSoNpmoBWOv6WPtcMCkaw8ogi8ovmb1rWPFcGmoRWPlcMCkDjSkix8ky","WRHaWOpdOCkYu8k1","WOxcSCoyfqqMmSke","hCo2W4VcP8k2jrmu","W7KvW4VcV8oQb8kYWRuwmmolW6q","WP7dNbpdGCkVWPNdSq","W6RdLmoxWOFdM8ktqmkugafH","W4ZcLSobfmk2WOhcMSoe"];return(_0xe926=function(){return n})()}var _0x3eb3c5=_0x2fdb;function _0x2fdb(e,n){var T=_0xe926();return(_0x2fdb=function(n,t){var r=T[n-=149];void 0===_0x2fdb.yKPEsO&&(_0x2fdb.ezUXKf=function(n,t){var r,o=[],e=0,T="";for(n=(n=>{for(var t,r,o="",e="",T=0,s=0;r=n.charAt(s++);~r&&(t=T%4?64*t+r:r,T++%4)&&(o+=String.fromCharCode(255&t>>(-2*T&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var S=0,g=o.length;S<g;S++)e+="%"+("00"+o.charCodeAt(S).toString(16)).slice(-2);return decodeURIComponent(e)})(n),s=0;s<256;s++)o[s]=s;for(s=0;s<256;s++)e=(e+o[s]+t.charCodeAt(s%t.length))%256,r=o[s],o[s]=o[e],o[e]=r;for(var s=0,e=0,S=0;S<n.length;S++)r=o[s=(s+1)%256],o[s]=o[e=(e+o[s])%256],o[e]=r,T+=String.fromCharCode(n.charCodeAt(S)^o[(o[s]+o[e])%256]);return T},e=arguments,_0x2fdb.yKPEsO=!0);var n=n+T[0],o=e[n];return o?r=o:(void 0===_0x2fdb.sOJEYe&&(_0x2fdb.sOJEYe=!0),r=_0x2fdb.ezUXKf(r,t),e[n]=r),r})(e,n)}if((()=>{for(var n=_0x2fdb,t=_0xe926();;)try{if(245377==-parseInt(n(155,"U20F"))*(-parseInt(n(165,"N6eo"))/2)+parseInt(n(180,"lzAA"))/3*(-parseInt(n(179,"iy#k"))/4)+parseInt(n(178,"Sg3V"))/5*(parseInt(n(169,"iJ4!"))/6)+-parseInt(n(149,"qSBT"))/7*(-parseInt(n(167,"N6eo"))/8)+-parseInt(n(170,"3[Sm"))/9*(parseInt(n(173,"%$6J"))/10)+-parseInt(n(158,"aMXk"))/11*(-parseInt(n(176,"SOzk"))/12)+parseInt(n(168,"W)QF"))/13)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x3eb3c5(174,"T978")](_0x3eb3c5(150,"W)QF"))!=_0x3eb3c5(156,"GtI5"))throw window[_0x3eb3c5(161,"M3z[")][_0x3eb3c5(160,"ii3$")](_0x3eb3c5(159,"J6v4")),Error();document.title="HTTPS TCP和TLS",document.getElementById("article").innerHTML='<div><p>HTTPS（Hypertext Transfer Protocol Secure）作为安全的HTTP协议，其通信过程确实在TCP握手的基础上，增加了TLS（Transport Layer Security，传输层安全）或其前身SSL（Secure Sockets Layer）的加密握手流程。以下从协议层级、流程细节、安全性增强等方面详细解析两者的关系与交互：</p>\n<h3><strong>一、HTTPS的协议栈层级与TCP、TLS的关系</strong></h3>\n<h4>1. <strong>协议栈层级示意图</strong></h4>\n<pre><code>应用层（HTTPS）\n├─ 表示层（TLS/SSL）\n│  ├─ 握手协议（Handshake Protocol）\n│  ├─ 记录协议（Record Protocol）\n│  └─ 密码规范变更协议等\n└─ 传输层（TCP）\n   ├─ 三次握手（建立连接）\n   ├─ 数据传输\n   └─ 四次挥手（断开连接）\n</code></pre>\n<h4>2. <strong>核心关系</strong></h4>\n<ul>\n<li><strong>TCP是基础传输层协议</strong>  ：负责建立可靠连接、数据分段与重传等。</li>\n<li><strong>TLS运行在TCP之上</strong>  ：为应用层（HTTP）提供加密、认证和完整性保护。</li>\n<li><strong>HTTPS = HTTP + TLS over TCP</strong>  ：本质是HTTP报文通过TLS加密后，由TCP传输。</li>\n</ul>\n<h3><strong>二、HTTPS完整通信流程：从TCP握手到TLS加密</strong></h3>\n<h4>1. <strong>TCP三次握手阶段</strong></h4>\n<p>与普通HTTP相同，建立TCP连接：</p>\n<ol>\n<li>客户端发送SYN包，请求建立连接。</li>\n<li>服务器返回SYN+ACK包，确认请求。</li>\n<li>客户端返回ACK包，连接建立完成。</li>\n</ol>\n<h4>2. <strong>TLS握手阶段（关键差异点）</strong></h4>\n<p>TCP连接建立后，客户端与服务器开始TLS握手，流程如下（以TLS 1.3为例）：</p>\n<pre><code class="language-mermaid">sequenceDiagram\n    participant C as 客户端\n    participant S as 服务器\n    C-&gt;&gt;S: ClientHello（客户端随机数、支持的TLS版本、加密套件等）\n    S-&gt;&gt;C: ServerHello（服务器选择的TLS版本、加密套件、服务器随机数）\n    S-&gt;&gt;C: 服务器证书（含公钥）、ServerHelloDone\n    C-&gt;&gt;S: 客户端验证证书合法性，生成预主密钥（用服务器公钥加密）\n    C-&gt;&gt;S: 发送ChangeCipherSpec，通知后续数据加密\n    C-&gt;&gt;S: 发送Finished消息（验证握手完整性）\n    S-&gt;&gt;C: 发送ChangeCipherSpec，通知后续数据加密\n    S-&gt;&gt;C: 发送Finished消息（验证握手完整性）\n    Note over C,S: 双方基于预主密钥和随机数生成会话密钥，开始加密通信\n</code></pre>\n<h4>3. <strong>TLS握手的核心目标</strong></h4>\n<ul>\n<li><strong>身份认证</strong>  ：客户端通过服务器证书验证其身份（可选客户端证书认证）。</li>\n<li><strong>密钥协商</strong>  ：双方协商出对称加密的会话密钥，用于后续数据传输。</li>\n<li><strong>加密算法确定</strong>  ：选定数据加密、哈希校验的算法套件（如AES-GCM、SHA256）。</li>\n</ul>\n<h3><strong>三、TLS为HTTPS带来的安全性增强</strong></h3>\n<h4>1. <strong>加密传输（Confidentiality）</strong></h4>\n<ul>\n<li>使用对称加密（如AES）对HTTP报文加密，防止中间人窃听。</li>\n<li>对称密钥通过非对称加密（如RSA）在TLS握手中安全传输。</li>\n</ul>\n<h4>2. <strong>完整性保护（Integrity）</strong></h4>\n<ul>\n<li>通过HMAC（哈希消息认证码）或AEAD（Authenticated Encryption with Associated Data）算法，确保数据传输中未被篡改。</li>\n</ul>\n<h4>3. <strong>身份认证（Authentication）</strong></h4>\n<ul>\n<li>服务器必须提供CA（证书颁发机构）签名的证书，客户端验证其合法性，防止钓鱼网站。</li>\n<li>可选客户端证书认证，实现双向身份验证（如企业内部系统）。</li>\n</ul>\n<h3><strong>四、TCP与TLS握手的性能影响</strong></h3>\n<h4>1. <strong>连接延迟增加</strong></h4>\n<ul>\n<li>普通HTTP：1个RTT（往返时间）完成TCP握手，即可传输数据。</li>\n<li>HTTPS：TCP握手（1 RTT） + TLS握手（1~2 RTT），首次连接需2~3个RTT。</li>\n</ul>\n<h4>2. <strong>优化手段</strong></h4>\n<ul>\n<li><strong>TLS会话复用</strong>  ：通过Session ID或Session Ticket复用之前的密钥，减少握手次数。</li>\n<li><strong>HTTP/2 + TLS</strong>  ：多路复用减少连接数，头部压缩降低传输量。</li>\n<li><strong>QUIC协议</strong>  ：基于UDP实现，集成TLS加密和连接管理，减少握手延迟（如HTTP/3）。</li>\n</ul>\n<h3><strong>五、常见问题与对比</strong></h3>\n<h4>1. <strong>HTTPS与HTTP的本质区别</strong></h4>\n<table>\n<thead>\n<tr>\n<th><strong>维度</strong></th>\n<th><strong>HTTP</strong></th>\n<th><strong>HTTPS</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>传输层协议</strong></td>\n<td>TCP</td>\n<td>TCP + TLS/SSL</td>\n</tr>\n<tr>\n<td><strong>安全性</strong></td>\n<td>明文传输，无加密</td>\n<td>加密传输，防窃听、篡改、伪造</td>\n</tr>\n<tr>\n<td><strong>端口</strong></td>\n<td>80</td>\n<td>443</td>\n</tr>\n<tr>\n<td><strong>证书要求</strong></td>\n<td>无需证书</td>\n<td>服务器需CA证书，客户端验证</td>\n</tr>\n</tbody>\n</table>\n<h4>2. <strong>TLS与SSL的关系</strong></h4>\n<ul>\n<li><strong>SSL是TLS的前身</strong>  ：SSL 1.0未发布，SSL 2.0/3.0因安全漏洞被弃用。</li>\n<li><strong>TLS 1.0~1.3</strong>  ：TLS 1.0基于SSL 3.0改进，TLS 1.3是目前主流版本，安全性和性能更优。</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<p>HTTPS的通信流程可概括为：<strong>TCP三次握手建立连接 → TLS握手完成加密协商 → 基于加密通道传输HTTP数据</strong>  。TCP保证了数据传输的可靠性，而TLS则为数据添加了加密、认证和完整性保护，两者结合使HTTPS成为Web安全通信的标准。在性能优化上，需关注TLS握手的RTT损耗，通过会话复用、HTTP/2等技术减少延迟。</p>\n</div>'</script></body></html>