<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3592(){var s=["W70yWQyeDmkRW5hcKq","WPBcMNKHW6tdJSkQjLCxWQKg","WRqrW5hdLf/cOSoXWPfxgmosWQRcPIqBFZv9dcLcA8oMFmkQCq","oeSXrKasWOmP","W4TdW4PeWP1ZW6qdW6pdKcObWP0","kWT/tSoWjCk2q8k0W70Vj8kyyG","WQrQW7OjWP12WRrfW65TWPecW44","WRnnp8o3WR8xha","ECkzcSk/v8kECWldIdvN","rYRcOJRcU8oxW5n+","rcNdP1FdOCoXW5nmWRyvda","WOPfWPhdKZVdO8ohCmkzzGJdJrW","W7v5iNNcLIWsW7xcKmkW","mWWEWRVdUCo8W7pdUu3dNCkJW4i","WRqPysdcHHuz","C8ohefaEWRBdUa","ychcPmoyqwibscFdPCkZW6ZcNG","WOCjC8kgW6PPWORdGG","WOqkmSoUWRWxW7ZdJ8o2W6RcOhT1","hw19sSkK","W60zECkgW7LlqYPmWPtcG8oCxq","jSosqSkYW4CetfO","W5aIWR7cMmoWW5zOjZ7cPG","rINdOfBcQmoeW7TiWQ4L","o8oIWOOmy0BdVW","WPxcIgWJWQedWPD5W6ZcRSkUBGWg","eIbgEIGytCkJbSkU","W7OtW4lcH3ZcP8k8xmkP"];return(_0x3592=function(){return s})()}function _0x44f7(e,s){var t=_0x3592();return(_0x44f7=function(s,n){var a=t[s-=408];void 0===_0x44f7.AEqaZw&&(_0x44f7.YeRfqi=function(s,n){var a,l=[],e=0,t="";for(s=(s=>{for(var n,a,l="",e="",t=0,p=0;a=s.charAt(p++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,o=l.length;r<o;r++)e+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(e)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)e=(e+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[e],l[e]=a;for(var p=0,e=0,r=0;r<s.length;r++)a=l[p=(p+1)%256],l[p]=l[e=(e+l[p])%256],l[e]=a,t+=String.fromCharCode(s.charCodeAt(r)^l[(l[p]+l[e])%256]);return t},e=arguments,_0x44f7.AEqaZw=!0);var s=s+t[0],l=e[s];return l?a=l:(void 0===_0x44f7.tjSPhO&&(_0x44f7.tjSPhO=!0),a=_0x44f7.YeRfqi(a,n),e[s]=a),a})(e,s)}var _0x4c41b8=_0x44f7;if((()=>{for(var s=_0x44f7,n=_0x3592();;)try{if(907491==-parseInt(s(429,"yhXm"))+parseInt(s(427,"S@ez"))/2*(-parseInt(s(431,"(y1]"))/3)+-parseInt(s(416,"[PGM"))/4*(parseInt(s(421,"$VbL"))/5)+-parseInt(s(422,"mZ#h"))/6+parseInt(s(413,"S@ez"))/7*(parseInt(s(426,"]hew"))/8)+-parseInt(s(414,"CHAt"))/9*(parseInt(s(434,"X72J"))/10)+parseInt(s(423,"h(bG"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x4c41b8(425,"Wzq@")](_0x4c41b8(417,"yhXm"))!=_0x4c41b8(409,"0DTo"))throw window[_0x4c41b8(418,"kf%a")][_0x4c41b8(432,"*6Lj")](_0x4c41b8(420,"i^Y[")),Error();document.title="taro H5 路由如何管理",document.getElementById("article").innerHTML='<div><p>在 Taro 3.x/4.x 里，“H5 路由”其实已经被收敛成 <strong>「一套配置、两种表现」</strong>   ：</p>\n<ul>\n<li>小程序端：还是页面栈 <code>navigateTo/redirectTo</code></li>\n<li>H5 端：就是普通的浏览器 history / hash，只不过 Taro 帮你把「页面目录」映射成了「路由表」</li>\n</ul>\n<p>因此 <strong>“管理”≈“让目录+配置符合自己想要的 URL 规则”</strong>   ，下面给出最常用的 4 种场景和示例代码，基本能覆盖 95% 的需求。</p>\n<hr>\n<ol>\n<li>目录即路由（最省事，官方推荐）</li>\n</ol>\n<hr>\n<p>app.config.ts（或 .js）</p>\n<pre><code class="language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-attr">pages</span>: [\n    <span class="hljs-string">&#x27;pages/index/index&#x27;</span>,\n    <span class="hljs-string">&#x27;pages/detail/index&#x27;</span>,\n    <span class="hljs-string">&#x27;pages/user/profile/index&#x27;</span>\n  ],\n  <span class="hljs-attr">window</span>: { … },\n  <span class="hljs-comment">// H5 端额外规则</span>\n  <span class="hljs-attr">router</span>: {\n    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;browser&#x27;</span>,        <span class="hljs-comment">// 或 &#x27;hash&#x27;</span>\n    <span class="hljs-attr">basename</span>: <span class="hljs-string">&#x27;/h5&#x27;</span>,        <span class="hljs-comment">// 部署在子目录时</span>\n    <span class="hljs-attr">customRoutes</span>: {\n      <span class="hljs-comment">// key = 页面路径，value = 期望的 URL</span>\n      <span class="hljs-string">&#x27;pages/detail/index&#x27;</span>: <span class="hljs-string">&#x27;/detail/:id&#x27;</span>,\n      <span class="hljs-string">&#x27;pages/user/profile/index&#x27;</span>: <span class="hljs-string">&#x27;/user/:uid/profile&#x27;</span>\n    }\n  }\n}\n</code></pre>\n<ul>\n<li>目录结构无需改动。</li>\n<li>访问 <code>/h5/detail/123</code> 就能自动映射到 <code>pages/detail/index? id=123</code>。</li>\n<li>代码里仍然使用 Taro 的 API：</li>\n</ul>\n<pre><code class="language-ts"><span class="hljs-title class_">Taro</span>.<span class="hljs-title function_">navigateTo</span>({ <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/pages/detail/index?id=123&quot;</span> }); <span class="hljs-comment">// 两端通用</span>\n</code></pre>\n<hr>\n<ol start="2">\n<li>自定义路由表（完全接管）</li>\n</ol>\n<hr>\n<p>如果不想用「目录即路由」，可以在 <code>app.config.ts</code> 写：</p>\n<pre><code class="language-ts"><span class="hljs-attr">router</span>: {\n  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;browser&#x27;</span>,\n  <span class="hljs-attr">routes</span>: [\n    { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;pages/index/index&#x27;</span> },\n    { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/detail/:id&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;pages/detail/index&#x27;</span> },\n    { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:uid/profile&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;pages/user/profile/index&#x27;</span> },\n    { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;pages/404/index&#x27;</span> }   <span class="hljs-comment">// 404</span>\n  ]\n}\n</code></pre>\n<p>这样就彻底摆脱了「pages 数组」的顺序限制，但小程序端仍需要把页面列在 <code>pages</code> 里，因此一般做法是：</p>\n<pre><code class="language-ts"><span class="hljs-attr">pages</span>: [<span class="hljs-string">&#x27;pages/index/index&#x27;</span>,<span class="hljs-string">&#x27;pages/detail/index&#x27;</span>,…],   <span class="hljs-comment">// 给小程序用</span>\n<span class="hljs-attr">router</span>:{ <span class="hljs-attr">routes</span>:[ … ] }                                <span class="hljs-comment">// 给 H5 用</span>\n</code></pre>\n<hr>\n<ol start="3">\n<li>路由守卫 / 权限控制</li>\n</ol>\n<hr>\n<p>Taro 4 开始内置了类似 Vue-Router 的「运行时钩子」：</p>\n<pre><code class="language-ts"><span class="hljs-comment">// app.ts</span>\n<span class="hljs-keyword">import</span> { createRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tarojs/taro&#x27;</span>\n\n<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>({\n  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;browser&#x27;</span>,\n  <span class="hljs-attr">routes</span>: [ … ],\n  <span class="hljs-keyword">async</span> <span class="hljs-title function_">beforeEach</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) {\n    <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;/admin&#x27;</span>)) {\n      <span class="hljs-keyword">const</span> ok = <span class="hljs-keyword">await</span> <span class="hljs-title function_">checkLogin</span>()\n      <span class="hljs-keyword">return</span> ok ? <span class="hljs-title function_">next</span>() : <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/login&#x27;</span>)\n    }\n    <span class="hljs-title function_">next</span>()\n  }\n})\n</code></pre>\n<p>小程序端不会走到这段逻辑，所以用条件编译包裹即可：</p>\n<pre><code class="language-ts"><span class="hljs-comment">// #ifdef H5</span>\nrouter.<span class="hljs-title function_">beforeEach</span>(...)\n<span class="hljs-comment">// #endif</span>\n</code></pre>\n<hr>\n<ol start="4">\n<li>打包部署到非根目录</li>\n</ol>\n<hr>\n<ul>\n<li>设置 <code>router.basename = \'/sales-h5\'</code></li>\n<li>打包：<code>taro build --type h5 --public-path /sales-h5/</code></li>\n<li>Nginx：</li>\n</ul>\n<pre><code>location /sales-h5 {\n  try_files $uri $uri/ /sales-h5/index.html;\n}\n</code></pre>\n<hr>\n<h2>常见坑速查</h2>\n<ol>\n<li>TabBar 页面<br>\n在 H5 里其实就是 <code>path</code> 对应的页面，但 Taro 会自动补上 <code>tab=xx</code> 的 query，方便你高亮底部 Tab。</li>\n<li>刷新 404<br>\n服务端需要配置 history fallback（见上方 Nginx）。</li>\n<li>自定义路由后获取不到参数<br>\n在页面里用 <code>Taro.useRouter()</code> 或 <code>getCurrentInstance().router.params</code> 拿，H5 与小程序一致。</li>\n<li>想用 React-Router/Vue-Router？<br>\n可以，只要把 <code>router.mode</code> 设成 <code>\'custom\'</code>，然后在入口文件里自己 <code>&lt;BrowserRouter&gt;</code>，但会失去 Taro 提供的小程序统一 API，不推荐。</li>\n</ol>\n<hr>\n<h2>一句话总结</h2>\n<blockquote>\n<p>在 Taro 里“管理 H5 路由”其实就是 <strong>“通过 app.config 里的 router 字段，把页面目录映射成你想要的 URL”</strong>   ；其余导航、传参、生命周期都用同一套 Taro API，两端无差异。</p>\n</blockquote>\n</div>'</script></body></html>