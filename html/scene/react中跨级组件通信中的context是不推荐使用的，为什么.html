<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x181977=_0x5247;function _0x5247(l,s){var p=_0x2bd0();return(_0x5247=function(s,n){var a=p[s-=117];void 0===_0x5247.jMcWwJ&&(_0x5247.ZxXQEm=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=t.length;c<o;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,c=0;c<s.length;c++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(c)^t[(t[e]+t[l])%256]);return p},l=arguments,_0x5247.jMcWwJ=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x5247.mHLgli&&(_0x5247.mHLgli=!0),a=_0x5247.ZxXQEm(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x5247,n=_0x2bd0();;)try{if(449795==-parseInt(s(132,"f#KC"))+parseInt(s(137,"PSMJ"))/2+parseInt(s(123,"4P5u"))/3*(-parseInt(s(131,"]aKy"))/4)+-parseInt(s(124,"dbYW"))/5+parseInt(s(138,"VD)l"))/6*(-parseInt(s(133,"]aKy"))/7)+-parseInt(s(118,"dbYW"))/8+parseInt(s(126,"^zlO"))/9*(parseInt(s(127,"Curg"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x181977(128,"VD)l")](_0x181977(142,"!^Ct"))!=_0x181977(117,"Ho7j"))throw window[_0x181977(129,"xnU*")][_0x181977(119,"JbC[")](_0x181977(140,"Curg")),Error();function _0x2bd0(){var s=["WP3dVKNcPmkRW5mUfI0","WRWyw8k9WOzaAMfZBG","z8oBWP/dUb/cG8kJzCktqSou","W5ZcKtOaeSksWP3dISkrf0ry","WQdcU2H2WQ0jnmkNmW","W5VcICo5W71By8kLW7qjW73cM8k4oW","t8ogW6XdhLlcKSoqawpcJdBcLmkwv8o3WPlcGM42lmkJwdRcJxi","WQPvDSkVxW7dNSon","WO1pfremWRWvW43dNa","WO1cx8oqwq","urSsECo1y1reWRxcRwVcO8o2","jHxcM8oTWRqWbG","W49Dn8kRySkax8oCD359W5WIpG","eSkrm8kYc0XHysG+WRyc","W48pfmkvfLjohCkwAfPccG","CKPJWP/dLrhcJmo6","ubuBESoYzvnAWQ7cGLtcN8oY","W7tcSvW2WPdcUdpdQmkuWRqluq","WRpdQLlcJu9qWPm","fCkeWQKdw1ZcJmopgMFcIbRcNCkP","W7pdQsHWWPepga","WQZdQaDIW5hdPtxdHq","zSo6WQOxW7tcG8ki","CSo2cuToe8o5W7Xoemom","W4ddI8oqW4/cQIhdMmkfkaldTH8","Fmo1d04chSoZW4jRkG"];return(_0x2bd0=function(){return s})()}document.title="react中跨级组件通信中的context是不推荐使用的，为什么",document.getElementById("article").innerHTML='<div><p>在 React 中，Context 是一种用于跨级组件通信的机制，但有时候被认为在某些场景下不推荐过度使用。以下是原因和分析：</p>\n<hr>\n<h3>1. <strong>Context 会导致组件的隐式依赖</strong></h3>\n<ul>\n<li>\n<p><strong>问题</strong>  ：使用 Context 会使组件隐式地依赖于上下文的值，而不是通过明确的 props 传递数据。这种隐式依赖可能使组件的行为变得难以预测和调试。</p>\n</li>\n<li>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">Button</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">const</span> theme = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">background:</span> <span class="hljs-attr">theme.background</span> }}&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n};\n</code></pre>\n<p>在上述代码中，<code>Button</code> 组件依赖于 <code>ThemeContext</code>，但这种依赖关系并没有在组件的 props 中显式声明。</p>\n</li>\n<li>\n<p><strong>影响</strong>  ：当上下文值发生变化时，依赖它的组件可能会表现出意外的行为，而开发者可能难以追踪问题的根源。</p>\n</li>\n</ul>\n<hr>\n<h3>2. <strong>Context 会增加组件的重新渲染</strong></h3>\n<ul>\n<li>\n<p><strong>问题</strong>  ：Context 的值发生变化时，所有消费该 Context 的组件都会重新渲染，即使它们的 props 没有变化。</p>\n</li>\n<li>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">CountContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">Counter</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">const</span> count = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">CountContext</span>);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n};\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);\n  <span class="hljs-keyword">const</span> [text, setText] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">CountContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{count}</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> /&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{text}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setText(e.target.value)} /&gt;\n    <span class="hljs-tag">&lt;/<span class="hljs-name">CountContext.Provider</span>&gt;</span></span>\n  );\n};\n</code></pre>\n<p>在上述代码中，每次更新 <code>text</code> 状态时，<code>Counter</code> 组件也会重新渲染，即使 <code>count</code> 没有变化。</p>\n</li>\n<li>\n<p><strong>影响</strong>  ：这可能导致不必要的性能开销，尤其是在消费 Context 的组件树较深或组件数量较多的情况下。</p>\n</li>\n</ul>\n<hr>\n<h3>3. <strong>Context 的设计初衷是用于全局共享状态，而不是频繁变化的数据</strong></h3>\n<ul>\n<li>\n<p><strong>问题</strong>  ：Context 最适合用于全局共享且变化不频繁的状态，如主题、语言等。如果用于频繁变化的状态，可能会导致性能问题和难以维护的代码。</p>\n</li>\n<li>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">UserProfile</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">const</span> user = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">UserContext</span>);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>User: {user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n};\n</code></pre>\n<p>如果 <code>UserContext</code> 的值频繁变化，所有依赖它的组件都会频繁重新渲染。</p>\n</li>\n<li>\n<p><strong>影响</strong>  ：这违背了 Context 的设计初衷，可能导致代码难以维护和性能下降。</p>\n</li>\n</ul>\n<hr>\n<h3>4. <strong>Context 的调试和测试较为困难</strong></h3>\n<ul>\n<li>\n<p><strong>问题</strong>  ：由于 Context 的隐式依赖和全局性，调试和测试变得困难。开发者需要了解整个上下文的值流，才能准确调试组件的行为。</p>\n</li>\n<li>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">AuthContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">ProtectedComponent</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">const</span> auth = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">AuthContext</span>);\n  <span class="hljs-keyword">if</span> (!auth.<span class="hljs-property">isAuthenticated</span>) {\n    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Please log in<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n  }\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Welcome back!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n};\n</code></pre>\n<p>在上述代码中，如果 <code>ProtectedComponent</code> 的行为不符合预期，开发者需要检查 <code>AuthContext</code> 的提供者和值流。</p>\n</li>\n<li>\n<p><strong>影响</strong>  ：这增加了调试和测试的复杂性，尤其是在大型应用中。</p>\n</li>\n</ul>\n<hr>\n<h3>5. <strong>Context 的过度使用可能导致代码耦合度增加</strong></h3>\n<ul>\n<li>\n<p><strong>问题</strong>  ：过度依赖 Context 会导致组件之间的耦合度增加，使得组件难以复用或独立测试。</p>\n</li>\n<li>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">AppContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">FeatureComponent</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">const</span> appState = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">AppContext</span>);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{appState.featureEnabled ? &#x27;Feature Enabled&#x27; : &#x27;Feature Disabled&#x27;}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n};\n</code></pre>\n<p>在上述代码中，<code>FeatureComponent</code> 紧密依赖于 <code>AppContext</code>，难以在其他上下文中复用。</p>\n</li>\n<li>\n<p><strong>影响</strong>  ：这降低了组件的可复用性和可维护性。</p>\n</li>\n</ul>\n<hr>\n<h3>6. <strong>React 的其他状态管理方案更适合复杂场景</strong></h3>\n<ul>\n<li><strong>问题</strong>  ：对于复杂的状态管理需求，React 提供了其他更合适的方案，如 Redux、MobX、Recoil 等。这些方案提供了更强大的状态管理能力和更好的性能优化。</li>\n<li><strong>示例</strong>  ：\n<ul>\n<li>Redux：通过 reducer 和 middleware 管理全局状态，提供了可预测的状态更新和更好的调试工具。</li>\n<li>Recoil：提供了更细粒度的状态管理，适合复杂应用。</li>\n</ul>\n</li>\n<li><strong>影响</strong>  ：在复杂场景下，使用 Context 可能导致代码难以维护和性能问题，而其他状态管理方案可能更适合。</li>\n</ul>\n<hr>\n<h3>总结</h3>\n<p>虽然 Context 是 React 中一种强大的跨级组件通信机制，但在某些场景下不推荐过度使用，主要原因包括：</p>\n<ol>\n<li>隐式依赖导致组件行为难以预测。</li>\n<li>可能导致不必要的组件重新渲染。</li>\n<li>不适合频繁变化的状态。</li>\n<li>调试和测试困难。</li>\n<li>增加组件耦合度。</li>\n<li>其他状态管理方案更适合复杂场景。</li>\n</ol>\n<p><strong>建议</strong>  ：</p>\n<ul>\n<li>在使用 Context 时，谨慎评估其适用性。</li>\n<li>对于全局共享且变化不频繁的状态，Context 是一个合适的选择。</li>\n<li>对于复杂的状态管理需求，考虑使用 Redux、MobX 或 Recoil 等方案。</li>\n<li>优先通过 props 传递数据，保持组件的独立性和可复用性。</li>\n</ul>\n</div>'</script></body></html>