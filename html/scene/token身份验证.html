<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1c15(){var n=["pSk8WQ7cUCoAWPhcT8oFW5C","WOpdT8oQmti0hCkxn8obW5fmWOG","gSoxW4Grn8kSW5y","W7TTWQPboeVdRG5bW4BdJZq","WQZcU8knW4RcV8oeW7xcPG","fKOrcmkAWOK7Fmk5pmoUWPSD","wCkcWO1eymo5W7qHW4tdOrBcQG","WPP5FmkVamoHbCo+gG","DJHXs04VW64/WP4","eK0xcSocW51kq8k+gW","WQtdQ8o7WQaHW4pcG1XDD8kt","agJdPfBcISkWcW1il8kmWQpdPKJdKCkbdmkPW4baWPtdHtS5htW","dJL0xmkNWRRdHCo+W5uYyW","bCo/WRudz8kOjCkCqmokoq","W57dNmoRz2COh8oLyWGs","W57cR8k5Ax5RsSk1","zSoKWQLeWPrzW53cSCopyLeyBW","o8kdE8koEqffxSogBCoXWPWK","Cgz/W4X1x8o6W44","WQFdRmo4WQaJWRlcMN1JsCkDbW","CYXoW6OgWQZdH8kzrmoK","wsZcPr/dJ8k8y3rgcmklWRO","WRNcOGJdOv8mFCoRW7baAs8","igS1D306W6G","zmoIWQ9fWPvwWO7cRSolxg0x","vmk5tCo/WPK"];return(_0x1c15=function(){return n})()}var _0x375356=_0x2e2f;function _0x2e2f(t,n){var s=_0x1c15();return(_0x2e2f=function(n,o){var e=s[n-=442];void 0===_0x2e2f.NuuCrk&&(_0x2e2f.pokYuz=function(n,o){var e,r=[],t=0,s="";for(n=(n=>{for(var o,e,r="",t="",s=0,k=0;e=n.charAt(k++);~e&&(o=s%4?64*o+e:e,s++%4)&&(r+=String.fromCharCode(255&o>>(-2*s&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var l=0,i=r.length;l<i;l++)t+="%"+("00"+r.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(t)})(n),k=0;k<256;k++)r[k]=k;for(k=0;k<256;k++)t=(t+r[k]+o.charCodeAt(k%o.length))%256,e=r[k],r[k]=r[t],r[t]=e;for(var k=0,t=0,l=0;l<n.length;l++)e=r[k=(k+1)%256],r[k]=r[t=(t+r[k])%256],r[t]=e,s+=String.fromCharCode(n.charCodeAt(l)^r[(r[k]+r[t])%256]);return s},t=arguments,_0x2e2f.NuuCrk=!0);var n=n+s[0],r=t[n];return r?e=r:(void 0===_0x2e2f.GKHpyO&&(_0x2e2f.GKHpyO=!0),e=_0x2e2f.pokYuz(e,o),t[n]=e),e})(t,n)}if((()=>{for(var n=_0x2e2f,o=_0x1c15();;)try{if(357368==-parseInt(n(464,"&xw8"))+-parseInt(n(447,"099o"))/2+-parseInt(n(466,"5j6@"))/3+parseInt(n(460,"SCy#"))/4*(-parseInt(n(455,"BkOA"))/5)+parseInt(n(443,"j6)P"))/6+-parseInt(n(463,"IqnW"))/7*(parseInt(n(450,"^RD@"))/8)+-parseInt(n(452,"dAF^"))/9*(-parseInt(n(451,"099o"))/10))break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x375356(465,"^RD@")](_0x375356(442,"V!*g"))!=_0x375356(467,"%6tz"))throw window[_0x375356(457,"j6)P")][_0x375356(444,"(AxN")](_0x375356(453,"IqnW")),Error();document.title="token身份验证",document.getElementById("article").innerHTML="<div><p>Token 进行身份验证是现代 Web 应用和移动应用中广泛采用的一种无状态身份验证机制。以下是对 Token 身份验证的详细解析：</p>\n<h3>一、Token 的基本概念</h3>\n<ul>\n<li><strong>定义</strong>  ：Token 是一个用于身份验证和授权的令牌，通常由服务器生成并返回给客户端。</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li><strong>无状态性</strong>  ：服务器不需要存储关于用户会话的状态数据，每次请求时客户端都会在请求头中附带 Token，服务器通过解析 Token 来验证身份。</li>\n<li><strong>自包含性</strong>  ：以 JWT（JSON Web Token）为代表的 Token，通常包含了用户的身份信息、权限信息等数据，这些信息直接存储在 Token 本身中，服务器无需查询数据库或其他后端服务即可获取信息。</li>\n</ul>\n</li>\n</ul>\n<h3>二、Token 的工作流程</h3>\n<ol>\n<li><strong>用户登录</strong>  ：用户通过登录界面提供用户名和密码，发送给服务器。</li>\n<li><strong>服务器验证并生成 Token</strong>  ：服务器验证用户身份（如验证用户名和密码），如果验证通过，生成一个 Token（例如 JWT），并返回给客户端。</li>\n<li><strong>客户端存储 Token</strong>  ：客户端收到 Token 后，将其存储在本地，常见的存储方式有 localStorage、sessionStorage 或 Cookie。</li>\n<li><strong>客户端在后续请求中携带 Token</strong>  ：在随后的 HTTP 请求中，客户端将 Token 附加到请求头的 Authorization 部分。</li>\n<li><strong>服务器验证 Token</strong>  ：服务器解析 Token，验证其有效性，确保 Token 没有过期，并根据 Token 中的信息（如用户身份、权限等）判断是否允许访问相应的资源。</li>\n</ol>\n<h3>三、Token 的类型</h3>\n<ul>\n<li><strong>JWT（JSON Web Token）</strong>  ：\n<ul>\n<li><strong>结构</strong>  ：JWT 包含三部分：Header（头部）、Payload（载荷）、Signature（签名）。</li>\n<li><strong>特点</strong>  ：JWT 是一种开放标准，用于在网络应用环境中传递声明。它通常使用 HMAC SHA256 或 RSA 等算法进行签名，以确保 Token 的完整性和真实性。</li>\n</ul>\n</li>\n<li><strong>OAuth 2.0 Token</strong>  ：\n<ul>\n<li><strong>类型</strong>  ：包括 Access Token 和 Refresh Token。</li>\n<li><strong>特点</strong>  ：Access Token 用于访问受保护的资源，有效期通常较短；Refresh Token 用于获取新的 Access Token，当 Access Token 过期时，客户端可以通过 Refresh Token 来重新获取一个新的 Access Token。</li>\n</ul>\n</li>\n<li><strong>API Token</strong>  ：\n<ul>\n<li><strong>特点</strong>  ：API Token 通常用于后台 API 的访问控制，是一种简单的身份认证方式，通常以字符串的形式存在，客户端将其附加到 HTTP 请求头中进行验证。</li>\n</ul>\n</li>\n</ul>\n<h3>四、Token 身份验证的优点</h3>\n<ul>\n<li><strong>无状态性</strong>  ：减轻了服务器的存储压力，尤其适合分布式和微服务架构。</li>\n<li><strong>跨域支持</strong>  ：Token 是通过 HTTP 请求头传递的，不受浏览器的跨域限制，适合跨域认证。</li>\n<li><strong>安全性</strong>  ：Token 通常包含签名，可以有效防止数据被篡改，同时结合 HTTPS 协议传输，确保 Token 的安全性。</li>\n</ul>\n<h3>五、Token 身份验证的缺点</h3>\n<ul>\n<li><strong>占带宽</strong>  ：Token 通常比 session_id 更大，需要消耗更多流量。</li>\n<li><strong>性能问题</strong>  ：相比于 session-cookie 来说，Token 需要服务端花费更多的时间和性能来对 Token 进行解密验证。</li>\n<li><strong>存储风险</strong>  ：Token 通常存储在客户端，存在被窃取的风险，因此需要注意安全性。</li>\n</ul>\n<h3>六、Token 身份验证的安全策略</h3>\n<ul>\n<li><strong>使用 HTTPS 协议</strong>  ：确保 Token 在传输过程中的安全性。</li>\n<li><strong>Token 加密存储</strong>  ：在客户端存储 Token 时，可以使用加密算法进行加密，增加安全性。</li>\n<li><strong>设置过期时间</strong>  ：在 Token 中设置过期时间，避免 Token 被长期滥用。</li>\n<li><strong>使用刷新 Token 机制</strong>  ：在 Access Token 过期后，通过 Refresh Token 获取新的 Access Token，避免用户频繁登录。</li>\n<li><strong>限制 Token 使用次数</strong>  ：设置 IP 白名单和限制 Token 的使用次数等措施，增加安全性。</li>\n</ul>\n</div>"</script></body></html>