<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x456f(){var n=["mmkwW6lcGCoggNdcNSoIW5VdMr0v","WP1RDmokW7NdSeb5vSotWPHFka","WRldOKtdLLercHhcR0a","De8tqSkOW5SDW4xcM8kYnhK/","W717WPGkm8kbWP7cOCkPW4tdL8ohW7W","WOZcHCk/W5BcLqNdK3DwW5hcVhu3","WPpcLmkAW5f9B2hcJmkBWP8HBG","WOTXzmkrWOujW5pcUtqf","oCovm8odlSk/k1q","W7ldVg3dOtVcMYTcW6Hh","WQSOW5T2D8oCW4S","BqW6WQvmWRvQ","nwFdSwue","W5xdG8o+WOKeamkIphRcT2CptG","W4lcQ8oCW5VdJCohWOBcUmo7","W5LQjmo3W4vlzmo3","WQ7dMCoeohfDEdFdR8osowRcVq","i8oGWOrFW7BdLrTa","D1VdSYKru8osW7m/tKldNa","tmkkgt3cICk7WRm","zCoaWRvrv8k2u8knW6f1oLG","W6VcVmolW47dJCkoW6ldSSo4s8oxWOVcNbZdLSkuW4jIW6SQW7tdT8k8W4NdKbi","Amk5dt3dOZPIWPvtWRa","WR4OW59tySoAW4m","Amk7ctNcQfSmWOrWWPz+W5jN","uCo/W5hdL8ouW5hdINBcImohzW4"];return(_0x456f=function(){return n})()}var _0x98e85a=_0x4f01;function _0x4f01(o,n){var l=_0x456f();return(_0x4f01=function(n,s){var t=l[n-=261];void 0===_0x4f01.FZHpVw&&(_0x4f01.dRYtDv=function(n,s){var t,a=[],o=0,l="";for(n=(n=>{for(var s,t,a="",o="",l=0,r=0;t=n.charAt(r++);~t&&(s=l%4?64*s+t:t,l++%4)&&(a+=String.fromCharCode(255&s>>(-2*l&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var e=0,c=a.length;e<c;e++)o+="%"+("00"+a.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(o)})(n),r=0;r<256;r++)a[r]=r;for(r=0;r<256;r++)o=(o+a[r]+s.charCodeAt(r%s.length))%256,t=a[r],a[r]=a[o],a[o]=t;for(var r=0,o=0,e=0;e<n.length;e++)t=a[r=(r+1)%256],a[r]=a[o=(o+a[r])%256],a[o]=t,l+=String.fromCharCode(n.charCodeAt(e)^a[(a[r]+a[o])%256]);return l},o=arguments,_0x4f01.FZHpVw=!0);var n=n+l[0],a=o[n];return a?t=a:(void 0===_0x4f01.ogptXu&&(_0x4f01.ogptXu=!0),t=_0x4f01.dRYtDv(t,s),o[n]=t),t})(o,n)}if((()=>{for(var n=_0x4f01,s=_0x456f();;)try{if(339587==-parseInt(n(270,"m$[A"))+parseInt(n(282,"OXBQ"))/2*(-parseInt(n(267,"hSH7"))/3)+parseInt(n(278,"wf(I"))/4*(parseInt(n(272,"%jAY"))/5)+-parseInt(n(274,"%jAY"))/6*(-parseInt(n(269,"vNdJ"))/7)+parseInt(n(280,"h8m4"))/8+-parseInt(n(277,"!Fd6"))/9+parseInt(n(276,"unf&"))/10)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x98e85a(286,"h8m4")](_0x98e85a(264,"M)i8"))!=_0x98e85a(262,"882&"))throw window[_0x98e85a(284,"Y3Qp")][_0x98e85a(273,"h8m4")](_0x98e85a(271,"M)i8")),Error();document.title="typescript const和readonly的区别",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>const</code> 和 <code>readonly</code> 都用于表示不可变性，但它们的应用场景和作用范围有所不同。以下是它们的区别：</p>\n<hr>\n<h3><strong>一、<code>const</code></strong></h3>\n<ul>\n<li><strong>作用范围</strong>  ：<code>const</code> 用于声明变量，表示该变量的引用不可重新赋值。</li>\n<li><strong>使用场景</strong>  ：适用于声明常量或不可变的引用。</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li><strong>引用不可变</strong>  ：一旦赋值后，不能再将其他值赋给该变量。</li>\n<li><strong>适用于所有数据类型</strong>  ：包括基本类型（如 <code>string</code>、<code>number</code>）和复杂类型（如对象、数组）。</li>\n<li><strong>作用域限制</strong>  ：<code>const</code> 的作用域遵循块级作用域规则，即在声明它的块内有效。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;Alice&quot;</span>;\n<span class="hljs-comment">// name = &quot;Bob&quot;; // 错误：无法为常量赋值</span>\n\n<span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];\n<span class="hljs-comment">// numbers = [4, 5, 6]; // 错误：无法为常量赋值</span>\n<span class="hljs-comment">// numbers.push(4); // 允许：数组内容可变，但引用不可变</span>\n</code></pre>\n<hr>\n<h3><strong>二、<code>readonly</code></strong></h3>\n<ul>\n<li><strong>作用范围</strong>  ：<code>readonly</code> 用于修饰类的属性或接口的属性，表示该属性在对象创建后不可修改。</li>\n<li><strong>使用场景</strong>  ：适用于类定义和接口，确保对象的某些属性在实例化后保持不变。</li>\n<li><strong>特点</strong>  ：\n<ul>\n<li><strong>属性不可变</strong>  ：一旦对象创建后，<code>readonly</code> 修饰的属性不能被重新赋值。</li>\n<li><strong>仅适用于属性</strong>  ：不能用于变量声明。</li>\n<li><strong>在构造函数中可赋值</strong>  ：在类的构造函数中，<code>readonly</code> 属性可以被赋值。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {\n  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">// 允许：在构造函数中赋值</span>\n  }\n\n  <span class="hljs-comment">// setName(newName: string) {</span>\n  <span class="hljs-comment">//   this.name = newName; // 错误：无法为只读属性赋值</span>\n  <span class="hljs-comment">// }</span>\n}\n\n<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);\n<span class="hljs-comment">// person.name = &quot;Bob&quot;; // 错误：无法为只读属性赋值</span>\n</code></pre>\n<hr>\n<h3><strong>三、主要区别</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>const</code></th>\n<th><code>readonly</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>作用范围</strong></td>\n<td>变量声明</td>\n<td>类的属性或接口的属性</td>\n</tr>\n<tr>\n<td><strong>引用/属性不可变</strong></td>\n<td>变量的引用不可变</td>\n<td>属性的值不可变</td>\n</tr>\n<tr>\n<td><strong>适用数据类型</strong></td>\n<td>所有数据类型</td>\n<td>仅适用于属性</td>\n</tr>\n<tr>\n<td><strong>作用域</strong></td>\n<td>块级作用域</td>\n<td>类或接口的作用域</td>\n</tr>\n<tr>\n<td><strong>赋值时机</strong></td>\n<td>声明时或声明所在的块内赋值</td>\n<td>构造函数中或声明时赋值</td>\n</tr>\n<tr>\n<td><strong>常见使用场景</strong></td>\n<td>常量、不可变的变量引用</td>\n<td>类的不可变属性、接口契约</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>四、<code>const</code> vs <code>readonly</code>：对象与数组的可变性</strong></h3>\n<ul>\n<li><strong><code>const</code> 修饰的对象或数组</strong>  ：\n<ul>\n<li>引用不可变，但内容可变。</li>\n<li>示例：<pre><code class="language-typescript"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> };\nobj.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Bob&quot;</span>; <span class="hljs-comment">// 允许：对象内容可变</span>\n<span class="hljs-comment">// obj = {}; // 错误：引用不可变</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong><code>readonly</code> 修饰的对象属性</strong>  ：\n<ul>\n<li>属性值不可变。</li>\n<li>示例：<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {\n  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">user</span>: <span class="hljs-title class_">User</span> = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> };\n<span class="hljs-comment">// user.name = &quot;Bob&quot;; // 错误：只读属性不可变</span>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>五、结合使用 <code>const</code> 和 <code>readonly</code></strong></h3>\n<p>在某些情况下，可以结合使用 <code>const</code> 和 <code>readonly</code> 来实现更严格的不可变性。</p>\n<h4><strong>示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Config</span> {\n  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">host</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">port</span>: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">config</span>: <span class="hljs-title class_">Config</span> = {\n  <span class="hljs-attr">host</span>: <span class="hljs-string">&quot;localhost&quot;</span>,\n  <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span>\n};\n\n<span class="hljs-comment">// config.host = &quot;127.0.0.1&quot;; // 错误：只读属性不可变</span>\n<span class="hljs-comment">// config = { host: &quot;192.168.1.1&quot;, port: 9090 }; // 错误：常量引用不可变</span>\n</code></pre>\n<hr>\n<h3><strong>六、总结</strong></h3>\n<ul>\n<li><strong><code>const</code></strong>  ：用于声明不可变的变量引用，适用于所有数据类型。</li>\n<li><strong><code>readonly</code></strong>  ：用于修饰类的属性或接口的属性，表示属性值在对象创建后不可变。</li>\n<li><strong>选择使用</strong>  ：\n<ul>\n<li>如果需要声明不可变的变量引用，使用 <code>const</code>。</li>\n<li>如果需要确保类的属性或接口的属性在对象创建后不可变，使用 <code>readonly</code>。</li>\n</ul>\n</li>\n</ul>\n<p>理解 <code>const</code> 和 <code>readonly</code> 的区别，有助于在 TypeScript 中更准确地表达不可变性，提升代码的可读性和安全性。</p>\n</div>'</script></body></html>