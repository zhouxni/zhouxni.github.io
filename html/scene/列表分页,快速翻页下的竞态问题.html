<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2cf2f5=_0x13cd;function _0x13cd(t,s){var p=_0x1b5d();return(_0x13cd=function(s,n){var a=p[s-=333];void 0===_0x13cd.jyoTvP&&(_0x13cd.IPfetN=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,r=0;a=s.charAt(r++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=l.length;o<c;o++)t+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(t)})(s),r=0;r<256;r++)l[r]=r;for(r=0;r<256;r++)t=(t+l[r]+n.charCodeAt(r%n.length))%256,a=l[r],l[r]=l[t],l[t]=a;for(var r=0,t=0,o=0;o<s.length;o++)a=l[r=(r+1)%256],l[r]=l[t=(t+l[r])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(o)^l[(l[r]+l[t])%256]);return p},t=arguments,_0x13cd.jyoTvP=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x13cd.QDcfiQ&&(_0x13cd.QDcfiQ=!0),a=_0x13cd.IPfetN(a,n),t[s]=a),a})(t,s)}function _0x1b5d(){var s=["tmoSFCk/W6NdJCklxa","W4dcVmk/WRFdGv3cLx49lSoKW4hdJq","jmkobSojkmkwWRtcOG","WPuurs4wW5bodConW41UyLu","BSo+kmkwW7OOW5u","W5rLW4mwWONdGCk3","lvhdVCo3dJpdSCodW6GFWQjEWRO","W5CyWQzlW7BdUCkxW4qYECkD","CrBdMMvDbColW6lcH8oYWQalW7G","lvtdUCo2bhpcKmo7W4KjWP8","W5xcLWjSW60","W7ldUSkRrNNcHsy","CbddMwfwa8opW6pcTmouWRu3W48","DXBdMgvsamkUW5JcI8oEWO8j","u8kfmmo1W4PiWRhdTSoogSoG","W5xdNexcG0JcJNu","WPdcQ8kNvSk8mmk3W7Db","E8o+lmkZW68UW50","jqZdVCkcWOi6zSka","jmk+l1lcQSoqW6xcP8oXWQxdL8oQuCk8W4xcMSkxh8odhSkJWO/cL8keyqa","umo4vCkOWRvWWPe","nSkcW5SCymkcdConB8krmNpcNW","W5uBWQvdW7JdMCk+W6ivs8k3","tSotrSk/W6xdOSkOa3/cRSooWQRdVa"];return(_0x1b5d=function(){return s})()}if((()=>{for(var s=_0x13cd,n=_0x1b5d();;)try{if(263948==-parseInt(s(335,"vFO!"))+-parseInt(s(334,"VkxR"))/2+parseInt(s(354,"3lA("))/3*(-parseInt(s(347,"XOgn"))/4)+parseInt(s(346,"K3tQ"))/5*(parseInt(s(350,"a7G6"))/6)+-parseInt(s(344,"[tTV"))/7*(-parseInt(s(356,"SNcM"))/8)+-parseInt(s(333,"VkxR"))/9+parseInt(s(351,"3lA("))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x2cf2f5(338,"$c^o")](_0x2cf2f5(337,")4Cw"))!=_0x2cf2f5(355,"J61("))throw window[_0x2cf2f5(345,"zwBE")][_0x2cf2f5(349,"$c^o")](_0x2cf2f5(340,"#IvA")),Error();document.title="列表分页,快速翻页下的竞态问题",document.getElementById("article").innerHTML='<div><p>在列表分页和快速翻页的场景下，竞态问题（Race Condition）是一个常见的挑战。竞态问题通常发生在多个异步操作同时发起或完成时，导致数据不一致或操作冲突。以下是关于列表分页快速翻页下竞态问题的详细分析：</p>\n<hr>\n<h3><strong>一、竞态问题的表现</strong></h3>\n<ol>\n<li><strong>数据覆盖</strong>  ：\n<ul>\n<li>快速翻页时，后一个分页请求返回的数据可能覆盖了前一个请求的数据，导致用户看到的是错误或不一致的数据。</li>\n</ul>\n</li>\n<li><strong>重复渲染</strong>  ：\n<ul>\n<li>由于多个请求同时触发，可能导致页面多次渲染，造成性能浪费和用户体验下降。</li>\n</ul>\n</li>\n<li><strong>请求堆积</strong>  ：\n<ul>\n<li>快速翻页时，可能会发起大量请求，导致服务器压力增大，甚至可能触发限流或熔断机制。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>二、竞态问题的原因</strong></h3>\n<ol>\n<li><strong>异步请求并发</strong>  ：\n<ul>\n<li>翻页操作通常涉及异步请求，快速翻页时，多个请求可能同时发起，导致竞态问题。</li>\n</ul>\n</li>\n<li><strong>请求与响应顺序不一致</strong>  ：\n<ul>\n<li>由于网络延迟或服务器处理时间不同，请求的响应顺序可能与发起顺序不一致。</li>\n</ul>\n</li>\n<li><strong>缺乏请求管理</strong>  ：\n<ul>\n<li>没有对请求进行有效的管理，如取消未完成的请求、限制并发请求数量等。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>三、解决方案</strong></h3>\n<h4><strong>1. 请求取消机制</strong></h4>\n<ul>\n<li><strong>原理</strong>  ：\n<ul>\n<li>在发起新请求时，取消未完成的旧请求，确保只有最新的请求能够完成并更新数据。</li>\n</ul>\n</li>\n<li><strong>实现方式</strong>  ：\n<ul>\n<li>使用 <code>AbortController</code>（在浏览器环境中）或类似的机制来取消请求。</li>\n<li>在请求库（如 Axios）中，支持取消令牌（Cancel Token）或信号（Signal）。</li>\n</ul>\n</li>\n<li><strong>示例代码</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">let</span> abortController = <span class="hljs-literal">null</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">page</span>) {\n  <span class="hljs-comment">// 取消未完成的请求</span>\n  <span class="hljs-keyword">if</span> (abortController) {\n    abortController.<span class="hljs-title function_">abort</span>();\n  }\n\n  <span class="hljs-comment">// 创建新的 AbortController</span>\n  abortController = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();\n  <span class="hljs-keyword">const</span> signal = abortController.<span class="hljs-property">signal</span>;\n\n  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/data?page=<span class="hljs-subst">${page}</span>`</span>, { signal })\n    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())\n    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n      <span class="hljs-comment">// 更新页面数据</span>\n      <span class="hljs-title function_">updatePageData</span>(data);\n    })\n    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {\n      <span class="hljs-keyword">if</span> (error.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;AbortError&#x27;</span>) {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求已取消&#x27;</span>);\n      } <span class="hljs-keyword">else</span> {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求失败&#x27;</span>, error);\n      }\n    });\n}\n</code></pre>\n</li>\n</ul>\n<h4><strong>2. 防抖（Debounce）与节流（Throttle）</strong></h4>\n<ul>\n<li><strong>防抖</strong>  ：\n<ul>\n<li>在用户停止翻页操作一段时间后，再发起请求，避免频繁请求。</li>\n<li>适用于用户翻页操作较为频繁，但只需要获取最终翻页结果的场景。</li>\n</ul>\n</li>\n<li><strong>节流</strong>  ：\n<ul>\n<li>限制在一定时间内只允许发起一次请求，避免请求堆积。</li>\n<li>适用于需要实时响应翻页操作，但又要控制请求频率的场景。</li>\n</ul>\n</li>\n<li><strong>示例代码（防抖）</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">let</span> debounceTimer = <span class="hljs-literal">null</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">handlePageChange</span>(<span class="hljs-params">page</span>) {\n  <span class="hljs-built_in">clearTimeout</span>(debounceTimer);\n  debounceTimer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-title function_">fetchData</span>(page);\n  }, <span class="hljs-number">300</span>); <span class="hljs-comment">// 延迟300毫秒后发起请求</span>\n}\n</code></pre>\n</li>\n</ul>\n<h4><strong>3. 请求队列管理</strong></h4>\n<ul>\n<li><strong>原理</strong>  ：\n<ul>\n<li>维护一个请求队列，确保请求按顺序执行，避免竞态问题。</li>\n<li>后发起的请求会覆盖先发起的请求，只有最新的请求会被执行。</li>\n</ul>\n</li>\n<li><strong>实现方式</strong>  ：\n<ul>\n<li>使用一个变量来跟踪当前正在处理的请求，忽略过时的请求。</li>\n</ul>\n</li>\n<li><strong>示例代码</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">let</span> currentRequest = <span class="hljs-literal">null</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">page</span>) {\n  <span class="hljs-comment">// 如果已有请求正在进行，则取消（或忽略）</span>\n  <span class="hljs-keyword">if</span> (currentRequest) {\n    currentRequest.<span class="hljs-title function_">abort</span>(); <span class="hljs-comment">// 假设请求支持取消</span>\n  }\n\n  <span class="hljs-comment">// 创建新的请求</span>\n  <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();\n  <span class="hljs-keyword">const</span> signal = controller.<span class="hljs-property">signal</span>;\n  currentRequest = { controller, <span class="hljs-attr">request</span>: <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/data?page=<span class="hljs-subst">${page}</span>`</span>, { signal }) };\n\n  currentRequest.<span class="hljs-property">request</span>\n    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())\n    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n      <span class="hljs-comment">// 更新页面数据</span>\n      <span class="hljs-title function_">updatePageData</span>(data);\n      <span class="hljs-comment">// 请求完成后，重置 currentRequest</span>\n      currentRequest = <span class="hljs-literal">null</span>;\n    })\n    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {\n      <span class="hljs-keyword">if</span> (error.<span class="hljs-property">name</span> !== <span class="hljs-string">&#x27;AbortError&#x27;</span>) {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求失败&#x27;</span>, error);\n      }\n      <span class="hljs-comment">// 请求完成后，重置 currentRequest</span>\n      currentRequest = <span class="hljs-literal">null</span>;\n    });\n}\n</code></pre>\n</li>\n</ul>\n<h4><strong>4. 乐观更新与回滚</strong></h4>\n<ul>\n<li><strong>原理</strong>  ：\n<ul>\n<li>在发起请求时，立即更新页面为预期的状态（乐观更新）。</li>\n<li>如果请求失败或返回的数据与预期不符，则回滚到之前的状态。</li>\n</ul>\n</li>\n<li><strong>实现方式</strong>  ：\n<ul>\n<li>维护一个状态历史记录，用于在需要时回滚。</li>\n</ul>\n</li>\n<li><strong>示例代码</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">let</span> previousData = <span class="hljs-literal">null</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">page</span>) {\n  <span class="hljs-comment">// 乐观更新：立即更新页面为加载状态</span>\n  <span class="hljs-title function_">updatePageData</span>({ <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span> });\n\n  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/data?page=<span class="hljs-subst">${page}</span>`</span>)\n    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())\n    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n      <span class="hljs-comment">// 保存当前数据，用于回滚</span>\n      previousData = { ...data }; <span class="hljs-comment">// 假设数据是对象</span>\n      <span class="hljs-comment">// 更新页面数据</span>\n      <span class="hljs-title function_">updatePageData</span>(data);\n    })\n    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求失败&#x27;</span>, error);\n      <span class="hljs-comment">// 回滚到之前的状态</span>\n      <span class="hljs-keyword">if</span> (previousData) {\n        <span class="hljs-title function_">updatePageData</span>(previousData);\n      } <span class="hljs-keyword">else</span> {\n        <span class="hljs-title function_">updatePageData</span>({ <span class="hljs-attr">error</span>: <span class="hljs-literal">true</span> });\n      }\n    });\n}\n</code></pre>\n</li>\n</ul>\n<h4><strong>5. 限制并发请求数量</strong></h4>\n<ul>\n<li><strong>原理</strong>  ：\n<ul>\n<li>控制同时进行的请求数量，避免服务器过载。</li>\n<li>可以使用请求队列或信号量机制来实现。</li>\n</ul>\n</li>\n<li><strong>实现方式</strong>  ：\n<ul>\n<li>使用一个计数器或队列来跟踪当前正在进行的请求数量。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>四、最佳实践</strong></h3>\n<ol>\n<li><strong>结合多种策略</strong>  ：\n<ul>\n<li>根据具体需求，结合请求取消、防抖/节流、请求队列管理等多种策略，以达到最佳效果。</li>\n</ul>\n</li>\n<li><strong>优化服务器响应</strong>  ：\n<ul>\n<li>在服务器端，优化查询性能，减少响应时间，降低竞态问题的影响。</li>\n</ul>\n</li>\n<li><strong>用户反馈</strong>  ：\n<ul>\n<li>在请求进行中，提供加载指示器或进度条，提升用户体验。</li>\n</ul>\n</li>\n<li><strong>错误处理</strong>  ：\n<ul>\n<li>对请求失败的情况进行妥善处理，如重试机制、错误提示等。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>五、总结</strong></h3>\n<ul>\n<li><strong>竞态问题</strong>  在列表分页和快速翻页场景下是一个常见的问题，可能导致数据不一致和性能浪费。</li>\n<li><strong>解决方案</strong>  包括请求取消机制、防抖/节流、请求队列管理、乐观更新与回滚、限制并发请求数量等。</li>\n<li><strong>最佳实践</strong>  是结合多种策略，根据具体需求进行优化，同时提升服务器性能和用户体验。</li>\n</ul>\n<p>通过合理的请求管理和优化策略，可以有效避免竞态问题，提升列表分页和快速翻页场景下的性能和稳定性。</p>\n</div>'</script></body></html>