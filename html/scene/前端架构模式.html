<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5505b0=_0x29a0;function _0x3707(){var n=["F252smkhW5yhBSknwW","W5HMddjuqWtcJq","W5hdQ8k3WR3dQgpcRg/dPSoqCLm","W4vNx8oVmmoyW4nljsxcUSo2e8kvW6BcMbpcO8odW75AW47cKWtdNh8","W4TReCoVWPxcQXRdStzPgq","WOVcJbi9rq3cPSos","EhP/W6xdRtVdOW","W7/dI0FcLSkJa8k9WOn3W4ldJCkIgG","iSoPdtrxWO/cRa","kY1MW5JdTJ/dPIa","WPFcQ8o1W7BcOq","d8oEWPfIsCktWPGMWPhcTq","W5TUbZFcKuxdR8om","W4PcC8keluVdPa","zmkYFxeWyCkWW4Gbf8ocW4VcRq","bfpdKarnW5hdUeRcPCorW7iCWOq","CSoEqCkfDqddNuBdIf1QWPlcTCkl","dmoFWPPGo8oeW4H1WPJcLHeBzSok","W77dNrWSwr/cHCo8hq","W6/cPfGRDrL5WO3dUmkIEaVcNW","W6BcG8kVWQD3cmoPW7CIeSkwlaW","vCk6WPu9W6/cNf7cVCkMxhG","W6ylA2RcM8kpAqRcHmk8vHq","WQeJW5THW5VcLmoHW6CGWOvlWRK","W7SMA1jZWQ/dO0a","f8oInfZcK8ogdq","FYSocCkqW78X","W5lcGCkWW53dUmksW6hcMexdH8kZW48","qCk9lg0HgSkg","eY1xW7aiW4VdReXplqXItG"];return(_0x3707=function(){return n})()}function _0x29a0(l,n){var s=_0x3707();return(_0x29a0=function(n,t){var r=s[n-=364];void 0===_0x29a0.MPRXbD&&(_0x29a0.XxLznp=function(n,t){var r,o=[],l=0,s="";for(n=(n=>{for(var t,r,o="",l="",s=0,i=0;r=n.charAt(i++);~r&&(t=s%4?64*t+r:r,s++%4)&&(o+=String.fromCharCode(255&t>>(-2*s&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var g=0,e=o.length;g<e;g++)l+="%"+("00"+o.charCodeAt(g).toString(16)).slice(-2);return decodeURIComponent(l)})(n),i=0;i<256;i++)o[i]=i;for(i=0;i<256;i++)l=(l+o[i]+t.charCodeAt(i%t.length))%256,r=o[i],o[i]=o[l],o[l]=r;for(var i=0,l=0,g=0;g<n.length;g++)r=o[i=(i+1)%256],o[i]=o[l=(l+o[i])%256],o[l]=r,s+=String.fromCharCode(n.charCodeAt(g)^o[(o[i]+o[l])%256]);return s},l=arguments,_0x29a0.MPRXbD=!0);var n=n+s[0],o=l[n];return o?r=o:(void 0===_0x29a0.XTSOOG&&(_0x29a0.XTSOOG=!0),r=_0x29a0.XxLznp(r,t),l[n]=r),r})(l,n)}if((()=>{for(var n=_0x29a0,t=_0x3707();;)try{if(759868==-parseInt(n(365,"Hu#S"))*(-parseInt(n(371,"5PSf"))/2)+-parseInt(n(393,"bS9)"))/3*(-parseInt(n(392,"mmn&"))/4)+parseInt(n(368,"(wg]"))/5+parseInt(n(384,"6j$o"))/6*(-parseInt(n(378,"i4Qd"))/7)+-parseInt(n(364,"rAKK"))/8*(parseInt(n(385,"xTct"))/9)+parseInt(n(383,"Nl0e"))/10+parseInt(n(380,"OBiI"))/11*(parseInt(n(390,"NX&j"))/12))break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x5505b0(375,"i4Qd")](_0x5505b0(387,"toIc"))!=_0x5505b0(379,"5PSf"))throw window[_0x5505b0(381,"0A]V")][_0x5505b0(382,"*EQ*")](_0x5505b0(372,"JgK8")),Error();document.title="前端架构模式",document.getElementById("article").innerHTML="<div><p>前端架构模式随着 Web 应用的复杂度提升而不断演进，以下是主流的 <strong>前端架构模式</strong>   及其核心特点、适用场景和代表框架：</p>\n<hr>\n<h3><strong>1. MVC（Model-View-Controller）</strong></h3>\n<ul>\n<li><strong>核心思想</strong>   ：<br>\n将应用分为三层：\n<ul>\n<li><strong>Model</strong>   ：数据逻辑</li>\n<li><strong>View</strong>   ：UI 展示</li>\n<li><strong>Controller</strong>   ：协调 Model 和 View</li>\n</ul>\n</li>\n<li><strong>优点</strong>   ：职责分离，易于维护。</li>\n<li><strong>缺点</strong>   ：View 和 Controller 可能过度耦合。</li>\n<li><strong>适用场景</strong>   ：传统服务端渲染应用。</li>\n<li><strong>代表框架</strong>   ：Backbone.js、早期 AngularJS。</li>\n</ul>\n<hr>\n<h3><strong>2. MVVM（Model-View-ViewModel）</strong></h3>\n<ul>\n<li><strong>核心思想</strong>   ：\n<ul>\n<li><strong>ViewModel</strong>   ：双向绑定 View 和 Model（自动同步数据）。</li>\n</ul>\n</li>\n<li><strong>优点</strong>   ：减少手动 DOM 操作，开发效率高。</li>\n<li><strong>缺点</strong>   ：大项目可能因双向绑定导致调试困难。</li>\n<li><strong>适用场景</strong>   ：数据驱动的动态应用。</li>\n<li><strong>代表框架</strong>   ：Vue.js、Knockout.js、WPF。</li>\n</ul>\n<hr>\n<h3><strong>3. Flux / 单向数据流</strong></h3>\n<ul>\n<li><strong>核心思想</strong>   ：<br>\n数据单向流动：<br>\n<strong>View → Action → Dispatcher → Store → View</strong></li>\n<li><strong>优点</strong>   ：数据变化可预测，适合复杂状态管理。</li>\n<li><strong>缺点</strong>   ：需要编写较多模板代码。</li>\n<li><strong>适用场景</strong>   ：大型应用的状态管理。</li>\n<li><strong>代表实现</strong>   ：Redux、Vuex、MobX（变种）。</li>\n</ul>\n<hr>\n<h3><strong>4. 组件化架构（Component-Based Architecture）</strong></h3>\n<ul>\n<li><strong>核心思想</strong>   ：<br>\n将 UI 拆分为独立组件（高内聚、低耦合）。</li>\n<li><strong>优点</strong>   ：复用性强，便于协作。</li>\n<li><strong>缺点</strong>   ：需规范组件通信机制。</li>\n<li><strong>适用场景</strong>   ：现代前端框架的默认模式。</li>\n<li><strong>代表框架</strong>   ：React、Vue、Svelte。</li>\n</ul>\n<hr>\n<h3><strong>5. 微前端（Micro Frontends）</strong></h3>\n<ul>\n<li><strong>核心思想</strong>   ：<br>\n将单体应用拆分为多个独立子应用（独立开发、部署）。</li>\n<li><strong>优点</strong>   ：技术栈无关，增量升级。</li>\n<li><strong>缺点</strong>   ：性能开销，共享状态复杂。</li>\n<li><strong>适用场景</strong>   ：大型企业级应用。</li>\n<li><strong>代表方案</strong>   ：Module Federation（Webpack）、Single-SPA、Qiankun。</li>\n</ul>\n<hr>\n<h3><strong>6. 原子设计（Atomic Design）</strong></h3>\n<ul>\n<li><strong>核心思想</strong>   ：<br>\n自底向上构建 UI：<strong>原子（Button）→ 分子（Form）→ 组织（Header）→ 模板 → 页面</strong>   。</li>\n<li><strong>优点</strong>   ：设计系统化，一致性高。</li>\n<li><strong>缺点</strong>   ：前期设计成本高。</li>\n<li><strong>适用场景</strong>   ：需要统一设计规范的项目。</li>\n<li><strong>代表工具</strong>   ：Storybook、Figma。</li>\n</ul>\n<hr>\n<h3><strong>7. 无服务端架构（Serverless + JAMStack）</strong></h3>\n<ul>\n<li><strong>核心思想</strong>   ：<br>\n前端直接调用云函数（如 API 网关 + CDN）。</li>\n<li><strong>优点</strong>   ：无需管理服务器，扩展性强。</li>\n<li><strong>缺点</strong>   ：冷启动延迟， vendor 锁定。</li>\n<li><strong>适用场景</strong>   ：静态站点、轻量级 API。</li>\n<li><strong>代表技术</strong>   ：Next.js（SSG）、Gatsby、Vercel。</li>\n</ul>\n<hr>\n<h3><strong>8. 分层架构（Layered Architecture）</strong></h3>\n<ul>\n<li><strong>核心思想</strong>   ：<br>\n按功能分层（如表现层、业务层、数据层）。</li>\n<li><strong>优点</strong>   ：逻辑清晰，便于测试。</li>\n<li><strong>缺点</strong>   ：层间依赖可能冗余。</li>\n<li><strong>适用场景</strong>   ：企业级中后台系统。</li>\n<li><strong>代表实践</strong>   ：Clean Architecture（领域驱动设计）。</li>\n</ul>\n<hr>\n<h3><strong>9. 响应式架构（Reactive Architecture）</strong></h3>\n<ul>\n<li><strong>核心思想</strong>   ：<br>\n数据流驱动 UI（基于观察者模式）。</li>\n<li><strong>优点</strong>   ：实时响应，高性能。</li>\n<li><strong>缺点</strong>   ：学习曲线陡峭。</li>\n<li><strong>适用场景</strong>   ：实时数据应用（如股票行情）。</li>\n<li><strong>代表库</strong>   ：RxJS、Cycle.js。</li>\n</ul>\n<hr>\n<h3><strong>10. Islands Architecture（岛屿架构）</strong></h3>\n<ul>\n<li><strong>核心思想</strong>   ：<br>\n静态页面中嵌入交互性“岛屿”（部分 hydrate）。</li>\n<li><strong>优点</strong>   ：极致性能，渐进式增强。</li>\n<li><strong>缺点</strong>   ：需框架支持。</li>\n<li><strong>适用场景</strong>   ：内容为主的网站。</li>\n<li><strong>代表框架</strong>   ：Astro、Marko。</li>\n</ul>\n<hr>\n<h3><strong>对比总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>核心目标</th>\n<th>状态管理</th>\n<th>典型场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>MVC/MVVM</td>\n<td>职责分离</td>\n<td>双向/单向</td>\n<td>传统 SPA</td>\n</tr>\n<tr>\n<td>Flux/Redux</td>\n<td>可预测状态</td>\n<td>集中式</td>\n<td>复杂状态应用</td>\n</tr>\n<tr>\n<td>组件化</td>\n<td>复用与组合</td>\n<td>分散式</td>\n<td>现代 Web 应用</td>\n</tr>\n<tr>\n<td>微前端</td>\n<td>解耦团队协作</td>\n<td>混合式</td>\n<td>大型企业应用</td>\n</tr>\n<tr>\n<td>Islands</td>\n<td>性能优先</td>\n<td>按需加载</td>\n<td>内容型网站</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>选型建议</strong></h3>\n<ol>\n<li><strong>小型项目</strong>   ：组件化 + 轻量状态管理（如 React + Zustand）。</li>\n<li><strong>中大型项目</strong>   ：微前端 + Redux/MobX。</li>\n<li><strong>内容型网站</strong>   ：Islands 架构（Astro）。</li>\n<li><strong>实时数据应用</strong>   ：响应式架构（RxJS）。</li>\n</ol>\n<p>根据团队技术栈、项目规模和性能需求灵活选择，现代框架（如 Next.js、Remix）已融合多种模式。</p>\n</div>"</script></body></html>