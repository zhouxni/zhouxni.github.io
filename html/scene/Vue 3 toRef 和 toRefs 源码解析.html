<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x423fa4=_0xc090;if((()=>{for(var s=_0xc090,n=_0x1630();;)try{if(443824==+parseInt(s(508,"d26z"))+parseInt(s(496,"nzi3"))/2*(-parseInt(s(507,"r7hB"))/3)+parseInt(s(501,"8t&P"))/4+parseInt(s(497,"A(I*"))/5*(-parseInt(s(498,"SA!6"))/6)+parseInt(s(486,"k]1^"))/7+parseInt(s(494,"bPQW"))/8*(parseInt(s(489,"ejJi"))/9)+parseInt(s(506,"Egcm"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x423fa4(502,"Q12T")](_0x423fa4(500,"Y%%6"))!=_0x423fa4(495,"xZ(#"))throw window[_0x423fa4(510,"(AqC")][_0x423fa4(499,"lf(T")](_0x423fa4(488,"b%XI")),Error();function _0xc090(l,s){var t=_0x1630();return(_0xc090=function(s,n){var a=t[s-=485];void 0===_0xc090.kXpkyA&&(_0xc090.wCvTOO=function(s,n){var a,e=[],l=0,t="";for(s=(s=>{for(var n,a,e="",l="",t=0,p=0;a=s.charAt(p++);~a&&(n=t%4?64*n+a:a,t++%4)&&(e+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=e.length;c<o;c++)l+="%"+("00"+e.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)e[p]=p;for(p=0;p<256;p++)l=(l+e[p]+n.charCodeAt(p%n.length))%256,a=e[p],e[p]=e[l],e[l]=a;for(var p=0,l=0,c=0;c<s.length;c++)a=e[p=(p+1)%256],e[p]=e[l=(l+e[p])%256],e[l]=a,t+=String.fromCharCode(s.charCodeAt(c)^e[(e[p]+e[l])%256]);return t},l=arguments,_0xc090.kXpkyA=!0);var s=s+t[0],e=l[s];return e?a=e:(void 0===_0xc090.uZKaJv&&(_0xc090.uZKaJv=!0),a=_0xc090.wCvTOO(a,n),l[s]=a),a})(l,s)}function _0x1630(){var s=["WQeNqd7cGaVcUSkmWQWPWRuG","WRtdQvqYW4a","WOxcHNFcMvhcK3HsFa","yCoPtXqtWO0QvmoJDSotWPpdHa","W57cNGCvxhRcHa","svKatmkBWOJcKW","W4XdWRJcTmonaCoagLG","W4ddU8oQW4KiW4eFAWRcQSoGDXC","DCozW498W7xcGCo+","WRCiqghdGXFdMComW6xcSG","WO8QWP3cPSo+mCovW5/dPG","rxDNW6BcQCkJg8oZWPBdVCkOWRG","W7RcGxxdQCoknmoOW4hcSmoQuJJdKa","WOimW4ldTKKSW7W5edW","W6T2g0BdKSkEW6dcImkDW7yhcW","W4qFW7PkimonWQNdT8owW7OfWQpdGq","WRKHi1ZcICopWQWU","W7K5jCoImG/cQwq9W5muW4e","WRmmq2VcNLFdOSopW77cPJtdHG","W40flKldHmk2WQxdUd1/gSoqW7i","kmolW5RcGIC9h8oqW47dJJbIW6VdRhWiW7SuvbrjWONdVCo/W6ZcTa","W4ZcJgJdNL3dUmkHWR4","W7jFWRrHWOBcQmoqeNRdJ2yAwW","WQjCjLNdH1tcUW","hs9oCgGDm8oQW71mWP4j","WOCpWQhdICoxmHRdQa"];return(_0x1630=function(){return s})()}document.title="Vue 3 toRef 和 toRefs 源码解析",document.getElementById("article").innerHTML='<div><p><code>toRef</code> 和 <code>toRefs</code> 是 Vue 3 组合式 API 中的重要工具函数，用于从响应式对象中提取属性并保持响应性连接。让我们深入理解它们的实现原理。</p>\n<h2><code>toRef</code> 源码解析</h2>\n<h3>核心实现</h3>\n<p><code>toRef</code> 的源码位于 <code>vue-next/packages/reactivity/src/ref.ts</code> 中：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> toRef&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>, K <span class="hljs-keyword">extends</span> keyof T&gt;(\n  <span class="hljs-attr">object</span>: T,\n  <span class="hljs-attr">key</span>: K,\n): <span class="hljs-title class_">ToRef</span>&lt;T[K]&gt; {\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">isRef</span>(<span class="hljs-built_in">object</span>[key])\n    ? <span class="hljs-built_in">object</span>[key]\n    : (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectRefImpl</span>(<span class="hljs-built_in">object</span>, key) <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>);\n}\n</code></pre>\n<h3>ObjectRefImpl 实现</h3>\n<p><code>ObjectRefImpl</code> 是 <code>toRef</code> 的核心实现类：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectRefImpl</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>, K <span class="hljs-keyword">extends</span> keyof T&gt; {\n  <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> __v_isRef = <span class="hljs-literal">true</span>;\n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">_object</span>: T,\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">_key</span>: K,\n  </span>) {}\n\n  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_object</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">_key</span>];\n  }\n\n  <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">newVal</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_object</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">_key</span>] = newVal;\n  }\n}\n</code></pre>\n<h3>关键点</h3>\n<ol>\n<li><strong>响应性保持</strong>   ：<code>toRef</code> 创建的 ref 会保持与源对象属性的响应性连接</li>\n<li><strong>非复制</strong>   ：不会创建属性的副本，而是建立访问器桥接</li>\n<li><strong>Ref 检查</strong>   ：如果源属性已经是 ref，则直接返回</li>\n</ol>\n<h2><code>toRefs</code> 源码解析</h2>\n<h3>核心实现</h3>\n<p><code>toRefs</code> 的源码也在同一文件中：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> toRefs&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt;(<span class="hljs-attr">object</span>: T): <span class="hljs-title class_">ToRefs</span>&lt;T&gt; {\n  <span class="hljs-keyword">if</span> (__DEV__ &amp;&amp; !<span class="hljs-title function_">isProxy</span>(<span class="hljs-built_in">object</span>)) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(\n      <span class="hljs-string">`toRefs() expects a reactive object but received a plain one.`</span>,\n    );\n  }\n\n  <span class="hljs-keyword">const</span> <span class="hljs-attr">ret</span>: <span class="hljs-built_in">any</span> = <span class="hljs-title function_">isArray</span>(<span class="hljs-built_in">object</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-built_in">object</span>.<span class="hljs-property">length</span>) : {};\n\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> <span class="hljs-built_in">object</span>) {\n    ret[key] = <span class="hljs-title function_">toRef</span>(<span class="hljs-built_in">object</span>, key);\n  }\n\n  <span class="hljs-keyword">return</span> ret;\n}\n</code></pre>\n<h3>关键点</h3>\n<ol>\n<li><strong>遍历转换</strong>   ：对对象每个属性调用 <code>toRef</code></li>\n<li><strong>数组支持</strong>   ：正确处理数组类型的响应式对象</li>\n<li><strong>开发警告</strong>   ：在开发模式下检查传入的是否为响应式对象</li>\n</ol>\n<h2>设计原理</h2>\n<h3>1. 响应式连接机制</h3>\n<p><code>toRef</code> 和 <code>toRefs</code> 创建的 ref 实际上是对原始对象属性的访问器代理：</p>\n<pre><code>原始响应式对象: { foo: reactiveValue }\n          ↑\n          | 通过 getter/setter 连接\n          ↓\ntoRef(obj, \'foo\'): { value: getter/setter }\n</code></pre>\n<h3>2. 与 <code>ref</code> 的区别</h3>\n<ul>\n<li><code>ref()</code>: 创建完全独立的响应式引用，值被包裹在 <code>.value</code> 中</li>\n<li><code>toRef()</code>: 创建与源对象属性连接的引用，不独立存储值</li>\n</ul>\n<h3>3. 解构响应式对象</h3>\n<p><code>toRefs</code> 的主要用途是解构响应式对象而不丢失响应性：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span> });\n\n<span class="hljs-comment">// 使用 toRefs 解构</span>\n<span class="hljs-keyword">const</span> { foo, bar } = <span class="hljs-title function_">toRefs</span>(state);\n<span class="hljs-comment">// 等价于</span>\n<span class="hljs-keyword">const</span> foo = <span class="hljs-title function_">toRef</span>(state, <span class="hljs-string">&quot;foo&quot;</span>);\n<span class="hljs-keyword">const</span> bar = <span class="hljs-title function_">toRef</span>(state, <span class="hljs-string">&quot;bar&quot;</span>);\n</code></pre>\n<h2>性能考虑</h2>\n<ol>\n<li><strong>轻量级代理</strong>   ：<code>ObjectRefImpl</code> 是非常轻量的包装器，几乎没有内存开销</li>\n<li><strong>惰性访问</strong>   ：只在访问 <code>.value</code> 时才读取原始对象属性</li>\n<li><strong>无重复转换</strong>   ：对已经是 ref 的属性会直接返回</li>\n</ol>\n<h2>使用场景</h2>\n<h3>1. 组合函数返回</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useFeature</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> });\n  <span class="hljs-keyword">return</span> {\n    ...<span class="hljs-title function_">toRefs</span>(state), <span class="hljs-comment">// 保持响应性</span>\n    <span class="hljs-attr">other</span>: <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>),\n  };\n}\n</code></pre>\n<h3>2. Props 转换</h3>\n<pre><code class="language-typescript"><span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>) {\n  <span class="hljs-comment">// 将 props 转换为 refs，便于使用</span>\n  <span class="hljs-keyword">const</span> { title, content } = <span class="hljs-title function_">toRefs</span>(props)\n}\n</code></pre>\n<h2>总结</h2>\n<p><code>toRef</code> 和 <code>toRefs</code> 的实现展示了 Vue 3 响应式系统的灵活性：</p>\n<ol>\n<li><code>toRef</code> 通过 <code>ObjectRefImpl</code> 建立轻量级属性访问代理</li>\n<li><code>toRefs</code> 是 <code>toRef</code> 的批量操作版本，便于对象解构</li>\n<li>两者都保持与源对象的响应性连接，而不创建独立副本</li>\n<li>设计上注重性能和开发者体验，是组合式 API 的重要基础设施</li>\n</ol>\n<p>理解这些实现原理有助于更有效地使用它们，并在需要时创建类似的自定义工具函数。</p>\n</div>'</script></body></html>