<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4803(i,n){var e=_0x11d1();return(_0x4803=function(n,r){var o=e[n-=381];void 0===_0x4803.rPgBrY&&(_0x4803.bodfta=function(n,r){var o,t=[],i=0,e="";for(n=(n=>{for(var r,o,t="",i="",e=0,l=0;o=n.charAt(l++);~o&&(r=e%4?64*r+o:o,e++%4)&&(t+=String.fromCharCode(255&r>>(-2*e&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var W=0,d=t.length;W<d;W++)i+="%"+("00"+t.charCodeAt(W).toString(16)).slice(-2);return decodeURIComponent(i)})(n),l=0;l<256;l++)t[l]=l;for(l=0;l<256;l++)i=(i+t[l]+r.charCodeAt(l%r.length))%256,o=t[l],t[l]=t[i],t[i]=o;for(var l=0,i=0,W=0;W<n.length;W++)o=t[l=(l+1)%256],t[l]=t[i=(i+t[l])%256],t[i]=o,e+=String.fromCharCode(n.charCodeAt(W)^t[(t[l]+t[i])%256]);return e},i=arguments,_0x4803.rPgBrY=!0);var n=n+e[0],t=i[n];return t?o=t:(void 0===_0x4803.TigUOB&&(_0x4803.TigUOB=!0),o=_0x4803.bodfta(o,r),i[n]=o),o})(i,n)}var _0x1fad1b=_0x4803;if((()=>{for(var n=_0x4803,r=_0x11d1();;)try{if(345266==+parseInt(n(408,"oVqf"))*(parseInt(n(386,"lwpU"))/2)+parseInt(n(389,"km]1"))/3+parseInt(n(404,"W@^8"))/4*(parseInt(n(385,"ZViz"))/5)+parseInt(n(383,"CgVL"))/6*(-parseInt(n(387,"ZViz"))/7)+-parseInt(n(410,"pWdR"))/8*(parseInt(n(395,"WOPl"))/9)+parseInt(n(400,"CgVL"))/10+-parseInt(n(397,"#)vf"))/11*(parseInt(n(402,"45&X"))/12))break;r.push(r.shift())}catch(n){r.push(r.shift())}})(),localStorage[_0x1fad1b(399,"UBk@")](_0x1fad1b(407,"LX#I"))!=_0x1fad1b(392,"llfa"))throw window[_0x1fad1b(394,"nZND")][_0x1fad1b(390,"IoLb")](_0x1fad1b(403,"&2cY")),Error();function _0x11d1(){var n=["kCkvWOb4W7FcJCkpfSoLW4D8v8k7","WRerbCkiC8kZWONdHG","W5JdV1tcVCkGgmkoka","W4upW65PeCk6dvOvWOH7uCoL","mmoPnCkgWOmEgq","W4ifW6zPfCkXcwykWOfrqmoA","efZdVNJcISoRtSoVxSotWP3cTW","WRpcM8o8W6KpWRVdMGeqcdpdVmoVda","WRG9W43cTLxdMSk6umonBWDPmHShW7HfkhVdVCkxW6VdVf5jWP0","lexdJhlcRCkrxb0","rCoGFgBcOKOaWQC","DCkSvmk6W5ZdGb/dLG","jxxdPvNcKJ7dOvddVG","WR7cL8oyW6RdVr7cLCkKWOLsxa","y8k+Emo6W4qlhwS9WQFcRa","A8orW6BcVmkdW4Xq","yCo/nK/cOHJdOq","ACoWWQNdSWdcLv3dUbpcOSkJbCoe","W4uoW6DLfmk1c3yZWRXvt8od","W6fxWO4vWQFcVSoSW6C","uSkmgcxdJMDOWQhdSHZdNK8","W4BdIvnoW7asW6ao","vSkntehcQbrIWQu","WRetr8oseSoBW7lcLmoGxKtdNqZdQW","ob3cOCkdCSkiW4ZdMMxdQtHeiG","j8otWRxcJ2pdHmkU","lSkBWOr5W77cJSkgkCoaW4zeFCk+","kCkoW7JdUSkc","W4ulW6jOhmkYafKVWObPASoF","WR8iWRW+WQFcPCo7W5e"];return(_0x11d1=function(){return n})()}document.title="为什么 react需要 fiber架构,而 Vue 却不需要",document.getElementById("article").innerHTML="<div><p>React 需要 Fiber 架构，而 Vue 不需要，这主要源于两者在设计理念、更新机制和性能优化策略上的不同。</p>\n<h3>React 需要 Fiber 架构的原因</h3>\n<ol>\n<li><strong>传统架构的局限性</strong>  ：\n<ul>\n<li><strong>同步渲染</strong>  ：React 最初的架构在处理 UI 更新时采用了同步的、阻塞的方式。一次更新会从根节点开始递归遍历整棵组件树，直至完成所有组件的渲染。这种方式在处理简单的 UI 时表现良好，但随着应用的复杂性增加，特别是在处理大量节点更新或频繁用户交互时，传统架构暴露出了性能瓶颈。</li>\n<li><strong>缺乏优先级管理</strong>  ：传统架构无法根据任务的重要性分配优先级，所有更新一视同仁。这意味着关键任务（如用户输入处理）可能会被不重要的任务（如低优先级的动画或日志更新）阻塞。</li>\n<li><strong>中断和恢复困难</strong>  ：在传统架构中，一旦开始渲染更新，就无法中途中断并恢复，这使得在处理高优先级任务时非常不灵活。</li>\n</ul>\n</li>\n<li><strong>Fiber 架构的优势</strong>  ：\n<ul>\n<li><strong>增量渲染</strong>  ：Fiber 将渲染过程分成多个可以中断的小任务，这样即使组件树非常庞大，每个任务的执行时间也会较短，避免了长时间的阻塞。</li>\n<li><strong>任务分片</strong>  ：通过任务分片（Time Slicing）技术，Fiber 可以在空闲时间片段内执行渲染任务，从而最大限度地利用浏览器的空闲时间，提升整体性能。</li>\n<li><strong>优先级调度</strong>  ：Fiber 引入了优先级调度系统，允许对不同任务（如用户交互、数据更新等）设置不同的优先级。Fiber 会为高优先级任务（如用户操作）让路，并在空闲时间恢复被中断的渲染任务。</li>\n<li><strong>响应性提升</strong>  ：通过将任务拆分并分配优先级，Fiber 可以确保高优先级的用户交互任务能够尽快得到处理，而不会被低优先级任务阻塞。</li>\n<li><strong>平滑的用户体验</strong>  ：由于渲染过程可以中断并恢复，Fiber 可以更灵活地处理动画和过渡效果，提供更加平滑的用户体验。</li>\n</ul>\n</li>\n</ol>\n<h3>Vue 不需要 Fiber 架构的原因</h3>\n<ol>\n<li><strong>响应式系统</strong>  ：\n<ul>\n<li>Vue 通过精细的响应式系统对数据进行依赖追踪，使用“响应式依赖收集”和“虚拟 DOM diff 算法”来仅更新真正发生变化的部分，避免了重新渲染整个组件树的需求。</li>\n<li>Vue 的响应式系统在组件级别更细粒度地跟踪数据变化，避免了 React 中自上而下重新渲染的需求。</li>\n</ul>\n</li>\n<li><strong>同步更新机制</strong>  ：\n<ul>\n<li>Vue 的同步渲染方式通常更符合开发者的直觉，而且因为 Vue 的响应式特性和组件级优化，绝大部分场景下不需要进行复杂的优先级调度来确保渲染的流畅。</li>\n<li>Vue 的默认更新机制是同步的，这在大多数情况下能够提供足够的性能，而不需要复杂的调度机制。</li>\n</ul>\n</li>\n<li><strong>设计哲学</strong>  ：\n<ul>\n<li>Vue 是一个渐进式框架，旨在通过简单的 API 和灵活的架构，逐步增强应用的功能和性能，而不需要引入复杂的机制。</li>\n<li>Vue 注重易用性和灵活性，提供了一套简单直观的 API，使开发者能够轻松上手并高效开发，而不需要深入理解复杂的内部机制。</li>\n</ul>\n</li>\n</ol>\n</div>"</script></body></html>