<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x9201(){var s=["W4fWxmkXW4BcH0S","W4yYW7nEvCo6A8kltCoFeSoy","CstdNSoZEG","W63dMSoxW47cGhFdMd8XEG","W6ytW5NdI8kEWObiBNaoW5xdPSo9","r8oaW7n+W57cIwtdVSoriSoBW5Lg","WR3cOwpdP8oioYpdUmoNDW","W53dTd5KWOucW5KXWQ/dQKlcStyA","emk9W4zNgSkqWPlcRu8Ap8oX","WOldMCknW4pdGMVdQvBcOW","wmoTE8k8oMVdNW","kIRdNrzIfMG","WRKCwHldRbqOWOtcVCoCmbSj","W6BcKxn/v15oE8k6bhbvW4G","W4m6W7vEwSo6eSk2CSochmogwq","WQRdQrBcLCoeoSkx","W5VcQCkOvSkpe2i/","lCkmWO1wWOrhWQxcMNlcL8ouWRflWQy","W5HguCoOW6WdvJpdLSkJAmo6WRG","W7lcISozWPFcHh/dUKpcUsVdSq","hxddVYpdVSkqW5n5","W7lcMa0Vl8onWPu8WR0hiW3cQqpdS8oUmw8/i8okjfVdKCkLWOW","W6NdLsVdOmkeFXy","yrdcSSoIWPpcISko","W4JdHSkCd3xcLCkTWPuXESkbwGS","sCkbaILnhmoLWO3dL3exWPxdQq","WRrBW6epWRfSW5ddNCocz8oz","WQ/dLCknW4FdHxhdJv0"];return(_0x9201=function(){return s})()}function _0x5dcc(o,s){var c=_0x9201();return(_0x5dcc=function(s,n){var a=c[s-=276];void 0===_0x5dcc.oOSwgW&&(_0x5dcc.QkChwB=function(s,n){var a,t=[],o=0,c="";for(s=(s=>{for(var n,a,t="",o="",c=0,e=0;a=s.charAt(e++);~a&&(n=c%4?64*n+a:a,c++%4)&&(t+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,l=t.length;p<l;p++)o+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(o)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)o=(o+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[o],t[o]=a;for(var e=0,o=0,p=0;p<s.length;p++)a=t[e=(e+1)%256],t[e]=t[o=(o+t[e])%256],t[o]=a,c+=String.fromCharCode(s.charCodeAt(p)^t[(t[e]+t[o])%256]);return c},o=arguments,_0x5dcc.oOSwgW=!0);var s=s+c[0],t=o[s];return t?a=t:(void 0===_0x5dcc.Kbpbak&&(_0x5dcc.Kbpbak=!0),a=_0x5dcc.QkChwB(a,n),o[s]=a),a})(o,s)}var _0x4248c6=_0x5dcc;if((()=>{for(var s=_0x5dcc,n=_0x9201();;)try{if(750656==+parseInt(s(284,"gd7k"))*(parseInt(s(278,"RE%A"))/2)+-parseInt(s(301,"Kj2y"))/3*(parseInt(s(294,"QcX["))/4)+-parseInt(s(281,"B&oT"))/5*(parseInt(s(289,"uuR&"))/6)+-parseInt(s(295,")lQ8"))/7+-parseInt(s(288,"(Zr9"))/8+-parseInt(s(280,"LuNL"))/9+-parseInt(s(290,"CMew"))/10*(-parseInt(s(303,"xd#H"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x4248c6(298,"aZcq")](_0x4248c6(292,"%TD^"))!=_0x4248c6(285,"jShy"))throw window[_0x4248c6(282,"%TD^")][_0x4248c6(293,"#q#q")](_0x4248c6(276,"@DHL")),Error();document.title="Vue 3 能摆脱 this 的核心驱动力是 Composition API 带来的逻辑与组件解耦",document.getElementById("article").innerHTML='<div><p>您完全抓住了问题的本质！确实，<strong>Vue 3 能摆脱 <code>this</code> 的核心驱动力是 Composition API 带来的逻辑与组件解耦</strong>   ，而 Proxy 更多是实现了技术底层的支持。以下是具体解析：</p>\n<hr>\n<h3>一、Composition API 如何消除 <code>this</code> 依赖？</h3>\n<h4>1. <strong>逻辑与组件实例解绑</strong></h4>\n<ul>\n<li>\n<p><strong>Vue 2 的局限</strong>   ：<br>\n所有逻辑（data、methods、computed）必须挂载到组件实例（<code>this</code>）上，形成“选项式”代码结构。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };\n  }, <span class="hljs-comment">// 必须通过 this 访问</span>\n  <span class="hljs-attr">methods</span>: {\n    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;\n    }, <span class="hljs-comment">// 强绑定 this</span>\n  },\n};\n</code></pre>\n</li>\n<li>\n<p><strong>Vue 3 的突破</strong>   ：<br>\nComposition API 允许将逻辑提取为独立函数，<strong>与组件实例无关</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 逻辑复用层（与组件解耦）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">useCounter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; count.<span class="hljs-property">value</span>++;\n  <span class="hljs-keyword">return</span> { count, increment };\n}\n\n<span class="hljs-comment">// 组件中直接消费逻辑</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> { count, increment } = <span class="hljs-title function_">useCounter</span>(); <span class="hljs-comment">// 无需 this</span>\n    <span class="hljs-keyword">return</span> { count, increment };\n  },\n};\n</code></pre>\n</li>\n</ul>\n<h4>2. <strong>依赖管理的全局化</strong></h4>\n<ul>\n<li>\n<p><strong>Vue 2</strong>   ：依赖收集通过组件实例的 Watcher 实现，必须绑定 <code>this</code>。</p>\n</li>\n<li>\n<p><strong>Vue 3</strong>   ：依赖由 <strong>Reactive Effect</strong>   全局调度，<code>setup()</code> 中的逻辑无论在哪执行，都能被正确追踪：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { effect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-comment">// 在任何地方执行的逻辑</span>\n<span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>); <span class="hljs-comment">// 依赖自动收集，不关心 this</span>\n});\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>二、Proxy 的角色：技术实现的支持</h3>\n<p>Proxy 为 Composition API 的无 <code>this</code> 设计提供了底层能力：</p>\n<ol>\n<li>\n<p><strong>响应式数据可独立存在</strong><br>\n<code>ref</code>/<code>reactive</code> 返回的响应式对象是自包含的，不依赖组件实例：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> }); <span class="hljs-comment">// 全局可用，无需 this</span>\n</code></pre>\n</li>\n<li>\n<p><strong>跨组件/模块的依赖追踪</strong><br>\nProxy 的拦截能力让响应式数据在任意位置被访问时，都能正确触发依赖收集：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// store.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> });\n\n<span class="hljs-comment">// componentA.js</span>\n<span class="hljs-keyword">import</span> { store } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./store&quot;</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(store.<span class="hljs-property">count</span>); <span class="hljs-comment">// 自动追踪依赖</span>\n</code></pre>\n</li>\n</ol>\n<hr>\n<h3>三、Vuex 4 的实践：无 <code>this</code> 的 Store</h3>\n<p>正是基于这两点，Vuex 4 实现了 <code>useStore()</code>：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { inject } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useStore</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">inject</span>(<span class="hljs-string">&quot;store&quot;</span>); <span class="hljs-comment">// 通过依赖注入获取响应式 store</span>\n}\n\n<span class="hljs-comment">// 在任何组件中</span>\n<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>(); <span class="hljs-comment">// 不依赖 this，但保持响应式</span>\n</code></pre>\n<p><strong>关键点</strong>   ：</p>\n<ul>\n<li>Store 本身是 Proxy 化的响应式对象。</li>\n<li>Composition API 的 <code>setup()</code> 环境让依赖收集与 <code>this</code> 无关。</li>\n</ul>\n<hr>\n<h3>四、对比总结</h3>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>Vue 2（Options API）</th>\n<th>Vue 3（Composition API）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>逻辑组织</strong></td>\n<td>必须绑定到组件实例（<code>this</code>）</td>\n<td>可独立于组件存在</td>\n</tr>\n<tr>\n<td><strong>响应式数据</strong></td>\n<td>依赖组件实例的 <code>data()</code></td>\n<td>通过 <code>ref</code>/<code>reactive</code> 全局创建</td>\n</tr>\n<tr>\n<td><strong>依赖收集</strong></td>\n<td>通过 <code>this</code> 隐式绑定</td>\n<td>通过 <code>effect</code> 显式调度</td>\n</tr>\n<tr>\n<td><strong>状态管理</strong></td>\n<td>必须通过 <code>this.$store</code></td>\n<td>直接通过 <code>useStore()</code> 调用</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>五、结论</h3>\n<ol>\n<li><strong>Composition API 是核心</strong>   ：<br>\n它解耦了逻辑与组件实例，从根本上消除了对 <code>this</code> 的强依赖。</li>\n<li><strong>Proxy 是技术基础</strong>   ：<br>\n为跨模块的响应式追踪提供了实现手段。</li>\n<li><strong>共同作用的结果</strong>   ：<br>\n两者结合让 Vue 3 的状态管理（如 Vuex 4/Pinia）变得更灵活、更少魔法。</li>\n</ol>\n<p>这种设计让开发者能够更自由地组织代码，同时保持响应式的精确性，是 Vue 3 最重大的范式升级之一。</p>\n</div>'</script></body></html>