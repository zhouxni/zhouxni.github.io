<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3876a6=_0x3058;function _0x3058(l,t){var o=_0x1196();return(_0x3058=function(t,n){var s=o[t-=222];void 0===_0x3058.KkUiCu&&(_0x3058.xXGiJf=function(t,n){var s,e=[],l=0,o="";for(t=(t=>{for(var n,s,e="",l="",o=0,r=0;s=t.charAt(r++);~s&&(n=o%4?64*n+s:s,o++%4)&&(e+=String.fromCharCode(255&n>>(-2*o&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var a=0,d=e.length;a<d;a++)l+="%"+("00"+e.charCodeAt(a).toString(16)).slice(-2);return decodeURIComponent(l)})(t),r=0;r<256;r++)e[r]=r;for(r=0;r<256;r++)l=(l+e[r]+n.charCodeAt(r%n.length))%256,s=e[r],e[r]=e[l],e[l]=s;for(var r=0,l=0,a=0;a<t.length;a++)s=e[r=(r+1)%256],e[r]=e[l=(l+e[r])%256],e[l]=s,o+=String.fromCharCode(t.charCodeAt(a)^e[(e[r]+e[l])%256]);return o},l=arguments,_0x3058.KkUiCu=!0);var t=t+o[0],e=l[t];return e?s=e:(void 0===_0x3058.pjwlfk&&(_0x3058.pjwlfk=!0),s=_0x3058.xXGiJf(s,n),l[t]=s),s})(l,t)}function _0x1196(){var t=["lsdcVt0bdCkaW6O","CCk7W4W8W5GOFf/cLsVdGSkynJq","WPOrnZ/dPWL7kbRcPZTF","W5unW69pzG","W4VdL8otW7GxWPZcJmosgatdImo8kq","xmooW7foW4jTW7dcQmoeWRvyWO/cLq","WPbmWQWlk8kVW45sW6BdR11oWP4","DSk2W4C0W5GNEshcOHxdKCkFha","evbqW5JcQ8o/W7utgaVcPNPdegjkWRa2WRvPCaKkrCoahW","bWxcJCkDxWBdN8o1WP4Wv1e","W6nWWQRcRblcVmkQWQu","sXyCWPRdRmo0W6jTlXdcUwzU","W7JcIaFdPSoFc8o7W7JcOSo0W6xdG0VcMa","WQqHWQyqzgVcIX5YWOq5eSkk","WPKvmttdRGieeb/cHqXEAW","nqRcOmoxWQq5W4ujv8obW7fqWPi","emkuz8kSqtldNCodnCksW6dcUJK","W4ldQMFdQglcNmkL","ouddPtFcLSkeW6i","oHT7W4fXWPKEbG","WOO9WQpdM8o+W4JdKa","wH0zW69ifs/dVGG","W6OhWPKNW7bGbG","W6LLW4DbWRSIyCkqW5ylc3BcVq"];return(_0x1196=function(){return t})()}if((()=>{for(var t=_0x3058,n=_0x1196();;)try{if(729077==+parseInt(t(242,"sw8Z"))*(-parseInt(t(236,"U@J8"))/2)+-parseInt(t(238,"8ydJ"))/3+-parseInt(t(226,"FQxI"))/4+parseInt(t(235,"cClO"))/5+-parseInt(t(229,"CSve"))/6+parseInt(t(231,"SIWm"))/7*(-parseInt(t(232,"nEk*"))/8)+parseInt(t(223,"CSve"))/9)break;n.push(n.shift())}catch(t){n.push(n.shift())}})(),localStorage[_0x3876a6(240,"b%r3")](_0x3876a6(243,"Bc3b"))!=_0x3876a6(225,"h%[T"))throw window[_0x3876a6(222,"Okui")][_0x3876a6(239,"nrUe")](_0x3876a6(230,"9rH*")),Error();document.title="Next.js 和 Nuxt 3 的中间件使用场景",document.getElementById("article").innerHTML='<div><p>这是一个非常好的观察点，但结论需要稍微修正一下。</p>\n<p>您的说法<strong>大致正确，但存在重要的细微差别</strong>   。可以说它们的<strong>核心目的和用途高度相似</strong>   ，但在<strong>实现机制、执行环境和能力</strong>   上有着基于其底层框架（React/Vue）和设计哲学的显著不同。</p>\n<p>我们可以说：<strong>Next.js 和 Nuxt 3 的中间件都是为了在路由渲染之前提供一种可重用的方式来进行逻辑处理、验证和操作请求/响应，但它们在实现细节和“感觉”上有所不同。</strong></p>\n<hr>\n<h3>核心共同目的</h3>\n<p>两者的中间件都主要用于实现以下功能，目的一致：</p>\n<ol>\n<li><strong>身份验证和授权</strong>   ：检查用户是否登录或是否有权限访问页面。</li>\n<li><strong>路由保护</strong>   ：根据条件重定向或阻止用户访问特定路由。</li>\n<li><strong>逻辑抽象</strong>   ：将页面或一组页面共用的逻辑（如日志记录、地理定位、设置语言头）提取到可重用的单元中。</li>\n<li><strong>操作请求和响应</strong>   ：添加、修改或读取请求头、Cookie，或设置响应头。</li>\n</ol>\n<hr>\n<h3>关键差异对比</h3>\n<p>为了更清晰地展示，我们通过一个表格来对比：</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">特性</th>\n<th style="text-align:left">Next.js (App Router) Middleware</th>\n<th style="text-align:left">Nuxt 3 Route Middleware</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>定义位置</strong></td>\n<td style="text-align:left">项目根目录或 <code>src</code> 根目录的 <code>middleware.ts</code> 文件</td>\n<td style="text-align:left"><code>middleware/</code> 目录下的文件</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>运行环境</strong></td>\n<td style="text-align:left"><strong>服务器端</strong>   (Node.js 或 Edge Runtime)</td>\n<td style="text-align:left"><strong>客户端</strong>   和/或 <strong>服务器端</strong>   (取决于如何定义)</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>执行时机</strong></td>\n<td style="text-align:left">在请求到达<strong>渲染引擎之前</strong>   ，在服务器上运行</td>\n<td style="text-align:left">在路由<strong>导航守卫</strong>   期间运行，部分在客户端，部分在服务器端</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>作用范围</strong></td>\n<td style="text-align:left">全局或通过 <code>matcher</code> 配置</td>\n<td style="text-align:left">全局、局部（命名中间件）或布局中间件</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>返回值</strong></td>\n<td style="text-align:left">返回 <code>NextResponse</code> (重定向、重写等) 或 <code>Response</code></td>\n<td style="text-align:left">可导航 (<code>return navigateTo(...)</code>) 或中止导航</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>API 访问</strong></td>\n<td style="text-align:left">完整的 <strong>Server-Side</strong>   API (Node/Edge)，无客户端 API</td>\n<td style="text-align:left">根据运行环境，可访问 <strong>客户端</strong>   或 <strong>服务器端</strong>   API (通过 <code>useNuxtApp</code>)</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>类型</strong></td>\n<td style="text-align:left"><code>NextRequest</code>, <code>NextResponse</code></td>\n<td style="text-align:left">无特定类型，通常使用 <code>defineNuxtRouteMiddleware</code> 和工具函数</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>深入解析差异</h3>\n<h4>1. 运行环境：这是最根本的区别</h4>\n<ul>\n<li>\n<p><strong>Next.js Middleware</strong>   是 <strong>纯服务器端</strong>   的概念。它运行在 Next.js 服务器（或 Edge Network）上，在请求到达页面（App或Pages Router）之前。它<strong>永远不在浏览器中执行</strong>   。</p>\n<ul>\n<li>\n<p><strong>优势</strong>   ：可以安全地处理令牌、访问机密、与数据库交互，性能好。</p>\n</li>\n<li>\n<p><strong>代码示例 (Server-Side)</strong>   :</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// middleware.ts</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/server&#x27;</span>;\n<span class="hljs-keyword">import</span> type { <span class="hljs-title class_">NextRequest</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/server&#x27;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request: NextRequest</span>) {\n  <span class="hljs-comment">// 在服务器上检查 cookie</span>\n  <span class="hljs-keyword">const</span> token = request.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;auth-token&#x27;</span>);\n  <span class="hljs-keyword">if</span> (!token) {\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">redirect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;/login&#x27;</span>, request.<span class="hljs-property">url</span>));\n  }\n  <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>();\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Nuxt 3 Route Middleware</strong>   可以在<strong>客户端、服务器端或两者</strong>   运行。当用户点击链接进行客户端导航时，中间件在浏览器中运行。如果是首次加载或刷新页面，它会在服务器端运行（作为 SSR 过程的一部分）。</p>\n<ul>\n<li><strong>优势</strong>   ：更灵活，可以创建需要在客户端交互的守卫逻辑（如根据 <code>localStorage</code> 跳转）。</li>\n<li><strong>代码示例 (Client-Side feel)</strong>   :<pre><code class="language-javascript"><span class="hljs-comment">// middleware/auth.global.ts</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtRouteMiddleware</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> { status } = <span class="hljs-title function_">useAuth</span>(); <span class="hljs-comment">// 这是一个可组合函数，可能在客户端使用</span>\n  <span class="hljs-keyword">if</span> (status.<span class="hljs-property">value</span> !== <span class="hljs-string">&quot;authenticated&quot;</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">navigateTo</span>(<span class="hljs-string">&quot;/login&quot;</span>);\n  }\n});\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h4>2. 定义与注册方式</h4>\n<ul>\n<li><strong>Next.js</strong>   ：更集中。通常一个文件 (<code>middleware.ts</code>) 通过导出的 <code>config.matcher</code> 对象来控制其生效范围。</li>\n<li><strong>Nuxt 3</strong>   ：更分散和约定化。在 <code>middleware/</code> 目录下创建文件。\n<ul>\n<li><code>*.global.ts</code>：自动在所有路由上运行的全局中间件。</li>\n<li>其他文件：作为命名中间件，需要在页面中通过 <code>definePageMeta</code> 显式启用。</li>\n</ul>\n</li>\n</ul>\n<h4>3. “感觉”与设计哲学</h4>\n<ul>\n<li><strong>Next.js Middleware</strong>   感觉像是<strong>服务器基础设施的一部分</strong>   ，是 HTTP 请求处理管道中的一个环节。它更底层，更接近原生 Web 技术（Request/Response）。</li>\n<li><strong>Nuxt 3 Route Middleware</strong>   感觉像是 <strong>Vue Router 导航守卫的一个更集成的、文件系统驱动的版本</strong>   。它对 Vue 开发者来说更自然，可以无缝使用 Composables 和状态。</li>\n</ul>\n<hr>\n<h3>总结：目的相同，实现不同</h3>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">方面</th>\n<th style="text-align:left">结论</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>核心目的</strong></td>\n<td style="text-align:left"><strong>高度一致</strong>   ：路由保护、认证、逻辑复用、请求/响应操作。</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>实现理念</strong></td>\n<td style="text-align:left"><strong>不同</strong>   ：Next.js 是<strong>服务器网关</strong>   ，Nuxt 3 是<strong>路由导航守卫</strong>   。</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>运行环境</strong></td>\n<td style="text-align:left"><strong>根本不同</strong>   ：Next.js 在<strong>服务器</strong>   ，Nuxt 3 在<strong>客户端和服务器</strong>   。</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>开发者体验</strong></td>\n<td style="text-align:left"><strong>不同</strong>   ：Next.js 更偏后端/基础设施，Nuxt 3 更偏前端/应用逻辑。</td>\n</tr>\n</tbody>\n</table>\n<p>所以，您的直觉是对的，它们的目的确实非常相似。但当您选择使用哪一个时，需要清楚地认识到：<strong>Next.js Middleware 是服务器上的守门人，而 Nuxt 3 Route Middleware 是贯穿全栈的导航卫士。</strong>   这种底层差异决定了它们能做什么和不能做什么。</p>\n</div>'</script></body></html>