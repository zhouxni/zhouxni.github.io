<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x88778a=_0x3112;function _0x54f8(){var n=["W6JdPWNdRCoklCkud8kmW6tcLCobWQhdH13dRLVcVwDaWRpcH0L+W77cHG","WRjSzSkDW7K8l8kMpqtcSXW6","mNFdUmofWRpdVmooW4VdOmoyW5C","FsNdKSkyW7ddRKapW6D4WP4","js/cPxTbWQZdGmkr","W6jbW7i3W692q3W","WODsl8o/kCkMW6j9a8ohqG3cSa","lsyqC8oPs0eOWQ4","fwVdKaTjn8omWOi","fMJcLhGNrmkpWQFcJwNcU8kcEW","cCo9WQfcWOi","a2iJWR4TW7VdMa","smkXW6uhW4KgoXvWx8oUDa","W7NdT8kRWQn+WPWCW4PG","W4ystmk7uhOuma","WRhdSCo1W4WQWO0KWQpdSa","oHdcUWyvWPBcU8o3W6rzxq","hL58WONcKbJcJ8oiW7PcqSkRdq","WRNcPCoRWOHAWQK9","pmkNWPJdGJtdSCoxWRlcSNao","WQBcG8k6p8k2WPBdT8o5WQpdOGy","sbKMiNVcJaJdLSoEWOHYWRBcKG","WRSXWRJdGmkzW4JcT8k9WQdcMtbC","WRhdPx04zSkhe8koWPiAdCoZWQG","WPFdTmkfBCo4bghcLG"];return(_0x54f8=function(){return n})()}function _0x3112(r,n){var l=_0x54f8();return(_0x3112=function(n,t){var o=l[n-=487];void 0===_0x3112.xlBhLg&&(_0x3112.FhgMqM=function(n,t){var o,e=[],r=0,l="";for(n=(n=>{for(var t,o,e="",r="",l=0,s=0;o=n.charAt(s++);~o&&(t=l%4?64*t+o:o,l++%4)&&(e+=String.fromCharCode(255&t>>(-2*l&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var i=0,d=e.length;i<d;i++)r+="%"+("00"+e.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(r)})(n),s=0;s<256;s++)e[s]=s;for(s=0;s<256;s++)r=(r+e[s]+t.charCodeAt(s%t.length))%256,o=e[s],e[s]=e[r],e[r]=o;for(var s=0,r=0,i=0;i<n.length;i++)o=e[s=(s+1)%256],e[s]=e[r=(r+e[s])%256],e[r]=o,l+=String.fromCharCode(n.charCodeAt(i)^e[(e[s]+e[r])%256]);return l},r=arguments,_0x3112.xlBhLg=!0);var n=n+l[0],e=r[n];return e?o=e:(void 0===_0x3112.hDxsyX&&(_0x3112.hDxsyX=!0),o=_0x3112.FhgMqM(o,t),r[n]=o),o})(r,n)}if((()=>{for(var n=_0x3112,t=_0x54f8();;)try{if(372383==-parseInt(n(503,"Twc8"))+parseInt(n(500,"LJ9E"))/2+-parseInt(n(497,"8w6E"))/3*(parseInt(n(511,"55pq"))/4)+parseInt(n(496,"Zc9u"))/5*(parseInt(n(499,"!9s3"))/6)+-parseInt(n(506,"yS[k"))/7+parseInt(n(504,"5Sa["))/8+parseInt(n(505,"Hj3H"))/9*(-parseInt(n(488,"WEN@"))/10))break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x88778a(494,"E(HH")](_0x88778a(498,"LQt9"))!=_0x88778a(493,"XHUV"))throw window[_0x88778a(507,"Io^r")][_0x88778a(501,"Zc9u")](_0x88778a(508,"E0AS")),Error();document.title="列出 Redux 的核心方法",document.getElementById("article").innerHTML="<div><p>Redux 的核心方法主要包括以下几个：</p>\n<ol>\n<li><strong><code>createStore(reducer, [preloadedState], [enhancer])</code></strong>\n<ul>\n<li><strong>作用</strong>  ：创建一个 Redux store，用于保存应用的所有 state。</li>\n<li><strong>参数</strong>  ：\n<ul>\n<li><code>reducer</code>：一个函数，用于接收当前的 state 和 action，并返回新的 state。</li>\n<li><code>preloadedState</code>（可选）：初始 state。</li>\n<li><code>enhancer</code>（可选）：Store enhancer，如中间件等。</li>\n</ul>\n</li>\n<li><strong>返回值</strong>  ：一个 Redux store 对象。</li>\n</ul>\n</li>\n<li><strong><code>store.getState()</code></strong>\n<ul>\n<li><strong>作用</strong>  ：返回应用当前的 state 树。</li>\n<li><strong>使用场景</strong>  ：用于获取 store 中存储的 state。</li>\n</ul>\n</li>\n<li><strong><code>store.dispatch(action)</code></strong>\n<ul>\n<li><strong>作用</strong>  ：分发一个 action，这是触发 state 变化的唯一途径。</li>\n<li><strong>参数</strong>  ：\n<ul>\n<li><code>action</code>：一个描述要执行的操作的普通 JavaScript 对象，必须包含 <code>type</code> 属性。</li>\n</ul>\n</li>\n<li><strong>使用场景</strong>  ：用于通知 reducer 根据 action 更新 state。</li>\n</ul>\n</li>\n<li><strong><code>store.subscribe(listener)</code></strong>\n<ul>\n<li><strong>作用</strong>  ：添加一个变化监听器，每当 dispatch action 时就会执行，并在 state 树更新后调用。</li>\n<li><strong>参数</strong>  ：\n<ul>\n<li><code>listener</code>：一个回调函数，当 state 发生变化时会被调用。</li>\n</ul>\n</li>\n<li><strong>返回值</strong>  ：一个函数，用于取消监听器。</li>\n<li><strong>使用场景</strong>  ：用于订阅 state 的变化，以便在 state 更新后执行某些操作，如重新渲染 UI。</li>\n</ul>\n</li>\n<li><strong><code>combineReducers(reducers)</code></strong>\n<ul>\n<li><strong>作用</strong>  ：将多个 reducer 函数合并成一个 reducer 函数，用于管理 state 树的不同部分。</li>\n<li><strong>参数</strong>  ：\n<ul>\n<li><code>reducers</code>：一个对象，其值（value）为不同部分的 reducer 函数。</li>\n</ul>\n</li>\n<li><strong>返回值</strong>  ：一个函数，该函数接收整个 state 和一个 action，并返回一个新的 state 对象。</li>\n<li><strong>使用场景</strong>  ：当应用需要管理多个独立的状态片段时，使用 <code>combineReducers</code> 可以将多个 reducer 组合在一起。</li>\n</ul>\n</li>\n<li><strong><code>applyMiddleware(...middlewares)</code></strong>\n<ul>\n<li><strong>作用</strong>  ：应用中间件到 Redux store，中间件可以扩展 Redux 的 dispatch 方法。</li>\n<li><strong>参数</strong>  ：\n<ul>\n<li><code>...middlewares</code>：多个中间件函数。</li>\n</ul>\n</li>\n<li><strong>返回值</strong>  ：一个 store enhancer，可以用于创建 store。</li>\n<li><strong>使用场景</strong>  ：用于处理异步操作、日志记录、崩溃报告等。</li>\n</ul>\n</li>\n</ol>\n<p>这些方法构成了 Redux 的核心 API，它们共同协作，使得 Redux 能够有效地管理应用的状态，并确保状态的一致性和可预测性。</p>\n</div>"</script></body></html>