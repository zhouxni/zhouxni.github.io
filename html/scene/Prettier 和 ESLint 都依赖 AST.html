<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4daeb5=_0xaa2e;function _0x2669(){var n=["oSouW7q+prZcKsyuW6DUorhdOYRdMYpcR1xdHSoagvGiW4Ci","kmozW6JdQwRcT8kdy8kWWOddNMe","FgRdQCoQD2CClCk3W4ddL8ki","WPzSsdmlW4FcSa","W53dSJiBW6/dIJ0Tsa","WQ3cOwusW67dNtunra","agL6bNG","W7xdImkzW7hcM8oaW50","qSkQysJdHSo3W6LY","W6tdLuHAW7uSWQ3cLHJdMJxcNq","W57dTtjhW4RdVHK/w8k4","uCkwbCkvWRDEcr/cSmkIWR4","W47dJYPivdDFW7WcW5VcPcK","yCkuWRf6EXldP0G5W71YaG","W5qBp28OWRtdVq","sWP2z8k5y8ovgNRcSq","yKtcOh4oWRvP","bYPOWP0IxCoxW5a","vCoIEKdcR8krDelcM2K","uNu9WOKUEmoaW5tcMa","z8kwWRn2FKFdKK0TW4v2","i3C0W67cQHJdOq","WR9Ygc0SqMNcRCo3WQa7","W4yQWPZdTSojACk+WPXbWQe","gqldQ8oyu3ebW5VcNMK","F8k2kcHHnKKUW6C","WPNcU8o8EImzuCo1eq","tqiOFSkCWRGhxeFdM8ksWOu","c8ktWRiBW6lcS07cVSoDwa","W6CgWOuyoHHzCq","WRnWhciLze3cPCodWQy0","W7xcL8oyW6/dQCoIoa"];return(_0x2669=function(){return n})()}function _0xaa2e(s,n){var e=_0x2669();return(_0xaa2e=function(n,t){var r=e[n-=358];void 0===_0xaa2e.pkmFUd&&(_0xaa2e.kEdaqf=function(n,t){var r,o=[],s=0,e="";for(n=(n=>{for(var t,r,o="",s="",e=0,d=0;r=n.charAt(d++);~r&&(t=e%4?64*t+r:r,e++%4)&&(o+=String.fromCharCode(255&t>>(-2*e&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var a=0,i=o.length;a<i;a++)s+="%"+("00"+o.charCodeAt(a).toString(16)).slice(-2);return decodeURIComponent(s)})(n),d=0;d<256;d++)o[d]=d;for(d=0;d<256;d++)s=(s+o[d]+t.charCodeAt(d%t.length))%256,r=o[d],o[d]=o[s],o[s]=r;for(var d=0,s=0,a=0;a<n.length;a++)r=o[d=(d+1)%256],o[d]=o[s=(s+o[d])%256],o[s]=r,e+=String.fromCharCode(n.charCodeAt(a)^o[(o[d]+o[s])%256]);return e},s=arguments,_0xaa2e.pkmFUd=!0);var n=n+e[0],o=s[n];return o?r=o:(void 0===_0xaa2e.ghxyhK&&(_0xaa2e.ghxyhK=!0),r=_0xaa2e.kEdaqf(r,t),s[n]=r),r})(s,n)}if((()=>{for(var n=_0xaa2e,t=_0x2669();;)try{if(125475==-parseInt(n(369,"v!Er"))*(-parseInt(n(389,"S@JY"))/2)+-parseInt(n(387,"*eoP"))/3*(parseInt(n(360,"1Gy#"))/4)+parseInt(n(366,"UOsg"))/5+-parseInt(n(363,"LsR&"))/6*(parseInt(n(371,"]YZt"))/7)+-parseInt(n(372,"XC&j"))/8*(-parseInt(n(358,"UOsg"))/9)+parseInt(n(378,"XC&j"))/10*(-parseInt(n(364,"b![8"))/11)+parseInt(n(365,"SKy9"))/12*(parseInt(n(370,"5I7("))/13))break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x4daeb5(382,"a0NO")](_0x4daeb5(373,"XC&j"))!=_0x4daeb5(374,"QA5u"))throw window[_0x4daeb5(385,"*eoP")][_0x4daeb5(384,"XPi(")](_0x4daeb5(368,"XQj#")),Error();document.title="Prettier 和 ESLint 都依赖 AST",document.getElementById("article").innerHTML='<div><p>是的，<strong>Prettier 和 ESLint 都依赖 AST（抽象语法树）</strong>  ，但它们的核心目标、处理方式和应用场景不同。以下是两者的对比分析：</p>\n<hr>\n<h2><strong>1. 共同点：基于 AST 工作</strong></h2>\n<ul>\n<li><strong>解析阶段</strong>  ：\n<ul>\n<li>两者都会将源代码解析为 AST（不同语言使用各自的解析器，如 Babel、TypeScript、PostCSS 等）。</li>\n<li>例如：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> code = <span class="hljs-string">&quot;const x=1&quot;</span>; <span class="hljs-comment">// 原始代码</span>\n<span class="hljs-keyword">const</span> ast = parser.<span class="hljs-title function_">parse</span>(code); <span class="hljs-comment">// 生成 AST</span>\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>遍历 AST</strong>  ：\n<ul>\n<li>均会遍历 AST 节点，分析代码结构。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2><strong>2. 核心差异</strong></h2>\n<table>\n<thead>\n<tr>\n<th><strong>维度</strong></th>\n<th><strong>Prettier</strong></th>\n<th><strong>ESLint</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>主要目标</strong></td>\n<td><strong>代码格式化</strong>  （统一风格）</td>\n<td><strong>代码质量检查</strong>  （错误、风格、最佳实践）</td>\n</tr>\n<tr>\n<td><strong>AST 用途</strong></td>\n<td>丢弃原始格式，重新生成标准化代码</td>\n<td>分析 AST 节点，检查是否符合规则</td>\n</tr>\n<tr>\n<td><strong>规则类型</strong></td>\n<td>不可覆盖的格式化规则（如缩进、换行）</td>\n<td>可配置的静态分析规则（如 <code>no-unused-vars</code>）</td>\n</tr>\n<tr>\n<td><strong>输出结果</strong></td>\n<td>直接重写代码</td>\n<td>报告错误或警告（需手动或自动修复）</td>\n</tr>\n<tr>\n<td><strong>灵活性</strong></td>\n<td>低（强制统一风格）</td>\n<td>高（可自定义规则）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>3. 工作流程对比</strong></h2>\n<h3><strong>Prettier（格式化优先）</strong></h3>\n<ol>\n<li><strong>解析</strong>   → 生成 AST（忽略原始格式）。</li>\n<li><strong>丢弃格式</strong>   → 仅保留逻辑结构（如变量声明、表达式）。</li>\n<li><strong>重新生成代码</strong>   → 按配置（如 <code>printWidth: 80</code>）输出标准化格式。</li>\n</ol>\n<h3><strong>ESLint（静态分析优先）</strong></h3>\n<ol>\n<li><strong>解析</strong>   → 生成 AST。</li>\n<li><strong>遍历 AST</strong>   → 检查节点是否符合规则（如变量是否未使用）。</li>\n<li><strong>报告问题</strong>   → 提示错误/警告，需手动或通过 <code>--fix</code> 修复。</li>\n</ol>\n<hr>\n<h2><strong>4. 为什么需要结合使用？</strong></h2>\n<ul>\n<li><strong>Prettier</strong>   解决格式问题（如缩进、引号），<strong>ESLint</strong>   解决逻辑问题（如未使用的变量）。</li>\n<li><strong>互补性</strong>  ：\n<ul>\n<li>ESLint 的 <code>--fix</code> 可修复部分风格问题，但无法像 Prettier 彻底统一格式。</li>\n<li>Prettier 不检查代码质量（如 <code>==</code> 与 <code>===</code>）。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>如何配合？</strong></h3>\n<ol>\n<li>\n<p>使用 <code>eslint-config-prettier</code> 关闭 ESLint 中与 Prettier 冲突的格式规则。</p>\n</li>\n<li>\n<p>在项目中同时运行：</p>\n<pre><code class="language-sh">prettier --write . &amp;&amp; eslint --fix .\n</code></pre>\n<p>（或通过工具如 <code>lint-staged</code> 在 Git 提交前自动执行）</p>\n</li>\n</ol>\n<hr>\n<h2><strong>5. 总结</strong></h2>\n<ul>\n<li><strong>Prettier</strong>  ：基于 AST <strong>重写代码格式</strong>  ，追求一致性。</li>\n<li><strong>ESLint</strong>  ：基于 AST <strong>分析代码质量</strong>  ，追求可配置性。</li>\n<li><strong>AST 是共同基础</strong>  ，但两者的设计目标和输出结果截然不同。</li>\n</ul>\n<p>如果需要 <strong>既统一格式又保证代码质量</strong>  ，推荐结合使用！</p>\n</div>'</script></body></html>