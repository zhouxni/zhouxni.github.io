<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x498f0d=_0xd015;function _0xd015(o,n){var s=_0x2ba8();return(_0xd015=function(n,e){var t=s[n-=140];void 0===_0xd015.kpLtgK&&(_0xd015.KHCoLO=function(n,e){var t,d=[],o=0,s="";for(n=(n=>{for(var e,t,d="",o="",s=0,l=0;t=n.charAt(l++);~t&&(e=s%4?64*e+t:t,s++%4)&&(d+=String.fromCharCode(255&e>>(-2*s&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var r=0,a=d.length;r<a;r++)o+="%"+("00"+d.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(o)})(n),l=0;l<256;l++)d[l]=l;for(l=0;l<256;l++)o=(o+d[l]+e.charCodeAt(l%e.length))%256,t=d[l],d[l]=d[o],d[o]=t;for(var l=0,o=0,r=0;r<n.length;r++)t=d[l=(l+1)%256],d[l]=d[o=(o+d[l])%256],d[o]=t,s+=String.fromCharCode(n.charCodeAt(r)^d[(d[l]+d[o])%256]);return s},o=arguments,_0xd015.kpLtgK=!0);var n=n+s[0],d=o[n];return d?t=d:(void 0===_0xd015.ZKkTPs&&(_0xd015.ZKkTPs=!0),t=_0xd015.KHCoLO(t,e),o[n]=t),t})(o,n)}function _0x2ba8(){var n=["imoVWO9fgmonk8kAWOz1W4vgWO7dHCkrmCkiWPvujLHyWO9bave","W4BcLmkrWQNcUSo0yIhcR8kUpLnE","W4aNb3xcNSk1bCkNWOldRSoxW7dcJW","WPnAEdBcPHJcT8oXCHZdVSoFdXu","pmkzx0/cSSoiofiP","WOFcLmkVWQldU8kdW6hcPmoPssVcGmke","bxP9qrS","WQpdPLrZWRLgW7dcS8k3kq","aCkNFmk1W48Aese","W4KxiSkcW5qDxmo3W6xcMmkMWOrF","WQ8qm2VcHtHWW7xdPZa","WOnPvCo2EGqQdu8Rc8o8uW","BNu5WR/dNSk/W7S8WOPcxN4f","WOZcR8oBmM3dUSorfsTKWRxdGCoQ","Fr7dSSknWR7cRmo0","dbZdRenYA1y","C8kdW5CTy8kWFfH+rCozWPRcUG","W7LWW4Cer8k5W5tcNrldJe3dJLG","W44ddgajwCoDA35uWOCntgq","wCoWuHRdQN7dIW","W5xdG8oIW5/cUSoEWRK","W5/cUhhcN8kQWR4n","W5apog/dTKJdPW","FcqlW6ZdRfPtkveJWRJdTmk8","WRv1xsJdMCo1ECkVWQ8","WQ8qoZFcGdTYW4pdUG"];return(_0x2ba8=function(){return n})()}if((()=>{for(var n=_0xd015,e=_0x2ba8();;)try{if(729020==+parseInt(n(165,"0Y#L"))*(parseInt(n(142,"ilxl"))/2)+parseInt(n(151,"$HF]"))/3+-parseInt(n(158,"tKbD"))/4+-parseInt(n(140,"N#52"))/5+parseInt(n(149,"$RV$"))/6*(-parseInt(n(147,"t3yX"))/7)+parseInt(n(150,"RzA^"))/8*(parseInt(n(153,"p0@C"))/9)+parseInt(n(144,"tVNf"))/10)break;e.push(e.shift())}catch(n){e.push(e.shift())}})(),localStorage[_0x498f0d(155,"N#52")](_0x498f0d(159,"(X1H"))!=_0x498f0d(141,"$3%A"))throw window[_0x498f0d(143,"nLDz")][_0x498f0d(157,"X*FN")](_0x498f0d(161,"N]wj")),Error();document.title="Vue 3 无 key 时的 keyToNewIndexMap 处理",document.getElementById("article").innerHTML='<div><p>在 Vue 3 的 diff 算法中，当子元素没有绑定 <code>key</code> 时，处理方式与 React 类似但有一些关键区别：</p>\n<h2>无 key 时的处理机制</h2>\n<ol>\n<li><strong><code>keyToNewIndexMap</code> 不会被创建</strong>  ：\n<ul>\n<li>Vue 3 会完全跳过构建这个基于 key 的映射表</li>\n<li>改为使用<strong>顺序比较法</strong>  （类似于 React 的无 key 策略）</li>\n</ul>\n</li>\n<li><strong>替代的比较方式</strong>  ：\n<ul>\n<li>通过 <code>patchKeyedChildren</code> 函数的另一种逻辑路径处理</li>\n<li>直接按新旧子节点的<strong>位置顺序</strong>  进行比较</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-comment">// 伪代码表示 Vue 3 的无 key 比较逻辑</span>\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newChildren.<span class="hljs-property">length</span>; i++) {\n  <span class="hljs-keyword">const</span> newVNode = newChildren[i]\n  <span class="hljs-keyword">const</span> oldVNode = oldChildren[i]\n  \n  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVNodeType</span>(oldVNode, newVNode)) {\n    <span class="hljs-title function_">patch</span>(oldVNode, newVNode) <span class="hljs-comment">// 复用节点</span>\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 创建新节点</span>\n  }\n}\n</code></pre>\n</li>\n<li><strong>索引保存方式</strong>  ：\n<ul>\n<li>不会将无 key 节点的索引存入任何映射表</li>\n<li>比较时直接使用数组下标作为位置参考</li>\n<li>在 <code>newIndexToOldIndexMap</code> 中，无 key 节点会被当作&quot;可能可复用&quot;的节点处理</li>\n</ul>\n</li>\n</ol>\n<h2>与有 key 时的性能对比</h2>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>有 key (使用 keyToNewIndexMap)</th>\n<th>无 key</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>节点复用</td>\n<td>跨位置识别相同节点</td>\n<td>仅能识别相同位置的相同类型</td>\n</tr>\n<tr>\n<td>DOM 操作</td>\n<td>最小化移动</td>\n<td>可能大量销毁/重建</td>\n</tr>\n<tr>\n<td>复杂度</td>\n<td>O(n)</td>\n<td>O(n)但实际效率更低</td>\n</tr>\n</tbody>\n</table>\n<h2>特殊处理细节</h2>\n<ol>\n<li><strong>类型检查</strong>  ：\n<ul>\n<li>Vue 会通过 <code>sameVNodeType</code> 检查节点类型是否相同</li>\n<li>类型相同但无 key 的节点可能被复用（如果位置相同）</li>\n</ul>\n</li>\n<li><strong>移动优化</strong>  ：\n<ul>\n<li>无 key 时完全无法使用基于 LIS 的移动优化算法</li>\n<li>所有顺序变化都会导致节点重建</li>\n</ul>\n</li>\n</ol>\n<h2>最佳实践</h2>\n<p>Vue 官方同样建议：</p>\n<blockquote>\n<p>对于动态列表始终提供唯一 key\n避免依赖无 key 时的默认行为</p>\n</blockquote>\n<p>无 key 模式是 Vue 的降级策略，仅适用于简单静态列表，在动态列表中使用会导致性能显著下降。</p>\n</div>'</script></body></html>