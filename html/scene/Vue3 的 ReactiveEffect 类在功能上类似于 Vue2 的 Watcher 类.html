<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1e15(){var s=["pxBdOIOsF8oXW6FcG1CiWOm","yeayFSkmWOyk","cCo7WPxdVgDHeW","WRzbW5NdRtueca1GFqFdUmob","WRi3WOhcShj0tW","WPm+WPjvW5hcSeFdUCoSW781W6xcRW","WPhdRKZcQe1gWRG","W6tcHdXBsq","nuJcP8obW5P+Ch5sW5tcTCkdWQO","WQtdTmkeCJpdMZKmW43cMsRcTWS","W4ZcPmknyCkJamkic8o7W4W1WOv/","lHdcLWBcHCoJjCkCmCokWPqv","kSoua8kEmmksW4zNW5rWW5DhW4S","kCkdAmoGB8oPWOC","W5OfW4aCW6NdRCoDWOO","sdRcGXiVDuS","W7nkw8ozW7uTW5tdTCobW6tdNgFdGq","W6y7WQmEWP4CW5/dKW/dM8k3aGpcLCodW4WkttHyWPRdNhyAasu","W7RcS0PTmuFdL8kB","W5D9WOHnESkYW4y9WR7dI8ksWRNdIq","yCkgW6HUW7W6W6tdJZldS8k3W5iO","W7/dKmk+ltddHCkT","W6HsfaZdKmoKWQO","WOeBd8kjWRzTWQFdUCoa","W5WfWRbTWQ0ql1ldMSomW7FdLW","W415WPNdJg1kwX4avaLb","WPpcTSoxaLhdH2eN","W75gWOLNptqPWOGxwCo4ugy"];return(_0x1e15=function(){return s})()}function _0x265e(e,s){var c=_0x1e15();return(_0x265e=function(s,n){var a=c[s-=250];void 0===_0x265e.DqPLtQ&&(_0x265e.xzqmld=function(s,n){var a,t=[],e=0,c="";for(s=(s=>{for(var n,a,t="",e="",c=0,l=0;a=s.charAt(l++);~a&&(n=c%4?64*n+a:a,c++%4)&&(t+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,p=t.length;o<p;o++)e+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(e)})(s),l=0;l<256;l++)t[l]=l;for(l=0;l<256;l++)e=(e+t[l]+n.charCodeAt(l%n.length))%256,a=t[l],t[l]=t[e],t[e]=a;for(var l=0,e=0,o=0;o<s.length;o++)a=t[l=(l+1)%256],t[l]=t[e=(e+t[l])%256],t[e]=a,c+=String.fromCharCode(s.charCodeAt(o)^t[(t[l]+t[e])%256]);return c},e=arguments,_0x265e.DqPLtQ=!0);var s=s+c[0],t=e[s];return t?a=t:(void 0===_0x265e.qQsXry&&(_0x265e.qQsXry=!0),a=_0x265e.xzqmld(a,n),e[s]=a),a})(e,s)}var _0x491640=_0x265e;if((()=>{for(var s=_0x265e,n=_0x1e15();;)try{if(863162==+parseInt(s(262,"mW2%"))*(parseInt(s(265,"y@pd"))/2)+-parseInt(s(272,"JO#v"))/3+-parseInt(s(260,"li8!"))/4+parseInt(s(252,"$!LD"))/5*(parseInt(s(275,"R03$"))/6)+-parseInt(s(257,"(joi"))/7+-parseInt(s(270,"U5a!"))/8*(parseInt(s(261,"WPik"))/9)+parseInt(s(268,"phW)"))/10*(parseInt(s(250,"hCuc"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x491640(253,"#6!u")](_0x491640(255,"3c[h"))!=_0x491640(267,"ePp["))throw window[_0x491640(258,"zBWe")][_0x491640(254,"&tPW")](_0x491640(277,"E)L)")),Error();document.title="Vue3 的 ReactiveEffect 类在功能上类似于 Vue2 的 Watcher 类",document.getElementById("article").innerHTML='<div><p>是的，Vue3 的 <code>ReactiveEffect</code> 类在功能上类似于 Vue2 的 <code>Watcher</code> 类，但两者在设计定位、实现机制和使用方式上存在本质差异。以下是详细对比：</p>\n<h3><strong>核心对比：设计理念的演进</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>Vue2 Watcher</strong></th>\n<th><strong>Vue3 ReactiveEffect</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>核心定位</strong></td>\n<td>面向用户的高层 API（用户直接使用）</td>\n<td>面向框架的底层实现（用户基本不会直接接触）</td>\n</tr>\n<tr>\n<td><strong>创建方式</strong></td>\n<td>通过 <code>watch</code> 选项、<code>$watch</code> 或 <code>computed</code> 创建</td>\n<td>通过 <code>effect()</code> 函数内部创建 <code>ReactiveEffect</code> 实例</td>\n</tr>\n<tr>\n<td><strong>依赖收集</strong></td>\n<td>手动指定监听的数据源（如 <code>\'user.name\'</code>）</td>\n<td>自动追踪函数体中访问的所有响应式数据</td>\n</tr>\n<tr>\n<td><strong>副作用触发</strong></td>\n<td>依赖变化时执行用户回调</td>\n<td>依赖变化时<strong>重新执行整个函数体</strong></td>\n</tr>\n<tr>\n<td><strong>实现机制</strong></td>\n<td>基于 <code>Object.defineProperty</code></td>\n<td>基于 ES6 Proxy</td>\n</tr>\n<tr>\n<td><strong>应用场景</strong></td>\n<td>数据变化的副作用处理（如日志、异步请求）</td>\n<td>渲染函数、计算属性、watch API 的底层实现</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>1. Vue2 Watcher 的工作方式</strong></h3>\n<p>在 Vue2 中，<code>Watcher</code> 是响应式系统的核心抽象：</p>\n<ul>\n<li><strong>用户直接使用</strong>  ：通过 <code>watch</code> 选项或 <code>this.$watch()</code> API 创建。</li>\n<li><strong>依赖明确指定</strong>  ：需要手动声明监听的路径（如 <code>\'user.name\'</code>）。</li>\n<li><strong>回调驱动</strong>  ：依赖变化时执行用户提供的回调函数。</li>\n</ul>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> {\n      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>\n    }\n  },\n  <span class="hljs-attr">watch</span>: {\n    <span class="hljs-title function_">count</span>(<span class="hljs-params">newVal, oldVal</span>) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Count changed from <span class="hljs-subst">${oldVal}</span> to <span class="hljs-subst">${newVal}</span>`</span>);\n    }\n  }\n}\n</code></pre>\n<h3><strong>2. Vue3 ReactiveEffect 的工作方式</strong></h3>\n<p>在 Vue3 中，<code>ReactiveEffect</code> 是响应式系统的底层核心：</p>\n<ul>\n<li><strong>框架内部使用</strong>  ：用户通过 <code>effect()</code>、<code>computed()</code>、<code>watch()</code> 等 API 间接使用。</li>\n<li><strong>自动依赖收集</strong>  ：通过执行函数体，自动追踪所有访问的响应式数据。</li>\n<li><strong>函数体重执行</strong>  ：依赖变化时重新执行整个函数体。</li>\n</ul>\n<p><strong>源码简化示例</strong>  ：</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// Vue3 ReactiveEffect 简化实现</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> {\n  active = <span class="hljs-literal">true</span>;\n  deps = []; <span class="hljs-comment">// 存储依赖</span>\n  \n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">\n    <span class="hljs-keyword">public</span> <span class="hljs-attr">fn</span>: <span class="hljs-title class_">Function</span>,\n    <span class="hljs-keyword">public</span> <span class="hljs-attr">scheduler</span>?: <span class="hljs-title class_">Function</span>\n  </span>) {}\n  \n  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span>) {\n      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fn</span>();\n    }\n    \n    <span class="hljs-comment">// 将当前 effect 设为全局激活状态</span>\n    activeEffect = <span class="hljs-variable language_">this</span>;\n    <span class="hljs-comment">// 执行副作用函数，触发响应式属性的 get trap</span>\n    <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fn</span>();\n    activeEffect = <span class="hljs-literal">null</span>;\n    <span class="hljs-keyword">return</span> result;\n  }\n  \n  <span class="hljs-comment">// 依赖变化时调用</span>\n  <span class="hljs-title function_">trigger</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">scheduler</span>) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">scheduler</span>();\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">// 重新执行函数体</span>\n    }\n  }\n}\n</code></pre>\n<h3><strong>3. 渲染 Watcher 在 Vue3 中的实现</strong></h3>\n<p>在 Vue3 中，组件的渲染函数由 <code>effect</code> 驱动：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 简化的渲染 effect 实现</span>\n<span class="hljs-keyword">const</span> effect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactiveEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> vnode = component.<span class="hljs-title function_">render</span>(); <span class="hljs-comment">// 执行用户编写的 render 函数</span>\n  <span class="hljs-title function_">patch</span>(vnode);                     <span class="hljs-comment">// 更新 DOM</span>\n});\n\n<span class="hljs-comment">// 首次执行渲染</span>\neffect.<span class="hljs-title function_">run</span>();\n\n<span class="hljs-comment">// 当响应式数据变化时，trigger 会重新执行 effect</span>\n</code></pre>\n<h3><strong>4. Vue3 中用户侧的 Watch API</strong></h3>\n<p>Vue3 提供了更灵活的 <code>watch</code> 和 <code>watchEffect</code> API，它们基于 <code>ReactiveEffect</code> 实现：</p>\n<h4><strong>4.1 <code>watch</code>（类似 Vue2 的 <code>watch</code> 选项）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { ref, watch } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;\n\n<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n\n<span class="hljs-title function_">watch</span>(count, <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Count changed: <span class="hljs-subst">${newVal}</span>`</span>);\n});\n</code></pre>\n<h4><strong>4.2 <code>watchEffect</code>（自动追踪依赖）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { ref, watchEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;\n\n<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n\n<span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 自动追踪 count.value 作为依赖</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Count is: <span class="hljs-subst">${count.value}</span>`</span>);\n});\n</code></pre>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>功能类似</strong>  ：<code>ReactiveEffect</code> 和 <code>Watcher</code> 都负责依赖收集和副作用触发。</li>\n<li><strong>设计差异</strong>  ：\n<ul>\n<li>Vue2 的 <code>Watcher</code> 是用户直接操作的高层类，需要手动管理依赖。</li>\n<li>Vue3 的 <code>ReactiveEffect</code> 是框架内部使用的底层类，通过自动依赖收集和函数体重执行简化了实现。</li>\n</ul>\n</li>\n<li><strong>用户体验</strong>  ：Vue3 通过 <code>watch</code> 和 <code>watchEffect</code> 等 API 提供了更友好的用户接口，隐藏了 <code>ReactiveEffect</code> 的复杂性。</li>\n</ul>\n<p>理解这些差异有助于更好地掌握 Vue3 的响应式原理，并在开发中正确使用相关 API。</p>\n</div>'</script></body></html>