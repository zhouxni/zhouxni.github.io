<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0xa30032=_0x142b;function _0x142b(r,n){var o=_0x2acd();return(_0x142b=function(n,s){var t=o[n-=176];void 0===_0x142b.WouuCx&&(_0x142b.BtHVTo=function(n,s){var t,a=[],r=0,o="";for(n=(n=>{for(var s,t,a="",r="",o=0,e=0;t=n.charAt(e++);~t&&(s=o%4?64*s+t:t,o++%4)&&(a+=String.fromCharCode(255&s>>(-2*o&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var p=0,l=a.length;p<l;p++)r+="%"+("00"+a.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(r)})(n),e=0;e<256;e++)a[e]=e;for(e=0;e<256;e++)r=(r+a[e]+s.charCodeAt(e%s.length))%256,t=a[e],a[e]=a[r],a[r]=t;for(var e=0,r=0,p=0;p<n.length;p++)t=a[e=(e+1)%256],a[e]=a[r=(r+a[e])%256],a[r]=t,o+=String.fromCharCode(n.charCodeAt(p)^a[(a[e]+a[r])%256]);return o},r=arguments,_0x142b.WouuCx=!0);var n=n+o[0],a=r[n];return a?t=a:(void 0===_0x142b.yXfTwK&&(_0x142b.yXfTwK=!0),t=_0x142b.BtHVTo(t,s),r[n]=t),t})(r,n)}function _0x2acd(){var n=["geRdPSo8jmoWE35oW75NWQyl","W48eWPjiWQaucJ1VqqRdHNu","sK7cQ8kxf8k6W5O","iNe9p8ovvdVdVgdcPmkHWQnCEG","n8kWWQNcNmkTEf/cTmoOhXvWbW","WR7dVSklW5iJW6OucW5LAH3cNq","wq/cO8k5BG","qCojEdyxsmok","W5frjGxdOhjnfhFdGSo8wq","g0VcQmkPwCk8lhK","nmk0WQNcN8kSEf/cQCo2bH1geW","ge7dQmo/imo3C05MW4bFWO0v","WQ8cpCoTWOtdGCo2WPqhncG","W75DW71iWRPpW7ZcRW/cQ8orpN3dTq","W7ziomoLW4GJW60","iSk9fmoPDmotWOvWWRRcTmoTjHy","FmkKW7GcWOPNEKPVwXxdT8ko","qq7cPmk6zmo/zdLeW7PHWRCDWQVdV8o0WRxcTtVcPraoWO7cLqVcKW","qwjiW7pcNryUW7C","W57cHYqVoXlcGSoP","W5JdIgCxWRyMW74","W40eWPDiWQirvtnRxZBdUa","WRPwW4aAW6jsDdXX","WRynW6KCWP0BWPNdUG/cS1i"];return(_0x2acd=function(){return n})()}if((()=>{for(var n=_0x142b,s=_0x2acd();;)try{if(361098==-parseInt(n(186,"2A9W"))+-parseInt(n(177,"hq7*"))/2*(parseInt(n(184,"]fo@"))/3)+parseInt(n(193,"UNj@"))/4*(-parseInt(n(191,"8yZu"))/5)+-parseInt(n(189,"1BA@"))/6+parseInt(n(180,"Dwn*"))/7+-parseInt(n(176,"1BA@"))/8+parseInt(n(178,"Ejxc"))/9)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0xa30032(179,"U(#V")](_0xa30032(187,"2A9W"))!=_0xa30032(195,"1BA@"))throw window[_0xa30032(183,"SfgJ")][_0xa30032(196,"4#[G")](_0xa30032(182,"1BA@")),Error();document.title="js 同步多次操作真实 dom",document.getElementById("article").innerHTML='<div><p>在 JavaScript 中，<strong>同步的多次 DOM 操作默认不会自动合并</strong>  ，但浏览器会通过一些优化机制（如渲染队列）来减少不必要的重排（Reflow）和重绘（Repaint）。以下是详细分析：</p>\n<hr>\n<h3><strong>一、核心结论</strong></h3>\n<ol>\n<li><strong>不会自动合并操作</strong>  ：每次同步的 DOM 修改都会触发浏览器的样式计算和布局更新。</li>\n<li><strong>但浏览器会优化渲染流程</strong>  ：通过 <strong>渲染队列（Render Queue）</strong>   延迟合并连续操作，避免多次重排。</li>\n<li><strong>强制同步布局（Forced Synchronous Layout）</strong>   会破坏优化：某些操作会强制立即重排，导致性能问题。</li>\n</ol>\n<hr>\n<h3><strong>二、关键机制解析</strong></h3>\n<h4><strong>1. 渲染队列（Render Queue）</strong></h4>\n<p>浏览器会将连续的 DOM 操作暂存到队列中，在下一个 <strong>渲染帧（Frame）</strong>   前批量处理。<br>\n<strong>示例</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 以下操作会被浏览器优化，只触发一次重排</span>\ndiv.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">&#x27;100px&#x27;</span>;\ndiv.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">&#x27;200px&#x27;</span>;\ndiv.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span>;\n</code></pre>\n<ul>\n<li><strong>优化后</strong>  ：浏览器合并修改，仅触发一次重排。</li>\n</ul>\n<h4><strong>2. 强制同步布局（性能杀手）</strong></h4>\n<p>如果在读取布局属性（如 <code>offsetWidth</code>、<code>getComputedStyle</code>）前有未处理的 DOM 修改，浏览器会 <strong>立即强制重排</strong>  ，破坏队列优化。<br>\n<strong>反例</strong>  ：</p>\n<pre><code class="language-javascript">div.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">&#x27;100px&#x27;</span>;  <span class="hljs-comment">// 修改样式（加入渲染队列）</span>\n<span class="hljs-keyword">const</span> width = div.<span class="hljs-property">offsetWidth</span>; <span class="hljs-comment">// 读取布局属性 → 强制立即重排！</span>\ndiv.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">&#x27;200px&#x27;</span>; <span class="hljs-comment">// 再次触发重排</span>\n</code></pre>\n<ul>\n<li><strong>结果</strong>  ：触发 <strong>两次重排</strong>  （性能差）。</li>\n</ul>\n<hr>\n<h3><strong>三、如何主动合并 DOM 操作？</strong></h3>\n<h4><strong>方法 1：使用 <code>requestAnimationFrame</code></strong></h4>\n<p>将操作放到下一帧前统一处理：</p>\n<pre><code class="language-javascript"><span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-function">() =&gt;</span> {\n  div.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">&#x27;100px&#x27;</span>;\n  div.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">&#x27;200px&#x27;</span>;\n});\n</code></pre>\n<h4><strong>方法 2：使用 CSS <code>class</code> 或 <code>cssText</code></strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 一次性修改多个样式</span>\ndiv.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;new-style&#x27;</span>; \n\n<span class="hljs-comment">// 或</span>\ndiv.<span class="hljs-property">style</span>.<span class="hljs-property">cssText</span> = <span class="hljs-string">&#x27;width: 100px; height: 200px; color: red;&#x27;</span>;\n</code></pre>\n<h4><strong>方法 3：使用文档片段（DocumentFragment）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {\n  <span class="hljs-keyword">const</span> item = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);\n  fragment.<span class="hljs-title function_">appendChild</span>(item);\n}\n<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(fragment); <span class="hljs-comment">// 仅一次重排</span>\n</code></pre>\n<hr>\n<h3><strong>四、性能对比测试</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>操作方式</strong></th>\n<th>重排次数</th>\n<th>性能影响</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>同步多次修改样式</td>\n<td>1次（优化后）</td>\n<td>✅ 最佳</td>\n</tr>\n<tr>\n<td>强制同步布局（读取布局属性）</td>\n<td>多次</td>\n<td>❌ 最差</td>\n</tr>\n<tr>\n<td>使用 <code>requestAnimationFrame</code></td>\n<td>1次</td>\n<td>✅ 好</td>\n</tr>\n<tr>\n<td>使用 <code>DocumentFragment</code></td>\n<td>1次</td>\n<td>✅ 好</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>五、特殊情况：现代框架的优化</strong></h3>\n<p>React/Vue 等框架使用 <strong>虚拟 DOM</strong>   或 <strong>增量 DOM</strong>   技术，在内存中计算差异后批量更新真实 DOM，本质上也是合并操作。</p>\n<hr>\n<h3><strong>六、总结</strong></h3>\n<ol>\n<li><strong>默认情况</strong>  ：同步 DOM 操作会被浏览器优化，但需避免强制同步布局。</li>\n<li><strong>最佳实践</strong>  ：</li>\n</ol>\n<ul>\n<li>集中修改样式或类名。</li>\n<li>避免在修改后立即读取布局属性。</li>\n<li>复杂操作使用 <code>DocumentFragment</code> 或 <code>requestAnimationFrame</code>。</li>\n</ul>\n<ol start="3">\n<li><strong>调试工具</strong>  ：用 Chrome DevTools 的 <strong>Performance 面板</strong>   检测重排（Recalculate Style 和 Layout 事件）。</li>\n</ol>\n<p>理解这些机制可以显著提升 Web 应用的渲染性能！</p>\n</div>'</script></body></html>