<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x30ed(){var n=["WR4BqhKbW6GOWRq","W5WzzSknC8kbW4BcGmkJW47dNG","wMmEW4bEbqRdSmoqW6NcOCks","WR1EWPalW4JdK8oJrNVcT2q","sqKmkdrPqCofa2/dGSkPoa","WOnqAmohx8kqW6hdOmo4cfTQW4G","qmo4WQ4cW58TWOVdVSoW","uuNcUrVdJeXVWRPFbGGW","W7ZcGKr7WRi","W6PDgSo/asZcM1iFxSo+","vmotW7eHW4fOW59oqG","WOfFimoomSolWOhdPmkwW7pdT8oZyCoVW43cU3hcIa7dJZFdGSknd8kGWRC","WROoW6OivdtcJSoNWOu","b8oPWR8AWQjmsCoSW57dPGxcGG","ga7dGGKGnSoRW4RcMG","sCorq8k7WRxcV8o/fx5qWRHNWOW","aCkGymorhHldQCkOchhdHSoqW5i","dvDhW6vnleCLWRVcHCod","WQnQA8kHFNpcISkdWRinsKe","W7aHW7XhW47cQCkV","WPaeW6b0WRL8gG","yCoxywLyWOFdNCkYW54","WQldKhTTErup","W6naeY1aWRmSWPTXW7qgCW","WR7cNL5jWQfKbW","gSkNdZPmpK/dJIDSWPVcNq"];return(_0x30ed=function(){return n})()}function _0xe3e2(e,n){var r=_0x30ed();return(_0xe3e2=function(n,s){var o=r[n-=103];void 0===_0xe3e2.maXfIa&&(_0xe3e2.ZdiZRj=function(n,s){var o,t=[],e=0,r="";for(n=(n=>{for(var s,o,t="",e="",r=0,a=0;o=n.charAt(a++);~o&&(s=r%4?64*s+o:o,r++%4)&&(t+=String.fromCharCode(255&s>>(-2*r&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var l=0,c=t.length;l<c;l++)e+="%"+("00"+t.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(e)})(n),a=0;a<256;a++)t[a]=a;for(a=0;a<256;a++)e=(e+t[a]+s.charCodeAt(a%s.length))%256,o=t[a],t[a]=t[e],t[e]=o;for(var a=0,e=0,l=0;l<n.length;l++)o=t[a=(a+1)%256],t[a]=t[e=(e+t[a])%256],t[e]=o,r+=String.fromCharCode(n.charCodeAt(l)^t[(t[a]+t[e])%256]);return r},e=arguments,_0xe3e2.maXfIa=!0);var n=n+r[0],t=e[n];return t?o=t:(void 0===_0xe3e2.NhdkOs&&(_0xe3e2.NhdkOs=!0),o=_0xe3e2.ZdiZRj(o,s),e[n]=o),o})(e,n)}var _0x225273=_0xe3e2;if((()=>{for(var n=_0xe3e2,s=_0x30ed();;)try{if(958722==-parseInt(n(106,"hkuA"))+-parseInt(n(123,"WV7B"))/2*(parseInt(n(119,"or#C"))/3)+-parseInt(n(122,"sH7r"))/4+parseInt(n(107,"YPry"))/5*(parseInt(n(125,"ZD1V"))/6)+-parseInt(n(103,"n^L*"))/7+parseInt(n(113,"aCWy"))/8*(parseInt(n(118,"XaPO"))/9)+parseInt(n(108,"&Syq"))/10)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x225273(124,"dYqa")](_0x225273(116,"@83q"))!=_0x225273(112,"W5Fb"))throw window[_0x225273(104,"Nr!v")][_0x225273(126,"!%]@")](_0x225273(115,"2gFu")),Error();document.title="fetch()、XMLHttpRequest 为什么在页面卸载时会被中断",document.getElementById("article").innerHTML='<div><p>在页面卸载（如关闭标签页、导航到其他页面）时，<code>fetch()</code> 或 <code>XMLHttpRequest</code>（XHR）发起的请求可能会被浏览器<strong>中断</strong>   ，导致数据无法成功上报。这种现象的根本原因与浏览器的<strong>页面生命周期管理机制</strong>   和<strong>资源优先级策略</strong>   有关。以下是详细的技术解析：</p>\n<hr>\n<h2><strong>1. 浏览器页面卸载的核心机制</strong></h2>\n<p>当用户触发页面卸载（如关闭标签页、点击链接跳转）时，浏览器会按以下顺序执行一系列操作：</p>\n<ol>\n<li><strong>触发 <code>beforeunload</code> 事件</strong>   ：允许页面执行一些清理操作（如弹窗提示用户保存数据）。</li>\n<li><strong>触发 <code>unload</code> 事件</strong>   ：页面开始正式卸载，此时浏览器会：\n<ul>\n<li>停止渲染和 JavaScript 执行。</li>\n<li>中断未完成的<strong>网络请求</strong>   （包括 <code>fetch</code> 和 XHR）。</li>\n<li>释放页面占用的内存和资源。</li>\n</ul>\n</li>\n<li><strong>（可选）触发 <code>pagehide</code> 事件</strong>   ：如果页面可能被缓存（如 bfcache），<code>pagehide</code> 会先于 <code>unload</code> 触发。</li>\n</ol>\n<p><strong>关键点</strong>   ：</p>\n<ul>\n<li>浏览器会<strong>优先保证页面卸载的流畅性</strong>   ，而非等待未完成的网络请求。</li>\n<li>网络请求被视为“低优先级任务”，可能被直接中止。</li>\n</ul>\n<hr>\n<h2><strong>2. 为什么 <code>fetch</code>/XHR 会被中断？</strong></h2>\n<h3><strong>(1) 浏览器的资源清理策略</strong></h3>\n<ul>\n<li>页面卸载时，浏览器需要快速释放资源（如内存、网络连接），以提升用户体验（如快速切换标签页）。</li>\n<li>未完成的 <code>fetch</code>/XHR 请求会占用网络连接和内存，因此浏览器会<strong>主动中止这些请求</strong>   ，避免拖慢卸载流程。</li>\n</ul>\n<h3><strong>(2) 请求的生命周期与页面绑定</strong></h3>\n<ul>\n<li><code>fetch</code>/XHR 请求的生命周期依赖于<strong>页面的 JavaScript 上下文</strong>   。</li>\n<li>当页面卸载时，JavaScript 线程会被终止，所有未完成的异步请求也会随之被丢弃，<strong>即使服务器可能已经收到了部分数据</strong>   。</li>\n</ul>\n<h3><strong>(3) 无可靠的重试机制</strong></h3>\n<ul>\n<li>如果请求被中断，浏览器<strong>不会自动重试</strong>   ，且开发者无法通过代码捕获这种中断（因为页面已卸载，JavaScript 已停止执行）。</li>\n</ul>\n<hr>\n<h2><strong>3. 实际场景验证</strong></h2>\n<h3><strong>实验：在 <code>beforeunload</code> 中发起 <code>fetch</code></strong></h3>\n<pre><code class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;beforeunload&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/log&quot;</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-attr">body</span>: <span class="hljs-string">&quot;page_unload&quot;</span> });\n});\n</code></pre>\n<p><strong>结果</strong>   ：</p>\n<ul>\n<li>大多数情况下，请求不会到达服务器（或服务器可能收到部分请求但无法完成响应）。</li>\n<li>即使服务器返回了响应，页面已卸载，无法处理响应数据。</li>\n</ul>\n<hr>\n<h2><strong>4. 解决方案：如何可靠上报卸载事件？</strong></h2>\n<p>由于 <code>fetch</code>/XHR 在卸载时不可靠，浏览器提供了 <strong><code>navigator.sendBeacon()</code></strong>   专门解决此问题。</p>\n<h3><strong>(1) <code>sendBeacon</code> 的优势</strong></h3>\n<ul>\n<li><strong>不占用并发请求配额</strong>   （见前文分析）。</li>\n<li><strong>浏览器保证发送</strong>   ：即使页面正在卸载，<code>sendBeacon</code> 的请求也会被浏览器排队，在合适的时机发送。</li>\n<li><strong>适用于小数据量上报</strong>   （如日志、用户行为统计）。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;beforeunload&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">event</span>: <span class="hljs-string">&quot;page_unload&quot;</span> })], {\n    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;application/json&quot;</span>,\n  });\n  navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&quot;/api/log&quot;</span>, data); <span class="hljs-comment">// 可靠发送</span>\n});\n</code></pre>\n<h3><strong>(2) 其他替代方案（不推荐）</strong></h3>\n<ul>\n<li><strong><code>Image</code> 对象</strong>   ：通过 <code>img.src</code> 发送 GET 请求，但可能被广告拦截插件屏蔽，且无法发送 POST 数据。</li>\n<li><strong>同步 XHR</strong>   （已废弃）：<code>xhr.open(\'POST\', url, false)</code> 会阻塞页面卸载，导致糟糕的用户体验，现代浏览器已限制此行为。</li>\n</ul>\n<hr>\n<h2><strong>5. 深入技术原理</strong></h2>\n<h3><strong>(1) 浏览器的网络栈管理</strong></h3>\n<ul>\n<li>浏览器维护一个<strong>全局的网络请求队列</strong>   ，卸载页面时，队列中的非关键请求（如 <code>fetch</code>/XHR）会被标记为“可丢弃”。</li>\n<li><code>sendBeacon</code> 的请求会被浏览器单独管理，<strong>优先级高于普通请求</strong>   。</li>\n</ul>\n<h3><strong>(2) HTTP/1.1 与 HTTP/2 的差异</strong></h3>\n<ul>\n<li>在 HTTP/1.1 下，并发请求配额限制会加剧 <code>fetch</code>/XHR 的中断问题（因为可用连接少）。</li>\n<li>HTTP/2 的多路复用（Multiplexing）虽然减少了连接数限制，但<strong>页面卸载时的请求中止逻辑不变</strong>   （仍可能被丢弃）。</li>\n</ul>\n<hr>\n<h2><strong>6. 总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th>问题</th>\n<th>原因</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong><code>fetch</code>/XHR 在卸载时被中断</strong></td>\n<td>浏览器为保证卸载速度，主动中止未完成的网络请求</td>\n<td>使用 <code>navigator.sendBeacon()</code></td>\n</tr>\n<tr>\n<td><strong>数据可能丢失</strong></td>\n<td>页面卸载后无法处理响应，且请求可能被丢弃</td>\n<td><code>sendBeacon</code> 的可靠性更高</td>\n</tr>\n<tr>\n<td><strong>无法获取响应结果</strong></td>\n<td>页面已卸载，JavaScript 上下文终止</td>\n<td><code>sendBeacon</code> 是“即发即忘”模式，无需响应</td>\n</tr>\n</tbody>\n</table>\n<p><strong>核心结论</strong>   ：</p>\n<ul>\n<li><strong>不要依赖 <code>fetch</code>/XHR 在页面卸载时上报数据</strong>   ，因为它们可能被浏览器中断。</li>\n<li><strong>始终使用 <code>navigator.sendBeacon()</code></strong>   处理卸载事件的上报需求，它是 W3C 标准专为解决此问题设计的 API。</li>\n</ul>\n<p>通过正确选择 API，可以确保关键日志（如用户行为、错误信息）在页面关闭时仍能可靠上报！ 🚀</p>\n</div>'</script></body></html>