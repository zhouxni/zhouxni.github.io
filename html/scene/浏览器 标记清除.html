<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x63e0(){var n=["W43cUd4fWRxdM3y","uYmQWPO+WP9U","ECkxcCodW7xcOW7dSCoXWOOhEa","W5xdQSoAWQ5OrGBdPIrl","W74Igay8FmkLW4lcVSo9WQxcIW","W7ClW6FcMmkwx8kxWOG/a8opyW","W6xcOcVdJSozDGXKWQi","W753nmkgp8oACM02WOBcGYS","Au/dO8kvW70rWOy","e8o6WPhdUdpdMCofFG","WOBcQSkcD8oZwmkbn8oyW4NcM8o0WPS","pSklWQ3dGmkbrSoM","WQNdGCkBW7tdQh9KiCkZW6jffCog","WRRdOmkcf2pcVZmNWQJcTaBdTCk6","WRO3C8obCW","FSkvd8ooW7dcPLtdOCokWPeUxmob","WPrBW5FdIwFcOmoxW7O","W4NcMConW59sW5hdHMW2zrRdOa","gSo7W6/cV3/cMSkzBtldT8orcmoe","ldlcGmojW7avp3q","bCoDiSksWO/cJ37dOSksqq","FXRdJSkXgSoKWP3cL8k4WOf3FW","W40EifNcHSoom8ofr8obWPpdKSkM","rxVdM1CreSk2W5rnWOBdJLBdH8kdt2BcJH/dJCkVBmkMdKazWRW"];return(_0x63e0=function(){return n})()}function _0x7320(l,n){var s=_0x63e0();return(_0x7320=function(n,o){var r=s[n-=453];void 0===_0x7320.RZntbV&&(_0x7320.RapnOw=function(n,o){var r,t=[],l=0,s="";for(n=(n=>{for(var o,r,t="",l="",s=0,g=0;r=n.charAt(g++);~r&&(o=s%4?64*o+r:r,s++%4)&&(t+=String.fromCharCode(255&o>>(-2*s&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var e=0,i=t.length;e<i;e++)l+="%"+("00"+t.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(l)})(n),g=0;g<256;g++)t[g]=g;for(g=0;g<256;g++)l=(l+t[g]+o.charCodeAt(g%o.length))%256,r=t[g],t[g]=t[l],t[l]=r;for(var g=0,l=0,e=0;e<n.length;e++)r=t[g=(g+1)%256],t[g]=t[l=(l+t[g])%256],t[l]=r,s+=String.fromCharCode(n.charCodeAt(e)^t[(t[g]+t[l])%256]);return s},l=arguments,_0x7320.RZntbV=!0);var n=n+s[0],t=l[n];return t?r=t:(void 0===_0x7320.JekplZ&&(_0x7320.JekplZ=!0),r=_0x7320.RapnOw(r,o),l[n]=r),r})(l,n)}var _0x573307=_0x7320;if((()=>{for(var n=_0x7320,o=_0x63e0();;)try{if(404258==+parseInt(n(470,"gfRh"))+parseInt(n(474,"u&IC"))/2*(-parseInt(n(468,"fus]"))/3)+-parseInt(n(462,"J3k]"))/4+-parseInt(n(459,"u&IC"))/5+-parseInt(n(465,"(gkI"))/6*(-parseInt(n(475,"TjZD"))/7)+-parseInt(n(456,"vxpu"))/8+parseInt(n(472,"&Yob"))/9)break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x573307(466,"Btfw")](_0x573307(471,"BxC]"))!=_0x573307(455,"&Yob"))throw window[_0x573307(457,"1i5e")][_0x573307(473,"dBcY")](_0x573307(464,")BIN")),Error();document.title="浏览器 标记清除",document.getElementById("article").innerHTML="<div><p>在浏览器的 JavaScript 引擎中，<strong>标记清除（Mark and Sweep）</strong>   是一种最常见的垃圾回收（Garbage Collection, GC）算法，用于自动回收不再使用的内存。以下是它的工作原理、优缺点及相关优化：</p>\n<h3><strong>1. 核心概念</strong></h3>\n<ul>\n<li><strong>可达性（Reachability）</strong>  ：JavaScript 引擎将对象分为两类：\n<ul>\n<li><strong>可达对象</strong>  ：被根对象（如全局变量、调用栈中的变量）直接或间接引用的对象。</li>\n<li><strong>不可达对象</strong>  ：没有任何引用指向的对象，会被视为垃圾。</li>\n</ul>\n</li>\n<li><strong>根对象（Roots）</strong>  ：包括：\n<ul>\n<li>全局变量（如 <code>window</code> 对象）。</li>\n<li>当前函数调用栈中的变量和参数。</li>\n<li>浏览器中的 DOM 节点。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>2. 标记清除算法步骤</strong></h3>\n<h4><strong>阶段一：标记（Mark）</strong></h4>\n<ol>\n<li><strong>从根对象开始遍历</strong>  ：JavaScript 引擎从根对象出发，递归地标记所有可达对象。</li>\n<li><strong>标记存活对象</strong>  ：为每个可达对象添加标记（如设置内部标志位 <code>marked = true</code>）。</li>\n</ol>\n<h4><strong>阶段二：清除（Sweep）</strong></h4>\n<ol>\n<li><strong>遍历堆内存</strong>  ：检查所有对象。</li>\n<li><strong>回收未标记对象</strong>  ：清除未被标记的对象（即不可达对象），释放其占用的内存。</li>\n<li><strong>重置标记</strong>  ：将所有标记重置为未标记状态（<code>marked = false</code>），为下一次 GC 做准备。</li>\n</ol>\n<h3><strong>3. 示例说明</strong></h3>\n<p>假设内存中有以下对象结构：</p>\n<pre><code>根对象 (Root)\n├── 对象 A\n│   └── 对象 B\n└── 对象 C\n    └── 对象 D\n</code></pre>\n<p><strong>步骤 1</strong>  ：标记阶段<br>\n从根对象出发，标记 A、B、C、D 为可达对象。</p>\n<p><strong>步骤 2</strong>  ：清除阶段<br>\n若此时根对象断开对 C 的引用：</p>\n<pre><code>根对象 (Root)\n├── 对象 A\n│   └── 对象 B\n└── 对象 C    // 不再可达\n    └── 对象 D // 不再可达\n</code></pre>\n<p>GC 将回收 C 和 D 占用的内存。</p>\n<h3><strong>4. 优缺点</strong></h3>\n<h4><strong>优点</strong></h4>\n<ul>\n<li><strong>实现简单</strong>  ：标记和清除两个阶段逻辑清晰。</li>\n<li><strong>兼容性好</strong>  ：适用于大多数场景，是主流 GC 算法。</li>\n</ul>\n<h4><strong>缺点</strong></h4>\n<ul>\n<li><strong>内存碎片化</strong>  ：清除后可能产生大量不连续的内存碎片，导致后续分配大对象时效率降低。</li>\n<li><strong>STW（Stop The World）</strong>  ：GC 执行时会暂停 JavaScript 执行，影响性能（尤其是长耗时的 GC）。</li>\n</ul>\n<h3><strong>5. 现代浏览器的优化</strong></h3>\n<h4><strong>分代垃圾回收（Generational GC）</strong></h4>\n<ul>\n<li><strong>新生代（Young Generation）</strong>  ：存放新创建的对象（如局部变量），生命周期短，GC 频繁。</li>\n<li><strong>老生代（Old Generation）</strong>  ：存放长期存活的对象（如全局变量），生命周期长，GC 频率低。</li>\n<li><strong>优化逻辑</strong>  ：新生代使用 <strong>复制算法</strong>  （更快），老生代使用 <strong>标记清除 + 标记整理</strong>  （减少碎片）。</li>\n</ul>\n<h4><strong>增量标记（Incremental Marking）</strong></h4>\n<ul>\n<li><strong>原理</strong>  ：将标记阶段拆分为多个小步骤，穿插在 JavaScript 执行过程中，减少单次 STW 的时间。</li>\n<li><strong>示例</strong>  ：Chrome 的 V8 引擎使用增量标记优化 GC 性能。</li>\n</ul>\n<h4><strong>并发清除（Concurrent Sweep）</strong></h4>\n<ul>\n<li><strong>原理</strong>  ：在 JavaScript 执行的同时进行清除操作，进一步减少 STW 时间。</li>\n</ul>\n<h4><strong>内存整理（Mark-Compact）</strong></h4>\n<ul>\n<li><strong>原理</strong>  ：在清除阶段后，将存活对象移动到连续内存区域，消除碎片。</li>\n<li><strong>适用场景</strong>  ：老生代中频繁使用。</li>\n</ul>\n<h3><strong>6. 对开发者的影响</strong></h3>\n<ul>\n<li><strong>减少全局变量</strong>  ：全局变量会一直被根对象引用，导致内存无法回收。</li>\n<li><strong>及时释放引用</strong>  ：不再使用的对象应手动设为 <code>null</code>（如 <code>obj = null</code>）。</li>\n<li><strong>避免闭包陷阱</strong>  ：闭包会引用外部函数的变量，导致这些变量无法被回收。</li>\n<li><strong>优化大数据处理</strong>  ：处理大量数据时，分批操作比一次性操作更不易触发长时间的 GC。</li>\n</ul>\n<h3><strong>7. 性能监控工具</strong></h3>\n<ul>\n<li><strong>Chrome DevTools</strong>  ：通过 Memory 面板分析内存使用和 GC 情况。</li>\n<li><strong>Performance API</strong>  ：通过 <code>performance.memory</code> 监控堆内存使用。</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<p>标记清除是浏览器垃圾回收的基础算法，现代浏览器通过分代回收、增量标记等优化提升了性能。理解其工作原理有助于开发者写出更高效、更节省内存的代码，减少 GC 带来的性能损耗。</p>\n</div>"</script></body></html>