<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2446(){var s=["k8oHW6WRea","C1BcK8oDWQRdJmksCmoKW7LBWQddVa","fKLlW5OGmMHi","W6GUWQVdUqatW7y/n8klWQ3dKWu","cSkQW6DMicHaWQa","WOfBW4G6WRRcLSokl05gW5JcUCoS","eLddQCkAq8kBW6BdS3P+WPFcSq","WOW4axFdVCkiW7XfsmkUW47dNMW","vqv1WO/cTmotfW","EfdcK8oCWQBdI8oUsCoDW41sWR0","cqtdSvO0W68snSkHlCo+WOVdKW","d8kNWO4YD1yrWQGqW43cVaqP","W5FcVwvKWPVcGfGnW7NcHSkSCIe","eqCQWPTMoCoSW5vjWONdPKLo","cSkoW6vIW4Xhy1O","d8kaWO03WPe/n3/dO8kvdraZ","WQfWWOCPW7tcQr4","tmo+WOpdPwSXWQeYWOi","vNJcL8k4hwJdQvhcHSk3nKC","m8oGW6SOgSkFWR0CWOeYW5/dICoGW5FcI8kRWPy0W6xcO8kvxaSYW7bi","W4PPamk2WR0Pmmo0W4RdKCoEDW"];return(_0x2446=function(){return s})()}function _0x1daf(t,s){var p=_0x2446();return(_0x1daf=function(s,n){var a=p[s-=414];void 0===_0x1daf.whAwhF&&(_0x1daf.zslRVN=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=l.length;c<r;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[t],l[t]=a;for(var e=0,t=0,c=0;c<s.length;c++)a=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[t])%256]);return p},t=arguments,_0x1daf.whAwhF=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x1daf.GmyKRn&&(_0x1daf.GmyKRn=!0),a=_0x1daf.zslRVN(a,n),t[s]=a),a})(t,s)}var _0x36d875=_0x1daf;if((()=>{for(var s=_0x1daf,n=_0x2446();;)try{if(565980==+parseInt(s(425,"$^g7"))+-parseInt(s(428,"scLt"))/2+parseInt(s(426,"n&V)"))/3+parseInt(s(434,"$w1R"))/4+parseInt(s(420,"scLt"))/5+parseInt(s(432,"Q(rv"))/6+-parseInt(s(422,"9WnF"))/7*(parseInt(s(433,"$w1R"))/8))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x36d875(414,"QZxu")](_0x36d875(415,"hf)Y"))!=_0x36d875(419,"zeL2"))throw window[_0x36d875(421,"z5g6")][_0x36d875(427,"uj&x")](_0x36d875(417,"zeL2")),Error();document.title="为什么建议传递给 setState的参数是一个 callback",document.getElementById("article").innerHTML='<div><p>在 React 中，建议传递给 <code>setState</code> 的参数是一个回调函数，而不是直接传递一个对象，主要有以下几个原因：</p>\n<hr>\n<h3><strong>1. 确保状态更新基于最新的状态</strong></h3>\n<ul>\n<li><strong>异步特性</strong>  ：\n<ul>\n<li>React 的 <code>setState</code> 是异步的，这意味着多次调用 <code>setState</code> 可能会导致状态更新被合并，而不是立即执行。</li>\n<li>如果直接传递一个对象，可能会因为状态更新的异步性而导致基于旧状态的计算不准确。</li>\n</ul>\n</li>\n<li><strong>回调函数的优势</strong>  ：\n<ul>\n<li>通过传递一个回调函数，可以确保状态更新是基于最新的状态值。</li>\n<li>回调函数接收两个参数：<code>prevState</code>（当前的状态）和 <code>props</code>（当前的属性），允许你根据最新的状态进行计算。</li>\n</ul>\n</li>\n</ul>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-jsx"><span class="hljs-comment">// 直接传递对象，可能导致状态更新不准确</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> });\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> });\n<span class="hljs-comment">// 由于 setState 是异步的，最终的 count 可能只增加了 1，而不是 2</span>\n\n<span class="hljs-comment">// 使用回调函数，确保状态更新基于最新的状态</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">prevState</span>) =&gt;</span> ({ <span class="hljs-attr">count</span>: prevState.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> }));\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">prevState</span>) =&gt;</span> ({ <span class="hljs-attr">count</span>: prevState.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> }));\n<span class="hljs-comment">// 最终的 count 会正确地增加 2</span>\n</code></pre>\n<hr>\n<h3><strong>2. 避免状态更新被覆盖</strong></h3>\n<ul>\n<li><strong>合并更新</strong>  ：\n<ul>\n<li>React 会合并多次 <code>setState</code> 调用，以减少渲染次数。</li>\n<li>如果直接传递一个对象，后续的状态更新可能会覆盖之前的更新。</li>\n</ul>\n</li>\n<li><strong>回调函数的解决方案</strong>  ：\n<ul>\n<li>使用回调函数可以确保每次状态更新都是基于最新的状态，避免更新被覆盖。</li>\n</ul>\n</li>\n</ul>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-jsx"><span class="hljs-comment">// 直接传递对象，可能导致更新被覆盖</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> }); <span class="hljs-comment">// 假设当前 count 为 0，更新为 1</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">2</span> }); <span class="hljs-comment">// 由于异步性，可能仍然基于旧的 count（0），更新为 2</span>\n\n<span class="hljs-comment">// 使用回调函数，确保更新基于最新的状态</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">prevState</span>) =&gt;</span> ({ <span class="hljs-attr">count</span>: prevState.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> })); <span class="hljs-comment">// 更新为 1</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">prevState</span>) =&gt;</span> ({ <span class="hljs-attr">count</span>: prevState.<span class="hljs-property">count</span> + <span class="hljs-number">2</span> })); <span class="hljs-comment">// 更新为 3</span>\n</code></pre>\n<hr>\n<h3><strong>3. 提高代码的可读性和可维护性</strong></h3>\n<ul>\n<li><strong>明确依赖关系</strong>  ：\n<ul>\n<li>使用回调函数可以明确地表示状态更新依赖于之前的状态，使代码更易于理解和维护。</li>\n</ul>\n</li>\n<li><strong>减少错误</strong>  ：\n<ul>\n<li>直接传递对象可能会导致难以发现的错误，特别是在状态更新逻辑复杂的情况下。</li>\n<li>使用回调函数可以减少这类错误的发生。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>4. 适应复杂的状态更新逻辑</strong></h3>\n<ul>\n<li><strong>复杂计算</strong>  ：\n<ul>\n<li>在某些情况下，状态更新可能涉及复杂的计算或逻辑。</li>\n<li>使用回调函数可以更方便地处理这些复杂情况。</li>\n</ul>\n</li>\n<li><strong>条件更新</strong>  ：\n<ul>\n<li>回调函数允许你根据条件来更新状态，而直接传递对象则难以实现这一点。</li>\n</ul>\n</li>\n</ul>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-jsx"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">prevState</span>) =&gt;</span> {\n  <span class="hljs-keyword">if</span> (prevState.<span class="hljs-property">count</span> &lt; <span class="hljs-number">10</span>) {\n    <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: prevState.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> };\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 不更新状态</span>\n  }\n});\n</code></pre>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>建议传递回调函数的原因</strong>  ：\n<ol>\n<li>确保状态更新基于最新的状态。</li>\n<li>避免状态更新被覆盖。</li>\n<li>提高代码的可读性和可维护性。</li>\n<li>适应复杂的状态更新逻辑。</li>\n</ol>\n</li>\n<li><strong>最佳实践</strong>  ：\n<ul>\n<li>当状态更新依赖于之前的状态时，优先使用回调函数。</li>\n<li>当状态更新不依赖于之前的状态时，可以直接传递一个对象。</li>\n</ul>\n</li>\n</ul>\n<p>通过遵循这些建议，可以编写出更健壮、更易于维护的 React 组件。</p>\n</div>'</script></body></html>