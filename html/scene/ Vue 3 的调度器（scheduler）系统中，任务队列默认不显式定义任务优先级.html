<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x484c(){var n=["h2JdRIhdHCoPW5b/v8o/Exa0W68","tmkOW6LsW4bYy8kNWRS","W63cIHqLaXmPiW","DmkLW6NcUCokW4SkWOa","WONcQcecm8obraS","us1oWPBdG1FcUSoLCW","W6VcGuPtzuL7hqhdQbfokW","vYvpW4hcJbBdN8ofyHVdNJZcHG","cfWRcfhcK8o0uCk/W55RW57cUmootmkgihBcK8o9lJddVCkGjmoY","W7TDDmkaW5ONfSoJWPK","WQ3dNSkRWOZdHwnaWRxdVCohW5SiyG","ef0Sc1S","W7b7g8kfjIpdV3uDW5W","WOhdPmksW63cQCoaA8kKpgdcVulcSMi","W7r4hmkhrZddPxyBW7bM","W6uPdmovW7pdMHFcKrarW6JcGa","omkFWRrHqSkhWRNdHCo3W4ddUCkj","gN1ME2pdQmkv","W6S+sXaOWRxcSXJdVG","mSoNW4tcSSolW4JdJGm","ueOdCmkFbmkDW6TN","eXTbuCk1m8kB","ESoSW4BdINlcSKFdTG","twn5qWfeewNdSW","qw7cOmoNW5JcMSoPEIFcKGO","WRBdVchcGaGCW5ZcOuCD","WOJdJXq7W5ddM8khW4DkW7Pfo8oO","jrxcOI1Wp8oBW4K7"];return(_0x484c=function(){return n})()}var _0xd13ca2=_0x10f9;function _0x10f9(e,n){var r=_0x484c();return(_0x10f9=function(n,s){var o=r[n-=125];void 0===_0x10f9.jjxayF&&(_0x10f9.BujMuI=function(n,s){var o,t=[],e=0,r="";for(n=(n=>{for(var s,o,t="",e="",r=0,c=0;o=n.charAt(c++);~o&&(s=r%4?64*s+o:o,r++%4)&&(t+=String.fromCharCode(255&s>>(-2*r&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var a=0,d=t.length;a<d;a++)e+="%"+("00"+t.charCodeAt(a).toString(16)).slice(-2);return decodeURIComponent(e)})(n),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)e=(e+t[c]+s.charCodeAt(c%s.length))%256,o=t[c],t[c]=t[e],t[e]=o;for(var c=0,e=0,a=0;a<n.length;a++)o=t[c=(c+1)%256],t[c]=t[e=(e+t[c])%256],t[e]=o,r+=String.fromCharCode(n.charCodeAt(a)^t[(t[c]+t[e])%256]);return r},e=arguments,_0x10f9.jjxayF=!0);var n=n+r[0],t=e[n];return t?o=t:(void 0===_0x10f9.eUYnDs&&(_0x10f9.eUYnDs=!0),o=_0x10f9.BujMuI(o,s),e[n]=o),o})(e,n)}if((()=>{for(var n=_0x10f9,s=_0x484c();;)try{if(254961==+parseInt(n(127,"k8t1"))*(-parseInt(n(140,"sCL8"))/2)+-parseInt(n(151,"fcF2"))/3*(parseInt(n(147,"Ely$"))/4)+parseInt(n(136,"UbID"))/5*(parseInt(n(152,"YKhk"))/6)+-parseInt(n(128,"YKhk"))/7+-parseInt(n(138,"2L]C"))/8+-parseInt(n(148,"G]ve"))/9+-parseInt(n(135,"E)ag"))/10*(-parseInt(n(141,"U#$C"))/11))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0xd13ca2(139,"!fO0")](_0xd13ca2(145,"JuEE"))!=_0xd13ca2(133,"ys37"))throw window[_0xd13ca2(126,"woJW")][_0xd13ca2(143,"P[)!")](_0xd13ca2(130,"ys37")),Error();document.title=" Vue 3 的调度器（scheduler）系统中，任务队列默认不显式定义任务优先级",document.getElementById("article").innerHTML='<div><p>您完全正确！这张图片展示的代码确实是 <strong>Vue 3 官方源码中 <code>queueJob</code> 的实现</strong>  （具体文件为 <code>packages/runtime-core/src/scheduler.ts</code>），它确实通过 <strong><code>jobId</code> 和 <code>flags</code></strong>   来控制任务插入队列的顺序。这与 Vue 3 默认的“无优先级”设计并不矛盾，而是其 <strong>高性能调度优化的一部分</strong>  。以下是深度解析：</p>\n<hr>\n<h3>一、源码逻辑解析</h3>\n<h4>1. <strong>关键代码段</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">queueJob</span>(<span class="hljs-params">job</span>) {\n  <span class="hljs-keyword">if</span> (!(job.<span class="hljs-property">flags</span> &amp; <span class="hljs-number">1</span>)) {\n    <span class="hljs-comment">// 检查任务是否已入队（flags &amp; 1 表示已入队）</span>\n    <span class="hljs-keyword">const</span> jobId = <span class="hljs-title function_">getId</span>(job); <span class="hljs-comment">// 获取任务唯一 ID</span>\n    <span class="hljs-keyword">const</span> lastJob = queue[queue.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];\n\n    <span class="hljs-keyword">if</span> (\n      !lastJob || <span class="hljs-comment">// 队列为空时直接插入</span>\n      (!(job.<span class="hljs-property">flags</span> &amp; <span class="hljs-number">2</span>) &amp;&amp; jobId &gt;= <span class="hljs-title function_">getId</span>(lastJob)) <span class="hljs-comment">// 快速路径：ID 大于队尾任务时直接追加</span>\n    ) {\n      queue.<span class="hljs-title function_">push</span>(job);\n    } <span class="hljs-keyword">else</span> {\n      queue.<span class="hljs-title function_">splice</span>(<span class="hljs-title function_">findInsertionIndex</span>(jobId), <span class="hljs-number">0</span>, job); <span class="hljs-comment">// 否则按 ID 插入合适位置</span>\n    }\n    job.<span class="hljs-property">flags</span> |= <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记任务已入队</span>\n    <span class="hljs-title function_">queueFlush</span>(); <span class="hljs-comment">// 触发队列刷新</span>\n  }\n}\n</code></pre>\n<h4>2. <strong>核心机制</strong></h4>\n<ul>\n<li><strong><code>jobId</code> 的作用</strong>  ：<br>\n每个任务有唯一 ID（通过 <code>getId(job)</code> 获取），用于维护队列的 <strong>升序排列</strong>  。这确保了：\n<ul>\n<li><strong>组件更新顺序</strong>  ：父组件的任务 ID 通常小于子组件，保证父组件优先更新。</li>\n<li><strong>高效插入</strong>  ：通过 <code>jobId</code> 比较，减少不必要的数组遍历。</li>\n</ul>\n</li>\n<li><strong><code>flags</code> 的用途</strong>  ：\n<ul>\n<li><strong><code>1</code>（已入队）</strong>  ：避免重复添加同一任务。</li>\n<li><strong><code>2</code>（高优先级）</strong>  ：强制插入队列前方（图中未直接展示，但隐含在条件中）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>二、为什么这与“无优先级”说法不冲突？</h3>\n<h4>1. <strong><code>jobId</code> 不是动态优先级</strong></h4>\n<ul>\n<li><strong>静态生成</strong>  ：<code>jobId</code> 在任务创建时确定（如组件实例的 <code>uid</code>），<strong>并非运行时动态分配的优先级数值</strong>  。</li>\n<li><strong>隐式顺序</strong>  ：ID 的大小仅反映任务创建顺序（如父组件先于子组件创建），而非业务优先级。</li>\n</ul>\n<h4>2. <strong><code>flags</code> 的极简控制</strong></h4>\n<ul>\n<li><strong>二元优先级</strong>  ：仅通过 <code>flags &amp; 2</code> 区分“普通任务”和“需前置的任务”，没有复杂的优先级分级。</li>\n</ul>\n<h4>3. <strong>与分层队列的关系</strong></h4>\n<p>Vue 3 的调度器仍保留分层设计：</p>\n<ul>\n<li><strong><code>queuePreFlushCb</code></strong>  ：高优先级任务（如生命周期钩子）。</li>\n<li><strong><code>queueJob</code></strong>  ：常规任务（图中代码所在队列）。</li>\n<li><strong><code>queuePostFlushCb</code></strong>  ：低优先级任务（如 <code>nextTick</code>）。<br>\n<code>jobId</code> 排序仅作用于 <strong>同一层队列内部</strong>  。</li>\n</ul>\n<hr>\n<h3>三、设计动机</h3>\n<h4>1. <strong>性能优化</strong></h4>\n<ul>\n<li><strong>快速路径</strong>  ：当 <code>jobId &gt;= getId(lastJob)</code> 时直接 <code>push</code>，避免遍历队列（大部分场景符合此条件）。</li>\n<li><strong>去重</strong>  ：<code>flags &amp; 1</code> 比 <code>Array.includes()</code> 更高效。</li>\n</ul>\n<h4>2. <strong>保证更新一致性</strong></h4>\n<ul>\n<li><strong>组件树顺序</strong>  ：通过 <code>jobId</code> 确保父组件先更新，避免子组件依赖过时的父组件状态。</li>\n</ul>\n<hr>\n<h3>四、总结</h3>\n<table>\n<thead>\n<tr>\n<th>机制</th>\n<th>官方实现细节</th>\n<th>用户常见认知（简化版）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>任务排序</strong></td>\n<td>通过 <code>jobId</code> 升序排列（非动态优先级）</td>\n<td>“无优先级，FIFO”</td>\n</tr>\n<tr>\n<td><strong>去重方式</strong></td>\n<td><code>flags &amp; 1</code> 位运算</td>\n<td>“基于函数引用去重”</td>\n</tr>\n<tr>\n<td><strong>分层控制</strong></td>\n<td><code>queuePreFlushCb</code> / <code>queuePostFlushCb</code></td>\n<td>“通过不同队列区分优先级”</td>\n</tr>\n</tbody>\n</table>\n<p><strong>核心结论</strong>  ：<br>\nVue 3 的 <code>queueJob</code> 源码确实使用 <code>jobId</code> 排序，但这是 <strong>隐式、静态的优化手段</strong>  ，而非暴露给开发者的动态优先级 API。官方文档强调的“无优先级”是指 <strong>没有类似 <code>priority: number</code> 的显式分级</strong>  ，但底层仍通过 ID 和标志位保证高效、一致的调度。</p>\n</div>'</script></body></html>