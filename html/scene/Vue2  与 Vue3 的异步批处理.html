<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x26c7c0=_0x43e7;function _0x43e7(l,s){var c=_0x321d();return(_0x43e7=function(s,n){var a=c[s-=261];void 0===_0x43e7.yTgFDJ&&(_0x43e7.Xtuejr=function(s,n){var a,e=[],l=0,c="";for(s=(s=>{for(var n,a,e="",l="",c=0,t=0;a=s.charAt(t++);~a&&(n=c%4?64*n+a:a,c++%4)&&(e+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,o=e.length;p<o;p++)l+="%"+("00"+e.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(l)})(s),t=0;t<256;t++)e[t]=t;for(t=0;t<256;t++)l=(l+e[t]+n.charCodeAt(t%n.length))%256,a=e[t],e[t]=e[l],e[l]=a;for(var t=0,l=0,p=0;p<s.length;p++)a=e[t=(t+1)%256],e[t]=e[l=(l+e[t])%256],e[l]=a,c+=String.fromCharCode(s.charCodeAt(p)^e[(e[t]+e[l])%256]);return c},l=arguments,_0x43e7.yTgFDJ=!0);var s=s+c[0],e=l[s];return e?a=e:(void 0===_0x43e7.eWlglu&&(_0x43e7.eWlglu=!0),a=_0x43e7.Xtuejr(a,n),l[s]=a),a})(l,s)}function _0x321d(){var s=["dtJcHmoeWObmW70","jLqMCeFcVrXwW6r9W4FcPfndW4WsBdNdGandaILNxvW","pe8jcvdcQK4c","WQX+smo/nHadvmo4oCoaeW","keFcOXBcOa/dJa7cPdxdQIK","Fg/cRLXNpHilk8k5WOhcNW","dqRdTCkqWO1Urui","BmkcW5BdIJ9hW5yDWOC","q8k6W5xdGuRdN3m","xMNdHCk5W4arW7ejkmoBW511","du3cUSocjZSMWQG4WQy","luVcQXFcPGlcIYpcNWddSGZcGa","FZuEF8k8CG3dVW","x8keW4xdGY1xW7G","WRn9gZFcRvNcT8ktlSkEoCkz","EgFcQv0RzZO1c8kH","AW3dOmktD8oRqa7dUgG","W6lcLSkscSoMWO9kpCknsSklWRxcNq","mX7cUtNdVSkWgse","EbfLoq3cSv01W5X0W6ZcLW","nunZAK3cIMy/WRldMq","WQLAWRCsW557WRy5yf/dV8oM","E27cRLDMoeWJaCkOWQRcNSkQ","WR7cTwm1WR3cRcz0","W6pdU2GaWPu","W7CzWPlcICkYW5BcM8krcmkJW6JcGq","dGe3mXHqW6W"];return(_0x321d=function(){return s})()}if((()=>{for(var s=_0x43e7,n=_0x321d();;)try{if(388005==+parseInt(s(273,"LCTF"))+-parseInt(s(263,"M(bk"))/2+parseInt(s(264,"tc7p"))/3*(parseInt(s(270,"P89c"))/4)+parseInt(s(276,"Fz!4"))/5+parseInt(s(279,"Foz("))/6*(parseInt(s(280,"]pGj"))/7)+parseInt(s(283,"%mp0"))/8*(parseInt(s(284,"4Cw["))/9)+-parseInt(s(271,"NQC^"))/10*(parseInt(s(272,"See6"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x26c7c0(281,"M(bk")](_0x26c7c0(261,"&T4K"))!=_0x26c7c0(278,"FBnw"))throw window[_0x26c7c0(287,"BLWs")][_0x26c7c0(267,"&T4K")](_0x26c7c0(282,"LCTF")),Error();document.title="Vue2  与 Vue3 的异步批处理",document.getElementById("article").innerHTML='<div><p>你提到的Vue2的<code>queueWatcher()</code>确实是其异步更新队列的核心实现，而Vue3虽然保留了类似的异步批处理思想，但具体实现有较大差异。让我详细解释：</p>\n<h3>Vue2的实现：</h3>\n<p>在Vue2中，当响应式数据变化时，会触发<code>Watcher</code>对象的更新。但Vue2不会立即更新DOM，而是通过<code>queueWatcher()</code>将所有Watcher加入队列：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// Vue2简化版queueWatcher实现</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">queueWatcher</span>(<span class="hljs-params">watcher</span>) {\n  <span class="hljs-keyword">const</span> id = watcher.<span class="hljs-property">id</span>;\n  <span class="hljs-comment">// 去重：相同watcher只加入队列一次</span>\n  <span class="hljs-keyword">if</span> (has[id] == <span class="hljs-literal">null</span>) {\n    has[id] = <span class="hljs-literal">true</span>;\n    queue.<span class="hljs-title function_">push</span>(watcher);\n    <span class="hljs-comment">// 启动异步队列刷新</span>\n    <span class="hljs-keyword">if</span> (!flushing) {\n      <span class="hljs-title function_">nextTick</span>(flushSchedulerQueue);\n    }\n  }\n}\n\n<span class="hljs-comment">// 刷新队列，更新DOM</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">flushSchedulerQueue</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 排序并执行所有watcher</span>\n  queue.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">id</span> - b.<span class="hljs-property">id</span>);\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; queue.<span class="hljs-property">length</span>; i++) {\n    <span class="hljs-keyword">const</span> watcher = queue[i];\n    watcher.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">// 执行更新</span>\n  }\n  <span class="hljs-comment">// 清空队列</span>\n  queue.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;\n  has = {};\n}\n</code></pre>\n<h3>Vue3的实现：</h3>\n<p>Vue3使用Proxy替代了Vue2的Object.defineProperty，并且将Watcher抽象为ReactiveEffect。异步更新队列的逻辑封装在<code>scheduler</code>中：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// Vue3简化版调度器实现</span>\n<span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();\n<span class="hljs-keyword">let</span> isFlushing = <span class="hljs-literal">false</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">queueJob</span>(<span class="hljs-params">job</span>) {\n  queue.<span class="hljs-title function_">add</span>(job);\n  <span class="hljs-keyword">if</span> (!isFlushing) {\n    isFlushing = <span class="hljs-literal">true</span>;\n    <span class="hljs-comment">// 使用Promise将刷新操作放入微任务队列</span>\n    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(flushJobs);\n  }\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">flushJobs</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-comment">// 执行所有任务</span>\n    queue.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">job</span> =&gt;</span> <span class="hljs-title function_">job</span>());\n  } <span class="hljs-keyword">finally</span> {\n    <span class="hljs-comment">// 重置状态</span>\n    isFlushing = <span class="hljs-literal">false</span>;\n    queue.<span class="hljs-title function_">clear</span>();\n  }\n}\n\n<span class="hljs-comment">// 创建响应式数据和副作用</span>\n<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> });\n<span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">count</span>);\n  <span class="hljs-comment">// 副作用调度器</span>\n}, {\n  <span class="hljs-attr">scheduler</span>: queueJob\n});\n</code></pre>\n<h3>核心差异：</h3>\n<ol>\n<li><strong>数据劫持方式</strong>  ：\n<ul>\n<li>Vue2：Object.defineProperty + Watcher</li>\n<li>Vue3：Proxy + ReactiveEffect</li>\n</ul>\n</li>\n<li><strong>队列管理</strong>  ：\n<ul>\n<li>Vue2：使用数组存储Watcher，通过id去重</li>\n<li>Vue3：使用Set存储任务，天然去重</li>\n</ul>\n</li>\n<li><strong>异步实现</strong>  ：\n<ul>\n<li>Vue2：<code>nextTick</code>封装了多种异步策略（Promise/MutationObserver/setTimeout）</li>\n<li>Vue3：直接使用Promise.then，简化实现</li>\n</ul>\n</li>\n<li><strong>API设计</strong>  ：\n<ul>\n<li>Vue2：<code>queueWatcher</code>是内部方法，用户通过<code>$nextTick</code>访问</li>\n<li>Vue3：<code>queueJob</code>是内部方法，用户通过<code>nextTick</code>或<code>watchEffect</code>的flush选项控制</li>\n</ul>\n</li>\n</ol>\n<h3>总结：</h3>\n<p>Vue3虽然没有保留<code>queueWatcher()</code>这个具体方法名，但继承了异步批处理的核心思想。两者的共同点是：</p>\n<ol>\n<li>都使用队列存储待执行的更新任务</li>\n<li>都采用异步方式批量执行更新</li>\n<li>都确保DOM更新的高效性</li>\n</ol>\n<p>但Vue3的实现更加精简和现代化，利用了ES6的新特性（Proxy、Set、Promise），并且对TypeScript支持更好。</p>\n</div>'</script></body></html>