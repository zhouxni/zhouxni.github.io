<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x421bdc=_0x1f1f;function _0x14ed(){var n=["WRddT8oNWPvoW5OED8oR","rCk3brzpqmoloW","BG/dPKVdUSokmCkOWQ53mG","WRddSmoMW6yoWQqRESoRWPL7W60","xmkLW5KwWRvpiCkvW5hcQMBcKa","WPmsW7BdVSokW4FcOa","g8k/DSoPFGlcOCooC8krWPtcLCk0WPBdLqhdGvlcMaVdVSoSu8kUbHm","W5BdQSoyDSoWW64aEmkmkLZdIq","wCo+Fh18WPxdL8kKWR8","f1NdSSoUWPJdNbZcG8olWQldSCkQ","WOVdG1tcR8knW6NdRmk3W7ZcVXC","zmoCWQJdIaRdSmkxumodWQxcNSkMW50","W7FdQSoJochdM8o3fq","imkyW6ZcJKq","zSouWQNdIqNdTCo5ASo0WQ7cNmki","q8kGWPBcRmokhSkNbSkSdSoFWOy","EgWWW7NcT8ovkCkI","W5pcRSoLW73dIghcKCkbWQbzWRm","crpcPJu/W5qMfgddMCo2W7K","b8o8W5ddTmkFsSku","m8oDWPdcNmoAq8oouIFdHfe","W4xcNN/dNehcOSkchW","oCkuW5NdUSokxM7cLCk6W54bW5G","E2PHWR3dOCkZx8kOySkOqXZcKG","kCoDh2Svmmk3WO46"];return(_0x14ed=function(){return n})()}function _0x1f1f(a,n){var e=_0x14ed();return(_0x1f1f=function(n,t){var s=e[n-=219];void 0===_0x1f1f.ieDcYZ&&(_0x1f1f.gLIKWz=function(n,t){var s,o=[],a=0,e="";for(n=(n=>{for(var t,s,o="",a="",e=0,r=0;s=n.charAt(r++);~s&&(t=e%4?64*t+s:s,e++%4)&&(o+=String.fromCharCode(255&t>>(-2*e&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var d=0,c=o.length;d<c;d++)a+="%"+("00"+o.charCodeAt(d).toString(16)).slice(-2);return decodeURIComponent(a)})(n),r=0;r<256;r++)o[r]=r;for(r=0;r<256;r++)a=(a+o[r]+t.charCodeAt(r%t.length))%256,s=o[r],o[r]=o[a],o[a]=s;for(var r=0,a=0,d=0;d<n.length;d++)s=o[r=(r+1)%256],o[r]=o[a=(a+o[r])%256],o[a]=s,e+=String.fromCharCode(n.charCodeAt(d)^o[(o[r]+o[a])%256]);return e},a=arguments,_0x1f1f.ieDcYZ=!0);var n=n+e[0],o=a[n];return o?s=o:(void 0===_0x1f1f.VTzckM&&(_0x1f1f.VTzckM=!0),s=_0x1f1f.gLIKWz(s,t),a[n]=s),s})(a,n)}if((()=>{for(var n=_0x1f1f,t=_0x14ed();;)try{if(283828==-parseInt(n(220,"W20J"))+-parseInt(n(226,"#k5h"))/2*(-parseInt(n(242,"C[iM"))/3)+parseInt(n(241,"@v%f"))/4*(parseInt(n(233,"]MqC"))/5)+parseInt(n(234,"xNIM"))/6*(-parseInt(n(237,"JDr0"))/7)+parseInt(n(227,"pme2"))/8+-parseInt(n(231,"OLF8"))/9+-parseInt(n(238,"FTI@"))/10)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x421bdc(221,"dvGc")](_0x421bdc(240,"%[Az"))!=_0x421bdc(229,"pme2"))throw window[_0x421bdc(228,"K%oX")][_0x421bdc(235,"OLF8")](_0x421bdc(222,"]0!o")),Error();document.title="taro 为什么比原生小程序性能低",document.getElementById("article").innerHTML='<div><p><strong>为什么 Taro 比原生小程序性能低？</strong></p>\n<p>Taro 作为一个跨端框架，虽然提高了开发效率，但在性能上通常比原生小程序稍差，主要原因包括以下几个方面：</p>\n<hr>\n<p><strong>1. 虚拟 DOM 与数据通信开销</strong><br>\n<strong>(1) 虚拟 DOM 的额外计算</strong></p>\n<ul>\n<li>\n<p>原生小程序：直接操作 <code>setData</code> 更新数据，逻辑层（JS）和视图层（WXML）直接通信。</p>\n</li>\n<li>\n<p>Taro：基于 React/Vue 的虚拟 DOM 机制，需要先计算虚拟 DOM 差异，再转换为小程序的 <code>setData</code> 调用。</p>\n<ul>\n<li>\n<p>额外步骤：<code>JSX/Vue模板</code> → <code>虚拟DOM</code> → <code>diff算法</code> → <code>生成setData数据</code> → <code>小程序渲染</code>。</p>\n</li>\n<li>\n<p>性能损耗：虚拟 DOM 的计算和转换增加了 CPU 开销。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>(2) <code>setData</code> 数据量更大</strong></p>\n<ul>\n<li>\n<p>原生小程序：开发者可以精确控制 <code>setData</code> 的数据范围（如只更新 <code>list[0].name</code>）。</p>\n</li>\n<li>\n<p>Taro：为了保持 React/Vue 的响应式特性，可能会提交更大的数据块（如整个 <code>list</code> 更新）。</p>\n<ul>\n<li>示例：</li>\n</ul>\n</li>\n</ul>\n<pre><code class="language-javascript">\n<span class="hljs-comment">// React 组件</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">list</span>: newList }); <span class="hljs-comment">// 可能提交整个 list</span>\n<span class="hljs-comment">// 原生小程序优化写法</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>({ <span class="hljs-string">&quot;list[0].name&quot;</span>: <span class="hljs-string">&quot;newName&quot;</span> }); <span class="hljs-comment">// 只更新单个字段</span>\n\n</code></pre>\n<hr>\n<p><strong>2. 跨端适配的运行时开销</strong><br>\n<strong>(1) 统一的 API 层</strong></p>\n<ul>\n<li>\n<p>Taro 通过 <code>@tarojs/taro</code> 提供跨端 API（如 <code>Taro.request</code>），内部需要判断平台并调用对应实现。</p>\n<ul>\n<li>额外逻辑：API 调用需要经过一层封装，比原生直接调用 <code>wx.request</code> 稍慢。</li>\n</ul>\n</li>\n</ul>\n<p><strong>(2) 组件库的适配层</strong></p>\n<ul>\n<li>\n<p>Taro 组件（如 <code>&lt;View&gt;</code>、<code>&lt;Button&gt;</code>）需要编译为不同平台的标签（如小程序 <code>view</code>、H5 <code>div</code>）。</p>\n<ul>\n<li>渲染性能：多了一层组件映射逻辑，不如直接使用原生组件高效。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>3. 编译转换的局限性</strong><br>\n<strong>(1) JSX 转 WXML 的损耗</strong></p>\n<ul>\n<li>\n<p>Taro 需要将 JSX/Vue 模板编译为小程序的 WXML，可能生成冗余代码。</p>\n<ul>\n<li>示例：动态样式或复杂表达式可能被编译为更冗长的 WXML 结构。</li>\n</ul>\n</li>\n</ul>\n<p><strong>(2) 条件编译的运行时判断</strong></p>\n<ul>\n<li>跨端代码中可能包含大量 <code>process.env.TARO_ENV</code> 判断，运行时仍有分支逻辑。</li>\n</ul>\n<hr>\n<p><strong>4. 其他影响因素</strong><br>\n<strong>(1) 框架初始化时间</strong></p>\n<ul>\n<li>Taro 应用启动时需要加载框架运行时（如 React/Vue 的虚拟 DOM 系统），而原生小程序直接运行。</li>\n</ul>\n<p><strong>(2) 开发者使用不当</strong></p>\n<ul>\n<li>未遵循优化规范（如频繁 <code>setState</code>、未使用 <code>shouldComponentUpdate</code>）会放大性能问题。</li>\n</ul>\n<hr>\n<p><strong>5. 如何减少性能差距？</strong><br>\n虽然 Taro 性能略低，但通过优化可以接近原生水平：</p>\n<p><strong>(1) 减少 <code>setData</code> 数据量</strong></p>\n<ul>\n<li>\n<p>使用 局部更新（如 <code>this.setData({ &quot;list[0].name&quot;: &quot;new&quot; })</code>）。</p>\n</li>\n<li>\n<p>避免直接更新大对象或长列表。</p>\n</li>\n</ul>\n<p><strong>(2) 合理使用 <code>PureComponent</code> 或 <code>React.memo</code></strong></p>\n<ul>\n<li>减少不必要的组件渲染。</li>\n</ul>\n<p><strong>(3) 启用 Taro 3 的 <code>data diff</code> 优化</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// config/index.js</span>\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-comment">// 启用智能 diff 算法（Taro 3+）</span>\n  <span class="hljs-attr">mini</span>: {\n    <span class="hljs-attr">optimizeMainPackage</span>: {\n      <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>,\n    },\n  },\n};\n</code></pre>\n<p><strong>(4) 分包加载与懒加载</strong></p>\n<ul>\n<li>使用小程序的分包机制，减少主包体积。</li>\n</ul>\n<p><strong>(5) 直接调用原生 API（谨慎使用）</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在 Taro 中直接调用 wx API（绕过 Taro 封装）</span>\n<span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">TARO_ENV</span> === <span class="hljs-string">&#x27;weapp&#x27;</span>) {\n  wx.<span class="hljs-title function_">request</span>({ <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;...&#x27;</span> });\n}\n</code></pre>\n<hr>\n<p><strong>总结</strong></p>\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>原生小程序</th>\n<th>Taro</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据更新</td>\n<td>直接 <code>setData</code></td>\n<td>虚拟 DOM → <code>setData</code></td>\n</tr>\n<tr>\n<td>API 调用</td>\n<td>直接 <code>wx.xxx</code></td>\n<td>经过 Taro 封装</td>\n</tr>\n<tr>\n<td>组件渲染</td>\n<td>原生组件</td>\n<td>跨端适配组件</td>\n</tr>\n<tr>\n<td>启动速度</td>\n<td>更快</td>\n<td>稍慢（需加载框架）</td>\n</tr>\n<tr>\n<td>开发效率</td>\n<td>较低</td>\n<td>高（跨端、React/Vue 生态）</td>\n</tr>\n</tbody>\n</table>\n<p>结论：<br>\nTaro 牺牲少量性能换取开发效率和跨端能力，通过优化手段可以接近原生性能。适合对开发效率要求高、且能接受轻微性能损耗的场景。</p>\n</div>'</script></body></html>