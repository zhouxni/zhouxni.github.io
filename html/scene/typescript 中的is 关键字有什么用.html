<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x208ed7=_0x2441;function _0x3f81(){var s=["W6tdIcpcL8kKuwL+","sdldOCkNemoeW4tdNmoFnw3cJvO","W6jydCoFWPBdL8k/WRNcRuZcNa","WRKTgc9PW4aQ","sZBdOCkRCCkGWPhdOSoRkq","W65LBYJdGbnNW55Gc8oAWOm","W57dSantsCkHWRlcP3S","W6TNBetcKKDNW4r4","W44Ujmk4W6tdVHKDW6FcKdBdTSkRwCoOAmogW6fyWQPtWPNdHSo0W7NdGG","W4iCWRtdReu0WOjcW5ddVcddPmo7","W4RdSmorm2TQca","WQRdMCoFy8kPWOhdGSkbWOSE","yKj5WPyPDcW","pmkvaCk/ymkaWRNcPNr0WQC","WPFdHmozW5BdVtKVbGWaW6mK","d8kYxSoWW5lcMqpcH8obla","cCk0xmo1WONdIWBcOmoZb0VdQW","W7XqgCktWOGXW5BcJCkKcSomWOXxxq","W5uagt9JWRqr","WR95q30yWPn+eCoyWR5LlGhdMa","lsXvWOJcLw/dQCksWQu","WRFcG2ayW77dNvJcG8kiW4/cLxO","WR3cK3BdGmoPce9KWQxcVSk1Da","BSkVWRbkpCklW7ddLem","W6fBc8k0W4xdL8kQWP3cKW","WQFcNSkvkCk1dJzuCxGJWRW","dCkkaxRcOG","cCkXxCoWW6NcRWFcVSoAka"];return(_0x3f81=function(){return s})()}function _0x2441(p,s){var c=_0x3f81();return(_0x2441=function(s,n){var a=c[s-=396];void 0===_0x2441.AoxONe&&(_0x2441.iAZBar=function(s,n){var a,l=[],p=0,c="";for(s=(s=>{for(var n,a,l="",p="",c=0,e=0;a=s.charAt(e++);~a&&(n=c%4?64*n+a:a,c++%4)&&(l+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,o=l.length;t<o;t++)p+="%"+("00"+l.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[p],l[p]=a;for(var e=0,p=0,t=0;t<s.length;t++)a=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=a,c+=String.fromCharCode(s.charCodeAt(t)^l[(l[e]+l[p])%256]);return c},p=arguments,_0x2441.AoxONe=!0);var s=s+c[0],l=p[s];return l?a=l:(void 0===_0x2441.GJBVAi&&(_0x2441.GJBVAi=!0),a=_0x2441.iAZBar(a,n),p[s]=a),a})(p,s)}if((()=>{for(var s=_0x2441,n=_0x3f81();;)try{if(485926==-parseInt(s(423,"EQAj"))+-parseInt(s(404,"^8LZ"))/2+parseInt(s(401,"4iEi"))/3*(parseInt(s(417,"4iEi"))/4)+-parseInt(s(416,"6dMg"))/5*(-parseInt(s(397,"xG7Y"))/6)+-parseInt(s(405,"31%T"))/7*(-parseInt(s(403,"XRgg"))/8)+parseInt(s(398,"^8LZ"))/9*(parseInt(s(399,"#hLm"))/10)+-parseInt(s(421,"31%T"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x208ed7(420,"3h57")](_0x208ed7(422,"gzwp"))!=_0x208ed7(400,"]8xo"))throw window[_0x208ed7(402,"3cSC")][_0x208ed7(412,"7nYP")](_0x208ed7(410,"w&qa")),Error();document.title="typescript 中的is 关键字有什么用",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>is</code> 关键字主要用于<strong>类型谓词（Type Predicates）</strong>  ，这是一种用于类型保护和类型缩小的机制。类型谓词允许你在运行时检查一个值的类型，并告诉 TypeScript 编译器这个值在特定条件下属于某个类型。</p>\n<hr>\n<h3><strong>类型谓词的基本用法</strong></h3>\n<h4><strong>语法</strong></h4>\n<p>类型谓词的语法如下：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionName</span>(<span class="hljs-params"><span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span></span>): value is <span class="hljs-title class_">Type</span> {\n  <span class="hljs-comment">// 实现类型检查的逻辑</span>\n}\n</code></pre>\n<ul>\n<li><strong><code>value is Type</code></strong>  ：这是类型谓词的核心部分，表示如果函数返回 <code>true</code>，则 <code>value</code> 被认为是 <code>Type</code> 类型。</li>\n<li><strong><code>unknown</code></strong>  ：通常用于表示未知类型的参数，但在实际应用中可以是任何类型。</li>\n</ul>\n<hr>\n<h3><strong>示例</strong></h3>\n<h4><strong>示例 1：检查对象是否为特定类型</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Fish</span> = { <span class="hljs-attr">swim</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> };\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Bird</span> = { <span class="hljs-attr">fly</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> };\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">isFish</span>(<span class="hljs-params"><span class="hljs-attr">pet</span>: <span class="hljs-title class_">Fish</span> | <span class="hljs-title class_">Bird</span></span>): pet is <span class="hljs-title class_">Fish</span> {\n  <span class="hljs-keyword">return</span> (pet <span class="hljs-keyword">as</span> <span class="hljs-title class_">Fish</span>).<span class="hljs-property">swim</span> !== <span class="hljs-literal">undefined</span>;\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">pet</span>: <span class="hljs-title class_">Fish</span> | <span class="hljs-title class_">Bird</span> = { <span class="hljs-attr">swim</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;I am swimming!&quot;</span>) };\n\n<span class="hljs-keyword">if</span> (<span class="hljs-title function_">isFish</span>(pet)) {\n  pet.<span class="hljs-title function_">swim</span>(); <span class="hljs-comment">// TypeScript 知道 pet 是 Fish 类型</span>\n} <span class="hljs-keyword">else</span> {\n  <span class="hljs-comment">// pet.fly(); // 如果需要，可以处理 Bird 类型</span>\n}\n</code></pre>\n<ul>\n<li><strong>解释</strong>  ：\n<ul>\n<li><code>isFish</code> 函数检查 <code>pet</code> 是否具有 <code>swim</code> 方法，如果是，则返回 <code>true</code>，表示 <code>pet</code> 是 <code>Fish</code> 类型。</li>\n<li>在 <code>if</code> 语句中，TypeScript 编译器知道 <code>pet</code> 是 <code>Fish</code> 类型，因此可以安全地调用 <code>swim</code> 方法。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>示例 2：检查字符串是否为特定格式</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isNumberString</span>(<span class="hljs-params"><span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span></span>): value is <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">number</span>}</span>`</span> {\n  <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^\\d+$/</span>.<span class="hljs-title function_">test</span>(value); <span class="hljs-comment">// 检查字符串是否只包含数字</span>\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;123&quot;</span>;\n\n<span class="hljs-keyword">if</span> (<span class="hljs-title function_">isNumberString</span>(value)) {\n  <span class="hljs-keyword">const</span> num = <span class="hljs-title class_">Number</span>(value); <span class="hljs-comment">// TypeScript 知道 value 是数字字符串，可以安全转换为数字</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num + <span class="hljs-number">1</span>); <span class="hljs-comment">// 输出：124</span>\n}\n</code></pre>\n<ul>\n<li><strong>解释</strong>  ：\n<ul>\n<li><code>isNumberString</code> 函数使用正则表达式检查字符串是否只包含数字。</li>\n<li>如果返回 <code>true</code>，TypeScript 编译器知道 <code>value</code> 是数字字符串，可以安全地转换为数字。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>类型谓词的优势</strong></h3>\n<ol>\n<li><strong>类型保护</strong>  ：类型谓词提供了一种在运行时检查类型的方法，使得 TypeScript 编译器能够在特定条件下缩小类型范围。</li>\n<li><strong>代码安全</strong>  ：通过类型谓词，可以避免在运行时访问不存在的方法或属性，提高代码的健壮性。</li>\n<li><strong>代码可读性</strong>  ：类型谓词使得类型检查逻辑更加清晰，易于理解和维护。</li>\n</ol>\n<hr>\n<h3><strong>与 <code>instanceof</code> 的比较</strong></h3>\n<ul>\n<li><strong><code>instanceof</code></strong>  ：用于检查一个对象是否是某个类的实例。</li>\n<li><strong>类型谓词</strong>  ：更加灵活，可以用于检查任何类型的条件，不仅仅是类的实例。</li>\n</ul>\n<h4><strong>示例对比</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> { <span class="hljs-title function_">bark</span>(<span class="hljs-params"></span>) {} }\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">isDog</span>(<span class="hljs-params"><span class="hljs-attr">animal</span>: <span class="hljs-title class_">Animal</span></span>): animal is <span class="hljs-title class_">Dog</span> {\n  <span class="hljs-keyword">return</span> animal <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Dog</span>; <span class="hljs-comment">// 也可以使用 instanceof，但类型谓词更通用</span>\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">animal</span>: <span class="hljs-title class_">Animal</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();\n\n<span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDog</span>(animal)) {\n  animal.<span class="hljs-title function_">bark</span>(); <span class="hljs-comment">// TypeScript 知道 animal 是 Dog 类型</span>\n}\n</code></pre>\n<ul>\n<li><strong>解释</strong>  ：\n<ul>\n<li><code>isDog</code> 函数使用 <code>instanceof</code> 检查 <code>animal</code> 是否是 <code>Dog</code> 的实例。</li>\n<li>类型谓词使得这种检查更加灵活，可以用于任何类型的条件。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>自定义类型保护</strong></h3>\n<p>类型谓词不仅限于内置类型或类，还可以用于自定义类型保护。</p>\n<h4><strong>示例：自定义类型保护</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> };\n<span class="hljs-keyword">type</span> <span class="hljs-title class_">Admin</span> = { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">role</span>: <span class="hljs-built_in">string</span> };\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">isAdmin</span>(<span class="hljs-params"><span class="hljs-attr">user</span>: <span class="hljs-title class_">User</span> | <span class="hljs-title class_">Admin</span></span>): user is <span class="hljs-title class_">Admin</span> {\n  <span class="hljs-keyword">return</span> (user <span class="hljs-keyword">as</span> <span class="hljs-title class_">Admin</span>).<span class="hljs-property">role</span> !== <span class="hljs-literal">undefined</span>;\n}\n\n<span class="hljs-keyword">const</span> <span class="hljs-attr">user</span>: <span class="hljs-title class_">User</span> | <span class="hljs-title class_">Admin</span> = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">role</span>: <span class="hljs-string">&quot;admin&quot;</span> };\n\n<span class="hljs-keyword">if</span> (<span class="hljs-title function_">isAdmin</span>(user)) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">role</span>); <span class="hljs-comment">// TypeScript 知道 user 是 Admin 类型</span>\n} <span class="hljs-keyword">else</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">age</span>); <span class="hljs-comment">// 如果需要，可以处理 User 类型</span>\n}\n</code></pre>\n<ul>\n<li><strong>解释</strong>  ：\n<ul>\n<li><code>isAdmin</code> 函数检查 <code>user</code> 是否具有 <code>role</code> 属性，如果是，则返回 <code>true</code>，表示 <code>user</code> 是 <code>Admin</code> 类型。</li>\n<li>在 <code>if</code> 语句中，TypeScript 编译器知道 <code>user</code> 是 <code>Admin</code> 类型，因此可以安全地访问 <code>role</code> 属性。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>类型谓词</strong>  ：使用 <code>is</code> 关键字定义，用于在运行时检查一个值的类型，并告诉 TypeScript 编译器这个值在特定条件下属于某个类型。</li>\n<li><strong>优势</strong>  ：提供类型保护、提高代码安全和可读性。</li>\n<li><strong>应用场景</strong>  ：适用于需要检查对象类型、字符串格式、自定义类型等场景。</li>\n</ul>\n<p>类型谓词是 TypeScript 中非常强大的特性，能够帮助开发者编写更加类型安全、健壮的代码。</p>\n</div>'</script></body></html>