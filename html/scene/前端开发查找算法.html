<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x383bbf=_0x6dc8;function _0xd4dd(){var s=["WOtdTSowW7CABYHCWQZcQvOJ","cCkmW6xcS8kiW7BdKmkAuMzdcaW","WOCDEmo9W4SxrvW","t0fVgcddQtBcSIRcSSk9WRBdKG","WRhdVK1xW6/cGCkh","uaZcJL1AzSoDWOX8W7a","W7ddP1TuW50","ACoxWOizuSkryrm","iJblDsHFfSky","WOqyfmklWRf3phy3WOJdTNWR","pCkFW63cQSkgm3BdS04bW6zhla","WOezgCkmWR1ZxwiDWOtdN0i","E8opsSosWRBcPwpdVxFdPG","t0jVgcldRdJcUbdcNmkSWQ/dLG","gZShzmkFlCk9zI7dLgrmpa","WPXTWOnWWPJcMv7cOa","WPZcKfVcMNpcSCk3WQtdUfLwzq","mCoQWOH3W7CqAmkdhW","WRNdTmk1bSkbASkZts7cQuJcMWnPlmkrFYddOmo2W4VcI8o/WPS2wa","dqZcUa3dQt4YW6L1W4ObW7ZcUW","chftW7bCwMu4WPDTjG","hsnzhSoiWP9mzMZdKLDe","sKTHgsxcK2hcNJxcQSkr","qSk8WR5qW4OZySkI","WQmVWPddRCkyWRzS","WQpdOHNdJ0FdHd0","W6ZdQ8kKW4dcU8oZWQT0cCk8xgry","WQHKr1OrDLW"];return(_0xd4dd=function(){return s})()}function _0x6dc8(p,s){var t=_0xd4dd();return(_0x6dc8=function(s,n){var a=t[s-=241];void 0===_0x6dc8.aGEBoO&&(_0x6dc8.VhDTJU=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,r=0;a=s.charAt(r++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,c=l.length;e<c;e++)p+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(p)})(s),r=0;r<256;r++)l[r]=r;for(r=0;r<256;r++)p=(p+l[r]+n.charCodeAt(r%n.length))%256,a=l[r],l[r]=l[p],l[p]=a;for(var r=0,p=0,e=0;e<s.length;e++)a=l[r=(r+1)%256],l[r]=l[p=(p+l[r])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(e)^l[(l[r]+l[p])%256]);return t},p=arguments,_0x6dc8.aGEBoO=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x6dc8.pOjsjQ&&(_0x6dc8.pOjsjQ=!0),a=_0x6dc8.VhDTJU(a,n),p[s]=a),a})(p,s)}if((()=>{for(var s=_0x6dc8,n=_0xd4dd();;)try{if(487750==+parseInt(s(263,"FcV8"))*(parseInt(s(252,"p63#"))/2)+-parseInt(s(253,"]1$I"))/3+parseInt(s(242,"p63#"))/4+-parseInt(s(241,"zeQq"))/5*(-parseInt(s(250,"zeQq"))/6)+-parseInt(s(249,"4[@F"))/7+-parseInt(s(267,"c3f9"))/8*(-parseInt(s(254,"!ma0"))/9)+-parseInt(s(244,"#BYc"))/10*(-parseInt(s(259,"w)bR"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x383bbf(266,"9bec")](_0x383bbf(256,"4^D#"))!=_0x383bbf(245,"rJR5"))throw window[_0x383bbf(246,"Xagy")][_0x383bbf(264,"AWL]")](_0x383bbf(257,"VP4M")),Error();document.title="前端开发查找算法",document.getElementById("article").innerHTML='<div><p>前端开发中，查找算法是用于在数据集合中快速定位目标元素的核心工具。以下从算法原理、实现、复杂度及应用场景等维度，系统梳理前端常见的查找算法：</p>\n<h3><strong>一、基础查找算法</strong></h3>\n<h4>1. <strong>顺序查找（Linear Search）</strong></h4>\n<ul>\n<li><strong>原理</strong>   ：从数据起始位置开始，逐个元素与目标值比较，直到找到匹配项或遍历完所有元素。</li>\n<li><strong>代码实现（JavaScript）</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">linearSearch</span>(<span class="hljs-params">arr, target</span>) {\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {\n    <span class="hljs-keyword">if</span> (arr[i] === target) <span class="hljs-keyword">return</span> i;\n  }\n  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;\n}\n</code></pre>\n</li>\n<li><strong>复杂度</strong>   ：\n<ul>\n<li>时间：平均/最坏 O(n)，最好 O(1)。</li>\n<li>空间：O(1)。</li>\n</ul>\n</li>\n<li><strong>应用场景</strong>   ：\n<ul>\n<li>数据量小或无序（如未排序的用户列表）。</li>\n<li>DOM操作中遍历节点（如<code>querySelectorAll</code>后逐个匹配）。</li>\n</ul>\n</li>\n</ul>\n<h4>2. <strong>二分查找（Binary Search）</strong></h4>\n<ul>\n<li><strong>原理</strong>   ：要求数据有序，通过比较中间元素，每次将查找范围缩小一半，直到找到目标值。</li>\n<li><strong>代码实现（JavaScript）</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">arr, target</span>) {\n  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>,\n    right = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;\n  <span class="hljs-keyword">while</span> (left &lt;= right) {\n    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);\n    <span class="hljs-keyword">if</span> (arr[mid] === target) <span class="hljs-keyword">return</span> mid;\n    <span class="hljs-keyword">if</span> (arr[mid] &lt; target) left = mid + <span class="hljs-number">1</span>;\n    <span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;\n  }\n  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;\n}\n</code></pre>\n</li>\n<li><strong>复杂度</strong>   ：\n<ul>\n<li>时间：平均/最坏 O(log n)。</li>\n<li>空间：O(1)。</li>\n</ul>\n</li>\n<li><strong>应用场景</strong>   ：\n<ul>\n<li>有序数组的快速定位（如排序后的商品价格列表筛选）。</li>\n<li>前端图表库中对时间序列数据的范围查询。</li>\n</ul>\n</li>\n</ul>\n<h4>3. <strong>哈希查找（Hash Search）</strong></h4>\n<ul>\n<li>\n<p><strong>原理</strong>   ：通过哈希函数将键值映射到哈希表的索引位置，直接访问该位置获取值。</p>\n</li>\n<li>\n<p><strong>代码实现（JavaScript）</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 使用Map实现哈希表</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">hashSearch</span>(<span class="hljs-params">hashTable, key</span>) {\n  <span class="hljs-keyword">return</span> hashTable.<span class="hljs-title function_">has</span>(key) ? hashTable.<span class="hljs-title function_">get</span>(key) : <span class="hljs-literal">null</span>;\n}\n\n<span class="hljs-comment">// 示例：用户ID映射</span>\n<span class="hljs-keyword">const</span> userMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([\n  [<span class="hljs-string">&quot;1001&quot;</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span> }],\n  [<span class="hljs-string">&quot;1002&quot;</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;李四&quot;</span> }],\n]);\n</code></pre>\n</li>\n<li>\n<p><strong>复杂度</strong>   ：</p>\n<ul>\n<li>时间：平均 O(1)，最坏（哈希冲突）O(n)。</li>\n<li>空间：O(n)。</li>\n</ul>\n</li>\n<li>\n<p><strong>应用场景</strong>   ：</p>\n<ul>\n<li>键值对快速查询（如用户ID与用户信息的映射）。</li>\n<li>前端缓存（如<code>localStorage</code>的键值存取）、状态管理（Redux的state树）。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>二、优化与扩展算法</strong></h3>\n<h4>1. <strong>插值查找（Interpolation Search）</strong></h4>\n<ul>\n<li><strong>原理</strong>   ：二分查找的优化版，根据目标值与数据分布的估计，计算更合理的中间位置（如<code>mid = left + (target - arr[left]) * (right - left) / (arr[right] - arr[left])</code>）。</li>\n<li><strong>适用场景</strong>   ：数据均匀分布时，比二分查找更快（如索引连续的数组）。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">interpolationSearch</span>(<span class="hljs-params">arr, target</span>) {\n  <span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>;\n  <span class="hljs-keyword">let</span> high = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;\n\n  <span class="hljs-keyword">while</span> (low &lt;= high &amp;&amp; target &gt;= arr[low] &amp;&amp; target &lt;= arr[high]) {\n    <span class="hljs-comment">// 计算插值位置</span>\n    <span class="hljs-comment">// target - arr[low]：计算目标值与当前区间下限值的差</span>\n    <span class="hljs-comment">// arr[high] - arr[low]：当前区间上下限值的差</span>\n    <span class="hljs-comment">// (target - arr[low]) / (arr[high] - arr[low])：目标值在值范围内的相对位置比例</span>\n    <span class="hljs-comment">// (high - low)：当前索引区间的长度</span>\n    <span class="hljs-comment">// 将比例乘以区间长度，得到从low开始的偏移量</span>\n    <span class="hljs-comment">// 最后用Math.floor()取整，确保结果是整数索引</span>\n    <span class="hljs-keyword">const</span> pos =\n      low +\n      <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(((target - arr[low]) * (high - low)) / (arr[high] - arr[low]));\n\n    <span class="hljs-keyword">if</span> (arr[pos] === target) {\n      <span class="hljs-keyword">return</span> pos; <span class="hljs-comment">// 找到目标值</span>\n    }\n\n    <span class="hljs-keyword">if</span> (arr[pos] &lt; target) {\n      low = pos + <span class="hljs-number">1</span>; <span class="hljs-comment">// 在右侧继续查找</span>\n    } <span class="hljs-keyword">else</span> {\n      high = pos - <span class="hljs-number">1</span>; <span class="hljs-comment">// 在左侧继续查找</span>\n    }\n  }\n\n  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 未找到</span>\n}\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-keyword">const</span> sortedArray = [\n  <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">16</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">33</span>, <span class="hljs-number">35</span>, <span class="hljs-number">42</span>, <span class="hljs-number">47</span>,\n];\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">interpolationSearch</span>(sortedArray, <span class="hljs-number">18</span>)); <span class="hljs-comment">// 输出: 4</span>\n</code></pre>\n<h4>2. <strong>分块查找（Block Search）</strong></h4>\n<ul>\n<li><strong>原理</strong>   ：将数据分为若干块，每块内部无序但记录块的最大/最小值，先确定目标值所在块，再在块内顺序查找。</li>\n<li><strong>复杂度</strong>   ：O(√n)，介于顺序与二分查找之间。</li>\n<li><strong>应用场景</strong>   ：前端大数据列表的分页加载（如按字母分块的联系人列表）。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockSearch</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">arr, blockSize</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span> = arr;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">blockSize</span> = blockSize || <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(arr.<span class="hljs-property">length</span>));\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">indexTable</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createIndexTable</span>();\n  }\n\n  <span class="hljs-comment">// 创建索引表</span>\n  <span class="hljs-title function_">createIndexTable</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> table = [];\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>.<span class="hljs-property">length</span>; i += <span class="hljs-variable language_">this</span>.<span class="hljs-property">blockSize</span>) {\n      <span class="hljs-keyword">const</span> block = <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>.<span class="hljs-title function_">slice</span>(i, i + <span class="hljs-variable language_">this</span>.<span class="hljs-property">blockSize</span>);\n      <span class="hljs-keyword">const</span> max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...block);\n      table.<span class="hljs-title function_">push</span>({\n        max,\n        <span class="hljs-attr">start</span>: i,\n        <span class="hljs-attr">end</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(i + <span class="hljs-variable language_">this</span>.<span class="hljs-property">blockSize</span> - <span class="hljs-number">1</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>),\n      });\n    }\n    <span class="hljs-keyword">return</span> table;\n  }\n\n  <span class="hljs-comment">// 分块查找</span>\n  <span class="hljs-title function_">search</span>(<span class="hljs-params">target</span>) {\n    <span class="hljs-comment">// 1. 在索引表中确定块</span>\n    <span class="hljs-keyword">const</span> block = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">findBlock</span>(target);\n    <span class="hljs-keyword">if</span> (block === -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;\n\n    <span class="hljs-comment">// 2. 在块内顺序查找</span>\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = block.<span class="hljs-property">start</span>; i &lt;= block.<span class="hljs-property">end</span>; i++) {\n      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>[i] === target) {\n        <span class="hljs-keyword">return</span> i;\n      }\n    }\n\n    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;\n  }\n\n  <span class="hljs-comment">// 查找目标值所在的块</span>\n  <span class="hljs-title function_">findBlock</span>(<span class="hljs-params">target</span>) {\n    <span class="hljs-comment">// 可以使用顺序查找或二分查找</span>\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">indexTable</span>.<span class="hljs-property">length</span>; i++) {\n      <span class="hljs-keyword">if</span> (target &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">indexTable</span>[i].<span class="hljs-property">max</span>) {\n        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">indexTable</span>[i];\n      }\n    }\n    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;\n  }\n}\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-keyword">const</span> data = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">10</span>];\n<span class="hljs-keyword">const</span> blockSearch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockSearch</span>(data, <span class="hljs-number">3</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(blockSearch.<span class="hljs-title function_">search</span>(<span class="hljs-number">8</span>)); <span class="hljs-comment">// 输出: 7</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(blockSearch.<span class="hljs-title function_">search</span>(<span class="hljs-number">15</span>)); <span class="hljs-comment">// 输出: -1</span>\n</code></pre>\n<h4>3. <strong>二叉搜索树（BST）查找</strong></h4>\n<ul>\n<li>\n<p><strong>原理</strong>   ：利用二叉树结构，左子树节点值小于根节点，右子树大于根节点，通过递归遍历查找。</p>\n</li>\n<li>\n<p><strong>代码实现（简化版）</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">val</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span> = <span class="hljs-literal">null</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span> = <span class="hljs-literal">null</span>;\n  }\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">searchBST</span>(<span class="hljs-params">root, target</span>) {\n  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;\n  <span class="hljs-keyword">if</span> (root.<span class="hljs-property">val</span> === target) <span class="hljs-keyword">return</span> root;\n  <span class="hljs-keyword">if</span> (target &lt; root.<span class="hljs-property">val</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">searchBST</span>(root.<span class="hljs-property">left</span>, target);\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">searchBST</span>(root.<span class="hljs-property">right</span>, target);\n}\n</code></pre>\n</li>\n<li>\n<p><strong>复杂度</strong>   ：平均 O(log n)，最坏（退化为链表）O(n)。</p>\n</li>\n<li>\n<p><strong>应用场景</strong>   ：前端路由匹配（如React Router的路径匹配树）、虚拟DOM的节点层级查找。</p>\n</li>\n</ul>\n<h3><strong>三、算法对比与选择指南</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>算法</strong></th>\n<th><strong>数据有序性</strong></th>\n<th><strong>平均时间复杂度</strong></th>\n<th><strong>空间复杂度</strong></th>\n<th><strong>典型场景</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>顺序查找</td>\n<td>无需有序</td>\n<td>O(n)</td>\n<td>O(1)</td>\n<td>DOM节点遍历、小数据量查找</td>\n</tr>\n<tr>\n<td>二分查找</td>\n<td>必须有序</td>\n<td>O(log n)</td>\n<td>O(1)</td>\n<td>排序数组筛选、图表数据定位</td>\n</tr>\n<tr>\n<td>哈希查找</td>\n<td>无需有序</td>\n<td>O(1)</td>\n<td>O(n)</td>\n<td>键值对缓存、状态管理映射</td>\n</tr>\n<tr>\n<td>插值查找</td>\n<td>必须有序且均匀</td>\n<td>O(log log n)</td>\n<td>O(1)</td>\n<td>连续索引数据（如时间戳序列）</td>\n</tr>\n<tr>\n<td>二叉搜索树</td>\n<td>动态有序</td>\n<td>O(log n)</td>\n<td>O(n)</td>\n<td>路由匹配、层级数据快速定位</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>四、前端工程实践技巧</strong></h3>\n<ol>\n<li><strong>数据预处理</strong>   ：\n<ul>\n<li>若数据需频繁查找，优先排序后使用二分查找（如商品列表按价格排序）。</li>\n<li>高频查询场景可构建哈希表（如用<code>Map</code>缓存API请求结果）。</li>\n</ul>\n</li>\n<li><strong>结合场景优化</strong>   ：\n<ul>\n<li>长列表搜索可结合“前缀匹配+分块查找”（如搜索框实时过滤联系人）。</li>\n<li>大数据量可视场景（如地图标注点）可使用空间索引算法（如R树）优化。</li>\n</ul>\n</li>\n<li><strong>性能监控</strong>   ：\n<ul>\n<li>使用<code>performance.now()</code>测试不同算法在实际数据量下的耗时，选择最优方案。</li>\n<li>避免在UI线程中执行大规模顺序查找，可通过<code>requestIdleCallback</code>分片处理。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>五、框架与库中的应用</strong></h3>\n<ul>\n<li><strong>React</strong>   ：<code>useMemo</code>/<code>useCallback</code>通过哈希表缓存依赖项，避免重复渲染。</li>\n<li><strong>Vue</strong>   ：虚拟DOM diff算法中使用“key”属性作为哈希键快速匹配节点。</li>\n<li><strong>Lodash</strong>   ：<code>_.find</code>实现顺序查找，<code>_.sortedIndex</code>实现二分查找。</li>\n</ul>\n<p>合理选择查找算法能显著提升前端应用的响应速度，尤其是在处理海量数据或高频交互场景时，需根据数据特性与业务需求权衡时间与空间复杂度。</p>\n</div>'</script></body></html>