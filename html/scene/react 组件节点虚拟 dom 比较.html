<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2b7f5d=_0x2d56;function _0x2d56(e,n){var o=_0x4aa4();return(_0x2d56=function(n,s){var t=o[n-=127];void 0===_0x2d56.UlFHtQ&&(_0x2d56.EXzJJN=function(n,s){var t,a=[],e=0,o="";for(n=(n=>{for(var s,t,a="",e="",o=0,r=0;t=n.charAt(r++);~t&&(s=o%4?64*s+t:t,o++%4)&&(a+=String.fromCharCode(255&s>>(-2*o&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var l=0,c=a.length;l<c;l++)e+="%"+("00"+a.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(e)})(n),r=0;r<256;r++)a[r]=r;for(r=0;r<256;r++)e=(e+a[r]+s.charCodeAt(r%s.length))%256,t=a[r],a[r]=a[e],a[e]=t;for(var r=0,e=0,l=0;l<n.length;l++)t=a[r=(r+1)%256],a[r]=a[e=(e+a[r])%256],a[e]=t,o+=String.fromCharCode(n.charCodeAt(l)^a[(a[r]+a[e])%256]);return o},e=arguments,_0x2d56.UlFHtQ=!0);var n=n+o[0],a=e[n];return a?t=a:(void 0===_0x2d56.swDPLJ&&(_0x2d56.swDPLJ=!0),t=_0x2d56.EXzJJN(t,s),e[n]=t),t})(e,n)}if((()=>{for(var n=_0x2d56,s=_0x4aa4();;)try{if(680024==+parseInt(n(130,"L!yb"))*(-parseInt(n(150,"X9]1"))/2)+-parseInt(n(142,"Ar52"))/3+parseInt(n(140,"$Cvf"))/4+parseInt(n(134,"(bEH"))/5*(-parseInt(n(135,"rVJh"))/6)+-parseInt(n(127,"uFuU"))/7+-parseInt(n(141,"Zm9*"))/8*(-parseInt(n(151,"7]Su"))/9)+-parseInt(n(138,"hZUP"))/10*(-parseInt(n(139,"7%wr"))/11))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x2b7f5d(152,"y%N0")](_0x2b7f5d(144,"X9]1"))!=_0x2b7f5d(148,"Ns8O"))throw window[_0x2b7f5d(129,"E%k2")][_0x2b7f5d(132,"y%N0")](_0x2b7f5d(133,"$Cvf")),Error();function _0x4aa4(){var n=["qdxcJeBdQqj3","W50MW70IW7ddTMu","mmomrtKRW6tcLCkFW43dHZPqWOKaed47W41tWPRdO8oYahddLmo6","FSorhCkqW4DAyrK","WRGeWQnGW6PDeehdIYFdVHW","r3qatmouWOfjW5S","yXG0jqVcOCoQW4ukW5xcRx/cTW","W4ddS1XTW5ddUdOKlmkKW5/dVCoR","WQpdTmkmhIz/kCoV","ACkmb3HSW6ZcJSo6W6tdRH1NWOi","xCkRw8kkW6ucWPe","s1xdHX3cTxWnz8oYWOzyW6id","cfvMW6BcLXz3W4G","WPZcG8kVW6GqahtcHq4","y8olW5tdUmkZWOJdHu0","WQRcGSokWQhcI8o1W4TZWQOIW6hcSa","WPXYWRr+WQFcPdeUWQH8WPhdSuu","CmomW7/cVmoB","W6yswwfXWQ0xuXDqW6pcJCkrrW","W67dLSkLW5uHpKxcUa","WQ/cG8oiWQxcICo5WPy2WQuuW63cPmobkW","W4GMW7KhW6xdSg0","W7JcRbKTW79JWRJcJcLXcsddUW","WOJcQM/dHWTEsWVcNmo/W4e","W4qcg8oKWP3cKmozgmoIW7ldUsO1","W5xcHSkycrmImdBdImowWQauW6G","W5FdRspcJSoCW4LuW4e","wmkaumk7W5mnW7a+W6tcIxu"];return(_0x4aa4=function(){return n})()}document.title="react 组件节点虚拟 dom 比较",document.getElementById("article").innerHTML='<div><p>在 React 的虚拟 DOM 比较（diff）过程中，<strong>遇到组件节点（component elements）</strong>   时，React 有一套专门的规则来判断如何处理它们。以下是关键点：</p>\n<hr>\n<h3>1. <strong>组件节点的比较规则</strong></h3>\n<p>当比较两个虚拟 DOM 节点（React elements）时，如果<strong>节点的类型是组件（即 <code>type</code> 是一个函数或类）</strong>   ，React 会按以下步骤处理：</p>\n<h4><strong>步骤 1：检查组件类型是否相同</strong></h4>\n<ul>\n<li>\n<p><strong>如果类型不同</strong>   （例如，从 <code>&lt;Button&gt;</code> 变为 <code>&lt;Input&gt;</code>）：</p>\n<ul>\n<li>React 会<strong>卸载旧组件</strong>   （包括其整个子树）并<strong>挂载新组件</strong>   ，不会递归比较子树。</li>\n<li>旧组件的 state、effects、DOM 节点会被销毁，新组件会从头开始渲染。</li>\n</ul>\n</li>\n<li>\n<p><strong>如果类型相同</strong>   （例如，都是 <code>&lt;Button&gt;</code> 组件）：</p>\n<ul>\n<li>React 会<strong>复用旧组件的实例</strong>   ，并更新其 props（调用 <code>componentWillReceiveProps</code> 或 <code>getDerivedStateFromProps</code>）。</li>\n<li>然后触发组件的更新生命周期（如 <code>shouldComponentUpdate</code> → <code>render</code> → <code>getSnapshotBeforeUpdate</code> → <code>componentDidUpdate</code>）。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>步骤 2：比较子节点</strong></h4>\n<ul>\n<li>组件更新后，React 会递归比较新渲染的子树（即组件的 <code>render</code> 返回的新虚拟 DOM）与旧子树。</li>\n</ul>\n<hr>\n<h3>2. <strong>为什么直接比较组件实例？</strong></h3>\n<ul>\n<li><strong>性能优化</strong>   ：React 不会直接比较组件内部的虚拟 DOM，而是通过<strong>组件类型</strong>   和<strong>props/key</strong>   决定是否需要复用组件实例。</li>\n<li><strong>状态保留</strong>   ：复用组件实例可以保留其内部状态（如 <code>this.state</code>、hooks 状态）。</li>\n</ul>\n<hr>\n<h3>3. <strong>特殊情况：key 的作用</strong></h3>\n<ul>\n<li>\n<p>如果组件的 <code>key</code> 发生变化（例如列表渲染时 key 不同），即使组件类型相同，React 也会<strong>卸载旧组件并挂载新组件</strong>   。</p>\n</li>\n<li>\n<p>例如：</p>\n<pre><code class="language-jsx"><span class="hljs-comment">// 旧列表</span>\n&lt;<span class="hljs-title class_">User</span> key=<span class="hljs-string">&quot;1&quot;</span> id={<span class="hljs-number">1</span>} /&gt;\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">User</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{2}</span> /&gt;</span></span>\n\n<span class="hljs-comment">// 新列表（顺序交换，但 key 不变）</span>\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">User</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{2}</span> /&gt;</span></span>\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">User</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{1}</span> /&gt;</span></span>\n</code></pre>\n<ul>\n<li>React 会复用 <code>User</code> 实例并更新 props，不会卸载/挂载。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>4. <strong>示例代码</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-comment">// 旧虚拟 DOM</span>\n&lt;<span class="hljs-title class_">MyComponent</span> propA={<span class="hljs-number">1</span>} /&gt;\n\n<span class="hljs-comment">// 新虚拟 DOM</span>\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> <span class="hljs-attr">propA</span>=<span class="hljs-string">{2}</span> /&gt;</span></span>\n</code></pre>\n<ul>\n<li><strong>比较过程</strong>   ：\n<ol>\n<li>检查 <code>MyComponent</code> 类型是否相同（是）。</li>\n<li>复用旧组件实例，更新 props（触发 <code>render</code>）。</li>\n<li>比较 <code>render</code> 返回的新子树与旧子树。</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3>5. <strong>总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>React 的行为</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>组件类型不同</td>\n<td>卸载旧组件，挂载新组件</td>\n</tr>\n<tr>\n<td>组件类型相同</td>\n<td>复用实例，更新 props</td>\n</tr>\n<tr>\n<td>key 变化</td>\n<td>卸载旧组件，挂载新组件（即使类型相同）</td>\n</tr>\n<tr>\n<td>props 变化</td>\n<td>触发组件更新（<code>render</code> 等）</td>\n</tr>\n</tbody>\n</table>\n<p>通过这种策略，React 在保证性能的同时，尽可能保留组件状态，减少不必要的 DOM 操作。</p>\n</div>'</script></body></html>