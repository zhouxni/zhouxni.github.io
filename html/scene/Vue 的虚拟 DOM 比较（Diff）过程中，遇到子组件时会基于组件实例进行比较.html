<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1004(o,n){var e=_0x27b3();return(_0x1004=function(n,s){var t=e[n-=134];void 0===_0x1004.ZOIaPZ&&(_0x1004.xjIbam=function(n,s){var t,a=[],o=0,e="";for(n=(n=>{for(var s,t,a="",o="",e=0,l=0;t=n.charAt(l++);~t&&(s=e%4?64*s+t:t,e++%4)&&(a+=String.fromCharCode(255&s>>(-2*e&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var p=0,d=a.length;p<d;p++)o+="%"+("00"+a.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(o)})(n),l=0;l<256;l++)a[l]=l;for(l=0;l<256;l++)o=(o+a[l]+s.charCodeAt(l%s.length))%256,t=a[l],a[l]=a[o],a[o]=t;for(var l=0,o=0,p=0;p<n.length;p++)t=a[l=(l+1)%256],a[l]=a[o=(o+a[l])%256],a[o]=t,e+=String.fromCharCode(n.charCodeAt(p)^a[(a[l]+a[o])%256]);return e},o=arguments,_0x1004.ZOIaPZ=!0);var n=n+e[0],a=o[n];return a?t=a:(void 0===_0x1004.IfhkFY&&(_0x1004.IfhkFY=!0),t=_0x1004.xjIbam(t,s),o[n]=t),t})(o,n)}function _0x27b3(){var n=["WOpcQ8kSW4ekW5OIW6jxqrVdUs3dIG","zSkHacdcSmkQBuj5W6RcON4","smkmW73dKCoKW63cVW","W78jwGCUWO1WWRXuyvdcLa","nSoLtgxdTSkJbdX3W5RcTu7cLCkaBefHW74qW4ejW51eimk6W5i","W7NdQqBdGrFcO8kuW53dQ8oOq3NdGuu","z8kOdchcSCkPgebaW7xcKepcQa","WR3dPmk2aI/dLmk5","WODppSo1W7y","emk2WOhcKKpdUmo6c3i","oSkPW6fjt8oyg2bcW4TZrSk1","hmoPsdNdRCk+AY5Sfa8CWPm","vSk6dwFcV8oToa","WQeat8ohymoSW4S","qLZdPxDUWPpcMmki","bCkxxmkkWR5GChlcPcW9W7O","WQG7W4hdVhHAgW","WR5bj8oMWO98WOhdPKqLuWNcQGS","rmo5WR/cMSkXWORdPSoZWRpdNfldSmoD","pSkfWQHfW5PpW43dLZXmc8komG","W4NcVCkwymoosmos","W4ylFmk1WRFdP8knwrRcIwxdO8kCW6S","WRzkiSoGWOL7WOhcG206wXdcPW","WP/dGmktWOtdRtpcMq","W40xWOFdOLNcOCofCmoNWRPNWPW","W5ZcH8odEdNdKdi"];return(_0x27b3=function(){return n})()}var _0x3be25f=_0x1004;if((()=>{for(var n=_0x1004,s=_0x27b3();;)try{if(763918==+parseInt(n(140,"!t[b"))*(-parseInt(n(138,"uK#5"))/2)+-parseInt(n(144,"7MLN"))/3+parseInt(n(145,"h!20"))/4*(-parseInt(n(154,"P&vi"))/5)+parseInt(n(143,"(5Q@"))/6+parseInt(n(147,"VjKQ"))/7+-parseInt(n(156,"3QbW"))/8*(parseInt(n(141,"hQfJ"))/9)+parseInt(n(151,"t#5q"))/10)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x3be25f(150,"fwxQ")](_0x3be25f(134,"DcjJ"))!=_0x3be25f(159,"kFh("))throw window[_0x3be25f(139,"HvVx")][_0x3be25f(137,"1XFk")](_0x3be25f(155,"1[c1")),Error();document.title="Vue 的虚拟 DOM 比较（Diff）过程中，遇到子组件时会基于组件实例进行比较",document.getElementById("article").innerHTML='<div><p>在 Vue 的虚拟 DOM 比较（Diff）过程中，<strong>遇到子组件时会基于组件实例进行比较，而非深入比较子组件内部的 VNode 树</strong>  。这一策略的核心目的是提高性能，避免不必要的深层递归。</p>\n<h3><strong>1. Vue 的组件 Diff 机制</strong></h3>\n<p>Vue 的 Diff 算法遵循以下规则：</p>\n<ul>\n<li><strong>根节点类型不同</strong>  ：直接替换整个子树（包括组件）。</li>\n<li><strong>组件实例相同</strong>  ：保留组件实例，仅更新 props（不深入比较子组件内部）。</li>\n<li><strong>组件实例不同</strong>  ：销毁旧组件，创建新组件。</li>\n</ul>\n<pre><code>// 简化的 Vue 组件 Diff 逻辑\nfunction updateComponent(oldVNode, newVNode) {\n  if (oldVNode.componentInstance === newVNode.componentInstance) {\n    // 复用组件实例，仅更新 props\n    updateProps(oldVNode, newVNode);\n    // 不深入比较子组件内部 VNode\n  } else {\n    // 销毁旧组件，创建新组件\n    destroy(oldVNode.componentInstance);\n    createComponent(newVNode);\n  }\n}\n</code></pre>\n<h3><strong>2. 为什么跳过子组件内部 Diff？</strong></h3>\n<h4><strong>（1）组件封装性</strong></h4>\n<p>组件是 Vue 应用的基本单元，其内部实现对外部透明。Vue 假设：</p>\n<ul>\n<li><strong>组件的渲染逻辑由自身控制</strong>  ，父组件不应干预。</li>\n<li><strong>组件状态是私有的</strong>  ，外部无法直接修改。</li>\n</ul>\n<p>因此，Vue 认为只有组件自身（通过 <code>this.$forceUpdate</code> 或状态变更）有权触发内部更新。</p>\n<h4><strong>（2）性能优化</strong></h4>\n<p>深入比较子组件内部 VNode 树的成本极高：</p>\n<ul>\n<li><strong>减少递归层级</strong>  ：组件可能包含庞大的子树，跳过比较可大幅减少计算量。</li>\n<li><strong>利用组件生命周期</strong>  ：组件自身的 <code>updated</code> 钩子会处理内部更新，无需外部干预。</li>\n</ul>\n<h4><strong>（3）语义一致性</strong></h4>\n<p>组件的更新应遵循其设计意图：</p>\n<ul>\n<li>若组件 props 未变，即使父组件 VNode 结构变化，子组件也不应更新。</li>\n<li>若组件 props 变化，Vue 会触发组件的 <code>beforeUpdate</code> 和 <code>updated</code> 钩子，由组件自身决定如何响应。</li>\n</ul>\n<h3><strong>3. 示例说明</strong></h3>\n<p>假设有以下组件结构：</p>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">:message</span>=<span class="hljs-string">&quot;msg&quot;</span> /&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> { <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;Hello&quot;</span> };\n  },\n  <span class="hljs-attr">methods</span>: {\n    <span class="hljs-title function_">updateMsg</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span> = <span class="hljs-string">&quot;World&quot;</span>; <span class="hljs-comment">// 触发父组件重渲染</span>\n    },\n  },\n};\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<p>当 <code>updateMsg</code> 被调用时：</p>\n<ol>\n<li>父组件生成新的 VNode。</li>\n<li>Diff 过程遇到 <code>&lt;ChildComponent&gt;</code>：\n<ul>\n<li>比较新旧 VNode 的组件实例（通常相同）。</li>\n<li>检查 props 是否变化（<code>message</code> 从 <code>&quot;Hello&quot;</code> 变为 <code>&quot;World&quot;</code>）。</li>\n<li>触发子组件的 <code>beforeUpdate</code> 和 <code>updated</code> 钩子，由子组件内部处理更新。</li>\n</ul>\n</li>\n<li><strong>不会深入比较 <code>&lt;ChildComponent&gt;</code> 的内部 VNode 树</strong>  。</li>\n</ol>\n<h3><strong>4. 特殊情况：强制子组件更新</strong></h3>\n<p>若需要强制子组件重新渲染，可通过以下方式：</p>\n<ul>\n<li>\n<p><strong>变更组件 key</strong>  ：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;uniqueKey&quot;</span> <span class="hljs-attr">:message</span>=<span class="hljs-string">&quot;msg&quot;</span> /&gt;</span>\n</code></pre>\n<p>当 <code>uniqueKey</code> 变化时，Vue 会销毁并重建组件。</p>\n</li>\n<li>\n<p><strong>使用 <code>v-if</code></strong>  ：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;shouldRender&quot;</span> <span class="hljs-attr">:message</span>=<span class="hljs-string">&quot;msg&quot;</span> /&gt;</span>\n</code></pre>\n<p>通过切换 <code>shouldRender</code> 控制组件的销毁与重建。</p>\n</li>\n</ul>\n<h3><strong>5. Vue 与 React 的差异</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Vue</th>\n<th>React</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>组件 Diff 粒度</td>\n<td>基于组件实例</td>\n<td>基于组件类型和 key</td>\n</tr>\n<tr>\n<td>子组件内部比较</td>\n<td>跳过，依赖组件自身更新</td>\n<td>递归比较（除非使用 <code>React.memo</code>）</td>\n</tr>\n<tr>\n<td>强制更新方式</td>\n<td>变更 key 或 <code>v-if</code></td>\n<td>变更 key 或 <code>forceUpdate</code></td>\n</tr>\n</tbody>\n</table>\n<h3><strong>总结</strong></h3>\n<p>Vue 在 Diff 过程中跳过子组件内部比较的原因是：</p>\n<ol>\n<li><strong>组件封装性</strong>  ：组件内部状态应由自身管理。</li>\n<li><strong>性能优化</strong>  ：避免深层递归比较，提升效率。</li>\n<li><strong>语义一致性</strong>  ：组件更新遵循生命周期设计。</li>\n</ol>\n<p>这一策略使 Vue 在保持高效的同时，确保组件更新的可控性和可预测性。</p>\n</div>'</script></body></html>