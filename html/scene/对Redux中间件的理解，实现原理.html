<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2d64(e,s){var l=_0x21a8();return(_0x2d64=function(s,n){var a=l[s-=182];void 0===_0x2d64.eHVbgl&&(_0x2d64.qaudJz=function(s,n){var a,t=[],e=0,l="";for(s=(s=>{for(var n,a,t="",e="",l=0,c=0;a=s.charAt(c++);~a&&(n=l%4?64*n+a:a,l++%4)&&(t+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,o=t.length;p<o;p++)e+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(s),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)e=(e+t[c]+n.charCodeAt(c%n.length))%256,a=t[c],t[c]=t[e],t[e]=a;for(var c=0,e=0,p=0;p<s.length;p++)a=t[c=(c+1)%256],t[c]=t[e=(e+t[c])%256],t[e]=a,l+=String.fromCharCode(s.charCodeAt(p)^t[(t[c]+t[e])%256]);return l},e=arguments,_0x2d64.eHVbgl=!0);var s=s+l[0],t=e[s];return t?a=t:(void 0===_0x2d64.XsYGOD&&(_0x2d64.XsYGOD=!0),a=_0x2d64.qaudJz(a,n),e[s]=a),a})(e,s)}function _0x21a8(){var s=["mhddKSkFF1KH","FZddMmomWQS7yW","WOa2aGiJAfFcRa","trTlWOyYsJGBWPBdTwyymq","b8oJjSoVW5ZcOKv9i8kRya","W69CmCodWPrKDq","jmoUkuaPC0lcTmorDdPh","nqfaj8oxCCkeft7cM8ocm8o9WPRcMSorWPVdKCoyWPZdO8k4W6xcVtnB","jJOtWROJW5NcRfb7W4f9WOK","hmk0drxcIXPhW7pcGCoNW4m+W6m","WPldPhxcQ8ojWQHM","e1OHhSoyW6PZiYBcSxtdLa","eLORh8oDW643eqxcTxtdPHi","WPCkBmkKWP/dMCkrW49Ce8kP","DCk3hN/dMa7dI8kJs3NdHwq","WQlcHSongt7cOCoaWO41kmoB","FsddM8otWRm","WOJdJ09AW67dU1VcOSkSxHPvW4m","WOpcQmolW4ZdGSojW6JcOx52hCkHbJC","g0e1WRZdPCofWOL8WO8","ymoKqCkPCIddJr9Ccf7cQsVcQa","nafFsbNcQSo4W77dR1RdOq"];return(_0x21a8=function(){return s})()}var _0x518704=_0x2d64;if((()=>{for(var s=_0x2d64,n=_0x21a8();;)try{if(313946==-parseInt(s(202,"TVEi"))+-parseInt(s(200,"I^@S"))/2+parseInt(s(193,"k57l"))/3*(parseInt(s(199,"PBgP"))/4)+-parseInt(s(189,"us%j"))/5+-parseInt(s(198,"iayN"))/6+-parseInt(s(184,"b9x["))/7+parseInt(s(190,"Ta0c"))/8)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x518704(194,"[SOy")](_0x518704(191,"s$51"))!=_0x518704(188,"(GRt"))throw window[_0x518704(196,"Wwiv")][_0x518704(195,"(GRt")](_0x518704(201,"Dj%n")),Error();document.title="对Redux中间件的理解，实现原理",document.getElementById("article").innerHTML='<div><h3>对 Redux 中间件的理解</h3>\n<p>Redux 中间件（Middleware）是 Redux 架构中的一个重要概念，它位于 Action 被发起之后、到达 Reducer 之前。中间件的主要作用是增强 Redux 的能力，允许开发者在 Action 的处理过程中插入额外的逻辑，如异步请求、日志记录、错误报告、崩溃报告等。</p>\n<h4>中间件的核心功能</h4>\n<ol>\n<li><strong>拦截 Action</strong>  ：中间件可以拦截 Action，在 Action 到达 Reducer 之前对其进行处理或修改。</li>\n<li><strong>异步操作</strong>  ：Redux 本身是纯同步的，中间件可以处理异步操作，如 API 请求，并在异步操作完成后发起新的 Action。</li>\n<li><strong>日志和调试</strong>  ：中间件可以记录 Action 和 State 的变化，帮助开发者进行调试和性能分析。</li>\n<li><strong>错误处理</strong>  ：中间件可以捕获和处理异步操作中的错误，提升应用的健壮性。</li>\n</ol>\n<h3>Redux 中间件的实现原理</h3>\n<p>Redux 中间件的实现原理主要基于 Redux 的 <code>store.dispatch</code> 方法。中间件通过增强 <code>dispatch</code> 方法，在 Action 被派发到 Reducer 之前插入自定义的逻辑。</p>\n<h4>中间件的工作流程</h4>\n<ol>\n<li><strong>创建 Store 时应用中间件</strong>  ：在创建 Redux Store 时，通过 <code>applyMiddleware</code> 方法将中间件应用到 Store 上。</li>\n<li><strong>增强 <code>dispatch</code> 方法</strong>  ：中间件会增强 <code>dispatch</code> 方法，使其在执行 Action 之前和之后执行额外的逻辑。</li>\n<li><strong>链式调用</strong>  ：多个中间件可以形成链式调用，每个中间件都可以处理或修改 Action，然后将其传递给下一个中间件或最终的 Reducer。</li>\n</ol>\n<h4>中间件的实现示例</h4>\n<p>以下是一个简单的 Redux 中间件实现示例，展示了如何拦截和修改 Action：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 定义一个简单的中间件</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">loggerMiddleware</span> = store =&gt; <span class="hljs-function"><span class="hljs-params">next</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">action</span> =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Dispatching:&#x27;</span>, action);\n  <span class="hljs-keyword">let</span> result = <span class="hljs-title function_">next</span>(action);\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Next state:&#x27;</span>, store.<span class="hljs-title function_">getState</span>());\n  <span class="hljs-keyword">return</span> result;\n};\n\n<span class="hljs-comment">// 创建一个应用中间件的 Redux Store</span>\n<span class="hljs-keyword">import</span> { createStore, applyMiddleware } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;\n<span class="hljs-keyword">import</span> rootReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducers&#x27;</span>;\n\n<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(\n  rootReducer,\n  <span class="hljs-title function_">applyMiddleware</span>(loggerMiddleware)\n);\n\n<span class="hljs-comment">// 使用增强后的 dispatch 方法</span>\nstore.<span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> });\n</code></pre>\n<p>在这个示例中，<code>loggerMiddleware</code> 中间件会在每个 Action 被派发之前和之后打印日志。<code>applyMiddleware</code> 方法将中间件应用到 Store 上，增强了 <code>dispatch</code> 方法。</p>\n<h3>常见的 Redux 中间件</h3>\n<ol>\n<li><strong>Redux Thunk</strong>  ：用于处理异步操作，允许 Action Creator 返回函数而不是普通的 Action 对象。</li>\n<li><strong>Redux Saga</strong>  ：使用 ES6 的 Generator 函数来管理异步操作，提供了更强大的异步流程控制。</li>\n<li><strong>Redux Logger</strong>  ：用于记录 Action 和 State 的变化，帮助开发者进行调试。</li>\n<li><strong>Redux Promise</strong>  ：处理返回 Promise 的 Action Creator，自动将 Promise 的结果派发为新的 Action。</li>\n</ol>\n<h3>中间件的链式调用原理</h3>\n<p>Redux 中间件通过组合函数的方式实现链式调用。每个中间件都是一个接受 <code>store</code> 参数并返回下一个中间件的函数。最终，所有中间件会形成一个嵌套的函数调用链，每个中间件都可以在处理完自己的逻辑后调用下一个中间件。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 简化版的 applyMiddleware 实现原理</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">applyMiddleware</span> = (<span class="hljs-params">...middlewares</span>) =&gt; {\n  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">createStore</span> =&gt;</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(...args);\n    <span class="hljs-keyword">let</span> dispatch = store.<span class="hljs-property">dispatch</span>;\n\n    <span class="hljs-keyword">const</span> middlewareAPI = {\n      <span class="hljs-attr">getState</span>: store.<span class="hljs-property">getState</span>,\n      <span class="hljs-attr">dispatch</span>: <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(...args)\n    };\n\n    <span class="hljs-keyword">const</span> chain = middlewares.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">middleware</span> =&gt;</span> <span class="hljs-title function_">middleware</span>(middlewareAPI));\n    dispatch = <span class="hljs-title function_">compose</span>(...chain)(store.<span class="hljs-property">dispatch</span>);\n\n    <span class="hljs-keyword">return</span> {\n      ...store,\n      dispatch\n    };\n  };\n};\n\n<span class="hljs-comment">// compose 函数用于组合多个中间件</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">compose</span> = (<span class="hljs-params">...funcs</span>) =&gt; {\n  <span class="hljs-keyword">if</span> (funcs.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> arg;\n  }\n\n  <span class="hljs-keyword">if</span> (funcs.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) {\n    <span class="hljs-keyword">return</span> funcs[<span class="hljs-number">0</span>];\n  }\n\n  <span class="hljs-keyword">return</span> funcs.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-title function_">a</span>(<span class="hljs-title function_">b</span>(...args)));\n};\n</code></pre>\n<p>在这个简化版的 <code>applyMiddleware</code> 实现中，<code>compose</code> 函数用于组合多个中间件，形成一个嵌套的函数调用链。每个中间件都可以在处理完自己的逻辑后调用下一个中间件，最终将 Action 派发到 Reducer。</p>\n</div>'</script></body></html>