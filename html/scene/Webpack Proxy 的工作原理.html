<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x9f9ce3=_0x57a0;function _0x57a0(t,n){var o=_0x153d();return(_0x57a0=function(n,s){var a=o[n-=348];void 0===_0x57a0.LhwvXK&&(_0x57a0.GcpwPt=function(n,s){var a,r=[],t=0,o="";for(n=(n=>{for(var s,a,r="",t="",o=0,e=0;a=n.charAt(e++);~a&&(s=o%4?64*s+a:a,o++%4)&&(r+=String.fromCharCode(255&s>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,p=r.length;c<p;c++)t+="%"+("00"+r.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(n),e=0;e<256;e++)r[e]=e;for(e=0;e<256;e++)t=(t+r[e]+s.charCodeAt(e%s.length))%256,a=r[e],r[e]=r[t],r[t]=a;for(var e=0,t=0,c=0;c<n.length;c++)a=r[e=(e+1)%256],r[e]=r[t=(t+r[e])%256],r[t]=a,o+=String.fromCharCode(n.charCodeAt(c)^r[(r[e]+r[t])%256]);return o},t=arguments,_0x57a0.LhwvXK=!0);var n=n+o[0],r=t[n];return r?a=r:(void 0===_0x57a0.VXQrEq&&(_0x57a0.VXQrEq=!0),a=_0x57a0.GcpwPt(a,s),t[n]=a),a})(t,n)}function _0x153d(){var n=["W7SCftFdJ8kaCmk0WQJdLtBcQSoSW6/dUvvAtGFdPmodCLDoWQig","W5VcOmkVw8oYWO7dLSkflhRdKvW","W6TBtHJcOCoTh8kLWP1ZW6aB","DrRcUmo4WQ8EWOtdVmkZW4VcI8k3W5C","dLhdUGhdVmkekG","dHFcHx/cSCkKp2xdI8klWPO","WRq3EmkLW4DXW5RdQ8k1WQJcKg1L","hNZdJCkhWQ3dR0S1","WPtdHCoav1RcSSolfq","W4XcpIhcRtH1W7OIpgpcSG","vq5QWRPk","nmodW4/dGtxdMhe","WQfEvNdcI8kjASowWRZdQIJcNCoX","w1FcOa3cSHr/zG","osmLBmkjWRJdN8o3W4BdO0NdLYC","dXhcJxFcUmoXAe3dOCkPWQldQZq","WP/cSmk9WPuoBSkSWQRdG0rsW5jA","b8oAlCorzmoaW6S","uqlcNtXAW5pcKmoK","hCk4W5ZcKvxcQ0tcNtydAmoFiG","W7FdIceRcSktoSox","zq0Ctmobm8kkltBcPmkrWPq","osTFbmoOW73cVmoW","W4tdOmk3mCoAc8okWQje","WQpdKG0ec8k3iq","v8k6WOSKWQJdIujU","EsS5WOhdULLCWPxdOGlcM8o3WOu"];return(_0x153d=function(){return n})()}if((()=>{for(var n=_0x57a0,s=_0x153d();;)try{if(718205==+parseInt(n(357,"QJkb"))+parseInt(n(360,"O%Aw"))/2*(parseInt(n(362,"Mzh]"))/3)+parseInt(n(359,"O%Aw"))/4*(-parseInt(n(358,"Y94F"))/5)+parseInt(n(349,"C]FK"))/6*(-parseInt(n(353,"ToQ]"))/7)+-parseInt(n(354,"YJ7&"))/8+parseInt(n(374,"J8q9"))/9+-parseInt(n(350,"vuIk"))/10*(parseInt(n(361,"VVhi"))/11))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x9f9ce3(366,"1OWv")](_0x9f9ce3(351,"EZ6d"))!=_0x9f9ce3(365,"mu!g"))throw window[_0x9f9ce3(348,"SOZO")][_0x9f9ce3(372,"aY*h")](_0x9f9ce3(355,"ulk*")),Error();document.title="Webpack Proxy 的工作原理",document.getElementById("article").innerHTML='<div><p><strong>Webpack Proxy 的工作原理及解决跨域问题的原因如下</strong>  ：</p>\n<h3><strong>Webpack Proxy 工作原理</strong></h3>\n<ol>\n<li><strong>代理服务器</strong>  ：Webpack Proxy 是通过配置 Webpack Dev Server 的 <code>proxy</code> 选项来实现的。它充当了一个代理服务器的角色，拦截浏览器发出的请求，并将这些请求转发到目标服务器。</li>\n<li><strong>请求转发</strong>  ：当浏览器向开发服务器（如 <code>localhost:8080</code>）发送请求时，Webpack Dev Server 会检查该请求的路径是否符合代理规则。如果符合，它会将该请求转发到配置的目标服务器（如 <code>http://localhost:3000</code>）。</li>\n<li><strong>响应回传</strong>  ：目标服务器接收到请求后，处理并返回响应。Webpack Dev Server 代理服务器收到响应后，将其再转发给浏览器。整个过程对浏览器是透明的，浏览器并不知道请求实际上是由代理服务器转发的。</li>\n</ol>\n<h3><strong>为什么能解决跨域问题</strong></h3>\n<ol>\n<li><strong>浏览器同源策略</strong>  ：浏览器的同源策略限制了前端应用程序通过 XMLHttpRequest 或 Fetch API 等方式向不同域的服务器发送请求。同源策略要求请求的协议、域名和端口必须相同，否则会被认为是跨域请求，并被浏览器阻止。</li>\n<li><strong>代理服务器绕过同源策略</strong>  ：Webpack Proxy 通过代理服务器的形式绕过了浏览器的同源策略。代理服务器作为一个位于浏览器和目标服务器之间的中间层，实际上是在同一域内与目标服务器进行通信。当前端应用程序通过代理服务器发送请求时，请求的源被修改为与代理服务器相同的域，从而绕过了浏览器的同源策略限制。</li>\n<li><strong>服务器间通信无跨域限制</strong>  ：服务器与服务器之间的通信是不存在跨域问题的。因此，当代理服务器将请求转发到目标服务器时，目标服务器会正常处理请求并返回响应。代理服务器再将响应返回给前端应用程序，整个过程没有触发浏览器的跨域限制。</li>\n</ol>\n<h3><strong>示例配置</strong></h3>\n<p>以下是一个典型的 Webpack Proxy 配置示例：</p>\n<pre><code class="language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">devServer</span>: {\n    <span class="hljs-attr">proxy</span>: {\n      <span class="hljs-string">&#x27;/api&#x27;</span>: {\n        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>, <span class="hljs-comment">// 目标服务器地址</span>\n        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 改变源地址，解决请求头问题</span>\n        <span class="hljs-attr">pathRewrite</span>: { <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span> } <span class="hljs-comment">// 重写路径，去掉请求路径中的 /api</span>\n      }\n    }\n  }\n};\n</code></pre>\n<h3><strong>总结</strong></h3>\n<p>Webpack Proxy 通过配置代理服务器，将浏览器发出的请求转发到目标服务器，并返回响应给浏览器。这种方式绕过了浏览器的同源策略限制，解决了跨域问题。代理服务器的本质是使浏览器始终认为它是在与同源的服务器进行通信，而实际的请求是在服务器端完成的跨域。</p>\n</div>'</script></body></html>