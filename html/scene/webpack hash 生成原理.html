<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2fd803=_0x158b;function _0x158b(l,n){var r=_0x5a71();return(_0x158b=function(n,s){var a=r[n-=243];void 0===_0x158b.wzhGnL&&(_0x158b.RzsCPA=function(n,s){var a,t=[],l=0,r="";for(n=(n=>{for(var s,a,t="",l="",r=0,o=0;a=n.charAt(o++);~a&&(s=r%4?64*s+a:a,r++%4)&&(t+=String.fromCharCode(255&s>>(-2*r&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,e=t.length;c<e;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(n),o=0;o<256;o++)t[o]=o;for(o=0;o<256;o++)l=(l+t[o]+s.charCodeAt(o%s.length))%256,a=t[o],t[o]=t[l],t[l]=a;for(var o=0,l=0,c=0;c<n.length;c++)a=t[o=(o+1)%256],t[o]=t[l=(l+t[o])%256],t[l]=a,r+=String.fromCharCode(n.charCodeAt(c)^t[(t[o]+t[l])%256]);return r},l=arguments,_0x158b.wzhGnL=!0);var n=n+r[0],t=l[n];return t?a=t:(void 0===_0x158b.KZDoxU&&(_0x158b.KZDoxU=!0),a=_0x158b.RzsCPA(a,s),l[n]=a),a})(l,n)}if((()=>{for(var n=_0x158b,s=_0x5a71();;)try{if(528480==+parseInt(n(262,"*l2@"))+-parseInt(n(264,"8y)5"))/2*(parseInt(n(266,"8y)5"))/3)+parseInt(n(257,"8y)5"))/4*(parseInt(n(254,"a$HE"))/5)+-parseInt(n(260,"Uj(l"))/6+parseInt(n(252,"@SS@"))/7+parseInt(n(249,"3cg!"))/8*(-parseInt(n(251,"1HtF"))/9)+parseInt(n(261,"35CU"))/10)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x2fd803(255,"Uj(l")](_0x2fd803(250,"8WqF"))!=_0x2fd803(259,"kUAE"))throw window[_0x2fd803(265,"8WqF")][_0x2fd803(247,"!vE0")](_0x2fd803(253,"8y)5")),Error();function _0x5a71(){var n=["ySohxhRdQCouWPlcQYrlW74nwq","W61kd3tcOZOJpCkbetri","jfnbW67cUciYW6jyW7eHWO4m","idJcQSorq8o1WOSjWQ0bWRiriG","W5CBWPZcHXpdHHq","W6VdH15EeL0dWRCjW4GVW5VcNW","lJL9h3CclmkxACkRW61cWO4","DJK7WOZcL11DFCow","smoPWRddVLpcO8oIWQG","W6NdHLbBe1adWOebW4GFW6hcNW","WRCntJpdPZbUxmk/hITxW4FdVcBdGSkXWRKsWP7cQaNdMCoJeSoL","WRjiWQL4yK8g","wSk3WQ3cGSoOsmoJ","f8ozcCoFW7JdPGfw","W61iaNFcPdX5omkrlHzUW6u","aHCVWOVcTNr1","h8kcEmoCuq","dSoKW67dUmkKgCk2rWTJW6iRAW","iSkwWQKuaYSfWOfiD8oKWOv7aW","vCkHW47cGSorkeRdHmkEsCoqEq","WO8lwLvcW5COW7tcMCo/","W6TkdJVdSgKKjSkx","wZu7WOJcKeD5DG","W6TkchddMKSlcSkvda","y3RcQutdQ8kQCcddNW"];return(_0x5a71=function(){return n})()}document.title="webpack hash 生成原理",document.getElementById("article").innerHTML='<div><p>在 <strong>Webpack</strong>   打包过程中，<strong>Hash 码</strong>  的生成主要基于文件内容的哈希值，旨在确保每次文件内容有变动时，输出的文件名也会相应改变，从而强制浏览器重新下载更新的资源。Webpack 提供了多种哈希生成策略，以下是详细解析：</p>\n<h3>1. <strong>Hash 码生成方式</strong></h3>\n<p>Webpack 中主要有三种类型的哈希值：<code>hash</code>、<code>chunkhash</code> 和 <code>contenthash</code>。</p>\n<ul>\n<li><strong><code>hash</code></strong>  ：\n<ul>\n<li><strong>原理</strong>  ：基于整个项目构建生成的唯一哈希值。</li>\n<li><strong>特点</strong>  ：只要项目中有任何一个文件变化，所有文件的哈希值都会改变。</li>\n<li><strong>适用场景</strong>  ：适用于项目较小或不太关心客户端缓存的情况。</li>\n<li><strong>示例配置</strong>  ：<pre><code class="language-javascript"><span class="hljs-attr">output</span>: {\n  <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].[hash].js&#x27;</span>,\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong><code>chunkhash</code></strong>  ：\n<ul>\n<li><strong>原理</strong>  ：基于每个 <strong>chunk</strong>  （代码块）生成的哈希值。</li>\n<li><strong>特点</strong>  ：只有当该 <strong>chunk</strong>   的内容发生变化时，对应的哈希值才会改变。</li>\n<li><strong>适用场景</strong>  ：适用于代码分割、懒加载等项目，可以更细粒度地控制缓存。</li>\n<li><strong>示例配置</strong>  ：<pre><code class="language-javascript"><span class="hljs-attr">output</span>: {\n  <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].[chunkhash].js&#x27;</span>,\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong><code>contenthash</code></strong>  ：\n<ul>\n<li><strong>原理</strong>  ：基于文件内容本身生成的哈希值。</li>\n<li><strong>特点</strong>  ：如果文件内容没有变化，即使其他文件发生变化，<code>contenthash</code> 也不会改变。</li>\n<li><strong>适用场景</strong>  ：特别适用于样式文件（如 CSS）或其他可以独立缓存的资源。</li>\n<li><strong>示例配置</strong>  ：<pre><code class="language-javascript"><span class="hljs-attr">output</span>: {\n  <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].[contenthash].js&#x27;</span>,\n}\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3>2. <strong>哈希生成过程</strong></h3>\n<p>Webpack 在构建过程中，会根据源码内容生成哈希值。具体过程如下：</p>\n<ol>\n<li><strong>获取模块哈希</strong>  ：\n<ul>\n<li>Webpack 在 <strong>build</strong>   阶段为每个模块生成一个 <code>_buildHash</code>。</li>\n<li>这个哈希值是基于模块的源码内容生成的。</li>\n</ul>\n</li>\n<li><strong>生成 **  chunk</strong> 哈希**  ：\n<ul>\n<li>对于每个 <strong>chunk</strong>  ，Webpack 会将其包含的所有模块的哈希值作为内容，生成一个 <strong>chunk</strong>   的哈希值。</li>\n</ul>\n</li>\n<li><strong>生成最终哈希</strong>  ：\n<ul>\n<li>如果使用 <code>hash</code>，Webpack 会将所有 <strong>chunk</strong>   的哈希值作为内容，生成最终的哈希值。</li>\n<li>如果使用 <code>chunkhash</code>，则直接使用每个 <strong>chunk</strong>   的哈希值。</li>\n<li>如果使用 <code>contenthash</code>，则基于文件内容生成独立的哈希值。</li>\n</ul>\n</li>\n</ol>\n<h3>3. <strong>避免哈希冲突</strong></h3>\n<p>虽然哈希算法（如 MD5、SHA-1 等）本身具有较低的碰撞概率，但在极端情况下仍可能发生哈希冲突。为了进一步降低冲突的可能性，可以采取以下措施：</p>\n<ul>\n<li><strong>确保唯一性</strong>  ：\n<ul>\n<li>确保每个模块或文件都有其独特的标识，避免重复的代码或资源。</li>\n<li>如果是动态生成的文件，确保每次生成的内容都有微小差异。</li>\n</ul>\n</li>\n<li><strong>调整哈希算法</strong>  ：\n<ul>\n<li>可以考虑使用更不容易出现碰撞的哈希算法，如 SHA-256 或 SHA-3。</li>\n</ul>\n</li>\n<li><strong>添加前缀或时间戳</strong>  ：\n<ul>\n<li>在文件名中添加前缀或时间戳，即使哈希碰撞，文件名也是唯一的。</li>\n</ul>\n</li>\n</ul>\n<h3>4. <strong>配置示例</strong></h3>\n<p>以下是一个完整的 Webpack 配置示例，展示了如何使用不同的哈希策略：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">entry</span>: {\n    <span class="hljs-attr">app</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,\n    <span class="hljs-attr">vendor</span>: [<span class="hljs-string">&#x27;react&#x27;</span>, <span class="hljs-string">&#x27;react-dom&#x27;</span>],\n  },\n  <span class="hljs-attr">output</span>: {\n    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),\n    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].[contenthash].js&#x27;</span>, <span class="hljs-comment">// 使用 contenthash</span>\n    <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&#x27;[name].[chunkhash].chunk.js&#x27;</span>, <span class="hljs-comment">// 使用 chunkhash</span>\n  },\n  <span class="hljs-attr">optimization</span>: {\n    <span class="hljs-attr">splitChunks</span>: {\n      <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>,\n    },\n  },\n};\n</code></pre>\n<h3>5. <strong>总结</strong></h3>\n<ul>\n<li><strong><code>hash</code></strong>  ：适用于整个项目，但任何文件变化都会导致所有文件哈希值改变。</li>\n<li><strong><code>chunkhash</code></strong>  ：适用于代码分割，只有相关 <strong>chunk</strong>   变化时哈希值才会改变。</li>\n<li><strong><code>contenthash</code></strong>  ：适用于独立缓存的资源，只有文件内容变化时哈希值才会改变。</li>\n</ul>\n<p>通过合理使用这些哈希策略，可以有效优化打包过程，提高前端资源的管理、性能和安全性。</p>\n</div>'</script></body></html>