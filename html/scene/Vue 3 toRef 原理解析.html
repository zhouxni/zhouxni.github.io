<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x39df(){var s=["WQfAWQ/cRSonWOZcPcxcQg1sEN8w","WRfSWPamEmkGWPVdPSk8WRy+fG","eSk+vCkbf8kMs8kQuq","ewddTwf/W7Gmzq","W4D4mmkHW4/cLtNcMCokDdijjJJcMM15cSkJWRipWPpcU1ddN0i","uSk9aepdUmo5aSkIW6vHW4q","W7qnW67dN8kjW5/dVW","jmoOwHdcUCoyoCkuW4u","f8k7umoGxSoYjCkgz8o6lSozW7S","W4PxWOdcGWTAWPSM","W7LLWOrkxCkryLNdUZO","eSk7v8oLnmksxmkvxSoU","xmooWOG4vX1htSk3C8of","BKBcVSoiWOZdOKG","WOb5WOFcG2Tzv0mCga","lMNcMWFcVCkqfCkJj8olWQTZW6y","WQBcGCk5W5ahW5nPW6bGFW","WPv5gJBdVGpcVba8WQrrWPlcQa","rvpcNCoDwCoBsqhdNq","WP0+CCoPWOZcMsdcJSobxtWXndK","W79Ya25KW458W6niW64LW4m","vL0sWQVdSCo0Amocr8khnHZcTG","WR82W4yqxSk7rq","WP04jSkYW5tdGg7dSq","Bmo4f8kCo8koWRtdSSkqWQucW5FdPq","AguuWRZdPNNdKq","WP7cSSkUa2aLW6RdHttdRsBcUha","W5znrSkeWOu"];return(_0x39df=function(){return s})()}var _0x34d74d=_0x161e;function _0x161e(t,s){var e=_0x39df();return(_0x161e=function(s,n){var a=e[s-=437];void 0===_0x161e.QAPCXT&&(_0x161e.LJCQim=function(s,n){var a,l=[],t=0,e="";for(s=(s=>{for(var n,a,l="",t="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=l.length;c<o;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)t=(t+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[t],l[t]=a;for(var p=0,t=0,c=0;c<s.length;c++)a=l[p=(p+1)%256],l[p]=l[t=(t+l[p])%256],l[t]=a,e+=String.fromCharCode(s.charCodeAt(c)^l[(l[p]+l[t])%256]);return e},t=arguments,_0x161e.QAPCXT=!0);var s=s+e[0],l=t[s];return l?a=l:(void 0===_0x161e.OifYsu&&(_0x161e.OifYsu=!0),a=_0x161e.LJCQim(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x161e,n=_0x39df();;)try{if(452038==+parseInt(s(451,"ZgXz"))*(-parseInt(s(458,"v&**"))/2)+parseInt(s(448,"^ID]"))/3*(-parseInt(s(452,"ke!T"))/4)+-parseInt(s(440,"0AFv"))/5*(parseInt(s(443,"QFn0"))/6)+-parseInt(s(464,"K(8w"))/7+parseInt(s(447,"y%Z$"))/8*(parseInt(s(453,"e*8]"))/9)+-parseInt(s(455,"L6ZP"))/10+parseInt(s(457,"Toog"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x34d74d(444,"Y)o)")](_0x34d74d(445,"QFn0"))!=_0x34d74d(437,"Bdj!"))throw window[_0x34d74d(441,"@f1l")][_0x34d74d(460,"^ID]")](_0x34d74d(442,"Toog")),Error();document.title="Vue 3 toRef 原理解析",document.getElementById("article").innerHTML='<div><p><code>toRef</code> 是 Vue 3 响应式系统中一个重要的工具函数，用于从响应式对象的属性创建 ref 引用。下面我将从多个角度深入解析其实现原理。</p>\n<h2>1. 核心设计思想</h2>\n<p><code>toRef</code> 的核心目标是：</p>\n<ul>\n<li><strong>保持响应式链接</strong>  ：创建的 ref 与源对象属性保持双向响应式连接</li>\n<li><strong>轻量级代理</strong>  ：不创建额外的响应式依赖，仅作为访问代理</li>\n<li><strong>延迟触发</strong>  ：修改 ref 不会立即触发依赖，而是通过源对象的响应式系统触发</li>\n</ul>\n<h2>2. 源码实现分析</h2>\n<h3>2.1 基础实现（reactivity/src/ref.ts）</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> toRef&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>, K <span class="hljs-keyword">extends</span> keyof T&gt;(\n  <span class="hljs-attr">object</span>: T,\n  <span class="hljs-attr">key</span>: K,\n  <span class="hljs-attr">defaultValue</span>?: T[K]\n): <span class="hljs-title class_">ToRef</span>&lt;T[K]&gt; {\n  <span class="hljs-keyword">const</span> val = <span class="hljs-built_in">object</span>[key]\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">isRef</span>(val)\n    ? val\n    : (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectRefImpl</span>(\n        <span class="hljs-built_in">object</span>,\n        key,\n        defaultValue\n      ) <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)\n}\n</code></pre>\n<h3>2.2 ObjectRefImpl 类实现</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectRefImpl</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>, K <span class="hljs-keyword">extends</span> keyof T&gt; {\n  <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> __v_isRef = <span class="hljs-literal">true</span>\n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">_object</span>: T,\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">_key</span>: K,\n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">_defaultValue</span>?: T[K]\n  </span>) {}\n\n  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() {\n    <span class="hljs-keyword">const</span> val = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_object</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">_key</span>]\n    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">_defaultValue</span>! : val\n  }\n\n  <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">newVal</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_object</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">_key</span>] = newVal\n  }\n}\n</code></pre>\n<h2>3. 关键机制解析</h2>\n<h3>3.1 响应式保持原理</h3>\n<p><code>toRef</code> 通过以下方式保持响应式：</p>\n<ol>\n<li><strong>代理访问</strong>  ：通过 getter/setter 代理到源对象属性</li>\n<li><strong>依赖收集</strong>  ：通过源对象的响应式系统自动收集依赖</li>\n<li><strong>触发更新</strong>  ：修改操作通过源对象的 setter 触发更新</li>\n</ol>\n<h3>3.2 与原始 ref 的区别</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>ref</code></th>\n<th><code>toRef</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>存储方式</td>\n<td>独立响应式对象</td>\n<td>源对象属性代理</td>\n</tr>\n<tr>\n<td>初始化触发</td>\n<td>立即触发</td>\n<td>延迟触发</td>\n</tr>\n<tr>\n<td>内存开销</td>\n<td>较高</td>\n<td>极低</td>\n</tr>\n<tr>\n<td>典型用途</td>\n<td>独立值</td>\n<td>对象属性转发</td>\n</tr>\n</tbody>\n</table>\n<h3>3.3 类型系统支持</h3>\n<p>类型定义体现了其设计意图：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ToRef</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Ref</span>&lt;T&gt; {\n  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">__v_isRef</span>: <span class="hljs-literal">true</span>\n}\n</code></pre>\n<h2>4. 响应式链路分析</h2>\n<pre><code>源响应式对象 (reactive)\n  ↓\nObjectRefImpl 代理\n  ├─ get → 触发源对象的 get 拦截器（收集依赖）\n  └─ set → 触发源对象的 set 拦截器（触发更新）\n</code></pre>\n<h2>5. 特殊场景处理</h2>\n<h3>5.1 默认值支持</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">foo</span>: <span class="hljs-literal">undefined</span> })\n<span class="hljs-keyword">const</span> fooRef = <span class="hljs-title function_">toRef</span>(obj, <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;default&#x27;</span>)\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fooRef.<span class="hljs-property">value</span>) <span class="hljs-comment">// &#x27;default&#x27;</span>\n</code></pre>\n<h3>5.2 与 computed 的结合</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> computedRef = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">toRef</span>(obj, <span class="hljs-string">&#x27;key&#x27;</span>).<span class="hljs-property">value</span>)\n</code></pre>\n<h2>6. 性能优化设计</h2>\n<ol>\n<li><strong>轻量级代理</strong>  ：不创建额外的依赖收集结构</li>\n<li><strong>惰性求值</strong>  ：仅在访问时获取当前值</li>\n<li><strong>直接委托</strong>  ：操作直接转发到源对象</li>\n</ol>\n<h2>7. 使用场景示例</h2>\n<h3>7.1 组合式函数属性暴露</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useCounter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> })\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">count</span>: <span class="hljs-title function_">toRef</span>(state, <span class="hljs-string">&#x27;count&#x27;</span>) <span class="hljs-comment">// 安全暴露</span>\n  }\n}\n</code></pre>\n<h3>7.2 模板属性传递</h3>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">:count</span>=<span class="hljs-string">&quot;countRef&quot;</span>/&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> })\n<span class="hljs-keyword">const</span> countRef = <span class="hljs-title function_">toRef</span>(state, <span class="hljs-string">&#x27;count&#x27;</span>)\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<h2>8. 限制与注意事项</h2>\n<ol>\n<li><strong>源对象必须响应式</strong>  ：普通对象创建的 ref 无响应性</li>\n<li><strong>属性必须存在</strong>  ：访问不存在的属性会返回 undefined</li>\n<li><strong>数组处理</strong>  ：可以用于数组索引（如 <code>toRef(arr, 0)</code>）</li>\n</ol>\n<p><code>toRef</code> 的这种设计使其成为 Vue 3 响应式系统中高效连接对象属性和 ref 世界的桥梁，特别适合在需要保持响应式链接又不想创建额外响应式对象的场景中使用。</p>\n</div>'</script></body></html>