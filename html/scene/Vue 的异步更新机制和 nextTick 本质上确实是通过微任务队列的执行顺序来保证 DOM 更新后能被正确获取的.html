<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x55a8(){var n=["W5CKWR5We8oVWOntWO0","WQiHWRvbnmoAWQS","W4tdKmoPlCo7W4PT","fbqIW53dVaxcS8oicCoqjSkpga","pYyswZtdR8oFW4CyW5RdPmoI","WPdcMmkDW6OSWRhcOCkQWQ4eW4Pc","Cw0wW6vNBSkHWQ8qBCkhC8kMW6y","WQelWPe9WRmegMRcJCk4o8ol","DdaPw8okWOn8W4ZdIIKCvgK","WQD+W60LvmkUW7P3WRP4BCodBq","WRxdGcRcM1pdI8kI","WRxcS3RdLY3cVCk7W4VcO8o5WP3dQW","W7KCtCoqW6CKzhSVfSoen8kp","lCk5WQJcS15KW50JWQHkcCknW7OG","ENPxawBcTCoj","dmoKCSkxlmkMW7K","WPFdG0j8FG3dHa","WOVdGCoUA1tdR3O","thVdUSkDktDU","qGxcPSoFvefjamo0xCkJgW","W7vQWOHpWPD9WPRcQmk+WPyLzrO","W7DsbSoOAG","lZjaWReNn8o8W7K","W4NcH8kaDSkhWQDRugBdUw1T","nrnVWP/cOdz/","ht4NuM/cPbi","W6xcQmkoW4iMaWNdQ8kPWQ/cQSkcia","huJdP8kzfeivA8ouvmkJdmoQm8oUWPhcUGj2WO0TvbL4WPFdTa"];return(_0x55a8=function(){return n})()}function _0x4931(o,n){var t=_0x55a8();return(_0x4931=function(n,s){var e=t[n-=500];void 0===_0x4931.KnnQNI&&(_0x4931.TKFpbn=function(n,s){var e,a=[],o=0,t="";for(n=(n=>{for(var s,e,a="",o="",t=0,c=0;e=n.charAt(c++);~e&&(s=t%4?64*s+e:e,t++%4)&&(a+=String.fromCharCode(255&s>>(-2*t&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var l=0,r=a.length;l<r;l++)o+="%"+("00"+a.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(o)})(n),c=0;c<256;c++)a[c]=c;for(c=0;c<256;c++)o=(o+a[c]+s.charCodeAt(c%s.length))%256,e=a[c],a[c]=a[o],a[o]=e;for(var c=0,o=0,l=0;l<n.length;l++)e=a[c=(c+1)%256],a[c]=a[o=(o+a[c])%256],a[o]=e,t+=String.fromCharCode(n.charCodeAt(l)^a[(a[c]+a[o])%256]);return t},o=arguments,_0x4931.KnnQNI=!0);var n=n+t[0],a=o[n];return a?e=a:(void 0===_0x4931.xhStKy&&(_0x4931.xhStKy=!0),e=_0x4931.TKFpbn(e,s),o[n]=e),e})(o,n)}var _0x53b46a=_0x4931;if((()=>{for(var n=_0x4931,s=_0x55a8();;)try{if(462047==-parseInt(n(510,"6$F!"))+parseInt(n(501,"KAik"))/2*(parseInt(n(509,"PMPw"))/3)+-parseInt(n(506,"Z8e3"))/4*(parseInt(n(508,"c2Wa"))/5)+-parseInt(n(514,"Z8e3"))/6+parseInt(n(500,"M5qg"))/7*(-parseInt(n(522,"Sm]1"))/8)+-parseInt(n(523,"[Q0s"))/9*(parseInt(n(503,"a$T!"))/10)+parseInt(n(518,"Ixds"))/11)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x53b46a(520,"EArj")](_0x53b46a(505,"Z8e3"))!=_0x53b46a(526,"qk8l"))throw window[_0x53b46a(527,"V)ll")][_0x53b46a(519,"PMPw")](_0x53b46a(504,"[Q0s")),Error();document.title="Vue 的异步更新机制和 nextTick 本质上确实是通过微任务队列的执行顺序来保证 DOM 更新后能被正确获取的",document.getElementById("article").innerHTML='<div><p>你的理解非常核心！Vue 的异步更新机制和 <code>nextTick</code> 本质上确实是通过<strong>微任务队列的执行顺序</strong>   来保证 DOM 更新后能被正确获取的，具体可以拆解为以下逻辑：</p>\n<h3>一、Vue 异步更新的本质：依赖微任务延迟 DOM 操作</h3>\n<p>当你在 Vue 中修改响应式数据（如 <code>this.msg = \'new\'</code>）时，Vue 并不会立即更新 DOM，而是：</p>\n<ol>\n<li>将 DOM 更新操作<strong>延迟到当前同步代码执行完毕后</strong>   。</li>\n<li>通过<strong>微任务（Microtask）</strong>   来调度 DOM 更新（Vue 内部优先使用 <code>Promise.then</code>，其次是 <code>MutationObserver</code> 等，均为微任务）。</li>\n</ol>\n<p><strong>原因</strong>   ：如果每次数据变化都立即更新 DOM，频繁的 DOM 操作会导致性能损耗（如多次修改数据触发多次重排/重绘）。Vue 通过“批量更新”策略，将同一轮事件循环中的所有数据变化对应的 DOM 更新合并，最终只执行一次 DOM 操作。</p>\n<h3>二、<code>nextTick</code> 的作用：在 DOM 更新后执行回调</h3>\n<p><code>nextTick</code> 的核心功能是：<strong>将回调函数放入微任务队列，且确保它在 Vue 内部的 DOM 更新微任务之后执行</strong>   。</p>\n<ul>\n<li>当你调用 <code>this.$nextTick(cb)</code> 时，<code>cb</code> 会被添加到微任务队列。</li>\n<li>由于 Vue 内部的 DOM 更新逻辑已经先一步进入微任务队列，因此 <code>cb</code> 会在 DOM 更新完成后执行，此时就能获取到更新后的 DOM。</li>\n</ul>\n<h3>三、微任务的执行顺序：“更新微任务”在前，“nextTick 微任务”在后</h3>\n<p>用一个例子直观说明：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 组件中</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span> = <span class="hljs-string">&quot;new message&quot;</span>; <span class="hljs-comment">// 修改响应式数据，触发异步更新</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;同步代码：&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-property">textContent</span>); <span class="hljs-comment">// 输出旧值（DOM 未更新）</span>\n\n<span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;nextTick 回调：&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-property">textContent</span>); <span class="hljs-comment">// 输出新值（DOM 已更新）</span>\n});\n</code></pre>\n<p><strong>微任务队列的执行流程</strong>   ：</p>\n<ol>\n<li>同步代码执行完毕（修改 <code>this.msg</code> 后，Vue 内部将 DOM 更新逻辑放入微任务队列）。</li>\n<li>执行微任务队列：\n<ul>\n<li><strong>第一步</strong>   ：执行 Vue 内部的 DOM 更新微任务（此时 DOM 被更新）。</li>\n<li><strong>第二步</strong>   ：执行 <code>nextTick</code> 回调的微任务（此时能获取到更新后的 DOM）。</li>\n</ul>\n</li>\n</ol>\n<h3>四、为什么是微任务，而非宏任务？</h3>\n<p>微任务的特点是<strong>在当前同步代码执行完毕后立即执行</strong>   （优先于宏任务，如 <code>setTimeout</code>），这保证了：</p>\n<ul>\n<li>DOM 更新的延迟时间最短（避免用户感知到延迟）。</li>\n<li><code>nextTick</code> 回调能以最快速度获取更新后的 DOM，而不必等待宏任务的长延迟。</li>\n</ul>\n<p>如果用宏任务（如 <code>setTimeout</code>），虽然也能获取更新后的 DOM，但会增加不必要的延迟（至少等待 4ms，且受事件循环影响更大）。</p>\n<h3>总结</h3>\n<ul>\n<li>Vue 的异步更新：通过<strong>微任务延迟 DOM 更新</strong>   ，实现批量更新优化。</li>\n<li><code>nextTick</code>：通过<strong>在 DOM 更新微任务之后插入回调微任务</strong>   ，保证能获取更新后的 DOM。</li>\n</ul>\n<p>两者的核心逻辑确实是<strong>微任务的先后顺序</strong>   ：Vue 内部的 DOM 更新微任务先执行，<code>nextTick</code> 的回调微任务后执行，从而实现“数据更新 → DOM 更新 → 回调获取 DOM”的完整流程。</p>\n</div>'</script></body></html>