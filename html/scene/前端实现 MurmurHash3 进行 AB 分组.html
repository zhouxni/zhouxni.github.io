<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x137fbe=_0x34bb;function _0x34bb(p,s){var t=_0x15c1();return(_0x34bb=function(s,n){var a=t[s-=292];void 0===_0x34bb.ZhFfwn&&(_0x34bb.zvjBKf=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,e=0;a=s.charAt(e++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=l.length;c<r;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[p],l[p]=a;for(var e=0,p=0,c=0;c<s.length;c++)a=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[p])%256]);return t},p=arguments,_0x34bb.ZhFfwn=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x34bb.xzzjCo&&(_0x34bb.xzzjCo=!0),a=_0x34bb.zvjBKf(a,n),p[s]=a),a})(p,s)}if((()=>{for(var s=_0x34bb,n=_0x15c1();;)try{if(182638==-parseInt(s(305,"oc4$"))+-parseInt(s(302,"pSvp"))/2+-parseInt(s(310,"ct4g"))/3+-parseInt(s(311,"9d4S"))/4+-parseInt(s(313,"qCy6"))/5*(-parseInt(s(315,"p!kV"))/6)+-parseInt(s(299,"kGr]"))/7+-parseInt(s(297,"!Dwj"))/8*(-parseInt(s(293,"N&nC"))/9))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x137fbe(308,"k[4M")](_0x137fbe(306,"N&nC"))!=_0x137fbe(307,"sdA^"))throw window[_0x137fbe(295,"mK%B")][_0x137fbe(294,"qVa(")](_0x137fbe(304,"mK%B")),Error();function _0x15c1(){var s=["W7jzeSoQfrBcJL3cTSknWRCh","W6ddKaHZW4RdRMjlWPhcMxBdQw3dQ8kcWRvvxNz9W7KlC8o/W78w","l8oSWP3cIwBcM1rzWPugW48m","k8kPfmoSeZBdV0VcLG","WPddNZ0Dxa","aSoGW5zqg3On","rw5zW4ddM27cRqTvdwhdNW","W5JdStlcJCksW4tdMtifWOtcIci","f8kdWRlcGSkPa1BcM8k4wSoJnG","WRZcLuHzW73cOd48WOm","bmopW7RcHIpdG8oIpmk9","qL17W5z9F8ouW4ZdHe5zeW","rSkBWOD6WR3dM8kMvCoTsaq","W5G0W4pdJCofW5ddSuP4WPxcNa","xSo7q8otjdhdH3BcHW","WO7cItaHFZis","W6tdIX9IW43cVsik","W6O8y1O3W7jdWQuR","nSkMvCk2W4JdLmobW4xcHmoFnHW","W6ehWRZcOSkQWPGVW6hcRXCAhW","pxOoWPqph8kVESo9pfldLG","WPhdK8kDzmkftG3dVJPgaSkb","rM1qW4hdMwVcRZfsigZdTW","WOxdVMldHJiKWRGHCI/dKCoW"];return(_0x15c1=function(){return s})()}document.title="前端实现 MurmurHash3 进行 AB 分组",document.getElementById("article").innerHTML='<div><p>MurmurHash3 是一种非加密型哈希函数，适用于一般的哈希检索操作。在前端实现 A/B 测试分组时，可以使用 MurmurHash3 来确保用户被稳定地分配到同一分组。</p>\n<h2>实现方案</h2>\n<h3>1. 引入 MurmurHash3 实现</h3>\n<p>首先需要一个 JavaScript 实现的 MurmurHash3。以下是简化版本：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">murmurhash3_32_gc</span>(<span class="hljs-params">key, seed = <span class="hljs-number">0</span></span>) {\n  <span class="hljs-keyword">let</span> h1 = seed;\n  <span class="hljs-keyword">const</span> c1 = <span class="hljs-number">0xcc9e2d51</span>;\n  <span class="hljs-keyword">const</span> c2 = <span class="hljs-number">0x1b873593</span>;\n  <span class="hljs-keyword">const</span> length = key.<span class="hljs-property">length</span>;\n\n  <span class="hljs-keyword">let</span> k1;\n  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;\n\n  <span class="hljs-keyword">while</span> (i + <span class="hljs-number">4</span> &lt;= length) {\n    k1 =\n      (key.<span class="hljs-title function_">charCodeAt</span>(i) &amp; <span class="hljs-number">0xff</span>) |\n      ((key.<span class="hljs-title function_">charCodeAt</span>(++i) &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">8</span>) |\n      ((key.<span class="hljs-title function_">charCodeAt</span>(++i) &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">16</span>) |\n      ((key.<span class="hljs-title function_">charCodeAt</span>(++i) &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">24</span>);\n    ++i;\n\n    k1 = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">imul</span>(k1, c1);\n    k1 = (k1 &lt;&lt; <span class="hljs-number">15</span>) | (k1 &gt;&gt;&gt; <span class="hljs-number">17</span>);\n    k1 = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">imul</span>(k1, c2);\n\n    h1 ^= k1;\n    h1 = (h1 &lt;&lt; <span class="hljs-number">13</span>) | (h1 &gt;&gt;&gt; <span class="hljs-number">19</span>);\n    h1 = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">imul</span>(h1, <span class="hljs-number">5</span>) + <span class="hljs-number">0xe6546b64</span>;\n  }\n\n  k1 = <span class="hljs-number">0</span>;\n\n  <span class="hljs-keyword">switch</span> (length - i) {\n    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:\n      k1 ^= (key.<span class="hljs-title function_">charCodeAt</span>(i + <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">16</span>;\n    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:\n      k1 ^= (key.<span class="hljs-title function_">charCodeAt</span>(i + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">8</span>;\n    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:\n      k1 ^= key.<span class="hljs-title function_">charCodeAt</span>(i) &amp; <span class="hljs-number">0xff</span>;\n      k1 = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">imul</span>(k1, c1);\n      k1 = (k1 &lt;&lt; <span class="hljs-number">15</span>) | (k1 &gt;&gt;&gt; <span class="hljs-number">17</span>);\n      k1 = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">imul</span>(k1, c2);\n      h1 ^= k1;\n  }\n\n  h1 ^= length;\n\n  h1 ^= h1 &gt;&gt;&gt; <span class="hljs-number">16</span>;\n  h1 = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">imul</span>(h1, <span class="hljs-number">0x85ebca6b</span>);\n  h1 ^= h1 &gt;&gt;&gt; <span class="hljs-number">13</span>;\n  h1 = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">imul</span>(h1, <span class="hljs-number">0xc2b2ae35</span>);\n  h1 ^= h1 &gt;&gt;&gt; <span class="hljs-number">16</span>;\n\n  <span class="hljs-keyword">return</span> h1 &gt;&gt;&gt; <span class="hljs-number">0</span>;\n}\n</code></pre>\n<h3>2. A/B 分组函数</h3>\n<p>基于 MurmurHash3 实现 A/B 分组：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getABGroup</span>(<span class="hljs-params">userId, groups = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>], seed = <span class="hljs-number">0</span></span>) {\n  <span class="hljs-comment">// 计算哈希值</span>\n  <span class="hljs-keyword">const</span> hash = <span class="hljs-title function_">murmurhash3_32_gc</span>(userId, seed);\n\n  <span class="hljs-comment">// 将哈希值映射到 [0, 1) 区间</span>\n  <span class="hljs-keyword">const</span> normalized = hash / <span class="hljs-number">0xffffffff</span>;\n\n  <span class="hljs-comment">// 计算分组索引</span>\n  <span class="hljs-keyword">const</span> groupIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(normalized * groups.<span class="hljs-property">length</span>);\n\n  <span class="hljs-keyword">return</span> groups[groupIndex];\n}\n</code></pre>\n<h3>3. 使用示例</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 使用用户ID或设备ID作为分组依据</span>\n<span class="hljs-keyword">const</span> userId = <span class="hljs-string">&quot;user12345&quot;</span>; <span class="hljs-comment">// 可以是用户ID、设备ID或cookie等</span>\n<span class="hljs-keyword">const</span> group = <span class="hljs-title function_">getABGroup</span>(userId, [<span class="hljs-string">&quot;control&quot;</span>, <span class="hljs-string">&quot;variant1&quot;</span>, <span class="hljs-string">&quot;variant2&quot;</span>]);\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`用户 <span class="hljs-subst">${userId}</span> 被分配到 <span class="hljs-subst">${group}</span> 组`</span>);\n</code></pre>\n<h2>实际应用建议</h2>\n<ol>\n<li>\n<p><strong>稳定的用户标识</strong>   ：使用不会频繁变化的用户标识，如用户ID、设备ID或持久化的cookie。</p>\n</li>\n<li>\n<p><strong>分组比例</strong>   ：可以通过调整groups数组中的元素数量来控制比例，例如：</p>\n<ul>\n<li><code>[\'A\', \'B\']</code> 是50/50分组</li>\n<li><code>[\'A\', \'B\', \'B\']</code> 是33/67分组</li>\n</ul>\n</li>\n<li>\n<p><strong>种子值</strong>   ：seed参数可以用于不同的实验之间保持独立性。</p>\n</li>\n<li>\n<p><strong>持久化分组</strong>   ：将分组结果存储在localStorage或cookie中，确保用户每次访问都在同一分组。</p>\n</li>\n<li>\n<p><strong>服务端验证</strong>   ：对于重要的A/B测试，建议在服务端也进行相同的分组逻辑验证。</p>\n</li>\n</ol>\n<h2>完整示例</h2>\n<pre><code class="language-javascript"><span class="hljs-comment">// 存储分组结果，确保一致性</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">getStableABGroup</span>(<span class="hljs-params">userId, experimentName, groups = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>]</span>) {\n  <span class="hljs-keyword">const</span> storageKey = <span class="hljs-string">`ab_group_<span class="hljs-subst">${experimentName}</span>`</span>;\n\n  <span class="hljs-comment">// 检查是否已有分组</span>\n  <span class="hljs-keyword">const</span> storedGroup = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(storageKey);\n  <span class="hljs-keyword">if</span> (storedGroup) {\n    <span class="hljs-keyword">return</span> storedGroup;\n  }\n\n  <span class="hljs-comment">// 计算新分组</span>\n  <span class="hljs-keyword">const</span> group = <span class="hljs-title function_">getABGroup</span>(userId + experimentName, groups);\n\n  <span class="hljs-comment">// 存储分组结果</span>\n  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(storageKey, group);\n\n  <span class="hljs-keyword">return</span> group;\n}\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-keyword">const</span> experimentName = <span class="hljs-string">&quot;new_feature_2023&quot;</span>;\n<span class="hljs-keyword">const</span> userId = <span class="hljs-string">&quot;user12345&quot;</span>; <span class="hljs-comment">// 实际应用中从cookie或用户系统获取</span>\n<span class="hljs-keyword">const</span> abGroup = <span class="hljs-title function_">getStableABGroup</span>(userId, experimentName, [\n  <span class="hljs-string">&quot;control&quot;</span>,\n  <span class="hljs-string">&quot;variant&quot;</span>,\n]);\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`实验 <span class="hljs-subst">${experimentName}</span> 中用户 <span class="hljs-subst">${userId}</span> 被分配到 <span class="hljs-subst">${abGroup}</span> 组`</span>);\n</code></pre>\n<p>这种方法确保了用户在不同会话间会被分配到相同的分组，同时保持了分组比例的准确性。</p>\n</div>'</script></body></html>