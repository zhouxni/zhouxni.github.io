<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x278884=_0x5a32;function _0x4328(){var n=["W6z9W6NdMMLlWPBdVLTAW5vzb0m","WOjYWOvaW4pcL8kUzsa","rCo5WPLOW6CwyCoB","W4pcH2/dRCkDbdu","W47cOh3cPCkMW5D3zrmrWO9dbcq","WPhcOfNcJ34WWOBdKCohW7ZdHa","WQuGWQdcGterW4C","W4pdSgKKFSoqn8oY","WR9tWOddLSkNlmk8WQSpW7yn","WPrXBmkowJ7dG8kXWO7cP0ZcUmo8","cgpcKmkIgCkuWPPaWO91FdP1","W7zjWPePW7pdPWzNWPxdOeGrW48","WRGZWR4asq","W6z2W6NdMMDeWPdcJNPvW5TDnW","W77cKtRcVxS3WQRcKq","W63cUCk7zCoTW7nOjmk7xIq","cHddG8ovt8oeW74","WPFcNSk6sSogwSk8","jqhcOu3dVhtdGeLXW7ZcHG","WQBdIMNdQJ5PW7tcVSoqW60ph2K","hSodW49gW5zWWO3dV0C","BSkwWPXqW7jQWOldTNC","bvhcO8o2o8kjW5/dGmkNo8kfotG","WOiuW4D8W7BcM8k+","W4hcVYddSSkhW6GdyW8Jw8oHW59vqmovWQTxCCkUDJNdPhpdIXC","WOzGW58vWOnnWRSIqCo7pctdOW","W6VcU8oyjmk3W7TKeG","WPJcMYBdJCkwWRD4","WPBcOI/dJtS5WQJdRa","pMhcIg/cI8k2W756sSoIhSohFW"];return(_0x4328=function(){return n})()}function _0x5a32(r,n){var o=_0x4328();return(_0x5a32=function(n,t){var s=o[n-=444];void 0===_0x5a32.EXAkWD&&(_0x5a32.AOQQKC=function(n,t){var s,a=[],r=0,o="";for(n=(n=>{for(var t,s,a="",r="",o=0,d=0;s=n.charAt(d++);~s&&(t=o%4?64*t+s:s,o++%4)&&(a+=String.fromCharCode(255&t>>(-2*o&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var l=0,e=a.length;l<e;l++)r+="%"+("00"+a.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(r)})(n),d=0;d<256;d++)a[d]=d;for(d=0;d<256;d++)r=(r+a[d]+t.charCodeAt(d%t.length))%256,s=a[d],a[d]=a[r],a[r]=s;for(var d=0,r=0,l=0;l<n.length;l++)s=a[d=(d+1)%256],a[d]=a[r=(r+a[d])%256],a[r]=s,o+=String.fromCharCode(n.charCodeAt(l)^a[(a[d]+a[r])%256]);return o},r=arguments,_0x5a32.EXAkWD=!0);var n=n+o[0],a=r[n];return a?s=a:(void 0===_0x5a32.yGafZQ&&(_0x5a32.yGafZQ=!0),s=_0x5a32.AOQQKC(s,t),r[n]=s),s})(r,n)}if((()=>{for(var n=_0x5a32,t=_0x4328();;)try{if(380946==-parseInt(n(452,"fe9o"))*(parseInt(n(472,"n9[%"))/2)+parseInt(n(470,"78Fd"))/3+-parseInt(n(454,"Pc)n"))/4*(parseInt(n(455,"rFZ8"))/5)+-parseInt(n(446,"QjXz"))/6*(parseInt(n(469,"9]R@"))/7)+-parseInt(n(460,"fe9o"))/8*(-parseInt(n(467,"TcTO"))/9)+parseInt(n(466,"[9s]"))/10*(parseInt(n(447,"$sIn"))/11)+parseInt(n(459,"n9[%"))/12)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x278884(462,"iPC$")](_0x278884(450,"LUu0"))!=_0x278884(471,"WXmp"))throw window[_0x278884(473,"E#84")][_0x278884(465,"n9[%")](_0x278884(453,"ni)Y")),Error();document.title="SSG（静态站点生成）、ISR（增量静态再生）、SSR（服务器端渲染）和CSR（客户端渲染）",document.getElementById("article").innerHTML='<div><p>在Next.js及现代Web开发中，<strong>SSG（静态站点生成）、ISR（增量静态再生）、SSR（服务器端渲染）和CSR（客户端渲染）</strong>   是四种主要的渲染策略，它们在性能、内容更新方式和适用场景上各有不同。以下是详细对比：</p>\n<h3><strong>核心概念对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>策略</strong></th>\n<th><strong>渲染时机</strong></th>\n<th><strong>内容更新方式</strong></th>\n<th><strong>首次加载性能</strong></th>\n<th><strong>SEO友好度</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>SSG（静态站点生成）</strong></td>\n<td>构建时（build time）</td>\n<td>重新构建整个应用</td>\n<td>最快（静态文件）</td>\n<td>优秀</td>\n<td>内容很少变化的页面（博客、文档）</td>\n</tr>\n<tr>\n<td><strong>ISR（增量静态再生）</strong></td>\n<td>构建时 + 运行时（按需）</td>\n<td>自动/手动触发单个页面更新</td>\n<td>快（缓存优先）</td>\n<td>优秀</td>\n<td>内容定期更新的页面（新闻、电商）</td>\n</tr>\n<tr>\n<td><strong>SSR（服务器端渲染）</strong></td>\n<td>每次请求时（runtime）</td>\n<td>实时生成</td>\n<td>中等（等待服务器响应）</td>\n<td>优秀</td>\n<td>实时数据页面（仪表盘、用户特定内容）</td>\n</tr>\n<tr>\n<td><strong>CSR（客户端渲染）</strong></td>\n<td>浏览器中（客户端）</td>\n<td>客户端JS动态获取数据</td>\n<td>最慢（等待JS加载执行）</td>\n<td>差（需特殊处理）</td>\n<td>高度交互的应用（SPA、游戏）</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>工作流程对比</strong></h3>\n<h4><strong>(1) SSG流程</strong></h4>\n<ol>\n<li><strong>构建时</strong>   ：Next.js执行数据获取逻辑（如<code>getStaticProps</code>），生成静态HTML和JSON。</li>\n<li><strong>部署后</strong>   ：所有请求直接返回预渲染的静态文件，无需服务器参与。</li>\n</ol>\n<h4><strong>(2) ISR流程</strong></h4>\n<ol>\n<li><strong>构建时</strong>   ：生成初始静态HTML。</li>\n<li><strong>部署后</strong>   ：\n<ul>\n<li>首次请求：直接返回缓存的HTML。</li>\n<li>超过<code>revalidate</code>时间后：旧HTML立即返回，同时在后台重新生成新页面并更新缓存。</li>\n</ul>\n</li>\n</ol>\n<h4><strong>(3) SSR流程</strong></h4>\n<ol>\n<li><strong>每次请求</strong>   ：服务器执行数据获取逻辑（如<code>getServerSideProps</code>），动态生成HTML。</li>\n<li><strong>响应返回</strong>   ：将生成的HTML发送到客户端。</li>\n</ol>\n<h4><strong>(4) CSR流程</strong></h4>\n<ol>\n<li><strong>首次请求</strong>   ：服务器返回空HTML和JS文件。</li>\n<li><strong>客户端</strong>   ：浏览器加载JS，执行数据获取逻辑，动态渲染页面。</li>\n</ol>\n<h3><strong>代码实现对比</strong></h3>\n<h4><strong>(1) SSG（Pages Router）</strong></h4>\n<pre><code class="language-tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStaticProps</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();\n  <span class="hljs-keyword">return</span> { <span class="hljs-attr">props</span>: { data } }; <span class="hljs-comment">// 构建时获取数据</span>\n}\n</code></pre>\n<h4><strong>(2) ISR（Pages Router）</strong></h4>\n<pre><code class="language-tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStaticProps</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">props</span>: { data },\n    <span class="hljs-attr">revalidate</span>: <span class="hljs-number">60</span> * <span class="hljs-number">60</span>, <span class="hljs-comment">// 1小时后可重新验证</span>\n  };\n}\n</code></pre>\n<h4><strong>(3) SSR（Pages Router）</strong></h4>\n<pre><code class="language-tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getServerSideProps</span>(<span class="hljs-params">context</span>) {\n  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>(context.<span class="hljs-property">query</span>); <span class="hljs-comment">// 每次请求时获取数据</span>\n  <span class="hljs-keyword">return</span> { <span class="hljs-attr">props</span>: { data } };\n}\n</code></pre>\n<h4><strong>(4) CSR（客户端组件）</strong></h4>\n<pre><code class="language-tsx"><span class="hljs-string">&quot;use client&quot;</span>;\n<span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">ClientComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-title function_">fetchData</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-title function_">setData</span>(res)); <span class="hljs-comment">// 客户端获取数据</span>\n  }, []);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{/* 渲染数据 */}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n<h3><strong>性能与SEO对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>维度</strong></th>\n<th><strong>SSG</strong></th>\n<th><strong>ISR</strong></th>\n<th><strong>SSR</strong></th>\n<th><strong>CSR</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>首次加载时间（TTFB）</strong></td>\n<td>最快</td>\n<td>快</td>\n<td>中等</td>\n<td>最慢</td>\n</tr>\n<tr>\n<td><strong>交互就绪时间</strong></td>\n<td>快</td>\n<td>快</td>\n<td>中等</td>\n<td>最慢</td>\n</tr>\n<tr>\n<td><strong>内容新鲜度</strong></td>\n<td>低（需重建）</td>\n<td>高（可实时更新）</td>\n<td>高（实时生成）</td>\n<td>高（客户端动态更新）</td>\n</tr>\n<tr>\n<td><strong>服务器负载</strong></td>\n<td>极低</td>\n<td>低</td>\n<td>高</td>\n<td>低</td>\n</tr>\n<tr>\n<td><strong>SEO友好度</strong></td>\n<td>优秀</td>\n<td>优秀</td>\n<td>优秀</td>\n<td>差（需特殊处理）</td>\n</tr>\n<tr>\n<td><strong>开发复杂度</strong></td>\n<td>低</td>\n<td>中等</td>\n<td>中等</td>\n<td>高</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>混合策略与最佳实践</strong></h3>\n<ol>\n<li><strong>在同一应用中组合使用</strong>   ：\n<ul>\n<li>首页/产品页：SSG或ISR（性能优先）。</li>\n<li>用户仪表盘：SSR（实时数据）。</li>\n<li>评论区/购物车：CSR（高度交互）。</li>\n</ul>\n</li>\n<li><strong>Next.js中的实现</strong>   ：\n<ul>\n<li><strong>App Router</strong>   ：通过<code>fetch</code>的缓存策略灵活控制（如<code>cache: \'force-cache\'</code>或<code>next: { revalidate }</code>）。</li>\n<li><strong>Pages Router</strong>   ：使用<code>getStaticProps</code>（SSG/ISR）和<code>getServerSideProps</code>（SSR）。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>如何选择？</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>场景</strong></th>\n<th><strong>推荐策略</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>博客、文档、营销页面</td>\n<td>SSG</td>\n</tr>\n<tr>\n<td>新闻网站、电商产品列表</td>\n<td>ISR</td>\n</tr>\n<tr>\n<td>实时数据仪表盘、用户特定内容</td>\n<td>SSR</td>\n</tr>\n<tr>\n<td>单页应用（SPA）、游戏</td>\n<td>CSR</td>\n</tr>\n<tr>\n<td>内容更新频繁但需高性能</td>\n<td>ISR + SSG</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>SSG</strong>   ：适合静态内容，性能最优，但更新需重建。</li>\n<li><strong>ISR</strong>   ：在SSG基础上支持动态更新，平衡性能与时效性。</li>\n<li><strong>SSR</strong>   ：提供实时内容，但服务器成本高。</li>\n<li><strong>CSR</strong>   ：适合高度交互的应用，但SEO和首屏性能较差。</li>\n</ul>\n<p>Next.js的强大之处在于允许你根据页面需求<strong>混合使用这些策略</strong>   ，从而在性能、成本和开发体验之间找到最佳平衡点。</p>\n</div>'</script></body></html>