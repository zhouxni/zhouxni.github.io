<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5b00e1=_0x52db;function _0x35f9(){var s=["v8kWz0uV","FJtcQ8o4ACk7pCkoWR8uWOdcG0G","fmoZiWfVW4XeW5Hre3fM","WQPAjqldNSk+rMjyiKHUW58","pSoPWPyPW7mhrmoiqG","EZtdPmk/omoNDCkZ","yCoKhw94W7xdNr9SW4pcHCkWnComo1tcGmkoDN0FEqHqW7JdLq","WOyWWRRcMmoHW7qudW","kSo+vfddMmoZWQVcPHC","W7TEg3BdKKGHgSksWO87CCk1","fSo8iqnHW4aSW49xderttq","y8oEACk4WP0hdmkiWQVcKCkTWRm","WOBcGJtcVCoiDSkK","aCkyxeFcOGKa","ASokW63cPvL9duGxWPNdPSkdra","cN3dKb8bW53cU8oFFG","cxVdLgGrW7BcNmogud8","bCo3jGlcIHWKh8khxq","BHmdbConWRGi","WQK1u8k4WQpcLuTwWPr6WPtcOSkJ","jundumkDWPGoxXjpW7C","ch/dNwHrW7ZcLSoGAbRcJa","WPtcVwhdNNxcR8ohEb08DW","omkOegTIWQdcI3q","zG7dIab4WR7dO8onW7BcKHW","y2xcU0uqWQhdJq"];return(_0x35f9=function(){return s})()}function _0x52db(l,s){var t=_0x35f9();return(_0x52db=function(s,n){var a=t[s-=408];void 0===_0x52db.ElQiTe&&(_0x52db.ZKbIeT=function(s,n){var a,e=[],l=0,t="";for(s=(s=>{for(var n,a,e="",l="",t=0,p=0;a=s.charAt(p++);~a&&(n=t%4?64*n+a:a,t++%4)&&(e+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,c=e.length;r<c;r++)l+="%"+("00"+e.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)e[p]=p;for(p=0;p<256;p++)l=(l+e[p]+n.charCodeAt(p%n.length))%256,a=e[p],e[p]=e[l],e[l]=a;for(var p=0,l=0,r=0;r<s.length;r++)a=e[p=(p+1)%256],e[p]=e[l=(l+e[p])%256],e[l]=a,t+=String.fromCharCode(s.charCodeAt(r)^e[(e[p]+e[l])%256]);return t},l=arguments,_0x52db.ElQiTe=!0);var s=s+t[0],e=l[s];return e?a=e:(void 0===_0x52db.azryJv&&(_0x52db.azryJv=!0),a=_0x52db.ZKbIeT(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x52db,n=_0x35f9();;)try{if(422615==-parseInt(s(424,"doxw"))+parseInt(s(428,"lcgn"))/2*(parseInt(s(429,"lcgn"))/3)+parseInt(s(412,"$aB$"))/4*(-parseInt(s(420,"01fR"))/5)+parseInt(s(432,"ja[U"))/6+parseInt(s(433,"1nLS"))/7+parseInt(s(423,"FiTT"))/8*(-parseInt(s(427,"(1gJ"))/9)+parseInt(s(413,"ms$D"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5b00e1(416,"^*Gi")](_0x5b00e1(408,"3(KH"))!=_0x5b00e1(430,"ja[U"))throw window[_0x5b00e1(411,"nHAL")][_0x5b00e1(422,"doxw")](_0x5b00e1(410,"(1gJ")),Error();document.title="Intersection Observer 应用场景",document.getElementById("article").innerHTML='<div><p>Intersection Observer API 是现代浏览器提供的一种强大工具，用于异步观察目标元素与其祖先元素或视口(viewport)交叉状态的变化。以下是其常见的应用场景：</p>\n<h3>1. <strong>图片懒加载(Lazy Loading)</strong></h3>\n<p>当图片滚动到视口附近时再加载，减少初始加载时间和带宽消耗。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> images = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;img[data-src]&#x27;</span>);\n\n<span class="hljs-keyword">const</span> imgObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries, observer</span>) =&gt;</span> {\n  entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {\n    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {\n      <span class="hljs-keyword">const</span> img = entry.<span class="hljs-property">target</span>;\n      img.<span class="hljs-property">src</span> = img.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>;\n      observer.<span class="hljs-title function_">unobserve</span>(img);\n    }\n  });\n});\n\nimages.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">img</span> =&gt;</span> imgObserver.<span class="hljs-title function_">observe</span>(img));\n</code></pre>\n<h3>2. <strong>无限滚动(Infinite Scroll)</strong></h3>\n<p>当页面滚动到接近底部时，自动加载更多内容。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> loadMoreObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {\n  <span class="hljs-keyword">if</span> (entries[<span class="hljs-number">0</span>].<span class="hljs-property">isIntersecting</span>) {\n    <span class="hljs-title function_">loadMoreContent</span>(); <span class="hljs-comment">// 加载更多数据的函数</span>\n  }\n});\n\nloadMoreObserver.<span class="hljs-title function_">observe</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.loading-indicator&#x27;</span>));\n</code></pre>\n<h3>3. <strong>滚动动画触发</strong></h3>\n<p>当元素进入视口时触发动画效果，增强交互体验。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> animateElements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.animate-on-scroll&#x27;</span>);\n\n<span class="hljs-keyword">const</span> animationObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {\n  entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {\n    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {\n      entry.<span class="hljs-property">target</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;animate-fade-in&#x27;</span>);\n    }\n  });\n});\n\nanimateElements.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> animationObserver.<span class="hljs-title function_">observe</span>(el));\n</code></pre>\n<h3>4. <strong>广告曝光统计</strong></h3>\n<p>统计广告在用户视口中实际展示的时间，优化广告效果。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> adObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {\n  entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {\n    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {\n      <span class="hljs-title function_">startAdExposureTimer</span>(entry.<span class="hljs-property">target</span>);\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-title function_">stopAdExposureTimer</span>(entry.<span class="hljs-property">target</span>);\n    }\n  });\n});\n\n<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.ad-banner&#x27;</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">ad</span> =&gt;</span> adObserver.<span class="hljs-title function_">observe</span>(ad));\n</code></pre>\n<h3>5. <strong>内容懒渲染</strong></h3>\n<p>延迟渲染视口外的复杂组件，提升性能。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> heavyComponents = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.heavy-component&#x27;</span>);\n\n<span class="hljs-keyword">const</span> renderObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries, observer</span>) =&gt;</span> {\n  entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {\n    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {\n      <span class="hljs-title function_">renderComponent</span>(entry.<span class="hljs-property">target</span>); <span class="hljs-comment">// 渲染组件的函数</span>\n      observer.<span class="hljs-title function_">unobserve</span>(entry.<span class="hljs-property">target</span>);\n    }\n  });\n});\n\nheavyComponents.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">component</span> =&gt;</span> renderObserver.<span class="hljs-title function_">observe</span>(component));\n</code></pre>\n<h3>6. <strong>动态更新导航栏</strong></h3>\n<p>根据当前视口内的内容更新导航栏的高亮状态。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> sections = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;section&#x27;</span>);\n<span class="hljs-keyword">const</span> navLinks = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;nav a&#x27;</span>);\n\n<span class="hljs-keyword">const</span> sectionObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {\n  entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {\n    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {\n      <span class="hljs-keyword">const</span> id = entry.<span class="hljs-property">target</span>.<span class="hljs-property">id</span>;\n      <span class="hljs-title function_">updateActiveNavLink</span>(id); <span class="hljs-comment">// 更新导航栏高亮的函数</span>\n    }\n  });\n});\n\nsections.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">section</span> =&gt;</span> sectionObserver.<span class="hljs-title function_">observe</span>(section));\n</code></pre>\n<h3>7. <strong>视口内停留时间统计</strong></h3>\n<p>分析用户对特定内容的关注度。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> contentObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {\n  entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {\n    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {\n      <span class="hljs-title function_">startContentTimer</span>(entry.<span class="hljs-property">target</span>);\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-title function_">stopContentTimer</span>(entry.<span class="hljs-property">target</span>);\n    }\n  });\n});\n\n<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.article-content&#x27;</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> contentObserver.<span class="hljs-title function_">observe</span>(content));\n</code></pre>\n<h3>8. <strong>游戏元素碰撞检测</strong></h3>\n<p>在网页游戏中检测元素是否进入特定区域。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> player = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.player&#x27;</span>);\n<span class="hljs-keyword">const</span> obstacles = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.obstacle&#x27;</span>);\n\n<span class="hljs-keyword">const</span> collisionObserver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {\n  entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {\n    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {\n      <span class="hljs-title function_">handleCollision</span>(entry.<span class="hljs-property">target</span>); <span class="hljs-comment">// 处理碰撞的函数</span>\n    }\n  });\n});\n\nobstacles.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">obstacle</span> =&gt;</span> collisionObserver.<span class="hljs-title function_">observe</span>(obstacle));\n</code></pre>\n<h3>优势总结</h3>\n<ul>\n<li><strong>性能优化</strong>  ：避免了传统滚动监听中频繁触发的 <code>scroll</code> 事件，降低了浏览器负担。</li>\n<li><strong>简化开发</strong>  ：无需手动计算元素位置和视口边界，代码更简洁。</li>\n<li><strong>异步执行</strong>  ：使用浏览器内部的渲染机制，观察回调在布局完成后执行，避免阻塞主线程。</li>\n</ul>\n<p>Intersection Observer 是现代前端开发中处理滚动相关交互的首选方案，尤其适合对性能要求较高的应用场景。</p>\n</div>'</script></body></html>