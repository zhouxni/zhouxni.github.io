<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5abb(){var n=["W73cSbVcNmoBW6NdH8ortHJdQKqB","avldRh4nW5CJWOKxWO/cVCkIW40","fYCfk8ofWPZcK8kM","WORcVmk/WRScj8klWPjAWRNcV8ogW74","fcn1FSknW6xdU8kkh8kcrmolsa","uSkRW4qjWPFdOCkBrCocW7eey8kI","c8kcvG/dVqNdQCobWPm3W5pcPa","WO4WW65TWP7dUgH6hW","W6pdO2VdVmovnrpdUKSWW7jQ","WPDHzu7cK8kHy8ot","W4xcMmoGWQu1daNdTSk9WONdMJPa","C8k2ymoSWRDaWOu","WQdcJYhcUWr9lIi","EHFcNrz0W4NdPSocW7CgWRqH","W7RdNmkOaqr/C8kMW5ndasi","ohZcGCohWQr2W5JcTSkPWODeW7BdMa","bCoGW54ghCkYnCoTzSozW45h","AmkdW7uOnwBdHMG4WPTIxW","q8oaeKJcTG","tConWPZdSb9oW6BcVqW9yCktWOe","pMlcVNb4rSoFvZGyWOfmW4K4ACkOW7/cI1ulCSoQj8omFCk1","WR7cHtlcTHf3ja"];return(_0x5abb=function(){return n})()}var _0x211837=_0xcb7b;function _0xcb7b(l,n){var o=_0x5abb();return(_0xcb7b=function(n,s){var t=o[n-=178];void 0===_0xcb7b.dwiglP&&(_0xcb7b.dPhVXe=function(n,s){var t,r=[],l=0,o="";for(n=(n=>{for(var s,t,r="",l="",o=0,a=0;t=n.charAt(a++);~t&&(s=o%4?64*s+t:t,o++%4)&&(r+=String.fromCharCode(255&s>>(-2*o&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var i=0,e=r.length;i<e;i++)l+="%"+("00"+r.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(l)})(n),a=0;a<256;a++)r[a]=a;for(a=0;a<256;a++)l=(l+r[a]+s.charCodeAt(a%s.length))%256,t=r[a],r[a]=r[l],r[l]=t;for(var a=0,l=0,i=0;i<n.length;i++)t=r[a=(a+1)%256],r[a]=r[l=(l+r[a])%256],r[l]=t,o+=String.fromCharCode(n.charCodeAt(i)^r[(r[a]+r[l])%256]);return o},l=arguments,_0xcb7b.dwiglP=!0);var n=n+o[0],r=l[n];return r?t=r:(void 0===_0xcb7b.VmrUPX&&(_0xcb7b.VmrUPX=!0),t=_0xcb7b.dPhVXe(t,s),l[n]=t),t})(l,n)}if((()=>{for(var n=_0xcb7b,s=_0x5abb();;)try{if(713108==+parseInt(n(188,"lI4u"))+-parseInt(n(194,"!dlL"))/2+-parseInt(n(180,"VT55"))/3+parseInt(n(185,"CO5h"))/4+parseInt(n(197,"A(Dk"))/5+parseInt(n(191,"figE"))/6+-parseInt(n(196,"foeg"))/7*(parseInt(n(199,"9Zcx"))/8))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x211837(183,"y@H$")](_0x211837(179,"5BEh"))!=_0x211837(190,"xUuj"))throw window[_0x211837(184,"gd!@")][_0x211837(193,"gd!@")](_0x211837(192,"mmM1")),Error();document.title="React 选择“中断渲染”而非“并行执行”的深层原因",document.getElementById("article").innerHTML='<div><p>React 的并发渲染机制选择 <strong>中断渲染而非直接切换任务</strong>  ，是基于以下几个关键考量：</p>\n<h3><strong>1. 虚拟 DOM 树构建的连续性要求</strong></h3>\n<p>React 的渲染过程本质上是<strong>递归构建虚拟 DOM 树</strong>  的过程，这一过程具有很强的连贯性：</p>\n<ul>\n<li>每个组件的渲染可能依赖于父组件的状态或上下文</li>\n<li>渲染过程中可能产生副作用（如计算样式、布局）</li>\n<li>直接切换任务会导致渲染上下文丢失或状态不一致</li>\n</ul>\n<p><strong>类比</strong>  ：<br>\n就像电影拍摄无法在镜头拍摄中途突然切换到另一个场景，必须完成当前镜头（组件）才能切换。</p>\n<h3><strong>2. 中断与恢复的成本控制</strong></h3>\n<p>React 的 Fiber 架构将渲染任务拆分为<strong>可中断的工作单元</strong>  （Fiber），每个单元包含：</p>\n<ul>\n<li>组件的类型、props、state</li>\n<li>当前渲染进度</li>\n<li>指向父级和子级的指针</li>\n</ul>\n<p>通过这种结构，React 可以：</p>\n<ol>\n<li><strong>暂停</strong>  当前工作单元的执行</li>\n<li><strong>保存现场</strong>  （当前 Fiber 节点的状态）</li>\n<li><strong>执行高优先级任务</strong></li>\n<li><strong>恢复</strong>  之前的工作单元（从保存的状态继续）</li>\n</ol>\n<p>这种机制的成本远低于重新开始整个渲染过程。</p>\n<h3><strong>3. 避免渲染抖动与不一致</strong></h3>\n<p>如果允许渲染过程中直接插入高优先级任务，会导致：</p>\n<ul>\n<li><strong>UI 闪烁</strong>  ：部分组件已更新，部分仍未更新</li>\n<li><strong>状态不一致</strong>  ：同一帧中组件使用不同版本的 state</li>\n<li><strong>布局抖动</strong>  ：渲染过程中多次触发布局计算</li>\n</ul>\n<p><strong>中断机制确保</strong>  ：</p>\n<ul>\n<li>每个渲染周期是<strong>原子性</strong>  的（要么完成，要么不执行）</li>\n<li>高优先级任务会在下一帧开始前插入</li>\n<li>用户不会看到“半成品”的 UI</li>\n</ul>\n<h3><strong>4. 优先级调度的实现基础</strong></h3>\n<p>React 的优先级调度系统需要精确控制渲染流程：</p>\n<ol>\n<li><strong>任务分级</strong>  ：将更新分为不同优先级（如用户输入、动画、数据获取）</li>\n<li><strong>时间分片</strong>  ：为每个优先级分配执行时间</li>\n<li><strong>过期机制</strong>  ：确保低优先级任务不会被无限延迟</li>\n</ol>\n<p>中断渲染是实现这些机制的基础：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 伪代码：React 的优先级调度逻辑</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoop</span>(<span class="hljs-params">hasTimeRemaining, initialTime</span>) {\n  <span class="hljs-keyword">let</span> currentTime = initialTime;\n  <span class="hljs-keyword">let</span> shouldYield = <span class="hljs-literal">false</span>;\n  \n  <span class="hljs-comment">// 处理高优先级任务（如用户输入）</span>\n  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">highPriorityWorkExists</span>()) {\n    <span class="hljs-title function_">performHighPriorityWork</span>();\n    shouldYield = <span class="hljs-literal">true</span>;\n  }\n  \n  <span class="hljs-comment">// 如果有时间，继续处理低优先级任务</span>\n  <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span> &amp;&amp; !shouldYield) {\n    workInProgress = <span class="hljs-title function_">performUnitOfWork</span>(workInProgress);\n    currentTime = <span class="hljs-title function_">requestCurrentTime</span>();\n    \n    <span class="hljs-comment">// 如果时间片用尽，暂停渲染</span>\n    <span class="hljs-keyword">if</span> (!hasTimeRemaining &amp;&amp; currentTime &gt; deadline) {\n      shouldYield = <span class="hljs-literal">true</span>;\n    }\n  }\n  \n  <span class="hljs-comment">// 如果需要让出控制权，下次再继续</span>\n  <span class="hljs-keyword">if</span> (shouldYield) {\n    <span class="hljs-title function_">scheduleCallback</span>(workLoop);\n  }\n}\n</code></pre>\n<h3><strong>5. 与浏览器渲染机制的协同</strong></h3>\n<p>现代浏览器的渲染流程包括：</p>\n<ol>\n<li>JavaScript 执行</li>\n<li>样式计算</li>\n<li>布局</li>\n<li>绘制</li>\n<li>合成</li>\n</ol>\n<p>React 的中断机制与浏览器的渲染帧同步：</p>\n<ul>\n<li>在每一帧的 <code>requestIdleCallback</code> 阶段执行低优先级渲染</li>\n<li>高优先级任务（如点击）会立即触发，打断当前渲染</li>\n<li>确保渲染不会阻塞浏览器的关键任务（如滚动、动画）</li>\n</ul>\n<h3><strong>6. 开发者体验与可预测性</strong></h3>\n<p>中断渲染使 React 能够：</p>\n<ul>\n<li>提供一致的编程模型（无需关心任务何时执行）</li>\n<li>通过 <code>useTransition</code> 和 <code>useDeferredValue</code> 等 API 抽象底层复杂性</li>\n<li>避免开发者手动管理复杂的任务调度</li>\n</ul>\n<p>如果允许直接在渲染过程中插入任务，开发者将不得不处理：</p>\n<ul>\n<li>渲染上下文丢失的问题</li>\n<li>任务执行顺序的不确定性</li>\n<li>状态不一致的风险</li>\n</ul>\n<h3><strong>总结：为何选择中断渲染？</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>原因</strong></th>\n<th><strong>解释</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>渲染连贯性</strong></td>\n<td>渲染过程不可分割，必须保持上下文一致性</td>\n</tr>\n<tr>\n<td><strong>成本控制</strong></td>\n<td>中断-恢复的成本低于重新渲染</td>\n</tr>\n<tr>\n<td><strong>UI 稳定性</strong></td>\n<td>避免渲染抖动和布局跳动</td>\n</tr>\n<tr>\n<td><strong>优先级调度</strong></td>\n<td>精确控制不同优先级任务的执行时机</td>\n</tr>\n<tr>\n<td><strong>浏览器协同</strong></td>\n<td>与浏览器渲染帧周期同步，避免阻塞关键任务</td>\n</tr>\n<tr>\n<td><strong>开发者体验</strong></td>\n<td>提供高层抽象，隐藏底层复杂性</td>\n</tr>\n</tbody>\n</table>\n<p>React 的中断渲染机制是在<strong>性能优化</strong>  与<strong>开发可维护性</strong>  之间取得的平衡，通过底层架构创新（Fiber）解决了传统同步渲染的固有问题。</p>\n</div>'</script></body></html>