<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x7bebba=_0x56a3;function _0x56a3(t,s){var p=_0x2665();return(_0x56a3=function(s,n){var a=p[s-=261];void 0===_0x56a3.YRBGaI&&(_0x56a3.FrgmFY=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=l.length;c<r;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[t],l[t]=a;for(var e=0,t=0,c=0;c<s.length;c++)a=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[t])%256]);return p},t=arguments,_0x56a3.YRBGaI=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x56a3.nDONOP&&(_0x56a3.nDONOP=!0),a=_0x56a3.FrgmFY(a,n),t[s]=a),a})(t,s)}function _0x2665(){var s=["A8oykCoqWRu","WR7cOWZdNZJdNuO7rrpdNXG","W4HdhSoqWRhdSmo4W7CogNdcTG","mSkqW4ZcKSoYWQj1","W6VdIdxdOmkXtmkGW6fNW4mTWQq","cq4xWRldUr7cNdVdKmoiWQC9W7W","E8ocWQ5jAvKJWOS","W5jCmuhdSmk2vCo+WPxcMmkB","wCkfWO7cIWCzzq","kNRdNCkhvmkFya","WOJcNLapDxxcSmk3EMddM1VdGW","WQFcVmounu7cPmoDW43dMMz4WOFdGq","zSoCCmkFWQXbWQu","W7xcJ8koWR7cHSk2fSovWOHIFSoCWPe","W6xcOmkWW5y6W6iuW6xcOhpdNCkh","F8kfWPvbxKSY","umkCW5VcNCoBWQ0QW6u","W71vWQ3cH1CeAN8YvSklt8kt","W4XjwCkVW4hcSmoiW4a","ESoQcmoWW5KUW6BdPhFdRbRdVmk5","WOBdLmozW6/dJCo3BCobWR0","WRhcOq7dLttcG0SaAGpdNG","wSkrW7Tvqd/cK0/cHmkowCkVbq","W7TBWQVcGf0cALKYxSkvu8k0","v0jxW7pcSHpcHgddOmotWO4LW4VcTSo6W5RdUIBdHmk+i8klsCoClWW"];return(_0x2665=function(){return s})()}if((()=>{for(var s=_0x56a3,n=_0x2665();;)try{if(504973==+parseInt(s(274,"kTJR"))*(parseInt(s(280,"SgNO"))/2)+-parseInt(s(266,"qtX8"))/3+-parseInt(s(279,"Zo5w"))/4+parseInt(s(270,"qQ8S"))/5+-parseInt(s(275,"!Ed^"))/6*(-parseInt(s(282,"yw9C"))/7)+parseInt(s(261,"f04q"))/8*(-parseInt(s(278,"@P!9"))/9)+-parseInt(s(285,"1taB"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x7bebba(281,"qmqQ")](_0x7bebba(267,"1taB"))!=_0x7bebba(272,"5!64"))throw window[_0x7bebba(263,"%nqs")][_0x7bebba(284,"[6Sn")](_0x7bebba(271,"KIpu")),Error();document.title="流式渲染",document.getElementById("article").innerHTML='<div><p>在浏览器里，“流式渲染”指的是 <strong>边加载边渲染</strong>   ，让页面在 HTML/CSS/JS 还没完全到达时就开始显示内容，而不是白屏到最后一刻。<br>\nJS 侧能做到的流式渲染大致分 3 个层次：</p>\n<ol>\n<li><strong>浏览器原生流式渲染</strong>   （你只需“别挡道”）</li>\n<li><strong>服务端流式 SSR</strong>   （React / Vue / Svelte 提供的 Streaming API）</li>\n<li><strong>纯前端大列表 / 大数据的流式渲染</strong>   （虚拟滚动、分片渲染、Web Stream API）</li>\n</ol>\n<p>下面给出每个层次的“最小可跑 Demo”及适用场景。</p>\n<hr>\n<h2>1. 浏览器原生：别让 JS 阻塞</h2>\n<p>浏览器本来就会一边下载一边解析一边渲染。<br>\n只要<strong>不阻塞</strong>   ，就能天然“流式”：</p>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- ✅ 好：放在最后，不阻塞解析 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;heavy.js&quot;</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n\n<span class="hljs-comment">&lt;!-- ❌ 坏：head 里同步 JS 会卡住首次渲染 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;heavy.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<p>或者给关键资源加 <code>preload</code>，让下载和解析并行：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;heavy.js&quot;</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;script&quot;</span> /&gt;</span>\n</code></pre>\n<hr>\n<h2>2. 服务端流式 SSR（以 React18 为例）</h2>\n<p>React18 提供了 <code>renderToPipeableStream</code>（Node）和 <code>renderToReadableStream</code>（Deno/Cloudflare），让服务器边生成 HTML 边吐给浏览器，浏览器流式 <strong>注水（hydrate）</strong>   。</p>\n<h3>服务端（Node）</h3>\n<pre><code class="language-js"><span class="hljs-comment">// server.jsx</span>\n<span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;express&quot;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n<span class="hljs-keyword">import</span> { renderToPipeableStream } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/server&quot;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.jsx&quot;</span>;\n\n<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();\napp.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n  res.<span class="hljs-title function_">write</span>(\n    <span class="hljs-string">&#x27;&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;SSR&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;root&quot;&gt;&#x27;</span>,\n  );\n\n  <span class="hljs-keyword">const</span> { pipe } = <span class="hljs-title function_">renderToPipeableStream</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, {\n    <span class="hljs-title function_">onShellReady</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-comment">// 先刷 shell</span>\n      <span class="hljs-title function_">pipe</span>(res);\n    },\n    <span class="hljs-title function_">onAllReady</span>(<span class="hljs-params"></span>) {\n      <span class="hljs-comment">// shell + 所有 Suspense 都好了</span>\n      res.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;&lt;/div&gt;&lt;script src=&quot;/client.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>);\n      res.<span class="hljs-title function_">end</span>();\n    },\n  });\n});\napp.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);\n</code></pre>\n<h3>客户端</h3>\n<pre><code class="language-jsx"><span class="hljs-comment">// client.jsx</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n<span class="hljs-keyword">import</span> { hydrateRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/client&quot;</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.jsx&quot;</span>;\n<span class="hljs-title function_">hydrateRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>), <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);\n</code></pre>\n<h3>延迟组件（Suspense）</h3>\n<pre><code class="language-jsx"><span class="hljs-comment">// Slow.jsx</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Slow</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">use</span>(<span class="hljs-title function_">getDataSlow</span>()); <span class="hljs-comment">// React18 的 use()</span>\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{data}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;\n}\n\n<span class="hljs-comment">// App.jsx</span>\n&lt;<span class="hljs-title class_">Suspense</span> fallback={<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>loading slow...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Slow</span> /&gt;</span></span>\n&lt;/<span class="hljs-title class_">Suspense</span>&gt;;\n</code></pre>\n<p>效果：</p>\n<ol>\n<li>浏览器先收到 shell（含 loading…）→ <strong>首屏 200 ms 可见</strong></li>\n<li>后端异步取完数据后，再推 <code>&lt;p&gt;真实数据&lt;/p&gt;</code> → <strong>流式插入 DOM，React 注水完成</strong></li>\n</ol>\n<hr>\n<h2>3. 纯前端大数据流式渲染</h2>\n<p>场景：本地一次性拿到 10 万条数据，DOM 不能一次全塞，需要“边算边画”。</p>\n<h3>3.1 分片渲染（requestAnimationFrame）</h3>\n<pre><code class="language-js"><span class="hljs-keyword">const</span> data = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">100000</span> }, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> i);\n<span class="hljs-keyword">const</span> chunk = <span class="hljs-number">200</span>;\n<span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> slice = data.<span class="hljs-title function_">slice</span>(cur, cur + chunk);\n  <span class="hljs-keyword">const</span> html = slice.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> <span class="hljs-string">`&lt;li&gt;<span class="hljs-subst">${n}</span>&lt;/li&gt;`</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);\n  list.<span class="hljs-title function_">insertAdjacentHTML</span>(<span class="hljs-string">&quot;beforeend&quot;</span>, html);\n  cur += chunk;\n  <span class="hljs-keyword">if</span> (cur &lt; data.<span class="hljs-property">length</span>) <span class="hljs-title function_">requestAnimationFrame</span>(render);\n}\n<span class="hljs-title function_">requestAnimationFrame</span>(render);\n</code></pre>\n<ul>\n<li>每帧只画 200 条，主线程不卡，滚动可交互。</li>\n<li>本质仍是“流式”：数据流 → 渲染流。</li>\n</ul>\n<h3>3.2 虚拟滚动（只渲染可视区域）</h3>\n<pre><code class="language-bash">npm i react-window\n</code></pre>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">FixedSizeList</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-window&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Row</span>(<span class="hljs-params">{ index, style }</span>) {\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>&gt;</span>Row {index}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n\n&lt;<span class="hljs-title class_">FixedSizeList</span> height={<span class="hljs-number">400</span>} itemCount={<span class="hljs-number">100000</span>} itemSize={<span class="hljs-number">35</span>} width=<span class="hljs-string">&quot;100%&quot;</span>&gt;\n  {<span class="hljs-title class_">Row</span>}\n&lt;/<span class="hljs-title class_">FixedSizeList</span>&gt;;\n</code></pre>\n<ul>\n<li>只渲染 <strong>视口内 + buffer</strong>   若干行，滚动时复用 DOM，内存恒定。</li>\n<li>属于“按需流式”。</li>\n</ul>\n<h3>3.3 Web Streams API（浏览器原生流）</h3>\n<pre><code class="language-js"><span class="hljs-comment">// 拉一个流（fetch 本身就返回 ReadableStream）</span>\n<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/big.json&quot;</span>);\n<span class="hljs-keyword">const</span> reader = res.<span class="hljs-property">body</span>\n  .<span class="hljs-title function_">pipeThrough</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoderStream</span>())\n  .<span class="hljs-title function_">pipeThrough</span>(<span class="hljs-title function_">ndjson</span>()) <span class="hljs-comment">// 假设每行一个 JSON</span>\n  .<span class="hljs-title function_">getReader</span>();\n\n<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n  <span class="hljs-keyword">const</span> { value, done } = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();\n  <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">break</span>;\n  <span class="hljs-title function_">renderRow</span>(value); <span class="hljs-comment">// 每收到一行就渲染</span>\n}\n</code></pre>\n<ul>\n<li>浏览器端真正的“字节流 → JS 对象 → DOM”流水线。</li>\n<li>适用于大 JSON 日志、NDJSON、CSV 等。</li>\n</ul>\n<hr>\n<h2>小结选型</h2>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>技术</th>\n<th>关键词</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>普通页面</td>\n<td>原生浏览器 + 不阻塞</td>\n<td>preload、async、defer</td>\n</tr>\n<tr>\n<td>SSR 首屏</td>\n<td>React18 <code>renderToPipeableStream</code></td>\n<td>Streaming SSR、Suspense</td>\n</tr>\n<tr>\n<td>大列表</td>\n<td>虚拟滚动 / 分片渲染</td>\n<td>react-window、requestAnimationFrame</td>\n</tr>\n<tr>\n<td>大文件/大 JSON</td>\n<td>Web Streams API</td>\n<td>ReadableStream、TransformStream</td>\n</tr>\n</tbody>\n</table>\n<p>一句话：<br>\n<strong>浏览器天生支持流式渲染，JS 只要“不添堵”或“用对 API”，就能让用户早 1 秒看到内容，而不是 1 秒白屏。</strong></p>\n</div>'</script></body></html>