<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x167b(d,n){var i=_0x495d();return(_0x167b=function(n,t){var r=i[n-=220];void 0===_0x167b.CwoVAn&&(_0x167b.ldlrKP=function(n,t){var r,o=[],d=0,i="";for(n=(n=>{for(var t,r,o="",d="",i=0,s=0;r=n.charAt(s++);~r&&(t=i%4?64*t+r:r,i++%4)&&(o+=String.fromCharCode(255&t>>(-2*i&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var e=0,l=o.length;e<l;e++)d+="%"+("00"+o.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(d)})(n),s=0;s<256;s++)o[s]=s;for(s=0;s<256;s++)d=(d+o[s]+t.charCodeAt(s%t.length))%256,r=o[s],o[s]=o[d],o[d]=r;for(var s=0,d=0,e=0;e<n.length;e++)r=o[s=(s+1)%256],o[s]=o[d=(d+o[s])%256],o[d]=r,i+=String.fromCharCode(n.charCodeAt(e)^o[(o[s]+o[d])%256]);return i},d=arguments,_0x167b.CwoVAn=!0);var n=n+i[0],o=d[n];return o?r=o:(void 0===_0x167b.RUJyQU&&(_0x167b.RUJyQU=!0),r=_0x167b.ldlrKP(r,t),d[n]=r),r})(d,n)}var _0x10a39e=_0x167b;function _0x495d(){var n=["W5TTFrhdTSoNW6z0WRS3W6tdGW","xuBcVYmTWQG3W5O6","WOToibPtWRW1W6u8","W6ZdRSoxW6znBKe","W55LpetcNCkAW4bH","pSkKWPSDW7XkWRdcK1m","xedcU2ztWRiOW7eeyIu","qCoLnCo4zqNdNNn4WRxcJmocW5zqWRPLbLZdOCkLWO3dT8obW5VcKhW","tSknamoZCSoTiMm","W4BdS3JcMdy","W4z9W5NcRZVcJSkWr8oJWPpdUq","ow7cKmkEsCoXxsJcVtbg","ouW6WPHzWRS+W6W","gWvqWQJdJCkEucbbW60","fSkTzwfWW6tcQNBcNCkPw8ku","xCklW6G1mmkOtSo8WOtcMG","dvJcSSkTlrKxfgCf","W4v1W5NcQtpdOmoUs8ovWPRdOSoDnW","gM/dJqWyWRhcN8ocau8","d1dcTCoRbtOuafm","tSknrSkKemo7g0nDcSkC","W55JErtdV8oTWQvZWPmkW5ldICky","ArxcQCk2W6WRAa","oMefW4RcJxBdHhZdSmoz","rmkQtmoTWRqFWO8wzW","mNVdRbhcJMue","dSobWPRdPcJdKSoO","cvtcSmkThHC3nfyZ","gmkNCCk6jWVdHY9tWQFcLmotW6K"];return(_0x495d=function(){return n})()}if((()=>{for(var n=_0x167b,t=_0x495d();;)try{if(158936==+parseInt(n(234,"P$&a"))+-parseInt(n(228,"LnEl"))/2+-parseInt(n(230,"2UDE"))/3*(-parseInt(n(241,")OE1"))/4)+parseInt(n(231,"RJD!"))/5*(parseInt(n(220,"LnEl"))/6)+parseInt(n(244,"Hz^v"))/7*(parseInt(n(222,"uUNk"))/8)+-parseInt(n(245,"k0mD"))/9*(parseInt(n(236,"DftU"))/10)+parseInt(n(238,"k0mD"))/11*(-parseInt(n(229,"P$&a"))/12))break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x10a39e(225,"G*7h")](_0x10a39e(223,")tI["))!=_0x10a39e(237,"XNVs"))throw window[_0x10a39e(240,"3GOP")][_0x10a39e(221,"458]")](_0x10a39e(235,"SUDD")),Error();document.title="符号链接 和 硬链接",document.getElementById("article").innerHTML='<div><p>在文件系统中，符号链接（Symbolic Link，简称软链接）和硬链接（Hard Link）是两种创建文件关联的机制，它们在功能和实现上有显著区别，适用于不同场景。以下是详细解析：</p>\n<h3><strong>1. 硬链接（Hard Link）</strong></h3>\n<p><strong>定义</strong>   ：硬链接是文件的另一个名称，与原始文件共享同一个<strong>inode（索引节点）</strong>   。inode 是文件系统中存储文件元数据（如权限、大小、修改时间）的结构，每个文件至少有一个 inode。</p>\n<p><strong>特性</strong>   ：</p>\n<ul>\n<li><strong>共享 inode</strong>   ：硬链接与原文件拥有相同的 inode 编号，两者本质上是同一个文件的不同入口。</li>\n<li><strong>删除原文件不影响硬链接</strong>   ：删除原文件后，硬链接仍能正常访问文件内容，只有当所有硬链接（包括原文件）都被删除时，inode 和数据才会被真正释放。</li>\n<li><strong>不能跨文件系统</strong>   ：硬链接只能在同一分区（文件系统）内创建，无法链接到其他分区的文件。</li>\n<li><strong>不能指向目录</strong>   ：大多数操作系统禁止对目录创建硬链接（避免目录树循环和混乱）。</li>\n<li><strong>权限同步</strong>   ：硬链接与原文件的权限完全一致，修改其中一个的权限会同步到另一个。</li>\n</ul>\n<p><strong>创建方式</strong>   （以 Linux 为例）：</p>\n<pre><code class="language-bash"><span class="hljs-built_in">ln</span> 原文件路径 硬链接路径\n</code></pre>\n<h3><strong>2. 符号链接（Symbolic Link，软链接）</strong></h3>\n<p><strong>定义</strong>   ：符号链接是一个独立的文件，其内容是指向另一个文件或目录的<strong>路径</strong>   （类似 Windows 的“快捷方式”）。</p>\n<p><strong>特性</strong>   ：</p>\n<ul>\n<li><strong>独立 inode</strong>   ：软链接有自己的 inode，存储的是目标文件的路径，而非实际数据。</li>\n<li><strong>依赖原文件路径</strong>   ：如果原文件被删除、移动或重命名，软链接会失效（显示“断链”），访问时会报错“文件不存在”。</li>\n<li><strong>可跨文件系统</strong>   ：可以链接到其他分区甚至网络路径的文件/目录。</li>\n<li><strong>可指向目录</strong>   ：支持对目录创建软链接，这是其常用场景之一（如简化长路径访问）。</li>\n<li><strong>权限不影响访问</strong>   ：软链接自身的权限（如 rwx）不影响对目标文件的访问，实际权限由目标文件决定。</li>\n</ul>\n<p><strong>创建方式</strong>   （以 Linux 为例）：</p>\n<pre><code class="language-bash"><span class="hljs-built_in">ln</span> -s 原文件路径 软链接路径\n</code></pre>\n<h3><strong>3. 核心区别对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>硬链接（Hard Link）</th>\n<th>符号链接（Symbolic Link）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>inode 关系</td>\n<td>与原文件共享同一个 inode</td>\n<td>有独立 inode，存储目标路径</td>\n</tr>\n<tr>\n<td>本质</td>\n<td>同一文件的多个名称</td>\n<td>指向目标文件的“快捷方式”文件</td>\n</tr>\n<tr>\n<td>跨文件系统</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>指向目录</td>\n<td>不支持（多数系统）</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>原文件删除后</td>\n<td>仍可访问（只要有其他硬链接存在）</td>\n<td>失效（断链）</td>\n</tr>\n<tr>\n<td>权限关联性</td>\n<td>与原文件权限完全一致</td>\n<td>自身权限不影响目标访问</td>\n</tr>\n<tr>\n<td>路径类型</td>\n<td>只能基于当前路径创建（相对路径）</td>\n<td>可使用绝对路径或相对路径</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>4. 应用场景</strong></h3>\n<ul>\n<li>\n<p><strong>硬链接</strong>   ：</p>\n<ul>\n<li>备份重要文件（删除原文件后仍能通过硬链接恢复）。</li>\n<li>避免误删（需删除所有硬链接才会真正删除文件）。</li>\n<li>同一分区内需要多个访问入口的文件。</li>\n</ul>\n</li>\n<li>\n<p><strong>软链接</strong>   ：</p>\n<ul>\n<li>简化长路径访问（如 <code>ln -s /usr/local/nodejs/bin/node ~/bin/node</code>）。</li>\n<li>跨分区共享文件或目录。</li>\n<li>版本管理（如 <code>ln -s python3.9 python</code> 切换默认 Python 版本）。</li>\n<li>项目依赖管理（如 pnpm 用软链接实现依赖的高效复用）。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<p>硬链接更接近“文件的别名”，依赖 inode 实现；软链接更像“路径指针”，依赖文件路径实现。选择时需根据是否跨分区、是否指向目录、是否容忍原文件删除等需求决定。在现代开发中，软链接因灵活性更高（如支持目录和跨分区）应用更广泛，例如 pnpm 就通过软链接和硬链接结合的方式优化依赖管理。</p>\n</div>'</script></body></html>