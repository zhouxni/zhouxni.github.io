<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1badb0=_0x35ae;function _0x3fcc(){var n=["WQZcOxVdQ8oae8kP","W5OfmSo6W43dO8oHE8kimcTIDSkI","qrddRahdK8o1WO5cuSkNW419","FdldLwi1zSoqmSk7WPZcGSkRW7u","WQldMxjaWONdQYldLK/dGXNcMmk4BW","W54coCo7W4/dRCknnSk4csDk","ECkghNxdK8o/l8oZ","WRyEWPxdS8o3W7ddJa","WQldMqGTW7xcTupcRG","ySoihJz7h2a","p25jW7ddSK7dOmkqW7xdTXxdKmk+","W77dMMVcOCk4W45UCW","cmoFqd7cPKpdOMT7","W5Oemmo/W4RdR8oTb8kYfWLPtq","W5NdPdJcI8ovWRTehWhcPCkMWQZcPW","W5NdQJtcISorWRSGhqhcH8kwWQC","W5NdQZJcICouWRHbcshcRCkTWPhcJa","rCkCW5FdM03dRWFdJ2iCW6elW73dGeb4m8ogWO9xjw9fx8keW64","WQVcI0NcPCk1W4zo","W6a4g3ahWRpcG20","WRRdIfhcOmoLuCopW60","b8oEWORdSSoppufaW5vMnJFdRq","o8ozuZFcTfpdJa","W4/dPhfDaXFdTW","W5ddKCoZWRnvW43cRCkp","WPhcLmoiWPPL","xZZcSchdVXTIWPxcGmk8W4ldU3W","omopgSkFwfJcSSoBsaCUEW"];return(_0x3fcc=function(){return n})()}function _0x35ae(o,n){var r=_0x3fcc();return(_0x35ae=function(n,s){var e=r[n-=309];void 0===_0x35ae.BWXAFk&&(_0x35ae.qjXvRG=function(n,s){var e,a=[],o=0,r="";for(n=(n=>{for(var s,e,a="",o="",r=0,l=0;e=n.charAt(l++);~e&&(s=r%4?64*s+e:e,r++%4)&&(a+=String.fromCharCode(255&s>>(-2*r&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var c=0,d=a.length;c<d;c++)o+="%"+("00"+a.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(o)})(n),l=0;l<256;l++)a[l]=l;for(l=0;l<256;l++)o=(o+a[l]+s.charCodeAt(l%s.length))%256,e=a[l],a[l]=a[o],a[o]=e;for(var l=0,o=0,c=0;c<n.length;c++)e=a[l=(l+1)%256],a[l]=a[o=(o+a[l])%256],a[o]=e,r+=String.fromCharCode(n.charCodeAt(c)^a[(a[l]+a[o])%256]);return r},o=arguments,_0x35ae.BWXAFk=!0);var n=n+r[0],a=o[n];return a?e=a:(void 0===_0x35ae.chTXgH&&(_0x35ae.chTXgH=!0),e=_0x35ae.qjXvRG(e,s),o[n]=e),e})(o,n)}if((()=>{for(var n=_0x35ae,s=_0x3fcc();;)try{if(282432==-parseInt(n(315,"n1%^"))*(parseInt(n(309,"ZlHN"))/2)+-parseInt(n(316,"f)TS"))/3+-parseInt(n(326,"7f*m"))/4*(-parseInt(n(336,"X$f7"))/5)+parseInt(n(334,"$^vH"))/6*(-parseInt(n(333,"kbz@"))/7)+-parseInt(n(320,"39ai"))/8+parseInt(n(332,"bJET"))/9*(-parseInt(n(314,"*Tii"))/10)+-parseInt(n(310,"*Tii"))/11*(-parseInt(n(317,"W*39"))/12))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x1badb0(324,"W*39")](_0x1badb0(318,"5$Ks"))!=_0x1badb0(331,"hMzR"))throw window[_0x1badb0(325,"ayg2")][_0x1badb0(328,"5$Ks")](_0x1badb0(323,"i)MP")),Error();document.title="window.onerror 和 unhandledrejection",document.getElementById("article").innerHTML='<div><p>在Web开发中，<code>window.onerror</code> 和 <code>unhandledrejection</code> 是两个用于捕获和处理JavaScript运行时错误的重要机制。它们分别用于处理不同类型的错误场景。</p>\n<h3>window.onerror</h3>\n<p><code>window.onerror</code> 是一个全局错误处理事件，用于捕获运行时错误。这些错误通常包括语法错误、运行时异常等。通过为 <code>window.onerror</code> 分配一个处理函数，你可以捕获这些错误并进行相应的处理，比如记录错误日志、发送错误报告等。</p>\n<h4>使用方法</h4>\n<pre><code class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">message, source, lineno, colno, error</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error message:&#x27;</span>, message);\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Source:&#x27;</span>, source);\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Line number:&#x27;</span>, lineno);\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Column number:&#x27;</span>, colno);\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error object:&#x27;</span>, error);\n  <span class="hljs-comment">// 可以在这里发送错误报告到服务器或错误跟踪服务</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 返回true表示错误已被处理，会阻止浏览器的默认错误行为（如显示错误对话框）</span>\n};\n</code></pre>\n<h4>参数说明</h4>\n<ul>\n<li><code>message</code>: 错误信息。</li>\n<li><code>source</code>: 发生错误的脚本URL。</li>\n<li><code>lineno</code>: 发生错误的行号。</li>\n<li><code>colno</code>: 发生错误的列号。</li>\n<li><code>error</code>: Error对象（如果浏览器支持）。</li>\n</ul>\n<h3>unhandledrejection</h3>\n<p><code>unhandledrejection</code> 事件用于捕获未处理的Promise拒绝。在异步编程中，如果Promise被拒绝但没有相应的<code>.catch()</code>处理，就会触发<code>unhandledrejection</code>事件。这对于捕获异步代码中的错误非常有用。</p>\n<h4>使用方法</h4>\n<pre><code class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;unhandledrejection&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Unhandled rejection:&#x27;</span>, event.<span class="hljs-property">reason</span>);\n  <span class="hljs-comment">// 可以在这里发送错误报告到服务器或错误跟踪服务</span>\n  <span class="hljs-comment">// event.preventDefault(); // 如果需要，可以调用此方法阻止默认行为（在某些浏览器中可能无效）</span>\n});\n</code></pre>\n<h4>参数说明</h4>\n<ul>\n<li><code>event</code>: 一个包含拒绝原因（<code>event.reason</code>）和Promise对象（<code>event.promise</code>）的事件对象。</li>\n</ul>\n<h3>区别与联系</h3>\n<ul>\n<li><strong>区别</strong>  :\n<ul>\n<li><code>window.onerror</code> 主要用于捕获同步代码中的运行时错误。</li>\n<li><code>unhandledrejection</code> 专门用于捕获未处理的Promise拒绝，即异步代码中的错误。</li>\n</ul>\n</li>\n<li><strong>联系</strong>  :\n<ul>\n<li>两者都是全局错误处理机制，用于提升应用的健壮性和用户体验。</li>\n<li>在实际应用中，通常会同时使用这两个机制来确保尽可能多地捕获和处理错误。</li>\n</ul>\n</li>\n</ul>\n<h3>实践建议</h3>\n<ol>\n<li><strong>结合使用</strong>  : 在项目中同时设置 <code>window.onerror</code> 和 <code>unhandledrejection</code> 处理函数，以全面捕获错误。</li>\n<li><strong>错误报告</strong>  : 将捕获到的错误发送到服务器或错误跟踪服务（如Sentry），以便进行后续分析和处理。</li>\n<li><strong>用户反馈</strong>  : 在捕获到错误后，向用户提供友好的反馈，避免显示技术性的错误信息。</li>\n<li><strong>调试与测试</strong>  : 在开发阶段充分利用调试工具，并编写单元测试和集成测试来预防错误的发生。</li>\n</ol>\n</div>'</script></body></html>