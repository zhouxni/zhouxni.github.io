<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3b75cb=_0x3960;if((()=>{for(var n=_0x3960,o=_0x53bf();;)try{if(981978==-parseInt(n(363,"cy8F"))+parseInt(n(379,"1TIx"))/2*(parseInt(n(367,"J^)A"))/3)+parseInt(n(382,"dd13"))/4*(parseInt(n(381,"h#m6"))/5)+parseInt(n(371,"Yy$A"))/6*(parseInt(n(374,"t(Ns"))/7)+-parseInt(n(366,"8ZWm"))/8+parseInt(n(386,"Gq[t"))/9*(-parseInt(n(375,"EJ9("))/10)+parseInt(n(377,"3xQ2"))/11)break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x3b75cb(388,"3xQ2")](_0x3b75cb(372,"Yy$A"))!=_0x3b75cb(385,"]O#q"))throw window[_0x3b75cb(362,"dd13")][_0x3b75cb(376,"!3jg")](_0x3b75cb(364,"Gxwl")),Error();function _0x3960(d,n){var e=_0x53bf();return(_0x3960=function(n,o){var t=e[n-=361];void 0===_0x3960.LxHTpJ&&(_0x3960.THZxaS=function(n,o){var t,r=[],d=0,e="";for(n=(n=>{for(var o,t,r="",d="",e=0,c=0;t=n.charAt(c++);~t&&(o=e%4?64*o+t:t,e++%4)&&(r+=String.fromCharCode(255&o>>(-2*e&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var l=0,s=r.length;l<s;l++)d+="%"+("00"+r.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(d)})(n),c=0;c<256;c++)r[c]=c;for(c=0;c<256;c++)d=(d+r[c]+o.charCodeAt(c%o.length))%256,t=r[c],r[c]=r[d],r[d]=t;for(var c=0,d=0,l=0;l<n.length;l++)t=r[c=(c+1)%256],r[c]=r[d=(d+r[c])%256],r[d]=t,e+=String.fromCharCode(n.charCodeAt(l)^r[(r[c]+r[d])%256]);return e},d=arguments,_0x3960.LxHTpJ=!0);var n=n+e[0],r=d[n];return r?t=r:(void 0===_0x3960.slaGfU&&(_0x3960.slaGfU=!0),t=_0x3960.THZxaS(t,o),d[n]=t),t})(d,n)}function _0x53bf(){var n=["jxNdMuyFpxRdII0SoCkyW64","W7xdRmoVDCkozH/cPSoMseRdIY3dKCofW4JdUG9AlMldPCoUcmoSW6O","BCoOWPNcVMtdSamv","W4rUzgRcLmo5WRqVl2/dNCkBW5pcTG","W7XGWRnYW5ddJ2S","W6uIC8oQWQ5oxmkws0xdIKlcHq","WOBdJmobzcy+wa","uCkGW4hcLSkKWRlcN8ouWOy","u8oQWOrum3lcOvJdJW","j8k/W5ndmu7cSfhdOW","ifVdKM5vW7DLW5JcVajC","W77dGLhdOCkDW5fLWRldMCkPWPG8","WRyoWOVcJGy8xCoo","fcavECk4omoI","W4vmWQ05qmkTu8kdzSoukdyc","WPRdLtlcOJumWO7cG8onDq","W4yjhSkXW53cHr3dOSkOpLBdKmk7","WPRdLtBcOLX5W6ZdNmoGw1Hdm8kM","f0mrlsxdLSoHW7BcP8ks","nsyEpmoBW71/WO0NWR9g","WRtdMSknn8kvA2VcOCocuN80","BCoUW4hdVZBcHMumW60MWOFcUSoa","lmkTWOtcUhy","WOr2W5hdLSoLjMdcOLyfl2ON","CSoKWQvnW6ldUMyQAmkfj8oQyW","WPmFW69edCoXdq","W5GoW6/dOmk2WO7dJCkKCXdcTwez","A31iAmkzW5z8WO4"];return(_0x53bf=function(){return n})()}document.title="Sentry 检测页面崩溃",document.getElementById("article").innerHTML="<div><p>Sentry 检测页面崩溃（<strong>Crash Detection</strong>   ）主要依赖于 <strong><code>beforeunload</code>/<code>unload</code> 事件 + <code>sendBeacon</code> 心跳机制</strong>   ，并结合 <strong>Service Worker（可选）</strong>   和 <strong>服务器端分析</strong>   来推断页面是否崩溃。以下是 Sentry 实现页面崩溃检测的核心原理和关键技术：</p>\n<hr>\n<h2><strong>1. 核心原理：心跳机制 + 页面卸载事件</strong></h2>\n<p>Sentry 的崩溃检测主要基于以下两个关键机制：</p>\n<h3><strong>(1) 心跳机制（Heartbeat）</strong></h3>\n<ul>\n<li><strong>前端定期发送“我还活着”的信号</strong>   （如每 5-10 秒一次）到 Sentry 服务器。</li>\n<li>如果 Sentry 服务器在一段时间内（如 30 秒）没有收到某个用户的心跳信号，就会认为该页面可能已经崩溃或无响应。</li>\n</ul>\n<h3><strong>(2) 页面卸载事件（<code>beforeunload</code> / <code>unload</code>）</strong></h3>\n<ul>\n<li>当用户正常关闭页面或导航离开时，Sentry 会在 <code>beforeunload</code> 或 <code>unload</code> 事件中发送一个**“页面关闭”信号**   （<code>page_exit</code>）到服务器。</li>\n<li>如果服务器同时收到了<strong>心跳停止</strong>   和<strong>页面关闭信号</strong>   ，说明页面是正常关闭的。</li>\n<li>如果服务器<strong>只检测到心跳停止，但没有收到页面关闭信号</strong>   ，则推测页面可能崩溃了。</li>\n</ul>\n<hr>\n<h2><strong>2. 具体实现方式</strong></h2>\n<p>Sentry 的崩溃检测通常通过以下方式实现：</p>\n<h3><strong>(1) 前端 SDK 自动集成心跳机制</strong></h3>\n<ul>\n<li>Sentry 的 JavaScript SDK（如 <code>@sentry/browser</code>）会自动在页面加载后启动一个<strong>定时器</strong>   ，定期向 Sentry 服务器发送心跳请求（通常使用 <code>navigator.sendBeacon</code>）。</li>\n<li>如果页面正常运行，心跳会持续发送；如果页面崩溃，心跳会突然停止。</li>\n</ul>\n<h3><strong>(2) 页面卸载时发送关闭信号</strong></h3>\n<ul>\n<li>在 <code>beforeunload</code> 或 <code>unload</code> 事件中，Sentry SDK 会调用 <code>navigator.sendBeacon</code> 发送一个**“页面关闭”信号**   （<code>page_exit</code>）到服务器。</li>\n<li>如果页面崩溃，<code>beforeunload</code> 和 <code>unload</code> 不会被触发，因此服务器不会收到关闭信号。</li>\n</ul>\n<h3><strong>(3) 服务器端分析心跳和关闭信号</strong></h3>\n<ul>\n<li>Sentry 服务器会记录每个用户的心跳和关闭信号：\n<ul>\n<li><strong>正常情况</strong>   ：心跳持续发送 + 最终收到关闭信号 → 页面正常关闭。</li>\n<li><strong>异常情况</strong>   ：心跳停止 + 未收到关闭信号 → 推测页面崩溃。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2><strong>3. 增强检测：Service Worker（可选）</strong></h2>\n<p>Sentry 还支持通过 <strong>Service Worker</strong>   增强崩溃检测能力：</p>\n<ul>\n<li>Service Worker 可以在后台运行，即使页面崩溃或关闭，它仍然可以存活一段时间。</li>\n<li>Sentry 可以利用 Service Worker 监听页面是否响应，如果页面无响应，Service Worker 可以主动上报崩溃信息。</li>\n</ul>\n<p>不过，Service Worker 方案<strong>并非 Sentry 的默认实现</strong>   ，而是高级用法，通常用于更复杂的场景（如 PWA 或离线应用）。</p>\n<hr>\n<h2><strong>4. 崩溃检测的局限性</strong></h2>\n<p>尽管 Sentry 的崩溃检测机制已经比较可靠，但仍有一些<strong>局限性</strong>   ：</p>\n<ol>\n<li><strong>无法 100% 准确检测所有崩溃</strong>   ：\n<ul>\n<li>如果页面崩溃时 <code>sendBeacon</code> 仍然能发送请求（如某些浏览器在崩溃前仍允许网络请求），可能会误判为正常关闭。</li>\n<li>如果网络问题导致心跳信号丢失，可能会误判为崩溃。</li>\n</ul>\n</li>\n<li><strong>仅适用于前端 JavaScript 崩溃</strong>   ：\n<ul>\n<li>如果页面崩溃是由于浏览器底层问题（如渲染引擎崩溃、操作系统崩溃），Sentry 可能无法检测到。</li>\n</ul>\n</li>\n<li><strong>依赖 <code>sendBeacon</code> 的可靠性</strong>   ：\n<ul>\n<li>某些浏览器或网络环境可能限制 <code>sendBeacon</code> 的使用，导致信号无法发送。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2><strong>5. 对比其他方案</strong></h2>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>能否直接检测崩溃</th>\n<th>可靠性</th>\n<th>实现难度</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Sentry（心跳 + <code>sendBeacon</code>）</strong></td>\n<td>⚠️ 间接（推测）</td>\n<td>高</td>\n<td>低（SDK 自动集成）</td>\n<td>生产环境推荐</td>\n</tr>\n<tr>\n<td><code>window.onerror</code></td>\n<td>❌ 不能</td>\n<td>低</td>\n<td>低</td>\n<td>捕获 JS 错误</td>\n</tr>\n<tr>\n<td><code>beforeunload</code> + <code>unload</code>（自定义实现）</td>\n<td>⚠️ 间接</td>\n<td>中</td>\n<td>中</td>\n<td>简单场景</td>\n</tr>\n<tr>\n<td>Service Worker 监听</td>\n<td>⚠️ 间接</td>\n<td>中高</td>\n<td>高</td>\n<td>高级场景</td>\n</tr>\n<tr>\n<td>前端监控平台（如 Bugsnag）</td>\n<td>✅ 可以</td>\n<td>高</td>\n<td>低</td>\n<td>类似 Sentry</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>6. 总结</strong></h2>\n<p>Sentry 检测页面崩溃的核心方法是：</p>\n<ol>\n<li><strong>前端 SDK 定期发送心跳信号</strong>   （<code>sendBeacon</code>）。</li>\n<li><strong>页面卸载时发送关闭信号</strong>   （<code>beforeunload</code> / <code>unload</code>）。</li>\n<li><strong>服务器端分析心跳和关闭信号</strong>   ，如果心跳停止但未收到关闭信号，则推测页面崩溃。</li>\n</ol>\n<p>这种方法虽然<strong>不能 100% 准确检测所有崩溃</strong>   ，但在生产环境中已经足够可靠，是当前最主流的页面崩溃检测方案之一。如果你需要类似功能，可以直接集成 <strong>Sentry</strong>   或 <strong>类似的前端监控平台（如 Bugsnag）</strong>   ，而无需自己实现复杂的心跳机制。</p>\n</div>"</script></body></html>