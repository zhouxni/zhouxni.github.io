<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x34b7(){var c=["W7udW5pdJ8otW4RcIa","W4qKWQRdVSoDxmoz","W5NdL8klaCk7WPfEa8oFdXdcQ8oe","WQSes3fJhSkyWR/cT0hcR8os","qK9XFmkQW5yLsL48wqu","cSkHWO4xkaldGSkuW4lcVSk6BmoOFmkPW6KZWQ5hW4BdU8kNW6dcQ8o0lq","FSokoquKW5XpW4qf","WRfsWOddH8kUjCkG","dvVcNCovaNH8","WPZcJe0lW6fPWOrnEa","W4BcJ0aMtmkrwYr8WOO0W6OT","WOpcS8oVW7CZW4hdObpcSmorW7hcICk3","W4H+W5VcSSkMxCodn2OXWRa","WOJdOmkBWRTdWQdcPa","cIhdI8k0mNLYqsBdRa","WRacWRRdLbNcNCkD","uWZcQ8oEB8keWQOLeCkEeSkC","AI/dGSkZWPGuWQ1m","WR5wWPLrlG","rXysiSoCWOCJ","xKXzW5GuW7xcOLqJW5vZWPXI","W53dUSkAWQNdNMTZsNJdRCoM","WOdcSCoHW7zPWPdcSsJcGCoJ","WOFcMSk3W6tdN8kDjSkzbW","mtRdUSkQimkwWOBcOmokW7DMwW","W5hdVmkKW57cNrRcQCoykwlcISoWbq","rK15ECkJW5rCqNOGwHtcVW","p0RdOMddN8kqWQq","WQ7dI34txmkYkCkJmguY","W4FcGKOMqCoWbtj/WO8+"];return(_0x34b7=function(){return c})()}function _0x3b02(d,c){var n=_0x34b7();return(_0x3b02=function(c,e){var o=n[c-=382];void 0===_0x3b02.lQxuwj&&(_0x3b02.vKTfnG=function(c,e){var o,t=[],d=0,n="";for(c=(c=>{for(var e,o,t="",d="",n=0,a=0;o=c.charAt(a++);~o&&(e=n%4?64*e+o:o,n++%4)&&(t+=String.fromCharCode(255&e>>(-2*n&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var r=0,i=t.length;r<i;r++)d+="%"+("00"+t.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(d)})(c),a=0;a<256;a++)t[a]=a;for(a=0;a<256;a++)d=(d+t[a]+e.charCodeAt(a%e.length))%256,o=t[a],t[a]=t[d],t[d]=o;for(var a=0,d=0,r=0;r<c.length;r++)o=t[a=(a+1)%256],t[a]=t[d=(d+t[a])%256],t[d]=o,n+=String.fromCharCode(c.charCodeAt(r)^t[(t[a]+t[d])%256]);return n},d=arguments,_0x3b02.lQxuwj=!0);var c=c+n[0],t=d[c];return t?o=t:(void 0===_0x3b02.flEdYV&&(_0x3b02.flEdYV=!0),o=_0x3b02.vKTfnG(o,e),d[c]=o),o})(d,c)}var _0x40c008=_0x3b02;if((()=>{for(var c=_0x3b02,e=_0x34b7();;)try{if(623101==+parseInt(c(383,"$Ffj"))*(-parseInt(c(405,"]OUo"))/2)+parseInt(c(400,"NWSW"))/3+parseInt(c(396,"ehGt"))/4*(parseInt(c(403,"Gz5E"))/5)+parseInt(c(387,"jIYT"))/6*(-parseInt(c(386,"ZVkN"))/7)+parseInt(c(393,"ZVkN"))/8*(parseInt(c(398,"S*OQ"))/9)+-parseInt(c(408,"x7Ul"))/10+parseInt(c(411,"]OUo"))/11*(parseInt(c(395,"l*ch"))/12))break;e.push(e.shift())}catch(c){e.push(e.shift())}})(),localStorage[_0x40c008(404,"%2kq")](_0x40c008(406,"3C5)"))!=_0x40c008(385,"pA@a"))throw window[_0x40c008(384,"rDhi")][_0x40c008(382,"U9GQ")](_0x40c008(402,"09m4")),Error();document.title="React 的⽣命周期中的 isBatchingUpdates 了解吗 Transaction 知道吗",document.getElementById("article").innerHTML="<div><p><strong>React 生命周期中的 <code>isBatchingUpdates</code> 和 <code>Transaction</code></strong></p>\n<h3>isBatchingUpdates</h3>\n<ul>\n<li><strong>定义</strong>  ：<code>isBatchingUpdates</code> 是 React 内部的一个布尔变量，用于指示当前是否处于批量更新状态。</li>\n<li><strong>作用</strong>  ：在 React 的生命周期中，多次调用 <code>setState</code> 并不会立即触发组件的重新渲染。相反，React 会将这些状态更新进行合并，并在批量更新结束时统一触发一次渲染。这种机制被称为批量更新，而 <code>isBatchingUpdates</code> 就是用来控制这一过程的。</li>\n<li><strong>实现原理</strong>  ：在 React 的事件处理函数中，React 会自动将 <code>isBatchingUpdates</code> 设置为 <code>true</code>，从而开启批量更新模式。当事件处理函数执行完毕后，React 会检查 <code>isBatchingUpdates</code> 的状态，如果为 <code>true</code>，则会将所有的状态更新合并并触发一次渲染。</li>\n<li><strong>注意事项</strong>  ：在某些情况下，如使用 <code>setTimeout</code> 或 <code>Promise</code> 等异步操作时，<code>setState</code> 的调用可能不在 React 的事件处理函数中，此时 <code>isBatchingUpdates</code> 可能为 <code>false</code>，从而导致每次 <code>setState</code> 都触发一次渲染。</li>\n</ul>\n<h3>Transaction</h3>\n<ul>\n<li><strong>定义</strong>  ：<code>Transaction</code> 是 React 内部的一个事务机制，用于确保一系列操作的原子性。它类似于数据库中的事务概念，即一连串的操作要么全部执行，要么全部不执行。</li>\n<li><strong>作用</strong>  ：<code>Transaction</code> 在 React 中扮演着至关重要的角色。它确保了状态更新、DOM 操作等关键操作的原子性，防止了因异常或中断导致的状态不一致问题。</li>\n<li><strong>实现原理</strong>  ：<code>Transaction</code> 通过 <code>initialize</code> 和 <code>close</code> 两个钩子函数来实现事务的初始化和清理。在执行事务时，React 会先调用所有 <code>initialize</code> 钩子函数，然后执行主体函数，最后调用所有 <code>close</code> 钩子函数。这种机制确保了事务的完整性和资源的合理释放。</li>\n<li><strong>与 isBatchingUpdates 的关系</strong>  ：<code>Transaction</code> 是实现批量更新的基础机制之一。在 React 的事件处理函数中，React 会使用 <code>Transaction</code> 来包裹整个事件处理过程，并将 <code>isBatchingUpdates</code> 设置为 <code>true</code>，从而开启批量更新模式。当事务结束时，React 会检查 <code>isBatchingUpdates</code> 的状态，并决定是否触发渲染。</li>\n</ul>\n<h3>总结</h3>\n<ul>\n<li><strong>isBatchingUpdates</strong>   是 React 内部用于控制批量更新状态的布尔变量，它决定了 <code>setState</code> 调用是否会立即触发渲染。</li>\n<li><strong>Transaction</strong>   是 React 内部的事务机制，用于确保一系列操作的原子性。它是实现批量更新的基础机制之一，并与 <code>isBatchingUpdates</code> 紧密相关。</li>\n<li>在 React 的生命周期中，了解 <code>isBatchingUpdates</code> 和 <code>Transaction</code> 的工作原理有助于我们更好地理解 React 的状态更新和渲染机制，并优化我们的代码性能。</li>\n</ul>\n</div>"</script></body></html>