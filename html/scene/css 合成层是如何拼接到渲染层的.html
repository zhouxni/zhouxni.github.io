<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x412c(e,n){var s=_0x4b6a();return(_0x412c=function(n,o){var r=s[n-=217];void 0===_0x412c.saPHtX&&(_0x412c.VwlrGq=function(n,o){var r,t=[],e=0,s="";for(n=(n=>{for(var o,r,t="",e="",s=0,l=0;r=n.charAt(l++);~r&&(o=s%4?64*o+r:r,s++%4)&&(t+=String.fromCharCode(255&o>>(-2*s&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var d=0,i=t.length;d<i;d++)e+="%"+("00"+t.charCodeAt(d).toString(16)).slice(-2);return decodeURIComponent(e)})(n),l=0;l<256;l++)t[l]=l;for(l=0;l<256;l++)e=(e+t[l]+o.charCodeAt(l%o.length))%256,r=t[l],t[l]=t[e],t[e]=r;for(var l=0,e=0,d=0;d<n.length;d++)r=t[l=(l+1)%256],t[l]=t[e=(e+t[l])%256],t[e]=r,s+=String.fromCharCode(n.charCodeAt(d)^t[(t[l]+t[e])%256]);return s},e=arguments,_0x412c.saPHtX=!0);var n=n+s[0],t=e[n];return t?r=t:(void 0===_0x412c.KMFOxY&&(_0x412c.KMFOxY=!0),r=_0x412c.VwlrGq(r,o),e[n]=r),r})(e,n)}function _0x4b6a(){var n=["lY5aWQKaWPvo","W71SFSkAW6tdU8kwWRddGSozWR0","W60aWPKvW7m6EmkozJxcMIi","ECo+W5nJDmkwW4m","WQPjosZcQ8ktE1f5W51zW4vW","nSofWR4aWPnIwq","W4BdR3ifxa","kfLvWQ4OWO5Cua","smkOW6iUWRDAfq","WQ5cW4jKW7OpgmkOW77dTZO","mCk+W7LCW6OAsSogmCkveJO","E0hcSMhcNxm+","W4tcNCkHqmoNW7NcUSkQWOy/WOVcJM8","W4dcNCkJqCoPWRBdVmkMWQiJWQC","WQ4jW60hlSkgWONcN8kgW5FcOa","WOxcGxOso8k+WR4LoHFdQmol","CSoVWRKfWRPitG","W6BdHSksfCo4jxGK","aLNcHuRcP0W+ph7dN2m2WO1pl0JcS2zcyNaSnSoqj8kO","jCoJW4DHW7bxwW","WQ5/buKBWOxcVmoaWQCNWRX9W4G","W5tcO8oMWR4ZW43dOWdcMmoFW5np","W53dGCkEW49bWRVdVa","W4VdISkseCo/p1WVpG","W79PmmoPWPJdKSkJWPy","W5pdP8kRoSoxfWCXWPbika","W4lcKSo1kSorWQ5up8ovWR/dMgdcPG","k8kOWPCBmCkjW6nmvdZdSq"];return(_0x4b6a=function(){return n})()}var _0x7ddd77=_0x412c;if((()=>{for(var n=_0x412c,o=_0x4b6a();;)try{if(171991==+parseInt(n(238,"PEhd"))+-parseInt(n(229,"S]qa"))/2*(-parseInt(n(244,"Ejen"))/3)+-parseInt(n(227,"KJq3"))/4+parseInt(n(231,"Uh[K"))/5*(-parseInt(n(237,"N4Pf"))/6)+-parseInt(n(228,"c@DD"))/7*(-parseInt(n(220,"d^A7"))/8)+-parseInt(n(243,"XUY^"))/9*(-parseInt(n(236,"S]qa"))/10)+parseInt(n(233,"35uU"))/11)break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x7ddd77(232,"c@DD")](_0x7ddd77(224,"FUUz"))!=_0x7ddd77(235,"R(&S"))throw window[_0x7ddd77(218,"FUUz")][_0x7ddd77(217,"DHkN")](_0x7ddd77(219,"Z)m2")),Error();document.title="css 合成层是如何拼接到渲染层的",document.getElementById("article").innerHTML="<div><p>在浏览器渲染流程中，<strong>合成层（Composite Layer）</strong>  与<strong>渲染层（Render Layer）</strong>  的拼接（合成）是通过 <strong>Compositing（合成）</strong>   阶段完成的。以下是详细的步骤和原理：</p>\n<hr>\n<h3>1. <strong>渲染层（Render Layer）的生成</strong></h3>\n<p>浏览器首先将页面元素分组成多个 <strong>渲染层</strong>  ：</p>\n<ul>\n<li>每个渲染层负责一部分内容的 <strong>绘制（Paint）</strong>  （例如：背景、边框、文本等）。</li>\n<li>渲染层是逻辑分组，不一定触发GPU加速。</li>\n</ul>\n<hr>\n<h3>2. <strong>合成层（Composite Layer）的创建</strong></h3>\n<p>部分渲染层会被提升为 <strong>合成层</strong>  （GPU加速的独立层），条件包括：</p>\n<ul>\n<li>使用 <code>transform</code>、<code>opacity</code>、<code>filter</code> 等GPU加速属性。</li>\n<li>显式声明 <code>will-change</code> 或 <code>translateZ(0)</code> 强制提升。</li>\n</ul>\n<hr>\n<h3>3. <strong>合成层的拼接流程</strong></h3>\n<p>浏览器通过以下步骤将合成层拼接到最终画面：</p>\n<h4>步骤 1：<strong>绘制（Paint）到纹理（Texture）</strong></h4>\n<ul>\n<li>每个合成层的内容会被 <strong>光栅化</strong>  （Rasterize）为位图（Bitmap），存储在 <strong>GPU内存</strong>   中（称为纹理）。</li>\n<li>例如：一个 <code>transform: translateZ(0)</code> 的<code>&lt;div&gt;</code>会被绘制为独立的GPU纹理。</li>\n</ul>\n<h4>步骤 2：<strong>生成合成树（Compositing Tree）</strong></h4>\n<ul>\n<li>浏览器构建一个 <strong>合成树</strong>  ，记录所有合成层的层级关系（z-index、重叠顺序等）。</li>\n<li>合成树决定了哪些层需要合并，哪些需要独立保留。</li>\n</ul>\n<h4>步骤 3：<strong>图层合成（Compositing）</strong></h4>\n<ul>\n<li>GPU 根据合成树的指令，将多个合成层的纹理 <strong>按正确顺序叠加</strong>  ：\n<ul>\n<li>通过 <strong>Alpha混合</strong>  （透明度混合）处理重叠区域。</li>\n<li>应用 <code>opacity</code>、<code>mix-blend-mode</code> 等混合效果。</li>\n</ul>\n</li>\n<li>最终输出一张完整的位图（即屏幕显示的帧）。</li>\n</ul>\n<h4>步骤 4：<strong>显示（Display）</strong></h4>\n<ul>\n<li>合成后的最终图像被提交给操作系统，显示到屏幕上。</li>\n</ul>\n<hr>\n<h3>4. <strong>关键点：合成层如何影响性能</strong></h3>\n<ul>\n<li><strong>优点</strong>  ：\n<ul>\n<li>独立合成层的变化（如移动、透明度）<strong>无需重绘</strong>  ，只需重新合成（性能更高）。</li>\n<li>GPU加速适用于动画、滚动等高频操作。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>过多的合成层会导致 <strong>内存占用增加</strong>  （每个层都需要GPU存储纹理）。</li>\n<li>不合理的层提升可能引发 <strong>层爆炸</strong>  （如过多<code>z-index</code>嵌套层）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>5. <strong>开发者工具验证</strong></h3>\n<p>在 <strong>Chrome DevTools</strong>   中：</p>\n<ol>\n<li>打开 <strong><code>Layers</code> 面板</strong>  （<code>More Tools → Layers</code>）：\n<ul>\n<li>查看所有合成层的层级结构和内存占用。</li>\n</ul>\n</li>\n<li>使用 <strong><code>Performance</code> 面板</strong>   录制：\n<ul>\n<li>分析 <code>Composite Layers</code> 阶段的耗时。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>6. <strong>优化建议</strong></h3>\n<ul>\n<li><strong>减少不必要的合成层</strong>  ：避免滥用 <code>will-change</code> 或 <code>translateZ(0)</code>。</li>\n<li><strong>优先使用GPU友好属性</strong>  ：如 <code>transform</code> 和 <code>opacity</code> 实现动画。</li>\n<li><strong>避免层重叠爆炸</strong>  ：控制 <code>z-index</code> 层级复杂度。</li>\n</ul>\n<hr>\n<h3>总结</h3>\n<p>合成层的拼接本质是：<br>\n<strong>将多个GPU纹理按层级关系混合成最终图像</strong>  ，通过独立的合成流程跳过布局（Layout）和绘制（Paint），从而提升渲染性能。</p>\n</div>"</script></body></html>