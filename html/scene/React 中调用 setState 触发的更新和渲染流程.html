<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x78eb(o,n){var l=_0x2d79();return(_0x78eb=function(n,e){var s=l[n-=337];void 0===_0x78eb.umMvvV&&(_0x78eb.nFaJty=function(n,e){var s,t=[],o=0,l="";for(n=(n=>{for(var e,s,t="",o="",l=0,a=0;s=n.charAt(a++);~s&&(e=l%4?64*e+s:s,l++%4)&&(t+=String.fromCharCode(255&e>>(-2*l&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var c=0,r=t.length;c<r;c++)o+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(o)})(n),a=0;a<256;a++)t[a]=a;for(a=0;a<256;a++)o=(o+t[a]+e.charCodeAt(a%e.length))%256,s=t[a],t[a]=t[o],t[o]=s;for(var a=0,o=0,c=0;c<n.length;c++)s=t[a=(a+1)%256],t[a]=t[o=(o+t[a])%256],t[o]=s,l+=String.fromCharCode(n.charCodeAt(c)^t[(t[a]+t[o])%256]);return l},o=arguments,_0x78eb.umMvvV=!0);var n=n+l[0],t=o[n];return t?s=t:(void 0===_0x78eb.RUbZZk&&(_0x78eb.RUbZZk=!0),s=_0x78eb.nFaJty(s,e),o[n]=s),s})(o,n)}var _0x237317=_0x78eb;function _0x2d79(){var n=["WPKpW4hdOmoYWOuVtSkdBuhcStqaW4tdMSkqcZnlWOWSyCodW79l","WRdcUmo8fgpcOmkCW50v","abFcQwymWOny","lGlcRSkywxdcKgKZW7yqzG","W4lcO8oOWRyOW45Pxq00vJC","W4blWOpcOmk3WO0Za8ksv1NcLYe","o0jLW53cTqrNeCo4xWy","WPLHoCoHW63dKCkW","lmovW7TUcvldVmoOWQXLW68W","juzJW6X7W7ZdTIT2W48obZy","WPpdJmkuW5hdSe09lSocv8oAtSkO","W7NcL2OukY4uW5e","iKfJW6n9W7ZcSW9JW4uLnq","iGBdMSobgItcO2u","W6/dGmo8AsPEzKeHamoM","W7ZcQL3dLb3cVsW","W65pWPZdKW7cLSo8xGZcUtjmWRu","W4BcO8oRbLVcMSkJ","pCoOx2WGW6C8mCk0pIBcOmkY","f1rfWR/dQSkJqJuSFmkPbG","lCowWO04saldJ8oh","W5tdVSoXWOT2WQVcOW","iNRdGw/dKhW3","yepdVftdUq","ELxdQ8o5WRrFW5ddQCkgWOW3WRX7","W6tdGmoWBYmVrKOkiSo5W7e"];return(_0x2d79=function(){return n})()}if((()=>{for(var n=_0x78eb,e=_0x2d79();;)try{if(281412==+parseInt(n(349,"L!%3"))*(parseInt(n(359,"buLA"))/2)+-parseInt(n(352,"xe2("))/3+-parseInt(n(361,"T@y3"))/4*(parseInt(n(360,"%*FZ"))/5)+parseInt(n(351,"gl6H"))/6+parseInt(n(338,"YE(y"))/7*(parseInt(n(355,"Gd0^"))/8)+-parseInt(n(357,"8Ce9"))/9+parseInt(n(337,"x@iM"))/10)break;e.push(e.shift())}catch(n){e.push(e.shift())}})(),localStorage[_0x237317(342,"xOa2")](_0x237317(348,"YE(y"))!=_0x237317(344,"gcL9"))throw window[_0x237317(358,"4]yj")][_0x237317(354,"1huP")](_0x237317(347,"xe2(")),Error();document.title="React 中调用 setState 触发的更新和渲染流程",document.getElementById("article").innerHTML='<div><p>在 React 中，调用 <code>setState</code> 触发的更新和渲染流程可以分为以下几个关键阶段（以 React 17+ 的 Fiber 架构为例，React 18 的并发模式类似但增加了优先级调度优化）：</p>\n<hr>\n<h3>1. <strong>触发 <code>setState</code></strong></h3>\n<pre><code class="language-jsx"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> }, callback); <span class="hljs-comment">// 类组件</span>\n<span class="hljs-comment">// 或</span>\n<span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 函数组件（useState 的 dispatch 类似 setState）</span>\n</code></pre>\n<ul>\n<li><strong>作用</strong>  ：将状态变更加入队列，并标记组件需要重新渲染。</li>\n</ul>\n<hr>\n<h3>2. <strong>创建更新对象（Update）</strong></h3>\n<ul>\n<li>React 会创建一个 <code>update</code> 对象，存储新的状态和回调：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> update = {\n  <span class="hljs-attr">lane</span>: <span class="hljs-title class_">Lane</span>,       <span class="hljs-comment">// 优先级（如 DefaultLane、SyncLane）</span>\n  <span class="hljs-attr">payload</span>: { <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> }, <span class="hljs-comment">// 新状态（或函数：prevState =&gt; newState）</span>\n  callback,        <span class="hljs-comment">// setState 的回调</span>\n  <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,      <span class="hljs-comment">// 指向下一个更新（链表结构）</span>\n};\n</code></pre>\n</li>\n<li><strong>批处理</strong>  ：多个 <code>setState</code> 会被合并到同一个 <code>updateQueue</code> 链表中（自动合并连续更新）。</li>\n</ul>\n<hr>\n<h3>3. <strong>调度更新（scheduleUpdateOnFiber）</strong></h3>\n<ul>\n<li>将更新关联到对应的 <code>Fiber</code> 节点，并递归标记父 Fiber 为“需要更新”。</li>\n<li><strong>优先级调度</strong>  ：\n<ul>\n<li><strong>同步模式</strong>  （React 17 默认）：直接同步触发渲染。</li>\n<li><strong>并发模式</strong>  （React 18）：根据优先级（如用户交互 &gt; 数据加载）调度任务，可能中断低优先级渲染。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>4. <strong>协调阶段（Reconciliation）</strong></h3>\n<h4><strong>Render 阶段（可中断）</strong></h4>\n<ul>\n<li><strong>从根节点开始遍历</strong>  ：React 从 <code>FiberRoot</code> 出发，重新构建 Fiber 树。</li>\n<li><strong>Diffing 算法</strong>  ：\n<ul>\n<li>对比新旧 Fiber 节点，生成新的 Fiber 树（<code>workInProgress</code> 树）。</li>\n<li>标记副作用（如 <code>Placement</code>、<code>Update</code>、<code>Deletion</code>）。</li>\n</ul>\n</li>\n<li><strong>执行组件渲染</strong>  ：\n<ul>\n<li>类组件：调用 <code>render()</code> 方法。</li>\n<li>函数组件：执行函数体本身。</li>\n<li>Hooks：计算新的状态（如 <code>useState</code>、<code>useReducer</code>）。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>双缓存技术</strong></h4>\n<ul>\n<li>React 同时维护两棵 Fiber 树：\n<ul>\n<li><code>current</code>：当前显示的树。</li>\n<li><code>workInProgress</code>：正在构建的新树。</li>\n</ul>\n</li>\n<li>渲染完成后，两棵树交换（<code>workInProgress</code> 变为 <code>current</code>）。</li>\n</ul>\n<hr>\n<h3>5. <strong>提交阶段（Commit）</strong></h3>\n<h4><strong>不可中断的 DOM 更新</strong></h4>\n<ol>\n<li><strong>BeforeMutation</strong>  ：\n<ul>\n<li>调用 <code>getSnapshotBeforeUpdate</code>（类组件）。</li>\n</ul>\n</li>\n<li><strong>Mutation</strong>  ：\n<ul>\n<li>更新 DOM（插入、删除、修改节点）。</li>\n<li>执行 <code>useLayoutEffect</code> 的销毁函数。</li>\n</ul>\n</li>\n<li><strong>Layout</strong>  ：\n<ul>\n<li>调用 <code>componentDidMount</code>/<code>componentDidUpdate</code>（类组件）。</li>\n<li>执行 <code>useLayoutEffect</code> 的回调。</li>\n<li>触发 <code>setState</code> 的回调（如果有）。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>6. <strong>后续处理</strong></h3>\n<ul>\n<li><strong>异步副作用</strong>  ：<code>useEffect</code> 的回调会在浏览器绘制完成后异步执行。</li>\n<li><strong>调度后续任务</strong>  ：如果有未处理的低优先级更新，重新调度。</li>\n</ul>\n<hr>\n<h3>关键优化机制</h3>\n<ol>\n<li><strong>批处理（Batching）</strong>  ：\n<ul>\n<li>在事件处理函数或生命周期中的多个 <code>setState</code> 会被合并为一次更新。</li>\n<li>React 18 的自动批处理扩展到 Promise、setTimeout 等场景。</li>\n</ul>\n</li>\n<li><strong>优先级调度</strong>  （React 18）：\n<ul>\n<li>高优先级更新（如用户输入）会打断低优先级渲染，减少卡顿。</li>\n</ul>\n</li>\n<li><strong>惰性状态计算</strong>  ：<pre><code class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prevState</span> =&gt;</span> ({ <span class="hljs-attr">count</span>: prevState.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> }));\n</code></pre>\n<ul>\n<li>函数式更新确保基于最新状态。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>流程图解</h3>\n<pre><code>setState → 创建 Update → 加入队列 → 调度更新\n  → Render 阶段（构建 Fiber 树，标记副作用）\n  → Commit 阶段（更新 DOM，执行生命周期）\n  → 触发回调 → 异步 useEffect\n</code></pre>\n<hr>\n<h3>与首次渲染的区别</h3>\n<ul>\n<li><strong>首次渲染</strong>  ：从 <code>ReactDOM.render</code> 开始，创建整个 Fiber 树。</li>\n<li><strong>更新渲染</strong>  ：从 <code>setState</code> 触发，复用现有 Fiber 树，通过 Diffing 最小化变更。</li>\n</ul>\n<p>通过这一流程，React 实现了高效的局部更新和流畅的用户体验。</p>\n</div>'</script></body></html>