<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x312b7f=_0x4edd;function _0x4edd(c,s){var l=_0x2da2();return(_0x4edd=function(s,n){var a=l[s-=276];void 0===_0x4edd.xWIGRQ&&(_0x4edd.bDdRNg=function(s,n){var a,e=[],c=0,l="";for(s=(s=>{for(var n,a,e="",c="",l=0,p=0;a=s.charAt(p++);~a&&(n=l%4?64*n+a:a,l++%4)&&(e+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,o=e.length;t<o;t++)c+="%"+("00"+e.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(c)})(s),p=0;p<256;p++)e[p]=p;for(p=0;p<256;p++)c=(c+e[p]+n.charCodeAt(p%n.length))%256,a=e[p],e[p]=e[c],e[c]=a;for(var p=0,c=0,t=0;t<s.length;t++)a=e[p=(p+1)%256],e[p]=e[c=(c+e[p])%256],e[c]=a,l+=String.fromCharCode(s.charCodeAt(t)^e[(e[p]+e[c])%256]);return l},c=arguments,_0x4edd.xWIGRQ=!0);var s=s+l[0],e=c[s];return e?a=e:(void 0===_0x4edd.QIjlFf&&(_0x4edd.QIjlFf=!0),a=_0x4edd.bDdRNg(a,n),c[s]=a),a})(c,s)}if((()=>{for(var s=_0x4edd,n=_0x2da2();;)try{if(962496==-parseInt(s(282,"w91*"))*(parseInt(s(299,"oD!G"))/2)+-parseInt(s(296,"*AE^"))/3+-parseInt(s(284,"Z(6f"))/4*(-parseInt(s(290,"*AE^"))/5)+-parseInt(s(286,"2vQD"))/6*(-parseInt(s(304,"8rjF"))/7)+-parseInt(s(291,"*K#$"))/8+parseInt(s(297,"*K#$"))/9*(-parseInt(s(301,"*K#$"))/10)+-parseInt(s(300,"lO%3"))/11*(-parseInt(s(276,"djwC"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x312b7f(287,"5e#Z")](_0x312b7f(278,"B^f9"))!=_0x312b7f(295,"fTw^"))throw window[_0x312b7f(294,"p06u")][_0x312b7f(298,"Qct8")](_0x312b7f(303,"8rjF")),Error();function _0x2da2(){var s=["x8oXW4FdUfBcHbie","WOb6WOxcHehcSColwmkdzgFcKG","k8oeWQldLmouWRxcNa","WPFdPmoEW60YWP3dVGm5WP0zWOr9WQhdHZ9DWQZdR8okq0v4xKtdGW","W43cQmolW7ysW5tcQv0","WQD5lMazjXmBWRhcO0aXBa","dIBdRCknaCkkzSkFw8khgM3cVW","W4iLW6VdICopW4hcKmolnb4+WP0l","FSoeWOhcISkvW7RcPqxcGW","WQmZC2JdKSk0W4WPW7ldQsfS","DSkQW6pcPSkYW4OOW7lcUuPmae0","WRhdGrxcTczzga","C8olk8kbqM1g","eSobzSoFkurpuG","W6NdSvq4W7BcSmk3W5WoW7b7esK","FmkMWRRdVmoqWO5MW6u","CL3dV8ksamoXCg/cNCoNWO3cQfy","WQ0AC8o+WRrNyG","WPJdJxG5W4KWWOldUh/dRCkVWQq","W4aVghn3W6NdU8o8WRu","W6ldL0pcKSkYq2W","WOX7WOxcGetcTSkvwCkTt3hcOSkq","zSoIW5hcGfnHEMVcHmojmsJcGW","WRtcSSkfBhJcNWFcKfddVmoqWRVcUW","W7VdN8oYgmo6sLZcLq","gSk9CCkUmW","W6xcMHddSmoFoduTWROTWOhcV8od","WOv6WO7dPY/dGSo2AmkQ","WOn/w0LmW4NdIW","ACoHg8kbW63dI8oCFsFdJ3lcIG"];return(_0x2da2=function(){return s})()}document.title="Vue3 中，effectScope 如何管理多个 effect 生命周期",document.getElementById("article").innerHTML='<div><p>在 Vue3 中，<code>effectScope</code> 是一个用于<strong>管理多个 effect 生命周期</strong>  的工具，它通过内部维护一个 <code>effects</code> 数组来收集所有注册到该作用域的 effect。以下是其工作原理的详细解析：</p>\n<h3><strong>1. 核心概念：EffectScope</strong></h3>\n<p><code>effectScope</code> 是一个作用域容器，用于：</p>\n<ul>\n<li>批量管理多个 effect 的生命周期（如统一停止）。</li>\n<li>在组件卸载时自动释放资源，避免内存泄漏。</li>\n<li>实现嵌套作用域（如组件树中的嵌套组件）。</li>\n</ul>\n<h3><strong>2. 收集 Effect 的机制</strong></h3>\n<p>当创建一个 <code>effectScope</code> 并在其内部创建 effect 时，这些 effect 会被自动添加到该作用域的 <code>effects</code> 数组中。核心流程如下：</p>\n<h4><strong>（1）创建作用域</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { effectScope, effect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;\n\n<span class="hljs-keyword">const</span> scope = <span class="hljs-title function_">effectScope</span>(); <span class="hljs-comment">// 创建一个新的作用域</span>\n</code></pre>\n<h4><strong>（2）在作用域内创建 effect</strong></h4>\n<p>使用 <code>scope.run(fn)</code> 执行一个函数，该函数内部创建的所有 effect 都会被自动收集到该作用域中：</p>\n<pre><code class="language-javascript">scope.<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 此函数内部创建的 effect 会被 scope 收集</span>\n  <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Effect 1&#x27;</span>);\n  });\n  \n  <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Effect 2&#x27;</span>);\n  });\n});\n</code></pre>\n<h4><strong>（3）作用域内部实现</strong></h4>\n<p>当调用 <code>scope.run(fn)</code> 时，Vue 会：</p>\n<ol>\n<li>将当前活动作用域（<code>activeEffectScope</code>）设为 <code>scope</code>。</li>\n<li>执行传入的函数 <code>fn</code>，此时函数内部创建的所有 effect 都会关联到 <code>scope</code>。</li>\n<li>恢复之前的活动作用域。</li>\n</ol>\n<h3><strong>3. 源码简化实现</strong></h3>\n<p>以下是 <code>effectScope</code> 的简化实现，展示其如何收集 effect：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EffectScope</span> {\n  effects = []; <span class="hljs-comment">// 存储所有收集的 effect</span>\n  active = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 作用域是否活跃</span>\n  \n  <span class="hljs-title function_">run</span>(<span class="hljs-params">fn</span>) {\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span>) {\n      <span class="hljs-keyword">return</span>;\n    }\n    \n    <span class="hljs-comment">// 保存当前的活动作用域</span>\n    <span class="hljs-keyword">const</span> currentScope = activeEffectScope;\n    \n    <span class="hljs-keyword">try</span> {\n      <span class="hljs-comment">// 将当前作用域设为活动状态</span>\n      activeEffectScope = <span class="hljs-variable language_">this</span>;\n      \n      <span class="hljs-comment">// 执行函数，内部创建的 effect 会被收集到 this.effects</span>\n      <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>();\n    } <span class="hljs-keyword">finally</span> {\n      <span class="hljs-comment">// 恢复之前的活动作用域</span>\n      activeEffectScope = currentScope;\n    }\n  }\n  \n  <span class="hljs-comment">// 停止所有收集的 effect</span>\n  <span class="hljs-title function_">stop</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span>) {\n      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">effects</span>.<span class="hljs-property">length</span>; i++) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">effects</span>[i].<span class="hljs-title function_">stop</span>(); <span class="hljs-comment">// 调用 effect 的停止方法</span>\n      }\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">effects</span> = [];\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span> = <span class="hljs-literal">false</span>;\n    }\n  }\n}\n\n<span class="hljs-comment">// 创建 effect 时的简化逻辑</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) {\n  <span class="hljs-keyword">const</span> effect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactiveEffect</span>(fn);\n  \n  <span class="hljs-comment">// 如果有活动作用域，将此 effect 添加到该作用域</span>\n  <span class="hljs-keyword">if</span> (activeEffectScope) {\n    activeEffectScope.<span class="hljs-property">effects</span>.<span class="hljs-title function_">push</span>(effect);\n  }\n  \n  <span class="hljs-comment">// 执行 effect</span>\n  effect.<span class="hljs-title function_">run</span>();\n  \n  <span class="hljs-keyword">return</span> effect;\n}\n</code></pre>\n<h3><strong>4. 嵌套作用域</strong></h3>\n<p><code>effectScope</code> 支持嵌套，内层作用域的 effect 会被收集到最近的活动作用域中：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> parentScope = <span class="hljs-title function_">effectScope</span>();\n\nparentScope.<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 这些 effect 属于 parentScope</span>\n  <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Parent effect&#x27;</span>));\n  \n  <span class="hljs-keyword">const</span> childScope = <span class="hljs-title function_">effectScope</span>();\n  childScope.<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-comment">// 这些 effect 属于 childScope</span>\n    <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Child effect&#x27;</span>));\n  });\n});\n</code></pre>\n<h3><strong>5. 组件与 EffectScope 的关系</strong></h3>\n<p>在 Vue3 组件中，每个组件实例都有一个关联的 <code>effectScope</code>：</p>\n<ul>\n<li>组件的渲染 effect 会被收集到该作用域中。</li>\n<li>组件内使用的 <code>watch</code>、<code>watchEffect</code>、<code>computed</code> 等创建的 effect 也会被收集到该作用域中。</li>\n<li>当组件卸载时，其关联的 <code>effectScope</code> 会自动调用 <code>stop()</code>，停止所有收集的 effect，防止内存泄漏。</li>\n</ul>\n<h3><strong>6. 手动管理 EffectScope</strong></h3>\n<p>开发者可以手动创建和管理 <code>effectScope</code>，例如：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 创建一个可手动管理的作用域</span>\n<span class="hljs-keyword">const</span> scope = <span class="hljs-title function_">effectScope</span>();\n\n<span class="hljs-comment">// 在作用域内创建 effect</span>\nscope.<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n  <span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>);\n  });\n});\n\n<span class="hljs-comment">// 手动停止所有 effect</span>\nscope.<span class="hljs-title function_">stop</span>();\n</code></pre>\n<h3><strong>总结</strong></h3>\n<p><code>effectScope</code> 通过以下机制收集内部 effect：</p>\n<ol>\n<li>在 <code>scope.run(fn)</code> 执行期间，将当前作用域设为活动状态。</li>\n<li>当在此期间创建 effect 时，自动将其添加到活动作用域的 <code>effects</code> 数组中。</li>\n<li>通过嵌套活动作用域实现层级管理。</li>\n<li>提供 <code>stop()</code> 方法批量停止所有收集的 effect。</li>\n</ol>\n<p>这种设计使得 Vue3 能够高效管理组件和应用中的所有响应式副作用，确保资源正确释放，避免内存泄漏。</p>\n</div>'</script></body></html>