<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x565619=_0x2600;function _0x407c(){var s=["mefeWRFcO3FdOSkye8ocdSo3","WOZdUSoAfSoqc28ko8kwW5n+","EYPsgMtcUSo7","dXOlz2ZcK2lcG8kuW4BdMW","WODQWOa9WRJcTCkNyCkKrmkYBW","yHmIeSobE8kns23cUmkKsee","eqhcJ2ZdLxjyvSkaaCoMrG","eqNdUIWAlCkFwq","WPddV3tcGSkpw8kcvCkregBdGbK","WQ0jWQypv8oLWQddO07cVmknWPq","jSk4BcJdQLLx","lCkYEWddQLvvna","WOBcPvWFf0ldLg0Lo8ovW6CY","W4RdT1iHW5LlW4lcGeRcVr3cIG","wmonB8kRW6JcHK/cVq","y0/dRZajiNtcVSonC8kAqfTcWResW5VcSxhcUCoXW7VcVfv+WRe","yxZcMmoGWOaGsg/cRIlcUCoE","WOHOWOS9WRRcUmoRDmkUxSkDtCo7","W4v0WRXsc8k2dmontSkktKq","re0tWRNcPSkiW7CAWP8","W5hcUJhdHCoo","WQ0fWQqmuCkAWOxdIKxcICki"];return(_0x407c=function(){return s})()}function _0x2600(t,s){var e=_0x407c();return(_0x2600=function(s,n){var a=e[s-=113];void 0===_0x2600.ihvAjk&&(_0x2600.HTSPmy=function(s,n){var a,l=[],t=0,e="";for(s=(s=>{for(var n,a,l="",t="",e=0,o=0;a=s.charAt(o++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,p=l.length;c<p;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),o=0;o<256;o++)l[o]=o;for(o=0;o<256;o++)t=(t+l[o]+n.charCodeAt(o%n.length))%256,a=l[o],l[o]=l[t],l[t]=a;for(var o=0,t=0,c=0;c<s.length;c++)a=l[o=(o+1)%256],l[o]=l[t=(t+l[o])%256],l[t]=a,e+=String.fromCharCode(s.charCodeAt(c)^l[(l[o]+l[t])%256]);return e},t=arguments,_0x2600.ihvAjk=!0);var s=s+e[0],l=t[s];return l?a=l:(void 0===_0x2600.jXQQRK&&(_0x2600.jXQQRK=!0),a=_0x2600.HTSPmy(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x2600,n=_0x407c();;)try{if(297121==-parseInt(s(116,"tkKN"))+-parseInt(s(122,"9xMF"))/2+-parseInt(s(124,"mF%n"))/3+parseInt(s(132,"AeCD"))/4+parseInt(s(119,"PmwG"))/5*(parseInt(s(130,"ENN%"))/6)+-parseInt(s(134,"ek7!"))/7+parseInt(s(133,"mhdb"))/8)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x565619(126,"arh5")](_0x565619(113,"iyG("))!=_0x565619(114,"mF%n"))throw window[_0x565619(127,"arh5")][_0x565619(118,"7U4g")](_0x565619(131,"EG4p")),Error();document.title="React-router 的原理",document.getElementById("article").innerHTML='<div><p>React Router 是 React 应用中用于实现路由功能的库，它允许开发者根据 URL 的变化来渲染不同的组件。React Router 的核心原理基于组件和上下文（Context），通过监听 URL 的变化来动态渲染对应的组件。以下是 React Router 的工作原理的详细解析：</p>\n<hr>\n<h3><strong>1. 路由的基本概念</strong></h3>\n<ul>\n<li><strong>路由</strong>  ：\n<ul>\n<li>路由是指根据 URL 的不同，渲染不同的组件或页面。</li>\n<li>在单页应用（SPA）中，路由由前端控制，而不是由服务器控制。</li>\n</ul>\n</li>\n<li><strong>React Router 的作用</strong>  ：\n<ul>\n<li>提供了一套 API，使得在 React 应用中实现路由变得简单。</li>\n<li>允许开发者定义路由规则，并根据 URL 的变化来渲染对应的组件。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>2. 核心组件</strong></h3>\n<p>React Router 提供了几个核心组件，用于定义和管理路由：</p>\n<ul>\n<li><strong><code>&lt;BrowserRouter&gt;</code></strong>  ：\n<ul>\n<li>使用 HTML5 的 History API（如 <code>pushState</code> 和 <code>replaceState</code>）来管理 URL。</li>\n<li>是最常用的路由器组件，适用于现代浏览器。</li>\n</ul>\n</li>\n<li><strong><code>&lt;HashRouter&gt;</code></strong>  ：\n<ul>\n<li>使用 URL 的 hash 部分（<code>#</code>）来管理路由。</li>\n<li>适用于需要支持旧版浏览器的应用。</li>\n</ul>\n</li>\n<li><strong><code>&lt;Routes&gt;</code></strong>   和 <strong><code>&lt;Route&gt;</code></strong>  ：\n<ul>\n<li><code>&lt;Routes&gt;</code> 用于包裹一组 <code>&lt;Route&gt;</code> 组件。</li>\n<li><code>&lt;Route&gt;</code> 用于定义具体的路由规则，指定 URL 路径和对应的组件。</li>\n</ul>\n</li>\n<li><strong><code>&lt;Link&gt;</code></strong>  ：\n<ul>\n<li>用于创建导航链接，类似于 HTML 的 <code>&lt;a&gt;</code> 标签，但不会触发页面刷新。</li>\n</ul>\n</li>\n<li><strong><code>&lt;Navigate&gt;</code></strong>  ：\n<ul>\n<li>用于编程式导航，可以在组件中触发路由跳转。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>3. 路由匹配原理</strong></h3>\n<ul>\n<li><strong>路径匹配</strong>  ：\n<ul>\n<li>当 URL 发生变化时，React Router 会遍历所有定义的 <code>&lt;Route&gt;</code> 组件，找到与当前 URL 匹配的路由。</li>\n<li>匹配成功后，渲染对应的组件。</li>\n</ul>\n</li>\n<li><strong>嵌套路由</strong>  ：\n<ul>\n<li>支持嵌套路由，可以在组件内部定义子路由。</li>\n<li>通过 <code>&lt;Outlet&gt;</code> 组件来渲染子路由对应的组件。</li>\n</ul>\n</li>\n<li><strong>动态路由</strong>  ：\n<ul>\n<li>支持动态路由参数，如 <code>/user/:id</code>。</li>\n<li>可以通过 <code>useParams</code> 钩子获取动态参数。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>4. 上下文（Context）机制</strong></h3>\n<ul>\n<li><strong>Router Context</strong>  ：\n<ul>\n<li>React Router 使用 React 的 Context API 来提供路由相关的信息（如当前 URL、导航方法等）。</li>\n<li><code>&lt;BrowserRouter&gt;</code> 或 <code>&lt;HashRouter&gt;</code> 组件会创建一个 Router Context，供子组件使用。</li>\n</ul>\n</li>\n<li><strong><code>useNavigate</code>、<code>useLocation</code>、<code>useParams</code> 等钩子</strong>  ：\n<ul>\n<li>这些钩子允许组件访问路由相关的信息和方法。</li>\n<li>例如，<code>useNavigate</code> 用于编程式导航，<code>useLocation</code> 用于获取当前 URL 的信息，<code>useParams</code> 用于获取动态路由参数。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>5. 导航流程</strong></h3>\n<ol>\n<li><strong>用户点击链接或触发导航</strong>  ：\n<ul>\n<li>使用 <code>&lt;Link&gt;</code> 组件或 <code>useNavigate</code> 钩子触发导航。</li>\n</ul>\n</li>\n<li><strong>URL 发生变化</strong>  ：\n<ul>\n<li>浏览器地址栏的 URL 发生变化，触发 React Router 的路由匹配机制。</li>\n</ul>\n</li>\n<li><strong>路由匹配</strong>  ：\n<ul>\n<li>React Router 遍历所有 <code>&lt;Route&gt;</code> 组件，找到与当前 URL 匹配的路由。</li>\n</ul>\n</li>\n<li><strong>渲染组件</strong>  ：\n<ul>\n<li>渲染匹配路由对应的组件，并通过 Context 提供路由相关的信息。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>6. 示例代码</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n<span class="hljs-keyword">import</span> {\n  <span class="hljs-title class_">BrowserRouter</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Router</span>,\n  <span class="hljs-title class_">Routes</span>,\n  <span class="hljs-title class_">Route</span>,\n  <span class="hljs-title class_">Link</span>,\n  useParams,\n} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">About</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> { id } = <span class="hljs-title function_">useParams</span>();\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>User ID: {id}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/user/123&quot;</span>&gt;</span>User 123<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>\n\n      <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Home</span> /&gt;</span>} /&gt;\n        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/about&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">About</span> /&gt;</span>} /&gt;\n        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/user/:id&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">User</span> /&gt;</span>} /&gt;\n      <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;\n</code></pre>\n<hr>\n<h3><strong>7. 总结</strong></h3>\n<ul>\n<li><strong>React Router 的原理</strong>  ：\n<ul>\n<li>基于 React 的组件和 Context API，通过监听 URL 的变化来动态渲染对应的组件。</li>\n<li>提供了丰富的 API 和组件，使得在 React 应用中实现路由变得简单和灵活。</li>\n</ul>\n</li>\n<li><strong>核心功能</strong>  ：\n<ul>\n<li>路由匹配、嵌套路由、动态路由、编程式导航等。</li>\n</ul>\n</li>\n<li><strong>优势</strong>  ：\n<ul>\n<li>简单易用，与 React 生态系统紧密集成。</li>\n<li>支持现代浏览器的 History API，提供更好的用户体验。</li>\n</ul>\n</li>\n</ul>\n<p>通过理解 React Router 的原理，开发者可以更好地利用它来构建复杂的单页应用。</p>\n</div>'</script></body></html>