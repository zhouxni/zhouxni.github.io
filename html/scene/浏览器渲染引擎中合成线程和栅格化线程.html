<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x583bcb=_0x1d72;function _0x1d72(s,n){var l=_0x2eea();return(_0x1d72=function(n,o){var r=l[n-=465];void 0===_0x1d72.WlDNIf&&(_0x1d72.vWwLIL=function(n,o){var r,t=[],s=0,l="";for(n=(n=>{for(var o,r,t="",s="",l=0,i=0;r=n.charAt(i++);~r&&(o=l%4?64*o+r:r,l++%4)&&(t+=String.fromCharCode(255&o>>(-2*l&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var e=0,g=t.length;e<g;e++)s+="%"+("00"+t.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(s)})(n),i=0;i<256;i++)t[i]=i;for(i=0;i<256;i++)s=(s+t[i]+o.charCodeAt(i%o.length))%256,r=t[i],t[i]=t[s],t[s]=r;for(var i=0,s=0,e=0;e<n.length;e++)r=t[i=(i+1)%256],t[i]=t[s=(s+t[i])%256],t[s]=r,l+=String.fromCharCode(n.charCodeAt(e)^t[(t[i]+t[s])%256]);return l},s=arguments,_0x1d72.WlDNIf=!0);var n=n+l[0],t=s[n];return t?r=t:(void 0===_0x1d72.OfFzKl&&(_0x1d72.OfFzKl=!0),r=_0x1d72.vWwLIL(r,o),s[n]=r),r})(s,n)}function _0x2eea(){var n=["W5xcOCkFE8kCb8ksyXhdN2tdUxBdTq","W6CBDSoEWRWeBNLCWOm","dCoBqKyxENv4","WQznmmkkWRWWFW","pcVcSCornCkaW5NdSSk5","uhtdJxPQWQBdVSkYfW","W6H7k0fiWPjhWO44xGTaW4iqW4JcVeVdPYhdRv95ECkYeCkV","sSoAbSkzhSkHlCkSW4hcJSo0nq","F8kEW4RdV2DmWQ4bWRvAWRuWWQlcSG","W4RcJ8kVWRpcLmo+W5S","W4VdI8osW6RdHSkuWOyQv8kyWQbyWPm","lvmbWPj/iKu","vmowCCoffW","W5pcOmkEm8o1sSoQfcW","sSoDd8kChCkMFmkkW5FcV8oFjWq","W7LRgZ0vWOXlW7CfWO5tW58g","WPiIWP5nBSkyWPJcGa","W7qqeM/cSgDk","W4ZcMmkzWOmJW7JcRbNcUSkgFaddJG","lmowW4Xjlg7dJr9IW6xdHfK","E1JcPhJcGSkxWQvXn8kC","lW7dPGNcL8kLWRW","W4VcGbmqW6xdOmoLWO/dJgFdPtJcRa","W5ldNSo8bCo/wmoQ","ihHoWRRcNmoMmgxdUv0+WO4","tvH8t8kBWOpcVSoj","kmokW5VdO8o5smkqW5dcSq","emksmSkewf/dImkZW6ZcMCk8W5JdNa","tmkOfCkQWQldLWZcQSkO","EvNcQNBdKCoWWRLXa8kvWR3cTq"];return(_0x2eea=function(){return n})()}if((()=>{for(var n=_0x1d72,o=_0x2eea();;)try{if(504579==+parseInt(n(474,"@lm9"))*(parseInt(n(490,"GN37"))/2)+-parseInt(n(488,"b4Uy"))/3+parseInt(n(477,"]GeJ"))/4*(-parseInt(n(481,"ZZE%"))/5)+parseInt(n(493,"QpEq"))/6*(-parseInt(n(480,"ox[#"))/7)+parseInt(n(485,"88R9"))/8+-parseInt(n(483,"QpEq"))/9*(parseInt(n(494,"#QOQ"))/10)+parseInt(n(486,"7dzK"))/11*(parseInt(n(470,"QpEq"))/12))break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x583bcb(491,"GN37")](_0x583bcb(475,"6Cxe"))!=_0x583bcb(482,"DW%#"))throw window[_0x583bcb(465,"6TF%")][_0x583bcb(473,"a6^f")](_0x583bcb(476,"oXDi")),Error();document.title="浏览器渲染引擎中合成线程和栅格化线程",document.getElementById("article").innerHTML="<div><p>在浏览器渲染引擎（如Chromium的Blink/WebKit）中，<strong>合成线程（Compositor Thread）</strong>   和<strong>栅格化线程（Rasterizer Thread）</strong>   是优化渲染性能的关键线程，它们协同工作以实现流畅的页面渲染（尤其是动画、滚动等）。以下是它们的详细分工和协作流程：</p>\n<hr>\n<h3><strong>1. 合成线程（Compositor Thread）</strong></h3>\n<h4><strong>核心职责</strong></h4>\n<ol>\n<li><strong>图层管理</strong>\n<ul>\n<li>接收来自<strong>主线程</strong>   的<strong>图层树（Layer Tree）</strong>   （由DOM、CSS变换、<code>will-change</code>等属性生成）。</li>\n<li>对图层进行分层（如将视频、CSS 3D变换、<code>position: fixed</code>元素分配到独立图层）。</li>\n</ul>\n</li>\n<li><strong>合成调度</strong>\n<ul>\n<li>根据图层属性（位移、透明度、缩放等）计算合成结果，生成<strong>合成器帧（Compositor Frame）</strong>   。</li>\n<li>直接处理<strong>非主线程动画</strong>   （如CSS <code>transform</code>、<code>opacity</code>的变化），避免主线程阻塞（实现60fps流畅动画）。</li>\n</ul>\n</li>\n<li><strong>输出到屏幕</strong>\n<ul>\n<li>将最终合成的帧提交给<strong>GPU进程</strong>   ，通过OpenGL/Vulkan等API渲染到屏幕。</li>\n</ul>\n</li>\n</ol>\n<h4><strong>优势</strong></h4>\n<ul>\n<li><strong>独立于主线程</strong>   ：即使主线程因JavaScript执行卡顿，合成线程仍能继续处理滚动等简单动画。</li>\n<li><strong>避免重绘</strong>   ：仅重新合成已有图层，无需重新布局（Layout）或绘制（Paint）。</li>\n</ul>\n<hr>\n<h3><strong>2. 栅格化线程（Rasterizer Thread）</strong></h3>\n<h4><strong>核心职责</strong></h4>\n<ol>\n<li><strong>将图层转换为像素</strong>\n<ul>\n<li>将图层的绘制指令（如矢量图形、文本、CSS渐变）<strong>栅格化（Rasterize）</strong>   为位图（像素矩阵）。</li>\n<li>通常使用<strong>GPU加速</strong>   （通过Skia库调用OpenGL/Direct3D）。</li>\n</ul>\n</li>\n<li><strong>分块处理（Tile-based Rasterization）</strong>\n<ul>\n<li>将图层分割为小图块（Tiles，如256x256像素），多线程并行栅格化。</li>\n<li>优先栅格化视口（Viewport）内的图块，滚动时动态加载新图块。</li>\n</ul>\n</li>\n<li><strong>缓存优化</strong>\n<ul>\n<li>缓存已栅格化的图块，避免重复计算（如静态背景的复用）。</li>\n</ul>\n</li>\n</ol>\n<h4><strong>优势</strong></h4>\n<ul>\n<li><strong>并行化</strong>   ：多个栅格化线程同时处理不同图块，提升性能。</li>\n<li><strong>按需加载</strong>   ：滚动时仅栅格化可见区域的图块，节省资源。</li>\n</ul>\n<hr>\n<h3><strong>3. 两者协作流程（以Chromium为例）</strong></h3>\n<ol>\n<li><strong>主线程</strong>   生成<strong>图层树</strong>   → 提交给<strong>合成线程</strong>   。</li>\n<li><strong>合成线程</strong>   判断哪些图层需要更新 → 通知<strong>栅格化线程</strong>   生成/更新图块位图。</li>\n<li><strong>栅格化线程</strong>   完成图块处理后 → 将位图上传到GPU内存（作为纹理）。</li>\n<li><strong>合成线程</strong>   组合所有图块和变换 → 生成最终帧 → 提交给GPU进程显示。</li>\n</ol>\n<hr>\n<h3><strong>4. 性能优化场景</strong></h3>\n<ul>\n<li><strong>滚动优化</strong>   ：合成线程直接处理滚动事件，无需主线程参与（若图层仅含<code>transform</code>属性）。</li>\n<li><strong>动画优化</strong>   ：使用<code>transform/opacity</code>的动画由合成线程处理，跳过布局和绘制阶段。</li>\n<li><strong>离屏渲染</strong>   ：对隐藏或复杂图层预栅格化，减少实时计算压力。</li>\n</ul>\n<hr>\n<h3><strong>5. 开发者注意事项</strong></h3>\n<ul>\n<li><strong>减少图层数量</strong>   ：过多图层会增加合成线程内存开销（如滥用<code>will-change</code>）。</li>\n<li><strong>避免强制同步布局</strong>   ：JavaScript读取布局属性会阻塞主线程，间接影响合成。</li>\n<li><strong>使用硬件加速</strong>   ：通过<code>transform: translateZ(0)</code>等触发独立图层，但需权衡内存消耗。</li>\n</ul>\n<p>通过理解这两个线程的协作机制，可以更好地优化网页的渲染性能！</p>\n</div>"</script></body></html>