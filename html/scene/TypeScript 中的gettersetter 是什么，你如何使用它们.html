<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5768(t,s){var e=_0x257e();return(_0x5768=function(s,n){var a=e[s-=252];void 0===_0x5768.otHdgE&&(_0x5768.PdBPSt=function(s,n){var a,l=[],t=0,e="";for(s=(s=>{for(var n,a,l="",t="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,c=l.length;r<c;r++)t+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(t)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)t=(t+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[t],l[t]=a;for(var p=0,t=0,r=0;r<s.length;r++)a=l[p=(p+1)%256],l[p]=l[t=(t+l[p])%256],l[t]=a,e+=String.fromCharCode(s.charCodeAt(r)^l[(l[p]+l[t])%256]);return e},t=arguments,_0x5768.otHdgE=!0);var s=s+e[0],l=t[s];return l?a=l:(void 0===_0x5768.jmCczo&&(_0x5768.jmCczo=!0),a=_0x5768.PdBPSt(a,n),t[s]=a),a})(t,s)}function _0x257e(){var s=["W5y9qvfPWPD3kdBcL8oIW77cPa","WO9KeqaPW4KTcq","WRHEW5LiWPv4W60","WP7dJCkSW4BdOSkXW4ZdKmk6W5FdTgeF","mCoQWR1yE8oEE8kOW6u","ESoBsryWWQiSWRm","WReAlSkNgCkuW4zAWRVdKSogfYy","WRCsitSGWQddHu3cPSkW","W63dJxNcQCkQWOxdUSobCwCTcq","W7ToBmo9tmofWPm","W5qYyCo6u8kTW5SAxW","t8oPpH7cKWNcV0dcR8k8WQyo","WQRcRMjPWQRcOWVdRmoDiCoHWPxdTGnFCSk0ACo+k8kuW6rbWRtdO1S","WRlcR2vQWQa","W5pdTCkDW6ZcLSkija","W5ZdJZtcJmkWn8kKFCoV","WPS8jmolWOpcQ8oiE8oeCa","WPWnoSoNW4qNW5ezymkZW4Hphq","WOnGsqVcKJJcHmkghSkW","W7hcV8okW4tcJmkXW6G","werRW7D0BSoPt8ogW7O6WPu1","WPCepmoOW4KJWRafAmk7W4bU","rCoPoXZcKqZdPwpcQmkpWRuWyq","WP0FW7RcI8kaB2pcH1Wuimkj","W4pcGMivaSonaHS","D8kQWRldT1tcTLRcUCkEW7r6c8oU","W6VdIN/dLCo9W6xdV8oxqq","WRembdxcHdTZW5De","ESkRWRpdSftcTf/cPSk/W61AlCoQ"];return(_0x257e=function(){return s})()}var _0x228d42=_0x5768;if((()=>{for(var s=_0x5768,n=_0x257e();;)try{if(947524==-parseInt(s(259,"zm@#"))*(-parseInt(s(280,"sd@I"))/2)+-parseInt(s(273,"3mAq"))/3+parseInt(s(258,"[M5m"))/4*(-parseInt(s(261,"rgDw"))/5)+-parseInt(s(272,"Sb!G"))/6+-parseInt(s(276,"Zja7"))/7*(parseInt(s(268,"zK6L"))/8)+parseInt(s(254,"e&EU"))/9*(parseInt(s(252,"aVJ3"))/10)+-parseInt(s(262,"vA8d"))/11*(-parseInt(s(265,"rgDw"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x228d42(275,"u4UQ")](_0x228d42(271,"#36J"))!=_0x228d42(257,"kod1"))throw window[_0x228d42(274,"3mAq")][_0x228d42(253,"73B9")](_0x228d42(256,"kod1")),Error();document.title="TypeScript 中的gettersetter 是什么，你如何使用它们",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<strong>getter 和 setter</strong>   是用于访问和修改类属性的方法。它们允许我们定义访问器（getter）和修改器（setter），以控制对类内部状态的访问和修改。通过使用 getter 和 setter，我们可以在访问或修改属性时添加额外的逻辑，如验证、计算或触发事件。</p>\n<hr>\n<h3><strong>1. 什么是 Getter 和 Setter？</strong></h3>\n<ul>\n<li><strong>Getter</strong>  ：是一个方法，用于获取属性的值。在调用时，就像访问普通属性一样，无需加括号。</li>\n<li><strong>Setter</strong>  ：是一个方法，用于设置属性的值。在调用时，就像给普通属性赋值一样，使用赋值操作符 <code>=</code>。</li>\n</ul>\n<hr>\n<h3><strong>2. 为什么使用 Getter 和 Setter？</strong></h3>\n<ul>\n<li><strong>封装性</strong>  ：隐藏属性的内部实现，只暴露必要的接口。</li>\n<li><strong>数据验证</strong>  ：在设置属性值时，可以添加验证逻辑，确保数据的合法性。</li>\n<li><strong>计算属性</strong>  ：可以动态计算属性的值，而不是存储实际值。</li>\n<li><strong>触发副作用</strong>  ：在属性被访问或修改时，执行额外的操作，如日志记录或事件触发。</li>\n</ul>\n<hr>\n<h3><strong>3. 如何定义和使用 Getter 和 Setter？</strong></h3>\n<h4><strong>基本语法</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {\n  <span class="hljs-keyword">private</span> <span class="hljs-attr">_property</span>: <span class="hljs-built_in">string</span>;\n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_property</span> = value;\n  }\n\n  <span class="hljs-comment">// Getter</span>\n  <span class="hljs-keyword">get</span> <span class="hljs-title function_">property</span>(): <span class="hljs-built_in">string</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Getting the value...&#x27;</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_property</span>;\n  }\n\n  <span class="hljs-comment">// Setter</span>\n  <span class="hljs-keyword">set</span> <span class="hljs-title function_">property</span>(<span class="hljs-params"><span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Setting the value...&#x27;</span>);\n    <span class="hljs-keyword">if</span> (value.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_property</span> = value;\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Value cannot be empty&#x27;</span>);\n    }\n  }\n}\n</code></pre>\n<h4><strong>使用示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(<span class="hljs-string">&#x27;Initial Value&#x27;</span>);\n\n<span class="hljs-comment">// 使用 getter</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">property</span>); <span class="hljs-comment">// 输出: Getting the value... Initial Value</span>\n\n<span class="hljs-comment">// 使用 setter</span>\nobj.<span class="hljs-property">property</span> = <span class="hljs-string">&#x27;New Value&#x27;</span>; <span class="hljs-comment">// 输出: Setting the value...</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">property</span>); <span class="hljs-comment">// 输出: Getting the value... New Value</span>\n\n<span class="hljs-comment">// 尝试设置无效值</span>\nobj.<span class="hljs-property">property</span> = <span class="hljs-string">&#x27;&#x27;</span>; <span class="hljs-comment">// 输出: Setting the value... Value cannot be empty</span>\n</code></pre>\n<hr>\n<h3><strong>4. Getter 和 Setter 的特点</strong></h3>\n<ul>\n<li><strong>访问控制</strong>  ：通过将属性设为 <code>private</code> 或 <code>protected</code>，并使用 getter 和 setter 控制访问，实现封装。</li>\n<li><strong>只读属性</strong>  ：可以只定义 getter 而不定义 setter，使属性成为只读。</li>\n<li><strong>只写属性</strong>  ：可以只定义 setter 而不定义 getter，但这种情况较少见。</li>\n</ul>\n<h4><strong>只读属性示例</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> {\n  <span class="hljs-keyword">private</span> <span class="hljs-attr">_radius</span>: <span class="hljs-built_in">number</span>;\n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">radius</span>: <span class="hljs-built_in">number</span></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_radius</span> = radius;\n  }\n\n  <span class="hljs-keyword">get</span> <span class="hljs-title function_">radius</span>(): <span class="hljs-built_in">number</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_radius</span>;\n  }\n\n  <span class="hljs-comment">// 没有 setter，radius 是只读属性</span>\n}\n\n<span class="hljs-keyword">const</span> circle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">5</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(circle.<span class="hljs-property">radius</span>); <span class="hljs-comment">// 输出: 5</span>\n<span class="hljs-comment">// circle.radius = 10; // 错误: 属性“radius”为只读属性</span>\n</code></pre>\n<hr>\n<h3><strong>5. 使用 Getter 和 Setter 的最佳实践</strong></h3>\n<ul>\n<li><strong>保持简单</strong>  ：getter 和 setter 应该尽量简单，避免复杂的逻辑。复杂的逻辑可以封装在其他方法中。</li>\n<li><strong>避免过度使用</strong>  ：不要为每个属性都定义 getter 和 setter，只有在需要时才使用。</li>\n<li><strong>文档注释</strong>  ：为 getter 和 setter 添加注释，说明其用途和行为，特别是当它们包含特殊逻辑时。</li>\n<li><strong>一致性</strong>  ：如果一个属性有 getter，通常也应该有 setter（除非是有意设计为只读）。</li>\n</ul>\n<hr>\n<h3><strong>6. 与普通属性的对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>普通属性</strong></th>\n<th><strong>Getter/Setter</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>访问方式</strong></td>\n<td>直接访问和修改</td>\n<td>通过方法访问和修改</td>\n</tr>\n<tr>\n<td><strong>封装性</strong></td>\n<td>较低，属性是公开的</td>\n<td>较高，可以隐藏内部实现</td>\n</tr>\n<tr>\n<td><strong>数据验证</strong></td>\n<td>需要在外部进行</td>\n<td>可以在 setter 中进行</td>\n</tr>\n<tr>\n<td><strong>计算属性</strong></td>\n<td>不支持</td>\n<td>支持，可以动态计算值</td>\n</tr>\n<tr>\n<td><strong>触发副作用</strong></td>\n<td>不支持</td>\n<td>支持，可以在访问或修改时执行操作</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>7. 实际应用场景</strong></h3>\n<h4><strong>数据验证</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {\n  <span class="hljs-keyword">private</span> <span class="hljs-attr">_age</span>: <span class="hljs-built_in">number</span>;\n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_age</span> = age;\n  }\n\n  <span class="hljs-keyword">get</span> <span class="hljs-title function_">age</span>(): <span class="hljs-built_in">number</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_age</span>;\n  }\n\n  <span class="hljs-keyword">set</span> <span class="hljs-title function_">age</span>(<span class="hljs-params"><span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span></span>) {\n    <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">0</span> &amp;&amp; value &lt;= <span class="hljs-number">120</span>) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_age</span> = value;\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Invalid age value&#x27;</span>);\n    }\n  }\n}\n\n<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">25</span>);\nuser.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>; <span class="hljs-comment">// 合法</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">age</span>); <span class="hljs-comment">// 输出: 30</span>\nuser.<span class="hljs-property">age</span> = -<span class="hljs-number">5</span>; <span class="hljs-comment">// 输出: Invalid age value</span>\n</code></pre>\n<h4><strong>计算属性</strong></h4>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> {\n  <span class="hljs-keyword">private</span> <span class="hljs-attr">_width</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-keyword">private</span> <span class="hljs-attr">_height</span>: <span class="hljs-built_in">number</span>;\n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_width</span> = width;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_height</span> = height;\n  }\n\n  <span class="hljs-keyword">get</span> <span class="hljs-title function_">area</span>(): <span class="hljs-built_in">number</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_width</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">_height</span>;\n  }\n}\n\n<span class="hljs-keyword">const</span> rect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rect.<span class="hljs-property">area</span>); <span class="hljs-comment">// 输出: 50</span>\n</code></pre>\n<hr>\n<h3><strong>8. 总结</strong></h3>\n<ul>\n<li><strong>Getter 和 Setter</strong>   是 TypeScript 中用于访问和修改类属性的方法，提供了对属性的封装和控制。</li>\n<li><strong>使用场景</strong>   包括数据验证、计算属性和触发副作用等。</li>\n<li><strong>最佳实践</strong>   是保持简单、避免过度使用，并在需要时添加文档注释。</li>\n</ul>\n<p><strong>通过合理使用 getter 和 setter，可以提高代码的封装性、可维护性和安全性。</strong></p>\n</div>'</script></body></html>