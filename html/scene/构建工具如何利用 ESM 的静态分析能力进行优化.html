<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4cc23c=_0x2f18;function _0x2710(){var s=["wmoVWPJdTdxcGCkthMZcMhxdKZm","iCoTwfj/EWVdKM8RrYu","W748W7XtiSolaJ7dLHD1","FCocWRZdGSk6lSkkW45GW7tcKYq","WPvUW4dcI8odWOZcI0qvW4jNW6tdIG","W6u8WPpdMCkjW4VdUgK7","WQPprJHnWRBcRLjtWQassq","kCo1ndFcOmoVu1LcW6TFnty","bCoPWOahmZ/cImkGoG","WO5FWQpcQmofi8kzW69XyufN","W7THWOKjE8oQlW","kupcTSknwSkwsmoSjmoOd8oUW7G","WQNcPKRcIvlcK1y","tmkWwbddVCkXWPq","FCogWRNcTSoJwmkpW5jU","WPlcJ8ougSk/dSkId8kPWRFcJtO","l1pdM0xcRSohWQe","A8kJq0ZcISkiC1mEW5dcRq","WOqqW77dSSk9w8kt","jmoOuffYEctdOh80BrO","WPugF1u7W7mo","W4bxmIL2WQefr8kydSkada","WQPCjSkDW53cKmknevxcS8o2WQS","W4ddQNtdK8ka","pdmeWPD/sG/cQq","FSkOhrq4Dw3cUgmgzr8JW5TIW49GW6ycW4JcIComWPxdJSkKEG"];return(_0x2710=function(){return s})()}function _0x2f18(o,s){var t=_0x2710();return(_0x2f18=function(s,n){var a=t[s-=408];void 0===_0x2f18.VBLaZj&&(_0x2f18.ANrrZa=function(s,n){var a,l=[],o=0,t="";for(s=(s=>{for(var n,a,l="",o="",t=0,c=0;a=s.charAt(c++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,e=l.length;p<e;p++)o+="%"+("00"+l.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(o)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)o=(o+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[o],l[o]=a;for(var c=0,o=0,p=0;p<s.length;p++)a=l[c=(c+1)%256],l[c]=l[o=(o+l[c])%256],l[o]=a,t+=String.fromCharCode(s.charCodeAt(p)^l[(l[c]+l[o])%256]);return t},o=arguments,_0x2f18.VBLaZj=!0);var s=s+t[0],l=o[s];return l?a=l:(void 0===_0x2f18.ttExhW&&(_0x2f18.ttExhW=!0),a=_0x2f18.ANrrZa(a,n),o[s]=a),a})(o,s)}if((()=>{for(var s=_0x2f18,n=_0x2710();;)try{if(213227==-parseInt(s(408,"T]W%"))*(parseInt(s(420,"kid9"))/2)+-parseInt(s(418,"$Hzk"))/3+-parseInt(s(424,"&a$p"))/4+-parseInt(s(433,"UN1h"))/5+-parseInt(s(430,"YvP0"))/6*(-parseInt(s(429,"0@Ix"))/7)+-parseInt(s(427,"RtcQ"))/8+parseInt(s(413,"lZ)l"))/9*(parseInt(s(432,"YxMd"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x4cc23c(412,"lZ)l")](_0x4cc23c(423,"6OYS"))!=_0x4cc23c(415,"jvTi"))throw window[_0x4cc23c(416,"OKrk")][_0x4cc23c(431,"!cnQ")](_0x4cc23c(417,"m&!K")),Error();document.title="构建工具如何利用 ESM 的静态分析能力进行优化",document.getElementById("article").innerHTML='<div><h3><strong>构建工具如何利用 ESM 的静态分析能力进行优化？</strong></h3>\n<p>ESM（ES Modules，即 <code>import/export</code> 语法）的关键特性是<strong>静态可分析性</strong>   ，这使得构建工具（如 Webpack、Rollup、Vite、Parcel）能够在编译阶段分析代码依赖关系，并实现以下优化：</p>\n<hr>\n<h2><strong>1. ESM 的静态分析能力</strong></h2>\n<p>ESM 的 <code>import/export</code> 语句必须<strong>在模块顶层</strong>   （不能动态生成），这使得构建工具可以：</p>\n<ul>\n<li><strong>在打包前解析所有依赖关系</strong>   （构建依赖图）。</li>\n<li><strong>确定哪些导出被使用，哪些未被使用</strong>   （Tree Shaking）。</li>\n<li><strong>优化代码加载顺序</strong>   （如并行加载、按需加载）。</li>\n</ul>\n<h4><strong>对比 CommonJS（动态分析）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// CommonJS（动态引入，无法静态分析）</span>\n<span class="hljs-keyword">const</span> lib = condition ? <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;libA&quot;</span>) : <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;libB&quot;</span>); <span class="hljs-comment">// 运行时才能确定</span>\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-comment">// ESM（静态引入，可分析）</span>\n<span class="hljs-keyword">import</span> libA <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;libA&quot;</span>; <span class="hljs-comment">// 构建时即可解析</span>\n<span class="hljs-keyword">import</span> libB <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;libB&quot;</span>; <span class="hljs-comment">// 即使未使用，也能检测到</span>\n</code></pre>\n<hr>\n<h2><strong>2. 构建工具如何利用 ESM 静态分析？</strong></h2>\n<h3><strong>(1) 依赖图（Dependency Graph）分析</strong></h3>\n<ul>\n<li><strong>步骤</strong>   ：\n<ol>\n<li>从入口文件（如 <code>main.js</code>）开始，递归解析所有 <code>import</code> 语句。</li>\n<li>生成完整的依赖关系图（类似一棵树）。</li>\n<li>根据依赖关系决定打包策略（如代码分割、懒加载）。</li>\n</ol>\n</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-comment">// main.js</span>\n<span class="hljs-keyword">import</span> { funcA } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./moduleA.js&quot;</span>; <span class="hljs-comment">// 构建工具会找到 moduleA.js</span>\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-comment">// moduleA.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">funcA</span>(<span class="hljs-params"></span>) {} <span class="hljs-comment">// 被使用，保留</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">funcB</span>(<span class="hljs-params"></span>) {} <span class="hljs-comment">// 未使用，Tree Shaking 移除</span>\n</code></pre>\n</li>\n</ul>\n<h3><strong>(2) Tree Shaking（摇树优化）</strong></h3>\n<ul>\n<li><strong>原理</strong>   ：\n<ul>\n<li>通过静态分析，标记未被使用的 <code>export</code>。</li>\n<li>在最终打包时移除未被引用的代码。</li>\n</ul>\n</li>\n<li><strong>触发条件</strong>   ：\n<ul>\n<li>代码必须是 ESM（<code>import/export</code>）。</li>\n<li><code>package.json</code> 中 <code>&quot;sideEffects&quot;: false</code>（或明确声明副作用文件）。</li>\n</ul>\n</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-comment">// utils.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">used</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;used&quot;</span>);\n}\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">unused</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;unused&quot;</span>);\n} <span class="hljs-comment">// 会被移除</span>\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-comment">// main.js</span>\n<span class="hljs-keyword">import</span> { used } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./utils.js&quot;</span>;\n<span class="hljs-title function_">used</span>();\n</code></pre>\n<strong>输出</strong>   ：<code>unused()</code> 不会出现在最终打包文件中。</li>\n</ul>\n<h3><strong>(3) Scope Hoisting（作用域提升）</strong></h3>\n<ul>\n<li><strong>原理</strong>   ：\n<ul>\n<li>将模块的代码“内联”到调用处，减少闭包和函数包装。</li>\n<li>减少代码体积，提升运行效率。</li>\n</ul>\n</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-comment">// 打包前（多个模块）</span>\n<span class="hljs-keyword">import</span> { a } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./moduleA.js&quot;</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-comment">// 打包后（Scope Hoisting 优化）</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 直接内联，移除模块包装</span>\n</code></pre>\n</li>\n</ul>\n<h3><strong>(4) 按需加载（Dynamic Import + Code Splitting）</strong></h3>\n<ul>\n<li><strong>原理</strong>   ：\n<ul>\n<li>通过动态 <code>import()</code> 拆分代码，实现懒加载。</li>\n<li>依赖静态分析确定拆分点。</li>\n</ul>\n</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-comment">// 动态加载（构建工具会单独打包 lodash）</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">loadLodash</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">const</span> { debounce } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;lodash-es&quot;</span>);\n  <span class="hljs-title function_">debounce</span>(<span class="hljs-function">() =&gt;</span> {}, <span class="hljs-number">300</span>);\n};\n</code></pre>\n<strong>输出</strong>   ：<code>lodash-es</code> 会被拆分成单独的 chunk（如 <code>lodash.hash.js</code>）。</li>\n</ul>\n<hr>\n<h2><strong>3. 构建工具的具体实现</strong></h2>\n<table>\n<thead>\n<tr>\n<th><strong>工具</strong></th>\n<th><strong>ESM 静态分析优化</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Webpack</strong></td>\n<td>- 基于 <code>acorn</code> 解析 ESM，生成依赖图。<br>- 通过 <code>TerserPlugin</code> 实现 Tree Shaking。</td>\n</tr>\n<tr>\n<td><strong>Rollup</strong></td>\n<td>- 专为 ESM 设计，默认支持 Tree Shaking 和 Scope Hoisting。<br>- 输出更干净的 ESM 包。</td>\n</tr>\n<tr>\n<td><strong>Vite</strong></td>\n<td>- 基于 Rollup 生产环境打包，继承 ESM 优化能力。<br>- 开发时用原生 ESM 加载，无需打包。</td>\n</tr>\n<tr>\n<td><strong>Parcel</strong></td>\n<td>- 自动检测 ESM，默认启用 Tree Shaking。<br>- 零配置，但灵活性较低。</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>4. 如何确保 ESM 静态分析生效？</strong></h2>\n<h3><strong>(1) 使用纯 ESM 写法</strong></h3>\n<ul>\n<li>\n<p>避免动态 <code>import</code>（除非必要）：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// ✅ 静态分析友好</span>\n<span class="hljs-keyword">import</span> { funcA } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;libA&quot;</span>;\n\n<span class="hljs-comment">// ❌ 无法静态分析（慎用）</span>\n<span class="hljs-keyword">const</span> lib = condition ? <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;libA&quot;</span>) : <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;libB&quot;</span>);\n</code></pre>\n</li>\n</ul>\n<h3><strong>(2) 配置 <code>sideEffects</code></strong></h3>\n<ul>\n<li>在 <code>package.json</code> 中声明无副作用的模块：<pre><code class="language-json"><span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;sideEffects&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span> <span class="hljs-comment">// 所有文件均可 Tree Shaking</span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n或指定有副作用的文件（如 CSS、全局 JS）：<pre><code class="language-json"><span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;sideEffects&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;**/*.css&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;**    /*.global.js&quot;</span><span class="hljs-punctuation">]</span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n</li>\n</ul>\n<h3><strong>(3) 避免破坏静态分析的写法</strong></h3>\n<ul>\n<li>\n<p><strong>避免顶层副作用</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// ❌ 打包工具无法移除这段代码</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This will always run!&quot;</span>);\n\n<span class="hljs-comment">// ✅ 改为函数封装</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Run only when called&quot;</span>);\n}\n</code></pre>\n</li>\n</ul>\n<h3><strong>(4) 检查 Babel 配置</strong></h3>\n<ul>\n<li>确保 Babel 不将 ESM 转成 CommonJS：<pre><code class="language-javascript"><span class="hljs-comment">// .babelrc</span>\n{\n  <span class="hljs-string">&quot;presets&quot;</span>: [\n    [<span class="hljs-string">&quot;@babel/preset-env&quot;</span>, { <span class="hljs-string">&quot;modules&quot;</span>: <span class="hljs-literal">false</span> }]  <span class="hljs-comment">// 保留 ESM</span>\n  ]\n}\n</code></pre>\n</li>\n</ul>\n<hr>\n<h2><strong>5. 测试静态分析是否生效</strong></h2>\n<ul>\n<li><strong>方法 1</strong>   ：运行生产构建，观察未使用的代码是否被移除。<pre><code class="language-bash">npm run build  <span class="hljs-comment"># Webpack/Vite/Rollup</span>\n</code></pre>\n</li>\n<li><strong>方法 2</strong>   ：使用打包分析工具（如 <code>webpack-bundle-analyzer</code>）查看输出。</li>\n<li><strong>方法 3</strong>   ：检查最终打包文件中是否存在未引用的导出。</li>\n</ul>\n<hr>\n<h2><strong>总结</strong></h2>\n<ol>\n<li><strong>ESM 的静态分析能力</strong>   是构建工具优化的核心，支持 Tree Shaking、Scope Hoisting、Code Splitting 等。</li>\n<li><strong>构建工具</strong>   （Webpack/Rollup/Vite）通过解析 <code>import/export</code> 生成依赖图，并移除无用代码。</li>\n<li><strong>确保优化生效</strong>   ：使用纯 ESM、配置 <code>sideEffects</code>、避免副作用代码、检查 Babel 配置。</li>\n<li><strong>测试方法</strong>   ：生产构建 + 打包分析工具验证。</li>\n</ol>\n<p>通过合理利用 ESM 的静态分析，可以显著减少打包体积，提升应用性能！</p>\n</div>'</script></body></html>