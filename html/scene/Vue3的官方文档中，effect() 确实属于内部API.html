<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5cf6(c,s){var t=_0xfbf4();return(_0x5cf6=function(s,n){var e=t[s-=152];void 0===_0x5cf6.PbAQIq&&(_0x5cf6.SDTGjn=function(s,n){var e,a=[],c=0,t="";for(s=(s=>{for(var n,e,a="",c="",t=0,o=0;e=s.charAt(o++);~e&&(n=t%4?64*n+e:e,t++%4)&&(a+=String.fromCharCode(255&n>>(-2*t&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var l=0,p=a.length;l<p;l++)c+="%"+("00"+a.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(c)})(s),o=0;o<256;o++)a[o]=o;for(o=0;o<256;o++)c=(c+a[o]+n.charCodeAt(o%n.length))%256,e=a[o],a[o]=a[c],a[c]=e;for(var o=0,c=0,l=0;l<s.length;l++)e=a[o=(o+1)%256],a[o]=a[c=(c+a[o])%256],a[c]=e,t+=String.fromCharCode(s.charCodeAt(l)^a[(a[o]+a[c])%256]);return t},c=arguments,_0x5cf6.PbAQIq=!0);var s=s+t[0],a=c[s];return a?e=a:(void 0===_0x5cf6.jtACiT&&(_0x5cf6.jtACiT=!0),e=_0x5cf6.SDTGjn(e,n),c[s]=e),e})(c,s)}var _0x246eaa=_0x5cf6;if((()=>{for(var s=_0x5cf6,n=_0xfbf4();;)try{if(210509==+parseInt(s(173,"^Abb"))*(-parseInt(s(153,"7IKo"))/2)+parseInt(s(165,"Jn%a"))/3*(-parseInt(s(167,"SaGC"))/4)+-parseInt(s(172,"v$Rn"))/5+-parseInt(s(159,"w&7U"))/6+-parseInt(s(154,"aSRi"))/7*(parseInt(s(175,"EnHY"))/8)+-parseInt(s(177,"EnHY"))/9+parseInt(s(176,"2%nT"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x246eaa(166,"^Uka")](_0x246eaa(164,"()gO"))!=_0x246eaa(171,"BS@I"))throw window[_0x246eaa(162,"6@!w")][_0x246eaa(163,"2%nT")](_0x246eaa(158,"0e#]")),Error();function _0xfbf4(){var s=["dtjvpSkR","WOdcSLyzWRbJWPSNW5tdMCkWWR4","ySkaW7KOW6ZdPCkpWPpdRauoW4a","CK/dGu7cJCkJmLFdUYiEWPK","ASooWOKheCkSv2dcIHlcT8kE","eblcRNBcPmoDw8kDkXZdVCkjW5lcPa","ASoiWOeggCkQChlcNqNcP8kZ","dc15WRtdGmo8W5VdGCoqjSk8W5q","W5vRWQtdLY5ksG","WO/dUZbVW5RdGhHx","W7ldUsSgD8ojbSo/p8kUqZm","WOmmWONdL14lW50XAWVdUSkmW5dcKa","WQ8JW67cS8oaWR7cGG","W6L2fCoTW7iEe8kbW7vUtrFdKdlcTConqH8IWQ/dLYldVvetuq","C03dGK7cHSkLAwhdPqyJWP4Q","W7pdVsSlDSomlCobcSklqdi","tSoOn8k9W4hcJK1RW5pcJ8o1jq","WP1psKVcULFcOCo3","u0hdQc3dSSkhdW","W4GvBCoGwcJdUZW5","E8k3eflcO8ouk8kmdXi3WPe","W5GWWPDEysJdOW","deTBkmouW6Dx","ESk/tstdO8kZa8kF","W4nqAeNcJhdcJW","W5uOW5tcGf83m8kVWRXeWRFdSmkv"];return(_0xfbf4=function(){return s})()}document.title="Vue3的官方文档中，effect() 确实属于内部API",document.getElementById("article").innerHTML='<div><p>在Vue3的官方文档中，<code>effect()</code> 确实属于<strong>内部API</strong>  ，并未作为公开接口推荐给开发者直接使用。这是因为它是Vue3响应式系统的底层实现原语，主要用于框架内部逻辑（如渲染函数、计算属性、watch等）的实现，而非面向应用层的开发接口。以下是详细说明：</p>\n<h3><strong>1. 为什么官网没有 <code>effect()</code>？</strong></h3>\n<ul>\n<li><strong>设计定位</strong>  ：<code>effect()</code> 是Vue3响应式系统的底层机制，类似于Vue2中的 <code>Watcher</code> 构造函数。这类API主要用于框架内部逻辑，而非直接提供给开发者使用。</li>\n<li><strong>稳定性考虑</strong>  ：底层API的实现可能随版本迭代调整，直接使用可能导致代码在后续版本中失效。</li>\n<li><strong>上层封装</strong>  ：Vue3提供了更易用的上层API（如 <code>watchEffect</code>、<code>computed</code>、组件渲染等），这些API已基于 <code>effect()</code> 封装，满足大多数开发需求。</li>\n</ul>\n<h3><strong>2. 哪些场景会用到 <code>effect()</code>？</strong></h3>\n<p>虽然官方不推荐直接使用，但在以下特殊场景中可能会接触到：</p>\n<ul>\n<li><strong>自定义响应式工具</strong>  ：开发Vue3插件或库时，可能需要通过 <code>effect()</code> 实现自定义响应式逻辑。</li>\n<li><strong>源码学习</strong>  ：理解Vue3响应式系统的核心原理时，需要分析 <code>effect()</code> 的工作机制。</li>\n</ul>\n<h3><strong>3. 替代方案：使用上层封装API</strong></h3>\n<p>Vue3提供了更安全、更易用的上层API，覆盖 <code>effect()</code> 的常见使用场景：</p>\n<h4><strong>（1）自动追踪依赖的副作用：<code>watchEffect</code></strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { watchEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;\n\n<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n\n<span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Count: <span class="hljs-subst">${count.value}</span>`</span>); <span class="hljs-comment">// 自动追踪 count.value</span>\n});\n</code></pre>\n<h4><strong>（2）带缓存的计算属性：<code>computed</code></strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { ref, computed } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;\n\n<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n<span class="hljs-keyword">const</span> doubleCount = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span> * <span class="hljs-number">2</span>);\n</code></pre>\n<h4><strong>（3）自定义依赖监听：<code>watch</code></strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { ref, watch } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;\n\n<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n<span class="hljs-keyword">const</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Vue&#x27;</span>);\n\n<span class="hljs-title function_">watch</span>(\n  [count, name], <span class="hljs-comment">// 手动指定依赖</span>\n  <span class="hljs-function">(<span class="hljs-params">[newCount, newName]</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Count: <span class="hljs-subst">${newCount}</span>, Name: <span class="hljs-subst">${newName}</span>`</span>);\n  }\n);\n</code></pre>\n<h3><strong>4. 底层实现：<code>effect()</code> 与上层API的关系</strong></h3>\n<p>Vue3的上层响应式API本质上是 <code>effect()</code> 的封装：</p>\n<ul>\n<li><code>watchEffect</code> = <code>effect()</code> + 自动停止（组件卸载时）</li>\n<li><code>computed</code> = <code>effect()</code> + 缓存机制 + 懒执行</li>\n<li>组件渲染函数 = <code>effect()</code> + 虚拟DOM更新逻辑</li>\n</ul>\n<p>以 <code>watchEffect</code> 为例，其简化实现如下：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">watchEffect</span>(<span class="hljs-params">effectFn</span>) {\n  <span class="hljs-comment">// 创建 effect 并返回停止函数</span>\n  <span class="hljs-keyword">const</span> effect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactiveEffect</span>(effectFn);\n  \n  <span class="hljs-comment">// 组件卸载时自动停止 effect</span>\n  <span class="hljs-title function_">onUnmounted</span>(effect.<span class="hljs-property">stop</span>);\n  \n  <span class="hljs-comment">// 立即执行一次</span>\n  effect.<span class="hljs-title function_">run</span>();\n  \n  <span class="hljs-keyword">return</span> effect.<span class="hljs-property">stop</span>;\n}\n</code></pre>\n<h3><strong>5. 注意：直接使用 <code>effect()</code> 的风险</strong></h3>\n<ul>\n<li><strong>版本兼容性</strong>  ：Vue3的底层API可能在未来版本中调整（如参数、返回值等）。</li>\n<li><strong>内存泄漏</strong>  ：未正确调用 <code>stop()</code> 会导致 effect 持续监听，消耗内存。</li>\n<li><strong>调试困难</strong>  ：底层API缺乏上层API的错误处理和调试信息。</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<p><code>effect()</code> 是Vue3响应式系统的底层实现，官网不推荐应用层开发者直接使用。在实际开发中，应优先使用 <code>watchEffect</code>、<code>computed</code>、<code>watch</code> 等上层API，它们更安全、易用且符合官方推荐的开发模式。若需深入理解响应式原理，可通过阅读Vue3源码（如 <code>@vue/reactivity</code> 包）研究 <code>effect()</code> 的实现逻辑。</p>\n</div>'</script></body></html>