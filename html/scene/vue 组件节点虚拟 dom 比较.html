<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0xb574e8=_0xf0b7;function _0xf0b7(a,n){var e=_0xbb1a();return(_0xf0b7=function(n,s){var o=e[n-=475];void 0===_0xf0b7.RyxFhI&&(_0xf0b7.bHrhJR=function(n,s){var o,t=[],a=0,e="";for(n=(n=>{for(var s,o,t="",a="",e=0,r=0;o=n.charAt(r++);~o&&(s=e%4?64*s+o:o,e++%4)&&(t+=String.fromCharCode(255&s>>(-2*e&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var c=0,p=t.length;c<p;c++)a+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(a)})(n),r=0;r<256;r++)t[r]=r;for(r=0;r<256;r++)a=(a+t[r]+s.charCodeAt(r%s.length))%256,o=t[r],t[r]=t[a],t[a]=o;for(var r=0,a=0,c=0;c<n.length;c++)o=t[r=(r+1)%256],t[r]=t[a=(a+t[r])%256],t[a]=o,e+=String.fromCharCode(n.charCodeAt(c)^t[(t[r]+t[a])%256]);return e},a=arguments,_0xf0b7.RyxFhI=!0);var n=n+e[0],t=a[n];return t?o=t:(void 0===_0xf0b7.xrAmTf&&(_0xf0b7.xrAmTf=!0),o=_0xf0b7.bHrhJR(o,s),a[n]=o),o})(a,n)}if((()=>{for(var n=_0xf0b7,s=_0xbb1a();;)try{if(433392==+parseInt(n(485,"9^vn"))+parseInt(n(487,"0Wl4"))/2+-parseInt(n(475,"JOhG"))/3*(-parseInt(n(479,"mIgQ"))/4)+-parseInt(n(494,"E2c@"))/5+parseInt(n(496,"9^vn"))/6*(parseInt(n(491,"7sC8"))/7)+-parseInt(n(492,"GnB4"))/8+-parseInt(n(497,"GnB4"))/9)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0xb574e8(486,"2$l^")](_0xb574e8(483,"DQKk"))!=_0xb574e8(484,"ifMh"))throw window[_0xb574e8(481,"Vza@")][_0xb574e8(490,"ifMh")](_0xb574e8(476,"7sC8")),Error();function _0xbb1a(){var n=["bCo7v1G/mYxdKmoPb0JcJHW","c3/dJCkUmCkDkYCeWROFFxm","iSohxH3dG8kWn8o5W4RdN8oGWPpdPW","WRFdVCkifCkvEJyln8o9gH7dHa","aHRdI8oTdYa2WQy","s8kVjSoFW7CximoW","c37dH8kKmCkAktGYWQqXreG","WRtcH8kBWP4RWRxdUq9RWOlcLMtcHW","ueHoW5NcKtpcRColW7FdSG","xmk3frX4mdpcP8ocjgxcKIZcQSkCaYJcUCoYsM0bcSo3WOlcOW","c3BdICkOm8kxidKSWOultei","ch3dImkLmSkEBa8vWQeeAW","W4hcL2iuW7vabsPVmq","FmkvxSkEzavxWOFdHSoD","W6NcNSkUCv8Ap3K","W6VcQ8kkWPVdN8kEks5EWPG","c8oFbeKNWPldGW/dMa","iSoBhmkZsG","sCkVrmkAWQXqaCoqsMldISka","nSk9m8ogm2VdSW","W6JcQCkmWPdcNCowlXLvWOysaq","kCkyW5ZdVCoCWORdQ8kOhmkekCoX","pmoNwX7dMg7dQSkwu2FcSu3dJW","imolh8kSuGGz"];return(_0xbb1a=function(){return n})()}document.title="vue 组件节点虚拟 dom 比较",document.getElementById("article").innerHTML='<div><p>在 Vue 的虚拟 DOM 比较（diff）过程中，遇到<strong>组件节点</strong>   （VNode 表示的是组件）时，处理逻辑与普通 DOM 元素节点不同，核心目标是<strong>高效判断是否需要更新组件</strong>   ，而不是直接操作 DOM。以下是关键步骤和细节：</p>\n<hr>\n<h3>1. <strong>组件节点的比较流程</strong></h3>\n<p>当新旧 VNode 都是组件节点（<code>vnode.componentOptions</code> 存在）时，Vue 会执行以下步骤：</p>\n<h4><strong>步骤 1：判断是否为相同组件</strong></h4>\n<p>通过比较组件的<strong>构造函数</strong>   （<code>Ctor</code>）和<strong>关键属性</strong>   （如 <code>tag</code>、<code>key</code>）：</p>\n<pre><code class="language-js"><span class="hljs-comment">// 伪代码</span>\n<span class="hljs-keyword">if</span> (oldVNode.<span class="hljs-property">tag</span> === newVNode.<span class="hljs-property">tag</span> &amp;&amp; oldVNode.<span class="hljs-property">key</span> === newVNode.<span class="hljs-property">key</span>) {\n  <span class="hljs-comment">// 是相同组件</span>\n} <span class="hljs-keyword">else</span> {\n  <span class="hljs-comment">// 销毁旧组件，创建新组件</span>\n}\n</code></pre>\n<ul>\n<li><strong>相同组件</strong>   ：复用组件实例，进入下一步更新。</li>\n<li><strong>不同组件</strong>   ：销毁旧组件（调用 <code>destroy</code> 钩子），重新挂载新组件（调用 <code>create</code> 钩子）。</li>\n</ul>\n<h4><strong>步骤 2：更新组件实例</strong></h4>\n<p>如果组件相同，Vue 不会销毁重建，而是<strong>复用组件实例</strong>   ，通过 <code>vnode.componentInstance</code> 获取实例，并触发其更新：</p>\n<ul>\n<li><strong>触发 <code>prepatch</code> 钩子</strong>   ：在组件实例上调用 <code>prepatch</code> 钩子（如 <code>beforeUpdate</code>）。</li>\n<li><strong>更新 <code>props/events/slots</code></strong>   ：将新 VNode 的 <code>props</code>、<code>events</code>、<code>children</code>（插槽）传递给组件实例，触发组件的响应式更新。</li>\n<li><strong>触发组件自身的更新</strong>   ：组件内部会重新渲染，生成新的子 VNode 树，并递归执行 diff。</li>\n</ul>\n<h4><strong>步骤 3：跳过子节点比较</strong></h4>\n<p>组件节点的子节点（<code>children</code>）是<strong>插槽内容</strong>   ，由组件自身管理。在 diff 过程中，<strong>不会直接比较组件的子节点</strong>   ，而是交由组件的渲染函数重新生成子 VNode 后，再对子树进行 diff。</p>\n<hr>\n<h3>2. <strong>与普通 DOM 节点的区别</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>对比维度</strong></th>\n<th><strong>组件节点</strong></th>\n<th><strong>普通 DOM 节点</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>比较目标</strong></td>\n<td>复用组件实例，更新内部状态</td>\n<td>复用 DOM 元素，更新属性/子节点</td>\n</tr>\n<tr>\n<td><strong>子节点处理</strong></td>\n<td>子节点是插槽，由组件内部管理</td>\n<td>直接比较子节点（diff 子树）</td>\n</tr>\n<tr>\n<td><strong>销毁逻辑</strong></td>\n<td>调用组件的 <code>beforeDestroy</code>/<code>destroy</code></td>\n<td>直接移除 DOM 元素</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>3. <strong>示例代码</strong></h3>\n<pre><code class="language-js"><span class="hljs-comment">// 旧 VNode：组件节点</span>\n<span class="hljs-keyword">const</span> oldVNode = {\n  <span class="hljs-attr">tag</span>: <span class="hljs-string">&quot;my-component&quot;</span>,\n  <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;a&quot;</span>,\n  <span class="hljs-attr">componentOptions</span>: { <span class="hljs-title class_">Ctor</span>: <span class="hljs-title class_">MyComponent</span>, <span class="hljs-attr">propsData</span>: { <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;hello&quot;</span> } },\n  <span class="hljs-attr">componentInstance</span>: myComponentInstance, <span class="hljs-comment">// 已挂载的实例</span>\n};\n\n<span class="hljs-comment">// 新 VNode：同组件，不同 props</span>\n<span class="hljs-keyword">const</span> newVNode = {\n  <span class="hljs-attr">tag</span>: <span class="hljs-string">&quot;my-component&quot;</span>,\n  <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;a&quot;</span>,\n  <span class="hljs-attr">componentOptions</span>: { <span class="hljs-title class_">Ctor</span>: <span class="hljs-title class_">MyComponent</span>, <span class="hljs-attr">propsData</span>: { <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;world&quot;</span> } },\n};\n\n<span class="hljs-comment">// diff 过程：</span>\n<span class="hljs-comment">// 1. 判断 tag 和 key 相同，复用实例</span>\n<span class="hljs-comment">// 2. 更新 props（msg 从 &#x27;hello&#x27; -&gt; &#x27;world&#x27;），触发组件重新渲染</span>\n<span class="hljs-comment">// 3. 组件内部生成新的子 VNode，再 diff 子树</span>\n</code></pre>\n<hr>\n<h3>4. <strong>性能优化点</strong></h3>\n<ul>\n<li><strong>key 的作用</strong>   ：组件节点的 <code>key</code> 会强制判断是否复用实例。改变 <code>key</code> 会触发组件销毁重建（如 <code>&lt;component :is=&quot;type&quot; :key=&quot;type&quot; /&gt;</code>）。</li>\n<li><strong>函数式组件</strong>   ：无状态的函数式组件没有实例，比较过程更简单（直接渲染子 VNode）。</li>\n</ul>\n<hr>\n<p>总结：Vue 对组件节点的 diff 核心是通过<strong>构造函数和 key 判断实例是否复用</strong>   ，然后依赖组件自身的响应式系统更新，而非直接操作 DOM 或子节点。</p>\n</div>'</script></body></html>