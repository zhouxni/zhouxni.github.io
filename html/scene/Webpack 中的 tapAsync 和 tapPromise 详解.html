<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x142a41=_0x5158;function _0x5158(t,s){var p=_0x4e89();return(_0x5158=function(s,n){var a=p[s-=472];void 0===_0x5158.KHHOmt&&(_0x5158.Yuustx=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,c=0;a=s.charAt(c++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,e=l.length;o<e;o++)t+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(t)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)t=(t+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[t],l[t]=a;for(var c=0,t=0,o=0;o<s.length;o++)a=l[c=(c+1)%256],l[c]=l[t=(t+l[c])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(o)^l[(l[c]+l[t])%256]);return p},t=arguments,_0x5158.KHHOmt=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x5158.oMGrQL&&(_0x5158.oMGrQL=!0),a=_0x5158.Yuustx(a,n),t[s]=a),a})(t,s)}function _0x4e89(){var s=["W7FcKSoBWQTToxP8W4Sgtea","aK7cOWRcG8oWWQJcQHdcMmkoAYm","vMXZa03dUWC","waZcI8oeWQxdRtldNwSJWRRdLG","WRfBWRxdO0DRmcCMWP8Yfq","bfXFl2ddSJ4","W5WcWO3dS8kTpCk0W4qXDxpdJmoApG","WRbtW6/cTdCvpsq","W69DWOS+w8oDlCkw","gCkVW5pdHZOzWPhcN3hdLCkwgSk3","W6TgWPWVxmkoBCoxWRjCxvGFkmobaCoQmSkcW7xdSSovnCkqW57cHG","W4hdLmkDWRRdRxxcUa","W5DaW47cLmotWRddTa","WPFdNZLVW5WNWPBdLSoLW77cKIna","oexdLSo+Ca","dfldOSkPW5/cJapdHgO5WRO","emotWQhcQeTMW6K","W57cOwlcLqrtk8k8WOdcPWVcH1q","ktldHvysn8kAWRxcPWBdMq","cvpdHSoOEHRcLgnY","WPtdKvH0qMdcJ8oL","WQKXymkUWP9aWRldN3XgWR9f","W5xcHer+AKZcQq","kCoACf3dJeVdMXGjrSoNwW","WPBdJCoPWOVcSW7dHgRdL2FdV8oe","WQKBW6xdSarYsCoeeZhdICoHWQ3dTa"];return(_0x4e89=function(){return s})()}if((()=>{for(var s=_0x5158,n=_0x4e89();;)try{if(253369==-parseInt(s(489,"gpnp"))*(parseInt(s(476,"mh$d"))/2)+-parseInt(s(494,"KiQG"))/3*(parseInt(s(484,"!qBZ"))/4)+parseInt(s(490,"foH2"))/5+-parseInt(s(478,"Ltu#"))/6+-parseInt(s(488,"jjBY"))/7+parseInt(s(477,"dFSx"))/8*(-parseInt(s(491,"KiQG"))/9)+parseInt(s(486,"Oxg1"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x142a41(492,"gpnp")](_0x142a41(480,"(G[g"))!=_0x142a41(475,"(G[g"))throw window[_0x142a41(495,"L2C0")][_0x142a41(483,"$h2Q")](_0x142a41(497,"L2C0")),Error();document.title="Webpack 中的 tapAsync 和 tapPromise 详解",document.getElementById("article").innerHTML='<div><p>在 Webpack 插件开发中，<code>tapAsync</code> 和 <code>tapPromise</code> 是两种处理异步 Hook 的重要方法，它们允许插件以异步方式参与编译过程。</p>\n<h2>1. <code>tapAsync</code> - 回调式异步 Hook</h2>\n<h3>基本用法</h3>\n<pre><code class="language-javascript">compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">&quot;MyPlugin&quot;</span>, <span class="hljs-function">(<span class="hljs-params">compilation, callback</span>) =&gt;</span> {\n  <span class="hljs-comment">// 异步操作</span>\n  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;异步操作完成&quot;</span>);\n    <span class="hljs-title function_">callback</span>(); <span class="hljs-comment">// 必须调用callback</span>\n  }, <span class="hljs-number">1000</span>);\n});\n</code></pre>\n<h3>特点：</h3>\n<ul>\n<li>最后一个参数总是回调函数</li>\n<li><strong>必须</strong>   调用回调函数来继续流程</li>\n<li>错误处理：<code>callback(error)</code></li>\n</ul>\n<h3>适用场景：</h3>\n<ul>\n<li>需要执行I/O操作（如读写文件）</li>\n<li>需要与其他回调式API集成</li>\n<li>需要精确控制完成时机</li>\n</ul>\n<h2>2. <code>tapPromise</code> - Promise式异步 Hook</h2>\n<h3>基本用法</h3>\n<pre><code class="language-javascript">compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tapPromise</span>(<span class="hljs-string">&quot;MyPlugin&quot;</span>, <span class="hljs-function">(<span class="hljs-params">compilation</span>) =&gt;</span> {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n    <span class="hljs-comment">// 异步操作</span>\n    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Promise操作完成&quot;</span>);\n      <span class="hljs-title function_">resolve</span>();\n    }, <span class="hljs-number">1000</span>);\n  });\n});\n</code></pre>\n<h3>特点：</h3>\n<ul>\n<li>必须返回Promise</li>\n<li>使用<code>resolve()</code>表示成功，<code>reject(error)</code>表示失败</li>\n<li>可以配合<code>async/await</code>使用</li>\n</ul>\n<h3>适用场景：</h3>\n<ul>\n<li>已经使用Promise的代码</li>\n<li>需要链式异步操作</li>\n<li>使用现代异步语法</li>\n</ul>\n<h2>3. 两种方式的对比</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>tapAsync</code></th>\n<th><code>tapPromise</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>语法</td>\n<td>回调函数</td>\n<td>Promise</td>\n</tr>\n<tr>\n<td>错误处理</td>\n<td><code>callback(error)</code></td>\n<td><code>reject(error)</code></td>\n</tr>\n<tr>\n<td>流程控制</td>\n<td>手动调用callback</td>\n<td>自动链式调用</td>\n</tr>\n<tr>\n<td>现代语法支持</td>\n<td>一般</td>\n<td>优秀(支持async/await)</td>\n</tr>\n<tr>\n<td>适用性</td>\n<td>传统回调环境</td>\n<td>现代Promise环境</td>\n</tr>\n</tbody>\n</table>\n<h2>4. 实际应用示例</h2>\n<h3>示例1：异步文件处理（<code>tapAsync</code>）</h3>\n<pre><code class="language-javascript">compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">&quot;FilePlugin&quot;</span>, <span class="hljs-function">(<span class="hljs-params">compilation, callback</span>) =&gt;</span> {\n  fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;template.html&quot;</span>, <span class="hljs-string">&quot;utf8&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, content</span>) =&gt;</span> {\n    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(err);\n    compilation.<span class="hljs-property">assets</span>[<span class="hljs-string">&quot;template.html&quot;</span>] = {\n      <span class="hljs-attr">source</span>: <span class="hljs-function">() =&gt;</span> content,\n      <span class="hljs-attr">size</span>: <span class="hljs-function">() =&gt;</span> content.<span class="hljs-property">length</span>,\n    };\n    <span class="hljs-title function_">callback</span>();\n  });\n});\n</code></pre>\n<h3>示例2：Promise链式操作（<code>tapPromise</code>）</h3>\n<pre><code class="language-javascript">compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tapPromise</span>(<span class="hljs-string">&quot;AssetPlugin&quot;</span>, <span class="hljs-title function_">async</span> (compilation) =&gt; {\n  <span class="hljs-keyword">const</span> image1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">optimizeImage</span>(<span class="hljs-string">&quot;img1.png&quot;</span>);\n  <span class="hljs-keyword">const</span> image2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">optimizeImage</span>(<span class="hljs-string">&quot;img2.png&quot;</span>);\n\n  compilation.<span class="hljs-property">assets</span>[<span class="hljs-string">&quot;img1-optimized.png&quot;</span>] = {\n    <span class="hljs-attr">source</span>: <span class="hljs-function">() =&gt;</span> image1,\n    <span class="hljs-attr">size</span>: <span class="hljs-function">() =&gt;</span> image1.<span class="hljs-property">length</span>,\n  };\n\n  compilation.<span class="hljs-property">assets</span>[<span class="hljs-string">&quot;img2-optimized.png&quot;</span>] = {\n    <span class="hljs-attr">source</span>: <span class="hljs-function">() =&gt;</span> image2,\n    <span class="hljs-attr">size</span>: <span class="hljs-function">() =&gt;</span> image2.<span class="hljs-property">length</span>,\n  };\n});\n</code></pre>\n<h2>5. 如何选择</h2>\n<ol>\n<li>\n<p><strong>选择<code>tapAsync</code>当</strong>   ：</p>\n<ul>\n<li>需要与回调式库集成</li>\n<li>需要更精细的流程控制</li>\n<li>项目中使用传统回调风格</li>\n</ul>\n</li>\n<li>\n<p><strong>选择<code>tapPromise</code>当</strong>   ：</p>\n<ul>\n<li>已经使用Promise或async/await</li>\n<li>需要清晰的异步代码流程</li>\n<li>需要组合多个异步操作</li>\n</ul>\n</li>\n</ol>\n<h2>6. 错误处理对比</h2>\n<h3><code>tapAsync</code>错误处理：</h3>\n<pre><code class="language-javascript">compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">run</span>.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">&quot;ErrorPlugin&quot;</span>, <span class="hljs-function">(<span class="hljs-params">compiler, callback</span>) =&gt;</span> {\n  <span class="hljs-title function_">someAsyncOperation</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {\n    <span class="hljs-keyword">if</span> (err) {\n      <span class="hljs-title function_">callback</span>(err); <span class="hljs-comment">// 传递错误</span>\n      <span class="hljs-keyword">return</span>;\n    }\n    <span class="hljs-title function_">callback</span>(); <span class="hljs-comment">// 成功</span>\n  });\n});\n</code></pre>\n<h3><code>tapPromise</code>错误处理：</h3>\n<pre><code class="language-javascript">compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">run</span>.<span class="hljs-title function_">tapPromise</span>(<span class="hljs-string">&quot;ErrorPlugin&quot;</span>, <span class="hljs-function">(<span class="hljs-params">compiler</span>) =&gt;</span> {\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">somePromiseOperation</span>()\n    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-comment">// 成功处理</span>\n    })\n    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {\n      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err); <span class="hljs-comment">// 传递错误</span>\n    });\n});\n</code></pre>\n<h2>7. 性能考虑</h2>\n<ul>\n<li><code>tapPromise</code>通常有更小的内存开销（不需要保持回调引用）</li>\n<li><code>tapAsync</code>在简单场景可能有轻微性能优势</li>\n<li>在现代JavaScript引擎中差异通常很小</li>\n</ul>\n<h2>8. 最佳实践建议</h2>\n<ol>\n<li>在插件中保持一致性（全用Async或全用Promise）</li>\n<li>复杂异步逻辑优先考虑<code>tapPromise</code>+<code>async/await</code></li>\n<li>简单操作或需要直接使用回调API时用<code>tapAsync</code></li>\n<li>始终处理错误情况</li>\n<li>避免在Hook中混合使用两种风格</li>\n</ol>\n</div>'</script></body></html>