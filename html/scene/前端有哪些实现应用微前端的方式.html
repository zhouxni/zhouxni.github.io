<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x38c2d7=_0x82c7;function _0x82c7(p,s){var t=_0x10c6();return(_0x82c7=function(s,n){var a=t[s-=383];void 0===_0x82c7.brDpGN&&(_0x82c7.aYFlNd=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,c=0;a=s.charAt(c++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,e=l.length;o<e;o++)p+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(p)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)p=(p+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[p],l[p]=a;for(var c=0,p=0,o=0;o<s.length;o++)a=l[c=(c+1)%256],l[c]=l[p=(p+l[c])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(o)^l[(l[c]+l[p])%256]);return t},p=arguments,_0x82c7.brDpGN=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x82c7.YOqeBb&&(_0x82c7.YOqeBb=!0),a=_0x82c7.aYFlNd(a,n),p[s]=a),a})(p,s)}if((()=>{for(var s=_0x82c7,n=_0x10c6();;)try{if(569680==+parseInt(s(408,"N%V]"))+parseInt(s(397,"GD(t"))/2*(-parseInt(s(390,"shCb"))/3)+parseInt(s(405,"3!AC"))/4*(parseInt(s(399,"xy&l"))/5)+parseInt(s(407,")aSo"))/6*(parseInt(s(389,"H[H2"))/7)+parseInt(s(385,"$36#"))/8+-parseInt(s(404,"9k5V"))/9*(parseInt(s(396,"TGjp"))/10)+-parseInt(s(388,"i5eo"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x38c2d7(398,"9k5V")](_0x38c2d7(393,"d9zO"))!=_0x38c2d7(392,"x[OS"))throw window[_0x38c2d7(403,"GD(t")][_0x38c2d7(410,"b@UE")](_0x38c2d7(387,")4WQ")),Error();function _0x10c6(){var s=["WRa3rNLiWPTcW4RcHCo2WR4Boq","WQWgqtf1x8koWO/cGmkRW5STW6S","Amoup090WOdcIYe","gc1RW5JcLCofW6rJWQWCkmoBW64","nCkdeebfWOZcOdO","W7pdLqqcW53dSmobW49A","W7FcV8kPomkpgW0","gCk1WQPaoSkKWOhdPvC","qs8eESoZW7LNWQPrDa","WQTYWQO8yYz/W4xdIuddNSkg","WRXJB0RdTSknW7tdKSotW4H5","WOT5W4XCW55yqa","FCk3WRiCW5mBcW","WPFdTMv8lK/dNrrBW7TfWQ8","WQZcSJj4xr4IaSogpSoUgbW","WPWzWQCzWRDQW4xcJxBcUG","W4RcTIe4AuBcGL1WW6LdWOpcUmoiW7KHWR9HWQ42WO93ldrHrG","F8oJWPL/W7JcNHZdTsRdIw5HsCo1","u33dKCk0pmo2WQhcOZxcP8kG","edWKq0VdUYjp","WQhcO3LiW4/dKMToWOmmWRj0WO7cLG","oCkKWOS/W4q","lrhcK8kVrHJdIsDD","W78GW40EW43dSCkPW5m3WOddSG","BSodwmonhbydFSoUj8kB","aSoxW4HNWRvVW6jMW5VdGSkz","AmoCsHuhWQhcJrxdLmoQva","WQdcHuKZW67dHmo+"];return(_0x10c6=function(){return s})()}document.title="前端有哪些实现应用微前端的方式",document.getElementById("article").innerHTML='<div><p>微前端是一种将前端应用拆分为多个独立可交付的小型应用（微应用），并能在同一页面中集成运行的架构模式。实现微前端的方式有多种，各有其适用场景和技术特点，以下是常见的实现方式及核心原理：</p>\n<h3>一、基于路由分发的微前端（最常用）</h3>\n<p><strong>核心思想</strong>   ：通过路由匹配规则，将不同 URL 路径分发到对应的微应用，每个微应用独立部署、运行在独立的路由上下文。<br>\n<strong>典型场景</strong>   ：大型应用按多个团队维护不同模块（如电商的商品页、购物车、结算页），通过路由隔离。</p>\n<h4>实现方式：</h4>\n<ol>\n<li>\n<p><strong>路由拦截 + 应用加载</strong></p>\n<ul>\n<li>主应用（基座）监听路由变化，根据路由规则匹配对应的微应用。</li>\n<li>动态加载微应用的入口资源（JS/CSS），并挂载到主应用的 DOM 容器中。</li>\n</ul>\n</li>\n<li>\n<p><strong>代表框架/库</strong>   ：</p>\n<ul>\n<li><strong>single-spa</strong>   ：最早的微前端框架，通过注册应用（指定路由规则和生命周期函数）实现路由分发，支持多种前端技术栈（Vue/React/Angular 等）。</li>\n<li><strong>qiankun</strong>   ：基于 single-spa 封装，提供更完善的沙箱隔离（JS/CSS 隔离）、预加载等能力，简化了微应用接入流程。</li>\n</ul>\n</li>\n</ol>\n<h4>示例（qiankun 核心逻辑）：</h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 主应用注册微应用</span>\n<span class="hljs-keyword">import</span> { registerMicroApps, start } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;qiankun&quot;</span>;\n\n<span class="hljs-title function_">registerMicroApps</span>([\n  {\n    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;vueApp&quot;</span>, <span class="hljs-comment">// 微应用名称</span>\n    <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;//localhost:8081&quot;</span>, <span class="hljs-comment">// 微应用入口地址</span>\n    <span class="hljs-attr">container</span>: <span class="hljs-string">&quot;#appContainer&quot;</span>, <span class="hljs-comment">// 挂载容器</span>\n    <span class="hljs-attr">activeRule</span>: <span class="hljs-string">&quot;/vue&quot;</span>, <span class="hljs-comment">// 路由匹配规则</span>\n  },\n  {\n    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;reactApp&quot;</span>,\n    <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;//localhost:8082&quot;</span>,\n    <span class="hljs-attr">container</span>: <span class="hljs-string">&quot;#appContainer&quot;</span>,\n    <span class="hljs-attr">activeRule</span>: <span class="hljs-string">&quot;/react&quot;</span>,\n  },\n]);\n\n<span class="hljs-comment">// 启动 qiankun</span>\n<span class="hljs-title function_">start</span>();\n</code></pre>\n<h3>二、基于 Web Components 的微前端</h3>\n<p><strong>核心思想</strong>   ：将每个微应用封装为自定义 Web Components 组件，主应用通过直接使用组件标签（如 <code>&lt;micro-app1&gt;</code>）集成，利用浏览器原生的组件隔离特性实现解耦。<br>\n<strong>典型场景</strong>   ：跨框架共享组件（如不同团队用 Vue 和 React 开发的组件需集成到同一页面）。</p>\n<h4>实现方式：</h4>\n<ol>\n<li>\n<p><strong>微应用封装为 Web Components</strong></p>\n<ul>\n<li>微应用通过 <code>customElements.define()</code> 注册为自定义元素，内部逻辑（如 Vue/React 应用）通过 Shadow DOM 隔离。</li>\n<li>主应用无需关心微应用技术栈，直接像使用原生标签一样引入。</li>\n</ul>\n</li>\n<li>\n<p><strong>优势</strong>   ：</p>\n<ul>\n<li>原生浏览器支持，无需依赖框架。</li>\n<li>强隔离性（Shadow DOM 天然隔离 CSS 和 DOM）。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 微应用（React 封装为 Web Component）</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n<span class="hljs-keyword">import</span> { createRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/client&quot;</span>;\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">MicroApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">super</span>();\n    <span class="hljs-comment">// 创建 Shadow DOM 隔离环境</span>\n    <span class="hljs-keyword">const</span> shadow = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;open&quot;</span> });\n    shadow.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&#x27;</span>;\n  }\n\n  <span class="hljs-title function_">connectedCallback</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-comment">// 在 Shadow DOM 中渲染 React 应用</span>\n    <span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">shadowRoot</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#root&quot;</span>)).<span class="hljs-title function_">render</span>(\n      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>React 微应用<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>,\n    );\n  }\n}\n\n<span class="hljs-comment">// 注册为自定义元素</span>\ncustomElements.<span class="hljs-title function_">define</span>(<span class="hljs-string">&quot;micro-react-app&quot;</span>, <span class="hljs-title class_">MicroApp</span>);\n</code></pre>\n<p>主应用直接使用：</p>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 主应用页面 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>主应用<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n  <span class="hljs-comment">&lt;!-- 引入 React 微应用 --&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">micro-react-app</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">micro-react-app</span>&gt;</span>\n  <span class="hljs-comment">&lt;!-- 引入 Vue 微应用（同理封装） --&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">micro-vue-app</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">micro-vue-app</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n</code></pre>\n</li>\n</ol>\n<h3>三、基于 iframe 的微前端（最简单直接）</h3>\n<p><strong>核心思想</strong>   ：通过 iframe 标签嵌入微应用，利用 iframe 天然的沙箱环境实现完全隔离（JS/CSS/DOM 互不干扰）。<br>\n<strong>典型场景</strong>   ：需要严格隔离的场景（如第三方应用接入、安全性要求高的模块）。</p>\n<h4>优势与局限：</h4>\n<ul>\n<li><strong>优势</strong>   ：实现简单（无需复杂框架）、隔离彻底（避免样式冲突和 JS 污染）。</li>\n<li><strong>局限</strong>   ：\n<ul>\n<li>性能损耗（iframe 会创建独立的浏览器上下文）。</li>\n<li>通信复杂（需通过 <code>postMessage</code> 传递数据）。</li>\n<li>路由同步困难（主应用和 iframe 路由需手动同步）。</li>\n</ul>\n</li>\n</ul>\n<h4>示例：</h4>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 主应用 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main-app&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>主应用<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n  <span class="hljs-comment">&lt;!-- 嵌入微应用 --&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span>\n    <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://micro-app.example.com&quot;</span>\n    <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span>\n    <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span>\n    <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500px&quot;</span>\n  &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-comment">// 主应用与微应用通信</span>\n  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {\n    <span class="hljs-keyword">if</span> (e.<span class="hljs-property">origin</span> === <span class="hljs-string">&quot;https://micro-app.example.com&quot;</span>) {\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到微应用消息:&quot;</span>, e.<span class="hljs-property">data</span>);\n    }\n  });\n\n  <span class="hljs-comment">// 向微应用发送消息</span>\n  <span class="hljs-keyword">const</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;iframe&quot;</span>);\n  iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">postMessage</span>(\n    <span class="hljs-string">&quot;来自主应用的消息&quot;</span>,\n    <span class="hljs-string">&quot;https://micro-app.example.com&quot;</span>,\n  );\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<h3>四、基于模块联邦（Module Federation）的微前端</h3>\n<p><strong>核心思想</strong>   ：通过 Webpack 5 的 Module Federation 特性，实现微应用间的模块共享和动态加载，允许一个应用直接引用另一个应用的组件或方法，无需完整加载整个应用。<br>\n<strong>典型场景</strong>   ：需要高度共享组件/逻辑的微应用（如多个应用共用一个导航组件）。</p>\n<h4>实现方式：</h4>\n<ol>\n<li><strong>微应用暴露模块</strong>   ：通过 Webpack 配置将组件或模块标记为“可共享”。</li>\n<li><strong>主应用动态引入</strong>   ：直接导入其他微应用暴露的模块，像使用本地模块一样调用。</li>\n</ol>\n<h4>示例（Webpack 配置）：</h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 微应用 A 的 webpack.config.js</span>\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">plugins</span>: [\n    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>({\n      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;appA&quot;</span>,\n      <span class="hljs-attr">exposes</span>: {\n        <span class="hljs-string">&quot;./Header&quot;</span>: <span class="hljs-string">&quot;./src/components/Header&quot;</span>, <span class="hljs-comment">// 暴露 Header 组件</span>\n      },\n    }),\n  ],\n};\n\n<span class="hljs-comment">// 主应用的 webpack.config.js</span>\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">plugins</span>: [\n    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>({\n      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mainApp&quot;</span>,\n      <span class="hljs-attr">remotes</span>: {\n        <span class="hljs-attr">appA</span>: <span class="hljs-string">&quot;appA@http://localhost:8081/remoteEntry.js&quot;</span>, <span class="hljs-comment">// 引入微应用 A</span>\n      },\n    }),\n  ],\n};\n\n<span class="hljs-comment">// 主应用中使用微应用 A 的组件</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">Header</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;appA/Header&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span> {/* 直接使用微应用 A 的组件 */}\n      <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>主应用内容<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h3>五、其他方式</h3>\n<ol>\n<li>\n<p><strong>基于基座应用的运行时集成</strong><br>\n主应用提供全局运行时环境（如注入 <code>window.microApps</code> 接口），微应用通过注册生命周期（<code>bootstrap</code>/<code>mount</code>/<code>unmount</code>）与主应用交互，手动处理加载、渲染和销毁逻辑（类似 single-spa 的底层原理，但需自定义实现）。</p>\n</li>\n<li>\n<p><strong>基于状态管理的微前端</strong><br>\n通过全局状态库（如 Redux、Pinia）共享数据，微应用通过订阅/发布模式通信，但需额外处理状态隔离和权限控制。</p>\n</li>\n</ol>\n<h3>选型建议</h3>\n<ul>\n<li><strong>简单隔离需求</strong>   ：优先用 <code>iframe</code>（快速实现，适合第三方接入）。</li>\n<li><strong>多团队协作 + 路由隔离</strong>   ：选 <code>qiankun</code> 或 <code>single-spa</code>（成熟稳定，支持多技术栈）。</li>\n<li><strong>跨框架组件共享</strong>   ：用 <code>Web Components</code>（原生隔离，适合组件级集成）。</li>\n<li><strong>模块级共享需求</strong>   ：用 <code>Module Federation</code>（Webpack 生态，适合高度共享的场景）。</li>\n</ul>\n<p>微前端的核心目标是“技术栈无关、独立开发部署、隔离与通信并存”，选择时需结合团队技术栈、隔离要求和性能需求综合判断。</p>\n</div>'</script></body></html>