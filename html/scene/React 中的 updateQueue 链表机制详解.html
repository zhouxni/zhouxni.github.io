<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3554(t,s){var l=_0x1296();return(_0x3554=function(s,a){var n=l[s-=486];void 0===_0x3554.iCxYvU&&(_0x3554.qfSDJK=function(s,a){var n,e=[],t=0,l="";for(s=(s=>{for(var a,n,e="",t="",l=0,p=0;n=s.charAt(p++);~n&&(a=l%4?64*a+n:n,l++%4)&&(e+=String.fromCharCode(255&a>>(-2*l&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,o=e.length;c<o;c++)t+="%"+("00"+e.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),p=0;p<256;p++)e[p]=p;for(p=0;p<256;p++)t=(t+e[p]+a.charCodeAt(p%a.length))%256,n=e[p],e[p]=e[t],e[t]=n;for(var p=0,t=0,c=0;c<s.length;c++)n=e[p=(p+1)%256],e[p]=e[t=(t+e[p])%256],e[t]=n,l+=String.fromCharCode(s.charCodeAt(c)^e[(e[p]+e[t])%256]);return l},t=arguments,_0x3554.iCxYvU=!0);var s=s+l[0],e=t[s];return e?n=e:(void 0===_0x3554.tsJuGF&&(_0x3554.tsJuGF=!0),n=_0x3554.qfSDJK(n,a),t[s]=n),n})(t,s)}var _0x571a22=_0x3554;function _0x1296(){var s=["k8kmW61FmSkow8oylmo3W6JdVmks","W45wWO55uG8w","uq86aSoQkLRdTW","W61IW79MaCkpWR4","uW/dLmk7bq","W4tdICoIDmoyW64uWOKVbblcRurC","i8osy8kZW4/cHbep","W4/dJSoJDmovW6T4W7icgYpcSG","D1pdUJFcMCk4zCorWOZdSYTyW5C","WO9UfIJcPfZcLW","aCkcW6nZW7xdO8k1Aba","WQ3dPmolW4mpW7BdKmke","W53dGCkLtCkrW47dJmoXW4hcGSoCWP4","DCo2m8kfW7BdGbmHuSkDr8kRcW","W5bWrSkLWPNcJ8kQ","W6mtF8ofW5FdGmk0","CCoxW5LYW47dK8k/Aq","WOtcQ2zHg8oqjCkva8kfEuG","fCkdc2hcJfX0W6W","C8okWQXIEmoSWRFcNf5yb8ob","WOtcQg5GfCorqCk3emkSAeddOq","WOSFvhhdMXxdRKNcK8kBW6f5WOC","A2WYj19FWQK","W6b8W794W5hcRComWQOPq8kBbSofWOBdS8kLgCkkedDnemoZWOJdH3S","W7y+WR4vjCkJdJNdHsPEBq","W6WTWO0FySo8WRTWW73cRmoEnW","DCoiWQrMDCoRW7xdUxDfgCoRWQddTa","mCoUWOL8g8odkutcHImhmCoa"];return(_0x1296=function(){return s})()}if((()=>{for(var s=_0x3554,a=_0x1296();;)try{if(845302==-parseInt(s(511,"8#60"))*(parseInt(s(498,"^o]#"))/2)+parseInt(s(493,"MD&N"))/3*(-parseInt(s(504,"AcHm"))/4)+parseInt(s(505,"I&9^"))/5*(-parseInt(s(495,"8#60"))/6)+-parseInt(s(508,"^Ahp"))/7*(-parseInt(s(509,"k!k2"))/8)+-parseInt(s(487,"]%eo"))/9+parseInt(s(494,"^0zW"))/10+parseInt(s(507,"k!k2"))/11)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x571a22(503,"%1ee")](_0x571a22(512,"1rK2"))!=_0x571a22(506,"eNDU"))throw window[_0x571a22(492,"2Xm1")][_0x571a22(489,"bjf9")](_0x571a22(497,"!0%F")),Error();document.title="React 中的 updateQueue 链表机制详解",document.getElementById("article").innerHTML='<div><p><code>updateQueue</code> 是 React Fiber 架构中的一个关键数据结构，用于管理组件的状态更新（如 <code>setState</code>、<code>useState</code>、<code>useReducer</code> 触发的更新）。它采用 <strong>单向链表</strong>   结构存储多个更新，确保批处理（Batching）和优先级调度（Lane Model）的正确执行。</p>\n<hr>\n<h2><strong>1. <code>updateQueue</code> 的结构</strong></h2>\n<p>每个 Fiber 节点都有一个 <code>updateQueue</code> 字段，用于存储该组件的待处理更新。其核心结构如下：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">UpdateQueue</span>&lt;<span class="hljs-title class_">State</span>&gt; = {\n  <span class="hljs-attr">baseState</span>: <span class="hljs-title class_">State</span>,        <span class="hljs-comment">// 当前基础状态（计算新状态的起点）</span>\n  <span class="hljs-attr">firstUpdate</span>: <span class="hljs-title class_">Update</span>&lt;<span class="hljs-title class_">State</span>&gt; | <span class="hljs-literal">null</span>, <span class="hljs-comment">// 链表头部（第一个更新）</span>\n  <span class="hljs-attr">lastUpdate</span>: <span class="hljs-title class_">Update</span>&lt;<span class="hljs-title class_">State</span>&gt; | <span class="hljs-literal">null</span>,  <span class="hljs-comment">// 链表尾部（最后一个更新）</span>\n  <span class="hljs-attr">firstEffect</span>: <span class="hljs-title class_">Update</span>&lt;<span class="hljs-title class_">State</span>&gt; | <span class="hljs-literal">null</span>, <span class="hljs-comment">// 副作用链表（用于 Commit 阶段）</span>\n  <span class="hljs-attr">lastEffect</span>: <span class="hljs-title class_">Update</span>&lt;<span class="hljs-title class_">State</span>&gt; | <span class="hljs-literal">null</span>,  <span class="hljs-comment">// 副作用链表尾部</span>\n};\n</code></pre>\n<h3><strong>更新对象（<code>Update</code>）的结构</strong></h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Update</span>&lt;<span class="hljs-title class_">State</span>&gt; = {\n  <span class="hljs-attr">lane</span>: <span class="hljs-title class_">Lane</span>,              <span class="hljs-comment">// 优先级（React 17+ 使用 Lane 模型）</span>\n  <span class="hljs-attr">action</span>: <span class="hljs-title class_">Action</span>&lt;<span class="hljs-title class_">State</span>&gt;,   <span class="hljs-comment">// 更新内容（可能是新状态或函数：`prevState =&gt; newState`）</span>\n  <span class="hljs-attr">next</span>: <span class="hljs-title class_">Update</span>&lt;<span class="hljs-title class_">State</span>&gt; | <span class="hljs-literal">null</span>, <span class="hljs-comment">// 指向下一个更新（链表结构）</span>\n  <span class="hljs-comment">// ... 其他内部字段（如 callback、eagerState 等）</span>\n};\n</code></pre>\n<hr>\n<h2><strong>2. <code>updateQueue</code> 的工作流程</strong></h2>\n<h3><strong>（1）添加更新（<code>enqueueUpdate</code>）</strong></h3>\n<p>当调用 <code>setState</code> 或 <code>useState</code> 的 dispatch 时：</p>\n<ol>\n<li>创建一个新的 <code>Update</code> 对象。</li>\n<li>将其插入到 <code>updateQueue</code> 链表的尾部（<code>lastUpdate.next = newUpdate</code>）。</li>\n<li>更新 <code>lastUpdate</code> 指针。</li>\n</ol>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 假设初始状态为 0</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> }); <span class="hljs-comment">// Update1</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">2</span> }); <span class="hljs-comment">// Update2</span>\n</code></pre>\n<p>链表结构：</p>\n<pre><code>updateQueue: {\n  firstUpdate: Update1,\n  lastUpdate: Update2,\n  baseState: 0,\n}\nUpdate1.next = Update2;\nUpdate2.next = null;\n</code></pre>\n<h3><strong>（2）处理更新（<code>processUpdateQueue</code>）</strong></h3>\n<p>在 <strong>Render 阶段</strong>  ，React 会遍历 <code>updateQueue</code>，依次执行更新，计算最终状态：</p>\n<ol>\n<li>从 <code>baseState</code> 开始，按顺序处理每个 <code>Update</code>。</li>\n<li>如果 <code>action</code> 是函数（如 <code>prevState =&gt; prevState + 1</code>），则调用它生成新状态。</li>\n<li>合并连续的同优先级更新（批处理）。</li>\n<li>最终得到新的 <code>memoizedState</code>，用于渲染。</li>\n</ol>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 初始状态：baseState = 0</span>\n<span class="hljs-comment">// Update1: action = { count: 1 }</span>\n<span class="hljs-comment">// Update2: action = prevState =&gt; ({ count: prevState.count + 1 })</span>\n<span class="hljs-comment">// 计算结果：</span>\n<span class="hljs-comment">// 1. 处理 Update1 → state = { count: 1 }</span>\n<span class="hljs-comment">// 2. 处理 Update2 → state = { count: 2 }</span>\n<span class="hljs-comment">// 最终 memoizedState = { count: 2 }</span>\n</code></pre>\n<hr>\n<h2><strong>3. 关键特性</strong></h2>\n<h3><strong>（1）批处理（Batching）</strong></h3>\n<ul>\n<li>在 <strong>同一事件循环</strong>   中的多个 <code>setState</code> 会被合并到同一个 <code>updateQueue</code> 中。</li>\n<li>React 17 及之前：仅在 React 事件处理函数中自动批处理。</li>\n<li>React 18+：对所有场景（包括 <code>setTimeout</code>、<code>Promise</code>）自动批处理。</li>\n</ul>\n<h3><strong>（2）优先级调度（Lane Model）</strong></h3>\n<ul>\n<li>每个 <code>Update</code> 有一个 <code>lane</code> 字段，表示优先级（如 <code>SyncLane</code>、<code>DefaultLane</code>）。</li>\n<li>高优先级更新会跳过低优先级更新（并发模式下）。</li>\n</ul>\n<h3><strong>（3）中断与恢复</strong></h3>\n<ul>\n<li>在 <strong>并发模式</strong>   下，低优先级更新可能被中断，此时：\n<ul>\n<li><code>baseState</code> 会保留当前处理到的状态。</li>\n<li>后续恢复时从 <code>baseState</code> 继续处理剩余更新。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2><strong>4. 与 Hooks 的关系</strong></h2>\n<ul>\n<li><strong><code>useState</code> / <code>useReducer</code></strong>  ：底层使用相同的 <code>updateQueue</code> 机制。</li>\n<li><strong><code>useEffect</code></strong>  ：副作用链表（<code>firstEffect</code>）在 Commit 阶段处理。</li>\n</ul>\n<hr>\n<h2><strong>5. 源码示例（简化版）</strong></h2>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">enqueueUpdate</span>(<span class="hljs-params">fiber, update</span>) {\n  <span class="hljs-keyword">const</span> queue = fiber.<span class="hljs-property">updateQueue</span>;\n  <span class="hljs-keyword">if</span> (!queue) <span class="hljs-keyword">return</span>;\n\n  <span class="hljs-keyword">if</span> (queue.<span class="hljs-property">lastUpdate</span> === <span class="hljs-literal">null</span>) {\n    <span class="hljs-comment">// 链表为空，直接作为第一个更新</span>\n    queue.<span class="hljs-property">firstUpdate</span> = queue.<span class="hljs-property">lastUpdate</span> = update;\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 添加到链表尾部</span>\n    queue.<span class="hljs-property">lastUpdate</span>.<span class="hljs-property">next</span> = update;\n    queue.<span class="hljs-property">lastUpdate</span> = update;\n  }\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">processUpdateQueue</span>(<span class="hljs-params">fiber</span>) {\n  <span class="hljs-keyword">const</span> queue = fiber.<span class="hljs-property">updateQueue</span>;\n  <span class="hljs-keyword">let</span> state = queue.<span class="hljs-property">baseState</span>;\n  <span class="hljs-keyword">let</span> update = queue.<span class="hljs-property">firstUpdate</span>;\n\n  <span class="hljs-keyword">while</span> (update !== <span class="hljs-literal">null</span>) {\n    <span class="hljs-comment">// 计算新状态</span>\n    <span class="hljs-keyword">const</span> action = update.<span class="hljs-property">action</span>;\n    state = <span class="hljs-keyword">typeof</span> action === <span class="hljs-string">&#x27;function&#x27;</span> \n      ? <span class="hljs-title function_">action</span>(state) \n      : action;\n    update = update.<span class="hljs-property">next</span>;\n  }\n\n  <span class="hljs-comment">// 更新 Fiber 的 memoizedState</span>\n  fiber.<span class="hljs-property">memoizedState</span> = state;\n}\n</code></pre>\n<hr>\n<h2><strong>6. 总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>数据结构</strong></td>\n<td>单向链表，存储 <code>Update</code> 对象。</td>\n</tr>\n<tr>\n<td><strong>批处理</strong></td>\n<td>合并连续更新，减少不必要的渲染。</td>\n</tr>\n<tr>\n<td><strong>优先级调度</strong></td>\n<td>通过 <code>lane</code> 标记优先级，高优先级更新优先处理。</td>\n</tr>\n<tr>\n<td><strong>中断与恢复</strong></td>\n<td>并发模式下，低优先级更新可被中断，恢复时从 <code>baseState</code> 继续。</td>\n</tr>\n<tr>\n<td><strong>与 Hooks 关联</strong></td>\n<td><code>useState</code>、<code>useReducer</code> 依赖 <code>updateQueue</code> 管理状态。</td>\n</tr>\n</tbody>\n</table>\n<p><code>updateQueue</code> 是 React 高效更新机制的核心，通过链表结构和优先级调度，实现了高性能的状态管理与渲染优化。</p>\n</div>'</script></body></html>