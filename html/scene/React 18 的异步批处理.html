<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5c4259=_0x27de;function _0x27de(l,s){var t=_0x56ef();return(_0x27de=function(s,n){var e=t[s-=298];void 0===_0x27de.Ocgkpk&&(_0x27de.CfDUEw=function(s,n){var e,a=[],l=0,t="";for(s=(s=>{for(var n,e,a="",l="",t=0,o=0;e=s.charAt(o++);~e&&(n=t%4?64*n+e:e,t++%4)&&(a+=String.fromCharCode(255&n>>(-2*t&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var c=0,r=a.length;c<r;c++)l+="%"+("00"+a.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),o=0;o<256;o++)a[o]=o;for(o=0;o<256;o++)l=(l+a[o]+n.charCodeAt(o%n.length))%256,e=a[o],a[o]=a[l],a[l]=e;for(var o=0,l=0,c=0;c<s.length;c++)e=a[o=(o+1)%256],a[o]=a[l=(l+a[o])%256],a[l]=e,t+=String.fromCharCode(s.charCodeAt(c)^a[(a[o]+a[l])%256]);return t},l=arguments,_0x27de.Ocgkpk=!0);var s=s+t[0],a=l[s];return a?e=a:(void 0===_0x27de.NUEPet&&(_0x27de.NUEPet=!0),e=_0x27de.CfDUEw(e,n),l[s]=e),e})(l,s)}function _0x56ef(){var s=["W6rra8kBWRjxW5i","W5OHW7hcJ8kUW6auWRFcVCkndbyl","WPRdGuH0waP6BG","W71XzSk2WQZcVuxcV1pcQuVdTG","W6BcICkBWRdcP2GeWRG","t2LtW6qwyCovpYKoWQaW","ctnlW5hdTSojWQGOeuW","eY8vWQDsBCkTyXuEWOG9imkglJlcV2VcONu4W7FdL8o2WQ7dVq","WOSLgCkDBGKVWQH1iJu","amkes2znnCkbW4G","W63cJCosWPBdGmk5W5PN","W57dH8kcESoZoSoHwG","WPldQsuupa4qW6C","W6pdJHngtSklW6hcTG","D2WFcmoTsZldLu53","hdzFW78KWRGJmd55W44d","v0fLWQqB","W58IqSolW71elCooWPqD","l8k2WRbEzgJcHcWAzCkrsW","WQddSCoLzmospmkGW4i","eCkkW70oyaKN","uCoFWRXwnLP3WOOuB8oRe8o4","h0ldJH3dG8kuWPypemogW7hdHa8","AmodWRDhW5SsWPC","WRVcVt/cJSo7nIxcT30wW63cT8kc","t8ovW5rcgmkRWP1elW","n27dK8k9WOPDfW","W4qxofJdVCo/nI9UpG","W53dGmolcCkMnCoZqCkQW7ZcVq","WPRdH3LvAq9yrG","CmogxCkcW4aPW7xcHSohdG","WOW8DSkEWRZcMHz0ASkm"];return(_0x56ef=function(){return s})()}if((()=>{for(var s=_0x27de,n=_0x56ef();;)try{if(107117==-parseInt(s(324,"Dw4J"))*(-parseInt(s(302,"s@oG"))/2)+-parseInt(s(303,"Hi#S"))/3*(parseInt(s(321,"^0Bk"))/4)+parseInt(s(327,"VC(o"))/5*(parseInt(s(311,"toCp"))/6)+-parseInt(s(319,"ZPzl"))/7*(-parseInt(s(308,"pbh5"))/8)+-parseInt(s(320,"@Lef"))/9*(-parseInt(s(323,"OwGx"))/10)+parseInt(s(314,"1*w!"))/11+-parseInt(s(317,"cOml"))/12*(parseInt(s(322,"VC(o"))/13))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5c4259(325,"seOQ")](_0x5c4259(318,"UG*A"))!=_0x5c4259(309,"enSi"))throw window[_0x5c4259(305,"O3kp")][_0x5c4259(313,"1*w!")](_0x5c4259(300,"q#dd")),Error();document.title="React 18 的异步批处理",document.getElementById("article").innerHTML='<div><p>React 18 的“异步批处理”（Automatic Batching）并不是简单地把 <code>batchedUpdates</code> 再包一层 Promise，而是把「<strong>更新何时 flush</strong>   」的决定权从<strong>同步调用栈结束</strong>   改成了「<strong>让 Scheduler 在微任务阶段统一调度</strong>   」。<br>\n核心链路只有 3 步：</p>\n<ol>\n<li>任何 setState → 2. 把 update 挂到 root 上 → 3. Scheduler 在微任务里 flush。<br>\n下面把关键源码（18.2.0）拆开给你看。</li>\n</ol>\n<hr>\n<ol>\n<li>入口：setState → scheduleUpdateOnFiber<br>\npackages/react-reconciler/src/ReactFiberWorkLoop.js</li>\n</ol>\n<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleUpdateOnFiber</span>(<span class="hljs-params">\n  root: FiberRoot,\n  fiber: Fiber,\n  lane: Lane,\n  eventTime: number\n</span>) {\n  <span class="hljs-comment">// 标记 root 有待处理工作</span>\n  <span class="hljs-title function_">markRootUpdated</span>(root, lane, eventTime);\n\n  <span class="hljs-comment">// 🔑 关键：不再区分 executionContext，统一走 ensureRootIsScheduled</span>\n  <span class="hljs-title function_">ensureRootIsScheduled</span>(root, eventTime);\n\n  <span class="hljs-comment">// flushSync 场景才立即 flush</span>\n  <span class="hljs-keyword">if</span> ((executionContext &amp; (<span class="hljs-title class_">RenderContext</span> | <span class="hljs-title class_">CommitContext</span>)) !== <span class="hljs-title class_">NoContext</span>) {\n    <span class="hljs-keyword">return</span>;\n  }\n}\n</code></pre>\n<ul>\n<li>Legacy 模式或 flushSync 场景会立即 flush；</li>\n<li>默认 Concurrent Root 会进入 <strong>ensureRootIsScheduled</strong>   ，把 flush 推迟到微任务。</li>\n</ul>\n<hr>\n<ol start="2">\n<li>ensureRootIsScheduled → scheduleCallback<br>\npackages/react-reconciler/src/ReactFiberWorkLoop.js</li>\n</ol>\n<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureRootIsScheduled</span>(<span class="hljs-params">root: FiberRoot, currentTime: number</span>) {\n  <span class="hljs-keyword">const</span> existingCallbackNode = root.<span class="hljs-property">callbackNode</span>;\n\n  <span class="hljs-keyword">const</span> nextLanes = <span class="hljs-title function_">getNextLanes</span>(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes : <span class="hljs-title class_">NoLanes</span>\n  );\n  <span class="hljs-keyword">if</span> (nextLanes === <span class="hljs-title class_">NoLanes</span>) {\n    <span class="hljs-comment">// 没有工作，取消已有 callback</span>\n    <span class="hljs-keyword">if</span> (existingCallbackNode !== <span class="hljs-literal">null</span>) {\n      <span class="hljs-title function_">cancelCallback</span>(existingCallbackNode);\n      root.<span class="hljs-property">callbackNode</span> = <span class="hljs-literal">null</span>;\n    }\n    <span class="hljs-keyword">return</span>;\n  }\n\n  <span class="hljs-keyword">const</span> priority = <span class="hljs-title function_">lanesToEventPriority</span>(nextLanes);\n  <span class="hljs-keyword">const</span> schedulerPriorityLevel = <span class="hljs-title function_">eventPriorityToSchedulerPriority</span>(priority);\n\n  <span class="hljs-keyword">const</span> newCallbackNode = <span class="hljs-title function_">scheduleCallback</span>(\n    schedulerPriorityLevel,\n    performConcurrentWorkOnRoot.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root) <span class="hljs-comment">// ← 真正渲染函数</span>\n  );\n\n  root.<span class="hljs-property">callbackNode</span> = newCallbackNode;\n}\n</code></pre>\n<ul>\n<li><code>scheduleCallback</code> 来自 <code>scheduler</code> 包，内部用 <code>MessageChannel</code> / <code>setImmediate</code> / <code>setTimeout</code> 实现 <strong>微任务/宏任务调度</strong>   。</li>\n<li>因此更新被<strong>异步</strong>   （微任务后）执行，实现“自动批处理”。</li>\n</ul>\n<hr>\n<ol start="3">\n<li>Scheduler 调度 → performConcurrentWorkOnRoot<br>\npackages/scheduler/src/Scheduler.js</li>\n</ol>\n<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unstable_scheduleCallback</span>(<span class="hljs-params">priorityLevel, callback</span>) {\n  <span class="hljs-keyword">const</span> currentTime = <span class="hljs-title function_">getCurrentTime</span>();\n  <span class="hljs-keyword">const</span> startTime = currentTime;\n\n  <span class="hljs-keyword">const</span> newTask = {\n    <span class="hljs-attr">id</span>: taskIdCounter++,\n    callback,\n    priorityLevel,\n    startTime,\n    <span class="hljs-attr">expirationTime</span>: startTime + <span class="hljs-title function_">timeoutForPriorityLevel</span>(priorityLevel),\n  };\n\n  <span class="hljs-comment">// 把任务 push 到 taskQueue，稍后 flush</span>\n  <span class="hljs-title function_">push</span>(taskQueue, newTask);\n  <span class="hljs-title function_">requestHostCallback</span>(flushWork); <span class="hljs-comment">// MessageChannel / setTimeout</span>\n}\n</code></pre>\n<ul>\n<li><code>requestHostCallback</code> 在下一次<strong>微任务/宏任务</strong>   里调用 <code>flushWork</code> → <code>performConcurrentWorkOnRoot</code>，真正完成 render + commit。</li>\n<li>因此<strong>所有 setState</strong>   无论写在 React 事件、setTimeout、Promise、原生事件里，都先被收集到同一个 <code>root</code>，然后<strong>统一</strong>   在微任务阶段 flush，实现“异步批处理”。</li>\n</ul>\n<hr>\n<ol start="4">\n<li>如何强制同步：flushSync<br>\npackages/react-dom/src/client/ReactDOM.js</li>\n</ol>\n<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> flushSync&lt;R&gt;(<span class="hljs-attr">fn</span>: <span class="hljs-function">() =&gt;</span> R): R {\n  <span class="hljs-comment">// 进入同步执行上下文</span>\n  <span class="hljs-keyword">const</span> prevExecutionContext = executionContext;\n  executionContext |= <span class="hljs-title class_">BatchedContext</span> | <span class="hljs-title class_">SyncContext</span>;\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 立即执行</span>\n  } <span class="hljs-keyword">finally</span> {\n    executionContext = prevExecutionContext;\n    <span class="hljs-title function_">flushSyncCallbacks</span>(); <span class="hljs-comment">// 立即 flush</span>\n  }\n}\n</code></pre>\n<ul>\n<li><code>flushSync</code> 会把 <code>executionContext</code> 打上 <code>SyncContext</code>，<code>scheduleUpdateOnFiber</code> 看到该标记就立刻 <code>flushSyncCallbacks</code>，跳出批处理。</li>\n</ul>\n<hr>\n<p>总结一句话<br>\nReact 18 的异步批处理 = <strong>Scheduler 微任务调度 + Lane 优先级模型</strong>   ：<br>\n任何 setState 都先挂到 root → <code>ensureRootIsScheduled</code> 用 <code>scheduleCallback</code> 把 flush 推迟到微任务 → 所有更新在一次渲染里完成；<br>\n需要同步时再用 <code>flushSync</code>。</p>\n</div>'</script></body></html>