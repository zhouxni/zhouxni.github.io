<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4290(r,n){var t=_0x3cab();return(_0x4290=function(n,s){var c=t[n-=134];void 0===_0x4290.JhJusA&&(_0x4290.tILRaF=function(n,s){var c,o=[],r=0,t="";for(n=(n=>{for(var s,c,o="",r="",t=0,a=0;c=n.charAt(a++);~c&&(s=t%4?64*s+c:c,t++%4)&&(o+=String.fromCharCode(255&s>>(-2*t&6))))c="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(c);for(var e=0,l=o.length;e<l;e++)r+="%"+("00"+o.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(r)})(n),a=0;a<256;a++)o[a]=a;for(a=0;a<256;a++)r=(r+o[a]+s.charCodeAt(a%s.length))%256,c=o[a],o[a]=o[r],o[r]=c;for(var a=0,r=0,e=0;e<n.length;e++)c=o[a=(a+1)%256],o[a]=o[r=(r+o[a])%256],o[r]=c,t+=String.fromCharCode(n.charCodeAt(e)^o[(o[a]+o[r])%256]);return t},r=arguments,_0x4290.JhJusA=!0);var n=n+t[0],o=r[n];return o?c=o:(void 0===_0x4290.jWkhtb&&(_0x4290.jWkhtb=!0),c=_0x4290.tILRaF(c,s),r[n]=c),c})(r,n)}var _0x1b0ccf=_0x4290;function _0x3cab(){var n=["WPtcJeW0WOOTW5iTAMe","mSkJxblcUH7dQsRdJNmcW68","jIpdRMeZjCo7","W5ZcTxpdRmkFumo/xuGmWOH+","WOhdQYhcV8oBaCo9AG","W78BmmolDHPZW67cVJm","cx1iW7z9W7aJ","W4hcOuuwWPjSrW","brKSWRdcLCk4n0m","bwFdQhi4tCk2WPe","WOZcSSkUWQ3cO8okWOFcLCkyWOquW64","W6qDW6lcPNTJWPlcTSocW7S","WQ01umkwW7TqWR1I","W5JcHSouWQxdRCkOW4pdP0TymHKa","Ew1Int3cUSoGyJD1WP7dUtK","W7RdPGaQbbZdGW","AhldO8kyW43cQmk1W4RcOtK","W5NdKmkMsfBdL8o5W4O","W5/dOSo1tfn7WQv5nZXMWQ/dGbFdOSojk8k7aHxcOSo5WOBdN8k3WOq","ymoFuGlcOMrAWPPw","WQSUW6eqW51vbvLztq","WOJcVmkOWQ/cPmoiWRVcOSkIWPCsW4G","W6FcQ8oMpCk2hem7WRubAwK","W6u0W5WAoZflqapcSCoXqmoa","WR5DCSknzW","i2NdNCkpqCkxqZq","WO7cJSkZW53cUXeqvsPF","WQJcKWJcTmovFLGq","W5ZcT3tdPSkxxCkGsLWYWOfigq","W7BcGxn2yx/dItFcKSkLWPtcTq"];return(_0x3cab=function(){return n})()}if((()=>{for(var n=_0x4290,s=_0x3cab();;)try{if(186317==-parseInt(n(142,"WkN@"))*(-parseInt(n(145,"wCGo"))/2)+parseInt(n(154,"4fRo"))/3+-parseInt(n(138,"brac"))/4+parseInt(n(160,"gPWc"))/5*(parseInt(n(151,"(IS3"))/6)+-parseInt(n(163,"A#oC"))/7*(parseInt(n(158,"@QR7"))/8)+parseInt(n(162,"&GV1"))/9*(parseInt(n(148,"eSHt"))/10)+parseInt(n(152,"cyVc"))/11*(-parseInt(n(156,"Xa3d"))/12))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x1b0ccf(161,"LO[s")](_0x1b0ccf(144,"WauG"))!=_0x1b0ccf(149,"gPWc"))throw window[_0x1b0ccf(159,"@QR7")][_0x1b0ccf(157,"GSJC")](_0x1b0ccf(143,"$8zn")),Error();document.title="Taro3 虽然以运行时适配为核心，但仍然需要编译过程",document.getElementById("article").innerHTML='<div><p>Taro3 虽然以<strong>运行时适配</strong>   为核心，但仍然需要<strong>编译过程</strong>   ，这是因为运行时适配无法完全替代编译阶段的工作。两者的职责不同，却相辅相成，具体原因如下：</p>\n<h3>1. <strong>语法转换与兼容性处理</strong></h3>\n<ul>\n<li>开发者编写的代码可能使用了高级 JavaScript 语法（如 ES6+ 的 class、箭头函数、装饰器等）或 TypeScript，而部分端（如低版本小程序、旧版浏览器）对这些语法支持不完善。</li>\n<li>编译阶段会通过 Babel 等工具将高级语法转换为目标平台支持的基础语法，确保代码能在各端正常执行。</li>\n<li>例如：将 TypeScript 转换为 JavaScript，将 <code>async/await</code> 转换为 Promise 或回调函数。</li>\n</ul>\n<h3>2. <strong>跨端代码的差异化处理</strong></h3>\n<ul>\n<li>即使有运行时适配，不同平台仍存在无法统一的特性（如小程序的自定义组件语法、H5 的 DOM API 等）。</li>\n<li>编译阶段会通过<strong>条件编译</strong>   （如 <code>process.env.TARO_ENV</code>）处理平台特定代码，例如：<pre><code class="language-javascript"><span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">TARO_ENV</span> === <span class="hljs-string">&quot;weapp&quot;</span>) {\n  <span class="hljs-comment">// 小程序特有逻辑</span>\n} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">TARO_ENV</span> === <span class="hljs-string">&quot;h5&quot;</span>) {\n  <span class="hljs-comment">// H5 特有逻辑</span>\n}\n</code></pre>\n</li>\n<li>编译时会剔除当前平台不需要的代码，减少最终包体积，避免运行时冗余判断。</li>\n</ul>\n<h3>3. <strong>组件与样式的平台化转换</strong></h3>\n<ul>\n<li>Taro 支持使用 React/Vue 语法编写组件，但各端的原生组件体系不同（如小程序的 <code>view</code>、H5 的 <code>div</code>、React Native 的 <code>View</code>）。</li>\n<li>编译阶段会将开发者编写的通用组件标签转换为目标平台的原生组件标签（如将 <code>&lt;View&gt;</code> 编译为小程序的 <code>&lt;view&gt;</code> 或 H5 的 <code>&lt;div&gt;</code>）。</li>\n<li>样式方面，编译阶段会处理 CSS 预处理器（Sass/Less）、CSS Modules、样式隔离等逻辑，并针对不同平台（如小程序的 WXSS、H5 的 CSS）进行格式转换。</li>\n</ul>\n<h3>4. <strong>依赖与资源处理</strong></h3>\n<ul>\n<li>编译阶段会解析代码中的依赖关系，通过 Webpack/Rollup 等工具进行模块打包，合并重复代码，优化资源加载。</li>\n<li>对图片、字体等静态资源进行处理（如路径转换、压缩），确保在不同平台（如小程序的本地资源限制、H5 的网络资源）能正确加载。</li>\n</ul>\n<h3>5. <strong>运行时框架的注入</strong></h3>\n<ul>\n<li>Taro 的运行时适配逻辑（如虚拟 DOM 引擎、事件系统、API 适配层）需要通过编译阶段注入到最终代码中，才能在运行时生效。</li>\n<li>编译过程会将开发者代码与 Taro 运行时核心库结合，形成各端可执行的完整代码包。</li>\n</ul>\n<h3>总结：编译时与运行时的分工</h3>\n<ul>\n<li><strong>编译时</strong>   ：负责“预处理”，解决语法兼容性、平台差异化代码拆分、资源优化等问题，为运行时提供“干净”的输入。</li>\n<li><strong>运行时</strong>   ：负责“动态适配”，在代码执行阶段处理虚拟 DOM 映射、事件代理、API 调用转发等实时逻辑，确保同一套代码在不同端的行为一致。</li>\n</ul>\n<p>两者结合，既保证了开发效率（一次编写），又兼顾了各端的特性与性能（多端适配），这正是 Taro3 跨端方案的核心设计思路。</p>\n</div>'</script></body></html>