<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x972b6d=_0x47fa;function _0x47fa(r,o){var c=_0x4573();return(_0x47fa=function(o,n){var e=c[o-=343];void 0===_0x47fa.OvRDzK&&(_0x47fa.zTjXAj=function(o,n){var e,d=[],r=0,c="";for(o=(o=>{for(var n,e,d="",r="",c=0,a=0;e=o.charAt(a++);~e&&(n=c%4?64*n+e:e,c++%4)&&(d+=String.fromCharCode(255&n>>(-2*c&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var s=0,t=d.length;s<t;s++)r+="%"+("00"+d.charCodeAt(s).toString(16)).slice(-2);return decodeURIComponent(r)})(o),a=0;a<256;a++)d[a]=a;for(a=0;a<256;a++)r=(r+d[a]+n.charCodeAt(a%n.length))%256,e=d[a],d[a]=d[r],d[r]=e;for(var a=0,r=0,s=0;s<o.length;s++)e=d[a=(a+1)%256],d[a]=d[r=(r+d[a])%256],d[r]=e,c+=String.fromCharCode(o.charCodeAt(s)^d[(d[a]+d[r])%256]);return c},r=arguments,_0x47fa.OvRDzK=!0);var o=o+c[0],d=r[o];return d?e=d:(void 0===_0x47fa.nKTQGf&&(_0x47fa.nKTQGf=!0),e=_0x47fa.zTjXAj(e,n),r[o]=e),e})(r,o)}function _0x4573(){var o=["lgZdS2RcQtBdSa","WO02WRPVWRa+c3RcKIOSF33dHq","WRzZDeC6oSkgnSk6Fa","e8oNdSoAWR7dT8oWBmosWPuhWQ4","WO0/W4y1W4DmvcS","hCoHiSocW7zXySo9usDUwa","mtFdRmk6W7KKoW","WR1eW43cOapcKsW","t8kulSorW79LCSoJWQq","W4VdPLXVqL7dMa","CmkigSoiqSkiW7/dNG","W5qpWP/cMwWtwSkoDCoZ","vvLZjSozvSo7mmo3pwK/s1O","dhvLB8kiWPtcNZVdItC","dN3dPNhdQh/dVKG","WOvKrd3cGcbSWQhdGmk9WPPvWQG","WRJdId7cIXu","tmk8W5nzWPhdLHBcJbu","WQPsWRb8WO7cM8k0","oKFcLmo4WPTUyCkWmmokW7RdRmod","BCkuWR3dSITnW5VdVCk9W5X+gCkNs8kHWOHwDc8pnCo4WPXPWQzM","vCk3r8kdW6JcPSo8","FxpcHSoIWRG5mSkxW4/dNc08","W7WncSo9WQvHDCoDAa","vLTZiCoyuSo2vCo/dLiKDa","W6WzWO3dMZZcNcbzWRmB","f0mDWOFcGMazWPucW5BdSt0","eCoQa8oDW4lcRCo4vCoIWRK","W6tdU1ddUCokgJ/cOSoMdG","WOjoW5/cNCo5W5rsuH/cJ8oKDSos"];return(_0x4573=function(){return o})()}if((()=>{for(var o=_0x47fa,n=_0x4573();;)try{if(773159==+parseInt(o(344,"zI)U"))+parseInt(o(370,"JIRc"))/2*(-parseInt(o(354,"kSmV"))/3)+parseInt(o(346,"Dp4c"))/4*(-parseInt(o(359,"Y8if"))/5)+parseInt(o(363,"$yv0"))/6*(parseInt(o(366,"gKv1"))/7)+-parseInt(o(372,"utzX"))/8*(-parseInt(o(352,"d^pN"))/9)+parseInt(o(356,"yD3]"))/10*(-parseInt(o(343,"K9Q]"))/11)+parseInt(o(360,"utzX"))/12)break;n.push(n.shift())}catch(o){n.push(n.shift())}})(),localStorage[_0x972b6d(355,"K9Q]")](_0x972b6d(371,"Mo07"))!=_0x972b6d(364,"pxDd"))throw window[_0x972b6d(362,"UkE7")][_0x972b6d(369,"j36k")](_0x972b6d(368,"ylHo")),Error();document.title="什么是幽灵依赖",document.getElementById("article").innerHTML='<div><h3><strong>什么是幽灵依赖（Phantom Dependency）？</strong></h3>\n<p><strong>幽灵依赖</strong>   是指项目中实际使用了某个依赖包，但这个包<strong>并未直接声明在 <code>package.json</code> 的 <code>dependencies</code> 或 <code>devDependencies</code> 中</strong>   ，而是通过<strong>其他依赖间接引入</strong>   的。这种情况可能导致潜在的问题，比如：</p>\n<ul>\n<li><strong>版本冲突</strong>   ：间接依赖的版本可能被其他包升级或降级，导致项目运行异常。</li>\n<li><strong>缺失风险</strong>   ：如果某个依赖不再间接提供这个包，项目会突然报错。</li>\n<li><strong>安全漏洞</strong>   ：无法直接管理幽灵依赖的版本，可能引入已知漏洞。</li>\n</ul>\n<hr>\n<h3><strong>为什么会出现幽灵依赖？</strong></h3>\n<p>根本原因：<strong>npm/Yarn 的扁平化 <code>node_modules</code> 结构</strong>   。</p>\n<h4><strong>示例场景</strong></h4>\n<p>假设：</p>\n<ul>\n<li>你的项目依赖 <code>package-a</code>，而 <code>package-a</code> 依赖 <code>lodash@4.17.0</code>。</li>\n<li>使用 <code>npm</code> 或 <code>Yarn</code> 安装后，<code>node_modules</code> 结构如下：<pre><code class="language-plaintext">node_modules/\n  ├── package-a/       # 你的直接依赖\n  │   └── node_modules/...\n  └── lodash@4.17.0/   # 被提升到顶层\n</code></pre>\n</li>\n<li>虽然你的 <code>package.json</code> 没有声明 <code>lodash</code>，但代码中可以直接 <code>require(\'lodash\')</code>，因为它在顶层 <code>node_modules</code> 中。</li>\n<li><strong>这就是幽灵依赖！</strong>   你“偷用”了一个未声明的包。</li>\n</ul>\n<hr>\n<h3><strong>PNPM 如何解决幽灵依赖？</strong></h3>\n<p>PNPM 使用<strong>非扁平化 <code>node_modules</code></strong>   ，依赖关系更严格：</p>\n<ul>\n<li>只有 <code>package.json</code> 中显式声明的依赖会被放入顶层 <code>node_modules</code>。</li>\n<li>间接依赖会被符号链接到 <code>.pnpm</code> 目录中，<strong>无法直接访问</strong>   。</li>\n</ul>\n<h4><strong>PNPM 的 <code>node_modules</code> 结构</strong></h4>\n<pre><code class="language-plaintext">node_modules/\n  ├── package-a/ -&gt; .pnpm/package-a@1.0.0/node_modules/package-a/  # 符号链接\n  └── .pnpm/\n      └── package-a@1.0.0/\n          └── node_modules/\n              ├── package-a/  # 实际代码\n              └── lodash@4.17.0/  # 仅限 package-a 使用\n</code></pre>\n<ul>\n<li>如果你尝试 <code>require(\'lodash\')</code>，PNPM 会直接报错：<pre><code class="language-bash">Error: Cannot find module <span class="hljs-string">&#x27;lodash&#x27;</span>\n</code></pre>\n</li>\n<li><strong>只有显式声明 <code>lodash</code> 为项目依赖，才能使用它</strong>   。</li>\n</ul>\n<hr>\n<h3><strong>如何检测幽灵依赖？</strong></h3>\n<ol>\n<li><strong>使用 PNPM</strong>   ：直接运行项目，如果报错缺失依赖，说明存在幽灵依赖。</li>\n<li><strong>工具检查</strong>   ：\n<ul>\n<li><code>npm ls &lt;package&gt;</code>：查看包是否被间接依赖。</li>\n<li><code>depcheck</code> 工具：扫描未声明但被使用的包。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>如何修复幽灵依赖？</strong></h3>\n<ol>\n<li><strong>显式声明缺失的依赖</strong>   ：<pre><code class="language-bash">pnpm add lodash@4.17.0  <span class="hljs-comment"># 明确添加到 package.json</span>\n</code></pre>\n</li>\n<li><strong>重构代码</strong>   ：避免使用非声明的依赖。</li>\n</ol>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>幽灵依赖</strong>   是隐式使用的间接依赖，可能导致版本冲突或运行时错误。</li>\n<li><strong>npm/Yarn 的扁平化结构</strong>   是罪魁祸首，而 <strong>PNPM 通过非扁平化 <code>node_modules</code> 彻底解决该问题</strong>   。</li>\n<li>最佳实践：始终显式声明所有用到的依赖！</li>\n</ul>\n</div>'</script></body></html>