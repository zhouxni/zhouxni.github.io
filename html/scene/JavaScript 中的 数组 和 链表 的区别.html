<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x52d9(){var s=["ocvmWOOcFmo5","ohDWWOdcOSoTWRVdNq","jg1GWPlcRW","WPBcKdPJhWNcLSomW64","W4ZdVCkse8k1o8kK","cmkrWPxdHCojtSkVxgqXtHHQEq","pvarW599zmoMWRjPW5/dVq","pgrQWPaThCoqW5JcJ8kLEaVcJW","ESkYsSoAWO5QsG","W7ujWRlcO0BcUexdGNS","WPNdJ21GesdcQW","rvDPFLTmDa","ySkMjmk7WOC4W4u+g8k8W59O","W7pdN8kOWQbLqCk6W7S5WRhdSq","WPqFsmkiESopWO9+WONdTgBdTq","W4rmW7znWPTakCo8W4HzkmoJWOz0","eSonBsesW77cGG","W5/cJbtcQ0CvfSkzdCoUWQrxCG","W6hcOqtdVdBdIHvFWP9YW4hcSCkQpwezrSkkcZHEcMZdUszr","WOdcImo8W7eMu8k7W5OL","W7ldMSkRWQvNf8kDW7SBWOxdIfC","v1rWW7CYDCk4","W4NcJ8oxymoHFmoXWRz4W5KMWPncWOi","gKVdT8o6W45GW707umo7W6RcPG","uW8RWQvnimkEW68CW5S6WOW","lSoNc8kNW4m6vNb6yCo7AW","gCoGycWgWRO9","WP7cLtm+AxtdKSkAW6nVWQGWtLy"];return(_0x52d9=function(){return s})()}var _0xf2060d=_0x5cee;function _0x5cee(l,s){var r=_0x52d9();return(_0x5cee=function(s,n){var a=r[s-=204];void 0===_0x5cee.IlpYlQ&&(_0x5cee.CjmjOY=function(s,n){var a,t=[],l=0,r="";for(s=(s=>{for(var n,a,t="",l="",r=0,e=0;a=s.charAt(e++);~a&&(n=r%4?64*n+a:a,r++%4)&&(t+=String.fromCharCode(255&n>>(-2*r&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,o=t.length;p<o;p++)l+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,p=0;p<s.length;p++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,r+=String.fromCharCode(s.charCodeAt(p)^t[(t[e]+t[l])%256]);return r},l=arguments,_0x5cee.IlpYlQ=!0);var s=s+r[0],t=l[s];return t?a=t:(void 0===_0x5cee.JVnFhu&&(_0x5cee.JVnFhu=!0),a=_0x5cee.CjmjOY(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x5cee,n=_0x52d9();;)try{if(758209==+parseInt(s(218,"@JHV"))*(parseInt(s(204,"(P9N"))/2)+parseInt(s(216,"pyYg"))/3*(-parseInt(s(229,"1JD@"))/4)+-parseInt(s(219,"vyoQ"))/5*(-parseInt(s(209,"pyYg"))/6)+-parseInt(s(206,"Eg@G"))/7*(parseInt(s(205,"pyYg"))/8)+-parseInt(s(213,"1c[n"))/9+parseInt(s(221,"lFn["))/10+parseInt(s(220,"*As$"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0xf2060d(214,"L6w!")](_0xf2060d(225,"vyoQ"))!=_0xf2060d(208,"[3E7"))throw window[_0xf2060d(207,"[3E7")][_0xf2060d(217,"o1iQ")](_0xf2060d(224,"QIuu")),Error();document.title="JavaScript 中的 数组 和 链表 的区别",document.getElementById("article").innerHTML='<div><p>JavaScript 中的 <strong>数组（Array）</strong>   和 <strong>链表（Linked List）</strong>   是两种不同的数据结构，它们在存储方式、操作效率和适用场景上有显著区别。以下是详细对比：</p>\n<hr>\n<h3><strong>1. 核心区别概述</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>数组（Array）</strong></th>\n<th><strong>链表（Linked List）</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>存储结构</strong></td>\n<td>连续内存空间</td>\n<td>非连续内存，通过指针（引用）连接节点</td>\n</tr>\n<tr>\n<td><strong>访问方式</strong></td>\n<td>随机访问（通过索引，时间复杂度 <code>O(1)</code>）</td>\n<td>顺序访问（从头遍历，时间复杂度 <code>O(n)</code>）</td>\n</tr>\n<tr>\n<td><strong>插入/删除效率</strong></td>\n<td>平均 <code>O(n)</code>（需移动元素）</td>\n<td>平均 <code>O(1)</code>（修改指针即可）</td>\n</tr>\n<tr>\n<td><strong>内存占用</strong></td>\n<td>紧凑，无额外开销</td>\n<td>每个节点需存储指针，内存占用更高</td>\n</tr>\n<tr>\n<td><strong>动态扩容</strong></td>\n<td>需重新分配内存（如 <code>push</code> 触发扩容）</td>\n<td>无需扩容，按需分配节点</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>2. 详细对比</strong></h3>\n<h4><strong>(1) 内存结构</strong></h4>\n<ul>\n<li>\n<p><strong>数组</strong>   ：</p>\n<ul>\n<li>元素存储在连续的内存块中。</li>\n<li>通过索引直接计算内存地址（如 <code>arr[2]</code> = 基地址 + 2 × 元素大小）。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]; <span class="hljs-comment">// 内存布局：[10][20][30]</span>\n</code></pre>\n</li>\n<li>\n<p><strong>链表</strong>   ：</p>\n<ul>\n<li>每个节点（Node）包含数据和指向下一个节点的指针（<code>next</code>）。</li>\n<li>节点分散在内存中，通过指针链接。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;\n  }\n}\n<span class="hljs-keyword">const</span> list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">10</span>);\nlist.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">20</span>); <span class="hljs-comment">// 内存布局不连续</span>\n</code></pre>\n</li>\n</ul>\n<h4><strong>(2) 访问元素</strong></h4>\n<ul>\n<li>\n<p><strong>数组</strong>   ：</p>\n<ul>\n<li>直接通过索引访问，时间复杂度 <code>O(1)</code>。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 输出 20（立即定位）</span>\n</code></pre>\n</li>\n<li>\n<p><strong>链表</strong>   ：</p>\n<ul>\n<li>必须从头节点开始逐个遍历，时间复杂度 <code>O(n)</code>。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getNode</span>(<span class="hljs-params">head, index</span>) {\n  <span class="hljs-keyword">let</span> current = head;\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {\n    current = current.<span class="hljs-property">next</span>; <span class="hljs-comment">// 逐个移动</span>\n  }\n  <span class="hljs-keyword">return</span> current.<span class="hljs-property">value</span>;\n}\n</code></pre>\n</li>\n</ul>\n<h4><strong>(3) 插入与删除</strong></h4>\n<ul>\n<li>\n<p><strong>数组</strong>   ：</p>\n<ul>\n<li><strong>插入</strong>   ：在中间插入需移动后续元素（<code>O(n)</code>）。<pre><code class="language-javascript">arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">15</span>); <span class="hljs-comment">// 在索引1插入15，后续元素后移</span>\n</code></pre>\n</li>\n<li><strong>删除</strong>   ：同样需要移动元素（<code>O(n)</code>）。</li>\n</ul>\n</li>\n<li>\n<p><strong>链表</strong>   ：</p>\n<ul>\n<li><strong>插入</strong>   ：只需修改相邻节点的指针（<code>O(1)</code>）。<pre><code class="language-javascript"><span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">15</span>);\nnewNode.<span class="hljs-property">next</span> = node1.<span class="hljs-property">next</span>; <span class="hljs-comment">// 插入到node1和node2之间</span>\nnode1.<span class="hljs-property">next</span> = newNode;\n</code></pre>\n</li>\n<li><strong>删除</strong>   ：直接修改指针跳过目标节点（<code>O(1)</code>）。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>(4) 动态扩容</strong></h4>\n<ul>\n<li>\n<p><strong>数组</strong>   ：</p>\n<ul>\n<li>JavaScript 数组是动态的，但 <code>push</code> 超出容量时需触发扩容（重新分配内存）。</li>\n<li>扩容成本高（通常按倍数增长，如 1.5× 或 2×）。</li>\n</ul>\n</li>\n<li>\n<p><strong>链表</strong>   ：</p>\n<ul>\n<li>无扩容概念，随时创建新节点并链接。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>3. JavaScript 中的实际表现</strong></h3>\n<h4><strong>(1) 数组的优化</strong></h4>\n<p>JavaScript 引擎（如 V8）对数组做了深度优化：</p>\n<ul>\n<li><strong>同构数组</strong>   （元素类型相同）：使用连续内存，访问极快。</li>\n<li><strong>异构数组</strong>   （混合类型）：退化为哈希表或链表结构，性能下降。</li>\n</ul>\n<h4><strong>(2) 链表的实现</strong></h4>\n<p>JavaScript 没有内置链表，需手动实现：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-literal">null</span>;\n  }\n  <span class="hljs-title function_">append</span>(<span class="hljs-params">value</span>) {\n    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value);\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode;\n    <span class="hljs-keyword">else</span> {\n      <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;\n      <span class="hljs-keyword">while</span> (current.<span class="hljs-property">next</span>) current = current.<span class="hljs-property">next</span>;\n      current.<span class="hljs-property">next</span> = newNode;\n    }\n  }\n}\n</code></pre>\n<hr>\n<h3><strong>4. 何时选择数组 vs 链表？</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>场景</strong></th>\n<th><strong>推荐结构</strong></th>\n<th><strong>理由</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>频繁随机访问</td>\n<td>数组</td>\n<td>索引访问速度快（如 <code>arr[100]</code>）</td>\n</tr>\n<tr>\n<td>频繁插入/删除（尤其是头部）</td>\n<td>链表</td>\n<td>无需移动元素（如实现队列、撤销操作）</td>\n</tr>\n<tr>\n<td>内存敏感</td>\n<td>数组</td>\n<td>链表每个节点需额外存储指针，内存占用高</td>\n</tr>\n<tr>\n<td>需要内置方法（如 <code>map</code>、<code>filter</code>）</td>\n<td>数组</td>\n<td>链表需手动实现高阶函数</td>\n</tr>\n<tr>\n<td>实现栈/队列</td>\n<td>均可</td>\n<td>数组对栈更优（<code>push/pop</code> 高效）；链表对队列更优（<code>shift</code> 在数组中慢）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>5. 性能测试示例</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 测试数组和链表的插入速度</span>\n<span class="hljs-keyword">const</span> arr = [];\n<span class="hljs-keyword">const</span> list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;Array Insert&quot;</span>);\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) {\n  arr.<span class="hljs-title function_">unshift</span>(i); <span class="hljs-comment">// 数组头部插入：O(n)</span>\n}\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&quot;Array Insert&quot;</span>); <span class="hljs-comment">// ~500ms</span>\n\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;LinkedList Insert&quot;</span>);\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) {\n  list.<span class="hljs-title function_">prepend</span>(i); <span class="hljs-comment">// 链表头部插入：O(1)</span>\n}\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&quot;LinkedList Insert&quot;</span>); <span class="hljs-comment">// ~10ms</span>\n</code></pre>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>数组</strong>   ：适合读多写少、需要快速随机访问的场景。</li>\n<li><strong>链表</strong>   ：适合写多读少、频繁插入/删除的场景。</li>\n<li><strong>JavaScript 现状</strong>   ：90% 的场景使用数组足够（引擎已优化），链表仅在特殊需求（如超大规模数据插入）时手动实现。</li>\n</ul>\n<p>根据实际需求选择，必要时可结合两者（如 JavaScript 的 <code>Array</code> 在底层可能自动切换为类链表结构优化性能）。</p>\n</div>'</script></body></html>