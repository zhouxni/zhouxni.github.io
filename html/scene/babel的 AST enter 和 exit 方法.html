<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0xf60c(){var n=["i8oHWPNdKCkagIfMwJNdQW","fSkWo8oADmk9W64","W5lcV8oUW7m/WPtcGSklW5ekWR3cMJCv","W6DnWQJcHhqhWPpdM2rTW5pcN0hdJq","W7XsW44FitRdVxTOWRW","W6vzrSoHW6BdTmkaWQqPAGa4kHe","WRvAW4ddT0afvSkilCkTWQG4EmoRW7breCo2W7ddKJ7cVI46kSo8","uSoCWPFdL8olr0VdRCkFACkX","wSk2W47cJCoeja9ava","d0tcMWD+WOHSpZVdT3y7","ASoHW6pcSwpcTmkwWRe1EG","cmobW5dcIHO","vCkRWRvDWR/cQLi","W4hcMSk7W5OWW6TvW6XTDxDA","DZRcTqlcV8oApCkYWQm","W4LHWOxdNh9LWOBcHCo+W7zhW6JdRSk0","WQKgW5tdOmkFumkbWR7cOG","oCoNW7ZdQSoBW7NdNCopamkm","W6DmWQ3cIxDXW4lcU0DNW7y","d8kcW4tcJ8kpAuldLq","W6xdV8kQWOiepmoQg8kHW7hcNmkOWPS","udNcImkwDSk6FG1pWQ1p","BL3cPCkhhSkBB03dI2a","W5VdTCo1WPRdGfizWO7dJbBdSq4Y"];return(_0xf60c=function(){return n})()}function _0xd56a(a,n){var o=_0xf60c();return(_0xd56a=function(n,s){var t=o[n-=444];void 0===_0xd56a.EHrWdC&&(_0xd56a.IcsFfj=function(n,s){var t,e=[],a=0,o="";for(n=(n=>{for(var s,t,e="",a="",o=0,c=0;t=n.charAt(c++);~t&&(s=o%4?64*s+t:t,o++%4)&&(e+=String.fromCharCode(255&s>>(-2*o&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var r=0,l=e.length;r<l;r++)a+="%"+("00"+e.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(a)})(n),c=0;c<256;c++)e[c]=c;for(c=0;c<256;c++)a=(a+e[c]+s.charCodeAt(c%s.length))%256,t=e[c],e[c]=e[a],e[a]=t;for(var c=0,a=0,r=0;r<n.length;r++)t=e[c=(c+1)%256],e[c]=e[a=(a+e[c])%256],e[a]=t,o+=String.fromCharCode(n.charCodeAt(r)^e[(e[c]+e[a])%256]);return o},a=arguments,_0xd56a.EHrWdC=!0);var n=n+o[0],e=a[n];return e?t=e:(void 0===_0xd56a.VraOxp&&(_0xd56a.VraOxp=!0),t=_0xd56a.IcsFfj(t,s),a[n]=t),t})(a,n)}var _0x2472db=_0xd56a;if((()=>{for(var n=_0xd56a,s=_0xf60c();;)try{if(675392==-parseInt(n(464,"[nBv"))+-parseInt(n(465,"#w0#"))/2*(parseInt(n(455,"pKuv"))/3)+-parseInt(n(447,"F7FF"))/4+-parseInt(n(458,"eqPP"))/5*(-parseInt(n(461,"pZcv"))/6)+-parseInt(n(451,"(cx@"))/7+-parseInt(n(454,"1YAa"))/8+parseInt(n(466,"gKj9"))/9)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x2472db(463,"16PM")](_0x2472db(459,"(cx@"))!=_0x2472db(462,"Hv3K"))throw window[_0x2472db(446,"eqPP")][_0x2472db(452,"SQLd")](_0x2472db(457,"99[!")),Error();document.title="babel的 AST enter 和 exit 方法",document.getElementById("article").innerHTML='<div><p>Babel 的插件系统基于抽象语法树（AST）转换，其中 <code>enter</code> 和 <code>exit</code> 是访问器（Visitor）模式中的两个关键方法。理解它们的工作机制对于编写 Babel 插件至关重要。</p>\n<h3><strong>1. 访问器（Visitor）模式</strong></h3>\n<p>Babel 插件通过定义访问器对象来遍历和修改 AST。每个节点类型（如 <code>FunctionDeclaration</code>、<code>Identifier</code>）都可以有对应的 <code>enter</code> 和 <code>exit</code> 方法。</p>\n<h4><strong>基本结构</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">visitor</span>: {\n      <span class="hljs-comment">// 节点类型（如 FunctionDeclaration）</span>\n      <span class="hljs-title class_">FunctionDeclaration</span>(path) {\n        <span class="hljs-comment">// 处理逻辑</span>\n      },\n      \n      <span class="hljs-comment">// 等价于</span>\n      <span class="hljs-title class_">FunctionDeclaration</span>: {\n        <span class="hljs-title function_">enter</span>(<span class="hljs-params">path</span>) { <span class="hljs-comment">/* 进入节点时执行 */</span> },\n        <span class="hljs-title function_">exit</span>(<span class="hljs-params">path</span>) { <span class="hljs-comment">/* 离开节点时执行 */</span> }\n      }\n    }\n  };\n}\n</code></pre>\n<h3><strong>2. <code>enter</code> 方法</strong></h3>\n<ul>\n<li><strong>触发时机</strong>  ：在遍历到节点的开始位置时调用。</li>\n<li><strong>用途</strong>  ：\n<ul>\n<li>收集信息（如变量定义、函数参数）。</li>\n<li>提前修改节点（如重命名标识符）。</li>\n<li>终止或跳过子节点的遍历（通过 <code>path.skip()</code>）。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>示例：统计函数声明数量</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> counter = {\n  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,\n  <span class="hljs-attr">visitor</span>: {\n    <span class="hljs-title class_">FunctionDeclaration</span>: {\n      <span class="hljs-title function_">enter</span>(<span class="hljs-params">path</span>) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++; <span class="hljs-comment">// 进入函数节点时计数</span>\n      }\n    }\n  }\n};\n</code></pre>\n<h3><strong>3. <code>exit</code> 方法</strong></h3>\n<ul>\n<li><strong>触发时机</strong>  ：在遍历完节点的所有子节点后调用。</li>\n<li><strong>用途</strong>  ：\n<ul>\n<li>确保子节点处理完成后再进行操作（如替换整个节点）。</li>\n<li>处理依赖子节点结果的逻辑（如计算表达式值）。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>示例：替换箭头函数为普通函数</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> arrowFunctionTransformer = {\n  <span class="hljs-attr">visitor</span>: {\n    <span class="hljs-title class_">ArrowFunctionExpression</span>: {\n      <span class="hljs-title function_">exit</span>(<span class="hljs-params">path</span>) {\n        <span class="hljs-comment">// 在所有子节点处理完成后，将箭头函数转换为普通函数</span>\n        path.<span class="hljs-title function_">replaceWith</span>(<span class="hljs-comment">/* 转换后的节点 */</span>);\n      }\n    }\n  }\n};\n</code></pre>\n<h3><strong>4. 执行顺序</strong></h3>\n<p>当遍历一个嵌套的 AST 时，<code>enter</code> 和 <code>exit</code> 的调用顺序类似于递归：</p>\n<pre><code>父节点 enter\n  子节点 enter\n    孙节点 enter\n    孙节点 exit\n  子节点 exit\n父节点 exit\n</code></pre>\n<h4><strong>示例代码</strong></h4>\n<p>假设有以下 AST 结构：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) {\n  <span class="hljs-keyword">return</span> a + b;\n}\n</code></pre>\n<p>遍历顺序为：</p>\n<ol>\n<li><code>FunctionDeclaration</code> enter</li>\n<li><code>Identifier</code> (add) enter/exit</li>\n<li><code>Identifier</code> (a) enter/exit</li>\n<li><code>Identifier</code> (b) enter/exit</li>\n<li><code>ReturnStatement</code> enter</li>\n<li><code>BinaryExpression</code> enter</li>\n<li><code>Identifier</code> (a) enter/exit</li>\n<li><code>Identifier</code> (b) enter/exit</li>\n<li><code>BinaryExpression</code> exit</li>\n<li><code>ReturnStatement</code> exit</li>\n<li><code>FunctionDeclaration</code> exit</li>\n</ol>\n<h3><strong>5. 常见应用场景</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>场景</strong></th>\n<th><strong>使用 <code>enter</code></strong></th>\n<th><strong>使用 <code>exit</code></strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>变量重命名</td>\n<td>直接修改标识符节点</td>\n<td>确保所有引用都被更新后再修改</td>\n</tr>\n<tr>\n<td>节点替换</td>\n<td>立即替换节点（可能影响子节点遍历）</td>\n<td>在子节点处理完成后替换</td>\n</tr>\n<tr>\n<td>收集作用域信息</td>\n<td>进入作用域时记录变量</td>\n<td>离开作用域时验证变量使用</td>\n</tr>\n<tr>\n<td>性能优化</td>\n<td>尽早终止不需要的遍历</td>\n<td>批量处理复杂转换</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>6. 注意事项</strong></h3>\n<ul>\n<li><strong>修改节点</strong>  ：在 <code>enter</code> 中修改节点可能导致子节点无法正确遍历，而 <code>exit</code> 更适合替换整个节点。</li>\n<li><strong>状态管理</strong>  ：避免在 <code>enter</code>/<code>exit</code> 中使用全局状态，推荐通过 <code>path.scope</code> 或插件实例管理状态。</li>\n<li><strong>跳过遍历</strong>  ：使用 <code>path.skip()</code> 可终止当前节点的子节点遍历（仅影响 <code>enter</code>）。</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong><code>enter</code></strong>  ：适合预处理、信息收集或快速修改。</li>\n<li><strong><code>exit</code></strong>  ：适合依赖子节点处理结果的操作或全局转换。</li>\n</ul>\n<p>合理使用 <code>enter</code> 和 <code>exit</code> 能让 Babel 插件更高效、更健壮。</p>\n</div>'</script></body></html>