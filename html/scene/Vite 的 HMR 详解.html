<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x24b2(p,s){var l=_0x11ce();return(_0x24b2=function(s,n){var a=l[s-=222];void 0===_0x24b2.LaFpty&&(_0x24b2.YhnIri=function(s,n){var a,t=[],p=0,l="";for(s=(s=>{for(var n,a,t="",p="",l=0,o=0;a=s.charAt(o++);~a&&(n=l%4?64*n+a:a,l++%4)&&(t+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=t.length;c<r;c++)p+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),o=0;o<256;o++)t[o]=o;for(o=0;o<256;o++)p=(p+t[o]+n.charCodeAt(o%n.length))%256,a=t[o],t[o]=t[p],t[p]=a;for(var o=0,p=0,c=0;c<s.length;c++)a=t[o=(o+1)%256],t[o]=t[p=(p+t[o])%256],t[p]=a,l+=String.fromCharCode(s.charCodeAt(c)^t[(t[o]+t[p])%256]);return l},p=arguments,_0x24b2.LaFpty=!0);var s=s+l[0],t=p[s];return t?a=t:(void 0===_0x24b2.oTSBQE&&(_0x24b2.oTSBQE=!0),a=_0x24b2.YhnIri(a,n),p[s]=a),a})(p,s)}var _0x3278a0=_0x24b2;if((()=>{for(var s=_0x24b2,n=_0x11ce();;)try{if(882752==-parseInt(s(225,"fS(a"))+parseInt(s(239,"wmKo"))/2+parseInt(s(235,"#)Tg"))/3+parseInt(s(238,"MgDU"))/4+parseInt(s(232,"ylQo"))/5+parseInt(s(233,"5Fb8"))/6*(-parseInt(s(241,"MQt)"))/7)+-parseInt(s(229,"MQt)"))/8)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3278a0(231,"vDX)")](_0x3278a0(222,"@QZ#"))!=_0x3278a0(226,"vi9#"))throw window[_0x3278a0(237,"MgDU")][_0x3278a0(240,"5Fb8")](_0x3278a0(223,"DuL^")),Error();function _0x11ce(){var s=["mqLkW4C9lx/cLXVdNSopmf0","Chv5W77dQNeeWPqQ","hKNcJLDZW4T9D0HycruzWOddVSkJWRyhWQhdPmkWW4FdImo4qCki","pMXiW659a8o/W7/cOwFdJuuE","oM5jW656cCkmW47cGKldTMe","W6rAW7BcTCkD","fq5vuxmvWQvUgSojnre","oM9jW6T4d8o/WO/cJhRdRMSfhG","qCoyW48feLhcTSkoEcFdNaBcLmol","lSoGW5Lna8oZW73cJSk2bbhdJ8o8","W4NdIvpdRwWQrq","bMehW5yOn8o8WQekW5BcR8o/uq","WRpdSmounmkxjMTUcepcRG","prKEFq1GW6tcMKW","DhNdTtetW6egW41KW6FcNtHQ","lSoMW5Lha8kwWR3cI8kNeci","CSofixHPletcRG","k8kzDY8QFr/cIdiAWR3cM8kG","CmkQWRHvxYimW57cV8kqjaq","W7dcP8kqA8ooexS","r8oAW4PcuGVdJSo3ua","ECkUWR5xxcqXW5pcRSkvpHq"];return(_0x11ce=function(){return s})()}document.title="Vite 的 HMR 详解",document.getElementById("article").innerHTML='<div><p>Vite 的 HMR（Hot Module Replacement）是其提升开发体验的核心特性之一，它通过<strong>原生 ESM 模块系统</strong>  和<strong>智能文件监听</strong>  实现了毫秒级的模块更新。以下是其工作原理的详细解析：</p>\n<h3><strong>1. 整体架构</strong></h3>\n<p>Vite 的 HMR 系统由三部分组成：</p>\n<ol>\n<li><strong>文件系统监听</strong>  ：Vite 服务器监听文件变化</li>\n<li><strong>WebSocket 通信</strong>  ：服务器与浏览器建立实时连接</li>\n<li><strong>模块运行时</strong>  ：浏览器端的 HMR 运行时代码处理更新</li>\n</ol>\n<pre><code class="language-mermaid">sequenceDiagram\n    participant 编辑器 as 代码编辑器\n    participant 服务器 as Vite 服务器\n    participant 浏览器 as 浏览器\n    编辑器-&gt;&gt;服务器: 文件修改事件\n    服务器-&gt;&gt;服务器: 差异编译（仅修改的文件）\n    服务器-&gt;&gt;浏览器: WebSocket 推送更新消息\n    浏览器-&gt;&gt;浏览器: 执行 import.meta.hot.accept 处理更新\n    浏览器-&gt;&gt;浏览器: 动态加载新模块替换旧模块\n</code></pre>\n<h3><strong>2. 关键技术实现</strong></h3>\n<h4><strong>① 基于原生 ESM 的模块系统</strong></h4>\n<p>Vite 利用浏览器原生支持的 ES 模块规范（<code>import/export</code>），无需打包即可直接运行代码。这使得 HMR 可以精确替换单个模块，而不是像 Webpack 那样重新构建整个模块链。</p>\n<p><strong>示例代码转换</strong>  ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 原始代码</span>\n<span class="hljs-keyword">import</span> { sum } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;\n\n<span class="hljs-comment">// Vite 处理后（开发环境）</span>\n<span class="hljs-keyword">import</span> { sum } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/@fs/path/to/math.js?v=123&#x27;</span>;\n</code></pre>\n<ul>\n<li><code>v=123</code> 是模块版本号，变化时触发浏览器重新加载</li>\n</ul>\n<h4><strong>② 文件监听与差异编译</strong></h4>\n<ul>\n<li><strong>Chokidar</strong>  ：Vite 使用 Chokidar 监听文件系统变化</li>\n<li><strong>按需编译</strong>  ：当文件修改时，Vite 仅编译该文件，不重新构建整个项目</li>\n<li><strong>内存文件系统</strong>  ：编译结果存储在内存中，无需写入磁盘</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// Vite 监听文件变化的核心逻辑</span>\nwatcher.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-title function_">async</span> (file) =&gt; {\n  <span class="hljs-comment">// 1. 检查文件是否在项目中</span>\n  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isProjectFile</span>(file)) <span class="hljs-keyword">return</span>;\n  \n  <span class="hljs-comment">// 2. 重新编译修改的文件</span>\n  <span class="hljs-keyword">const</span> updatedModule = <span class="hljs-keyword">await</span> <span class="hljs-title function_">compileModule</span>(file);\n  \n  <span class="hljs-comment">// 3. 推送更新到浏览器</span>\n  <span class="hljs-title function_">sendUpdateToClient</span>(updatedModule);\n});\n</code></pre>\n<h4><strong>③ WebSocket 实时通信</strong></h4>\n<p>Vite 服务器与浏览器通过 WebSocket 建立长连接，实现双向通信：</p>\n<ul>\n<li><strong>更新消息</strong>  ：服务器 → 浏览器（模块更新通知）</li>\n<li><strong>心跳检测</strong>  ：双向（保持连接，检测断线）</li>\n</ul>\n<p><strong>更新消息格式</strong>  ：</p>\n<pre><code class="language-json"><span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;update&quot;</span><span class="hljs-punctuation">,</span>\n  <span class="hljs-attr">&quot;updates&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>\n    <span class="hljs-punctuation">{</span>\n      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;js-update&quot;</span><span class="hljs-punctuation">,</span>\n      <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/src/components/Button.js&quot;</span><span class="hljs-punctuation">,</span>\n      <span class="hljs-attr">&quot;acceptedPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/src/components/Button.js&quot;</span><span class="hljs-punctuation">,</span>\n      <span class="hljs-attr">&quot;timestamp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1623456789</span>\n    <span class="hljs-punctuation">}</span>\n  <span class="hljs-punctuation">]</span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n<h4><strong>④ 浏览器端 HMR 运行时</strong></h4>\n<p>每个模块都包含特殊的 HMR 接口 <code>import.meta.hot</code>，用于处理模块更新：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 组件模块中的 HMR 处理逻辑</span>\n<span class="hljs-keyword">if</span> (<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">hot</span>) {\n  <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">accept</span>(<span class="hljs-function">(<span class="hljs-params">newModule</span>) =&gt;</span> {\n    <span class="hljs-comment">// 1. 替换当前模块</span>\n    <span class="hljs-title function_">updateComponent</span>(newModule);\n    \n    <span class="hljs-comment">// 2. 可选：保留组件状态</span>\n    <span class="hljs-title function_">preserveState</span>();\n  });\n}\n</code></pre>\n<h3><strong>3. 状态保持机制</strong></h3>\n<p>Vite 通过<strong>代理组件</strong>  和<strong>状态快照</strong>  实现 HMR 时的状态保持：</p>\n<h4><strong>① 函数组件状态保持</strong></h4>\n<ul>\n<li>Vite 在组件外部维护一个状态容器</li>\n<li>HMR 时替换组件实现，但保持状态容器引用</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// 伪代码：Vite 如何保持函数组件状态</span>\n<span class="hljs-keyword">let</span> currentState = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(currentState.<span class="hljs-property">count</span>);\n  \n  <span class="hljs-comment">// 保存状态到外部容器</span>\n  currentState.<span class="hljs-property">count</span> = count;\n  \n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;{count}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n}\n</code></pre>\n<h4><strong>② 自定义状态保持</strong></h4>\n<p>开发者可通过 <code>import.meta.hot</code> API 手动控制状态保存和恢复：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">hot</span>) {\n  <span class="hljs-comment">// 模块卸载前保存状态</span>\n  <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">dispose</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {\n    data.<span class="hljs-property">state</span> = currentFormData;\n  });\n  \n  <span class="hljs-comment">// 模块更新后恢复状态</span>\n  <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">accept</span>(<span class="hljs-function">(<span class="hljs-params">newModule</span>) =&gt;</span> {\n    newModule.<span class="hljs-title function_">initialize</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">hot</span>.<span class="hljs-property">data</span>.<span class="hljs-property">state</span>);\n  });\n}\n</code></pre>\n<h3><strong>4. 错误处理与恢复</strong></h3>\n<p>Vite 的 HMR 系统具有健壮的错误处理能力：</p>\n<ul>\n<li><strong>错误隔离</strong>  ：单个模块的错误不会影响其他模块</li>\n<li><strong>Overlay 提示</strong>  ：在浏览器中显示错误信息，不刷新页面</li>\n<li><strong>自动恢复</strong>  ：修复错误后，自动应用更新而无需重启服务器</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// Vite 错误处理逻辑</span>\n<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {\n  <span class="hljs-comment">// 1. 在浏览器中显示错误 Overlay</span>\n  <span class="hljs-title function_">showErrorOverlay</span>(err);\n  \n  <span class="hljs-comment">// 2. 监听文件变化，错误修复后自动恢复</span>\n  watcher.<span class="hljs-title function_">once</span>(<span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-title function_">hideErrorOverlay</span>();\n  });\n});\n</code></pre>\n<h3><strong>5. 性能优化</strong></h3>\n<p>Vite 通过多项技术确保 HMR 的极致性能：</p>\n<ol>\n<li><strong>预构建依赖</strong>  ：启动时预构建第三方模块，HMR 时直接使用缓存</li>\n<li><strong>增量编译</strong>  ：仅重新编译修改的文件</li>\n<li><strong>按需更新</strong>  ：只推送浏览器需要的更新内容</li>\n<li><strong>内存缓存</strong>  ：频繁修改的文件缓存编译结果</li>\n</ol>\n<p><strong>性能数据</strong>  ：</p>\n<ul>\n<li>小型项目 HMR 延迟：30-80ms</li>\n<li>大型项目 HMR 延迟：100-300ms（对比 Webpack 的 5-10s）</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<p>Vite 的 HMR 之所以高效，核心在于：</p>\n<ol>\n<li><strong>利用原生 ESM</strong>  ：无需打包即可实现模块级更新</li>\n<li><strong>精准文件监听</strong>  ：只处理变化的文件，不重建整个项目</li>\n<li><strong>智能状态管理</strong>  ：自动保持组件状态，减少开发干扰</li>\n<li><strong>轻量级通信</strong>  ：WebSocket 消息精简，传输效率高</li>\n</ol>\n<p>这种设计让 Vite 在大型项目中依然能保持秒级启动和毫秒级更新，显著提升开发体验。</p>\n</div>'</script></body></html>