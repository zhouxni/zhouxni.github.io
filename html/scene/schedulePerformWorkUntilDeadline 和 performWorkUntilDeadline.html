<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x44a8(l,n){var a=_0x95ae();return(_0x44a8=function(n,s){var e=a[n-=147];void 0===_0x44a8.ODQdya&&(_0x44a8.VWqGsv=function(n,s){var e,o=[],l=0,a="";for(n=(n=>{for(var s,e,o="",l="",a=0,t=0;e=n.charAt(t++);~e&&(s=a%4?64*s+e:e,a++%4)&&(o+=String.fromCharCode(255&s>>(-2*a&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var r=0,c=o.length;r<c;r++)l+="%"+("00"+o.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(n),t=0;t<256;t++)o[t]=t;for(t=0;t<256;t++)l=(l+o[t]+s.charCodeAt(t%s.length))%256,e=o[t],o[t]=o[l],o[l]=e;for(var t=0,l=0,r=0;r<n.length;r++)e=o[t=(t+1)%256],o[t]=o[l=(l+o[t])%256],o[l]=e,a+=String.fromCharCode(n.charCodeAt(r)^o[(o[t]+o[l])%256]);return a},l=arguments,_0x44a8.ODQdya=!0);var n=n+a[0],o=l[n];return o?e=o:(void 0===_0x44a8.HRyvDj&&(_0x44a8.HRyvDj=!0),e=_0x44a8.VWqGsv(e,s),l[n]=e),e})(l,n)}function _0x95ae(){var n=["CCkiCxBcSSo+W5e","WReqWP5sW5uAW45SWPVcSM0","W5ZdPmo1W4DkEmoWrZXYbM/cLq","rfTTiSoJvCkUeY8Td8k+DW","WOnkW6uCW51qCmom","WQNcSmkGWPmnp8klBtq","bgFcKmkZWQ1SWRtcL13dIdO","W4elW7WSW7W","qv9VlmoTwCo3gIyJlmkl","wSkavmkPvSo+W7lcKW","WRxcJ1GRACofAG","W4FdKCkTWPfxWQP0WP7cQCorkLC","eazrf8kZWQZdPtldTSo7DZNcRq","dCocWQLizZxdMd84W5SxWONdQG","lYytWO3cTIb5W53cUCkQW7/cKColW6qrymk5CSoMre0tW6LHW5ZcRq","aSoyd8o7fSosW7RcUKxcM8ol","WQBdKCodW7VdSCkQaxrOWRmmCCoq","euZdMmowWOaYzmkTWQVcPtJdUYK","r2/dImkrW6zXdmoaWOPFWPy","fvWoFSoXW7VcLW","d8ohWQ9ezt3dLq4wW6efWORdTa","DmoslH/dSmkPWQpcRCkscmopWQ04","eKdcG8kfW5/cPCoWWP4","WO3dLLhcSSoNBJu"];return(_0x95ae=function(){return n})()}var _0x4eb1ce=_0x44a8;if((()=>{for(var n=_0x44a8,s=_0x95ae();;)try{if(398432==+parseInt(n(154,"Ri]&"))+-parseInt(n(152,"hA09"))/2*(parseInt(n(168,"^N]l"))/3)+-parseInt(n(164,"#F8h"))/4+parseInt(n(163,"]%DB"))/5*(parseInt(n(170,"qBp)"))/6)+-parseInt(n(166,"9f4$"))/7+parseInt(n(162,"AG!j"))/8+-parseInt(n(158,"A52%"))/9)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x4eb1ce(156,"DC@b")](_0x4eb1ce(151,"y5jI"))!=_0x4eb1ce(153,"MA^t"))throw window[_0x4eb1ce(155,"6UVk")][_0x4eb1ce(169,")Z6b")](_0x4eb1ce(160,"t0&O")),Error();document.title="schedulePerformWorkUntilDeadline 和 performWorkUntilDeadline",document.getElementById("article").innerHTML='<div><p><code>schedulePerformWorkUntilDeadline</code> 和 <code>performWorkUntilDeadline</code> 是 React 调度器（Scheduler）中的两个关键函数，用于实现<strong>时间切片（Time Slicing）</strong>  和<strong>可中断渲染</strong>  。它们的核心作用是在浏览器的每一帧（如 <code>requestIdleCallback</code> 的模拟）中高效地分配和执行任务。</p>\n<hr>\n<h2><strong>1. <code>schedulePerformWorkUntilDeadline</code></strong></h2>\n<h3><strong>作用</strong></h3>\n<ul>\n<li><strong>调度任务</strong>  ：安排 <code>performWorkUntilDeadline</code> 在下一个事件循环中执行（通常使用 <code>MessageChannel</code> 或 <code>setImmediate</code> 等高效 API）。</li>\n<li><strong>避免阻塞主线程</strong>  ：确保任务在浏览器的空闲时段执行，防止长时间占用主线程导致页面卡顿。</li>\n</ul>\n<h3><strong>实现逻辑</strong></h3>\n<ol>\n<li><strong>选择调度器</strong>  ：\n<ul>\n<li>优先使用 <code>MessageChannel</code>（高效无延迟）。</li>\n<li>降级方案：<code>setImmediate</code>（Node.js）或 <code>setTimeout</code>（兼容性兜底）。</li>\n</ul>\n</li>\n<li><strong>触发回调</strong>  ：\n<ul>\n<li>通过 <code>port.postMessage()</code> 或 <code>setTimeout</code> 将 <code>performWorkUntilDeadline</code> 推入事件循环。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>伪代码</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">schedulePerformWorkUntilDeadline</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (isMessageChannelSupported) {\n    <span class="hljs-comment">// 使用 MessageChannel 调度</span>\n    <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>();\n    channel.<span class="hljs-property">port1</span>.<span class="hljs-property">onmessage</span> = performWorkUntilDeadline;\n    channel.<span class="hljs-property">port2</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-literal">null</span>);\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 降级到 setTimeout</span>\n    <span class="hljs-built_in">setTimeout</span>(performWorkUntilDeadline, <span class="hljs-number">0</span>);\n  }\n}\n</code></pre>\n<hr>\n<h2><strong>2. <code>performWorkUntilDeadline</code></strong></h2>\n<h3><strong>作用</strong></h3>\n<ul>\n<li><strong>执行任务</strong>  ：在调度后运行，处理当前时间切片内的任务。</li>\n<li><strong>检查时间限制</strong>  ：\n<ul>\n<li>使用 <code>performance.now()</code> 计算已用时间。</li>\n<li>如果超过 <code>5ms</code>（默认时间切片长度），则暂停并重新调度剩余任务（实现可中断渲染）。</li>\n</ul>\n</li>\n<li><strong>循环处理任务</strong>  ：\n<ul>\n<li>从任务队列中取出任务执行，直到时间耗尽或队列为空。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>关键逻辑</strong></h3>\n<ol>\n<li><strong>记录开始时间</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> startTime = performance.<span class="hljs-title function_">now</span>();\n</code></pre>\n</li>\n<li><strong>循环执行任务</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">while</span> (currentTask !== <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-title function_">shouldYieldToHost</span>()) {\n  <span class="hljs-comment">// 执行单个任务</span>\n  <span class="hljs-keyword">const</span> didUserCallbackTimeout = <span class="hljs-comment">/* 检查任务是否超时 */</span>;\n  <span class="hljs-keyword">const</span> continuationCallback = <span class="hljs-title function_">currentTask</span>(didUserCallbackTimeout);\n  \n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> continuationCallback === <span class="hljs-string">&#x27;function&#x27;</span>) {\n    <span class="hljs-comment">// 如果任务返回 continuation，说明未完成，保留后续处理</span>\n    currentTask = continuationCallback;\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// 任务完成，移出队列</span>\n    <span class="hljs-title function_">popTaskQueue</span>();\n  }\n}\n</code></pre>\n</li>\n<li><strong>检查是否应该让出主线程</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldYieldToHost</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> performance.<span class="hljs-title function_">now</span>() - startTime &gt; <span class="hljs-number">5</span>; <span class="hljs-comment">// 超过 5ms 就让出控制权</span>\n}\n</code></pre>\n</li>\n<li><strong>如果还有剩余任务，重新调度</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">if</span> (currentTask !== <span class="hljs-literal">null</span>) {\n  <span class="hljs-title function_">schedulePerformWorkUntilDeadline</span>(); <span class="hljs-comment">// 继续调度</span>\n}\n</code></pre>\n</li>\n</ol>\n<hr>\n<h2><strong>对比总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n<th>调用时机</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>schedulePerformWorkUntilDeadline</code></td>\n<td><strong>调度任务</strong>  ，安排 <code>performWorkUntilDeadline</code> 在下一个事件循环执行</td>\n<td>当有新任务或任务未完成时调用</td>\n</tr>\n<tr>\n<td><code>performWorkUntilDeadline</code></td>\n<td><strong>执行任务</strong>  ，处理当前时间切片内的任务，超时则暂停</td>\n<td>由 <code>schedulePerformWorkUntilDeadline</code> 触发</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>为什么这样设计？</strong></h2>\n<ol>\n<li><strong>避免 <code>setTimeout</code> 的延迟问题</strong>\n<ul>\n<li><code>MessageChannel</code> 比 <code>setTimeout(fn, 0)</code> 更快，减少任务调度的延迟。</li>\n</ul>\n</li>\n<li><strong>模拟 <code>requestIdleCallback</code></strong>\n<ul>\n<li>由于 <code>requestIdleCallback</code> 兼容性和触发频率问题，React 自己实现类似的时间切片机制。</li>\n</ul>\n</li>\n<li><strong>可中断渲染</strong>\n<ul>\n<li>通过 <code>shouldYieldToHost()</code> 检查时间，确保浏览器有机会处理高优先级任务（如用户输入）。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2><strong>应用场景</strong></h2>\n<ul>\n<li><strong>React Fiber 架构</strong>  ：<code>performWorkUntilDeadline</code> 是 React 调度任务的核心，支持并发模式（Concurrent Mode）。</li>\n<li><strong>批量更新优化</strong>  ：在事件循环中合理分配任务，避免一次性执行太多工作导致页面卡顿。</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><code>schedulePerformWorkUntilDeadline</code> → <strong>调度</strong>  （高效安排任务）。</li>\n<li><code>performWorkUntilDeadline</code> → <strong>执行</strong>  （控制时间切片，避免阻塞）。</li>\n</ul>\n<p>这种设计使得 React 能够在不阻塞主线程的情况下，高效地处理渲染和更新任务。</p>\n</div>'</script></body></html>