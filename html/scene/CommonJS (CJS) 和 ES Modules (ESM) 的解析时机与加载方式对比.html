<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x41ffe1=_0x49fe;if((()=>{for(var s=_0x49fe,n=_0x3a32();;)try{if(350512==+parseInt(s(452,"9*v&"))*(parseInt(s(462,"NMuI"))/2)+-parseInt(s(445,")#XU"))/3+-parseInt(s(444,"A1Vm"))/4+-parseInt(s(450,"isz5"))/5+parseInt(s(451,"dHqo"))/6+-parseInt(s(464,"MWO2"))/7*(parseInt(s(459,"u5yc"))/8)+-parseInt(s(461,"9*v&"))/9*(-parseInt(s(465,"0U&*"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x41ffe1(458,"NMuI")](_0x41ffe1(460,"&I7j"))!=_0x41ffe1(467,"0U&*"))throw window[_0x41ffe1(453,"RMj9")][_0x41ffe1(448,"MWO2")](_0x41ffe1(455,"Sfu4")),Error();function _0x49fe(a,s){var r=_0x3a32();return(_0x49fe=function(s,n){var t=r[s-=444];void 0===_0x49fe.rUMxcS&&(_0x49fe.TbbsOD=function(s,n){var t,o=[],a=0,r="";for(s=(s=>{for(var n,t,o="",a="",r=0,e=0;t=s.charAt(e++);~t&&(n=r%4?64*n+t:t,r++%4)&&(o+=String.fromCharCode(255&n>>(-2*r&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var l=0,c=o.length;l<c;l++)a+="%"+("00"+o.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(a)})(s),e=0;e<256;e++)o[e]=e;for(e=0;e<256;e++)a=(a+o[e]+n.charCodeAt(e%n.length))%256,t=o[e],o[e]=o[a],o[a]=t;for(var e=0,a=0,l=0;l<s.length;l++)t=o[e=(e+1)%256],o[e]=o[a=(a+o[e])%256],o[a]=t,r+=String.fromCharCode(s.charCodeAt(l)^o[(o[e]+o[a])%256]);return r},a=arguments,_0x49fe.rUMxcS=!0);var s=s+r[0],o=a[s];return o?t=o:(void 0===_0x49fe.xXQfvw&&(_0x49fe.xXQfvw=!0),t=_0x49fe.TbbsOD(t,n),a[s]=t),t})(a,s)}function _0x3a32(){var s=["WOGlWPhdTCkjq8o4FmoJWPZdJIi1","FCoUCmkJqK/cRLVcLa","qG7dIe58WOTS","W73cVgeOW7aByq","W4lcScZdO0WeWQriWPtdImoQWOO","m2ldGmkWW53dLdu","W5OJWPdcKCohWQxcR8oIWQxcGCkIW6xdNG","sSoPptVcT8kfeq","WP1KW5ddLCkn","tuCJW63dTCoaW6rccYe0tq","WQ0QWQmMWOzRc8kLimoLWR94","fsBdUxTaW6uhzmovW7JcMSkk","AcnNW4xcSbhdKSojkbLCx8kT","WP7cKvSFW6ldQWdcPxlcGmoVesK","DMtdTCkQW5BdGqK","zSoGW7NcU20apZqbECkDuq","W4eQhvnmWPqWqurqWOhcSSkn","iZuLWQWpWRD5bSoCW449xa","sedcVrWrW41/r8k9jtBdKa","WRWdW68ti0eUW7G","W7ZdMSo+WRpdJLa6","z23cLdVcU0W2W5VdQ8oTESosomkuqGVcQKRdLsaCW689WRfVbG","WRVdKCoGW5tdPmkqW5a","W7RcJmkkW7dcKrnrvfFcTmknW63dGq","WQJcUhSRW5a8wW"];return(_0x3a32=function(){return s})()}document.title="CommonJS (CJS) 和 ES Modules (ESM) 的解析时机与加载方式对比",document.getElementById("article").innerHTML='<div><h3><strong>CommonJS (CJS) 和 ES Modules (ESM) 的解析时机与加载方式对比</strong></h3>\n<hr>\n<h2><strong>1. 解析时机（何时确定依赖关系）</strong></h2>\n<table>\n<thead>\n<tr>\n<th><strong>模块系统</strong></th>\n<th><strong>解析时机</strong></th>\n<th><strong>特点</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>CommonJS</strong></td>\n<td><strong>运行时动态解析</strong></td>\n<td>代码执行到 <code>require()</code> 时才加载并解析模块（边执行边分析依赖）。</td>\n</tr>\n<tr>\n<td><strong>ESM</strong></td>\n<td><strong>编译时静态解析</strong></td>\n<td>在代码执行前，先扫描所有 <code>import</code>/<code>export</code> 语句，构建完整的依赖关系图。</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>CommonJS（运行时解析）</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// commonjs.cjs</span>\n<span class="hljs-keyword">if</span> (condition) {\n  <span class="hljs-keyword">const</span> moduleA = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./moduleA&quot;</span>); <span class="hljs-comment">// 只有执行到这里才会加载 moduleA</span>\n}\n</code></pre>\n<ul>\n<li><strong>优点</strong>   ：灵活，可根据条件动态加载模块。</li>\n<li><strong>缺点</strong>   ：无法提前优化依赖，性能较差。</li>\n</ul>\n<h3><strong>ESM（编译时解析）</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// esm.mjs</span>\n<span class="hljs-keyword">import</span> { foo } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./moduleB.mjs&quot;</span>; <span class="hljs-comment">// 在代码执行前已解析好依赖</span>\n\n<span class="hljs-comment">// ❌ 错误：import 不能嵌套在条件语句中</span>\n<span class="hljs-keyword">if</span> (condition) {\n  <span class="hljs-keyword">import</span> { bar } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./moduleC.mjs&quot;</span>; <span class="hljs-comment">// SyntaxError</span>\n}\n</code></pre>\n<ul>\n<li><strong>优点</strong>   ：工具（如 Webpack）可提前优化依赖，支持 Tree Shaking。</li>\n<li><strong>缺点</strong>   ：无法动态条件导入（需改用 <code>import()</code>）。</li>\n</ul>\n<hr>\n<h2><strong>2. 加载方式（如何获取模块内容）</strong></h2>\n<table>\n<thead>\n<tr>\n<th><strong>模块系统</strong></th>\n<th><strong>加载方式</strong></th>\n<th><strong>特点</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>CommonJS</strong></td>\n<td><strong>同步加载</strong></td>\n<td><code>require()</code> 会阻塞线程，直到模块加载完成（适用于 Node.js 文件系统）。</td>\n</tr>\n<tr>\n<td><strong>ESM</strong></td>\n<td><strong>异步加载</strong></td>\n<td>模块下载、初始化是非阻塞的，支持 <code>Top-Level Await</code>。</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>CommonJS（同步加载）</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// commonjs.cjs</span>\n<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>); <span class="hljs-comment">// 同步读取文件，阻塞后续代码</span>\n<span class="hljs-keyword">const</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;./file.txt&quot;</span>); <span class="hljs-comment">// 同步操作</span>\n</code></pre>\n<ul>\n<li><strong>Node.js 适用</strong>   ：因为文件 I/O 是同步的（但现代 Node.js 也支持异步 <code>fs.promises</code>）。</li>\n<li><strong>浏览器不适用</strong>   ：浏览器加载脚本必须异步（网络请求）。</li>\n</ul>\n<h3><strong>ESM（异步加载）</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// esm.mjs</span>\n<span class="hljs-keyword">import</span> { readFile } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;node:fs/promises&quot;</span>; <span class="hljs-comment">// 异步 API</span>\n\n<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./file.txt&quot;</span>); <span class="hljs-comment">// 非阻塞</span>\n</code></pre>\n<ul>\n<li><strong>浏览器原生支持</strong>   ：通过 <code>&lt;script type=&quot;module&quot;&gt;</code> 异步加载。</li>\n<li><strong>Node.js 也异步</strong>   ：即使本地文件系统，ESM 规范要求异步初始化。</li>\n</ul>\n<hr>\n<h2><strong>3. 互操作性</strong></h2>\n<h3><strong>(1) ESM 可以导入 CommonJS</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// esm.mjs</span>\n<span class="hljs-keyword">import</span> cjsModule <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./commonjs.cjs&quot;</span>; <span class="hljs-comment">// CJS 的 module.exports 作为 default</span>\n<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> cjs <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./commonjs.cjs&quot;</span>; <span class="hljs-comment">// 通过 cjs.default 访问导出</span>\n</code></pre>\n<ul>\n<li><strong>限制</strong>   ：CJS 的命名导出需通过 <code>default</code> 解构：<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { named } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./commonjs.cjs&quot;</span>; <span class="hljs-comment">// ❌ 错误</span>\n<span class="hljs-keyword">import</span> cjs <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./commonjs.cjs&quot;</span>;\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cjs.<span class="hljs-property">named</span>); <span class="hljs-comment">// ✅ 正确</span>\n</code></pre>\n</li>\n</ul>\n<h3><strong>(2) CommonJS 不能直接导入 ESM</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// commonjs.cjs</span>\n<span class="hljs-keyword">const</span> esmModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./esm.mjs&quot;</span>); <span class="hljs-comment">// ❌ 报错 [ERR_REQUIRE_ESM]</span>\n</code></pre>\n<ul>\n<li><strong>解决方案</strong>   ：用 <code>import()</code> 动态加载（返回 Promise）：<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadESM</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> esmModule = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./esm.mjs&quot;</span>);\n}\n</code></pre>\n</li>\n</ul>\n<hr>\n<h2><strong>4. 总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>CommonJS</strong></th>\n<th><strong>ES Modules (ESM)</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>解析时机</strong></td>\n<td>运行时动态解析</td>\n<td>编译时静态解析</td>\n</tr>\n<tr>\n<td><strong>加载方式</strong></td>\n<td>同步（阻塞）</td>\n<td>异步（非阻塞）</td>\n</tr>\n<tr>\n<td><strong>动态导入</strong></td>\n<td><code>require()</code>（同步）</td>\n<td><code>import()</code>（异步）</td>\n</tr>\n<tr>\n<td><strong>顶层 <code>await</code></strong></td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td><strong>浏览器支持</strong></td>\n<td>需打包工具转换</td>\n<td>原生支持（<code>&lt;script type=&quot;module&quot;&gt;</code>）</td>\n</tr>\n<tr>\n<td><strong>Node.js 支持</strong></td>\n<td>原生支持</td>\n<td>需 <code>.mjs</code> 或 <code>&quot;type&quot;: &quot;module&quot;</code></td>\n</tr>\n</tbody>\n</table>\n<h3><strong>选择建议</strong></h3>\n<ul>\n<li><strong>新项目</strong>   ：优先使用 ESM（现代浏览器和 Node.js 均原生支持）。</li>\n<li><strong>旧项目迁移</strong>   ：逐步替换 <code>require</code> 为 <code>import</code>，或用工具（Babel）转换。</li>\n<li><strong>动态加载</strong>   ：ESM 用 <code>import()</code>，CJS 用 <code>require()</code>。</li>\n</ul>\n</div>'</script></body></html>