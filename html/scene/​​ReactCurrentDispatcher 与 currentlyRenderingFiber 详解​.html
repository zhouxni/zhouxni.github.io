<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4922f4=_0x1358;function _0x1358(t,n){var r=_0x4da9();return(_0x1358=function(n,s){var a=r[n-=288];void 0===_0x1358.dJsJVq&&(_0x1358.JVQNcO=function(n,s){var a,e=[],t=0,r="";for(n=(n=>{for(var s,a,e="",t="",r=0,l=0;a=n.charAt(l++);~a&&(s=r%4?64*s+a:a,r++%4)&&(e+=String.fromCharCode(255&s>>(-2*r&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=e.length;o<c;o++)t+="%"+("00"+e.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(t)})(n),l=0;l<256;l++)e[l]=l;for(l=0;l<256;l++)t=(t+e[l]+s.charCodeAt(l%s.length))%256,a=e[l],e[l]=e[t],e[t]=a;for(var l=0,t=0,o=0;o<n.length;o++)a=e[l=(l+1)%256],e[l]=e[t=(t+e[l])%256],e[t]=a,r+=String.fromCharCode(n.charCodeAt(o)^e[(e[l]+e[t])%256]);return r},t=arguments,_0x1358.dJsJVq=!0);var n=n+r[0],e=t[n];return e?a=e:(void 0===_0x1358.FaNqzX&&(_0x1358.FaNqzX=!0),a=_0x1358.JVQNcO(a,s),t[n]=a),a})(t,n)}if((()=>{for(var n=_0x1358,s=_0x4da9();;)try{if(544406==-parseInt(n(308,"&1@2"))+parseInt(n(302,"tszW"))/2+parseInt(n(298,"O7e5"))/3+-parseInt(n(291,"y[n2"))/4*(-parseInt(n(306,"IopS"))/5)+parseInt(n(300,"zt8^"))/6+parseInt(n(307,"zMhv"))/7*(-parseInt(n(294,"&CBf"))/8)+-parseInt(n(288,"YGpE"))/9)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x4922f4(299,"y[n2")](_0x4922f4(309,"RgHn"))!=_0x4922f4(292,"QDQS"))throw window[_0x4922f4(290,"]u^E")][_0x4922f4(295,"b)]O")](_0x4922f4(310,"V3ex")),Error();function _0x4da9(){var n=["FmoXbYeMWQVdHIRdP3vWWOuA","emoHEIC+W7av","uSkflJJdPSkxW7FdGCo7W7ddRSo2sG","WQjyFCosW6NdRmkdtW","sSkIW4VdRSkIWPmMe8o/WOXjW65z","zYrqqvpcLmkTg8o0W77cKmkBza","W5RdLSoXcmobyXiaW7XlqmoA","sSkLWPpcJSorW61Giq","vSovWPxdU8k1WOFdUrG","yrZdQZ9RCHtdLq","WOdcL8okcmodWPTFnW7dNSkHW7u","zSknW5NcMs/cMCkrWRzR","WRxdK0tdIv7cUmkjeajElf7dPXpcP3bTWQFdMSksWRXLzHnlga","W5hdJIqPW4ZcUSo5W73dRmkVgZS","gfLcW4vlW5NcHh9lwgLjWO8","W7OdfSk7xWhdUCk3W7FcVXpcV2W","nx0OW4pcKSo7t8kV","rmk3pLD4W4eaW4hcT8kfjq","W5blW5CnDq","fCoBWO7dHwNdNmoIWRf2aCoVW64B","omkUW7XDW502WPJdOMW0W5fl","vG7cVSowW5D8yG","W6v6W5LMW6bnnWPHWR17W40o","y8kyiCohoNThAW/cO8o1"];return(_0x4da9=function(){return n})()}document.title="​​ReactCurrentDispatcher 与 currentlyRenderingFiber 详解​",document.getElementById("article").innerHTML='<div><p><strong>ReactCurrentDispatcher 与 currentlyRenderingFiber 详解</strong></p>\n<p>这两个是 React Fiber 架构中的核心全局变量，用于 管理 Hooks 的调用上下文 和 追踪当前渲染的组件。它们共同确保 Hooks 在正确的阶段调用，并维护组件状态的一致性。</p>\n<hr>\n<p><strong>1. <code>ReactCurrentDispatcher</code>：Hooks 的调度器</strong><br>\n<strong>作用</strong></p>\n<ul>\n<li>\n<p>决定当前可以调用哪些 Hooks（如 <code>useState</code>、<code>useEffect</code>）。</p>\n</li>\n<li>\n<p>在开发环境下提供详细的错误提示（如非法调用 Hook 时）。</p>\n</li>\n</ul>\n<p><strong>实现原理</strong></p>\n<ul>\n<li>\n<p>是一个全局对象，存储当前可用的 Hooks 实现。</p>\n</li>\n<li>\n<p>根据不同的渲染阶段切换不同的 dispatcher（调度器）。</p>\n</li>\n</ul>\n<p><strong>源码结构（简化）</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ReactCurrentDispatcher</span> = {\n  <span class="hljs-attr">current</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 当前生效的 Hooks 调度器</span>\n};\n</code></pre>\n<p><strong>Dispatcher 的类型</strong></p>\n<table>\n<thead>\n<tr>\n<th>调度器类型</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>HooksDispatcherOnMount</code></td>\n<td>组件首次渲染时使用的 Hooks 实现</td>\n</tr>\n<tr>\n<td><code>HooksDispatcherOnUpdate</code></td>\n<td>组件更新时使用的 Hooks 实现</td>\n</tr>\n<tr>\n<td><code>ContextOnlyDispatcher</code></td>\n<td>非法调用 Hooks 时抛出错误（开发环境专用）</td>\n</tr>\n</tbody>\n</table>\n<p><strong>工作流程</strong></p>\n<ol>\n<li>组件渲染前，React 设置对应的 dispatcher：<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderWithHooks</span>(<span class="hljs-params">Component, props</span>) {\n  <span class="hljs-title class_">ReactCurrentDispatcher</span>.<span class="hljs-property">current</span> =\n    current === <span class="hljs-literal">null</span> ? <span class="hljs-title class_">HooksDispatcherOnMount</span> : <span class="hljs-title class_">HooksDispatcherOnUpdate</span>;\n  <span class="hljs-keyword">const</span> children = <span class="hljs-title class_">Component</span>(props); <span class="hljs-comment">// 执行组件函数</span>\n  <span class="hljs-title class_">ReactCurrentDispatcher</span>.<span class="hljs-property">current</span> = <span class="hljs-title class_">ContextOnlyDispatcher</span>; <span class="hljs-comment">// 重置</span>\n  <span class="hljs-keyword">return</span> children;\n}\n</code></pre>\n</li>\n<li>调用 Hook 时，会从 <code>ReactCurrentDispatcher.current</code> 获取实现：<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useState</span>(<span class="hljs-params">initialState</span>) {\n  <span class="hljs-keyword">const</span> dispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>.<span class="hljs-property">current</span>;\n  <span class="hljs-keyword">return</span> dispatcher.<span class="hljs-title function_">useState</span>(initialState);\n}\n</code></pre>\n</li>\n<li>如果在非组件函数中调用 Hook，<code>dispatcher</code> 为 <code>null</code> 或 <code>ContextOnlyDispatcher</code>，会报错：<pre><code>Invalid hook call. Hooks can only be called inside a function component.\n</code></pre>\n</li>\n</ol>\n<hr>\n<p><strong>2. <code>currentlyRenderingFiber</code>：当前渲染的 Fiber 节点</strong><br>\n<strong>作用</strong></p>\n<ul>\n<li>\n<p>指向 当前正在渲染的 Fiber 节点，用于关联 Hooks 状态。</p>\n</li>\n<li>\n<p>维护 Hook 的链表结构（通过 <code>fiber.memoizedState</code>）。</p>\n</li>\n</ul>\n<p><strong>源码结构（简化）</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> currentlyRenderingFiber = <span class="hljs-literal">null</span>;\n</code></pre>\n<p><strong>关键用途</strong></p>\n<ol>\n<li>存储 Hooks 链表<br>\n每个 Hook 调用会被添加到 Fiber 节点的 <code>memoizedState</code> 链表：<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mountWorkInProgressHook</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> hook = { <span class="hljs-attr">memoizedState</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> };\n  <span class="hljs-keyword">if</span> (currentlyRenderingFiber.<span class="hljs-property">memoizedState</span> === <span class="hljs-literal">null</span>) {\n    currentlyRenderingFiber.<span class="hljs-property">memoizedState</span> = hook; <span class="hljs-comment">// 链表头</span>\n  } <span class="hljs-keyword">else</span> {\n    workInProgressHook.<span class="hljs-property">next</span> = hook; <span class="hljs-comment">// 链接到上一个 Hook</span>\n  }\n  <span class="hljs-keyword">return</span> hook;\n}\n</code></pre>\n</li>\n<li>校验 Hook 调用合法性<br>\n如果 <code>currentlyRenderingFiber</code> 为 <code>null</code>，说明不在渲染阶段，调用 Hook 会报错。</li>\n</ol>\n<hr>\n<p><strong>3. 两者的协作关系</strong><br>\n<strong>完整渲染流程</strong></p>\n<ol>\n<li>开始渲染组件<pre><code class="language-javascript">currentlyRenderingFiber = workInProgress; <span class="hljs-comment">// 设置当前 Fiber</span>\n<span class="hljs-title class_">ReactCurrentDispatcher</span>.<span class="hljs-property">current</span> = <span class="hljs-title class_">HooksDispatcherOnMount</span>; <span class="hljs-comment">// 设置调度器</span>\n</code></pre>\n</li>\n<li>执行组件函数</li>\n</ol>\n<ul>\n<li>\n<p>调用 <code>useState</code>、<code>useEffect</code> 时，会通过 <code>ReactCurrentDispatcher.current</code> 获取实现。</p>\n<ul>\n<li>Hook 状态被挂载到 <code>currentlyRenderingFiber.memoizedState</code>。</li>\n</ul>\n</li>\n</ul>\n<ol start="3">\n<li>渲染结束<pre><code class="language-javascript">currentlyRenderingFiber = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清除引用</span>\n<span class="hljs-title class_">ReactCurrentDispatcher</span>.<span class="hljs-property">current</span> = <span class="hljs-title class_">ContextOnlyDispatcher</span>; <span class="hljs-comment">// 防止非法调用</span>\n</code></pre>\n</li>\n</ol>\n<p><strong>错误检测示例</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useState</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (currentlyRenderingFiber === <span class="hljs-literal">null</span>) {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Hooks can only be called during rendering.&quot;</span>);\n  }\n  <span class="hljs-keyword">const</span> dispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>.<span class="hljs-property">current</span>;\n  <span class="hljs-keyword">return</span> dispatcher.<span class="hljs-title function_">useState</span>();\n}\n</code></pre>\n<hr>\n<p><strong>4. 生产环境优化</strong></p>\n<ul>\n<li>\n<p>移除校验逻辑：生产环境下会移除 <code>currentlyRenderingFiber</code> 和 <code>ReactCurrentDispatcher</code> 的校验代码，仅保留核心功能。</p>\n</li>\n<li>\n<p>压缩变量名：<code>currentlyRenderingFiber</code> 会被压缩为更短的变量名（如 <code>c</code>）。</p>\n</li>\n</ul>\n<hr>\n<p><strong>5. 总结</strong></p>\n<table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>作用</th>\n<th>生命周期</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ReactCurrentDispatcher</code></td>\n<td>控制可用的 Hooks 实现，防止非法调用</td>\n<td>组件渲染期间生效</td>\n</tr>\n<tr>\n<td><code>currentlyRenderingFiber</code></td>\n<td>存储当前组件的 Hook 链表，关联状态与组件</td>\n<td>组件渲染期间生效</td>\n</tr>\n</tbody>\n</table>\n<p>核心规则：</p>\n<ul>\n<li>\n<p>Hooks 必须在这两个变量生效时（即函数组件渲染期间）调用。</p>\n</li>\n<li>\n<p>React 通过它们实现 Hooks 的调用顺序一致性和状态隔离。</p>\n</li>\n</ul>\n</div>'</script></body></html>