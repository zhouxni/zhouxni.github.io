<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x55b7(e,o){var i=_0x55fc();return(_0x55b7=function(o,t){var n=i[o-=418];void 0===_0x55b7.SpcPsY&&(_0x55b7.CtIoIX=function(o,t){var n,r=[],e=0,i="";for(o=(o=>{for(var t,n,r="",e="",i=0,d=0;n=o.charAt(d++);~n&&(t=i%4?64*t+n:n,i++%4)&&(r+=String.fromCharCode(255&t>>(-2*i&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,l=r.length;c<l;c++)e+="%"+("00"+r.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(o),d=0;d<256;d++)r[d]=d;for(d=0;d<256;d++)e=(e+r[d]+t.charCodeAt(d%t.length))%256,n=r[d],r[d]=r[e],r[e]=n;for(var d=0,e=0,c=0;c<o.length;c++)n=r[d=(d+1)%256],r[d]=r[e=(e+r[d])%256],r[e]=n,i+=String.fromCharCode(o.charCodeAt(c)^r[(r[d]+r[e])%256]);return i},e=arguments,_0x55b7.SpcPsY=!0);var o=o+i[0],r=e[o];return r?n=r:(void 0===_0x55b7.CxFlNt&&(_0x55b7.CxFlNt=!0),n=_0x55b7.CtIoIX(n,t),e[o]=n),n})(e,o)}function _0x55fc(){var o=["uSkAWPxcUtlcP8kkW4LqW5y","x8kztY5YW6NdSvy4WOy+FW","WOZdGIJcTSoLh8oOjmoHW43cK1S","xSkDtY1YW6JdKw4QWPyKAa","EXmdWRyVW5OhW5JdNmoJW4eU","WOKBc8oPlCo8lSoW","EHCdWRuVW5SNW6ddJSoZW5S5","hmouW6/dJmkCDd5EF8oP","W5Sbn1i1W4hdJ08","W4H5f8o9vCodBa","sZVcO2pdQ1ldOmoRW4KtgWtcTa","W4HLf8kWvmoRiIS","WPxcR8kHW7/cRSkHW7vUW4RdTHNcUYW","zCoyW6lcGmowWQtcPKWRDKG+W7C","WPJcJ0TVoSoldXLQWOxcUmoKhq","Erv/W4zYWOCkW6i","WORdImozWQlcHIzEW6pcUrKaAwu","cH1yvConmsRdHf8","W59Pemohwa","W63cJSkbW4aCWPxdPSoHWQddGa","WOZdKCkEC8kVWR/dPSohqCoVWOBcTWe","W515e8oyqmofza","WRXQr8ktzNNcNCkCnmo/AXC","dGVdPqeEDa7cP0ZcVSklm8oUrCkHjf1BWPtcKZNdGmkzjuLC","W5fsiwqZpmkTW6G","WRRdJSoEW5zqWOldMs4TW7C"];return(_0x55fc=function(){return o})()}var _0x1f352e=_0x55b7;if((()=>{for(var o=_0x55b7,t=_0x55fc();;)try{if(230710==+parseInt(o(423,"mY6l"))+-parseInt(o(425,"r19R"))/2*(parseInt(o(426,"zsxk"))/3)+parseInt(o(439,"&7V8"))/4*(-parseInt(o(427,"5zpi"))/5)+parseInt(o(428,"iYru"))/6*(-parseInt(o(442,"#pR)"))/7)+parseInt(o(433,"xs^m"))/8+parseInt(o(430,"A#xF"))/9+parseInt(o(440,"R0*i"))/10)break;t.push(t.shift())}catch(o){t.push(t.shift())}})(),localStorage[_0x1f352e(429,"EWnb")](_0x1f352e(437,"]XH*"))!=_0x1f352e(438,"EWnb"))throw window[_0x1f352e(431,"2qsH")][_0x1f352e(441,"EWnb")](_0x1f352e(443,"n95U")),Error();document.title="React 的 Fiber 架构中 FiberRoot 和 RootFiber",document.getElementById("article").innerHTML="<div><p>在 React 的 Fiber 架构中，<strong>FiberRoot</strong>   和 <strong>RootFiber</strong>   是两个不同但密切相关的概念，它们分别代表应用的不同层级结构。以下是它们的详细区别和联系：</p>\n<h3><strong>1. FiberRoot（根节点）</strong></h3>\n<ul>\n<li><strong>定义</strong>  ：FiberRoot 是整个 React 应用的根容器，是 React 内部创建的第一个对象，由 <code>ReactDOM.createRoot()</code> 或旧版 <code>ReactDOM.render()</code> 初始化。</li>\n<li><strong>作用</strong>  ：\n<ul>\n<li>管理应用的生命周期（如更新调度、错误边界）。</li>\n<li>存储应用的状态和上下文信息。</li>\n<li>连接 React 内部与宿主环境（如浏览器 DOM）。</li>\n</ul>\n</li>\n<li><strong>关键属性</strong>  ：\n<ul>\n<li><code>current</code>：指向当前激活的 RootFiber。</li>\n<li><code>containerInfo</code>：存储宿主环境的容器信息（如浏览器中的 DOM 节点）。</li>\n<li><code>pendingChildren</code>：等待处理的新 JSX 元素。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>2. RootFiber（根 Fiber 节点）</strong></h3>\n<ul>\n<li><strong>定义</strong>  ：RootFiber 是 Fiber 树的根节点，是一个特殊的 Fiber 节点，类型为 <code>HostRoot</code>，由 React 自动创建。</li>\n<li><strong>作用</strong>  ：\n<ul>\n<li>作为整个 Fiber 树的起点，管理子 Fiber 节点的创建和更新。</li>\n<li>协调应用的渲染过程（如调度、中断、恢复）。</li>\n</ul>\n</li>\n<li><strong>关键属性</strong>  ：\n<ul>\n<li><code>stateNode</code>：指向 FiberRoot。</li>\n<li><code>child</code>：指向第一个子 Fiber 节点（通常是应用的根组件）。</li>\n<li><code>alternate</code>：指向内存中的另一个 Fiber 副本（用于双缓存机制）。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>3. 两者的关系</strong></h3>\n<ul>\n<li><strong>FiberRoot 包含 RootFiber</strong>  ：FiberRoot 的 <code>current</code> 属性指向当前的 RootFiber。</li>\n<li><strong>RootFiber 关联 FiberRoot</strong>  ：RootFiber 的 <code>stateNode</code> 属性指向创建它的 FiberRoot。</li>\n<li><strong>双缓存机制</strong>  ：RootFiber 有一个 <code>alternate</code> 属性，指向内存中的另一个副本，用于在渲染过程中进行比较和交换，实现高效的更新。</li>\n</ul>\n<h3><strong>4. 示例结构</strong></h3>\n<pre><code>// FiberRoot 对象\n{\n  current: RootFiber,\n  containerInfo: &lt;div id=&quot;root&quot; /&gt;, // 浏览器 DOM 容器\n  // 其他属性...\n}\n\n// RootFiber 对象（HostRoot 类型）\n{\n  type: 'HostRoot',\n  stateNode: FiberRoot,\n  child: AppComponentFiber, // 应用根组件\n  alternate: RootFiber,     // 双缓存中的另一个副本\n  // 其他 Fiber 属性...\n}\n</code></pre>\n<h3><strong>5. 为什么需要两者分离？</strong></h3>\n<ul>\n<li><strong>关注点分离</strong>  ：\n<ul>\n<li><strong>FiberRoot</strong>   负责与宿主环境（如 DOM）通信，管理应用全局状态。</li>\n<li><strong>RootFiber</strong>   专注于 Fiber 树的协调和渲染逻辑。</li>\n</ul>\n</li>\n<li><strong>双缓存优化</strong>  ：通过 RootFiber 的 <code>alternate</code> 实现高效的渲染和回滚机制，避免频繁创建新对象。</li>\n<li><strong>跨平台支持</strong>  ：FiberRoot 可以适配不同宿主环境（如浏览器、React Native），而 RootFiber 保持核心算法一致。</li>\n</ul>\n<h3><strong>6. 常见误区</strong></h3>\n<ul>\n<li>❌ <strong>混淆两者概念</strong>  ：FiberRoot 是应用根容器，RootFiber 是 Fiber 树的根节点。</li>\n<li>❌ <strong>认为它们是同一个对象</strong>  ：它们通过属性互相引用，但属于不同层级的抽象。</li>\n<li>❌ <strong>手动操作它们</strong>  ：FiberRoot 和 RootFiber 是 React 内部实现细节，不建议开发者直接访问或修改。</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>对比项</strong></th>\n<th><strong>FiberRoot</strong></th>\n<th><strong>RootFiber</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>类型</strong></td>\n<td>应用根容器对象</td>\n<td>特殊的 Fiber 节点（HostRoot）</td>\n</tr>\n<tr>\n<td><strong>作用</strong></td>\n<td>管理应用生命周期，连接宿主环境</td>\n<td>协调 Fiber 树的渲染过程</td>\n</tr>\n<tr>\n<td><strong>关键属性</strong></td>\n<td><code>current</code>, <code>containerInfo</code></td>\n<td><code>stateNode</code>, <code>child</code>, <code>alternate</code></td>\n</tr>\n<tr>\n<td><strong>创建方式</strong></td>\n<td>由 <code>ReactDOM.createRoot()</code> 创建</td>\n<td>由 React 自动创建</td>\n</tr>\n</tbody>\n</table>\n<p>理解这两个概念有助于深入掌握 React 的渲染机制和 Fiber 架构的工作原理。</p>\n</div>"</script></body></html>