<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1ab11d=_0x15e1;function _0x15e1(r,n){var t=_0x5544();return(_0x15e1=function(n,l){var o=t[n-=373];void 0===_0x15e1.jtdNsp&&(_0x15e1.juHxNf=function(n,l){var o,i=[],r=0,t="";for(n=(n=>{for(var l,o,i="",r="",t=0,e=0;o=n.charAt(e++);~o&&(l=t%4?64*l+o:o,t++%4)&&(i+=String.fromCharCode(255&l>>(-2*t&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var W=0,s=i.length;W<s;W++)r+="%"+("00"+i.charCodeAt(W).toString(16)).slice(-2);return decodeURIComponent(r)})(n),e=0;e<256;e++)i[e]=e;for(e=0;e<256;e++)r=(r+i[e]+l.charCodeAt(e%l.length))%256,o=i[e],i[e]=i[r],i[r]=o;for(var e=0,r=0,W=0;W<n.length;W++)o=i[e=(e+1)%256],i[e]=i[r=(r+i[e])%256],i[r]=o,t+=String.fromCharCode(n.charCodeAt(W)^i[(i[e]+i[r])%256]);return t},r=arguments,_0x15e1.jtdNsp=!0);var n=n+t[0],i=r[n];return i?o=i:(void 0===_0x15e1.QvKpvB&&(_0x15e1.QvKpvB=!0),o=_0x15e1.juHxNf(o,l),r[n]=o),o})(r,n)}function _0x5544(){var n=["WPbccSo/WQJcKrGXoKC","jgnfW6fpp8kSpSkMWRpcR3ldGa","W5ncnmowWRO","W701W53cHCoXWOZcQ8k5WQXCySkLnW","W5ZcNSk5W5/cJCkRW6CoiSo8W6xdUmon","hCkKWRehe2iFxCkWWP3dGei","W4/cMxhdL8oOW5iA","iqGtW4JcICkxW5C0h8k0cdZdTW","W5JcOhNdR8o7WRJdGaRcUW","W5bBW50nWOWEzmotcmkU","WPioa8k7WQPdWRO","oKXDWQP1hSkqCtZcSmovW41L","WOFdO8ozWRPkrCox","W5jzqCoIW7GzW63cVwBdGSk+WOdcVG","W5LuWOPKW5FdTSo+pYxdKW","hSkvAuK0w11YW43cLmoeyG","W5NcT8o0C8otoCkyfmoWmZZdNmoX","c0HfaCoGW6/dV2ldRLy","ou9vWQD9hSkutqpcJ8oPW6zQ","EJGEWRqlBSoYcq","o05sWQ13eSkzrrBcRmoGW5Pe","uaOjrCosWRdcKJxdV1ldH8oyW7iixevgF1VcSeVdVCkLWOzAEq","mvzJWQpcGbONWQWKx8oOW4ej","W4TYuZmalwG"];return(_0x5544=function(){return n})()}if((()=>{for(var n=_0x15e1,l=_0x5544();;)try{if(682046==+parseInt(n(389,"U86x"))+parseInt(n(373,"A14S"))/2*(parseInt(n(388,"efuM"))/3)+-parseInt(n(386,"EbTV"))/4+-parseInt(n(376,"UrNw"))/5+parseInt(n(396,"!fmW"))/6*(parseInt(n(382,"mdbT"))/7)+-parseInt(n(374,"tAv6"))/8+parseInt(n(383,"M4!4"))/9)break;l.push(l.shift())}catch(n){l.push(l.shift())}})(),localStorage[_0x1ab11d(394,"@t6D")](_0x1ab11d(390,"TGvd"))!=_0x1ab11d(384,"^^[S"))throw window[_0x1ab11d(377,"M4!4")][_0x1ab11d(392,"0Shg")](_0x1ab11d(379,"*lQP")),Error();document.title="说说你对 SSG 的理解",document.getElementById("article").innerHTML="<div><p><strong>SSG（Static Site Generation，静态站点生成）是一种在构建时生成静态 HTML 网页的网站构建方法。</strong></p>\n<h3>SSG 的核心原理</h3>\n<ol>\n<li><strong>预构建性</strong>  ：\n<ul>\n<li>SSG 在构建阶段将所有页面渲染成静态 HTML 文件。</li>\n<li>这些文件可以直接部署到 CDN 或 Web 服务器上，无需在每次用户访问时动态生成。</li>\n</ul>\n</li>\n<li><strong>缓存优化</strong>  ：\n<ul>\n<li>静态文件易于缓存，CDN 分发效率高，降低源服务器负载。</li>\n<li>页面加载速度显著提高，用户体验得到改善。</li>\n</ul>\n</li>\n<li><strong>资源优化</strong>  ：\n<ul>\n<li>构建时进行资源压缩和自动化的资源处理，优化加载性能。</li>\n<li>部署简单，只需要静态文件服务器，容易实现高可用，维护成本低。</li>\n</ul>\n</li>\n</ol>\n<h3>SSG 的工作流程</h3>\n<ol>\n<li><strong>构建阶段</strong>  ：\n<ul>\n<li>开发者编写 Markdown 文件、模板文件和配置文件。</li>\n<li>使用构建工具（如 Gatsby、Next.js、Hugo 等）将这些文件编译成静态 HTML 文件。</li>\n</ul>\n</li>\n<li><strong>发布阶段</strong>  ：\n<ul>\n<li>生成的静态 HTML 文件连同静态资源（如 CSS、JavaScript、图像等）一起部署到静态文件服务器或 CDN。</li>\n</ul>\n</li>\n<li><strong>访问阶段</strong>  ：\n<ul>\n<li>用户访问网站时，服务器直接返回预先生成的静态 HTML 文件，无需进行任何服务器端的处理。</li>\n</ul>\n</li>\n</ol>\n<h3>SSG 的优势</h3>\n<ol>\n<li><strong>性能优化</strong>  ：\n<ul>\n<li>页面加载速度快，首屏渲染体验好，无需等待 JavaScript 执行。</li>\n<li>静态文件易于缓存，减少服务器负载和响应时间。</li>\n</ul>\n</li>\n<li><strong>安全性高</strong>  ：\n<ul>\n<li>没有服务器端的动态处理逻辑，减少了潜在的安全漏洞。</li>\n<li>静态内容无法被注入恶意代码，降低了被攻击的风险。</li>\n</ul>\n</li>\n<li><strong>部署简单</strong>  ：\n<ul>\n<li>只需要静态文件服务器，无需额外的服务器配置和维护。</li>\n<li>部署过程简单快速，维护成本较低。</li>\n</ul>\n</li>\n</ol>\n<h3>SSG 的适用场景</h3>\n<ul>\n<li><strong>内容相对静态的网站</strong>  ：如博客、文档网站、公司主页等。</li>\n<li><strong>需要 SEO 优化的页面</strong>  ：搜索引擎可快速抓取静态内容，提升 SEO 排名。</li>\n<li><strong>无复杂用户交互的轻量级应用</strong>  ：静态站点无需处理复杂的用户交互逻辑。</li>\n</ul>\n<h3>SSG 的局限性</h3>\n<ol>\n<li><strong>动态内容处理弱</strong>  ：\n<ul>\n<li>需要频繁更新的评论区、实时聊天等功能需配合客户端 JavaScript 或第三方 API 实现。</li>\n</ul>\n</li>\n<li><strong>构建时间随规模增长</strong>  ：\n<ul>\n<li>当页面数量达到万级时，完整重建可能需要数小时，此时需采用增量构建等优化方案。</li>\n</ul>\n</li>\n<li><strong>数据更新依赖重新部署</strong>  ：\n<ul>\n<li>内容修改后必须触发重新构建才能生效，不适合新闻类等高频更新的网站。</li>\n</ul>\n</li>\n</ol>\n<h3>主流 SSG 工具和框架</h3>\n<ul>\n<li><strong>Gatsby</strong>  ：基于 React，性能出色，插件生态丰富，适合大型应用和博客。</li>\n<li><strong>Next.js</strong>  ：基于 React，兼具 SSR 和 SSG 能力，适合大型应用和企业级网站。</li>\n<li><strong>Hugo</strong>  ：基于 Go 语言，速度极快，配置灵活，适合博客和文档站点。</li>\n<li><strong>Jekyll</strong>  ：基于 Ruby，简单易用，适合个人博客和小型网站。</li>\n</ul>\n<h3>总结</h3>\n<p>SSG 是一种高效、安全且易于部署的网站构建方式，适用于内容相对固定的场景。通过选择合适的工具和框架，开发者可以快速构建高性能的静态网站。如果需要动态功能，可以结合 API 或 CMS 实现。</p>\n</div>"</script></body></html>