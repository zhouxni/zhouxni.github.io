<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4e8b(t,s){var p=_0x404e();return(_0x4e8b=function(s,n){var a=p[s-=122];void 0===_0x4e8b.xnHuYs&&(_0x4e8b.BrsLcf=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=l.length;c<o;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[t],l[t]=a;for(var e=0,t=0,c=0;c<s.length;c++)a=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[t])%256]);return p},t=arguments,_0x4e8b.xnHuYs=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x4e8b.RZkvFJ&&(_0x4e8b.RZkvFJ=!0),a=_0x4e8b.BrsLcf(a,n),t[s]=a),a})(t,s)}var _0x5eb5c9=_0x4e8b;function _0x404e(){var s=["nvKga1ZdOJ8EraZdVtC","c8oovLaV","nfqgavRdRGigFqldRcO","wmknW6q3WQuicbfuWOFdJ0G","WO/dNYVcI8kumMVcUa","WPfxc8kCe8kFymoaW44e","sSklerCSpmk5W5lcMmoz","W6VdS0yUW6/dNZFcGSo5WRldOq","Ae7dONFdOtXdAa","imkqmmozWRLoE3W1cmoMW4G","BuZdJ8kgrmoYW7rvW47dVMhdOv0EvSk7W47cQgzoW7yLvCophCkH","W7VdILO8CmkPsuldHgLPjW","W4HZgmoFpCkeWPKjaM00wr8","W7pdQCkzl8k5WO1FW6y9","urH4bSk9W4S3WQBdTCkzW7C","nWVcI8ohamo4W64cW5hdRMZdGwm","W5ZcVftcPfhcSeNdGq","aCk+hCkHWQKvwW","W7hcJmopW6tcUbXFCq","WPDswmoQhmkfz8oG","xXL9amk8WRnZWONdHSkhW7tdHmos","W7BcM07cPw9WWRTJE0GM","W4VcTftdMCkhWPtdHhzlWObeWQu","W4Ccs8oHhCkXra","imksmSozWR5kgeuDeSoLW44O","WPjxbSkrw8koFSoiW5CYWQq"];return(_0x404e=function(){return s})()}if((()=>{for(var s=_0x4e8b,n=_0x404e();;)try{if(245846==+parseInt(s(132,"5Bvz"))+-parseInt(s(134,"5Bvz"))/2+-parseInt(s(124,"f&%["))/3*(parseInt(s(135,"qA3c"))/4)+parseInt(s(140,"kSUY"))/5*(parseInt(s(127,"cO]H"))/6)+-parseInt(s(147,"JMS0"))/7+parseInt(s(139,"IsJD"))/8*(-parseInt(s(137,"FYKW"))/9)+parseInt(s(126,"N2J4"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5eb5c9(129,"FYKW")](_0x5eb5c9(145,"wFc@"))!=_0x5eb5c9(133,"Sbft"))throw window[_0x5eb5c9(122,"AZfI")][_0x5eb5c9(123,"SG9I")](_0x5eb5c9(142,"JMS0")),Error();document.title="react 在 SSR 阶段往组件内部注入 useEffect",document.getElementById("article").innerHTML='<div><p>在 SSR (Server-Side Rendering) 阶段，虽然 <code>useEffect</code> 代码不会在服务端执行，但我们可以通过以下方式将 <code>useEffect</code> 逻辑注入到 <code>App</code> 组件中，并确保这些代码<strong>仅在客户端运行</strong>   ：</p>\n<hr>\n<h3><strong>1. 核心原理</strong></h3>\n<ul>\n<li><strong>服务端</strong>   ：将需要执行的 <code>useEffect</code> 代码标记或序列化，嵌入到 HTML 中。</li>\n<li><strong>客户端</strong>   ：从 HTML 中提取这些代码，在 <code>useEffect</code> 中动态执行。</li>\n</ul>\n<hr>\n<h3><strong>2. 实现方案</strong></h3>\n<h4><strong>方案 1：全局变量 + 动态执行（推荐）</strong></h4>\n<h5><strong>服务端（Node.js）</strong></h5>\n<pre><code class="language-jsx"><span class="hljs-comment">// server.js</span>\napp.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {\n  <span class="hljs-comment">// 定义需要在客户端执行的 useEffect 逻辑</span>\n  <span class="hljs-keyword">const</span> clientEffects = [\n    {\n      <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;console.log(&quot;这段代码只在客户端执行&quot;)&#x27;</span>,\n      <span class="hljs-attr">deps</span>: [],\n    },\n    {\n      <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;fetch(&quot;/api/data&quot;).then(res =&gt; res.json())&#x27;</span>,\n      <span class="hljs-attr">deps</span>: [],\n    },\n  ];\n\n  <span class="hljs-keyword">const</span> html = <span class="hljs-title function_">renderToString</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);\n\n  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`\n    &lt;html&gt;\n      &lt;body&gt;\n        &lt;div id=&quot;root&quot;&gt;<span class="hljs-subst">${html}</span>&lt;/div&gt;\n        &lt;script&gt;\n          // 将 useEffect 逻辑保存到全局变量\n          window.__CLIENT_EFFECTS__ = <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(clientEffects)}</span>;\n        &lt;/script&gt;\n        &lt;script src=&quot;/client.js&quot;&gt;&lt;/script&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  `</span>);\n});\n</code></pre>\n<h5><strong>客户端（React 组件）</strong></h5>\n<pre><code class="language-jsx"><span class="hljs-comment">// App.js</span>\n<span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 客户端运行时执行注入的代码</span>\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">&quot;undefined&quot;</span> &amp;&amp; <span class="hljs-variable language_">window</span>.<span class="hljs-property">__CLIENT_EFFECTS__</span>) {\n      <span class="hljs-variable language_">window</span>.<span class="hljs-property">__CLIENT_EFFECTS__</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">{ code }</span>) =&gt;</span> {\n        <span class="hljs-keyword">try</span> {\n          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(code)(); <span class="hljs-comment">// 动态执行代码</span>\n        } <span class="hljs-keyword">catch</span> (err) {\n          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;执行客户端效果失败:&quot;</span>, err);\n        }\n      });\n    }\n  }, []);\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>My App<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n<hr>\n<h4><strong>方案 2：自定义 Hook 封装</strong></h4>\n<h5><strong>定义 Hook</strong></h5>\n<pre><code class="language-jsx"><span class="hljs-comment">// hooks/useClientEffect.js</span>\n<span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useClientEffect</span>(<span class="hljs-params">effect, deps = []</span>) {\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">&quot;undefined&quot;</span>) {\n      <span class="hljs-keyword">return</span> <span class="hljs-title function_">effect</span>();\n    }\n  }, deps);\n}\n</code></pre>\n<h5><strong>服务端注入</strong></h5>\n<pre><code class="language-jsx"><span class="hljs-comment">// server.js</span>\n<span class="hljs-keyword">const</span> clientEffects = [\n  { <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;() =&gt; console.log(&quot;Hello from client!&quot;)&#x27;</span>, <span class="hljs-attr">deps</span>: [] },\n];\n\nres.<span class="hljs-title function_">send</span>(<span class="hljs-string">`\n  &lt;script&gt;\n    window.__CLIENT_EFFECTS__ = <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(clientEffects)}</span>;\n  &lt;/script&gt;\n`</span>);\n</code></pre>\n<h5><strong>组件中使用</strong></h5>\n<pre><code class="language-jsx"><span class="hljs-comment">// App.js</span>\n<span class="hljs-keyword">import</span> { useClientEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./hooks/useClientEffect&quot;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">&quot;undefined&quot;</span> &amp;&amp; <span class="hljs-variable language_">window</span>.<span class="hljs-property">__CLIENT_EFFECTS__</span>) {\n    <span class="hljs-variable language_">window</span>.<span class="hljs-property">__CLIENT_EFFECTS__</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">{ code }</span>) =&gt;</span> {\n      <span class="hljs-title function_">useClientEffect</span>(<span class="hljs-function">() =&gt;</span> {\n        <span class="hljs-keyword">const</span> effect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">`return <span class="hljs-subst">${code}</span>`</span>)();\n        <span class="hljs-title function_">effect</span>();\n      });\n    });\n  }\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>My App<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n<hr>\n<h3><strong>3. 高级用法：支持依赖项</strong></h3>\n<p>如果需要依赖 React 状态或 props，可以改进注入逻辑：</p>\n<h5><strong>服务端</strong></h5>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> clientEffects = [\n  {\n    <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;(count) =&gt; console.log(&quot;Count is:&quot;, count)&#x27;</span>,\n    <span class="hljs-attr">deps</span>: [<span class="hljs-string">&quot;count&quot;</span>], <span class="hljs-comment">// 声明依赖的变量名</span>\n  },\n];\n</code></pre>\n<h5><strong>客户端</strong></h5>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params">{ initialCount }</span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(initialCount);\n\n  <span class="hljs-title function_">useClientEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-keyword">const</span> effect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-string">`return <span class="hljs-subst">${code}</span>`</span>)(count);\n    <span class="hljs-title function_">effect</span>();\n  }, [count]); <span class="hljs-comment">// 依赖项变化时重新执行</span>\n}\n</code></pre>\n<hr>\n<h3><strong>4. 安全注意事项</strong></h3>\n<ol>\n<li><strong>避免 XSS 攻击</strong>   ：如果代码来自用户输入，需 sanitize：<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">DOMPurify</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;dompurify&quot;</span>;\n<span class="hljs-keyword">const</span> safeCode = <span class="hljs-title class_">DOMPurify</span>.<span class="hljs-title function_">sanitize</span>(rawCode);\n</code></pre>\n</li>\n<li><strong>生产环境清理</strong>   ：<pre><code class="language-jsx"><span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&quot;production&quot;</span>) {\n  <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">__CLIENT_EFFECTS__</span>;\n}\n</code></pre>\n</li>\n</ol>\n<hr>\n<h3><strong>5. 完整流程总结</strong></h3>\n<ol>\n<li><strong>服务端</strong>   ：\n<ul>\n<li>将 <code>useEffect</code> 逻辑序列化为字符串。</li>\n<li>通过 <code>window.__CLIENT_EFFECTS__</code> 注入到 HTML。</li>\n</ul>\n</li>\n<li><strong>客户端</strong>   ：\n<ul>\n<li>在组件 <code>useEffect</code> 中读取全局变量。</li>\n<li>用 <code>new Function()</code> 或 <code>eval()</code>（谨慎）动态执行代码。</li>\n</ul>\n</li>\n<li><strong>优化</strong>   ：\n<ul>\n<li>封装为自定义 Hook（如 <code>useClientEffect</code>）。</li>\n<li>支持依赖项跟踪。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>6. 替代方案对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>全局变量注入</strong></td>\n<td>简单直接，无需额外依赖</td>\n<td>需手动管理依赖项</td>\n</tr>\n<tr>\n<td><strong>自定义 Hook</strong></td>\n<td>代码更健壮，易于复用</td>\n<td>需要初始封装成本</td>\n</tr>\n<tr>\n<td><strong>Next.js 插件</strong></td>\n<td>开箱即用（如 <code>next/dynamic</code>）</td>\n<td>需依赖框架</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>最终推荐方案</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-comment">// 服务端</span>\n<span class="hljs-keyword">const</span> clientEffects = [\n  {\n    <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;() =&gt; console.log(&quot;Client-only code!&quot;)&#x27;</span>,\n  },\n];\n\n<span class="hljs-comment">// 客户端</span>\n<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">&quot;undefined&quot;</span>) {\n    <span class="hljs-variable language_">window</span>.<span class="hljs-property">__CLIENT_EFFECTS__</span>?.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">{ code }</span>) =&gt;</span> {\n      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(code)();\n    });\n  }\n}, []);\n</code></pre>\n<p>这种方式既保持了 SSR 的 SEO 优势，又能精准控制客户端副作用！ 🚀 （Vue SSR 原理与 React 类似）</p>\n</div>'</script></body></html>