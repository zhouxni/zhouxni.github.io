<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5e27(e,n){var a=_0x23de();return(_0x5e27=function(n,s){var o=a[n-=314];void 0===_0x5e27.tHdAhe&&(_0x5e27.xwURGL=function(n,s){var o,c=[],e=0,a="";for(n=(n=>{for(var s,o,c="",e="",a=0,t=0;o=n.charAt(t++);~o&&(s=a%4?64*s+o:o,a++%4)&&(c+=String.fromCharCode(255&s>>(-2*a&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var l=0,d=c.length;l<d;l++)e+="%"+("00"+c.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(e)})(n),t=0;t<256;t++)c[t]=t;for(t=0;t<256;t++)e=(e+c[t]+s.charCodeAt(t%s.length))%256,o=c[t],c[t]=c[e],c[e]=o;for(var t=0,e=0,l=0;l<n.length;l++)o=c[t=(t+1)%256],c[t]=c[e=(e+c[t])%256],c[e]=o,a+=String.fromCharCode(n.charCodeAt(l)^c[(c[t]+c[e])%256]);return a},e=arguments,_0x5e27.tHdAhe=!0);var n=n+a[0],c=e[n];return c?o=c:(void 0===_0x5e27.RVfumD&&(_0x5e27.RVfumD=!0),o=_0x5e27.xwURGL(o,s),e[n]=o),o})(e,n)}var _0x2abecb=_0x5e27;function _0x23de(){var n=["W6NcRSkAvCkyWR3dJSoRW54","adhcVmooWO/dPmkpW4O","qKucW63cIJ0Nv8oLFq/dJCkz","smo9W4pdU8ot","W5JcMLlcIInLmCogW7a9yritW7W","W5hdPmkVW4GWWORdVSkbW7ZdSNDK","wqDpW4ZdISkQgvNdO8onWQbstW","xw7cNCoNWQ3dPmkTW54","W7BcT0uKW6KnWQOcWONdK05s","DSkMWOWoW4VcPCk1","BCk/WPGfu07dM8kGW6/cTNZdTmoh","WPNdV8kPFCkCWPBdJSop","WOZcPSkdW6u4WRud","WO7cPmoTWOL0WOhcTSo5W4/dJKbHWO/cKeVdUMJdG8oCowhcQryruSoH","nCkWArFcGe54jSkRW6ldT8oEWOKO","kSoDuCkzr8oQWPmIoxtcV8oryG","cmo6W4ldRCkEWRBdQmks","wN9xrCogW5hdPYG","WQ4wge9mBMW","W7BcRg7cRMOppf0fW4hdOLLF","wSkeW4iJWOxcN8ogBKzskITcW40","W5WEnCk9W6L4W6/cVrDHxWuv","pSkssmoViCo0t8kAcCoIy8krWQyH","Amk+WPGeue3dKCkXW4dcQhZdOSoO","sJBdSSkyWO4PWRq","W5tdP8kVW4W1WO/cRmkoW5ddJ2vCWOC"];return(_0x23de=function(){return n})()}if((()=>{for(var n=_0x5e27,s=_0x23de();;)try{if(835581==+parseInt(n(335,"@9JB"))*(-parseInt(n(319,"WjP^"))/2)+-parseInt(n(324,"woaj"))/3+parseInt(n(338,"Qt3q"))/4*(-parseInt(n(326,"4L5q"))/5)+-parseInt(n(320,"yA^E"))/6+-parseInt(n(333,"Af7p"))/7+parseInt(n(321,"G*9u"))/8+parseInt(n(331,"VCgS"))/9*(parseInt(n(318,"f0dD"))/10))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x2abecb(336,"u3GZ")](_0x2abecb(327,"Qt3q"))!=_0x2abecb(330,"Z*oU"))throw window[_0x2abecb(334,"3MB!")][_0x2abecb(339,"&Q!3")](_0x2abecb(314,"4L5q")),Error();document.title="JavaScript 中，new func.call()、new func.bind()、new func.apply() 都会报错",document.getElementById("article").innerHTML='<div><p>在 JavaScript 中，<code>new func.call()</code>、<code>new func.bind()</code>、<code>new func.apply()</code> 都会报错，这是因为这些方法（<code>call</code>、<code>bind</code>、<code>apply</code>）被设计为<strong>非构造函数</strong>   （non-constructor），无法通过 <code>new</code> 调用。以下是详细原因：</p>\n<hr>\n<h2><strong>1. <code>new func.call()</code> / <code>new func.apply()</code> 报错的原因</strong></h2>\n<h3><strong>(1) 语言规范限制</strong></h3>\n<ul>\n<li><code>Function.prototype.call</code> 和 <code>Function.prototype.apply</code> 被 ECMAScript 规范定义为<strong>非构造函数</strong>   （non-constructor），它们没有 <code>[[Construct]]</code> 内部方法，因此不能使用 <code>new</code> 调用。</li>\n<li>尝试 <code>new func.call()</code> 或 <code>new func.apply()</code> 会直接抛出：<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {}.<span class="hljs-title function_">call</span>();\n<span class="hljs-comment">// TypeError: function.call is not a constructor</span>\n</code></pre>\n</li>\n</ul>\n<h3><strong>(2) 逻辑矛盾</strong></h3>\n<ul>\n<li><code>new</code> 的作用：\n<ul>\n<li>创建一个新对象，并将构造函数内的 <code>this</code> 绑定到该对象。</li>\n<li><code>this</code> 由引擎自动管理，不能手动覆盖。</li>\n</ul>\n</li>\n<li><code>call</code> / <code>apply</code> 的作用：\n<ul>\n<li>动态绑定 <code>this</code> 到指定的 <code>context</code>。</li>\n</ul>\n</li>\n<li><strong>冲突点</strong>   ：\n<ul>\n<li><code>new</code> 要求 <code>this</code> 必须是新创建的对象，而 <code>call</code> / <code>apply</code> 试图覆盖 <code>this</code>，两者无法共存。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2><strong>2. <code>new func.bind()</code> 报错的原因</strong></h2>\n<h3><strong>(1) <code>bind</code> 返回的函数是“绑定函数”（Bound Function）</strong></h3>\n<ul>\n<li>\n<p><code>func.bind(obj)</code> 会返回一个新的函数，这个函数的 <code>this</code> 被永久绑定到 <code>obj</code>。</p>\n</li>\n<li>\n<p>但 <code>bind</code> 返回的函数<strong>默认不能作为构造函数</strong>   （除非原函数是构造函数）。</p>\n<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) {}\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">BoundFoo</span> = <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">bind</span>({});\n<span class="hljs-keyword">new</span> <span class="hljs-title class_">BoundFoo</span>(); <span class="hljs-comment">// ✅ 可以，因为 Foo 是构造函数</span>\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">arrowFn</span> = (<span class="hljs-params"></span>) =&gt; {};\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">BoundArrow</span> = arrowFn.<span class="hljs-title function_">bind</span>({});\n<span class="hljs-keyword">new</span> <span class="hljs-title class_">BoundArrow</span>(); <span class="hljs-comment">// ❌ TypeError: BoundArrow is not a constructor</span>\n</code></pre>\n</li>\n</ul>\n<h3><strong>(2) <code>bind</code> 返回的函数没有 <code>prototype</code></strong></h3>\n<ul>\n<li>如果原函数没有 <code>prototype</code>（如箭头函数、<code>bind</code> 后的函数），则 <code>new</code> 调用会报错：<pre><code class="language-js"><span class="hljs-keyword">const</span> boundFn = (<span class="hljs-function">() =&gt;</span> {}).<span class="hljs-title function_">bind</span>({});\n<span class="hljs-keyword">new</span> <span class="hljs-title function_">boundFn</span>(); <span class="hljs-comment">// ❌ TypeError: boundFn is not a constructor</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h2><strong>3. 如何绕过限制？</strong></h2>\n<h3><strong>(1) 使用 <code>Reflect.construct</code>（ES6+）</strong></h3>\n<p>如果需要在 <code>new</code> 调用时动态绑定参数，可以用：</p>\n<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {\n  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;\n}\n<span class="hljs-keyword">const</span> args = [<span class="hljs-string">&quot;Alice&quot;</span>];\n<span class="hljs-keyword">const</span> instance = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(<span class="hljs-title class_">Person</span>, args); <span class="hljs-comment">// ✅ 等同于 new Person(&quot;Alice&quot;)</span>\n</code></pre>\n<h3><strong>(2) 手动实现支持 <code>new</code> 的 <code>myCall</code></strong></h3>\n<pre><code class="language-js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) {\n  <span class="hljs-keyword">const</span> fn = <span class="hljs-variable language_">this</span>;\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&quot;function&quot;</span> || !fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) {\n      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;fn is not a constructor&quot;</span>);\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>(...args); <span class="hljs-comment">// 忽略 context，直接构造</span>\n  }\n  <span class="hljs-comment">// 普通调用逻辑...</span>\n};\n</code></pre>\n<hr>\n<h2><strong>总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>是否支持 <code>new</code> 调用</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>func.call()</code></td>\n<td>❌ 报错</td>\n<td>语言规范禁止 + <code>new</code> 和 <code>call</code> 对 <code>this</code> 的绑定冲突</td>\n</tr>\n<tr>\n<td><code>func.apply()</code></td>\n<td>❌ 报错</td>\n<td>同上</td>\n</tr>\n<tr>\n<td><code>func.bind()</code></td>\n<td>❌ 可能报错</td>\n<td>除非原函数是构造函数，否则 <code>bind</code> 返回的函数不能 <code>new</code></td>\n</tr>\n<tr>\n<td><code>Reflect.construct</code></td>\n<td>✅ 支持</td>\n<td>ES6 提供的动态构造方法</td>\n</tr>\n</tbody>\n</table>\n<p><strong>根本原因</strong>   ：<code>call</code>、<code>apply</code>、<code>bind</code> 的设计初衷是动态绑定 <code>this</code>，而 <code>new</code> 的 <code>this</code> 由引擎自动管理，两者语义冲突，因此语言规范直接禁止这种用法。</p>\n</div>'</script></body></html>