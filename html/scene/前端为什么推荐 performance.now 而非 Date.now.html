<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2bf8(){var n=["W6P6W7zlvSk9wmomWQDnW6pdHW","gWdcQYvxW6nmemonWOzifG","eHZdGSkLomk9D8oZd8oMC8oszq","jW7dQa7dMHqaWPm","qCofnCklW6DFs13dSmo6kG","WQaqwfpcQhldQmoFW4GfW5LjEG","W6NcISkyW4SeW7/dMW","WRaCWQO3W5FcPuaiWPL4zcW","W7yfW4aHyZrxmI5/eSkWza","W5ZdTHxcN3NdRSkqW5KYjGC","xwZdNSkWW6jrWRe3","nCk6gCoiwqxcTYNcMCoT","W6z2W5zgW48Htq","WPD4W4XKvcb8W6KgW5C","b8o/BCoBcLVcPa","WPxcHG5ae8kYW4xdR8k/q8kwvq","E0dcOIRcJa","W7HoWQTYWRFcQ1lcQY0","oWtdOmowW5lcJuNdUW","A8oKWRVcPIJcNWS","W6LoWQX3WR4Se8k+cCoAW77cOW","xvhdMa3dLYew","WPv9WR/dUYSPlh0tW6WOW7K","ELtcUfZcLKHAWRBdNmo0W7irrW","AWpcPfLME0C","emkgCSojWQiacqBdHmocdZ/dHd4sW6dcU8oPWReBwJVdNmoKWRmr"];return(_0x2bf8=function(){return n})()}var _0x2cb923=_0x2c24;function _0x2c24(t,n){var e=_0x2bf8();return(_0x2c24=function(n,s){var o=e[n-=235];void 0===_0x2c24.RTGIUq&&(_0x2c24.zIDNSD=function(n,s){var o,a=[],t=0,e="";for(n=(n=>{for(var s,o,a="",t="",e=0,r=0;o=n.charAt(r++);~o&&(s=e%4?64*s+o:o,e++%4)&&(a+=String.fromCharCode(255&s>>(-2*e&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var c=0,l=a.length;c<l;c++)t+="%"+("00"+a.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(n),r=0;r<256;r++)a[r]=r;for(r=0;r<256;r++)t=(t+a[r]+s.charCodeAt(r%s.length))%256,o=a[r],a[r]=a[t],a[t]=o;for(var r=0,t=0,c=0;c<n.length;c++)o=a[r=(r+1)%256],a[r]=a[t=(t+a[r])%256],a[t]=o,e+=String.fromCharCode(n.charCodeAt(c)^a[(a[r]+a[t])%256]);return e},t=arguments,_0x2c24.RTGIUq=!0);var n=n+e[0],a=t[n];return a?o=a:(void 0===_0x2c24.bJXyRQ&&(_0x2c24.bJXyRQ=!0),o=_0x2c24.zIDNSD(o,s),t[n]=o),o})(t,n)}if((()=>{for(var n=_0x2c24,s=_0x2bf8();;)try{if(155856==+parseInt(n(252,"Y960"))*(parseInt(n(247,"9p%b"))/2)+parseInt(n(254,"MWRm"))/3+parseInt(n(246,"6VPq"))/4*(-parseInt(n(257,"WbRP"))/5)+-parseInt(n(238,"evFr"))/6*(-parseInt(n(248,"dK%7"))/7)+parseInt(n(242,"2mwG"))/8+parseInt(n(256,"RSFR"))/9+-parseInt(n(241,"BLT5"))/10)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x2cb923(240,"mkiC")](_0x2cb923(251,"PtLB"))!=_0x2cb923(250,"0c4L"))throw window[_0x2cb923(237,"WbRP")][_0x2cb923(258,"pkUc")](_0x2cb923(259,"evFr")),Error();document.title="前端为什么推荐 performance.now 而非 Date.now",document.getElementById("article").innerHTML='<div><p>在前端性能测量场景中，<code>performance.now()</code> 比 <code>Date.now()</code> 更受推荐，主要原因在于其更高的精度、稳定性和可靠性。以下是详细对比：</p>\n<h3><strong>1. 精度差异</strong></h3>\n<ul>\n<li>\n<p><strong><code>Date.now()</code></strong><br>\n返回自 <strong>1970-01-01 00:00:00 UTC</strong>   以来的毫秒数（时间戳），精度通常为 <strong>1 毫秒</strong>   （部分浏览器可能更差）。<br>\n示例：<code>1698921600000</code>（整数）。</p>\n</li>\n<li>\n<p><strong><code>performance.now()</code></strong><br>\n返回自 <strong>页面加载开始</strong>   （<code>navigationStart</code>）以来的毫秒数，精度可达 <strong>微秒级</strong>   （小数点后 3 位）。<br>\n示例：<code>5248.625</code>（浮点数）。</p>\n</li>\n</ul>\n<p><strong>适用场景</strong>   ：</p>\n<ul>\n<li><code>Date.now()</code>：适用于记录绝对时间（如日志时间戳）。</li>\n<li><code>performance.now()</code>：适用于测量短时间间隔（如动画帧、API 响应时间）。</li>\n</ul>\n<h3><strong>2. 时间源稳定性</strong></h3>\n<ul>\n<li>\n<p><strong><code>Date.now()</code></strong><br>\n依赖系统时钟，可能受用户手动调整时间、NTP 同步或浏览器后台优化（如睡眠时间）影响，导致时间跳跃。</p>\n</li>\n<li>\n<p><strong><code>performance.now()</code></strong><br>\n使用独立的 <strong>单调时钟</strong>   （monotonic clock），不受系统时间调整影响，确保时间连续性。即使系统时间被修改，<code>performance.now()</code> 仍按固定速率递增。</p>\n</li>\n</ul>\n<p><strong>示例问题</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 用户突然调整系统时间</span>\n<span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();\n<span class="hljs-comment">// 用户手动将系统时间调快 1 小时</span>\n<span class="hljs-keyword">const</span> end = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(end - start); <span class="hljs-comment">// 可能显示 3600000ms（1小时），而非真实耗时</span>\n</code></pre>\n<h3><strong>3. 更高的测量精度</strong></h3>\n<ul>\n<li>\n<p><strong><code>Date.now()</code></strong><br>\n由于精度限制，测量极短操作（如函数执行）时可能返回 <code>0</code>。</p>\n</li>\n<li>\n<p><strong><code>performance.now()</code></strong><br>\n微秒级精度更适合测量精细操作，如：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>();\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {\n  <span class="hljs-comment">/* 执行耗时操作 */</span>\n}\n<span class="hljs-keyword">const</span> end = performance.<span class="hljs-title function_">now</span>();\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`操作耗时: <span class="hljs-subst">${end - start}</span>ms`</span>); <span class="hljs-comment">// 可能显示 2.45ms</span>\n</code></pre>\n</li>\n</ul>\n<h3><strong>4. 浏览器性能 API 集成</strong></h3>\n<ul>\n<li><strong><code>performance.now()</code></strong><br>\n是 <strong>Performance API</strong>   的一部分，可与其他性能指标（如 <code>performance.mark()</code>、<code>performance.measure()</code>）无缝配合，提供更全面的性能分析：<pre><code class="language-javascript">performance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&quot;start&quot;</span>);\n<span class="hljs-comment">// 执行操作</span>\nperformance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&quot;end&quot;</span>);\nperformance.<span class="hljs-title function_">measure</span>(<span class="hljs-string">&quot;操作耗时&quot;</span>, <span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>);\n<span class="hljs-keyword">const</span> entry = performance.<span class="hljs-title function_">getEntriesByName</span>(<span class="hljs-string">&quot;操作耗时&quot;</span>)[<span class="hljs-number">0</span>];\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entry.<span class="hljs-property">duration</span>); <span class="hljs-comment">// 精确测量结果</span>\n</code></pre>\n</li>\n</ul>\n<h3><strong>5. 跨浏览器兼容性</strong></h3>\n<ul>\n<li><strong><code>performance.now()</code></strong><br>\n现代浏览器（Chrome、Firefox、Safari、Edge）均已支持，仅需注意在旧浏览器（如 IE9-）中可能需要 polyfill。</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th><code>Date.now()</code></th>\n<th><code>performance.now()</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>记录绝对时间</td>\n<td>✅ 适合</td>\n<td>❌ 不适用（相对时间）</td>\n</tr>\n<tr>\n<td>测量短时间间隔</td>\n<td>❌ 精度不足</td>\n<td>✅ 推荐（微秒级精度）</td>\n</tr>\n<tr>\n<td>避免系统时间干扰</td>\n<td>❌ 受时钟调整影响</td>\n<td>✅ 独立单调时钟</td>\n</tr>\n<tr>\n<td>性能分析与 API 集成</td>\n<td>❌ 孤立使用</td>\n<td>✅ 与 Performance API 集成</td>\n</tr>\n</tbody>\n</table>\n<p><strong>建议</strong>   ：在性能敏感的场景（如动画、渲染、API 响应时间）中，优先使用 <code>performance.now()</code>；仅在需要绝对时间戳时使用 <code>Date.now()</code>。</p>\n</div>'</script></body></html>