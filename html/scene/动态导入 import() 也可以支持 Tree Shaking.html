<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x20d1(){var n=["W4tcQKn/WPBdLxa","W4LRWONcSWPDWQBcHvpdQ8o+WQW","W5LhwmkuWQv+lMW","mSoOymohW6ZcMCoQubxdN23cHq","ftiKWQ8LW5pcLNBcOmoUWRv1WOX1WRvLmmkjfrrAW4mmbmkeqW","W4BcJc7cNvrWW5ZdNhNcGCoa","WR5Gh1hcJSoTbY4","y3BcP8oCgu7dSdNcK3eOW60","dCk2WOWZW5VcNaNcReKwv8kd","BfhcOCk3W6hcGMhcTa","vt8ZW5TmhCkxWQDLo8k3ea","W5vZfmk8oCopdSo4b2RcT8k5jG","WPldNgJdPbvYW58","DmoUWOO/WPNcNsK","W7PbW5C9WQnyxYddOSkKWPFdNa","lsxcHmkGAe3dTN15sCo7dG","WOlcOtVcLCkzFmkcuCk0","vhDhWPuDxmkD","hCoIWPmQWO1duK4XW4GE","W6O1fwj3nmo0wHqLrvmE","W4NdIxG2WPddH8oDECoJWRhcK8kU","W4xcUffAWPhdKey","vJS0W5jcgmk1WRXHgCkLmW","lSkTWOJdOby","B8oSWPldIY53WRZdKq","g8oOWPqFW6/cVmo+CrVdQmkUCG","ecSzsve+WR8","EJW5rY/cKCkCna"];return(_0x20d1=function(){return n})()}var _0x51b805=_0x58db;function _0x58db(r,n){var e=_0x20d1();return(_0x58db=function(n,t){var o=e[n-=256];void 0===_0x58db.ARSJjl&&(_0x58db.VoyCJc=function(n,t){var o,s=[],r=0,e="";for(n=(n=>{for(var t,o,s="",r="",e=0,a=0;o=n.charAt(a++);~o&&(t=e%4?64*t+o:o,e++%4)&&(s+=String.fromCharCode(255&t>>(-2*e&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var c=0,l=s.length;c<l;c++)r+="%"+("00"+s.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(r)})(n),a=0;a<256;a++)s[a]=a;for(a=0;a<256;a++)r=(r+s[a]+t.charCodeAt(a%t.length))%256,o=s[a],s[a]=s[r],s[r]=o;for(var a=0,r=0,c=0;c<n.length;c++)o=s[a=(a+1)%256],s[a]=s[r=(r+s[a])%256],s[r]=o,e+=String.fromCharCode(n.charCodeAt(c)^s[(s[a]+s[r])%256]);return e},r=arguments,_0x58db.ARSJjl=!0);var n=n+e[0],s=r[n];return s?o=s:(void 0===_0x58db.uZfGkW&&(_0x58db.uZfGkW=!0),o=_0x58db.VoyCJc(o,t),r[n]=o),o})(r,n)}if((()=>{for(var n=_0x58db,t=_0x20d1();;)try{if(114891==-parseInt(n(260,"UD&W"))*(-parseInt(n(271,"O#GP"))/2)+parseInt(n(267,"UD&W"))/3*(parseInt(n(265,"eI]w"))/4)+-parseInt(n(268,"#Dwk"))/5+parseInt(n(258,"%b$H"))/6*(-parseInt(n(274,"DWni"))/7)+-parseInt(n(279,"e)0v"))/8+parseInt(n(269,"TRr5"))/9+-parseInt(n(256,"BEnK"))/10*(parseInt(n(275,"BA[d"))/11))break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x51b805(262,"h!o^")](_0x51b805(266,"cOR("))!=_0x51b805(273,"DWni"))throw window[_0x51b805(259,"77#H")][_0x51b805(263,"64AX")](_0x51b805(282,"4w1C")),Error();document.title="动态导入 import() 也可以支持 Tree Shaking",document.getElementById("article").innerHTML='<div><p>是的，<strong>动态导入（<code>import()</code>）也可以支持 Tree Shaking</strong>   ，但它的优化能力取决于具体的使用方式和打包工具的配置。以下是关键点分析：</p>\n<hr>\n<h3>1. <strong>动态导入（<code>import()</code>）的本质</strong></h3>\n<ul>\n<li>\n<p><code>import()</code> 是 ECMAScript 的<strong>动态模块加载语法</strong>   （返回 Promise），用于按需加载模块（代码分割）。</p>\n</li>\n<li>\n<p>它虽然是“动态”的（运行时加载），但<strong>模块路径必须是静态字符串</strong>   （或可静态分析的表达式），例如：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// ✅ 支持 Tree Shaking（路径是静态字符串）</span>\n<span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./moduleA&#x27;</span>).<span class="hljs-title function_">then</span>(...);\n\n<span class="hljs-comment">// ❌ 不支持 Tree Shaking（路径动态计算）</span>\n<span class="hljs-keyword">import</span>(<span class="hljs-string">`./<span class="hljs-subst">${moduleName}</span>`</span>).<span class="hljs-title function_">then</span>(...); <span class="hljs-comment">// 动态模板字符串</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>2. <strong>Tree Shaking 的条件</strong></h3>\n<ul>\n<li><strong>静态可分析的路径</strong>   ：打包工具（如 Webpack、Rollup）会解析 <code>import()</code> 中的静态路径，分析目标模块的依赖关系。</li>\n<li><strong>目标模块必须是 ESM</strong>   ：如果动态导入的模块是 ESM 格式，且标记了 <code>&quot;sideEffects&quot;: false</code>，工具可以对其内部代码做 Tree Shaking。</li>\n<li><strong>代码分割优先</strong>   ：动态导入的主要目的是按需加载（减少初始包体积），Tree Shaking 是附加优化。</li>\n</ul>\n<hr>\n<h3>3. <strong>实际场景中的行为</strong></h3>\n<ul>\n<li>\n<p><strong>示例 1：动态导入 + ESM 模块</strong></p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 动态导入一个 ESM 模块</span>\n<span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./utils&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">utils</span>) =&gt;</span> {\n  utils.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 如果只有 `foo` 被使用，其他导出会被 Tree Shaken</span>\n});\n</code></pre>\n<ul>\n<li>如果 <code>./utils</code> 是 ESM 模块且无副作用，打包工具会移除 <code>utils</code> 中未被使用的导出。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例 2：动态导入 + 副作用</strong></p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./styles.css&quot;</span>); <span class="hljs-comment">// 通常 CSS 文件有副作用（影响渲染），不会被 Tree Shaken</span>\n</code></pre>\n<ul>\n<li>需通过 <code>package.json</code> 的 <code>&quot;sideEffects&quot;: [&quot;*.css&quot;]</code> 显式声明。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>4. <strong>与静态导入（<code>import ... from</code>）的对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>静态导入 (<code>import ... from</code>)</th>\n<th>动态导入 (<code>import()</code>)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Tree Shaking</strong></td>\n<td>✅ 完全支持</td>\n<td>✅ 支持（需静态路径）</td>\n</tr>\n<tr>\n<td><strong>加载时机</strong></td>\n<td>编译时绑定，立即加载</td>\n<td>运行时按需加载</td>\n</tr>\n<tr>\n<td><strong>代码分割</strong></td>\n<td>默认不分割</td>\n<td>自动分割为独立 chunk</td>\n</tr>\n<tr>\n<td><strong>动态路径</strong></td>\n<td>❌ 不支持</td>\n<td>⚠️ 有限支持（需静态分析）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>5. <strong>工具链的注意事项</strong></h3>\n<ul>\n<li><strong>Webpack</strong>   ：从 v4 开始支持动态导入的 Tree Shaking，需确保：\n<ol>\n<li>使用 ESM 模块。</li>\n<li>生产模式（<code>mode: \'production\'</code>）会自动启用优化。</li>\n<li>避免动态模板字符串路径（如 <code>import(</code>./${name}<code>)</code>）。</li>\n</ol>\n</li>\n<li><strong>Rollup</strong>   ：默认支持动态导入的静态分析，但需配置 <code>output.dir</code> 代码分割。</li>\n<li><strong>Babel 转译</strong>   ：避免将 <code>import()</code> 转译为 <code>require.ensure</code>（需配置 <code>@babel/plugin-syntax-dynamic-import</code>）。</li>\n</ul>\n<hr>\n<h3>总结</h3>\n<ul>\n<li><strong>动态导入 <code>import()</code> 可以 Tree Shaking</strong>   ，但前提是：\n<ol>\n<li>模块路径是静态字符串。</li>\n<li>目标模块是 ESM 且标记为无副作用。</li>\n<li>打包工具配置正确（如生产模式）。</li>\n</ol>\n</li>\n<li><strong>动态导入的核心优势是代码分割</strong>   ，Tree Shaking 是附加优化。如果追求极致性能，静态导入的 Tree Shaking 效果更彻底。</li>\n</ul>\n</div>'</script></body></html>