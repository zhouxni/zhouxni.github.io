<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2edd73=_0x4a95;function _0x1291(){var n=["D8oDWRJcKtFdOmoQWPFdQ2ZdTCoa","dxrmnXCYW4rQnq","W5hdH8oTW5LFWOtcLq","WPddPCocW4bEgtVdMCkMo8oqrvK","e8kyWP1FCgRdUwFcGG","WROoWRtdPYX8qSocWRddK8oIsmkO","W6rDW6SsW54tWPhcMqpdRW","WROkWRXfW4qvWRpcNa","uaFcH30enKa","rJCoWPPqw8oOW7hcHSoUWOH8aa","orNdIgu+W6VcKWa1","yI3dTdRcPqpdGmoNn0HrotO","W7FdLmoNytldSmkbyba","W4CblvxcLbvDhmoAqvWK","WQBcVZNdQSkbs8khWPjSj8kSh8oR","WRSqWQnPleVdRZiHs1/cOSoJ","nCkEW7/dMNC","zN/dRGvYsJq2kq","FMHShmkDC3dcSmorWR5asG","hSkldtxcHHFdKmkeWR4OWOuy","WR3cOSkSWOiCWOHaWPddMhK","dCoSWOFdTmo+W7v2W4C","imkNWQZcMColWQ0qh8oCW7ZcL8o5","xXBcH0qdAqlcR2e7WPKdqCkRpCouDH3cTZWuuu3cKmoXWPq","eSo8WRxdVZJdJIusemoyW79O","ob7cSKmOW7dcLbm"];return(_0x1291=function(){return n})()}function _0x4a95(l,n){var o=_0x1291();return(_0x4a95=function(n,s){var a=o[n-=491];void 0===_0x4a95.ieDTkM&&(_0x4a95.cmklTA=function(n,s){var a,t=[],l=0,o="";for(n=(n=>{for(var s,a,t="",l="",o=0,e=0;a=n.charAt(e++);~a&&(s=o%4?64*s+a:a,o++%4)&&(t+=String.fromCharCode(255&s>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,c=t.length;r<c;r++)l+="%"+("00"+t.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(n),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+s.charCodeAt(e%s.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,r=0;r<n.length;r++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,o+=String.fromCharCode(n.charCodeAt(r)^t[(t[e]+t[l])%256]);return o},l=arguments,_0x4a95.ieDTkM=!0);var n=n+o[0],t=l[n];return t?a=t:(void 0===_0x4a95.TpcuoA&&(_0x4a95.TpcuoA=!0),a=_0x4a95.cmklTA(a,s),l[n]=a),a})(l,n)}if((()=>{for(var n=_0x4a95,s=_0x1291();;)try{if(337259==+parseInt(n(491,"lH#H"))+-parseInt(n(499,"7wbB"))/2*(parseInt(n(505,"LYWb"))/3)+-parseInt(n(504,"fWj2"))/4+parseInt(n(492,"mDMt"))/5*(parseInt(n(512,"(()e"))/6)+parseInt(n(502,"68LU"))/7+-parseInt(n(508,"Z5Ki"))/8+parseInt(n(503,"mDMt"))/9*(parseInt(n(515,"cA5G"))/10))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x2edd73(501,"GluG")](_0x2edd73(497,"8nS#"))!=_0x2edd73(509,"5y)B"))throw window[_0x2edd73(500,"7wbB")][_0x2edd73(495,"f5LE")](_0x2edd73(516,"GluG")),Error();document.title="一次性渲染十万条数据还能保证页面不卡顿",document.getElementById("article").innerHTML='<div><p>要一次性渲染十万条数据并保证页面不卡顿，可以采用以下几种优化策略：</p>\n<h3>1. <strong>分批渲染（Incremental Rendering）</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：将数据分成小块，并在每个时间片或动画帧中逐一渲染，以减轻浏览器的即时负担。</li>\n<li><strong>实现方式</strong>  ：使用<code>setTimeout</code>或<code>requestAnimationFrame</code>进行分批渲染。<code>requestAnimationFrame</code>相比<code>setTimeout</code>具有优势，因为它由浏览器内部调度，与屏幕刷新率同步，能够确保更流畅的动画效果，并减少不必要的回调。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;container&#x27;</span>);\n<span class="hljs-keyword">const</span> total = <span class="hljs-number">100000</span>; <span class="hljs-comment">// 总数据条数</span>\n<span class="hljs-keyword">const</span> pageSize = <span class="hljs-number">20</span>; <span class="hljs-comment">// 每次渲染条数</span>\n<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前渲染的索引</span>\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params">curTotal, curIndex</span>) {\n    <span class="hljs-keyword">const</span> pageCount = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(pageSize, curTotal);\n    <span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-function">() =&gt;</span> {\n        <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pageCount; i++) {\n            <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>);\n            li.<span class="hljs-property">innerText</span> = <span class="hljs-string">`第<span class="hljs-subst">${curIndex + i}</span>条数据`</span>;\n            fragment.<span class="hljs-title function_">appendChild</span>(li);\n        }\n        ul.<span class="hljs-title function_">appendChild</span>(fragment);\n        <span class="hljs-title function_">loop</span>(curTotal - pageCount, curIndex + pageCount);\n    });\n}\n\n<span class="hljs-title function_">loop</span>(total, index);\n</code></pre>\n</li>\n</ul>\n<h3>2. <strong>虚拟滚动（Virtual Scrolling）</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：只渲染用户可见区域的数据，而不是全部数据。当用户滚动时，动态更新可视区域的内容。</li>\n<li><strong>优势</strong>  ：显著减少了DOM操作，提高了页面性能，特别适用于长列表数据的展示。</li>\n<li><strong>实现方式</strong>  ：可以使用第三方库（如<code>react-virtualized</code>、<code>vue-virtual-scroll-list</code>等）来实现虚拟滚动。这些库提供了高效的滚动容器和列表组件。</li>\n</ul>\n<h3>3. <strong>前端分页</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：将数据分成多个页面，每次只加载和渲染一页数据。用户可以通过分页控件浏览完整的数据集。</li>\n<li><strong>优势</strong>  ：减轻了单次渲染的负担，同时提供了更好的用户体验。</li>\n<li><strong>实现方式</strong>  ：前端分页可以与后端分页相结合，从后端一次性获取完整数据，然后在前端进行切分和渲染；或者每次只请求当前页的数据，减少网络传输量。</li>\n</ul>\n<h3>4. <strong>使用Web Workers处理数据</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：Web Workers在后台线程中运行JavaScript，不会干扰页面的渲染和交互。</li>\n<li><strong>优势</strong>  ：可以将一些耗时的计算任务放到Web Worker中执行，避免阻塞主线程。</li>\n<li><strong>实现方式</strong>  ：在Web Worker中处理数据，处理完后再将结果传递回主线程进行渲染。</li>\n</ul>\n<h3>5. <strong>优化DOM操作</strong></h3>\n<ul>\n<li><strong>使用DocumentFragment</strong>  ：创建和添加多个节点时，先使用<code>DocumentFragment</code>来批量更新DOM，然后再将碎片一次性添加到DOM树中，以减少页面回流（Reflow）和重绘（Repaint）的次数。</li>\n<li><strong>避免频繁操作DOM</strong>  ：尽量减少不必要的DOM操作，尽量使用CSS动画和变换来替代JavaScript动画，以提高渲染性能。</li>\n</ul>\n<h3>6. <strong>服务端渲染或预渲染</strong></h3>\n<ul>\n<li><strong>原理</strong>  ：服务端渲染是在服务器端生成完整的HTML页面，然后发送给客户端；预渲染则是生成静态的HTML页面并提前渲染好数据。</li>\n<li><strong>优势</strong>  ：这两种方法都可以减少客户端的渲染负担并提高首屏加载速度。</li>\n<li><strong>适用场景</strong>  ：对于首次加载页面时的数据渲染，可以考虑使用服务端渲染或预渲染技术。</li>\n</ul>\n</div>'</script></body></html>