<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x466abc=_0x1f35;function _0x1f35(t,s){var e=_0x1d01();return(_0x1f35=function(s,n){var a=e[s-=495];void 0===_0x1f35.TuaIkm&&(_0x1f35.RjyRUp=function(s,n){var a,p=[],t=0,e="";for(s=(s=>{for(var n,a,p="",t="",e=0,l=0;a=s.charAt(l++);~a&&(n=e%4?64*n+a:a,e++%4)&&(p+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=p.length;c<r;c++)t+="%"+("00"+p.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),l=0;l<256;l++)p[l]=l;for(l=0;l<256;l++)t=(t+p[l]+n.charCodeAt(l%n.length))%256,a=p[l],p[l]=p[t],p[t]=a;for(var l=0,t=0,c=0;c<s.length;c++)a=p[l=(l+1)%256],p[l]=p[t=(t+p[l])%256],p[t]=a,e+=String.fromCharCode(s.charCodeAt(c)^p[(p[l]+p[t])%256]);return e},t=arguments,_0x1f35.TuaIkm=!0);var s=s+e[0],p=t[s];return p?a=p:(void 0===_0x1f35.QrOwMm&&(_0x1f35.QrOwMm=!0),a=_0x1f35.RjyRUp(a,n),t[s]=a),a})(t,s)}function _0x1d01(){var s=["W7fnWOldQNbNW4NcHa","WPlcV3FcG0ztke0","W4FdK8k4W73cUgS6bG","W5KKWPaqW6LYWRS","W70GyK/cO0iWWRZdGX9CFq","WRzPwHldH8k6W6Om","WQy/cSkCWRywWOG","WQayfmkPletcTeRcObxdHCkvWO0","mL0wAJ8vzSkKW4O","bxXfwgddNSkctmkaWQSo","gZldG8o0fH/dUmksWRvOm3O","W7Tuv8oUBuZcOYBcOdhdVSkRWRlcSuZcNmkIWRPAW5Xlfmk3W6OKuq","r8oDaKqZWQNcTSoub8k+Dq","AuTQeCoKoa/dLmo3jfhdGq","WRzSpx3cO8oeWPutWPrBvNTV","W4T2WPZcOSo1","eCoGWPuHqSoodmoW","y0nIfSoNmgpdR8ohlNVdLmoz","ktvHAfCrENr6nf/cPsK","W6ffu8oYFXxdQq","fSoTW5Tzo8kXEmobW7TphCkUpG","h8kGreNdGSopW5S","WQ3dOSkAWQnQW5RdLCoxW7NcPfpdNW","a8o+WQRcPSoXW6ZcNa","W5aHFXi0a8ofW50GW4BcMmkjza","gvpcN8kat2ZdMa","WOhcKWBdSsNcQcRcN8olW6OHWQy","zJRdGfbNzmkTssGaW5mG"];return(_0x1d01=function(){return s})()}if((()=>{for(var s=_0x1f35,n=_0x1d01();;)try{if(520694==-parseInt(s(502,"(fjg"))+parseInt(s(515,"mmIT"))/2*(parseInt(s(501,"p0$Y"))/3)+parseInt(s(512,"6!7m"))/4+-parseInt(s(496,"r[K)"))/5*(-parseInt(s(495,"%n$#"))/6)+-parseInt(s(497,"ErxQ"))/7*(-parseInt(s(518,"Dma!"))/8)+parseInt(s(508,"6!7m"))/9*(-parseInt(s(506,"ErxQ"))/10)+parseInt(s(509,"NC7K"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x466abc(498,"xdtf")](_0x466abc(500,"26vt"))!=_0x466abc(507,"EzyT"))throw window[_0x466abc(521,"nRVZ")][_0x466abc(511,"]Ov4")](_0x466abc(503,"]Ov4")),Error();document.title="Vue 3 中应用(app)与组件的关联机制详解",document.getElementById("article").innerHTML='<div><p>Vue 3 通过一套精密的上下文系统和依赖注入机制将应用实例(app)与组件关联起来。以下是完整的实现原理分析：</p>\n<h2>1. 应用上下文传递机制</h2>\n<h3>1.1 应用上下文的创建</h3>\n<p>在 <code>createApp</code> 时创建应用上下文：</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// runtime-core/src/apiCreateApp.ts</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">createAppContext</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">AppContext</span> {\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">app</span>: <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>,  <span class="hljs-comment">// 将在createApp中被填充</span>\n    <span class="hljs-attr">config</span>: { <span class="hljs-comment">/* 全局配置 */</span> },\n    <span class="hljs-attr">mixins</span>: [],\n    <span class="hljs-attr">components</span>: {},    <span class="hljs-comment">// 全局组件注册表</span>\n    <span class="hljs-attr">directives</span>: {},    <span class="hljs-comment">// 全局指令注册表</span>\n    <span class="hljs-attr">provides</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)  <span class="hljs-comment">// 依赖注入容器</span>\n  }\n}\n</code></pre>\n<h3>1.2 上下文注入到组件树</h3>\n<p>在挂载时通过vnode传递上下文：</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// 创建根vnode时关联上下文</span>\n<span class="hljs-keyword">const</span> vnode = <span class="hljs-title function_">createVNode</span>(rootComponent, rootProps)\nvnode.<span class="hljs-property">appContext</span> = context  <span class="hljs-comment">// 关键关联点</span>\n</code></pre>\n<h2>2. 组件实例获取应用引用</h2>\n<h3>2.1 组件实例创建时的关联</h3>\n<p>在组件实例化过程中建立联系：</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// runtime-core/src/component.ts</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">createComponentInstance</span>(<span class="hljs-params">vnode, parent</span>) {\n  <span class="hljs-keyword">const</span> instance = {\n    <span class="hljs-attr">appContext</span>: vnode.<span class="hljs-property">appContext</span> || parent?.<span class="hljs-property">appContext</span>,\n    <span class="hljs-comment">// 其他实例属性...</span>\n  }\n  <span class="hljs-keyword">return</span> instance\n}\n</code></pre>\n<h3>2.2 关键属性解析</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>来源</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>appContext</code></td>\n<td>从父组件或根vnode继承</td>\n<td>提供全局配置和注册信息</td>\n</tr>\n<tr>\n<td><code>parent</code></td>\n<td>组件树结构</td>\n<td>维护组件层级关系</td>\n</tr>\n<tr>\n<td><code>provides</code></td>\n<td>继承父级或新建</td>\n<td>实现依赖注入链</td>\n</tr>\n</tbody>\n</table>\n<h2>3. 全局注册的组件/指令查找</h2>\n<h3>3.1 解析链优先级</h3>\n<p>组件解析顺序：</p>\n<ol>\n<li>局部注册的组件</li>\n<li>父组件链上的组件</li>\n<li>应用全局注册的组件</li>\n</ol>\n<pre><code class="language-typescript"><span class="hljs-comment">// runtime-core/src/componentAssets.ts</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveComponent</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="hljs-title function_">resolveAsset</span>(<span class="hljs-variable constant_">COMPONENTS</span>, name) || \n    currentRenderingInstance?.<span class="hljs-property">appContext</span>.<span class="hljs-property">components</span>[name]\n  )\n}\n</code></pre>\n<h3>3.2 指令解析类似过程</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveDirective</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="hljs-title function_">resolveAsset</span>(<span class="hljs-variable constant_">DIRECTIVES</span>, name) ||\n    currentRenderingInstance?.<span class="hljs-property">appContext</span>.<span class="hljs-property">directives</span>[name]\n  )\n}\n</code></pre>\n<h2>4. 依赖注入系统实现</h2>\n<h3>4.1 提供(provide)机制</h3>\n<pre><code class="language-typescript"><span class="hljs-comment">// runtime-core/src/apiInject.ts</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">provide</span>(<span class="hljs-params">key, value</span>) {\n  <span class="hljs-keyword">if</span> (!currentInstance) <span class="hljs-keyword">return</span>\n  \n  <span class="hljs-keyword">let</span> provides = currentInstance.<span class="hljs-property">provides</span>\n  <span class="hljs-keyword">const</span> parentProvides = currentInstance.<span class="hljs-property">parent</span>?.<span class="hljs-property">provides</span>\n  \n  <span class="hljs-comment">// 只有第一次需要原型继承</span>\n  <span class="hljs-keyword">if</span> (provides === parentProvides) {\n    provides = currentInstance.<span class="hljs-property">provides</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parentProvides)\n  }\n  \n  provides[key] = value\n}\n</code></pre>\n<h3>4.2 注入(inject)机制</h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inject</span>(<span class="hljs-params">key, defaultValue</span>) {\n  <span class="hljs-keyword">const</span> instance = currentInstance\n  <span class="hljs-keyword">if</span> (instance) {\n    <span class="hljs-keyword">const</span> provides = instance.<span class="hljs-property">provides</span>\n    <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> provides) {\n      <span class="hljs-keyword">return</span> provides[key]\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span>) {\n      <span class="hljs-keyword">return</span> defaultValue\n    }\n  }\n}\n</code></pre>\n<h2>5. 配置属性的继承</h2>\n<h3>5.1 全局属性访问</h3>\n<pre><code class="language-typescript"><span class="hljs-comment">// runtime-core/src/componentPublicInstance.ts</span>\n<span class="hljs-keyword">const</span> publicPropertiesMap = {\n  <span class="hljs-attr">$</span>: <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i,\n  <span class="hljs-attr">$el</span>: <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i.<span class="hljs-property">vnode</span>.<span class="hljs-property">el</span>,\n  <span class="hljs-attr">$options</span>: <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i.<span class="hljs-property">type</span>,\n  <span class="hljs-attr">$slots</span>: <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i.<span class="hljs-property">slots</span>,\n  <span class="hljs-attr">$props</span>: <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i.<span class="hljs-property">props</span>,\n  <span class="hljs-attr">$attrs</span>: <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i.<span class="hljs-property">attrs</span>,\n  <span class="hljs-attr">$root</span>: <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i.<span class="hljs-property">root</span>.<span class="hljs-property">proxy</span>,\n  <span class="hljs-attr">$parent</span>: <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i.<span class="hljs-property">parent</span>?.<span class="hljs-property">proxy</span>,\n  <span class="hljs-attr">$emit</span>: <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i.<span class="hljs-property">emit</span>,\n  \n  <span class="hljs-comment">// 从appContext访问全局属性</span>\n  <span class="hljs-attr">appContext</span>: <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i.<span class="hljs-property">appContext</span>.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>\n}\n</code></pre>\n<h2>6. 生命周期关联</h2>\n<p>组件生命周期与应用的关联：</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// runtime-core/src/component.ts</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">setupComponent</span>(<span class="hljs-params">instance</span>) {\n  <span class="hljs-comment">// 应用级别的错误处理</span>\n  <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">appContext</span>.<span class="hljs-property">config</span>.<span class="hljs-property">errorHandler</span>) {\n    <span class="hljs-title function_">setupErrorHandling</span>(instance)\n  }\n  \n  <span class="hljs-comment">// 混入全局mixins</span>\n  <span class="hljs-title function_">applyMixins</span>(instance, instance.<span class="hljs-property">appContext</span>.<span class="hljs-property">mixins</span>)\n}\n</code></pre>\n<h2>7. 渲染更新流程中的关联</h2>\n<p>在组件渲染时保持上下文：</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// runtime-core/src/renderer.ts</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">setupRenderEffect</span>(<span class="hljs-params">instance, initialVNode</span>) {\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">componentUpdateFn</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-keyword">if</span> (!instance.<span class="hljs-property">isMounted</span>) {\n      <span class="hljs-comment">// 渲染前保存当前实例</span>\n      <span class="hljs-title function_">setCurrentInstance</span>(instance)\n      <span class="hljs-comment">// 执行render函数</span>\n      <span class="hljs-keyword">const</span> subTree = instance.<span class="hljs-property">render</span>.<span class="hljs-title function_">call</span>(proxyToUse)\n      <span class="hljs-comment">// 渲染后清除当前实例</span>\n      <span class="hljs-title function_">setCurrentInstance</span>(<span class="hljs-literal">null</span>)\n    }\n  }\n}\n</code></pre>\n<h2>总结：关联架构图</h2>\n<pre><code>App Instance\n├─ appContext\n│  ├─ components (全局组件)\n│  ├─ directives (全局指令)\n│  ├─ provides (全局依赖)\n│  └─ config (全局配置)\n│\n└─ mount()\n   └─ 创建根组件实例\n      ├─ appContext (引用应用上下文)\n      ├─ parent (null)\n      └─ provides (原型链继承appContext.provides)\n         └─ 子组件实例\n            ├─ appContext (相同引用)\n            └─ provides (原型链继承)\n</code></pre>\n<p>这种设计使得Vue 3能够：</p>\n<ol>\n<li>高效共享全局资源</li>\n<li>实现精确的依赖注入</li>\n<li>保持组件树的独立性</li>\n<li>支持多应用共存场景</li>\n</ol>\n</div>'</script></body></html>