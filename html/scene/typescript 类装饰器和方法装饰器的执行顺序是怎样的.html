<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1881(){var s=["d8oEuGlcGXldUYJdLCkw","z1pdPs0gW5zZBq","WOxdGLyxWQe8cSoioSoHWPRdGY4","pSoKoWrXW7BcMSop","W5/dJ8oTgc8totdcUZnSWPa","tmogvMXaWPiCztr/WPiWta","W6xcImo+W4TOWRVcIHtcULldS2rT","W7vxW5NcK8owW6nahu3dHSkSrG","W7yGu8oCjG","aSozvMtcQsFdQqJdTa","W7LvW5NdSSkmWQjjnwi","WRfKfmkBASovBmoifmk4WPje","W7nxW53cKSouW6jllLxdR8kIAG","bCoknCkbWQ/cPMLIeG","W73cUdLfgxNcKSoCvXu6m8oH","W7/cTZ1nhhVdTCo6BH87fq","W57dISoPh19NiJJcTqO","W6JcNK7cRbZdUbJcTuNcPMBcI8k9WQChoqlcKSo9wI4+WOxcJ8kKWO4","W4ixcmorcCowWPy","W5zFW7m4WOdcMmku","tSoaiaWVW5zpuq","W7FdVCoPWQVdO0v8a8kLWRK2WRv1","WRldGvTfW6NcSmkJWQL2hfxcHq","n8kdWP5EEmoTjZKln8kgWRrN"];return(_0x1881=function(){return s})()}function _0x1e1a(t,s){var p=_0x1881();return(_0x1e1a=function(s,n){var a=p[s-=407];void 0===_0x1e1a.wdSsrP&&(_0x1e1a.gliYBQ=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,c=0;a=s.charAt(c++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,e=l.length;o<e;o++)t+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(t)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)t=(t+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[t],l[t]=a;for(var c=0,t=0,o=0;o<s.length;o++)a=l[c=(c+1)%256],l[c]=l[t=(t+l[c])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(o)^l[(l[c]+l[t])%256]);return p},t=arguments,_0x1e1a.wdSsrP=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x1e1a.SVaPsV&&(_0x1e1a.SVaPsV=!0),a=_0x1e1a.gliYBQ(a,n),t[s]=a),a})(t,s)}var _0x1f0631=_0x1e1a;if((()=>{for(var s=_0x1e1a,n=_0x1881();;)try{if(250905==-parseInt(s(413,"t92x"))+-parseInt(s(423,"erJG"))/2+parseInt(s(417,"r4Q$"))/3*(parseInt(s(410,")H(0"))/4)+-parseInt(s(415,"lP%$"))/5+-parseInt(s(426,"NprU"))/6*(-parseInt(s(429,"r4Q$"))/7)+parseInt(s(427,"E4pd"))/8+parseInt(s(422,"w38s"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1f0631(420,"cs0M")](_0x1f0631(414,"X2zS"))!=_0x1f0631(409,"xQG@"))throw window[_0x1f0631(428,"bOG8")][_0x1f0631(419,"TDSM")](_0x1f0631(418,"]TOp")),Error();document.title="typescript 类装饰器和方法装饰器的执行顺序是怎样的",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，类装饰器和方法装饰器的执行顺序遵循一定的规则。具体来说：</p>\n<h3>执行顺序</h3>\n<ol>\n<li><strong>装饰器评估</strong>  ：\n<ul>\n<li>这一步会计算装饰器表达式的值，按照装饰器出现的顺序进行。首先是类装饰器，然后是类内部的装饰器（包括方法装饰器、属性装饰器等）。</li>\n</ul>\n</li>\n<li><strong>装饰器应用</strong>  ：\n<ul>\n<li>在应用装饰器时，顺序为：\n<ul>\n<li>方法装饰器</li>\n<li>属性装饰器</li>\n<li>类装饰器</li>\n</ul>\n</li>\n<li>也就是说，方法装饰器会先于属性装饰器和类装饰器执行。</li>\n</ul>\n</li>\n<li><strong>多个装饰器的执行顺序</strong>  ：\n<ul>\n<li>如果同一个类型的装饰器有多个，总是先执行后面的装饰器。这是因为装饰器的执行顺序与它们的声明顺序相反，类似于栈的行为（后进先出）。</li>\n</ul>\n</li>\n</ol>\n<h3>示例</h3>\n<p>以下是一个简单的示例，展示了类装饰器和方法装饰器的执行顺序：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logClass</span>(<span class="hljs-params"><span class="hljs-attr">params</span>: <span class="hljs-built_in">string</span></span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-built_in">any</span></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`类装饰器: <span class="hljs-subst">${params}</span>`</span>);\n  };\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">logMethod</span>(<span class="hljs-params"><span class="hljs-attr">params</span>: <span class="hljs-built_in">string</span></span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">methodName</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">desc</span>: <span class="hljs-title class_">PropertyDescriptor</span></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`方法装饰器: <span class="hljs-subst">${methodName}</span> - <span class="hljs-subst">${params}</span>`</span>);\n  };\n}\n\n<span class="hljs-meta">@logClass</span>(<span class="hljs-string">&#x27;类装饰器1&#x27;</span>)\n<span class="hljs-meta">@logClass</span>(<span class="hljs-string">&#x27;类装饰器2&#x27;</span>)\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {\n  <span class="hljs-meta">@logMethod</span>(<span class="hljs-string">&#x27;方法装饰器1&#x27;</span>)\n  <span class="hljs-title function_">myMethod</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;方法执行&#x27;</span>);\n  }\n}\n\n<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();\ninstance.<span class="hljs-title function_">myMethod</span>();\n</code></pre>\n<h3>输出结果</h3>\n<p>执行上述代码时，控制台的输出顺序将是：</p>\n<pre><code>类装饰器: 类装饰器2\n类装饰器: 类装饰器1\n方法装饰器: myMethod - 方法装饰器1\n方法执行\n</code></pre>\n<h3>解释</h3>\n<ul>\n<li><strong>装饰器评估</strong>  ：首先计算 <code>@logClass(\'类装饰器1\')</code> 和 <code>@logClass(\'类装饰器2\')</code> 的值，得到两个装饰器函数。</li>\n<li><strong>装饰器应用</strong>  ：\n<ul>\n<li>先应用方法装饰器 <code>@logMethod(\'方法装饰器1\')</code>，输出 <code>方法装饰器: myMethod - 方法装饰器1</code>。</li>\n<li>然后应用属性装饰器（本例中没有属性装饰器）。</li>\n<li>最后应用类装饰器，先执行 <code>@logClass(\'类装饰器2\')</code>，输出 <code>类装饰器: 类装饰器2</code>，再执行 <code>@logClass(\'类装饰器1\')</code>，输出 <code>类装饰器: 类装饰器1</code>。</li>\n</ul>\n</li>\n</ul>\n<h3>总结</h3>\n<p>在 TypeScript 中，装饰器的执行顺序是先评估后应用，且应用时遵循方法装饰器优先于属性装饰器和类装饰器的顺序。如果有多个同类型的装饰器，则后声明的装饰器先执行。</p>\n</div>'</script></body></html>