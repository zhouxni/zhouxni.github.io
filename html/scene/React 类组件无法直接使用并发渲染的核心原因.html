<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1dfa(){var n=["WP/cGx7cHY7dTCoDyqlcMG","vSk7n8kNWRjCwSkCW79XW7hdRLG","yt3dIIhcTmkRBem4","auvOaeWucSkcsSoIDW","zhlcOH7cLG","yInOW6eKW6uqW40","bKvIcu9iz8kvBmowscNdOW","fCoRusWIqmkpWRG","AmofW7yuh8oRlCo9acHTB8kM","W4/dK8kPkNpdL8ogW60","WQFdK8k2W4xdRGNcJ8oHW4atva","nSkxbh4oW7XVk8objcXola","vCk4mmkNWRHAu8khW5LdW5VdTeK","W6pdU3ZdRsJdL8ojFSoaya","sCkVWQSIWP5sWRhdV8ktyLRdGCku","uuBcV8oAWOCplmkhWR/dO8krW6VdQN8","FNBdQu5kWPmVW6FdKWlcLa","zsVcVWf3z8o1FguDW7BdOSoIiW","WOJcTmoJW6iiavrY","WRnUDmozWOmkWPK","oCkvWRbLxSk9Dq","D8oBWRm+rKapW4xcRLhdTgtdGG","W43dM8odEtldTSoAW4ZdICo5W7e","WQuchSo4W7dcUGHfe8oLlCkKW49yW5RdJCoQjSkwW7GuvmoXW6CFWPm","W4pdHSo9WRvyW6SlEG","zcdcVG1YACo1be0eW47dNCob"];return(_0x1dfa=function(){return n})()}function _0x3473(s,n){var r=_0x1dfa();return(_0x3473=function(n,t){var o=r[n-=155];void 0===_0x3473.OoWdsc&&(_0x3473.XCSvOh=function(n,t){var o,e=[],s=0,r="";for(n=(n=>{for(var t,o,e="",s="",r=0,d=0;o=n.charAt(d++);~o&&(t=r%4?64*t+o:o,r++%4)&&(e+=String.fromCharCode(255&t>>(-2*r&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var c=0,a=e.length;c<a;c++)s+="%"+("00"+e.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(s)})(n),d=0;d<256;d++)e[d]=d;for(d=0;d<256;d++)s=(s+e[d]+t.charCodeAt(d%t.length))%256,o=e[d],e[d]=e[s],e[s]=o;for(var d=0,s=0,c=0;c<n.length;c++)o=e[d=(d+1)%256],e[d]=e[s=(s+e[d])%256],e[s]=o,r+=String.fromCharCode(n.charCodeAt(c)^e[(e[d]+e[s])%256]);return r},s=arguments,_0x3473.OoWdsc=!0);var n=n+r[0],e=s[n];return e?o=e:(void 0===_0x3473.AfjeJh&&(_0x3473.AfjeJh=!0),o=_0x3473.XCSvOh(o,t),s[n]=o),o})(s,n)}var _0x4098e9=_0x3473;if((()=>{for(var n=_0x3473,t=_0x1dfa();;)try{if(922720==+parseInt(n(167,"P6$4"))*(-parseInt(n(179,"VZ3L"))/2)+-parseInt(n(157,"q7a^"))/3+-parseInt(n(168,"JOyA"))/4+parseInt(n(177,"&FZy"))/5+parseInt(n(170,"#V[O"))/6+-parseInt(n(156,"LFuk"))/7*(parseInt(n(172,"1r0$"))/8)+-parseInt(n(160,"JOyA"))/9*(-parseInt(n(178,"dZL&"))/10))break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x4098e9(163,"&FZy")](_0x4098e9(171,"exD3"))!=_0x4098e9(173,")Pc3"))throw window[_0x4098e9(176,"ycQD")][_0x4098e9(162,"qq7*")](_0x4098e9(166,"HoZ9")),Error();document.title="React 类组件无法直接使用并发渲染的核心原因",document.getElementById("article").innerHTML='<div><p>React 类组件无法直接使用并发渲染的核心原因在于其<strong>生命周期模型</strong>  与<strong>状态管理机制</strong>  和并发模式存在根本性冲突。以下是详细解释：</p>\n<h3><strong>1. 类组件的生命周期方法与并发渲染冲突</strong></h3>\n<h4><strong>1.1 旧生命周期方法的副作用问题</strong></h4>\n<p>类组件依赖如 <code>componentWillReceiveProps</code>、<code>componentWillUpdate</code> 等方法，这些方法在并发渲染中会导致<strong>不一致的副作用</strong>  ：</p>\n<ul>\n<li><strong>示例问题</strong>  ：在并发渲染中，渲染可能被中断并重新开始。如果在 <code>componentWillReceiveProps</code> 中执行副作用（如数据获取），这些副作用可能会被触发多次，导致资源浪费或数据不一致。</li>\n</ul>\n<h4><strong>1.2 生命周期执行顺序的不可预测性</strong></h4>\n<p>并发渲染允许渲染过程被中断和恢复，这使得类组件的生命周期方法（如 <code>componentDidMount</code>）的执行时机变得<strong>不可预测</strong>  。类组件假设这些方法只会在渲染完成后执行一次，但并发模式可能违反这一假设。</p>\n<h3><strong>2. 类组件的状态更新机制与并发渲染不兼容</strong></h3>\n<h4><strong>2.1 类组件的状态更新是同步的</strong></h4>\n<ul>\n<li>类组件使用 <code>this.setState</code> 更新状态，且状态更新是<strong>同步执行</strong>  的（即使在 React 18 中）。</li>\n<li>并发渲染要求状态更新可以被<strong>暂停、恢复或放弃</strong>  ，而类组件的 <code>setState</code> 无法满足这一要求。</li>\n</ul>\n<h4><strong>2.2 函数组件的状态更新是“不可变”的</strong></h4>\n<ul>\n<li>函数组件通过 Hooks（如 <code>useState</code>）管理状态，状态更新是通过返回新值实现的，天然支持不可变性。</li>\n<li>类组件的 <code>this.state</code> 是可变的，直接修改 <code>this.state</code> 会导致并发渲染中的竞态条件。</li>\n</ul>\n<h3><strong>3. 并发渲染依赖的新特性仅支持函数组件</strong></h3>\n<h4><strong>3.1 Transition API</strong></h4>\n<ul>\n<li><code>useTransition</code> 和 <code>startTransition</code> 是并发渲染的核心特性，用于标记非紧急更新。类组件无法使用这些 Hooks。</li>\n</ul>\n<h4><strong>3.2 Suspense 与异步渲染</strong></h4>\n<ul>\n<li>函数组件可以通过 <code>Suspense</code> 和 <code>useEffect</code> 优雅地处理异步操作（如数据获取），而类组件需要依赖 <code>componentDidMount</code> 等生命周期方法，与并发模式的异步渲染模型不匹配。</li>\n</ul>\n<h3><strong>4. React 团队的设计决策</strong></h3>\n<h4><strong>4.1 优先支持函数组件</strong></h4>\n<p>React 团队在开发并发渲染时，选择将资源集中在函数组件和 Hooks 上，因为：</p>\n<ul>\n<li>函数组件是 React 的未来方向，Hooks 提供了更简洁的状态管理方式。</li>\n<li>重构类组件的生命周期模型以支持并发渲染的成本过高，且可能引入更多兼容性问题。</li>\n</ul>\n<h4><strong>4.2 向后兼容策略</strong></h4>\n<ul>\n<li>React 18 保留了对类组件的支持，但将其限制在旧的同步渲染模式中，确保现有应用无需重写即可升级。</li>\n</ul>\n<h3><strong>5. 类组件在并发模式下的限制示例</strong></h3>\n<p>以下代码展示了类组件在并发渲染中的潜在问题：</p>\n<pre><code class="language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassComponent</span> extends React.Component {\n  state = { data: null };\n\n  // 在并发渲染中可能被多次调用\n  componentWillReceiveProps(nextProps) {\n    <span class="hljs-keyword">if</span> (nextProps.<span class="hljs-built_in">id</span> !== this.props.<span class="hljs-built_in">id</span>) {\n      // 副作用：可能在渲染中断后重复执行\n      fetchData(nextProps.<span class="hljs-built_in">id</span>).then(data =&gt; this.setState({ data }));\n    }\n  }\n\n  render() {\n    <span class="hljs-keyword">return</span> &lt;div&gt;{this.state.data}&lt;/div&gt;;\n  }\n}\n</code></pre>\n<p>在并发渲染中，<code>componentWillReceiveProps</code> 可能被多次调用，导致重复的数据请求。</p>\n<h3><strong>总结：为什么类组件无法使用并发渲染？</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>冲突点</strong></th>\n<th><strong>类组件特性</strong></th>\n<th><strong>并发渲染要求</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>生命周期方法</td>\n<td>依赖同步执行的副作用</td>\n<td>需要支持中断、恢复和放弃的副作用模型</td>\n</tr>\n<tr>\n<td>状态管理</td>\n<td>可变的 <code>this.state</code> 和同步 <code>setState</code></td>\n<td>不可变状态和异步状态更新</td>\n</tr>\n<tr>\n<td>新特性支持</td>\n<td>不支持 Hooks</td>\n<td>依赖 <code>useTransition</code>、<code>useEffect</code> 等</td>\n</tr>\n<tr>\n<td>渲染模式</td>\n<td>同步渲染</td>\n<td>可中断的异步渲染</td>\n</tr>\n</tbody>\n</table>\n<p>React 团队的选择是<strong>让类组件保持在旧模式下运行，同时推动函数组件作为并发渲染的主要载体</strong>  。如果需要利用并发渲染的优势，建议将类组件迁移为函数组件。</p>\n</div>'</script></body></html>