<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x418207=_0x3ae4;function _0x3006(){var n=["C3/dLSovBSo6lSkPWQD+eN1F","hmo4l8kGWOLTWR3cOG","zZaLW6VcJwTzW6K","BSkkWP/dMZtdNmoj","WP1dW4dcPCkmW4pdTmo9W6tcUrZdKdq","W4RcLcPAnvVcVYCWWPVcVSkXWQi","W6VdHHpcS8osWO/dLgG4wG/cGSod","W6RdJbBcT8owWOJdNgy1qc7cHSow","WQVcIGdcMXxdLgxcQtX8W7i","W4SuWOFdM8ojWP/cRa","ssWPW796W4ddOqy6tNRcHG","jmo2WRrrW7W5W7yv","W5tcN8kRE8kxWQ5BcJVdQtpdG8kr","W7T0t0VdSSkEWR4","BmoeW4ZcHulcO8oxlCkyWPHxW5y","uMJdLSkAW5JdNSk1md3cSW","hSoTW5tcOmoHW4n5WR9KeIddM2PPW5dcN8kXAv1xW5rRWRRdOcy+","WRFcOCkdW7NcRCo/zmkEWQVdVW","fmkfWOqCWRz2lXdcLCktDhxdJW","W7BdVmogWQpcTmoVAq","WQODW4/dTSoJW50sW6KjhSkHW4jd","W6NdGrxcVmowWONdNKmPCqBcG8oI","pNz8WQK5WOFdHZO1","W4zdW7aJCqf0","WQVdJ1FdV2ldGhO","fCkiWPCTBCoPW49KyNZcHW","WP9cW4hcPmkmW4NdUmojW6ZcKa3dNXu","WOHXEmkEW5e"];return(_0x3006=function(){return n})()}function _0x3ae4(d,n){var s=_0x3006();return(_0x3ae4=function(n,t){var r=s[n-=175];void 0===_0x3ae4.AbQUzn&&(_0x3ae4.xbsHpW=function(n,t){var r,o=[],d=0,s="";for(n=(n=>{for(var t,r,o="",d="",s=0,g=0;r=n.charAt(g++);~r&&(t=s%4?64*t+r:r,s++%4)&&(o+=String.fromCharCode(255&t>>(-2*s&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var W=0,l=o.length;W<l;W++)d+="%"+("00"+o.charCodeAt(W).toString(16)).slice(-2);return decodeURIComponent(d)})(n),g=0;g<256;g++)o[g]=g;for(g=0;g<256;g++)d=(d+o[g]+t.charCodeAt(g%t.length))%256,r=o[g],o[g]=o[d],o[d]=r;for(var g=0,d=0,W=0;W<n.length;W++)r=o[g=(g+1)%256],o[g]=o[d=(d+o[g])%256],o[d]=r,s+=String.fromCharCode(n.charCodeAt(W)^o[(o[g]+o[d])%256]);return s},d=arguments,_0x3ae4.AbQUzn=!0);var n=n+s[0],o=d[n];return o?r=o:(void 0===_0x3ae4.dXtsPB&&(_0x3ae4.dXtsPB=!0),r=_0x3ae4.xbsHpW(r,t),d[n]=r),r})(d,n)}if((()=>{for(var n=_0x3ae4,t=_0x3006();;)try{if(707378==-parseInt(n(199,"7pxj"))+-parseInt(n(198,"^aec"))/2*(parseInt(n(191,"vv36"))/3)+parseInt(n(180,"i!JB"))/4*(-parseInt(n(185,"n52N"))/5)+parseInt(n(186,"qXDP"))/6*(parseInt(n(190,"t]z7"))/7)+-parseInt(n(202,"k@Y#"))/8*(-parseInt(n(193,"yC69"))/9)+parseInt(n(197,"dQbz"))/10+-parseInt(n(192,"vv36"))/11)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x418207(194,"3^[v")](_0x418207(179,")L(r"))!=_0x418207(184,"Q1EQ"))throw window[_0x418207(196,"71vn")][_0x418207(176,"k@Y#")](_0x418207(201,"7m9H")),Error();document.title="双向链表的优势",document.getElementById("article").innerHTML="<div><p>双向链表、set、数组是三种完全不同的数据结构，它们各自擅长的场景不同。双向链表的优势主要体现在以下几个方面：</p>\n<hr>\n<h3>✅ <strong>1. 高效的插入与删除（已知节点位置）</strong></h3>\n<ul>\n<li><strong>双向链表</strong>   ：在已知某个节点指针的前提下，<strong>插入/删除的时间复杂度为 O(1)</strong>   ，因为只需要调整前后节点的指针即可。</li>\n<li><strong>数组</strong>   ：插入/删除需要移动后续元素，<strong>时间复杂度为 O(n)</strong>   。</li>\n<li><strong>set</strong>   ：虽然插入/删除平均也是 O(log n)（如红黑树实现）或 O(1)（如哈希表实现），但<strong>前提是你知道要插入/删除的值</strong>   ，而不是“在某个位置”操作。</li>\n</ul>\n<hr>\n<h3>✅ <strong>2. 支持双向遍历</strong></h3>\n<ul>\n<li><strong>双向链表</strong>   ：可以从头到尾或从尾到头遍历，适合需要前后移动的场景（如LRU缓存、浏览器历史）。</li>\n<li><strong>数组</strong>   ：只能从头或尾单向遍历（除非用下标模拟）。</li>\n<li><strong>set</strong>   ：通常是<strong>无序</strong>   的（如哈希set），或按排序规则遍历（如红黑树set），<strong>不支持双向遍历</strong>   。</li>\n</ul>\n<hr>\n<h3>✅ <strong>3. 稳定的迭代器（指针不失效）</strong></h3>\n<ul>\n<li><strong>双向链表</strong>   ：插入/删除<strong>不会使现有迭代器失效</strong>   （除非你删除的就是迭代器指向的节点）。</li>\n<li><strong>数组</strong>   ：插入/删除可能导致<strong>所有后续元素的地址变化</strong>   ，迭代器失效。</li>\n<li><strong>set</strong>   ：插入不会使迭代器失效，但删除会使<strong>指向被删元素的迭代器失效</strong>   。</li>\n</ul>\n<hr>\n<h3>✅ <strong>4. 适合实现“有序+频繁插入删除”的场景</strong></h3>\n<ul>\n<li><strong>双向链表</strong>   可以保持元素的原始顺序（不像set会自动排序），同时支持高效插入删除。</li>\n<li><strong>例子</strong>   ：\n<ul>\n<li>LRU缓存（需要按访问顺序维护元素，频繁移动节点）。</li>\n<li>文本编辑器的撤销/重做（需要双向遍历历史记录）。</li>\n<li>任务调度队列（支持从中间删除任务）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>✅ <strong>5. 内存分配灵活（非连续）</strong></h3>\n<ul>\n<li><strong>双向链表</strong>   ：每个节点单独分配，<strong>不需要连续内存</strong>   ，适合<strong>大对象</strong>   或<strong>内存碎片多</strong>   的场景。</li>\n<li><strong>数组</strong>   ：需要连续内存，可能因内存不足而扩容失败（即使总内存足够）。</li>\n<li><strong>set</strong>   ：也分散存储，但节点结构通常更复杂（如红黑树有颜色、父指针等）。</li>\n</ul>\n<hr>\n<h3>❗注意：双向链表的劣势</h3>\n<ul>\n<li><strong>随机访问慢</strong>   ：不能像数组那样用下标 O(1) 访问，必须从头遍历 O(n)。</li>\n<li><strong>额外内存开销</strong>   ：每个节点需要两个指针（prev/next），比数组/set更占空间。</li>\n<li><strong>缓存不友好</strong>   ：非连续存储，CPU缓存命中率低。</li>\n</ul>\n<hr>\n<h3>✅ 总结：何时选双向链表？</h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>双向链表</th>\n<th>数组</th>\n<th>set</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>频繁中间插入/删除</td>\n<td>✅ O(1)</td>\n<td>❌ O(n)</td>\n<td>❌ 需先查找</td>\n</tr>\n<tr>\n<td>需要双向遍历</td>\n<td>✅</td>\n<td>❌</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>保持插入顺序</td>\n<td>✅</td>\n<td>✅</td>\n<td>❌（自动排序）</td>\n</tr>\n<tr>\n<td>随机访问</td>\n<td>❌ O(n)</td>\n<td>✅ O(1)</td>\n<td>❌ O(log n) 或 O(1)</td>\n</tr>\n<tr>\n<td>内存连续性</td>\n<td>❌</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n</tbody>\n</table>\n<p><strong>一句话总结</strong>   ：<br>\n<strong>双向链表的核心优势是“在已知位置下，高效插入/删除且能双向遍历”，适合顺序敏感且频繁修改的结构（如LRU、任务队列）。</strong></p>\n</div>"</script></body></html>