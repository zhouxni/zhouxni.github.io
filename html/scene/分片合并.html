<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2d3058=_0x28a4;function _0x5b15(){var s=["uxldTqOuWQ3cG8oiiITr","d8o0WQBcG1fvW4hcKdZdOgH/","nCoZCH0pn33dNJDYqmokWQm","C3GjC8kXWRTAFwfIW4FdMq","ESogaLZcQ8kRW61j","W4hcOdJcOKG+WPC5WOWudGtcHGXFW44qW73cGLWIteCRESoF","i8kQd8otsCk3u8kv","WPyyWO4ofZ0LjH/cQWS","W5n0W4pdImkBnWyz","wh0KWQBcU8kXCSopWRjoWR4","yJBcNcRdLbVcJ8oumG","W4aDFCkhWOfQaq","ESkyW7fSWOGaW4VdVmkoWQqNW4D1","vLGZWQ/cP8ofW43cNgtdVCoqW7W","W4fjjSomW78LDmkfWPTWW5ddLrG","n8kMWPddUmokWPddRa/cTcOIW6y","WPRdLSkIW7f8WOqSWR0","CCoKW5FcUSkk","W4NcVmoCjbjogXNcQ2NdK8oEDq","BmkPW5aRWQ/cIudcLSkoWRBdP20","W5FdGSkXW7JcMCoLWQ7dLSoEW4qH","WP3dPH7cVx5kW4fd","kmkuW6TVWRtcV8onWQm","W556WPxcHM/dNCoO","fgtdHNJcKv3cKmoKoxbmha","gu/dVgxcMf3dVG","CIvCpSomW71y","W5BcQbCyW4VcG8o5pq"];return(_0x5b15=function(){return s})()}function _0x28a4(c,s){var t=_0x5b15();return(_0x28a4=function(s,n){var a=t[s-=332];void 0===_0x28a4.TqQQWp&&(_0x28a4.mcuufL=function(s,n){var a,l=[],c=0,t="";for(s=(s=>{for(var n,a,l="",c="",t=0,e=0;a=s.charAt(e++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,p=l.length;o<p;o++)c+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(c)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)c=(c+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[c],l[c]=a;for(var e=0,c=0,o=0;o<s.length;o++)a=l[e=(e+1)%256],l[e]=l[c=(c+l[e])%256],l[c]=a,t+=String.fromCharCode(s.charCodeAt(o)^l[(l[e]+l[c])%256]);return t},c=arguments,_0x28a4.TqQQWp=!0);var s=s+t[0],l=c[s];return l?a=l:(void 0===_0x28a4.ScRieY&&(_0x28a4.ScRieY=!0),a=_0x28a4.mcuufL(a,n),c[s]=a),a})(c,s)}if((()=>{for(var s=_0x28a4,n=_0x5b15();;)try{if(231747==-parseInt(s(344,"CQfY"))*(-parseInt(s(340,"imGV"))/2)+parseInt(s(355,"7PPq"))/3*(parseInt(s(338,"e^Od"))/4)+-parseInt(s(336,"Pu5O"))/5+parseInt(s(332,"EsJA"))/6*(-parseInt(s(333,"@OW9"))/7)+parseInt(s(352,"rZwk"))/8+-parseInt(s(334,"AHuI"))/9*(-parseInt(s(359,"Z6xw"))/10)+-parseInt(s(342,"(NV$"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x2d3058(337,"MiLU")](_0x2d3058(350,"Pu5O"))!=_0x2d3058(357,"7PPq"))throw window[_0x2d3058(356,"FUNL")][_0x2d3058(335,"GcJF")](_0x2d3058(345,"@OW9")),Error();document.title="分片合并",document.getElementById("article").innerHTML='<div><p>在 Node.js 中合并分片文件通常涉及读取所有分片文件并将它们按顺序写入一个新的文件中。以下是一个简单的示例，展示如何实现这一功能。假设你已经接收了多个分片文件，并且它们被存储在服务器的某个目录中，每个分片文件以某种方式命名（例如，通过索引或 UUID）来表明它们的顺序。</p>\n<h3>示例步骤</h3>\n<ol>\n<li><strong>确保分片顺序</strong>  ：在合并之前，需要确保所有分片按照正确的顺序排列。这通常通过文件名中的索引或某种排序逻辑来实现。</li>\n<li><strong>读取并写入文件</strong>  ：使用 Node.js 的 <code>fs</code> 模块来读取每个分片文件，并将它们的内容写入到目标文件中。</li>\n<li><strong>清理临时文件</strong>  （可选）：合并完成后，可以选择删除分片文件以释放存储空间。</li>\n</ol>\n<h3>示例代码</h3>\n<p>以下是一个简单的示例代码，展示如何合并分片文件：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);\n<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);\n\n<span class="hljs-comment">/**\n * 合并分片文件\n * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">dir</span> - 分片文件所在的目录\n * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">outputFile</span> - 合并后的输出文件路径\n * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">totalChunks</span> - 分片总数\n */</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeChunks</span>(<span class="hljs-params">dir, outputFile, totalChunks</span>) {\n    <span class="hljs-keyword">const</span> writeStream = fs.<span class="hljs-title function_">createWriteStream</span>(outputFile);\n\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; totalChunks; i++) {\n        <span class="hljs-keyword">const</span> chunkFileName = path.<span class="hljs-title function_">join</span>(dir, <span class="hljs-string">`chunk_<span class="hljs-subst">${i}</span>`</span>); <span class="hljs-comment">// 假设分片文件名为 chunk_0, chunk_1, ...</span>\n\n        <span class="hljs-keyword">const</span> chunkData = fs.<span class="hljs-title function_">readFileSync</span>(chunkFileName);\n        writeStream.<span class="hljs-title function_">write</span>(chunkData);\n\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Merged chunk <span class="hljs-subst">${i}</span>`</span>);\n    }\n\n    writeStream.<span class="hljs-title function_">end</span>();\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;All chunks merged successfully.&#x27;</span>);\n\n    <span class="hljs-comment">// 可选：合并完成后删除分片文件</span>\n    <span class="hljs-comment">// for (let i = 0; i &lt; totalChunks; i++) {</span>\n    <span class="hljs-comment">//     const chunkFileName = path.join(dir, `chunk_${i}`);</span>\n    <span class="hljs-comment">//     fs.unlinkSync(chunkFileName);</span>\n    <span class="hljs-comment">//     console.log(`Deleted chunk file ${chunkFileName}`);</span>\n    <span class="hljs-comment">// }</span>\n}\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-keyword">const</span> directory = <span class="hljs-string">&#x27;./chunks&#x27;</span>; <span class="hljs-comment">// 分片文件存储的目录</span>\n<span class="hljs-keyword">const</span> outputFilePath = <span class="hljs-string">&#x27;./merged_file.ext&#x27;</span>; <span class="hljs-comment">// 合并后的文件路径</span>\n<span class="hljs-keyword">const</span> totalChunks = <span class="hljs-number">5</span>; <span class="hljs-comment">// 假设总共有 5 个分片</span>\n\n<span class="hljs-title function_">mergeChunks</span>(directory, outputFilePath, totalChunks);\n</code></pre>\n<h3>注意事项</h3>\n<ol>\n<li><strong>分片命名</strong>  ：确保分片文件的命名方式能够反映它们的顺序。在上面的示例中，假设分片文件名为 <code>chunk_0</code>, <code>chunk_1</code>, 等。根据你的实际情况，可能需要调整命名规则。</li>\n<li><strong>错误处理</strong>  ：在实际应用中，应添加错误处理逻辑，以处理文件读取失败、写入失败等情况。</li>\n<li><strong>异步处理</strong>  ：上面的示例使用了同步文件读取（<code>fs.readFileSync</code>）来简化代码。在生产环境中，建议使用异步文件读取（<code>fs.readFile</code>）和写入（<code>fs.createWriteStream</code> 与 <code>write</code> 方法的异步组合）来提高性能。</li>\n<li><strong>流的使用</strong>  ：对于大文件或大量分片，使用流（<code>stream</code>）来处理文件读写会更高效，因为它可以减少内存占用。上面的示例已经使用了写流（<code>fs.createWriteStream</code>），但读取部分也可以改为使用流来进一步优化。</li>\n<li><strong>清理临时文件</strong>  ：合并完成后，通常可以删除分片文件以释放存储空间。但请确保在确认合并成功后再删除，以避免数据丢失。</li>\n</ol>\n</div>'</script></body></html>