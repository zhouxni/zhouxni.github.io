<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5913(r,n){var e=_0x4864();return(_0x5913=function(n,s){var t=e[n-=104];void 0===_0x5913.MWnUyQ&&(_0x5913.OXyFZC=function(n,s){var t,a=[],r=0,e="";for(n=(n=>{for(var s,t,a="",r="",e=0,l=0;t=n.charAt(l++);~t&&(s=e%4?64*s+t:t,e++%4)&&(a+=String.fromCharCode(255&s>>(-2*e&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var o=0,c=a.length;o<c;o++)r+="%"+("00"+a.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(r)})(n),l=0;l<256;l++)a[l]=l;for(l=0;l<256;l++)r=(r+a[l]+s.charCodeAt(l%s.length))%256,t=a[l],a[l]=a[r],a[r]=t;for(var l=0,r=0,o=0;o<n.length;o++)t=a[l=(l+1)%256],a[l]=a[r=(r+a[l])%256],a[r]=t,e+=String.fromCharCode(n.charCodeAt(o)^a[(a[l]+a[r])%256]);return e},r=arguments,_0x5913.MWnUyQ=!0);var n=n+e[0],a=r[n];return a?t=a:(void 0===_0x5913.QTfArY&&(_0x5913.QTfArY=!0),t=_0x5913.OXyFZC(t,s),r[n]=t),t})(r,n)}var _0xf99ff3=_0x5913;if((()=>{for(var n=_0x5913,s=_0x4864();;)try{if(952438==-parseInt(n(120,"JExD"))*(parseInt(n(118,"[1R*"))/2)+parseInt(n(115,"tw*("))/3*(-parseInt(n(110,"BSht"))/4)+parseInt(n(117,"K%3v"))/5+-parseInt(n(121,"tVij"))/6*(-parseInt(n(128,"JExD"))/7)+parseInt(n(116,"gPVa"))/8+parseInt(n(125,"ODxJ"))/9+-parseInt(n(107,"jj#a"))/10)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0xf99ff3(105,"#^ar")](_0xf99ff3(108,"DF&!"))!=_0xf99ff3(111,"B2[m"))throw window[_0xf99ff3(104,"5ifo")][_0xf99ff3(109,"DRfk")](_0xf99ff3(106,"vf2W")),Error();function _0x4864(){var n=["W4S6nsNdSrddVGbfj8kOBdhdOSkEtgRdG2BcVcXMi8kCWPZdKW","AcxcUeqxWOPpCmkIWOZdKCkEWOe","tmoiWONcOX4MW4VcT8of","W418WQLyWPpdGee","WRPqWOKxbSkOW5hdGCkk","W5ddVCoFr1u","WQBdT8oiW73cGCkvwSouW44","r8kCAxdcMCkWb8k2ugXB","WPTkCCoEWQargM7dVZddLq","uSokWQldKdmHWOOfW63cJ8kN","cc9tye4Ze8otcmo9dSktWP9q","W6FdKMe9WQ87WRbWzGVdRcCq","A8oLW4LegmoHWR3cJCk0W4pcQa","WRVdRIlcMSkpqmoGWQe","W7VcM8okz1OFWP3cGKW","WPfciCkWW4arfNq","vSofWQxdKtndW5qGW6FcJmkZb8ke","W5BcKSkCW4HqCbvppa","yYpcUKGqWOXjsmkSWPddISksWRi","W5FcM8krWOizhu13kCk0W65RkG","WRLuWOLeD8oXWPNcVSkBWRNcSJJdUfK","xgZdJSoKFxBcIf3cOmkJW7KFiq","W73cKSoeirz1WQdcPflcSCkbWQS","DGnRlmoiy1Pf","WQ5GW613W4zrW7q"];return(_0x4864=function(){return n})()}document.title="Vue 的模板编译流程",document.getElementById("article").innerHTML='<div><p>Vue 的模板编译流程，就是把开发者写的 <strong>模板字符串（Template）</strong>   转换成 <strong>可执行的渲染函数（Render Function）</strong>   的过程。<br>\n整个流程可以分为三大阶段：<strong>解析 → 优化 → 代码生成</strong>   ，最终产出 <code>render</code> 函数，供 Vue 运行时调用。</p>\n<hr>\n<h2>🧩 一、整体流程图（Vue 2 &amp; Vue 3 对比）</h2>\n<table>\n<thead>\n<tr>\n<th>阶段</th>\n<th>Vue 2</th>\n<th>Vue 3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>解析（Parse）</strong></td>\n<td>正则 + 递归下降</td>\n<td>基于 <code>acorn</code> 的 AST 解析</td>\n</tr>\n<tr>\n<td><strong>优化（Optimize）</strong></td>\n<td>标记静态节点</td>\n<td>标记静态节点 + 提升</td>\n</tr>\n<tr>\n<td><strong>代码生成（Codegen）</strong></td>\n<td><code>with(this){}</code> 字符串拼接</td>\n<td>AST → 字符串/函数拼接</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>🪄 二、Vue 模板编译流程详解（以 Vue 3 为主）</h2>\n<h3>① 解析（Parse）</h3>\n<p><strong>输入</strong>   ：模板字符串<br>\n<strong>输出</strong>   ：AST（抽象语法树）</p>\n<ul>\n<li>使用 <strong>HTML Parser</strong>   解析模板，生成 AST：\n<ul>\n<li>标签、属性、指令（<code>v-if</code>、<code>v-for</code> 等）</li>\n<li>文本节点、表达式（<code>{{ msg }}</code>）</li>\n</ul>\n</li>\n<li>处理错误和警告（如标签未闭合）</li>\n</ul>\n<pre><code class="language-js"><span class="hljs-comment">// 模板</span>\n&lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ msg }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>\n&lt;/div&gt;\n\n<span class="hljs-comment">// AST 结构（简化）</span>\n{\n  <span class="hljs-attr">type</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 元素节点</span>\n  <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>,\n  <span class="hljs-attr">props</span>: [{ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;app&#x27;</span> }],\n  <span class="hljs-attr">children</span>: [\n    {\n      <span class="hljs-attr">type</span>: <span class="hljs-number">1</span>,\n      <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;p&#x27;</span>,\n      <span class="hljs-attr">children</span>: [\n        { <span class="hljs-attr">type</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">expression</span>: <span class="hljs-string">&#x27;_ctx.msg&#x27;</span> } <span class="hljs-comment">// 文本表达式</span>\n      ]\n    }\n  ]\n}\n</code></pre>\n<hr>\n<h3>② 优化（Optimize）</h3>\n<p><strong>输入</strong>   ：AST<br>\n<strong>输出</strong>   ：优化后的 AST（带静态标记）</p>\n<ul>\n<li><strong>标记静态节点</strong>   （永远不会变的节点）</li>\n<li><strong>静态提升</strong>   （Vue 3 新增）：把静态节点提升到渲染函数外部，避免每次重新创建</li>\n<li><strong>Patch Flag</strong>   （Vue 3 新增）：标记动态属性/文本，优化 diff</li>\n</ul>\n<pre><code class="language-js"><span class="hljs-comment">// 优化后 AST 会标记：</span>\n- 静态节点：跳过 diff\n- 动态节点：添加 patchFlag（如 <span class="hljs-variable constant_">TEXT</span>、<span class="hljs-variable constant_">CLASS</span>、<span class="hljs-variable constant_">STYLE</span> 等）\n</code></pre>\n<hr>\n<h3>③ 代码生成（Codegen）</h3>\n<p><strong>输入</strong>   ：优化后的 AST<br>\n<strong>输出</strong>   ：<code>render</code> 函数字符串</p>\n<ul>\n<li>使用 <strong>字符串拼接</strong>   或 <strong>函数拼接</strong>   生成 <code>render</code> 函数</li>\n<li>Vue 3 使用 <strong>AST 转字符串</strong>   （更可控，避免 <code>with</code>）</li>\n</ul>\n<pre><code class="language-js"><span class="hljs-comment">// Vue 3 生成的 render 函数（简化）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">_ctx, _cache</span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="hljs-title function_">_openBlock</span>(),\n    <span class="hljs-title function_">_createElementBlock</span>(<span class="hljs-string">&quot;div&quot;</span>, { <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;app&quot;</span> }, [\n      <span class="hljs-title function_">_createElementVNode</span>(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-title function_">_toDisplayString</span>(_ctx.<span class="hljs-property">msg</span>), <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>),\n    ])\n  );\n}\n</code></pre>\n<hr>\n<h2>🧪 三、编译时 vs 运行时</h2>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>编译时机</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>运行时编译</strong></td>\n<td>浏览器运行时</td>\n<td>使用 <code>vue.esm-browser.js</code>，模板字符串在运行时编译（体积大）</td>\n</tr>\n<tr>\n<td><strong>构建时编译</strong></td>\n<td><code>vue-loader</code> / <code>@vitejs/plugin-vue</code></td>\n<td>模板在构建时预编译为 <code>render</code> 函数（体积小，性能好）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>🧰 四、调试工具</h2>\n<ul>\n<li>Vue 3 的编译器源码在 <code>packages/compiler-core</code> 和 <code>packages/compiler-dom</code></li>\n<li>在线 AST 查看器：<a href="https://astexplorer.net/" target="_blank">https://astexplorer.net/</a>（选 Vue）</li>\n</ul>\n<hr>\n<h2>✅ 总结一句话</h2>\n<blockquote>\n<p>Vue 模板编译 = 模板字符串 → AST → 优化静态节点 → 生成 render 函数 → 运行时渲染。</p>\n</blockquote>\n<p>如果你有具体模板想知道它编译后长什么样，我可以帮你现场编译一段看看。</p>\n</div>'</script></body></html>