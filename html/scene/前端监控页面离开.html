<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1c0a7d=_0x5d02;function _0x5d02(t,s){var l=_0x5ddb();return(_0x5d02=function(s,n){var a=l[s-=225];void 0===_0x5d02.Ouespr&&(_0x5d02.OOxOQG=function(s,n){var a,e=[],t=0,l="";for(s=(s=>{for(var n,a,e="",t="",l=0,o=0;a=s.charAt(o++);~a&&(n=l%4?64*n+a:a,l++%4)&&(e+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,p=e.length;c<p;c++)t+="%"+("00"+e.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),o=0;o<256;o++)e[o]=o;for(o=0;o<256;o++)t=(t+e[o]+n.charCodeAt(o%n.length))%256,a=e[o],e[o]=e[t],e[t]=a;for(var o=0,t=0,c=0;c<s.length;c++)a=e[o=(o+1)%256],e[o]=e[t=(t+e[o])%256],e[t]=a,l+=String.fromCharCode(s.charCodeAt(c)^e[(e[o]+e[t])%256]);return l},t=arguments,_0x5d02.Ouespr=!0);var s=s+l[0],e=t[s];return e?a=e:(void 0===_0x5d02.wTBzRI&&(_0x5d02.wTBzRI=!0),a=_0x5d02.OOxOQG(a,n),t[s]=a),a})(t,s)}function _0x5ddb(){var s=["W5LqW6JcNCkLWRyDW5CFea","WQhcJqhcQgtdMguGnxOUWRFcVG","s8oWWQFdMNm","W6VdUr/cPCk2WQ3cHSotBvrRjSkN","oqfCFSofsIr2nmkj","W4jLjKBcQCoOWQ5c","W6FcQCo5b8o8BSoaWRNcVanYhq","WQRcR1JdVSoLW7BdMW","bN/dRSkQe8k/WPNdL8oJaYjk","BmkeW5qVeexcVa","WRfytH8JW48JvSkQnmoU","fSoCWPXCWQvmWPtdRCkb","WPC/C1dcVmojWQnEW7e","W5xcOwFcR8osW5/dI3BdQ8kAWOVdJ2K","WOeWWO3cG2VcKa3dSCkibwu","WOhdRCkicMhdVvdcG8od","ASocWOBdLHFdOmk9WQ/dOrjBymo/WOBdPb0xsHyPW5xdH8kMF8kMAG","pM3dTfq8W7RdM8oVnCorW4JcLae","W78VAvKlW57cQ8otWQ/dQKVcJSok","bNZdQSkIemk+WOZdV8ovfs9T","fSkxmCocW7RdTCoatmkt","W7qaDNldNtddRSk2WRCXoCotWOy","o8kdW4tdKqxcKSoWW7ldNa","W65dECk3gxyBrSkmW7WjqG"];return(_0x5ddb=function(){return s})()}if((()=>{for(var s=_0x5d02,n=_0x5ddb();;)try{if(525574==-parseInt(s(248,"ca]A"))+-parseInt(s(237,"@rw5"))/2*(parseInt(s(229,"^%GI"))/3)+parseInt(s(228,"@XOM"))/4+-parseInt(s(245,"epMG"))/5*(-parseInt(s(239,"kuER"))/6)+parseInt(s(233,"VqZ2"))/7+-parseInt(s(246,"wWhB"))/8+parseInt(s(238,"eQPP"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1c0a7d(234,"BZIi")](_0x1c0a7d(240,"txaA"))!=_0x1c0a7d(227,"dy#@"))throw window[_0x1c0a7d(230,"@rw5")][_0x1c0a7d(232,"@XOM")](_0x1c0a7d(241,"l^4G")),Error();document.title="前端监控页面离开",document.getElementById("article").innerHTML='<div><p>前端监控页面离开（如关闭、跳转、刷新等）是用户行为分析的重要部分，通常用于统计用户停留时间、流失率等。以下是 <strong>完整的前端监控页面离开的方法</strong>   ，涵盖不同场景和兼容性处理：</p>\n<hr>\n<h2><strong>1. 核心方法：监听页面卸载事件</strong></h2>\n<p>页面离开的核心事件包括 <code>beforeunload</code>、<code>unload</code> 和 <code>pagehide</code>，它们在不同场景下触发：</p>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>触发时机</th>\n<th>是否可靠</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>beforeunload</code></td>\n<td>页面即将卸载（刷新、关闭、导航）</td>\n<td>部分浏览器可能不触发（如移动端）</td>\n<td>简单场景</td>\n</tr>\n<tr>\n<td><code>unload</code></td>\n<td>页面正在卸载（资源清理阶段）</td>\n<td>可靠性较低，异步请求可能被中断</td>\n<td>数据清理</td>\n</tr>\n<tr>\n<td><code>pagehide</code></td>\n<td>页面隐藏或导航离开（包括 bfcache 情况）</td>\n<td>更可靠，覆盖移动端和 bfcache</td>\n<td>移动端、SPA</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>基础实现（<code>beforeunload</code> + <code>unload</code>）</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 记录页面加载时间</span>\n<span class="hljs-keyword">let</span> pageLoadTime = performance.<span class="hljs-title function_">now</span>();\n\n<span class="hljs-comment">// 监听页面卸载事件</span>\n<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;beforeunload&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> stayTime = performance.<span class="hljs-title function_">now</span>() - pageLoadTime;\n  <span class="hljs-title function_">sendStayTimeToServer</span>(stayTime); <span class="hljs-comment">// 需异步处理（见下文）</span>\n});\n\n<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;unload&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 可用于清理数据，但避免异步操作</span>\n});\n</code></pre>\n<p><strong>问题</strong>   ：</p>\n<ul>\n<li><code>beforeunload</code> 在移动端可能不触发。</li>\n<li><code>unload</code> 中的异步请求（如 <code>fetch</code>）可能被浏览器中断。</li>\n</ul>\n<hr>\n<h2><strong>2. 更可靠的方案：<code>pagehide</code> + <code>visibilitychange</code></strong></h2>\n<p>结合 <code>pagehide</code>（覆盖移动端和 bfcache）和 <code>visibilitychange</code>（监听标签页切换），提高覆盖率。</p>\n<h3><strong>完整实现</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> pageLoadTime = performance.<span class="hljs-title function_">now</span>();\n<span class="hljs-keyword">let</span> totalStayTime = <span class="hljs-number">0</span>;\n<span class="hljs-keyword">let</span> lastVisibleTime = pageLoadTime;\n\n<span class="hljs-comment">// 1. 监听可见性变化（标签页切换、最小化）</span>\n<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;visibilitychange&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">visibilityState</span> === <span class="hljs-string">&quot;hidden&quot;</span>) {\n    totalStayTime += performance.<span class="hljs-title function_">now</span>() - lastVisibleTime;\n  } <span class="hljs-keyword">else</span> {\n    lastVisibleTime = performance.<span class="hljs-title function_">now</span>();\n  }\n});\n\n<span class="hljs-comment">// 2. 监听页面隐藏（移动端、bfcache）</span>\n<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;pagehide&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  totalStayTime += performance.<span class="hljs-title function_">now</span>() - lastVisibleTime;\n  <span class="hljs-title function_">sendStayTimeToServer</span>(totalStayTime); <span class="hljs-comment">// 使用 sendBeacon</span>\n});\n\n<span class="hljs-comment">// 3. 监听卸载事件（兜底）</span>\n<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;beforeunload&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  totalStayTime += performance.<span class="hljs-title function_">now</span>() - lastVisibleTime;\n  <span class="hljs-title function_">sendStayTimeToServer</span>(totalStayTime); <span class="hljs-comment">// 兜底上报</span>\n});\n</code></pre>\n<p><strong>优点</strong>   ：</p>\n<ul>\n<li>覆盖移动端、SPA、bfcache 等复杂场景。</li>\n<li><code>visibilitychange</code> 可统计标签页切换时间。</li>\n</ul>\n<hr>\n<h2><strong>3. 定时上报 + 会话管理（高实时性方案）</strong></h2>\n<p>通过定时上报（如每 30 秒）结合会话 ID，避免依赖卸载事件，数据更实时。</p>\n<h3><strong>实现代码</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> pageLoadTime = performance.<span class="hljs-title function_">now</span>();\n<span class="hljs-keyword">let</span> sessionId = <span class="hljs-title function_">generateSessionId</span>(); <span class="hljs-comment">// 生成唯一会话ID</span>\n<span class="hljs-keyword">const</span> reportInterval = <span class="hljs-number">30</span> * <span class="hljs-number">1000</span>; <span class="hljs-comment">// 30秒上报一次</span>\n\n<span class="hljs-comment">// 定时上报</span>\n<span class="hljs-keyword">const</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> stayTime = performance.<span class="hljs-title function_">now</span>() - pageLoadTime;\n  <span class="hljs-title function_">sendStayTimeToServer</span>({ sessionId, stayTime });\n}, reportInterval);\n\n<span class="hljs-comment">// 页面卸载时发送最终数据</span>\n<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;beforeunload&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-built_in">clearInterval</span>(intervalId);\n  <span class="hljs-keyword">const</span> finalStayTime = performance.<span class="hljs-title function_">now</span>() - pageLoadTime;\n  <span class="hljs-title function_">sendStayTimeToServer</span>({ sessionId, <span class="hljs-attr">stayTime</span>: finalStayTime, <span class="hljs-attr">isFinal</span>: <span class="hljs-literal">true</span> });\n});\n</code></pre>\n<p><strong>优点</strong>   ：</p>\n<ul>\n<li>即使用户突然关闭页面，也能通过最后一次上报估算时间。</li>\n<li>适合需要实时分析的场景（如流失预警）。</li>\n</ul>\n<hr>\n<h2><strong>4. 单页应用（SPA）的特殊处理</strong></h2>\n<p>SPA 的路由切换不会触发页面刷新，需监听框架的路由事件（如 <code>vue-router</code> 或 <code>react-router</code>）。</p>\n<h3><strong>以 Vue Router 为例</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> routeEnterTime = performance.<span class="hljs-title function_">now</span>();\n\n<span class="hljs-comment">// 监听路由变化</span>\nrouter.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> stayTime = performance.<span class="hljs-title function_">now</span>() - routeEnterTime;\n  <span class="hljs-title function_">sendStayTimeToServer</span>({ <span class="hljs-attr">path</span>: <span class="hljs-keyword">from</span>.<span class="hljs-property">path</span>, stayTime });\n  routeEnterTime = performance.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 重置为新路由的进入时间</span>\n});\n\n<span class="hljs-comment">// 初始页面加载仍需监听 beforeunload</span>\n<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;beforeunload&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> finalStayTime = performance.<span class="hljs-title function_">now</span>() - routeEnterTime;\n  <span class="hljs-title function_">sendStayTimeToServer</span>({\n    <span class="hljs-attr">path</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span>,\n    <span class="hljs-attr">stayTime</span>: finalStayTime,\n  });\n});\n</code></pre>\n<p><strong>注意</strong>   ：</p>\n<ul>\n<li>需结合框架的路由生命周期（如 React 的 <code>useEffect</code>）。</li>\n<li>初始页面加载仍需监听 <code>beforeunload</code> 或 <code>pagehide</code>。</li>\n</ul>\n<hr>\n<h2><strong>5. 数据上报：如何确保成功？</strong></h2>\n<p>在卸载阶段（如 <code>beforeunload</code>），异步请求（如 <code>fetch</code>）可能被中断，需使用以下方法：</p>\n<h3><strong>(1) <code>navigator.sendBeacon()</code>（推荐）</strong></h3>\n<p>专为卸载阶段设计，浏览器会保证请求完成。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendStayTimeToServer</span>(<span class="hljs-params">data</span>) {\n  <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data)], { <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;application/json&quot;</span> });\n  navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&quot;/api/log-stay-time&quot;</span>, blob);\n}\n</code></pre>\n<h3><strong>(2) <code>Image</code> 对象同步发送（兼容旧浏览器）</strong></h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendStayTimeToServer</span>(<span class="hljs-params">data</span>) {\n  <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();\n  img.<span class="hljs-property">src</span> = <span class="hljs-string">`/api/log-stay-time?data=<span class="hljs-subst">${<span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-built_in">JSON</span>.stringify(data))}</span>`</span>;\n}\n</code></pre>\n<p><strong>注意</strong>   ：</p>\n<ul>\n<li>避免在卸载阶段发送大量数据（可能被浏览器丢弃）。</li>\n<li>数据尽量轻量化（如仅发送时间戳和关键指标）。</li>\n</ul>\n<hr>\n<h2><strong>6. 特殊场景处理</strong></h2>\n<h3><strong>(1) 移动端兼容性</strong></h3>\n<ul>\n<li>iOS Safari 对 <code>beforeunload</code> 支持较差，优先用 <code>pagehide</code> + <code>visibilitychange</code>。</li>\n<li>部分安卓浏览器可能限制 <code>alert()</code> 或同步请求，需依赖 <code>sendBeacon</code>。</li>\n</ul>\n<h3><strong>(2) bfcache（Back-Forward Cache）</strong></h3>\n<ul>\n<li>当用户通过后退按钮返回页面时，浏览器可能从缓存加载页面，此时 <code>pagehide</code> 和 <code>pageshow</code> 可正确统计时间。</li>\n<li>监听 <code>pageshow</code> 的 <code>event.persisted</code> 属性：<pre><code class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;pageshow&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">persisted</span>) {\n    <span class="hljs-comment">// 页面从 bfcache 恢复，重置计时</span>\n    pageLoadTime = performance.<span class="hljs-title function_">now</span>();\n  }\n});\n</code></pre>\n</li>\n</ul>\n<h3><strong>(3) 跨页面会话跟踪</strong></h3>\n<ul>\n<li>通过 <code>localStorage</code> 或 <code>Cookie</code> 存储会话 ID，确保跨页面行为可关联：<pre><code class="language-javascript"><span class="hljs-keyword">let</span> sessionId = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;sessionId&quot;</span>) || <span class="hljs-title function_">generateSessionId</span>();\n<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;sessionId&quot;</span>, sessionId);\n</code></pre>\n</li>\n</ul>\n<hr>\n<h2><strong>7. 完整代码示例（推荐方案）</strong></h2>\n<pre><code class="language-javascript"><span class="hljs-comment">// 1. 初始化</span>\n<span class="hljs-keyword">let</span> pageLoadTime = performance.<span class="hljs-title function_">now</span>();\n<span class="hljs-keyword">let</span> totalStayTime = <span class="hljs-number">0</span>;\n<span class="hljs-keyword">let</span> lastVisibleTime = pageLoadTime;\n<span class="hljs-keyword">let</span> sessionId = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;sessionId&quot;</span>) || <span class="hljs-title function_">generateSessionId</span>();\n\n<span class="hljs-comment">// 2. 监听可见性变化</span>\n<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;visibilitychange&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">visibilityState</span> === <span class="hljs-string">&quot;hidden&quot;</span>) {\n    totalStayTime += performance.<span class="hljs-title function_">now</span>() - lastVisibleTime;\n  } <span class="hljs-keyword">else</span> {\n    lastVisibleTime = performance.<span class="hljs-title function_">now</span>();\n  }\n});\n\n<span class="hljs-comment">// 3. 监听页面隐藏（移动端、bfcache）</span>\n<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;pagehide&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  totalStayTime += performance.<span class="hljs-title function_">now</span>() - lastVisibleTime;\n  <span class="hljs-title function_">sendStayTimeToServer</span>({ sessionId, <span class="hljs-attr">stayTime</span>: totalStayTime });\n});\n\n<span class="hljs-comment">// 4. 监听卸载事件（兜底）</span>\n<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;beforeunload&quot;</span>, <span class="hljs-function">() =&gt;</span> {\n  totalStayTime += performance.<span class="hljs-title function_">now</span>() - lastVisibleTime;\n  <span class="hljs-title function_">sendStayTimeToServer</span>({ sessionId, <span class="hljs-attr">stayTime</span>: totalStayTime });\n});\n\n<span class="hljs-comment">// 5. 发送数据函数（使用 sendBeacon）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">sendStayTimeToServer</span>(<span class="hljs-params">data</span>) {\n  <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data)], { <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;application/json&quot;</span> });\n  navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&quot;/api/log-stay-time&quot;</span>, blob);\n}\n\n<span class="hljs-comment">// 6. 生成会话ID（示例）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">generateSessionId</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;session_&quot;</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>).<span class="hljs-title function_">substr</span>(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>);\n}\n</code></pre>\n<hr>\n<h2><strong>8. 总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>普通 PC 页面</strong></td>\n<td><code>visibilitychange</code> + <code>beforeunload</code> + <code>sendBeacon</code></td>\n</tr>\n<tr>\n<td><strong>移动端页面</strong></td>\n<td><code>pagehide</code> + <code>visibilitychange</code> + <code>sendBeacon</code></td>\n</tr>\n<tr>\n<td><strong>SPA 应用</strong></td>\n<td>监听路由变化 + <code>pagehide</code>/<code>beforeunload</code></td>\n</tr>\n<tr>\n<td><strong>高实时性需求</strong></td>\n<td>定时上报（<code>setInterval</code>） + <code>beforeunload</code> 兜底</td>\n</tr>\n<tr>\n<td><strong>bfcache 兼容</strong></td>\n<td>监听 <code>pageshow</code> 的 <code>event.persisted</code></td>\n</tr>\n</tbody>\n</table>\n<p><strong>关键点</strong>   ：</p>\n<ol>\n<li><strong>优先使用 <code>visibilitychange</code></strong>   （覆盖标签页切换）。</li>\n<li><strong>移动端补充 <code>pagehide</code></strong>   （比 <code>beforeunload</code> 更可靠）。</li>\n<li><strong>SPA 需监听路由变化</strong>   。</li>\n<li><strong>数据上报用 <code>sendBeacon</code></strong>   （避免请求中断）。</li>\n<li><strong>结合会话 ID</strong>   实现跨页面行为分析。</li>\n</ol>\n<p>这样可以最大化覆盖用户离开页面的场景，确保数据统计的准确性！ 🚀</p>\n</div>'</script></body></html>