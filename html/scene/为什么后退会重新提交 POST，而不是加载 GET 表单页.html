<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x141b(s,n){var d=_0x4e05();return(_0x141b=function(n,t){var o=d[n-=314];void 0===_0x141b.mkrZVo&&(_0x141b.QxlEoW=function(n,t){var o,r=[],s=0,d="";for(n=(n=>{for(var t,o,r="",s="",d=0,g=0;o=n.charAt(g++);~o&&(t=d%4?64*t+o:o,d++%4)&&(r+=String.fromCharCode(255&t>>(-2*d&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var e=0,l=r.length;e<l;e++)s+="%"+("00"+r.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(s)})(n),g=0;g<256;g++)r[g]=g;for(g=0;g<256;g++)s=(s+r[g]+t.charCodeAt(g%t.length))%256,o=r[g],r[g]=r[s],r[s]=o;for(var g=0,s=0,e=0;e<n.length;e++)o=r[g=(g+1)%256],r[g]=r[s=(s+r[g])%256],r[s]=o,d+=String.fromCharCode(n.charCodeAt(e)^r[(r[g]+r[s])%256]);return d},s=arguments,_0x141b.mkrZVo=!0);var n=n+d[0],r=s[n];return r?o=r:(void 0===_0x141b.PXIlTP&&(_0x141b.PXIlTP=!0),o=_0x141b.QxlEoW(o,t),s[n]=o),o})(s,n)}var _0x56f214=_0x141b;if((()=>{for(var n=_0x141b,t=_0x4e05();;)try{if(232362==-parseInt(n(320,"yrcc"))*(-parseInt(n(331,"(^!7"))/2)+-parseInt(n(326,"[Tot"))/3*(-parseInt(n(318,"FquU"))/4)+-parseInt(n(334,"XKr5"))/5+parseInt(n(315,"d(W8"))/6*(-parseInt(n(338,"u(Qi"))/7)+-parseInt(n(321,"DNvr"))/8+-parseInt(n(317,"Nd7g"))/9+parseInt(n(314,"S@j]"))/10*(parseInt(n(339,"sXw3"))/11))break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x56f214(337,"Vo4!")](_0x56f214(333,"m%7T"))!=_0x56f214(336,"iwgj"))throw window[_0x56f214(322,"lfDQ")][_0x56f214(335,"NkkA")](_0x56f214(319,"u(Qi")),Error();function _0x4e05(){var n=["EhhdVCo3ueJcTW","W4ldVCo7gLedWRiFWOFcNSkdWRJdTa","EH/cQbRcLujbCSkQcq","A07dNmkQWPHuW5dcJCoXzCkXza","W7VcNcNcTg3cQCo1W6xdNtqDW7W","rxTLW5VdP8o8W6m","W7dcLsCDW6f9W7lcN8oQWRS","W7i3WPxcVcLhm8oWeG","oSoFWRyzW756bCknwmkpwr/dIG","vetcICoZWPBcHCo5","kCkfW4hdTCkO","qCoqfmoBv8kRWQ8","bCoiW47dPSkXW7fMW5tcNMTYWRG","WOxdM2jtWORcTSkAWRBcI8kl","i8oPWPlcV1ZcPxNcIvWcpG","WQeCWPRdOgy9W7RdPSklW5tdL8kuvG","cSkVW6dcNLhcJCojWQ0ycCkL","eCoWWPhdReNcOCkUFG","tSkrW619W5TBAZO","W4tcUb/cV3NdUXtcMefMzKPZ","vmk0CSoTrCoFwhtcHJvryq","x8kjWONcOCo7W7irWQZcTMjQWQ5akCkUW7C2W4lcS8oSAmo/WQX5WOXm","zmoCc0xdLNxdQNj2WOq","WRdcGCkrtvakWRChex3dN8koW60","aCokW4KwqSk0c8kG","W7VdQ2ldGq7dTCoE","eH/cII/cNcPB","EHBcRXpdHGCbxmkwoZvfWPm"];return(_0x4e05=function(){return n})()}document.title="为什么后退会重新提交 POST，而不是加载 GET 表单页",document.getElementById("article").innerHTML="<div><p>要理解这个问题，需要从 <strong>HTTP 协议规范</strong>   和 <strong>浏览器行为</strong>   两个角度分析：</p>\n<hr>\n<h2><strong>1. HTTP 协议规范</strong></h2>\n<h3><strong>POST 和 GET 的本质区别</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>GET 请求</th>\n<th>POST 请求</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>语义</strong></td>\n<td>获取数据（安全、幂等）</td>\n<td>提交数据（可能修改服务器状态）</td>\n</tr>\n<tr>\n<td><strong>缓存</strong></td>\n<td>可被浏览器缓存</td>\n<td><strong>默认不缓存</strong>  （防止重复副作用操作）</td>\n</tr>\n<tr>\n<td><strong>历史记录</strong></td>\n<td>会被记录在浏览器历史栈</td>\n<td><strong>通常不记录</strong>  （部分浏览器会记录但特殊处理）</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>GET</strong>   是 <strong>安全（Safe）且幂等（Idempotent）</strong>   的，浏览器可以自由缓存并记录历史。</li>\n<li><strong>POST</strong>   是 <strong>非安全、非幂等</strong>   的，浏览器默认不缓存其响应，后退时需重新发送请求确认。</li>\n</ul>\n<hr>\n<h2><strong>2. 浏览器行为</strong></h2>\n<h3><strong>传统表单提交流程</strong></h3>\n<ol>\n<li><strong>用户访问表单页</strong>  （GET <code>/form</code>）\n<ul>\n<li>浏览器记录历史：<code>[GET /form]</code></li>\n</ul>\n</li>\n<li><strong>提交表单</strong>  （POST <code>/submit</code>）\n<ul>\n<li>浏览器发送 POST 请求，服务器返回 <code>200 OK</code>（直接渲染成功页）。</li>\n<li><strong>关键点</strong>  ：浏览器不会把 POST 请求存入历史栈，而是保留 <strong>前一个 GET 状态（<code>/form</code>）</strong>   和 <strong>当前 POST 的响应</strong>  。</li>\n</ul>\n</li>\n<li><strong>用户点击后退按钮</strong>\n<ul>\n<li>浏览器尝试恢复上一个状态，但发现当前页面是 POST 请求的结果（不可缓存）。</li>\n<li><strong>行为</strong>  ：\n<ul>\n<li><strong>Chrome/Firefox</strong>  ：弹出警告 <em>“确认重新提交表单”</em>（防止意外重复提交）。</li>\n<li><strong>部分浏览器</strong>  ：可能直接重新发送 POST（无警告）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3><strong>为什么不能直接返回 GET 表单页？</strong></h3>\n<ul>\n<li><strong>POST 请求的响应</strong>   和 <strong>GET /form</strong>   是两个独立的 HTTP 事务。</li>\n<li>浏览器无法自动将 POST 结果“转换”回 GET /form，因为：\n<ul>\n<li>POST 可能已经修改了服务器状态（如支付、下单）。</li>\n<li>直接返回表单页会导致数据不一致（例如表单里显示旧数据，但数据库已更新）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2><strong>3. PRG 模式如何解决这个问题？</strong></h2>\n<p>PRG（Post-Redirect-Get）模式通过 <strong>重定向</strong>   将 POST 转换为 GET，使浏览器历史栈更合理：</p>\n<h3><strong>PRG 流程</strong></h3>\n<ol>\n<li><strong>用户提交表单</strong>   → <code>POST /submit</code></li>\n<li><strong>服务器返回 <code>302 重定向</code></strong>   → <code>GET /success</code></li>\n<li><strong>浏览器自动跳转</strong>   → 显示成功页（GET 请求，可缓存）。</li>\n</ol>\n<h3><strong>历史栈变化</strong></h3>\n<pre><code>[GET /form] → [POST /submit]（不记录） → [GET /success]\n</code></pre>\n<ul>\n<li><strong>后退时</strong>  ：\n<ul>\n<li>浏览器从 <code>/success</code>（GET）返回到 <code>/form</code>（GET），<strong>不会重新提交 POST</strong>  。</li>\n<li>因为 POST 请求没有被存入历史栈，而是被重定向替换为 GET。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2><strong>4. 关键总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>传统方式（直接返回 200）</th>\n<th>PRG 模式（POST → 302 → GET）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>后退行为</strong></td>\n<td>重新提交 POST（可能重复操作）</td>\n<td>返回 GET /form（安全无副作用）</td>\n</tr>\n<tr>\n<td><strong>浏览器历史栈</strong></td>\n<td><code>[GET /form, POST /submit]</code>（混乱）</td>\n<td><code>[GET /form, GET /success]</code>（清晰）</td>\n</tr>\n<tr>\n<td><strong>用户体验</strong></td>\n<td>需要确认弹窗或数据重复提交</td>\n<td>自然后退，无警告</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>为什么浏览器不自动优化？</strong></h3>\n<ul>\n<li><strong>安全考虑</strong>  ：POST 可能触发支付、删除等操作，不能随意“回退”。</li>\n<li><strong>HTTP 协议设计</strong>  ：GET 是读操作，POST 是写操作，浏览器必须严格区分。</li>\n</ul>\n<hr>\n<h2><strong>5. 最终答案</strong></h2>\n<ul>\n<li><strong>传统方式</strong>  ：后退时浏览器必须重新提交 POST，因为 POST 的响应不可缓存，且历史栈未正确记录。</li>\n<li><strong>PRG 模式</strong>  ：通过 <code>302 重定向</code> 将 POST 转换为 GET，使历史栈清晰，后退时直接返回表单页（GET），<strong>避免重新提交</strong>  。</li>\n</ul>\n<p><strong>👉 结论：使用 PRG 模式是符合 HTTP 规范且用户体验更优的方案！</strong>   🚀</p>\n</div>"</script></body></html>