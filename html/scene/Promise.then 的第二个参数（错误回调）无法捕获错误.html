<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5db033=_0x1168;if((()=>{for(var s=_0x1168,n=_0x4fff();;)try{if(713939==-parseInt(s(367,"5FLZ"))*(-parseInt(s(376,"(dlU"))/2)+parseInt(s(366,"4Iqs"))/3+parseInt(s(382,"GwYq"))/4+-parseInt(s(386,"1h&K"))/5*(parseInt(s(371,"LkOQ"))/6)+-parseInt(s(363,"K&VE"))/7+parseInt(s(364,"4h$%"))/8+parseInt(s(385,"D]Wa"))/9*(-parseInt(s(369,"4Iqs"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5db033(370,"mj)I")](_0x5db033(381,"D]Wa"))!=_0x5db033(383,"gPol"))throw window[_0x5db033(379,"bW2Q")][_0x5db033(373,"nI22")](_0x5db033(377,"PozG")),Error();function _0x1168(c,s){var e=_0x4fff();return(_0x1168=function(s,n){var a=e[s-=363];void 0===_0x1168.wSbjYI&&(_0x1168.ajClES=function(s,n){var a,t=[],c=0,e="";for(s=(s=>{for(var n,a,t="",c="",e=0,o=0;a=s.charAt(o++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var l=0,r=t.length;l<r;l++)c+="%"+("00"+t.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(c)})(s),o=0;o<256;o++)t[o]=o;for(o=0;o<256;o++)c=(c+t[o]+n.charCodeAt(o%n.length))%256,a=t[o],t[o]=t[c],t[c]=a;for(var o=0,c=0,l=0;l<s.length;l++)a=t[o=(o+1)%256],t[o]=t[c=(c+t[o])%256],t[c]=a,e+=String.fromCharCode(s.charCodeAt(l)^t[(t[o]+t[c])%256]);return e},c=arguments,_0x1168.wSbjYI=!0);var s=s+e[0],t=c[s];return t?a=t:(void 0===_0x1168.PMLrKY&&(_0x1168.PMLrKY=!0),a=_0x1168.ajClES(a,n),c[s]=a),a})(c,s)}function _0x4fff(){var s=["WQ9IW7tcV8ooBbpcJmkr","FWa8rgOUsJhcRbOCasS3W6rfW68RW48DWQhcUvhdHCogEq","WOVdPqVcMCkXWQZcRCoEasq","W7G/b8ofW7tdQYHW","g2m+W5y6ysGgW4ddTG","W4RcK8kMhJLQqNddKq","bSkkW6jkF2JdImoYW5NcP2FdKM8","W63dICo9w8oh","dmkbWOLDEI7cKSksWPNdVmoyWPRcLW","WRNdGSo1th1WCfBdRSo4W7q","pCo0pCkLaqLpWQhdGwi","WOa+W6rYWQOzWQOgrwK","ec3dM0JcU8khW49bWPmTfG","B1VdL8kNECkKWR9EW5jwWQ1KW5q","WOu1W6DXW7LRW6KEvKPInCkC","jKvXasGLvxRcOsqHjqi","WRldLSkUWROghgBcVmowqZRdG2G","W5aKW73cTef7WRZcUmo5xq","bCkmW6ndC2NdImokW5hcM2RdJve","WRddNSkMWR9/AJlcKCojwW","thjiW7ZcNSo4za","u8ogWOHUrCkBh8o3WQhcGG","pCo5oCkToJ5mWRhdGxS","W57dIGL8eJKK","W6ZcMSk4WQxcQCoch2WIW6ddLZC3","gcuoW7tcV8ozrHxdJG"];return(_0x4fff=function(){return s})()}document.title="Promise.then 的第二个参数（错误回调）无法捕获错误",document.getElementById("article").innerHTML='<div><p>在 JavaScript 的 <code>Promise</code> 中，<code>then</code> 方法的第二个参数（<code>onRejected</code> 回调）可以捕获错误，但它的行为可能与 <code>catch</code> 不同，导致你以为它“无法捕捉”。以下是详细解析：</p>\n<hr>\n<p><strong>1. <code>then</code> 的第二个参数 vs <code>catch</code></strong><br>\n<strong>(1) 基本语法</strong></p>\n<pre><code class="language-javascript">promise\n  .<span class="hljs-title function_">then</span>(\n    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> { <span class="hljs-comment">/* 成功回调 */</span> },\n    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> { <span class="hljs-comment">/* 失败回调 */</span> }  <span class="hljs-comment">// 第二个参数</span>\n  )\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> { <span class="hljs-comment">/* catch 捕获错误 */</span> });\n</code></pre>\n<p><strong>(2) 关键区别</strong></p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>then</code> 的第二个参数</th>\n<th><code>catch</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>捕获范围</td>\n<td>仅捕获当前 <code>then</code> 之前的 <code>reject</code></td>\n<td>捕获整个链中未处理的 <code>reject</code></td>\n</tr>\n<tr>\n<td>链式调用影响</td>\n<td>如果自身抛出错误，会被后续 <code>catch</code> 捕获</td>\n<td>捕获所有上游未处理的错误</td>\n</tr>\n<tr>\n<td>推荐使用场景</td>\n<td>针对特定步骤的错误处理</td>\n<td>全局错误处理</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p><strong>2. 为什么你觉得“无法捕捉”？</strong><br>\n<strong>场景 1：<code>then</code> 的第二个参数未触发</strong></p>\n<pre><code class="language-javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()\n  .<span class="hljs-title function_">then</span>(\n    <span class="hljs-function">() =&gt;</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;手动错误&quot;</span>); },\n    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then 捕获:&quot;</span>, error); } <span class="hljs-comment">// 不会执行！</span>\n  )\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;catch 捕获:&quot;</span>, error); });\n</code></pre>\n<p>输出：</p>\n<pre><code>catch 捕获: Error: 手动错误\n</code></pre>\n<p>原因：</p>\n<ul>\n<li><code>then</code> 的第一个回调（成功回调）抛出的错误，不会被同一个 <code>then</code> 的第二个参数捕获，而是会被后续的 <code>catch</code> 捕获。</li>\n</ul>\n<p><strong>场景 2：<code>then</code> 的第二个参数能捕获的情况</strong></p>\n<pre><code class="language-javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;初始错误&quot;</span>))\n  .<span class="hljs-title function_">then</span>(\n    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成功:&quot;</span>, value); },\n    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then 捕获:&quot;</span>, error); } <span class="hljs-comment">// 会执行！</span>\n  )\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;catch 捕获:&quot;</span>, error); });\n</code></pre>\n<p>输出：</p>\n<pre><code>then 捕获: Error: 初始错误\n</code></pre>\n<p>原因：</p>\n<ul>\n<li>这里的 <code>reject</code> 是由 <code>Promise.reject</code> 直接触发的，所以被 <code>then</code> 的第二个参数捕获。</li>\n</ul>\n<hr>\n<p><strong>3. 最佳实践</strong><br>\n<strong>(1) 统一使用 <code>catch</code>（推荐）</strong></p>\n<pre><code class="language-javascript">promise\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> { <span class="hljs-comment">/* 逻辑 */</span> })\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> { <span class="hljs-comment">/* 统一错误处理 */</span> });\n</code></pre>\n<ul>\n<li>\n<p>优点：捕获整个链中所有未处理的 <code>reject</code> 和 <code>throw</code>。</p>\n</li>\n<li>\n<p>缺点：无法区分错误来源（需通过 <code>error</code> 类型判断）。</p>\n</li>\n</ul>\n<p><strong>(2) 特定步骤使用 <code>then</code> 的第二个参数</strong></p>\n<pre><code class="language-javascript">promise\n  .<span class="hljs-title function_">then</span>(\n    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> { <span class="hljs-comment">/* 逻辑 */</span> },\n    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> { \n      <span class="hljs-keyword">if</span> (error.<span class="hljs-property">type</span> === <span class="hljs-string">&quot;特定错误&quot;</span>) {\n        <span class="hljs-comment">// 处理特定错误</span>\n      } <span class="hljs-keyword">else</span> {\n        <span class="hljs-keyword">throw</span> error; <span class="hljs-comment">// 传递给后续 catch</span>\n      }\n    }\n  )\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> { <span class="hljs-comment">/* 其他错误 */</span> });\n</code></pre>\n<ul>\n<li>适用场景：需要针对某些错误特殊处理，其余错误继续传递。</li>\n</ul>\n<hr>\n<p><strong>4. 总结</strong></p>\n<table>\n<thead>\n<tr>\n<th>情况</th>\n<th><code>then</code> 第二个参数是否捕获</th>\n<th><code>catch</code> 是否捕获</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Promise.reject()</code></td>\n<td>✅ 是</td>\n<td>❌ 否（已被捕获）</td>\n</tr>\n<tr>\n<td><code>then</code> 成功回调中 <code>throw</code></td>\n<td>❌ 否</td>\n<td>✅ 是</td>\n</tr>\n<tr>\n<td>上游未处理的 <code>reject</code></td>\n<td>✅ 是</td>\n<td>❌ 否（已被捕获）</td>\n</tr>\n</tbody>\n</table>\n<p>关键点：</p>\n<ol>\n<li><code>then</code> 的第二个参数 只能捕获之前的 <code>reject</code>，无法捕获自身成功回调中的 <code>throw</code>。</li>\n<li><code>catch</code> 是全局兜底，优先使用它简化错误处理。</li>\n<li>如果需要精细化处理，可结合 <code>then</code> 的第二个参数和 <code>catch</code>。</li>\n</ol>\n</div>'</script></body></html>