<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x52f7b6=_0x4225;function _0x4225(t,s){var p=_0x3833();return(_0x4225=function(s,a){var n=p[s-=133];void 0===_0x4225.yPRRIT&&(_0x4225.PZRBNb=function(s,a){var n,l=[],t=0,p="";for(s=(s=>{for(var a,n,l="",t="",p=0,c=0;n=s.charAt(c++);~n&&(a=p%4?64*a+n:n,p++%4)&&(l+=String.fromCharCode(255&a>>(-2*p&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var e=0,o=l.length;e<o;e++)t+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)t=(t+l[c]+a.charCodeAt(c%a.length))%256,n=l[c],l[c]=l[t],l[t]=n;for(var c=0,t=0,e=0;e<s.length;e++)n=l[c=(c+1)%256],l[c]=l[t=(t+l[c])%256],l[t]=n,p+=String.fromCharCode(s.charCodeAt(e)^l[(l[c]+l[t])%256]);return p},t=arguments,_0x4225.yPRRIT=!0);var s=s+p[0],l=t[s];return l?n=l:(void 0===_0x4225.FKaiyl&&(_0x4225.FKaiyl=!0),n=_0x4225.PZRBNb(n,a),t[s]=n),n})(t,s)}function _0x3833(){var s=["WPlcH8kfvCoKir5xW73dJ37cPSo0","W4VdHmoef8kGkWmRW6NdR0VcL8oUWPvYWONcGCkZzgRcMZDfotiZ","oetcLJbNWQhcPe8","CmkeW6/dT8oaofbSW5CKWR9FAq","cmkKW5eOWROhFCorW6eE","W6BdNmoSWQnEl8kTzYjcr8kcsa","cSkMWOzsWQ85FSow","pb3cO0b/EaXPWOuDW77cUSkP","p8kiWRKNsGiPp8o3dW","W6BdLCkBW6OfvmoCAWNdUfrG","oaNdRwxcI29iWOJdQW","W4TNje/dGSkzqa","W5/dVWPWW7/dUfTTW7zmkWq","DCkgWRJcHmkawXHU","D1pdIrZdMedcHGtcSq4","vgxdPH3dHuJcOYKkcmkoWQlcNW","WRdcUCo4BILhWRjg","WOldGSkkqb/dJuq","W7nvm8okWQFcGCky","WOFdQSoFk8k/BrFcPG","W53cSW9SW6RdMYW","W5/dUGX7W7JdVdv5W41rdZtcQa","uMxdOr3cQbxdMse1gq","vSoECSots8ksWQDX","FGhcGcPP","W6xdKSoQWQnDwmoJuILeCW","WOldO0mCWQ3cIa3dSCkaW7uAda","sMtdKspcQmkDAdi","C8oLWPRdSadcJh0mWPtdTSkLpq"];return(_0x3833=function(){return s})()}if((()=>{for(var s=_0x4225,a=_0x3833();;)try{if(335594==-parseInt(s(155,"#B01"))*(parseInt(s(153,"]6Op"))/2)+parseInt(s(141,"hF6h"))/3*(parseInt(s(137,"h[Ha"))/4)+parseInt(s(144,"xzwx"))/5*(-parseInt(s(134,"#kf*"))/6)+-parseInt(s(133,"q7bk"))/7+-parseInt(s(156,"4n8H"))/8+parseInt(s(143,"q7bk"))/9*(parseInt(s(142,"SEFl"))/10)+-parseInt(s(145,"!PTd"))/11*(-parseInt(s(161,"8PJ4"))/12))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x52f7b6(150,"4n8H")](_0x52f7b6(140,"fP$K"))!=_0x52f7b6(154,"8PJ4"))throw window[_0x52f7b6(149,"@lHG")][_0x52f7b6(147,"b!KD")](_0x52f7b6(160,"znKa")),Error();document.title="Vue3 的 Block Tree",document.getElementById("article").innerHTML='<div><p>Vue3 的 <strong>Block Tree</strong>   是一种将虚拟 DOM 树分层组织的优化结构，通过 <strong>区块（Block）</strong>   的概念减少 diff 过程中需要遍历的节点数量。下面详细解析其分割逻辑和实现机制：</p>\n<h3><strong>1. 区块（Block）的定义</strong></h3>\n<ul>\n<li><strong>区块</strong>  是一种特殊的虚拟节点（VNode），它会<strong>记录其内部所有动态子节点</strong>  （即带有 <code>Patch Flag</code> 的节点）。</li>\n<li><strong>静态节点</strong>  （无标记）会被排除在区块的动态子节点列表外，从而在 diff 时被跳过。</li>\n</ul>\n<h3><strong>2. 区块分割的触发条件</strong></h3>\n<p>Vue3 编译器会在以下场景创建区块：</p>\n<ol>\n<li><strong>组件根节点</strong>  ：每个组件的根节点默认是一个区块。</li>\n<li><strong>动态节点的父级节点</strong>  ：如果某个节点包含动态子节点，且这些子节点需要被统一管理，其父节点会被提升为区块。</li>\n<li><strong>特定指令或语法</strong>  ：如 <code>v-if</code>、<code>v-for</code>、<code>&lt;transition&gt;</code> 等，这些会创建独立的区块。</li>\n</ol>\n<h3><strong>3. 区块分割的具体规则</strong></h3>\n<h4><strong>规则 1：组件根节点自动成为区块</strong></h4>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- 根节点自动成为 Block --&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-comment">&lt;!-- 动态节点，属于根 Block --&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n<h4><strong>规则 2：v-if/v-else 分支创建独立区块</strong></h4>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;flag&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- 独立 Block --&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ dynamicText }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-comment">&lt;!-- 属于该 Block --&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span> <span class="hljs-comment">&lt;!-- 另一个独立 Block --&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{ anotherText }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-comment">&lt;!-- 属于该 Block --&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n<h4><strong>规则 3：v-for 创建带 KEYED_FRAGMENT 标记的区块</strong></h4>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span> <span class="hljs-comment">&lt;!-- 普通节点 --&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- 每个列表项属于一个 KEYED_FRAGMENT Block --&gt;</span>\n      {{ item.name }}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n<h4><strong>规则 4：动态组件创建独立区块</strong></h4>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;currentComponent&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 独立 Block --&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n<h3><strong>4. 编译后的区块结构示例</strong></h3>\n<p>假设有如下模板：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- 根 Block --&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>静态头部<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span> <span class="hljs-comment">&lt;!-- 静态节点，跳过 --&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-comment">&lt;!-- 动态节点，记录到根 Block 的 dynamicChildren --&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;showList&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- 独立 Block (CONDITIONAL) --&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>{{ item.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <span class="hljs-comment">&lt;!-- 动态列表，记录到 v-if Block --&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>静态底部<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span> <span class="hljs-comment">&lt;!-- 静态节点，跳过 --&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n<p>编译后的 Block Tree 结构：</p>\n<pre><code>Root Block (div)\n├─ header (静态节点，不记录)\n├─ main (普通节点)\n│  ├─ p (TEXT 标记，记录到 Root Block)\n│  └─ Conditional Block (ul, v-if)\n│     └─ Keyed Fragment (li 列表)\n└─ footer (静态节点，不记录)\n</code></pre>\n<h3><strong>5. 动态子节点的收集</strong></h3>\n<ul>\n<li><strong>dynamicChildren 数组</strong>  ：每个区块会维护一个 <code>dynamicChildren</code> 数组，存储其内部所有动态子节点。</li>\n<li><strong>深度优先遍历</strong>  ：编译时，Vue3 编译器会递归遍历虚拟 DOM 树，将动态节点添加到最近的区块的 <code>dynamicChildren</code> 中。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// 简化的区块结构</span>\n<span class="hljs-keyword">const</span> rootBlock = {\n  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;div&#x27;</span>,\n  <span class="hljs-attr">dynamicChildren</span>: [\n    { <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-attr">patchFlag</span>: <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span> },\n    {\n      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ul&#x27;</span>,\n      <span class="hljs-attr">patchFlag</span>: <span class="hljs-number">64</span> <span class="hljs-comment">/* CONDITIONAL */</span>,\n      <span class="hljs-attr">dynamicChildren</span>: [\n        <span class="hljs-comment">// 列表项节点...</span>\n      ]\n    }\n  ]\n}\n</code></pre>\n<h3><strong>6. 性能优化的核心</strong></h3>\n<ul>\n<li><strong>跳过静态节点</strong>  ：diff 过程中，只比较 <code>dynamicChildren</code> 数组中的节点，静态节点完全被忽略。</li>\n<li><strong>减少遍历层级</strong>  ：区块树将大型虚拟 DOM 树拆分为多个小区块，每个区块独立 diff，避免全量遍历。</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<p>Vue3 的 Block Tree 通过以下方式实现高效分割：</p>\n<ol>\n<li><strong>组件根节点和关键动态节点自动升级为区块</strong>  。</li>\n<li><strong>区块记录所有动态子节点</strong>  ，静态节点被排除在外。</li>\n<li><strong>区块层级化管理</strong>  ，形成树状结构，减少 diff 范围。</li>\n</ol>\n<p>这种优化是 Vue3 编译器的“黑盒”能力，开发者无需手动干预，编写常规模板即可享受性能提升。</p>\n</div>'</script></body></html>