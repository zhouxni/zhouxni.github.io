<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5379(e,s){var c=_0x177d();return(_0x5379=function(s,n){var a=c[s-=273];void 0===_0x5379.rrsIVD&&(_0x5379.PtGtoc=function(s,n){var a,l=[],e=0,c="";for(s=(s=>{for(var n,a,l="",e="",c=0,t=0;a=s.charAt(t++);~a&&(n=c%4?64*n+a:a,c++%4)&&(l+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,o=l.length;r<o;r++)e+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(e)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)e=(e+l[t]+n.charCodeAt(t%n.length))%256,a=l[t],l[t]=l[e],l[e]=a;for(var t=0,e=0,r=0;r<s.length;r++)a=l[t=(t+1)%256],l[t]=l[e=(e+l[t])%256],l[e]=a,c+=String.fromCharCode(s.charCodeAt(r)^l[(l[t]+l[e])%256]);return c},e=arguments,_0x5379.rrsIVD=!0);var s=s+c[0],l=e[s];return l?a=l:(void 0===_0x5379.KkPWwT&&(_0x5379.KkPWwT=!0),a=_0x5379.PtGtoc(a,n),e[s]=a),a})(e,s)}var _0x2425ec=_0x5379;function _0x177d(){var s=["n2BcSmoDWRldOZveWR4","WPDNDCkLbCoTua","WOpcPCkNW47cNmkqgCoLcJH4FeK","aNVdKfeSF8oY","xZ1rWRtdVmkzwCongbrSzmkr","W6ziW6iODCobbmowh0pcIa","W6pdIsb6deH3tW","mCkizmkBW7VdHCk0aW","WPfFW4qqamkPnCkimYO5WQO","W4y6W53cJ0qpnqddNa","f8kifMddI8oaW5C+W6/cKqJdUG","W4rcWRfAz8keW7WTWRBdQGe","oCkLDSoFmbGTob7cG8klva","hNKAW7FcSq","WOZcLSoaovhcR3jiWOi","bdpdKLzZh3xcRNBcPSoMbG","W49eWRKmpSknW74WWOu","W5/cPxNdG8k1FCk3dhpdVtFdGhC","W7ldPNddSCk6lNJdPchdSmkQhmkq","icddIXXzWOvHxmkRhK5bdG","WOFdUSkRW5rBpCoC","AbddIMHNuqpcHmokmmozWPa7Amo6A3CFzmk8W6RcSCkDWOxcL3C","WRZcHmoLWONcOCoSy0b8bdBcUai","W7VdJCkxBrhdQGLdWRurWQ3dTmoi","W47cNSkVW4b7gmkZpW","yGOPbCkIbmky","W4FdJmoiswLPWOtcTSkR"];return(_0x177d=function(){return s})()}if((()=>{for(var s=_0x5379,n=_0x177d();;)try{if(920665==+parseInt(s(275,"*#W7"))*(parseInt(s(274,"$z1Q"))/2)+parseInt(s(289,"6QEx"))/3+parseInt(s(294,"@uQ9"))/4+parseInt(s(291,"kdP4"))/5+-parseInt(s(296,"QxCD"))/6*(-parseInt(s(282,"7ebM"))/7)+-parseInt(s(283,"EG8B"))/8*(-parseInt(s(298,"A]ey"))/9)+-parseInt(s(280,"9bki"))/10*(parseInt(s(299,"(8(T"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x2425ec(297,"E3XC")](_0x2425ec(286,"ilR9"))!=_0x2425ec(285,"ge9#"))throw window[_0x2425ec(279,"#S0V")][_0x2425ec(273,"[Kf4")](_0x2425ec(293,"FKeC")),Error();document.title="TypeScript中的Declare关键字有什么用",document.getElementById("article").innerHTML='<div><p>在 TypeScript 中，<code>declare</code> 关键字用于声明类型信息，而不提供具体的实现。它主要用于以下几种场景：</p>\n<hr>\n<h3><strong>1. 声明全局变量、函数或类</strong></h3>\n<ul>\n<li><strong>用途</strong>  ：当需要为全局变量、函数或类提供类型信息时，可以使用 <code>declare</code> 关键字。</li>\n<li><strong>示例</strong>  ：</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-comment">// 声明一个全局变量</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">globalVar</span>: <span class="hljs-built_in">number</span>;\n\n<span class="hljs-comment">// 声明一个全局函数</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">globalFunction</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span>;\n\n<span class="hljs-comment">// 声明一个全局类</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalClass</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>);\n  <span class="hljs-title function_">greet</span>(): <span class="hljs-built_in">void</span>;\n}\n</code></pre>\n<ul>\n<li><strong>解释</strong>  ：\n<ul>\n<li>这些声明告诉 TypeScript 编译器，这些变量、函数或类在全局作用域中存在，并且具有指定的类型。</li>\n<li>实际的实现可能由其他文件或运行时环境提供（如浏览器中的 <code>window</code> 对象）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>2. 声明模块</strong></h3>\n<ul>\n<li><strong>用途</strong>  ：使用 <code>declare module</code> 为模块提供类型声明，特别是为第三方库或自定义模块。</li>\n<li><strong>示例</strong>  ：</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-comment">// 声明一个模块，并导出接口</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;my-module&quot;</span> {\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> {\n    <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;\n    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;\n  }\n}\n</code></pre>\n<ul>\n<li><strong>解释</strong>  ：\n<ul>\n<li>这告诉 TypeScript 编译器，存在一个名为 <code>&quot;my-module&quot;</code> 的模块，并且它导出了一个 <code>MyInterface</code> 接口。</li>\n<li>可以在其他模块中通过 <code>import { MyInterface } from &quot;my-module&quot;;</code> 导入并使用。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>3. 声明命名空间</strong></h3>\n<ul>\n<li><strong>用途</strong>  ：使用 <code>declare namespace</code> 为命名空间提供类型声明，特别是在处理全局对象时。</li>\n<li><strong>示例</strong>  ：</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-comment">// 声明一个命名空间</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title class_">MyNamespace</span> {\n  <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span>;\n  <span class="hljs-keyword">const</span> <span class="hljs-attr">version</span>: <span class="hljs-built_in">string</span>;\n}\n</code></pre>\n<ul>\n<li><strong>解释</strong>  ：\n<ul>\n<li>这告诉 TypeScript 编译器，存在一个名为 <code>MyNamespace</code> 的命名空间，并且它包含了一个 <code>greet</code> 函数和一个 <code>version</code> 常量。</li>\n<li>可以在代码中使用 <code>MyNamespace.greet(&quot;Alice&quot;);</code> 或 <code>MyNamespace.version</code>。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>4. 声明合并</strong></h3>\n<ul>\n<li><strong>用途</strong>  ：<code>declare</code> 关键字可以用于声明合并，将多个声明合并为一个类型。</li>\n<li><strong>示例</strong>  ：</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-comment">// 声明一个接口</span>\n<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Box</span> {\n  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;\n  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-comment">// 声明合并，添加新的成员</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;some-module&quot;</span> {\n  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Box</span> {\n    <span class="hljs-attr">depth</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 添加新的成员</span>\n  }\n}\n</code></pre>\n<ul>\n<li><strong>解释</strong>  ：\n<ul>\n<li>通过声明合并，可以在不同的声明块中扩展接口、命名空间或类。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>5. 声明类型别名、枚举等</strong></h3>\n<ul>\n<li><strong>用途</strong>  ：虽然不常用，但 <code>declare</code> 也可以用于声明类型别名、枚举等，以提供类型信息而不提供实现。</li>\n<li><strong>示例</strong>  ：</li>\n</ul>\n<pre><code class="language-typescript"><span class="hljs-comment">// 声明一个类型别名</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Str</span> = <span class="hljs-built_in">string</span>;\n\n<span class="hljs-comment">// 声明一个枚举（通常不需要 declare，因为枚举有实现）</span>\n<span class="hljs-keyword">declare</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Colors</span> {\n  <span class="hljs-title class_">Red</span>,\n  <span class="hljs-title class_">Green</span>,\n  <span class="hljs-title class_">Blue</span>\n}\n</code></pre>\n<ul>\n<li><strong>解释</strong>  ：\n<ul>\n<li>对于类型别名，<code>declare</code> 的作用主要是强调这是一个类型声明，而不是变量声明。</li>\n<li>对于枚举，通常不需要 <code>declare</code>，因为枚举在 TypeScript 中既有类型也有实现。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong><code>declare</code> 的作用</strong>  ：用于声明类型信息，而不提供具体的实现。</li>\n<li><strong>主要场景</strong>  ：\n<ul>\n<li>声明全局变量、函数、类。</li>\n<li>声明模块，为模块提供类型信息。</li>\n<li>声明命名空间，组织全局类型。</li>\n<li>声明合并，扩展接口、命名空间或类。</li>\n</ul>\n</li>\n<li><strong>注意事项</strong>  ：\n<ul>\n<li><code>declare</code> 关键字仅提供类型信息，不会生成任何 JavaScript 代码。</li>\n<li>实际的实现需要在其他地方提供，或者由运行时环境（如浏览器、Node.js）提供。</li>\n</ul>\n</li>\n</ul>\n<p>通过合理使用 <code>declare</code> 关键字，可以更好地与现有的 JavaScript 代码或第三方库集成，同时保持 TypeScript 的类型安全优势。</p>\n</div>'</script></body></html>