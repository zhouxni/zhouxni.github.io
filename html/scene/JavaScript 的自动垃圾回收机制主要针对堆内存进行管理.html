<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2bfa(){var s=["WP4PESoBWQ7cHG3cTSkXW47dJ8oMWQm","CCoLW4VdVLGwWRakwa4","s1ldMCkbW58DqSkiWPDHk8oN","W7X/nW/dPYm2W55vnYZdNu4","W4v2W4DGoCkAW6BdNg5aWPuRWQm","WRLTW5VdHbJcTmkyWOlcNmoXW5xdVq","m8kNWQhdO8oVW4jtA8oS","zd7dL3bYW6RcM3G","zCkGgSo9ug0RWQtdRsaViSkp","WOj7Dr/dJKfm","thHXv8k5AtlcOSkLWPHdFW","m8kDxG8b","tWGjbgCYW4Chcx3dK8kaWRO","uWVcLmoNW6q7W4m","W7X9nGZdOI10W5DdfaFdQG","afRdKCkEW4azW7VdICoMtq","WR9HWQ4AW4VdLSoRWPyqoG","WO/cPdOtWOxdPcpdSq","WRhcVWWsW7ZcPvxdGG","WPmAnLD/wLW","rH3cHmo0fmolB8oCW4ZdGNNcRGG","W4tdNfhdIexdI3HYnSop","WPOQEmoEWQdcHq7cPCkGW4ddNSomWQi","zCo3Amk9daP/","W47cVx3dJaNcSuhdTWhcHsfuu3pdTXldLd/dRX/cN8oJWOnqpCkZ","qSo6W7G8vfP2xCkAW78Bn8kl","W47cLXFcV2JdMNm","bG/cQ8oDW70pW4O"];return(_0x2bfa=function(){return s})()}function _0x3993(l,s){var o=_0x2bfa();return(_0x3993=function(s,n){var a=o[s-=495];void 0===_0x3993.zjYnpD&&(_0x3993.aYTdGx=function(s,n){var a,t=[],l=0,o="";for(s=(s=>{for(var n,a,t="",l="",o=0,r=0;a=s.charAt(r++);~a&&(n=o%4?64*n+a:a,o++%4)&&(t+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,p=t.length;e<p;e++)l+="%"+("00"+t.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(l)})(s),r=0;r<256;r++)t[r]=r;for(r=0;r<256;r++)l=(l+t[r]+n.charCodeAt(r%n.length))%256,a=t[r],t[r]=t[l],t[l]=a;for(var r=0,l=0,e=0;e<s.length;e++)a=t[r=(r+1)%256],t[r]=t[l=(l+t[r])%256],t[l]=a,o+=String.fromCharCode(s.charCodeAt(e)^t[(t[r]+t[l])%256]);return o},l=arguments,_0x3993.zjYnpD=!0);var s=s+o[0],t=l[s];return t?a=t:(void 0===_0x3993.XhofJu&&(_0x3993.XhofJu=!0),a=_0x3993.aYTdGx(a,n),l[s]=a),a})(l,s)}var _0x2a645f=_0x3993;if((()=>{for(var s=_0x3993,n=_0x2bfa();;)try{if(832269==+parseInt(s(506,"&IRB"))*(parseInt(s(500,"NW7f"))/2)+-parseInt(s(521,"$wJv"))/3+parseInt(s(513,"LP7O"))/4+parseInt(s(519,"6KJ&"))/5*(-parseInt(s(503,"^cCq"))/6)+parseInt(s(498,")&dD"))/7+parseInt(s(499,"Y(2X"))/8*(parseInt(s(504,"x7v*"))/9)+-parseInt(s(516,"NW7f"))/10*(-parseInt(s(517,"VX2U"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x2a645f(514,"NW7f")](_0x2a645f(507,"@On0"))!=_0x2a645f(512,"FTNP"))throw window[_0x2a645f(518,"D!TQ")][_0x2a645f(510,"([Rn")](_0x2a645f(497,"6AKe")),Error();document.title="JavaScript 的自动垃圾回收机制主要针对堆内存进行管理",document.getElementById("article").innerHTML='<div><p>是的！JavaScript 的 <strong>自动垃圾回收（Garbage Collection, GC）机制</strong>   主要针对 <strong>堆内存（Heap Memory）</strong>   进行管理，而 <strong>栈内存（Stack Memory）</strong>   则由系统自动分配和释放（如函数调用栈的压栈和出栈）。下面我会从 <strong>回收目标、回收算法、内存泄漏</strong>   等方面详细讲解，并给出具体示例。</p>\n<hr>\n<h2>一、为什么主要针对堆内存？</h2>\n<h3>✅ <strong>栈内存 vs 堆内存 的回收方式</strong></h3>\n<table>\n<thead>\n<tr>\n<th>内存区域</th>\n<th>存储内容</th>\n<th>回收方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>栈内存</strong></td>\n<td>基本类型值、函数调用栈帧</td>\n<td><strong>自动即时回收</strong>   （函数执行完立即释放）</td>\n</tr>\n<tr>\n<td><strong>堆内存</strong></td>\n<td>对象、数组等引用类型</td>\n<td><strong>垃圾回收器（GC）定期扫描</strong></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>栈内存</strong>   ：函数执行时创建，执行完毕立即释放，<strong>严格遵循 LIFO（后进先出）规则</strong>   ，无需垃圾回收。</li>\n<li><strong>堆内存</strong>   ：对象生命周期不确定，可能被多个变量引用，<strong>必须通过 GC 机制回收</strong>   。</li>\n</ul>\n<hr>\n<h2>二、JavaScript 的垃圾回收算法</h2>\n<h3>1. <strong>标记-清除（Mark-and-Sweep）</strong>   （主流算法）</h3>\n<p><strong>步骤</strong>   ：</p>\n<ol>\n<li><strong>标记</strong>   ：从根对象（如 <code>window</code>、全局变量）出发，递归标记所有可达对象。</li>\n<li><strong>清除</strong>   ：遍历堆内存，删除未被标记的对象（不可达对象）。</li>\n</ol>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> }; <span class="hljs-comment">// 对象在堆中，obj 变量在栈中存引用</span>\nobj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 解除引用，堆中的 { name: &#x27;Alice&#x27; } 变成不可达，下次 GC 时被回收</span>\n</code></pre>\n<h3>2. <strong>引用计数（Reference Counting）</strong>   （已淘汰）</h3>\n<p><strong>原理</strong>   ：记录每个对象的引用次数，当次数归零时回收。<br>\n<strong>缺陷</strong>   ：无法处理循环引用！</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 循环引用导致内存泄漏（引用计数无法回收）</span>\n<span class="hljs-keyword">let</span> a = {};\n<span class="hljs-keyword">let</span> b = {};\na.<span class="hljs-property">child</span> = b; <span class="hljs-comment">// a 引用 b</span>\nb.<span class="hljs-property">parent</span> = a; <span class="hljs-comment">// b 引用 a</span>\na = b = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 即使手动解除，引用计数仍为 1</span>\n</code></pre>\n<h3>3. <strong>分代回收（Generational Collection）</strong>   （V8 引擎优化）</h3>\n<ul>\n<li><strong>新生代（Young Generation）</strong>   ：新创建的对象，用 <strong>Scavenge 算法</strong>   （复制存活对象到另一半空间）。</li>\n<li><strong>老生代（Old Generation）</strong>   ：存活时间长的对象，用 <strong>标记-清除/标记-整理</strong>   。</li>\n</ul>\n<hr>\n<h2>三、哪些情况会导致堆内存泄漏？</h2>\n<h3>🚨 <strong>常见内存泄漏场景</strong></h3>\n<h4>1. <strong>意外的全局变量</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">leak</span>(<span class="hljs-params"></span>) {\n  leakedVar = <span class="hljs-string">&quot;I am global!&quot;</span>; <span class="hljs-comment">// 未用 var/let/const，变成 window.leakedVar</span>\n}\n</code></pre>\n<h4>2. <strong>未清理的定时器/事件监听</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 定时器未清除</span>\n<span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {}, <span class="hljs-number">1000</span>);\n<span class="hljs-comment">// 忘记 clearInterval(timer);</span>\n\n<span class="hljs-comment">// 事件监听未移除</span>\nbutton.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, onClick);\n<span class="hljs-comment">// 忘记 removeEventListener</span>\n</code></pre>\n<h4>3. <strong>闭包持有外部变量</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosure</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> bigData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&quot;data&quot;</span>);\n  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bigData[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 闭包持有 bigData，即使函数执行完也不会释放</span>\n}\n<span class="hljs-keyword">const</span> closure = <span class="hljs-title function_">createClosure</span>(); <span class="hljs-comment">// bigData 一直被引用</span>\n</code></pre>\n<h4>4. <strong>DOM 引用未释放</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> elements = {\n  <span class="hljs-attr">button</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myButton&quot;</span>), <span class="hljs-comment">// 即使 DOM 被删除，elements.button 仍引用它</span>\n};\n<span class="hljs-comment">// 解决方案：手动置空 elements.button = null;</span>\n</code></pre>\n<hr>\n<h2>四、如何手动触发垃圾回收？（仅调试用）</h2>\n<h3>⚠️ 注意：生产环境慎用！</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 浏览器环境（非标准 API）</span>\n<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">global</span>.<span class="hljs-property">gc</span> === <span class="hljs-string">&quot;function&quot;</span>) {\n  <span class="hljs-variable language_">global</span>.<span class="hljs-title function_">gc</span>(); <span class="hljs-comment">// Chrome 通过 --expose-gc 启动时可用</span>\n}\n\n<span class="hljs-comment">// Node.js 环境</span>\n<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">global</span>.<span class="hljs-property">gc</span>) {\n  <span class="hljs-variable language_">global</span>.<span class="hljs-title function_">gc</span>();\n}\n</code></pre>\n<hr>\n<h2>五、最佳实践：避免内存泄漏</h2>\n<ol>\n<li><strong>及时解除引用</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">let</span> data = <span class="hljs-title function_">loadHugeData</span>();\n<span class="hljs-title function_">processData</span>(data);\ndata = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 使用后手动解除</span>\n</code></pre>\n</li>\n<li><strong>使用弱引用（WeakMap/WeakSet）</strong>   ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> weakMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();\nweakMap.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;temp&quot;</span>), <span class="hljs-string">&quot;info&quot;</span>); <span class="hljs-comment">// DOM 移除后自动回收</span>\n</code></pre>\n</li>\n<li><strong>避免滥用闭包</strong>   ：确保闭包内不持有大对象。</li>\n</ol>\n<hr>\n<h2>✅ 总结</h2>\n<table>\n<thead>\n<tr>\n<th>关键点</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>GC 目标</strong></td>\n<td>主要管理堆内存，栈内存由系统自动回收</td>\n</tr>\n<tr>\n<td><strong>回收算法</strong></td>\n<td>标记-清除（主流）、分代回收（V8 优化）</td>\n</tr>\n<tr>\n<td><strong>内存泄漏场景</strong></td>\n<td>全局变量、未清理的定时器/事件、闭包、DOM 引用</td>\n</tr>\n<tr>\n<td><strong>检测工具</strong></td>\n<td>Chrome DevTools Memory 面板、Node.js 的 <code>process.memoryUsage()</code></td>\n</tr>\n<tr>\n<td><strong>优化建议</strong></td>\n<td>及时解除引用、使用弱引用、避免循环引用</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>🔍 <strong>如果你想知道如何用 Chrome DevTools 分析内存泄漏，或想深入了解 V8 的垃圾回收细节，可以告诉我！</strong></p>\n</div>'</script></body></html>