<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0xca72(){var n=["W5BdTmk1obhdHJvS","emk6fmo+lLufWQJcV09M","ySo3WOFcLH4XW6jJWQ4EWO0","W68/WQXBWOK","iCkMW4BdIK4BW7C","fmk5fSo5lc5dWOhcMgXRWPeW","jLLXz8ojn8oCq23cRN7dVG4","WQpcHr52W6VcL8ojWQ3dL8o1FY41W4C","fCkKlmkHw8oHW6RdKI5XW5TY","WOxdI0VdH8koWOehvCkR","BIflWRpdM8kklHSEW6X7CX8","h8k7c8oerha8lJr0WR7cGSok","DComcmoKeSopW7RcJHHlrbhdKMe","ysddLvfxW5Dsl1BdPmobyfC","rhJcQ193W4PseG","ifD1zSodnCoytxdcLfJdPqC","xConW5fSiZ/cQ8kh","BKRdHKfFW7e8kc/cOsbWnq","jSkSWO/cVeRcIbxcHZddNeHbWP8","jmkVWO/cU0RcIepcMZxdJgbA","W5nciCoDWOidmSktW7pcNmoagSkoWPJcHSoxW6uEwItcJ2BcSHjPWOS","WOxcG8o5kmopWQNcHG"];return(_0xca72=function(){return n})()}var _0x28f2e8=_0x449a;function _0x449a(a,n){var o=_0xca72();return(_0x449a=function(n,t){var s=o[n-=174];void 0===_0x449a.VadszP&&(_0x449a.pWLWwa=function(n,t){var s,r=[],a=0,o="";for(n=(n=>{for(var t,s,r="",a="",o=0,l=0;s=n.charAt(l++);~s&&(t=o%4?64*t+s:s,o++%4)&&(r+=String.fromCharCode(255&t>>(-2*o&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var e=0,d=r.length;e<d;e++)a+="%"+("00"+r.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(a)})(n),l=0;l<256;l++)r[l]=l;for(l=0;l<256;l++)a=(a+r[l]+t.charCodeAt(l%t.length))%256,s=r[l],r[l]=r[a],r[a]=s;for(var l=0,a=0,e=0;e<n.length;e++)s=r[l=(l+1)%256],r[l]=r[a=(a+r[l])%256],r[a]=s,o+=String.fromCharCode(n.charCodeAt(e)^r[(r[l]+r[a])%256]);return o},a=arguments,_0x449a.VadszP=!0);var n=n+o[0],r=a[n];return r?s=r:(void 0===_0x449a.tFTUkE&&(_0x449a.tFTUkE=!0),s=_0x449a.pWLWwa(s,t),a[n]=s),s})(a,n)}if((()=>{for(var n=_0x449a,t=_0xca72();;)try{if(616171==+parseInt(n(186,"g%f3"))+-parseInt(n(179,"RBv&"))/2+-parseInt(n(180,")dHh"))/3+parseInt(n(192,"&NJF"))/4*(parseInt(n(184,"O9HW"))/5)+parseInt(n(194,"J[Zp"))/6+-parseInt(n(189,"$gO@"))/7+parseInt(n(174,"2w5g"))/8)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x28f2e8(183,")Pxu")](_0x28f2e8(193,"N46c"))!=_0x28f2e8(187,"g44w"))throw window[_0x28f2e8(176,"IxEA")][_0x28f2e8(188,"g%f3")](_0x28f2e8(182,"smOC")),Error();document.title="Vite 和 Webpack 的 HMR 对比",document.getElementById("article").innerHTML='<div><p>Vite 和 Webpack 的 HMR（热模块替换）在实现原理、更新速度、状态保持等方面存在显著差异，这些差异直接影响开发体验和效率。以下是详细对比：</p>\n<h3><strong>1. 核心原理差异</strong></h3>\n<h4><strong>Webpack HMR</strong></h4>\n<ul>\n<li><strong>基于打包后的模块系统</strong>  ：Webpack 构建时会为每个模块添加 HMR 相关代码</li>\n<li><strong>全量编译</strong>  ：修改文件后，Webpack 重新编译受影响的模块及其依赖链</li>\n<li><strong>代理层传递更新</strong>  ：通过 Webpack Dev Server 与浏览器建立 WebSocket 连接，推送更新补丁</li>\n</ul>\n<h4><strong>Vite HMR</strong></h4>\n<ul>\n<li><strong>基于原生 ESM</strong>  ：利用浏览器原生支持的 ES 模块系统</li>\n<li><strong>按需编译</strong>  ：仅编译修改的文件，不涉及整个依赖树</li>\n<li><strong>精准模块替换</strong>  ：通过 Vite 服务器直接推送修改的模块，浏览器动态加载</li>\n</ul>\n<h3><strong>2. 更新速度对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th>项目规模</th>\n<th>Webpack HMR 延迟</th>\n<th>Vite HMR 延迟</th>\n<th>速度提升</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>小型项目</td>\n<td>500-1000ms</td>\n<td>30-80ms</td>\n<td>~15倍</td>\n</tr>\n<tr>\n<td>中型项目</td>\n<td>1-3s</td>\n<td>50-150ms</td>\n<td>~20倍</td>\n</tr>\n<tr>\n<td>大型项目</td>\n<td>5-10s</td>\n<td>100-300ms</td>\n<td>~30倍</td>\n</tr>\n</tbody>\n</table>\n<p><strong>关键原因</strong>  ：</p>\n<ul>\n<li>Webpack 需要重新构建整个模块链，依赖越深延迟越高</li>\n<li>Vite 只需更新修改的文件，其他模块保持缓存状态</li>\n</ul>\n<h3><strong>3. 状态保持能力</strong></h3>\n<h4><strong>Webpack</strong></h4>\n<ul>\n<li><strong>函数组件状态丢失</strong>  ： useState/useReducer 状态在 HMR 后重置</li>\n<li><strong>类组件实例保留</strong>  ：但方法可能更新不及时导致不一致</li>\n<li><strong>手动干预</strong>  ：需通过 <code>module.hot.accept</code> 手动处理状态恢复</li>\n</ul>\n<h4><strong>Vite</strong></h4>\n<ul>\n<li><strong>自动状态保持</strong>  ：默认保留函数组件状态（基于代理机制）</li>\n<li><strong>自定义恢复逻辑</strong>  ：通过 <code>import.meta.hot</code> API 精细控制<pre><code class="language-javascript"><span class="hljs-comment">// 保留表单状态示例</span>\n<span class="hljs-keyword">if</span> (<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">hot</span>) {\n  <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">dispose</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-comment">// 保存当前状态</span>\n    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;formState&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(formData));\n  });\n  \n  <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">accept</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-comment">// 恢复状态</span>\n    <span class="hljs-keyword">const</span> savedState = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;formState&#x27;</span>));\n    <span class="hljs-title function_">initializeForm</span>(savedState);\n  });\n}\n</code></pre>\n</li>\n</ul>\n<h3><strong>4. 错误处理机制</strong></h3>\n<h4><strong>Webpack</strong></h4>\n<ul>\n<li><strong>错误中断 HMR</strong>  ：单个模块的语法错误可能导致整个 HMR 连接断开</li>\n<li><strong>需手动刷新</strong>  ：修复错误后需刷新页面重新建立连接</li>\n</ul>\n<h4><strong>Vite</strong></h4>\n<ul>\n<li><strong>错误隔离</strong>  ：单个模块错误不影响其他模块 HMR</li>\n<li><strong>Overlay 提示</strong>  ：通过浏览器 Overlay 显示错误信息，修复后自动恢复<br>\n<img src="https://picsum.photos/800/400?random=1&amp;blur=2" alt=""><br>\n<em>（Vite 错误 Overlay 示例）</em></li>\n</ul>\n<h3><strong>5. 配置复杂度</strong></h3>\n<h4><strong>Webpack</strong></h4>\n<ul>\n<li><strong>繁琐的 HMR 配置</strong>  ：需安装 <code>webpack-dev-server</code>、配置 <code>HotModuleReplacementPlugin</code></li>\n<li><strong>loader 兼容性问题</strong>  ：部分 loader（如 css-loader）需额外配置支持 HMR<pre><code class="language-javascript"><span class="hljs-comment">// webpack.config.js</span>\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">devServer</span>: {\n    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>\n  },\n  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">HotModuleReplacementPlugin</span>()]\n};\n</code></pre>\n</li>\n</ul>\n<h4><strong>Vite</strong></h4>\n<ul>\n<li><strong>零配置启用</strong>  ：默认支持 HMR，无需额外插件</li>\n<li><strong>自动处理依赖</strong>  ：对 CSS、TS、JSX 等文件类型自动支持 HMR</li>\n</ul>\n<h3><strong>6. 大型项目表现</strong></h3>\n<h4><strong>Webpack</strong></h4>\n<ul>\n<li><strong>内存占用高</strong>  ：大型项目 dev server 内存占用常超过 1.5GB</li>\n<li><strong>更新卡顿明显</strong>  ：随着项目规模增长，HMR 延迟呈指数级上升</li>\n</ul>\n<h4><strong>Vite</strong></h4>\n<ul>\n<li><strong>轻量级运行</strong>  ：内存占用通常低于 500MB</li>\n<li><strong>稳定的更新性能</strong>  ：项目规模对 HMR 速度影响较小</li>\n</ul>\n<h3><strong>7. 典型场景对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>Webpack 体验</th>\n<th>Vite 体验</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>调试组件样式</td>\n<td>修改 CSS → 等待编译 → 刷新页面</td>\n<td>修改 CSS → 样式立即更新</td>\n</tr>\n<tr>\n<td>调整表单逻辑</td>\n<td>输入内容丢失 → 重新填写测试</td>\n<td>保持输入状态 → 直接验证修改</td>\n</tr>\n<tr>\n<td>修复语法错误</td>\n<td>刷新页面 → 重新操作恢复测试环境</td>\n<td>修复后自动恢复 → 继续测试</td>\n</tr>\n<tr>\n<td>大型项目开发</td>\n<td>频繁等待编译，思维中断</td>\n<td>几乎无感知的即时反馈</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>Webpack</th>\n<th>Vite</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>更新速度</strong></td>\n<td>随项目增大显著变慢</td>\n<td>稳定在毫秒级</td>\n</tr>\n<tr>\n<td><strong>状态保持</strong></td>\n<td>需手动处理，容易丢失</td>\n<td>自动保持，支持精细控制</td>\n</tr>\n<tr>\n<td><strong>错误恢复</strong></td>\n<td>需刷新页面</td>\n<td>自动恢复，不中断开发流</td>\n</tr>\n<tr>\n<td><strong>配置难度</strong></td>\n<td>复杂，需额外插件</td>\n<td>零配置，开箱即用</td>\n</tr>\n<tr>\n<td><strong>内存占用</strong></td>\n<td>高（1-2GB）</td>\n<td>低（0.5GB 以下）</td>\n</tr>\n<tr>\n<td><strong>适合场景</strong></td>\n<td>复杂构建需求、 legacy 项目</td>\n<td>现代框架、追求极致开发体验</td>\n</tr>\n</tbody>\n</table>\n<p><strong>选择建议</strong>  ：</p>\n<ul>\n<li>若追求极致开发效率和简洁配置，优先选择 Vite</li>\n<li>若项目依赖复杂 Webpack 插件生态，暂时保留 Webpack</li>\n<li>大型项目迁移：可考虑使用 Vite 开发，Webpack 构建生产环境</li>\n</ul>\n</div>'</script></body></html>