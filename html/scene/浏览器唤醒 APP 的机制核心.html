<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x512534=_0xbbc1;function _0xbbc1(l,n){var e=_0xd4d3();return(_0xbbc1=function(n,t){var o=e[n-=374];void 0===_0xbbc1.ykdHzH&&(_0xbbc1.UDVOSV=function(n,t){var o,r=[],l=0,e="";for(n=(n=>{for(var t,o,r="",l="",e=0,i=0;o=n.charAt(i++);~o&&(t=e%4?64*t+o:o,e++%4)&&(r+=String.fromCharCode(255&t>>(-2*e&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var d=0,s=r.length;d<s;d++)l+="%"+("00"+r.charCodeAt(d).toString(16)).slice(-2);return decodeURIComponent(l)})(n),i=0;i<256;i++)r[i]=i;for(i=0;i<256;i++)l=(l+r[i]+t.charCodeAt(i%t.length))%256,o=r[i],r[i]=r[l],r[l]=o;for(var i=0,l=0,d=0;d<n.length;d++)o=r[i=(i+1)%256],r[i]=r[l=(l+r[i])%256],r[l]=o,e+=String.fromCharCode(n.charCodeAt(d)^r[(r[i]+r[l])%256]);return e},l=arguments,_0xbbc1.ykdHzH=!0);var n=n+e[0],r=l[n];return r?o=r:(void 0===_0xbbc1.wVsTii&&(_0xbbc1.wVsTii=!0),o=_0xbbc1.UDVOSV(o,t),l[n]=o),o})(l,n)}function _0xd4d3(){var n=["W4JcQvVcICkSqrSkxwC","A8opWR/dV8ksWQ7dT8ohWOBcRq","WORdPr/dISk4","h8kwemozevmIW5fLxLWpAa","WQLJW6JcHrv0WRJdGIuKmxzYW6pcNZxdTtdcQ2GcW4CUWQhcOmkD","WQ9vW67cOGi3ohVdPSom","WOeobKazWRLsW5PTWOWLrXddMG","mSouuKX9a0H+","WPy7WOGxW7xdJmoyW5/dRdq","WPVcPmodjcHynCkau8ojWP/cSGTU","W4P1sCkvy8oQoKtdGSkVWPhdNKu","u8o6WQxdTCoyWRpcRGeD","WPvwcHCEw8kr","qmo7W7ddNSoiumkCDSoUW4ikaSo0","W70iWRO0mXVdQw7dJ2ldUwRdSq","u3/cUJXVWOxcKCkmW70HWRC","WQfrW6DIy1f2wXyLWOq","W4NcOLZdICknDJ8Ytq","W49TW4pcVWnMotJcGmoIW6PKrG","W7r/eKpcGqrAWP7cR8o+E8kCWQO","umkHyZRdNSopW5vuWQeq","W7Tqy8oRWRhdQCkLomoFfga","WPb1iCkGW6hdQqykmdW","W7ymWPldRZpcKNW","oCkPW7RdLaf9WRddJSkYa8ov","FrZdQ8k4WQGOWROjW78"];return(_0xd4d3=function(){return n})()}if((()=>{for(var n=_0xbbc1,t=_0xd4d3();;)try{if(702680==-parseInt(n(396,"A&96"))+parseInt(n(386,"1PCy"))/2*(parseInt(n(391,"$0I["))/3)+-parseInt(n(374,"n3$G"))/4+-parseInt(n(379,"@mZ!"))/5+parseInt(n(384,"IGl1"))/6*(-parseInt(n(382,"voO9"))/7)+parseInt(n(385,"yWOI"))/8*(-parseInt(n(375,"XTkJ"))/9)+parseInt(n(392,"0Yie"))/10)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x512534(383,"RX3g")](_0x512534(397,"JrHI"))!=_0x512534(388,"1PCy"))throw window[_0x512534(393,"XsU9")][_0x512534(398,"d*1@")](_0x512534(390,"BMo8")),Error();document.title="浏览器唤醒 APP 的机制核心",document.getElementById("article").innerHTML='<div><p>好的，这是一个非常有趣且实用的技术点。浏览器唤醒APP（也称为 <strong>“深度链接”</strong>   或 <strong>“App Scheme”</strong>   ）的机制核心在于<strong>协议映射</strong>   。</p>\n<p>简单来说，就是让浏览器知道，当遇到一个特定“协议”开头的链接时，不应该由浏览器自己处理，而应该交给系统中注册了这个协议的应用（APP）来处理。</p>\n<p>其核心流程是：浏览器通过特定的自定义协议或通用链接，将打开页面的请求移交给操作系统，操作系统根据协议名称在已安装的应用中查找匹配项，并最终启动目标APP。整个过程可以概括为以下的流程图：</p>\n<pre><code class="language-mermaid">flowchart TD\n    A[用户点击特殊链接] --&gt; B{&quot;链接类型判断&quot;}\n\n    B -- Custom Scheme URL&lt;br&gt;如: myapp://detail?id=123 --&gt; C[浏览器尝试打开]\n    C --&gt; D{系统检查协议注册情况}\n    D -- 已安装对应APP --&gt; E[&quot;系统将请求(含参数)&lt;br&gt;传递给目标APP&quot;]\n    D -- 未安装对应APP --&gt; F[打开失败&lt;br&gt;显示错误页面]\n\n    B -- Universal Link&lt;br&gt;如: https://app.com/share/123 --&gt; G[浏览器访问普通网页]\n    G --&gt; H[服务器返回HTTP头&lt;br&gt;含关联APP信息]\n    H --&gt; I{系统检查关联APP}\n    I -- 已安装 --&gt; J[&quot;直接唤醒APP&lt;br&gt;(跳过浏览器)&quot;]\n    I -- 未安装 --&gt; K[继续正常加载网页]\n\n    E &amp; J --&gt; L[目标APP被唤醒]\n    M[APP开发者] -- 预先声明 --&gt; N[操作系统注册表]\n    subgraph N [系统维护的协议映射表]\n        N1[协议: myapp -&gt; APP A]\n        N2[域名: app.com -&gt; APP A]\n    end\n\n    D -.-&gt; N\n    I -.-&gt; N\n</code></pre>\n<p>下面我为你详细解释几种主流的实现方式和原理。</p>\n<hr>\n<h3>方法一：自定义 URL Scheme（最传统、最通用）</h3>\n<p>这是最基础也是最广泛支持的方式。</p>\n<h4>1. 原理</h4>\n<ul>\n<li><strong>APP端</strong>   ：开发者在开发APP时，会在其配置文件中声明一个<strong>自定义的协议</strong>   （例如：<code>myapp://</code>）。</li>\n<li><strong>系统端</strong>   ：当APP被安装到手机上时，操作系统（iOS / Android）会记录下这个协议和APP的对应关系，并注册这个协议。</li>\n<li><strong>浏览器端</strong>   ：当用户在浏览器中点击或访问一个以 <code>myapp://</code> 开头的链接时，浏览器会将这个请求<strong>交给操作系统</strong>   。操作系统一看这个协议，就知道该去唤醒哪个APP，并把它打开。</li>\n</ul>\n<h4>2. 实现方式</h4>\n<ul>\n<li><strong>链接示例</strong>   ：<code>myapp://product/detail?id=123</code></li>\n<li><strong>如何触发</strong>   ：\n<ul>\n<li><strong>用户点击</strong>   ：一个配置了 <code>href=&quot;myapp://product/detail?id=123&quot;</code> 的链接或按钮。</li>\n<li><strong>JS重定向</strong>   ：通过 <code>window.location.href = \'myapp://product/detail?id=123\';</code> 来实现自动跳转。</li>\n</ul>\n</li>\n</ul>\n<h4>3. 优点与缺点</h4>\n<ul>\n<li><strong>优点</strong>   ：实现简单，兼容性好（Android和iOS都支持）。</li>\n<li><strong>缺点</strong>   ：\n<ul>\n<li><strong>体验不流畅</strong>   ：如果用户没有安装APP，点击后会显示一个“无法打开页面”的错误，体验很差。</li>\n<li><strong>有安全风险</strong>   ：因为任何网页都可以尝试唤醒你的APP，所以APP在处理传入的链接和参数时，必须进行严格的校验和过滤，防止被恶意利用。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>方法二：通用链接（Universal Links - iOS）和应用链接（App Links - Android）</h3>\n<p>这是苹果和谷歌官方推出的更先进的方案，旨在解决自定义 Scheme 的体验问题。</p>\n<h4>1. 原理</h4>\n<p>它不再使用 <code>myapp://</code> 这种自定义协议，而是使用 <strong>标准的 HTTPS 链接</strong>   （例如：<code>https://www.yourdomain.com/product/123</code>）。</p>\n<ul>\n<li><strong>APP端</strong>   ：开发者需要在APP中声明它关联的互联网域名（例如：<code>www.yourdomain.com</code>）。</li>\n<li><strong>服务器端</strong>   ：需要在该域名的根目录下放置一个由苹果或谷歌提供的配置文件（<code>apple-app-site-association</code> 或 <code>assetlinks.json</code>），这个文件证明了“这个APP确实拥有这个域名”。</li>\n<li><strong>系统端</strong>   ：当APP安装时，系统会去下载并验证这个配置文件，从而建立 <code>https://www.yourdomain.com/...</code> 和 APP 的映射关系。</li>\n</ul>\n<h4>2. 工作流程</h4>\n<ol>\n<li>用户点击一个普通的网页链接，比如 <code>https://www.yourdomain.com/product/123</code>。</li>\n<li>操作系统会先拦截这个点击事件。</li>\n<li>它检查这个域名是否有关联的已安装的APP。</li>\n<li><strong>如果有</strong>   ，则<strong>直接唤醒APP</strong>   ，并将链接内容传递给APP。</li>\n<li><strong>如果没有</strong>   （或者验证失败），则** fallback **   到默认行为——在浏览器中打开这个网页。</li>\n</ol>\n<h4>3. 优点与缺点</h4>\n<ul>\n<li><strong>优点</strong>   ：\n<ul>\n<li><strong>无缝体验</strong>   ：不会出现“无法打开页面”的错误。同一个链接，装了APP就打开APP，没装APP就打开网页，对用户无感知。</li>\n<li><strong>安全</strong>   ：需要通过域名所有权认证，只有你自己的网站和APP才能建立关联。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>   ：\n<ul>\n<li><strong>配置复杂</strong>   ：需要同时配置APP和服务器。</li>\n<li><strong>平台特定</strong>   ：iOS和Android的配置方法不同。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>方法三：Intent Scheme（主要用于Android）</h3>\n<p>这是Android平台上一种更强大、更精确的唤醒机制。</p>\n<h4>1. 原理</h4>\n<p>它可以指定要唤醒的APP包名，并携带更复杂的指令和数据。</p>\n<h4>2. 链接格式</h4>\n<pre><code>intent://path/#Intent;scheme=https;package=com.example.app;action=android.intent.action.VIEW;end\n</code></pre>\n<h4>3. 优点与缺点</h4>\n<ul>\n<li><strong>优点</strong>   ：功能强大，可以指定包名，避免调起错误的APP。</li>\n<li><strong>缺点</strong>   ：语法复杂，且主要在Android上使用。</li>\n</ul>\n<hr>\n<h3>最佳实践与注意事项</h3>\n<ol>\n<li>\n<p><strong>优雅降级（Fallback）</strong>   ：</p>\n<ul>\n<li>这是最关键的一点。无论用什么方法，都必须考虑用户没有安装APP的情况。</li>\n<li>通常的策略是：尝试用自定义Scheme唤醒 -&gt; 等待一段时间（例如300ms）-&gt; 如果没成功，则跳转到App Store/应用市场的下载页面，或者跳转到对应的H5页面。</li>\n</ul>\n</li>\n<li>\n<p><strong>传递参数</strong>   ：</p>\n<ul>\n<li>所有方法都可以在链接后面拼接参数，如 <code>id=123&amp;from=share</code>。APP被唤醒后，需要解析这些参数并跳转到对应的页面（如商品详情页、活动页等）。</li>\n</ul>\n</li>\n<li>\n<p><strong>安全处理</strong>   ：</p>\n<ul>\n<li>APP对接收到的所有URL参数都必须进行<strong>验证和消毒</strong>   ，防止通过恶意链接进行注入攻击。</li>\n</ul>\n</li>\n</ol>\n<p><strong>总结一下</strong>   ：</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">方法</th>\n<th style="text-align:left">原理</th>\n<th style="text-align:left">优点</th>\n<th style="text-align:left">缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>自定义 Scheme</strong></td>\n<td style="text-align:left"><code>myapp://</code> 协议映射</td>\n<td style="text-align:left">简单，兼容性好</td>\n<td style="text-align:left">体验差（没装APP会报错）</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>通用/应用链接</strong></td>\n<td style="text-align:left"><code>https://</code> 域名关联</td>\n<td style="text-align:left">体验无缝，安全</td>\n<td style="text-align:left">配置复杂，平台不一</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>Intent</strong></td>\n<td style="text-align:left">指定包名和指令</td>\n<td style="text-align:left">功能强大（Android）</td>\n<td style="text-align:left">语法复杂</td>\n</tr>\n</tbody>\n</table>\n<p>在实际商业项目中，通常会采用 <strong>“组合拳”</strong>   ：</p>\n<ul>\n<li>在 <strong>iOS</strong>   上优先使用 <strong>Universal Links</strong>   。</li>\n<li>在 <strong>Android</strong>   上使用 <strong>Intent Scheme</strong>   或 <strong>自定义 Scheme</strong>   。</li>\n<li>同时为两者都做好<strong>优雅降级</strong>   方案，确保用户体验的流畅性。</li>\n</ul>\n</div>'</script></body></html>