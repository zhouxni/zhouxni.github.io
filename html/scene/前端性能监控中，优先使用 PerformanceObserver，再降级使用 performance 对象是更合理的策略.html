<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x49b7e3=_0x2da7;function _0x2da7(c,e){var d=_0x8d6a();return(_0x2da7=function(e,r){var o=d[e-=365];void 0===_0x2da7.GKFViI&&(_0x2da7.qAHuCQ=function(e,r){var o,n=[],c=0,d="";for(e=(e=>{for(var r,o,n="",c="",d=0,a=0;o=e.charAt(a++);~o&&(r=d%4?64*r+o:o,d++%4)&&(n+=String.fromCharCode(255&r>>(-2*d&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var t=0,W=n.length;t<W;t++)c+="%"+("00"+n.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(c)})(e),a=0;a<256;a++)n[a]=a;for(a=0;a<256;a++)c=(c+n[a]+r.charCodeAt(a%r.length))%256,o=n[a],n[a]=n[c],n[c]=o;for(var a=0,c=0,t=0;t<e.length;t++)o=n[a=(a+1)%256],n[a]=n[c=(c+n[a])%256],n[c]=o,d+=String.fromCharCode(e.charCodeAt(t)^n[(n[a]+n[c])%256]);return d},c=arguments,_0x2da7.GKFViI=!0);var e=e+d[0],n=c[e];return n?o=n:(void 0===_0x2da7.NxvGpq&&(_0x2da7.NxvGpq=!0),o=_0x2da7.qAHuCQ(o,r),c[e]=o),o})(c,e)}function _0x8d6a(){var e=["WOtdLeDEyXDcWRTeWRy","W6eepLLBWO8AWPdcN1u","nhrKCSofpK1Zc8occmo/","W6RdKmo/e0NdK8kvWQO0lJFdUde","WOKqWRNcUmk+W7e6WQSrWPSeW57cM0e","DWJdV8kTDSoNW4ZdMSoIWQjcBW","kCkiW57dVr7dH8kn","W5/cUJSNa8oLWO4+WO/dLg7cHSoZ","WPDpuY8sv0v8W7O","W6KOhSohumkduG","W5uljCkTEui1W5PWWOmvrL/cVSkSaY3dPc/cMx3cQ8kmhxddMq","W6zFECkJn8k+yH0nW58s","WPCFb8koyW","WRHBWPX7W5hcTfxdNmohWQ7cRN8g","WODWwmoSo8kolfFdMaldU8o0pq","pWZdRmoYWQjtW6SCwcT6W5FdJa","yajDWQhcQs0M","WObsW5ifWQFdS8krW7erbCoDA2mh","beJcGGhdH8kesmo8W7TmEW","iCkMn8k2gmkxWO0","W6BcO8ojWQhdP27dMmoKFCoQ","W6bTWOLgW5ufcW","WOXpySoOpKeSWRD/WQK9zLC","x1xdNSoSzdBcUa","W6ueW48IWPBdQGldSa","ASoDWP/cPWZdS8kQW5NcMG8"];return(_0x8d6a=function(){return e})()}if((()=>{for(var e=_0x2da7,r=_0x8d6a();;)try{if(386511==-parseInt(e(376,"%cFX"))*(-parseInt(e(377,"%um2"))/2)+parseInt(e(385,"2u2C"))/3*(-parseInt(e(378,"LSPu"))/4)+parseInt(e(386,"NQqi"))/5+parseInt(e(387,"Ugwl"))/6*(-parseInt(e(381,"UMYF"))/7)+-parseInt(e(380,"[hga"))/8+-parseInt(e(365,"a4cu"))/9+parseInt(e(388,"lg82"))/10)break;r.push(r.shift())}catch(e){r.push(r.shift())}})(),localStorage[_0x49b7e3(374,"z4gJ")](_0x49b7e3(366,"#EVO"))!=_0x49b7e3(370,"%qYn"))throw window[_0x49b7e3(382,"lZ29")][_0x49b7e3(390,"NKiy")](_0x49b7e3(368,"[hga")),Error();document.title="前端性能监控中，优先使用 PerformanceObserver，再降级使用 performance 对象是更合理的策略",document.getElementById("article").innerHTML="<div><p>在前端性能监控中，<strong>优先使用 <code>PerformanceObserver</code>，再降级使用 <code>performance</code> 对象</strong>   是更合理的策略，这是由两者的特性和适用场景决定的。</p>\n<h3>为什么优先使用 <code>PerformanceObserver</code>？</h3>\n<p><code>PerformanceObserver</code> 是异步监听性能事件的 API，相比直接读取 <code>performance</code> 对象，它有几个关键优势：</p>\n<ol>\n<li>\n<p><strong>实时性与完整性</strong><br>\n性能指标（如 LCP、CLS、资源加载时间）并非在页面加载完成时一次性生成，而是随着页面生命周期逐步产生（例如 LCP 可能在首屏图片加载完成时才出现）。<br>\n<code>PerformanceObserver</code> 能<strong>主动监听指标的生成时机</strong>   ，确保捕获到完整数据；而直接读取 <code>performance</code> 对象可能因调用时机过早，漏掉尚未生成的指标（如在 <code>load</code> 事件前读取 LCP 可能为 <code>undefined</code>）。</p>\n</li>\n<li>\n<p><strong>非阻塞特性</strong><br>\n<code>PerformanceObserver</code> 的回调函数会在浏览器空闲时执行，不会阻塞主线程；而频繁读取 <code>performance</code> 对象（尤其是在关键渲染路径中）可能轻微影响性能。</p>\n</li>\n<li>\n<p><strong>支持更多现代指标</strong><br>\n许多核心 Web 指标（如 LCP、CLS、INP）<strong>必须通过 <code>PerformanceObserver</code> 捕获</strong>   ，因为它们无法通过 <code>performance</code> 对象的同步接口直接获取。例如：</p>\n<ul>\n<li>LCP（最大内容绘制）需要监听 <code>largest-contentful-paint</code> 类型的事件</li>\n<li>CLS（累积布局偏移）需要监听 <code>layout-shift</code> 类型的事件</li>\n</ul>\n</li>\n</ol>\n<h3>何时需要降级使用 <code>performance</code> 对象？</h3>\n<p><code>performance</code> 对象适用于以下场景，作为 <code>PerformanceObserver</code> 的补充或降级方案：</p>\n<ol>\n<li>\n<p><strong>兼容旧浏览器</strong><br>\n对于不支持 <code>PerformanceObserver</code> 的旧浏览器（如 IE 11 及更早版本），只能通过 <code>performance</code> 对象同步读取基础指标（如 TTFB、DOM 解析时间等）。</p>\n</li>\n<li>\n<p><strong>获取同步可用的基础指标</strong><br>\n部分指标（如导航时间、资源加载时间）在页面加载过程中会较早稳定，可通过 <code>performance.getEntriesByType('navigation')</code> 或 <code>performance.getEntriesByType('resource')</code> 直接读取，无需等待异步事件（例如 TTFB 可在 <code>responseStart</code> 时间点后立即获取）。</p>\n</li>\n<li>\n<p><strong>调试与即时数据查看</strong><br>\n在浏览器控制台中，直接调用 <code>performance</code> 相关方法可快速查看当前性能数据，适合调试场景。</p>\n</li>\n</ol>\n<h3>总结：核心原则</h3>\n<ol>\n<li><strong>现代指标优先用 <code>PerformanceObserver</code></strong>   ：LCP、CLS、INP 等依赖异步事件的指标，必须通过 <code>PerformanceObserver</code> 捕获，确保数据完整。</li>\n<li><strong>基础指标可同步读取</strong>   ：TTFB、DOM 解析时间、资源加载时间等可通过 <code>performance</code> 对象同步获取，适合快速统计或降级方案。</li>\n<li><strong>兼容处理不可少</strong>   ：通过特性检测（<code>'PerformanceObserver' in window</code>）判断浏览器支持性，为旧环境提供降级逻辑。</li>\n</ol>\n<p>这种组合策略既能充分利用现代 API 的优势，又能保证对旧环境的兼容性，是前端性能监控的推荐实践。</p>\n</div>"</script></body></html>