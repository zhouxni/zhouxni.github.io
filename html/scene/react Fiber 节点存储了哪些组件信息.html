<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x531a68=_0x3195;function _0xec45(){var n=["u3DkWRdcMHpdUa","cSoNz8oMWP/cSGe","xbZdO8oWoLFdGmkJWO3dNXpdI8oYW40","ps7cVIVdM8oyD0eXCNRdTG","W5D4lmkSk8kUWPZcOG","WPtcLuhcL8ot","ur7dO8o4nLhcVmowWPVdMHxdGW","yKnMWQtcQs/dGbfvW5lcUmoifmoAAmoDW6vwqSoMfCoxgf/dS8ou","W611jZbLh1T0ww3dOa","WPPoWQldKSotWQTyWOJcHa","W4BdMSkoW6ddNCo9a0pdG3ZdRhCW","WP84rXXJWPmSFSkjW5xdRda","wCk2iSkEW5ldPvvnmWBcG8oFyca","W77cOSkjFgFdH8ozWOZcOSoUW7ldLCo3","nsdcVYlcHSkfuguvBa","iM5kWPBdHmkYWOnbvSops8oIWPu","CvRdMCo5CmoQlmovmCoh","DrOCiw/cLmoBW5ZdOJKKEs8","W4BdKSkoW6xdN8o7qKFdO2ldKvC","t8o/BSoNW7afw8oDW6W2W6e","WORdRCouEseJCmon","pWeHW6dcUgdcNeDUW64","W7HzW5miWO7cGrio","z8oWW4CSBXhcH8k8nSk9"];return(_0xec45=function(){return n})()}function _0x3195(o,n){var a=_0xec45();return(_0x3195=function(n,t){var s=a[n-=249];void 0===_0x3195.AvrGbX&&(_0x3195.GwOrmK=function(n,t){var s,e=[],o=0,a="";for(n=(n=>{for(var t,s,e="",o="",a=0,d=0;s=n.charAt(d++);~s&&(t=a%4?64*t+s:s,a++%4)&&(e+=String.fromCharCode(255&t>>(-2*a&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var c=0,r=e.length;c<r;c++)o+="%"+("00"+e.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(o)})(n),d=0;d<256;d++)e[d]=d;for(d=0;d<256;d++)o=(o+e[d]+t.charCodeAt(d%t.length))%256,s=e[d],e[d]=e[o],e[o]=s;for(var d=0,o=0,c=0;c<n.length;c++)s=e[d=(d+1)%256],e[d]=e[o=(o+e[d])%256],e[o]=s,a+=String.fromCharCode(n.charCodeAt(c)^e[(e[d]+e[o])%256]);return a},o=arguments,_0x3195.AvrGbX=!0);var n=n+a[0],e=o[n];return e?s=e:(void 0===_0x3195.rbDNqk&&(_0x3195.rbDNqk=!0),s=_0x3195.GwOrmK(s,t),o[n]=s),s})(o,n)}if((()=>{for(var n=_0x3195,t=_0xec45();;)try{if(820907==-parseInt(n(251,"y7UP"))+-parseInt(n(257,"EDW#"))/2+-parseInt(n(261,"2TvI"))/3+-parseInt(n(259,"Bpk1"))/4*(parseInt(n(254,"r%f9"))/5)+-parseInt(n(262,"U5*F"))/6*(parseInt(n(270,"*f9f"))/7)+-parseInt(n(255,"SKB8"))/8+parseInt(n(252,"TGcP"))/9)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x531a68(265,"TGcP")](_0x531a68(249,"$E5w"))!=_0x531a68(269,"P3jH"))throw window[_0x531a68(268,"wMlJ")][_0x531a68(264,"Stkp")](_0x531a68(271,"2TvI")),Error();document.title="react Fiber 节点存储了哪些组件信息",document.getElementById("article").innerHTML='<div><p>在 React 的 <strong>Fiber 架构</strong>   中，<strong>Fiber 节点</strong>   是构建虚拟 DOM 树的核心数据结构，它存储了组件的关键信息，但并不包含组件的所有内部细节。以下是 Fiber 节点存储的主要组件信息：</p>\n<hr>\n<h2><strong>1. Fiber 节点存储的核心信息</strong></h2>\n<p>Fiber 节点（<code>fiber</code> 对象）包含以下关键字段，用于描述组件及其渲染状态：</p>\n<h3><strong>(1) 组件标识与类型</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>字段</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>tag</code></td>\n<td>标识组件类型（函数组件、类组件、DOM 元素等），如 <code>FunctionComponent</code>、<code>ClassComponent</code>、<code>HostComponent</code></td>\n</tr>\n<tr>\n<td><code>type</code></td>\n<td>组件本身（函数/类）或 DOM 标签名（如 <code>\'div\'</code>）</td>\n</tr>\n<tr>\n<td><code>key</code></td>\n<td>React 元素的 <code>key</code>，用于协调算法（Diffing）</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>(2) 组件实例与状态</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>字段</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>stateNode</code></td>\n<td><strong>类组件</strong>  ：存储组件实例（<code>this</code>）<br/><strong>DOM 元素</strong>  ：存储真实 DOM 节点（如 <code>div</code>）</td>\n</tr>\n<tr>\n<td><code>memoizedState</code></td>\n<td><strong>函数组件</strong>  ：存储 Hook 链表（<code>useState</code>、<code>useEffect</code> 等）<br/><strong>类组件</strong>  ：存储 <code>this.state</code></td>\n</tr>\n<tr>\n<td><code>memoizedProps</code></td>\n<td>当前渲染使用的 <code>props</code></td>\n</tr>\n<tr>\n<td><code>pendingProps</code></td>\n<td>等待处理的新 <code>props</code>（更新时暂存）</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>(3) 组件关系（Fiber 树结构）</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>字段</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>return</code></td>\n<td>指向父 Fiber 节点（用于回溯）</td>\n</tr>\n<tr>\n<td><code>child</code></td>\n<td>指向第一个子 Fiber 节点</td>\n</tr>\n<tr>\n<td><code>sibling</code></td>\n<td>指向下一个兄弟 Fiber 节点</td>\n</tr>\n<tr>\n<td><code>alternate</code></td>\n<td>指向上一次渲染的 Fiber（用于 Diffing 和双缓存机制）</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>(4) 更新与副作用</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>字段</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>updateQueue</code></td>\n<td>存储待处理的更新（如 <code>setState</code> 的更新队列）</td>\n</tr>\n<tr>\n<td><code>flags</code>（旧版 <code>effectTag</code>）</td>\n<td>标记副作用（如 <code>Placement</code>、<code>Update</code>、<code>Deletion</code>）</td>\n</tr>\n<tr>\n<td><code>lanes</code></td>\n<td>优先级标记（调度相关，如高优先级用户交互 vs 低优先级数据加载）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>2. Fiber 节点 <em>不存储</em> 哪些组件信息？</strong></h2>\n<p>虽然 Fiber 节点存储了组件的核心渲染信息，但<strong>以下内容不直接存储在 Fiber 中</strong>  ：</p>\n<h3><strong>(1) 函数组件的局部变量</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">let</span> localVar = <span class="hljs-number">0</span>; <span class="hljs-comment">// ❌ 不存储在 Fiber 中（每次渲染重新创建）</span>\n  <span class="hljs-keyword">const</span> [state] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// ✅ 存储在 `memoizedState`（Hook 链表）</span>\n}\n</code></pre>\n<ul>\n<li><strong>局部变量</strong>  （如 <code>localVar</code>）由闭包管理，Fiber 不存储它们。</li>\n<li><strong>Hook 状态</strong>  （如 <code>useState</code>）存储在 <code>memoizedState</code> 的链表中。</li>\n</ul>\n<h3><strong>(2) 上下文（Context）</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dark&quot;</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<ul>\n<li>Context 的值由 Provider 动态传递，<strong>不直接存储在 Fiber</strong>   中。</li>\n<li>Fiber 仅记录组件是否消费了 Context。</li>\n</ul>\n<h3><strong>(3) 事件处理函数</strong></h3>\n<pre><code class="language-jsx">&lt;button onClick={<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;click&quot;</span>)}&gt;<span class="hljs-title class_">Click</span>&lt;/button&gt;\n</code></pre>\n<ul>\n<li>事件回调（如 <code>onClick</code>）作为 <code>props</code> 存储在 <code>memoizedProps</code> 中，但函数本身<strong>不关联 Fiber</strong>  。</li>\n<li>React 使用合成事件系统统一管理事件。</li>\n</ul>\n<h3><strong>(4) 派生数据</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">List</span>(<span class="hljs-params">{ items }</span>) {\n  <span class="hljs-keyword">const</span> filteredItems = items.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">active</span>); <span class="hljs-comment">// ❌ 不存储在 Fiber</span>\n  <span class="hljs-keyword">const</span> memoizedItems = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> items.<span class="hljs-title function_">filter</span>(...), [items]); <span class="hljs-comment">// ✅ 存储在 Hook 链表</span>\n}\n</code></pre>\n<ul>\n<li><strong>计算得到的派生数据</strong>  （如 <code>filteredItems</code>）默认不存储，除非使用 <code>useMemo</code>。</li>\n</ul>\n<hr>\n<h2><strong>3. 如何查看 Fiber 节点信息？</strong></h2>\n<h3><strong>(1) React DevTools</strong></h3>\n<ul>\n<li>在浏览器开发者工具中，使用 <strong>React DevTools</strong>   选中组件，查看其 Fiber 节点的 <code>props</code>、<code>state</code>、<code>hooks</code> 等。</li>\n</ul>\n<h3><strong>(2) 调试源码</strong></h3>\n<ul>\n<li>在 React 源码中，Fiber 节点类型定义在 <code>ReactFiber.old.js</code> / <code>ReactFiber.new.js</code>（如 <code>FunctionComponent = 0</code>, <code>ClassComponent = 1</code>）。</li>\n</ul>\n<h3><strong>(3) 控制台打印</strong></h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>();\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ref.<span class="hljs-property">current</span>?.<span class="hljs-property">_reactInternals</span>); <span class="hljs-comment">// 查看 Fiber 节点</span>\n  }, []);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n<ul>\n<li>通过 <code>ref._reactInternals</code> 可以访问 DOM 节点对应的 Fiber（仅开发环境可用）。</li>\n</ul>\n<hr>\n<h2><strong>4. 总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th><strong>存储内容</strong></th>\n<th><strong>Fiber 字段</strong></th>\n<th><strong>示例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>组件类型</td>\n<td><code>tag</code>, <code>type</code></td>\n<td><code>FunctionComponent</code>, <code>\'div\'</code></td>\n</tr>\n<tr>\n<td>组件实例/DOM 节点</td>\n<td><code>stateNode</code></td>\n<td>类组件的 <code>this</code> 或 <code>HTMLDivElement</code></td>\n</tr>\n<tr>\n<td>Props</td>\n<td><code>memoizedProps</code>, <code>pendingProps</code></td>\n<td><code>{ color: &quot;red&quot; }</code></td>\n</tr>\n<tr>\n<td>状态（Hooks/类组件 state）</td>\n<td><code>memoizedState</code></td>\n<td><code>useState</code> 的值或 <code>this.state</code></td>\n</tr>\n<tr>\n<td>子节点关系</td>\n<td><code>child</code>, <code>sibling</code>, <code>return</code></td>\n<td>Fiber 树结构</td>\n</tr>\n<tr>\n<td>更新与副作用</td>\n<td><code>updateQueue</code>, <code>flags</code></td>\n<td><code>setState</code> 队列、<code>Placement</code></td>\n</tr>\n</tbody>\n</table>\n<p>Fiber 节点是 React 协调（Reconciliation）和渲染的核心，但它<strong>不存储组件的所有内部细节</strong>  （如局部变量、派生数据），而是通过 Hooks、Context 和闭包等机制协同工作。</p>\n</div>'</script></body></html>