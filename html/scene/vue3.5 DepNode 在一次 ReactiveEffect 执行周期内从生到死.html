<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x22ea11=_0x4b40;function _0x4b40(p,s){var l=_0x4779();return(_0x4b40=function(s,n){var e=l[s-=457];void 0===_0x4b40.BEydIJ&&(_0x4b40.fTobSD=function(s,n){var e,a=[],p=0,l="";for(s=(s=>{for(var n,e,a="",p="",l=0,t=0;e=s.charAt(t++);~e&&(n=l%4?64*n+e:e,l++%4)&&(a+=String.fromCharCode(255&n>>(-2*l&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var o=0,c=a.length;o<c;o++)p+="%"+("00"+a.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(p)})(s),t=0;t<256;t++)a[t]=t;for(t=0;t<256;t++)p=(p+a[t]+n.charCodeAt(t%n.length))%256,e=a[t],a[t]=a[p],a[p]=e;for(var t=0,p=0,o=0;o<s.length;o++)e=a[t=(t+1)%256],a[t]=a[p=(p+a[t])%256],a[p]=e,l+=String.fromCharCode(s.charCodeAt(o)^a[(a[t]+a[p])%256]);return l},p=arguments,_0x4b40.BEydIJ=!0);var s=s+l[0],a=p[s];return a?e=a:(void 0===_0x4b40.zYUdUV&&(_0x4b40.zYUdUV=!0),e=_0x4b40.fTobSD(e,n),p[s]=e),e})(p,s)}if((()=>{for(var s=_0x4b40,n=_0x4779();;)try{if(530587==-parseInt(s(458,"oAv0"))*(parseInt(s(460,"EV8N"))/2)+-parseInt(s(463,"74Ce"))/3+-parseInt(s(475,"tgWk"))/4*(parseInt(s(457,"K9Al"))/5)+parseInt(s(462,"Y!I0"))/6+parseInt(s(468,"j3PN"))/7+parseInt(s(474,"Ky2a"))/8+-parseInt(s(459,"xD%F"))/9*(parseInt(s(470,"xD%F"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x22ea11(467,"d0bx")](_0x22ea11(466,"Qfx5"))!=_0x22ea11(478,"KwF5"))throw window[_0x22ea11(480,"HQah")][_0x22ea11(477,"6Sb&")](_0x22ea11(482,"Qfx5")),Error();function _0x4779(){var s=["o8kSwexdMv4PaCkp","WOBdUqxcM8oDjXJcIXxcNsyjla","BmotmSoJsa4dWRddJCo6","u8oCWOGnW7/dUmoDrCk/W4bXWQT3","W4RcJvTYW7XDxISm","zMBdNqOAu1pcGSoNgSoPW7NdMa","W7ZcTmkzW5H3WQOE","xmoskSkfaW","bSk4W6aVWRtdSCoUW4BcKq","yCoYa0FdOfaCfq","WQvHW53cNq7dN8k+aI0pe8kmWPq","W7XtWRW7vYvrqSkRWPmBnSo2hSkpxCkrWPtcJGeOW69oWRebWRi","W4pdR8opWRfGW4xdQ8ontSoMWOW","D8o7WQlcPstcK8ktx8oi","nGSsW5yoWRW1WQpdJCoxt8k7aq","cSkcbCokWOtdMmkLW6n4CW","vmoFW4XGWPtcMmkGtq","BSoqnSoOg0DuWO3dRSo2umo7fa","WQ7dMCkaW5K+FIlcP8o8W41hW7tcQW","C8k7c8kxDaRcRa3dOCkHja","WRFdKCo7lSoonmkmW5hdMSkKWRXOW74","W5veWQSUv2W1cmkO","w8kKemkHE8kuBW","hCoeBvviWP7cG8oLWOLkW6n7WOG","oCkKuHdcOGTecCkNWOWFW6Li","mWjqWRrHW5zpWQS"];return(_0x4779=function(){return s})()}document.title="vue3.5 DepNode 在一次 ReactiveEffect 执行周期内从生到死",document.getElementById("article").innerHTML='<div><p>下面按时间线把「DepNode 在一次 ReactiveEffect 执行周期内<strong>从生到死</strong>   」完整走一遍，每一步都给出<strong>源码级细节</strong>   （伪代码 + 行号映射），你可以直接打开 <code>effect.ts</code> 跟着对。</p>\n<hr>\n<ol>\n<li>进入执行周期 —— run() 被调用</li>\n</ol>\n<pre><code class="language-ts"><span class="hljs-comment">// effect.ts  run()</span>\n<span class="hljs-keyword">const</span> effect = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 当前 ReactiveEffect</span>\nactiveEffect = effect; <span class="hljs-comment">// 全局指针，让接下来的 track 能找到我</span>\neffect.<span class="hljs-property">dirty</span> = <span class="hljs-literal">false</span>;\neffect.<span class="hljs-property">depsTail</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 清空旧链表，准备重新收集</span>\n<span class="hljs-title function_">effect</span>();\n</code></pre>\n<ul>\n<li><code>activeEffect</code> 置为当前 effect，下面的 <code>track</code> 就知道把节点挂到哪条垂直链。</li>\n</ul>\n<hr>\n<ol start="2">\n<li>模板 / 函数体里读取响应式字段 —— track() 触发</li>\n</ol>\n<pre><code class="language-ts"><span class="hljs-comment">// dep.ts  track()</span>\n<span class="hljs-keyword">if</span> (dep.<span class="hljs-property">head</span>?.<span class="hljs-property">sub</span> === activeEffect) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 1. 同一次执行周期已来过，直接复用</span>\n<span class="hljs-keyword">let</span> node = activeEffect.<span class="hljs-property">depsTail</span>; <span class="hljs-comment">// 2. 先看尾节点能否复用</span>\n<span class="hljs-keyword">if</span> (!node || node.<span class="hljs-property">dep</span> !== dep) {\n  node = <span class="hljs-title function_">createDepNode</span>(activeEffect, dep); <span class="hljs-comment">// 3. 真正创建</span>\n}\n<span class="hljs-title function_">link</span>(dep, node); <span class="hljs-comment">// 4. 挂到两条链</span>\n</code></pre>\n<ul>\n<li><strong>createDepNode</strong>   只做一件事：<code>{ sub: effect, dep }</code> 并初始化指针。</li>\n<li><strong>link</strong>   把节点同时插进：\n<ul>\n<li><strong>水平链</strong>   ：<code>dep.head … dep.tail</code>（字段级）</li>\n<li><strong>垂直链</strong>   ：<code>effect.depsHead … effect.depsTail</code>（watcher 级）</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ol start="3">\n<li>多次读取同一字段 —— 复用节点</li>\n</ol>\n<pre><code class="language-ts"><span class="hljs-comment">// 第二次读取同一 dep</span>\ndep.<span class="hljs-property">head</span>?.<span class="hljs-property">sub</span> === activeEffect; <span class="hljs-comment">// true，直接 return</span>\n</code></pre>\n<ul>\n<li>不会分配新节点，也不会重复插入链表。</li>\n</ul>\n<hr>\n<ol start="4">\n<li>执行完毕 —— run() 结束</li>\n</ol>\n<pre><code class="language-ts"><span class="hljs-comment">// effect.ts  run() 尾部</span>\n<span class="hljs-title function_">finalizeRun</span>(effect);\n</code></pre>\n<ul>\n<li><code>finalizeRun</code> 把 <code>activeEffect</code> 设回 <code>undefined</code>，表示<strong>收集阶段结束</strong>   。</li>\n</ul>\n<p>此时：</p>\n<ul>\n<li><strong>DepNode 已全建完</strong>   ，挂在两条链上。</li>\n<li>组件进入渲染或计算完成状态。</li>\n</ul>\n<hr>\n<ol start="5">\n<li>依赖发生变化 —— trigger() 触发</li>\n</ol>\n<pre><code class="language-ts"><span class="hljs-comment">// dep.ts  trigger()</span>\n<span class="hljs-keyword">let</span> node = dep.<span class="hljs-property">head</span>;\n<span class="hljs-keyword">while</span> (node) {\n  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">sub</span>.<span class="hljs-property">dirty</span> !== dep.<span class="hljs-property">version</span>) {\n    node.<span class="hljs-property">sub</span>.<span class="hljs-property">dirty</span> = dep.<span class="hljs-property">version</span>;\n    <span class="hljs-title function_">queueEffect</span>(node.<span class="hljs-property">sub</span>); <span class="hljs-comment">// 调度器排队</span>\n  }\n  node = node.<span class="hljs-property">nextDep</span>;\n}\n</code></pre>\n<ul>\n<li>只是遍历水平链表，<strong>不会动节点本身</strong>   。</li>\n</ul>\n<hr>\n<ol start="6">\n<li>重新执行 —— 调度器再次调用 run()</li>\n</ol>\n<pre><code class="language-ts">effect.<span class="hljs-title function_">run</span>();\n</code></pre>\n<ul>\n<li>进入新一轮执行周期，<strong>先 cleanup 旧节点</strong>   ：</li>\n</ul>\n<pre><code class="language-ts"><span class="hljs-comment">// effect.ts  run() 开头</span>\n<span class="hljs-title function_">cleanup</span>(effect);\n</code></pre>\n<hr>\n<ol start="7">\n<li>cleanup —— 节点死亡</li>\n</ol>\n<pre><code class="language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params">effect</span>) {\n  <span class="hljs-keyword">let</span> node = effect.<span class="hljs-property">depsHead</span>\n  <span class="hljs-keyword">while</span> (node) {\n    <span class="hljs-keyword">const</span> next = node.<span class="hljs-property">nextSub</span>\n    <span class="hljs-comment">// 从两条链摘掉</span>\n    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">prevDep</span>) node.<span class="hljs-property">prevDep</span>.<span class="hljs-property">nextDep</span> = node.<span class="hljs-property">nextDep</span>\n    <span class="hljs-keyword">else</span> node.<span class="hljs-property">dep</span>.<span class="hljs-property">head</span> = node.<span class="hljs-property">nextDep</span>\n    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">nextDep</span>) node.<span class="hljs-property">nextDep</span>.<span class="hljs-property">prevDep</span> = node.<span class="hljs-property">prevDep</span>\n    <span class="hljs-keyword">else</span> node.<span class="hljs-property">dep</span>.<span class="hljs-property">tail</span> = node.<span class="hljs-property">prevDep</span>\n    <span class="hljs-comment">// 从垂直链摘掉</span>\n    ...\n    node = next\n  }\n  effect.<span class="hljs-property">depsHead</span> = effect.<span class="hljs-property">depsTail</span> = <span class="hljs-literal">undefined</span>\n}\n</code></pre>\n<ul>\n<li>所有旧节点<strong>失去引用</strong>   ，等待 GC。</li>\n<li>然后开始新的收集周期（回到步骤 1）。</li>\n</ul>\n<hr>\n<p>时间轴小结（一句话背下来）：</p>\n<blockquote>\n<p><strong>DepNode 只在“当前 ReactiveEffect 正在跑”的这段时间里活着；跑完后一把全删掉，下次重新跑再重新生。</strong></p>\n</blockquote>\n</div>'</script></body></html>