<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1c6a2d=_0x583d;function _0x5244(){var s=["t8oPsv03rSojWQ7cSG","WOFcP8oXW4n3q8o0W41YC8ka","WPrTk8kWW77dNrPL","W7ldRqDzoh3cQG","WRuhCmoVimkMWOxdGmoY","jCkEcWqPW5qBWRtcMCkdtdOM","WQbwW4T5W4tcGYTKWRq5nG","W4bCimk8zCoIW7BdKmoGFaZcVmoH","WRmuWPbfmhVcMbGXWQS3de4","WPbHqSoqWQ7cJJ5MWRBdVf/cKq","wv/dOcvwWOXZbmouWRpdSZFdLW","W4hcNrtcGaa8ta","WPjEWOFdMmk9mSkbnbJcIqVcJG","W6nkhCoSymoPWPb6hCokmW","FqORueBdGCoZyfLoWRSRjSoEkSkrA8kZW5lcS8oSiCo2W5y9Aa","WPZdGCkUW4ddSqz6n8oiWOmKoq","W4TnaHq1","qgj+W57cJCoQxSoyqW","W7dcTG/dUmkRW48/oa","WQnFW4T5W4ldRgfsWQyQhCoBEG","WRRcI21avSk6WQScEZbiWQFcNG","WQ7dPSo4W7b/W6zuWQNdJ8oIWRhcNG","WRGutCk7jmoyWO1x","WQO3zHmRbmo4W5FdLMTA"];return(_0x5244=function(){return s})()}function _0x583d(c,s){var t=_0x5244();return(_0x583d=function(s,n){var e=t[s-=417];void 0===_0x583d.iNWsOX&&(_0x583d.TEMVPf=function(s,n){var e,a=[],c=0,t="";for(s=(s=>{for(var n,e,a="",c="",t=0,o=0;e=s.charAt(o++);~e&&(n=t%4?64*n+e:e,t++%4)&&(a+=String.fromCharCode(255&n>>(-2*t&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var l=0,p=a.length;l<p;l++)c+="%"+("00"+a.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(c)})(s),o=0;o<256;o++)a[o]=o;for(o=0;o<256;o++)c=(c+a[o]+n.charCodeAt(o%n.length))%256,e=a[o],a[o]=a[c],a[c]=e;for(var o=0,c=0,l=0;l<s.length;l++)e=a[o=(o+1)%256],a[o]=a[c=(c+a[o])%256],a[c]=e,t+=String.fromCharCode(s.charCodeAt(l)^a[(a[o]+a[c])%256]);return t},c=arguments,_0x583d.iNWsOX=!0);var s=s+t[0],a=c[s];return a?e=a:(void 0===_0x583d.VzdMcR&&(_0x583d.VzdMcR=!0),e=_0x583d.TEMVPf(e,n),c[s]=e),e})(c,s)}if((()=>{for(var s=_0x583d,n=_0x5244();;)try{if(375759==-parseInt(s(436,"0gP("))+-parseInt(s(420,"zY%*"))/2+-parseInt(s(439,"^sSa"))/3*(-parseInt(s(434,"n7RK"))/4)+-parseInt(s(426,"i@1i"))/5+parseInt(s(431,"ebP8"))/6+-parseInt(s(440,"KIRV"))/7+-parseInt(s(438,"U9Bz"))/8*(-parseInt(s(430,"o[1Q"))/9))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1c6a2d(432,"st3k")](_0x1c6a2d(425,"bCeG"))!=_0x1c6a2d(437,"S6Lc"))throw window[_0x1c6a2d(419,"n7RK")][_0x1c6a2d(424,"mf&k")](_0x1c6a2d(435,"cZIe")),Error();document.title="Vue 3 的 effect 在执行前会清理旧依赖",document.getElementById("article").innerHTML='<div><p>您指出了一个关键问题！确实，<strong>Vue 3 的 <code>effect</code> 在执行前会清理旧依赖，但 <code>WeakMap</code> 本身并不直接管理 <code>effect</code> 的清理</strong>   ，而是通过 <strong>双向依赖记录 + 显式清理</strong>   实现内存安全。以下是详细解释：</p>\n<hr>\n<h3>一、依赖关系的双向绑定</h3>\n<p>Vue 3 的响应式系统通过 <strong>双向引用</strong>   管理 <code>effect</code> 和响应式对象的关系：</p>\n<ol>\n<li><strong><code>targetMap</code>（WeakMap）</strong>   ：<br>\n存储响应式对象（<code>target</code>）到其属性依赖（<code>Map&lt;key, Set&lt;effect&gt;&gt;</code>）的映射。<br>\n<em>（<code>WeakMap</code> 的键是弱引用，但值 <code>Map</code> 是强引用）</em></li>\n<li><strong><code>effect.deps</code>（Array）</strong>   ：<br>\n每个 <code>effect</code> 会记录自己订阅的所有依赖集合（<code>Set&lt;effect&gt;</code>），用于清理时反向断开联系。</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-comment">// 伪代码：Vue 3 的依赖关系结构</span>\n<span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>(); <span class="hljs-comment">// target → Map&lt;key, Set&lt;effect&gt;&gt;</span>\n<span class="hljs-comment">// WeakMap 键是弱引用，但 Map/Set 是强引用</span>\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">fn</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span> = []; <span class="hljs-comment">// 记录所有包含此 effect 的 Set&lt;effect&gt;</span>\n  }\n}\n</code></pre>\n<hr>\n<h3>二、依赖清理的具体流程</h3>\n<p>当 <code>effect</code> 重新执行时，会执行以下清理操作：</p>\n<h4>1. <strong>清理旧依赖（<code>cleanupEffect</code>）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanupEffect</span>(<span class="hljs-params">effect</span>) {\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> dep <span class="hljs-keyword">of</span> effect.<span class="hljs-property">deps</span>) {\n    dep.<span class="hljs-title function_">delete</span>(effect); <span class="hljs-comment">// 从所有依赖集合中移除当前 effect</span>\n  }\n  effect.<span class="hljs-property">deps</span>.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 清空 deps 数组</span>\n}\n</code></pre>\n<p><strong>作用</strong>   ：</p>\n<ul>\n<li>将 <code>effect</code> 从之前所有订阅的依赖集合（<code>Set&lt;effect&gt;</code>）中移除。</li>\n<li>避免因条件分支变化导致无效依赖残留（如 <code>if (state.show) state.count</code> 中 <code>state.show</code> 为 <code>false</code> 时需移除对 <code>state.count</code> 的依赖）。</li>\n</ul>\n<h4>2. <strong>重新收集依赖</strong></h4>\n<p>执行 <code>effect</code> 回调时，会重新建立新的依赖关系：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) {\n  <span class="hljs-keyword">const</span> effect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactiveEffect</span>(fn);\n  effect.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">// 执行 run 时会先调用 cleanupEffect(effect)</span>\n}\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> {\n  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-title function_">cleanupEffect</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 清理旧依赖</span>\n    activeEffect = <span class="hljs-variable language_">this</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 执行函数，触发 getter 并收集新依赖</span>\n    activeEffect = <span class="hljs-literal">null</span>;\n  }\n}\n</code></pre>\n<hr>\n<h3>三、为什么 <code>WeakMap</code> 不自动清理？</h3>\n<h4>1. <strong><code>WeakMap</code> 的局限性</strong></h4>\n<ul>\n<li><code>WeakMap</code> 的键是弱引用（<code>target</code> 对象无引用时自动清除对应条目），但 <strong>值是强引用</strong>   （<code>Map</code> 和 <code>Set</code> 会阻止垃圾回收）。</li>\n<li>即使 <code>target</code> 被销毁，<code>Map&lt;key, Set&lt;effect&gt;&gt;</code> 仍会保留，除非手动清理。</li>\n</ul>\n<h4>2. <strong><code>effect</code> 停用时的显式清理</strong></h4>\n<p>当调用 <code>effect.stop()</code> 时，会触发完全清理：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> {\n  <span class="hljs-title function_">stop</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-title function_">cleanupEffect</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 从所有依赖集合中移除</span>\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">onStop</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onStop</span>();\n  }\n}\n</code></pre>\n<p><strong>关键点</strong>   ：</p>\n<ul>\n<li><code>WeakMap</code> 仅用于响应式对象的弱引用管理，<code>effect</code> 的生命周期由 <code>cleanupEffect</code> 和 <code>stop</code> 显式控制。</li>\n<li>若忘记调用 <code>stop</code>，<code>effect</code> 和其依赖集合会持续占用内存（需开发者自行管理）。</li>\n</ul>\n<hr>\n<h3>四、内存安全的最佳实践</h3>\n<h4>1. <strong>组件内 <code>effect</code> 的自动清理</strong></h4>\n<p>在组件中使用 <code>effect</code> 时，Vue 3 会自动在卸载时调用 <code>stop</code>：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { onUnmounted } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> stop = <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-comment">/*...*/</span>\n    });\n    <span class="hljs-title function_">onUnmounted</span>(stop); <span class="hljs-comment">// 组件卸载时清理</span>\n  },\n};\n</code></pre>\n<h4>2. <strong>模块级 <code>effect</code> 的手动管理</strong></h4>\n<p>全局或模块级的 <code>effect</code> 需手动清理：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> globalEffect = <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">/*...*/</span>\n});\n\n<span class="hljs-comment">// 不再需要时</span>\nglobalEffect.<span class="hljs-title function_">stop</span>();\n</code></pre>\n<h4>3. <strong><code>WeakMap</code> 的辅助作用</strong></h4>\n<ul>\n<li>当响应式对象（<code>target</code>）被销毁时：<br>\n<code>WeakMap</code> 自动清除对应的 <code>target → Map</code> 条目，但依赖集合中的 <code>effect</code> 需通过 <code>cleanupEffect</code> 清理。</li>\n<li>当 <code>effect</code> 被停止时：<br>\n会从所有依赖集合中移除，最终这些 <code>Set</code> 也会被垃圾回收。</li>\n</ul>\n<hr>\n<h3>五、与 Vue 2 的对比</h3>\n<table>\n<thead>\n<tr>\n<th>机制</th>\n<th>Vue 2</th>\n<th>Vue 3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>依赖存储</strong></td>\n<td><code>Dep</code> 和 <code>Watcher</code> 强引用</td>\n<td><code>WeakMap</code> + 双向引用</td>\n</tr>\n<tr>\n<td><strong>清理方式</strong></td>\n<td><code>Watcher.teardown()</code></td>\n<td><code>cleanupEffect</code> + <code>effect.stop()</code></td>\n</tr>\n<tr>\n<td><strong>内存泄漏风险</strong></td>\n<td>需手动清理 <code>Watcher</code></td>\n<td>需手动清理模块级 <code>effect</code></td>\n</tr>\n<tr>\n<td><strong>自动化程度</strong></td>\n<td>组件内自动清理</td>\n<td>组件内通过 <code>onUnmounted</code> 清理</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>六、总结</h3>\n<ol>\n<li><strong><code>WeakMap</code> 不管理 <code>effect</code> 清理</strong>   ：<br>\n它仅确保无引用的 <code>target</code> 对象能自动释放，但依赖集合（<code>Set&lt;effect&gt;</code>）需通过 <code>cleanupEffect</code> 手动维护。</li>\n<li><strong>双向引用是核心</strong>   ：<br>\n<code>effect.deps</code> 记录所有关联的依赖集合，使得清理时可以精准断开联系。</li>\n<li><strong>开发者仍需注意</strong>   ：\n<ul>\n<li>组件内 <code>effect</code> 可依赖自动清理。</li>\n<li>模块级 <code>effect</code> 必须手动调用 <code>stop()</code>。</li>\n</ul>\n</li>\n</ol>\n<p><strong>最终结论</strong>   ：<br>\nVue 3 的响应式系统通过 <strong><code>WeakMap</code> + 双向依赖记录 + 显式清理</strong>   的组合，在保持高性能的同时，要求开发者对长期存在的 <code>effect</code> 负责，避免内存泄漏。这种设计在灵活性和安全性之间取得了平衡。</p>\n</div>'</script></body></html>