<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x433caa=_0x3ba3;function _0x3ba3(o,n){var l=_0x2c94();return(_0x3ba3=function(n,a){var e=l[n-=366];void 0===_0x3ba3.FzLTDp&&(_0x3ba3.DIkEZk=function(n,a){var e,s=[],o=0,l="";for(n=(n=>{for(var a,e,s="",o="",l=0,t=0;e=n.charAt(t++);~e&&(a=l%4?64*a+e:e,l++%4)&&(s+=String.fromCharCode(255&a>>(-2*l&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var i=0,r=s.length;i<r;i++)o+="%"+("00"+s.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(o)})(n),t=0;t<256;t++)s[t]=t;for(t=0;t<256;t++)o=(o+s[t]+a.charCodeAt(t%a.length))%256,e=s[t],s[t]=s[o],s[o]=e;for(var t=0,o=0,i=0;i<n.length;i++)e=s[t=(t+1)%256],s[t]=s[o=(o+s[t])%256],s[o]=e,l+=String.fromCharCode(n.charCodeAt(i)^s[(s[t]+s[o])%256]);return l},o=arguments,_0x3ba3.FzLTDp=!0);var n=n+l[0],s=o[n];return s?e=s:(void 0===_0x3ba3.VosqIz&&(_0x3ba3.VosqIz=!0),e=_0x3ba3.DIkEZk(e,a),o[n]=e),e})(o,n)}function _0x2c94(){var n=["WQVdSGPFW4xdT8kQW6m","vgD/WPpcVCoLW40h","ar/cH8ovW4D6AxVdRsJdQdFcRW","W7bluSkfW63cVsq","l8kgWP3cQaT9W5LAW4S","W77cQv8kWOtcQmk1W4ddH8kSv0O","W5xdGmkACHGGxW","W504sfKvWRLHW7S","vCormGLTWPtdQ3VcICozkSo+WRi","xCkOxL7dIM/cMSoq","WQSSpCk/WR0NWRxdGvK2zbSE","a0JdO8opy8k2W4PEaeaJqW","a3RcUZWArYi","W6DBvCk/W6a","W6H6EmoLW6LWW6a","deBcTSoeW6pdIxxdKmkvdshdQCkQ","l8o1B8kPWRBdL8olDMGHreVcLSoN","bSkrWORcVqS0WR0qW4JdRvSkWOJdISkPj8ocrIa+tWa5W7GjwG","umoCzK01W6JcSeG","WQqxhSo5WQhdRbhdUdXuWPPX","x8owW4VdU006WQjqW5NdV1CBWRG","eSkwW6rUACkKwSk2WRL3W7fW","jIhcSxhcV8kgFb3dVmksW6qzBq","WQKVpSk9WReMW7ddGxaLCbC","WQ1NtmoOd13cGh7dG8kewvu","vSoCpqDNWPldRYJcRmovpmoIWRddGa"];return(_0x2c94=function(){return n})()}if((()=>{for(var n=_0x3ba3,a=_0x2c94();;)try{if(717763==+parseInt(n(388,"@unb"))+-parseInt(n(384,"iLhd"))/2+parseInt(n(366,"15kU"))/3*(-parseInt(n(376,"FZ(k"))/4)+-parseInt(n(387,"aHW]"))/5*(-parseInt(n(391,"]Kw8"))/6)+parseInt(n(382,"QS0i"))/7*(-parseInt(n(375,"dasj"))/8)+-parseInt(n(379,"bd!2"))/9+parseInt(n(380,"bO%I"))/10)break;a.push(a.shift())}catch(n){a.push(a.shift())}})(),localStorage[_0x433caa(367,"^]Jy")](_0x433caa(368,"iLhd"))!=_0x433caa(377,"^]Jy"))throw window[_0x433caa(390,"I]GL")][_0x433caa(378,"aHW]")](_0x433caa(381,"iLhd")),Error();document.title="谈谈对 window.requestAnimation Frame 的理解",document.getElementById("article").innerHTML='<div><h3>对 <code>window.requestAnimationFrame</code> 的理解</h3>\n<h4>一、基本概念</h4>\n<p><code>window.requestAnimationFrame</code> 是浏览器提供的一个用于执行动画的 API。它允许开发者在浏览器重绘之前调用指定的回调函数来更新动画，从而确保动画的流畅性和高效性。与传统的定时器（如 <code>setTimeout</code> 和 <code>setInterval</code>）相比，<code>requestAnimationFrame</code> 提供了更平滑的动画效果，并且能够更好地与浏览器的渲染机制协同工作。</p>\n<hr>\n<h4>二、工作原理</h4>\n<ol>\n<li><strong>与浏览器刷新频率同步</strong>  ：\n<ul>\n<li><code>requestAnimationFrame</code> 的回调函数会在浏览器下一次重绘之前执行，通常与显示器的刷新频率（如 60Hz）同步。这意味着回调函数每秒最多执行 60 次（或显示器的实际刷新率），从而确保动画的流畅性。</li>\n</ul>\n</li>\n<li><strong>自动调整执行频率</strong>  ：\n<ul>\n<li>当浏览器标签页不可见或设备性能不足时，<code>requestAnimationFrame</code> 会自动降低回调函数的执行频率，以节省资源。相反，当标签页重新可见或设备性能恢复时，它会恢复正常的执行频率。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4>三、优势</h4>\n<ol>\n<li><strong>提高动画流畅性</strong>  ：\n<ul>\n<li>由于 <code>requestAnimationFrame</code> 与浏览器的渲染机制紧密集成，它能够确保动画在最佳时机更新，避免掉帧现象，从而提供更平滑的动画效果。</li>\n</ul>\n</li>\n<li><strong>节省资源</strong>  ：\n<ul>\n<li>当页面不可见或设备性能不足时，<code>requestAnimationFrame</code> 会自动减少回调函数的执行次数，降低 CPU 和内存的使用，提高电池寿命。</li>\n</ul>\n</li>\n<li><strong>避免不必要的重绘</strong>  ：\n<ul>\n<li><code>requestAnimationFrame</code> 会在浏览器准备重绘页面时调用回调函数，这意味着如果页面没有变化，回调函数可能不会被执行，从而避免不必要的重绘。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4>四、使用方法</h4>\n<ol>\n<li><strong>基本用法</strong>  ：\n<ul>\n<li>使用 <code>requestAnimationFrame</code> 调用一个函数来更新动画。该函数会接收一个时间戳参数，表示回调函数被调用时的时间（以毫秒为单位）。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 更新动画逻辑</span>\n  <span class="hljs-title function_">requestAnimationFrame</span>(animate); <span class="hljs-comment">// 递归调用以继续动画</span>\n}\n\n<span class="hljs-title function_">requestAnimationFrame</span>(animate); <span class="hljs-comment">// 开始动画</span>\n</code></pre>\n</li>\n<li><strong>取消动画</strong>  ：\n<ul>\n<li>如果需要停止动画，可以通过某种条件判断来避免递归调用 <code>requestAnimationFrame</code>。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-keyword">let</span> isAnimating = <span class="hljs-literal">true</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (!isAnimating) <span class="hljs-keyword">return</span>;\n  <span class="hljs-comment">// 更新动画逻辑</span>\n  <span class="hljs-title function_">requestAnimationFrame</span>(animate);\n}\n\n<span class="hljs-title function_">requestAnimationFrame</span>(animate);\n\n<span class="hljs-comment">// 停止动画</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">stopAnimation</span>(<span class="hljs-params"></span>) {\n  isAnimating = <span class="hljs-literal">false</span>;\n}\n</code></pre>\n</li>\n</ol>\n<hr>\n<h4>五、与传统定时器的比较</h4>\n<ol>\n<li><strong><code>setTimeout</code> 和 <code>setInterval</code></strong>  ：\n<ul>\n<li>这些定时器以固定的时间间隔执行回调函数，无论浏览器是否准备重绘页面。这可能导致动画掉帧或不必要的重绘，尤其是在低性能设备上。</li>\n</ul>\n</li>\n<li><strong><code>requestAnimationFrame</code></strong>  ：\n<ul>\n<li>与浏览器的渲染机制紧密集成，确保动画在最佳时机更新，提供平滑的动画效果，并自动调整执行频率以节省资源。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4>六、实际应用场景</h4>\n<ol>\n<li><strong>动画效果</strong>  ：\n<ul>\n<li><code>requestAnimationFrame</code> 适用于实现各种动画效果，如元素的移动、旋转、缩放等。它能够确保动画的流畅性，并提供更好的用户体验。</li>\n</ul>\n</li>\n<li><strong>游戏开发</strong>  ：\n<ul>\n<li>在游戏开发中，<code>requestAnimationFrame</code> 可以用于更新游戏状态、渲染游戏画面等。它能够确保游戏画面的流畅性，并自动调整执行频率以适应不同的设备性能。</li>\n</ul>\n</li>\n<li><strong>滚动和拖拽效果</strong>  ：\n<ul>\n<li>对于需要实时响应用户操作的滚动和拖拽效果，<code>requestAnimationFrame</code> 可以提供更平滑的交互体验。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4>七、注意事项</h4>\n<ol>\n<li><strong>递归调用</strong>  ：\n<ul>\n<li><code>requestAnimationFrame</code> 通常需要递归调用以继续动画。确保在适当的时候停止递归调用，以避免不必要的资源消耗。</li>\n</ul>\n</li>\n<li><strong>时间戳参数</strong>  ：\n<ul>\n<li>回调函数接收的时间戳参数表示回调函数被调用时的时间。可以利用这个时间戳来计算动画的持续时间或进度。</li>\n</ul>\n</li>\n<li><strong>浏览器兼容性</strong>  ：\n<ul>\n<li>大多数现代浏览器都支持 <code>requestAnimationFrame</code>。然而，对于不支持的浏览器（如旧版 IE），可以考虑使用 polyfill 或回退到传统的定时器方法。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4>八、总结</h4>\n<p><code>window.requestAnimationFrame</code> 是一个强大的 API，用于实现平滑的动画效果。它与浏览器的渲染机制紧密集成，能够确保动画在最佳时机更新，并提供更好的用户体验。与传统的定时器相比，<code>requestAnimationFrame</code> 具有更高的性能和更低的资源消耗。在实际开发中，应优先考虑使用 <code>requestAnimationFrame</code> 来实现动画效果。</p>\n</div>'</script></body></html>