<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4fd34c=_0x286e;function _0x286e(t,s){var e=_0x2fec();return(_0x286e=function(s,n){var a=e[s-=232];void 0===_0x286e.SWmmMp&&(_0x286e.LySAkG=function(s,n){var a,l=[],t=0,e="";for(s=(s=>{for(var n,a,l="",t="",e=0,r=0;a=s.charAt(r++);~a&&(n=e%4?64*n+a:a,e++%4)&&(l+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=l.length;o<c;o++)t+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(t)})(s),r=0;r<256;r++)l[r]=r;for(r=0;r<256;r++)t=(t+l[r]+n.charCodeAt(r%n.length))%256,a=l[r],l[r]=l[t],l[t]=a;for(var r=0,t=0,o=0;o<s.length;o++)a=l[r=(r+1)%256],l[r]=l[t=(t+l[r])%256],l[t]=a,e+=String.fromCharCode(s.charCodeAt(o)^l[(l[r]+l[t])%256]);return e},t=arguments,_0x286e.SWmmMp=!0);var s=s+e[0],l=t[s];return l?a=l:(void 0===_0x286e.jPetTB&&(_0x286e.jPetTB=!0),a=_0x286e.LySAkG(a,n),t[s]=a),a})(t,s)}function _0x2fec(){var s=["wCo6W44JW5pdOX/dUSoj","W47cUSkjWQVdNmkZWPe","dCoPoSkTcSkEW5pcTmoJW5GSWRJcSmojDSkHWRjFos52xweBnxW","W7OxWRJcMmkJ","W5xdPwNcLKGFlLfAW6yLW6pdKq","WRRdQtCMAGOd","v8kUECoTs8kuW4/dJSoYW5KjWPxcUG","WO7cUCo4W5dcM0/cPCkCnG","W47cPSkzisdcI8k5FmoMyWhcLaddGG","lCkOWPvWWPddGX7dNmojCmoB","W5bjWPjkwmkhx8kRiKjxWO3cSq","smoHW6VdTmkPnCkhWOBdPa","WPZcNLRdUMpdUZNcNSo0CtVcU0S","D1tcLCkbEe97W4W2","E8kyE8ojWP5BW6ugjftdKcq5jq","AIJdTh7dPd3cUmkkWQ5jWORdSCoU","kqj+W6izv8osfI1kqsC","WQldTCkom8owWQ/cSSk0rxxcHq","zSkoW6bCzCkCcgzgW5PBWOZcGa","zSoWWOWhomokEG","k8kUWPrXWPxcP2xdUSocE8obW5bD","W7ZcPJ7dM8obCJJcRq","WOFcSctdPGXcDa","kNRcSclcTwRdQq","WQpdUgtcISkfkH/cLXFcJ8oIfa","WOZdVSknpmkAWPlcJG"];return(_0x2fec=function(){return s})()}if((()=>{for(var s=_0x286e,n=_0x2fec();;)try{if(787347==-parseInt(s(257,"ru!)"))*(-parseInt(s(234,"agfU"))/2)+parseInt(s(253,"v%eh"))/3+parseInt(s(254,"GKZ8"))/4*(parseInt(s(232,"gMoG"))/5)+-parseInt(s(233,"agfU"))/6+-parseInt(s(245,"scVM"))/7*(-parseInt(s(246,")Ij1"))/8)+parseInt(s(249,"j@2J"))/9+parseInt(s(248,"MD)t"))/10*(-parseInt(s(251,"q0qy"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x4fd34c(237,"scVM")](_0x4fd34c(241,"83XK"))!=_0x4fd34c(244,"wP5i"))throw window[_0x4fd34c(236,"E0Y9")][_0x4fd34c(238,"0pG0")](_0x4fd34c(243,"!eIA")),Error();document.title="不同标签页和窗口之间通信",document.getElementById("article").innerHTML='<div><p>在不同标签页或窗口间实现<strong>主动推送消息机制</strong>  的方式有多种，主要依赖于浏览器的特性和技术。以下是几种常见的方法及其特点：</p>\n<hr>\n<h3><strong>1. 使用 <code>localStorage</code> 和 <code>storage</code> 事件</strong></h3>\n<h4><strong>原理</strong></h4>\n<ul>\n<li><code>localStorage</code> 是浏览器提供的持久化存储机制。</li>\n<li>当一个标签页或窗口修改了 <code>localStorage</code> 中的数据时，其他标签页或窗口会触发 <code>storage</code> 事件。</li>\n</ul>\n<h4><strong>实现步骤</strong></h4>\n<ol>\n<li><strong>写入数据</strong>  ：在一个标签页中修改 <code>localStorage</code>。</li>\n<li><strong>监听事件</strong>  ：在其他标签页中监听 <code>storage</code> 事件，获取修改后的数据。</li>\n</ol>\n<h4><strong>示例代码</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 写入数据</span>\n<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-string">&#x27;Hello, other tab!&#x27;</span>);\n\n<span class="hljs-comment">// 监听事件</span>\n<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;storage&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">key</span> === <span class="hljs-string">&#x27;message&#x27;</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received message:&#x27;</span>, event.<span class="hljs-property">newValue</span>);\n  }\n});\n</code></pre>\n<h4><strong>优点</strong></h4>\n<ul>\n<li>简单易用，无需额外服务器支持。</li>\n<li>跨标签页通信直接。</li>\n</ul>\n<h4><strong>缺点</strong></h4>\n<ul>\n<li>仅在同源（same origin）的页面间有效。</li>\n<li>数据存储有限制（通常 5-10MB）。</li>\n<li>不适合频繁或大量的数据传输。</li>\n</ul>\n<hr>\n<h3><strong>2. 使用 <code>BroadcastChannel</code> API</strong></h3>\n<h4><strong>原理</strong></h4>\n<ul>\n<li><code>BroadcastChannel</code> 允许同源的不同浏览上下文（如标签页、窗口、iframe）进行双向通信。</li>\n</ul>\n<h4><strong>实现步骤</strong></h4>\n<ol>\n<li><strong>创建频道</strong>  ：在所有需要通信的标签页中创建同一个频道的 <code>BroadcastChannel</code> 实例。</li>\n<li><strong>发送消息</strong>  ：在一个标签页中通过频道发送消息。</li>\n<li><strong>接收消息</strong>  ：在其他标签页中监听频道的消息事件。</li>\n</ol>\n<h4><strong>示例代码</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 创建频道</span>\n<span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BroadcastChannel</span>(<span class="hljs-string">&#x27;my_channel&#x27;</span>);\n\n<span class="hljs-comment">// 发送消息</span>\nchannel.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Hello, other tab!&#x27;</span> });\n\n<span class="hljs-comment">// 接收消息</span>\nchannel.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received message:&#x27;</span>, event.<span class="hljs-property">data</span>);\n};\n</code></pre>\n<h4><strong>优点</strong></h4>\n<ul>\n<li>简单易用，API 设计直观。</li>\n<li>支持双向通信。</li>\n<li>无需轮询，实时性高。</li>\n</ul>\n<h4><strong>缺点</strong></h4>\n<ul>\n<li>仅在同源的页面间有效。</li>\n<li>浏览器支持可能有限（但现代浏览器普遍支持）。</li>\n</ul>\n<hr>\n<h3><strong>3. 使用 Service Worker</strong></h3>\n<h4><strong>原理</strong></h4>\n<ul>\n<li>Service Worker 是运行在浏览器后台的脚本，可以拦截和处理网络请求，也可以用于实现跨标签页的通信。</li>\n<li>通过 <code>postMessage</code> 方法，页面可以与 Service Worker 通信，Service Worker 也可以向所有连接的页面广播消息。</li>\n</ul>\n<h4><strong>实现步骤</strong></h4>\n<ol>\n<li><strong>注册 Service Worker</strong>  ：在页面加载时注册 Service Worker。</li>\n<li><strong>与 Service Worker 通信</strong>  ：页面通过 <code>navigator.serviceWorker.controller.postMessage</code> 发送消息。</li>\n<li><strong>Service Worker 广播消息</strong>  ：Service Worker 监听消息，并通过 <code>clients.matchAll</code> 向所有连接的页面广播消息。</li>\n</ol>\n<h4><strong>示例代码</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 页面代码</span>\nnavigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;/service-worker.js&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {\n  navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-property">controller</span>.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Hello, other tab!&#x27;</span> });\n});\n\nnavigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received message from SW:&#x27;</span>, event.<span class="hljs-property">data</span>);\n});\n\n<span class="hljs-comment">// Service Worker 代码（service-worker.js）</span>\nself.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  self.<span class="hljs-property">clients</span>.<span class="hljs-title function_">matchAll</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">clients</span>) =&gt;</span> {\n    clients.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">client</span>) =&gt;</span> {\n      client.<span class="hljs-title function_">postMessage</span>(event.<span class="hljs-property">data</span>);\n    });\n  });\n});\n</code></pre>\n<h4><strong>优点</strong></h4>\n<ul>\n<li>支持复杂的后台处理逻辑。</li>\n<li>可以实现离线功能和消息缓存。</li>\n<li>跨标签页通信能力强。</li>\n</ul>\n<h4><strong>缺点</strong></h4>\n<ul>\n<li>实现相对复杂。</li>\n<li>需要处理 Service Worker 的生命周期和更新问题。</li>\n</ul>\n<hr>\n<h3><strong>4. 使用 WebSocket 或 Server-Sent Events (SSE)</strong></h3>\n<h4><strong>原理</strong></h4>\n<ul>\n<li>WebSocket 和 SSE 都是服务器向客户端推送消息的技术。</li>\n<li>通过建立与服务器的持久连接，服务器可以主动向所有连接的客户端（包括不同标签页或窗口）推送消息。</li>\n</ul>\n<h4><strong>实现步骤</strong></h4>\n<ol>\n<li><strong>建立连接</strong>  ：在每个标签页中建立与服务器的 WebSocket 或 SSE 连接。</li>\n<li><strong>服务器推送消息</strong>  ：服务器向所有连接的客户端推送消息。</li>\n<li><strong>接收消息</strong>  ：客户端监听消息事件，处理接收到的消息。</li>\n</ol>\n<h4><strong>WebSocket 示例代码</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 客户端代码</span>\n<span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;wss://example.com/socket&#x27;</span>);\n\nsocket.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received message:&#x27;</span>, event.<span class="hljs-property">data</span>);\n};\n\n<span class="hljs-comment">// 服务器代码（Node.js 示例）</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">WebSocket</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ws&#x27;</span>);\n<span class="hljs-keyword">const</span> wss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>.<span class="hljs-title class_">Server</span>({ <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span> });\n\nwss.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">ws</span>) =&gt;</span> {\n  ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> {\n    wss.<span class="hljs-property">clients</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">client</span>) =&gt;</span> {\n      <span class="hljs-keyword">if</span> (client.<span class="hljs-property">readyState</span> === <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">OPEN</span>) {\n        client.<span class="hljs-title function_">send</span>(message);\n      }\n    });\n  });\n});\n</code></pre>\n<h4><strong>优点</strong></h4>\n<ul>\n<li>支持实时性高的通信需求。</li>\n<li>可以跨域（需要服务器支持 CORS）。</li>\n<li>适用于需要服务器主动推送消息的场景。</li>\n</ul>\n<h4><strong>缺点</strong></h4>\n<ul>\n<li>需要服务器支持。</li>\n<li>实现相对复杂，需要处理连接管理和消息路由。</li>\n</ul>\n<hr>\n<h3><strong>5. 使用 SharedWorker</strong></h3>\n<h4><strong>原理</strong></h4>\n<ul>\n<li><code>SharedWorker</code> 允许多个浏览上下文（如标签页、窗口）共享同一个 Web Worker 实例。</li>\n<li>通过 <code>SharedWorker</code>，不同标签页可以共享数据和通信。</li>\n</ul>\n<h4><strong>实现步骤</strong></h4>\n<ol>\n<li><strong>创建 SharedWorker</strong>  ：在所有需要通信的标签页中创建同一个 <code>SharedWorker</code> 实例。</li>\n<li><strong>与 SharedWorker 通信</strong>  ：通过 <code>port</code> 对象发送和接收消息。</li>\n</ol>\n<h4><strong>示例代码</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 页面代码</span>\n<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedWorker</span>(<span class="hljs-string">&#x27;/shared-worker.js&#x27;</span>);\n\nworker.<span class="hljs-property">port</span>.<span class="hljs-title function_">start</span>();\n\nworker.<span class="hljs-property">port</span>.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Hello, other tab!&#x27;</span> });\n\nworker.<span class="hljs-property">port</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received message from SW:&#x27;</span>, event.<span class="hljs-property">data</span>);\n};\n\n<span class="hljs-comment">// SharedWorker 代码（shared-worker.js）</span>\nonconnect = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> port = e.<span class="hljs-property">ports</span>[<span class="hljs-number">0</span>];\n\n  port.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n    port.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">`Echo: <span class="hljs-subst">${event.data.text}</span>`</span>);\n  };\n};\n</code></pre>\n<h4><strong>优点</strong></h4>\n<ul>\n<li>支持共享数据和计算资源。</li>\n<li>适用于需要共享状态的场景。</li>\n</ul>\n<h4><strong>缺点</strong></h4>\n<ul>\n<li>实现相对复杂。</li>\n<li>浏览器支持可能有限。</li>\n</ul>\n<hr>\n<h3><strong>总结与推荐</strong></h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>实时性</th>\n<th>复杂度</th>\n<th>浏览器支持</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>localStorage</code> + <code>storage</code> 事件</td>\n<td>高</td>\n<td>低</td>\n<td>广泛</td>\n<td>简单的跨标签页通信</td>\n</tr>\n<tr>\n<td><code>BroadcastChannel</code></td>\n<td>高</td>\n<td>低</td>\n<td>现代浏览器</td>\n<td>同源标签页间的实时通信</td>\n</tr>\n<tr>\n<td>Service Worker</td>\n<td>高</td>\n<td>中</td>\n<td>现代浏览器</td>\n<td>复杂的后台处理和跨标签页通信</td>\n</tr>\n<tr>\n<td>WebSocket / SSE</td>\n<td>高</td>\n<td>高</td>\n<td>广泛</td>\n<td>需要服务器主动推送消息的场景</td>\n</tr>\n<tr>\n<td><code>SharedWorker</code></td>\n<td>中</td>\n<td>中</td>\n<td>有限</td>\n<td>需要共享状态和计算资源的场景</td>\n</tr>\n</tbody>\n</table>\n<p><strong>推荐</strong>  ：</p>\n<ul>\n<li>如果只需要简单的同源标签页通信，<strong><code>BroadcastChannel</code></strong>   是最佳选择。</li>\n<li>如果需要更复杂的后台处理或离线支持，<strong>Service Worker</strong>   是更好的选择。</li>\n<li>如果需要服务器主动推送消息，<strong>WebSocket</strong>   或 <strong>SSE</strong>   是必要的。</li>\n</ul>\n<p>根据具体需求和场景，选择合适的方法实现跨标签页或窗口间的主动推送消息机制。</p>\n</div>'</script></body></html>