<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0xdff0(){var n=["WRxdULuyW74WW4hcUq","WP5WDCo0wCoQWPxcUXq","W4pdTmolW4PcW48TsutdI8klh8og","WORcJCoPh8ktzSkgsCkebKi","W4FcHxGTW5JdH8k5W57cMSk1msm6","pNWOW4FcSa","WPtdHGpcSCohWPddSxRdGxu","omoEySkzWRFdN8o7WQrfua5xW40","WPlcQY7cUchcRWhcQeSyW5FdJY8","WOTdE0OvW5lcQvfAWOC","nmoGjIZcSSkPqCkxWOLzqxldUW","W5qeu8k+ohhcNW","zCotcNBdVmohgSoiecddMs/dQ8o6hGLKpdJdVwrYW49cW7xdJG","WPZdLmojWONdR8oAW6bvnt7dPsKL","W5Pqd8o9jLdcV8oWW555","emobWOFcUupdGx5Id0ZcJW","k3VcOtnSW5xcImoe","W5n5sCkkW7pcKCoF","y8oLW6ZcQmo5WPbH","WP3dHGdcTSofWP7dRw3dPxG","DshdRgnEyCkR","qSoQxX3dRXunACkJWOpcOCoHW6C","WQzzW5lcM37cL1y","WP4Gl8oIwCohWP8","pmkustdcUSonbmknkYZdOdZdVq","favnWR5iWPdcJbBdHq","WOLeWRrsWOurcCk8","W7SxkrSIW6NcT0zq","WP/dNSolWOZdR8oDW6zAoHJdUduV","W5i7dSoIWO/dSCkIkXJdMr/dMmkg","WPxcGSktW5hcM8kSWOK","msFdSN9NzCkN"];return(_0xdff0=function(){return n})()}var _0x37bc8d=_0x3615;function _0x3615(r,n){var o=_0xdff0();return(_0x3615=function(n,s){var t=o[n-=117];void 0===_0x3615.RFtuWl&&(_0x3615.MdIBdL=function(n,s){var t,a=[],r=0,o="";for(n=(n=>{for(var s,t,a="",r="",o=0,l=0;t=n.charAt(l++);~t&&(s=o%4?64*s+t:t,o++%4)&&(a+=String.fromCharCode(255&s>>(-2*o&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var e=0,c=a.length;e<c;e++)r+="%"+("00"+a.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(r)})(n),l=0;l<256;l++)a[l]=l;for(l=0;l<256;l++)r=(r+a[l]+s.charCodeAt(l%s.length))%256,t=a[l],a[l]=a[r],a[r]=t;for(var l=0,r=0,e=0;e<n.length;e++)t=a[l=(l+1)%256],a[l]=a[r=(r+a[l])%256],a[r]=t,o+=String.fromCharCode(n.charCodeAt(e)^a[(a[l]+a[r])%256]);return o},r=arguments,_0x3615.RFtuWl=!0);var n=n+o[0],a=r[n];return a?t=a:(void 0===_0x3615.zHVjuS&&(_0x3615.zHVjuS=!0),t=_0x3615.MdIBdL(t,s),r[n]=t),t})(r,n)}if((()=>{for(var n=_0x3615,s=_0xdff0();;)try{if(518978==-parseInt(n(128,"heES"))*(parseInt(n(136,"G0Na"))/2)+parseInt(n(126,"sqBc"))/3*(parseInt(n(135,"CrT*"))/4)+parseInt(n(117,"wjC@"))/5*(-parseInt(n(124,"b]GL"))/6)+-parseInt(n(140,"N]xL"))/7+parseInt(n(118,"heES"))/8*(parseInt(n(129,"s4f)"))/9)+-parseInt(n(121,"a7wo"))/10*(parseInt(n(123,"N]xL"))/11)+parseInt(n(130,"1O]M"))/12*(parseInt(n(146,"nU@O"))/13))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x37bc8d(145,"1n(j")](_0x37bc8d(122,"G0Na"))!=_0x37bc8d(132,"rt]V"))throw window[_0x37bc8d(143,"I$qj")][_0x37bc8d(147,"sqBc")](_0x37bc8d(139,"Cf60")),Error();document.title="设计一套全站请求耗时统计工具",document.getElementById("article").innerHTML='<div><p>设计一套全站请求耗时统计工具，可以帮助前端开发者监控和分析页面请求的性能，从而优化用户体验。以下是设计这样一套工具的详细步骤和考虑因素：</p>\n<hr>\n<h3><strong>一、设计目标</strong></h3>\n<ol>\n<li><strong>全面监控</strong>  ：统计全站所有HTTP请求的耗时。</li>\n<li><strong>实时反馈</strong>  ：实时展示请求耗时数据，便于及时发现问题。</li>\n<li><strong>易于集成</strong>  ：方便与现有前端项目集成，无需大量修改代码。</li>\n<li><strong>数据分析</strong>  ：提供数据分析和可视化功能，帮助开发者定位性能瓶颈。</li>\n</ol>\n<hr>\n<h3><strong>二、工具设计</strong></h3>\n<h4><strong>1. 拦截HTTP请求</strong></h4>\n<ul>\n<li><strong>使用Fetch/XHR拦截器</strong>  ：\n<ul>\n<li>对于现代浏览器，可以使用<code>fetch</code> API的拦截器库（如<code>ky</code>、<code>fetch-intercept</code>）或<code>XMLHttpRequest</code>的封装。</li>\n<li>对于Axios等HTTP库，可以利用其提供的拦截器功能。</li>\n</ul>\n</li>\n<li><strong>示例代码（使用Fetch拦截器）</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">import</span> fetchIntercept <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fetch-intercept&#x27;</span>;\n\n<span class="hljs-keyword">const</span> unregister = fetchIntercept.<span class="hljs-title function_">register</span>({\n  <span class="hljs-attr">request</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">url, config</span>) {\n    config.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;X-Request-Start&#x27;</span>] = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();\n    <span class="hljs-keyword">return</span> [url, config];\n  },\n  <span class="hljs-attr">response</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) {\n    <span class="hljs-keyword">const</span> startTime = response.<span class="hljs-property">config</span>?.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;X-Request-Start&#x27;</span>];\n    <span class="hljs-keyword">if</span> (startTime) {\n      <span class="hljs-keyword">const</span> endTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();\n      <span class="hljs-keyword">const</span> duration = endTime - startTime;\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Request to <span class="hljs-subst">${response.url}</span> took <span class="hljs-subst">${duration}</span>ms`</span>);\n      <span class="hljs-comment">// 将耗时数据发送到统计服务</span>\n      <span class="hljs-title function_">sendDurationToAnalytics</span>(response.<span class="hljs-property">url</span>, duration);\n    }\n    <span class="hljs-keyword">return</span> response;\n  },\n});\n\n<span class="hljs-comment">// 在应用结束时注销拦截器</span>\n<span class="hljs-comment">// unregister();</span>\n</code></pre>\n</li>\n</ul>\n<h4><strong>2. 记录请求耗时</strong></h4>\n<ul>\n<li><strong>计算耗时</strong>  ：在请求发出时记录开始时间，在响应返回时计算耗时。</li>\n<li><strong>存储数据</strong>  ：将请求URL、耗时、状态码等信息存储到内存或发送到后端服务。</li>\n</ul>\n<h4><strong>3. 数据上报</strong></h4>\n<ul>\n<li><strong>实时上报</strong>  ：每次请求完成后，立即将耗时数据发送到后端统计服务。</li>\n<li><strong>批量上报</strong>  ：将多个请求的耗时数据收集起来，定期批量上报，减少网络请求次数。</li>\n<li><strong>示例代码（实时上报）</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendDurationToAnalytics</span>(<span class="hljs-params">url, duration</span>) {\n  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://your-analytics-service.com/api/report&#x27;</span>, {\n    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,\n    <span class="hljs-attr">headers</span>: {\n      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,\n    },\n    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ url, duration, <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() }),\n  });\n}\n</code></pre>\n</li>\n</ul>\n<h4><strong>4. 数据存储与分析</strong></h4>\n<ul>\n<li><strong>后端存储</strong>  ：在后端使用数据库（如MySQL、MongoDB）存储请求耗时数据。</li>\n<li><strong>数据分析</strong>  ：对收集到的数据进行分析，生成统计报表和可视化图表。</li>\n<li><strong>可视化工具</strong>  ：使用图表库（如Chart.js、ECharts）展示请求耗时分布、平均耗时、最大耗时等。</li>\n</ul>\n<hr>\n<h3><strong>三、功能扩展</strong></h3>\n<h4><strong>1. 错误监控</strong></h4>\n<ul>\n<li><strong>捕获错误</strong>  ：在拦截器中捕获请求错误（如网络错误、超时），并记录错误信息。</li>\n<li><strong>错误上报</strong>  ：将错误信息上报到后端，便于分析和定位问题。</li>\n</ul>\n<h4><strong>2. 性能指标</strong></h4>\n<ul>\n<li><strong>计算性能指标</strong>  ：如首屏加载时间、页面完全加载时间等。</li>\n<li><strong>关联分析</strong>  ：将请求耗时与性能指标关联，分析请求对整体性能的影响。</li>\n</ul>\n<h4><strong>3. 用户行为分析</strong></h4>\n<ul>\n<li><strong>关联用户行为</strong>  ：记录用户操作（如点击、输入）与请求耗时的关系，分析用户行为对性能的影响。</li>\n<li><strong>个性化优化</strong>  ：根据用户行为数据，提供个性化的性能优化建议。</li>\n</ul>\n<hr>\n<h3><strong>四、实现细节</strong></h3>\n<h4><strong>1. 跨浏览器兼容性</strong></h4>\n<ul>\n<li><strong>支持多种浏览器</strong>  ：确保工具在不同浏览器（如Chrome、Firefox、Safari）中都能正常工作。</li>\n<li><strong>Polyfill</strong>  ：对于不支持某些API的浏览器，使用Polyfill或降级方案。</li>\n</ul>\n<h4><strong>2. 性能开销</strong></h4>\n<ul>\n<li><strong>最小化开销</strong>  ：确保拦截器和数据上报逻辑对页面性能的影响最小化。</li>\n<li><strong>异步处理</strong>  ：使用异步操作（如<code>Promise</code>、<code>async/await</code>）避免阻塞主线程。</li>\n</ul>\n<h4><strong>3. 安全性</strong></h4>\n<ul>\n<li><strong>数据加密</strong>  ：在数据上报时，对敏感信息进行加密处理。</li>\n<li><strong>防止滥用</strong>  ：设置上报频率限制，防止恶意用户滥用上报接口。</li>\n</ul>\n<hr>\n<h3><strong>五、示例架构图</strong></h3>\n<pre><code>+-----------------+        +-----------------+        +-----------------+\n|   Frontend App  | -----&gt; |  Interceptor    | -----&gt; | Analytics Service|\n| (Browser/Node)  |        | (Fetch/XHR)     |        | (Backend API)    |\n+-----------------+        +-----------------+        +-----------------+\n         |                          |                          |\n         |  Request/Response        |  Collect Duration        |  Store &amp; Analyze\n         |                          |                          |\n         +--------------------------+--------------------------+\n                                    |\n                                    |  Report Data\n                                    |\n                                    v\n                              +-----------------+\n                              |  Database       |\n                              | (MySQL/MongoDB) |\n                              +-----------------+\n</code></pre>\n<hr>\n<h3><strong>六、总结</strong></h3>\n<p>设计一套全站请求耗时统计工具需要综合考虑拦截HTTP请求、记录耗时、数据上报、存储与分析等多个方面。通过合理的架构设计和实现细节处理，可以构建出一套高效、易用的性能监控工具，帮助开发者及时发现和解决性能问题，提升用户体验。</p>\n</div>'</script></body></html>