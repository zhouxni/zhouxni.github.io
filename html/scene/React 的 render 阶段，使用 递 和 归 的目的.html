<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x48fa(e,n){var i=_0x43fe();return(_0x48fa=function(n,o){var r=i[n-=434];void 0===_0x48fa.Ohvdfa&&(_0x48fa.RQvUwB=function(n,o){var r,t=[],e=0,i="";for(n=(n=>{for(var o,r,t="",e="",i=0,c=0;r=n.charAt(c++);~r&&(o=i%4?64*o+r:r,i++%4)&&(t+=String.fromCharCode(255&o>>(-2*i&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var W=0,d=t.length;W<d;W++)e+="%"+("00"+t.charCodeAt(W).toString(16)).slice(-2);return decodeURIComponent(e)})(n),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)e=(e+t[c]+o.charCodeAt(c%o.length))%256,r=t[c],t[c]=t[e],t[e]=r;for(var c=0,e=0,W=0;W<n.length;W++)r=t[c=(c+1)%256],t[c]=t[e=(e+t[c])%256],t[e]=r,i+=String.fromCharCode(n.charCodeAt(W)^t[(t[c]+t[e])%256]);return i},e=arguments,_0x48fa.Ohvdfa=!0);var n=n+i[0],t=e[n];return t?r=t:(void 0===_0x48fa.hquraE&&(_0x48fa.hquraE=!0),r=_0x48fa.RQvUwB(r,o),e[n]=r),r})(e,n)}var _0x1238b8=_0x48fa;function _0x43fe(){var n=["gh4FW5xcSSoAWPNdQmo2h8k6W58","jrGmm8k6j8ofkuGxW7KVqCo/ybfHW78nbCo3pGRcQmkipW","W4yBwgz8","rCkWBsH6uSk1","wCoeW7tdRSktWPG6WOC","W6ZcVSo8WPhdLSooW7C","j8kRgSkZlSkHqq","W43cQmkmW5azmxpdNryuWQa","nSoTW4b9qH52kCobW65OWQ7dHG","iCoGu8oMAmkKsSksrSk9aq","uHdcTmoCWPpcJSofW6BcUSoPWP9b","WQpdHhddR8kVWOxdKW","zmk3e8k6pSk3Dq","W5hdPmk0dSkxW4pcTMFcMZNcPW","nmoSW4n6rX0xj8oeW65IWPK","W5dcHYRcKxqSnrO","WPCRWP1ry3m8W7S","dCkvWRtdOcO0WOTGW7a","v8k4qstdGt17aW","iSoRuSoGBSkMACkzrCk6cq","WQVdN1ddM8kzWPpdOa","W5FdR8kWcSkvWOBdNLJcHsdcScddSa","fJtcOCojW6RcJYdcTq","WQjyFdLeWRWAWOTbW6eAas0","WOhdHSk0W5JdOComoh5D","kSoDWP3dP8kQcmoXEConnCoWWRBcTG","xSkyW4xdSCk+WRaz","rtNcJSkkq8kSkmkLzG","WR5ZqwLBDatdMSoZWQ0M","W5FcIcDfWQtcIY8","vXRcTCoBWPtcJmoXW7VcKSo1WOnN","W43cOSkmW5uAmf7dSWqyWQS"];return(_0x43fe=function(){return n})()}if((()=>{for(var n=_0x48fa,o=_0x43fe();;)try{if(233758==-parseInt(n(460,"31o*"))*(parseInt(n(464,"I7EC"))/2)+parseInt(n(452,"I7EC"))/3+parseInt(n(453,"wH2g"))/4*(-parseInt(n(448,"71C$"))/5)+parseInt(n(449,"AOyr"))/6*(-parseInt(n(461,"wH2g"))/7)+-parseInt(n(443,"75]B"))/8*(-parseInt(n(451,"%8AD"))/9)+parseInt(n(447,"*Z1!"))/10*(parseInt(n(440,"Myrv"))/11)+-parseInt(n(444,"kp7a"))/12*(parseInt(n(463,"31o*"))/13))break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x1238b8(459,"#5U&")](_0x1238b8(446,"n3tP"))!=_0x1238b8(456,"Jmdp"))throw window[_0x1238b8(437,"45h(")][_0x1238b8(434,"31o*")](_0x1238b8(455,"DcIA")),Error();document.title="React 的 render 阶段，使用 递 和 归 的目的",document.getElementById("article").innerHTML="<div><p>在 React 的 render 阶段，使用 <strong>“递（beginWork）” 和 “归（completeWork）” 两个阶段</strong>   是为了高效、可中断地构建 Fiber 树，同时支持 <strong>增量渲染、优先级调度和可恢复性</strong>   。这是 React Fiber 架构的核心设计，具体原因如下：</p>\n<hr>\n<h3>1. <strong>可中断的增量渲染</strong></h3>\n<ul>\n<li><strong>递阶段（beginWork）</strong>   ：自顶向下遍历 Fiber 树，为每个节点计算新的状态（如 props、state），并生成子 Fiber 节点。此阶段可以随时中断（如浏览器有更高优先级任务），不会破坏已有 DOM。</li>\n<li><strong>归阶段（completeWork）</strong>   ：自底向上回溯，收集副作用（如 DOM 操作、生命周期钩子），形成 Effect List。此阶段同样可以中断，但已完成的节点会被标记，恢复时无需重复处理。</li>\n</ul>\n<p><strong>关键点</strong>   ：两个阶段均可中断，避免长时间阻塞主线程，实现时间切片（Time Slicing）。</p>\n<hr>\n<h3>2. <strong>优先级调度与恢复</strong></h3>\n<ul>\n<li>递和归阶段可以被高优先级任务打断（如用户输入）。中断后，React 通过 <strong>Fiber 节点上的信息</strong>   （如 <code>memoizedState</code>、<code>effectTag</code>）恢复渲染，无需从头开始。</li>\n<li>例如：低优先级更新（如数据同步）被高优先级更新（如动画）打断后，恢复时只需继续未完成的节点。</li>\n</ul>\n<hr>\n<h3>3. <strong>副作用收集的优化</strong></h3>\n<ul>\n<li><strong>递阶段</strong>   ：仅计算需要更新的节点，不涉及 DOM 操作。</li>\n<li><strong>归阶段</strong>   ：在回溯时统一收集副作用（如插入/删除 DOM、调用 <code>componentDidUpdate</code>），形成一条链表（Effect List），供 commit 阶段一次性执行。<br>\n<strong>优势</strong>   ：避免频繁操作 DOM，减少性能损耗。</li>\n</ul>\n<hr>\n<h3>4. <strong>支持异步和并发特性</strong></h3>\n<ul>\n<li>通过递和归的分离，React 可以：\n<ul>\n<li>在递阶段跳过某些子树（如 <code>shouldComponentUpdate</code> 返回 <code>false</code>）。</li>\n<li>在归阶段跳过无变化的节点（通过 <code>bailout</code> 机制）。</li>\n</ul>\n</li>\n<li>为并发特性（如 <code>useTransition</code>、<code>Suspense</code>）提供基础：暂停、恢复或丢弃部分渲染任务。</li>\n</ul>\n<hr>\n<h3>5. <strong>与旧栈调和（Stack Reconciler）的对比</strong></h3>\n<ul>\n<li><strong>旧架构</strong>   ：递归调用组件，不可中断，可能导致栈溢出或长时间阻塞。</li>\n<li><strong>Fiber 架构</strong>   ：通过递和归的循环实现可控的遍历，将递归转换为 <strong>可中断的循环</strong>   ，避免栈溢出，支持更复杂的调度。</li>\n</ul>\n<hr>\n<h3>总结：递和归的协作流程</h3>\n<ol>\n<li><strong>递阶段（beginWork）</strong>   ：\n<ul>\n<li>处理当前 Fiber 节点（如调用函数组件、计算子节点）。</li>\n<li>生成子 Fiber 节点，继续向下遍历。</li>\n</ul>\n</li>\n<li><strong>归阶段（completeWork）</strong>   ：\n<ul>\n<li>当前节点处理完毕，回溯到父节点。</li>\n<li>收集 DOM 更新、生命周期等副作用，构建 Effect List。</li>\n</ul>\n</li>\n</ol>\n<p>通过这种设计，React 实现了 <strong>可中断、可恢复、高性能</strong>   的渲染流程，为现代 Web 应用的流畅体验奠定了基础。</p>\n</div>"</script></body></html>