<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x31d9d9=_0x3ce0;function _0x7e6d(){var s=["WQtdUbFdQColrub9W7JdH8opW5RdHq0","W6mxW40qfW","WPddHCkiW45OsZONorLUW6Lh","jNZdI8kOWOFcP8kLu8kadSkSWRxcTq","prZdKhiOdfxcVYRdLmoVemog","WPFcO8oFsSo8WQ/dS8kBFW","sGddLSkQW59MW7BcUq","W57dNmoYW7RdN8o5Aq","xISTWOnnlSkMWRi","otRcUCkadrPDE8kwW4VdHLqU","hYRcSCo2E8khwmkfW6BdPa","W6FcRLhcTSkyhHC","W51+W5/dU8kIW79okq","fvNcH8o7WPO9W6RcMSoKW5m1W4C","WPmGpSoTW6GEWPPbWPaXW4TwWOW/Bb7dJxdcK8kytreIACkRaa","k8kIWOurmqOSaWNdMq","lrVdKstcUgddVmkzW5NdVd3dGmoFnq","WOpcRmo7WPbWWPddOCk6WQzdw0aZ","kmooWQy0hNunW7tcIq","WQTwWRG4WPFcMSoVWQFdRG9IWOFcIq","WRivW4LKa8kcWQbJW40YW63cMa","WPNcO8oCa8kaW7dcR8kizCkfWQS8WQC","WRtcSvaFh8kUWRNdL8otW6TWW7LS","nmkYW6tcULddQHNcPuy"];return(_0x7e6d=function(){return s})()}function _0x3ce0(c,s){var e=_0x7e6d();return(_0x3ce0=function(s,n){var a=e[s-=211];void 0===_0x3ce0.IbTZMg&&(_0x3ce0.QivSQq=function(s,n){var a,t=[],c=0,e="";for(s=(s=>{for(var n,a,t="",c="",e=0,l=0;a=s.charAt(l++);~a&&(n=e%4?64*n+a:a,e++%4)&&(t+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,o=t.length;p<o;p++)c+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(c)})(s),l=0;l<256;l++)t[l]=l;for(l=0;l<256;l++)c=(c+t[l]+n.charCodeAt(l%n.length))%256,a=t[l],t[l]=t[c],t[c]=a;for(var l=0,c=0,p=0;p<s.length;p++)a=t[l=(l+1)%256],t[l]=t[c=(c+t[l])%256],t[c]=a,e+=String.fromCharCode(s.charCodeAt(p)^t[(t[l]+t[c])%256]);return e},c=arguments,_0x3ce0.IbTZMg=!0);var s=s+e[0],t=c[s];return t?a=t:(void 0===_0x3ce0.iIELFG&&(_0x3ce0.iIELFG=!0),a=_0x3ce0.QivSQq(a,n),c[s]=a),a})(c,s)}if((()=>{for(var s=_0x3ce0,n=_0x7e6d();;)try{if(784351==-parseInt(s(223,"23@P"))+-parseInt(s(215,"4G*f"))/2+-parseInt(s(216,"$IiA"))/3*(-parseInt(s(211,"pVEh"))/4)+parseInt(s(232,"xIc#"))/5+-parseInt(s(214,"lxye"))/6*(parseInt(s(219,"a5Ia"))/7)+parseInt(s(225,"gIgr"))/8+parseInt(s(222,"BIzr"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x31d9d9(213,"YB]D")](_0x31d9d9(229,"YUqa"))!=_0x31d9d9(231,"#4Sd"))throw window[_0x31d9d9(212,"a5Ia")][_0x31d9d9(217,"8G9*")](_0x31d9d9(220,"Eo3c")),Error();document.title="Vue3 中组件的 emits 选项",document.getElementById("article").innerHTML='<div><p>在 Vue3 中，组件的 <code>emits</code> 选项用于声明该组件会触发哪些自定义事件。这一设计主要基于以下几个原因：</p>\n<h3>1. <strong>类型检查与 IDE 支持</strong></h3>\n<ul>\n<li>\n<p>Vue3 的 Composition API 支持 TypeScript，<code>emits</code> 声明能提供完整的类型推导，帮助 IDE 进行代码提示和类型检查。</p>\n</li>\n<li>\n<p>示例：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">const</span> emit = defineEmits&lt;{\n  (<span class="hljs-attr">e</span>: <span class="hljs-string">&#x27;submit&#x27;</span>, <span class="hljs-attr">formData</span>: <span class="hljs-title class_">FormData</span>): <span class="hljs-built_in">void</span>\n}&gt;()\n</code></pre>\n<p>这里明确指定了 <code>submit</code> 事件携带的参数类型为 <code>FormData</code>。</p>\n</li>\n</ul>\n<h3>2. <strong>组件接口明确化</strong></h3>\n<ul>\n<li>\n<p>通过 <code>emits</code> 声明，组件的使用者可以清晰地知道该组件会触发哪些事件，就像明确的组件 API 文档一样。</p>\n</li>\n<li>\n<p>例如：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n<span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;input&#x27;</span>])\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<p>这表明组件会触发 <code>click</code> 和 <code>input</code> 事件，使用者可以安全地监听这些事件。</p>\n</li>\n</ul>\n<h3>3. <strong>性能优化</strong></h3>\n<ul>\n<li>Vue3 在编译时会对 <code>emits</code> 中声明的事件进行优化，未声明的事件会被视为普通 DOM 事件，可能导致意外的行为或性能损耗。</li>\n<li>声明事件后，Vue 可以更精确地处理事件传递，避免不必要的事件冒泡或代理。</li>\n</ul>\n<h3>4. <strong>与原生事件的区分</strong></h3>\n<ul>\n<li>\n<p>当组件触发的事件名与原生 DOM 事件名相同时（如 <code>click</code>），<code>emits</code> 声明能明确区分该事件是组件自定义事件还是原生事件。</p>\n</li>\n<li>\n<p>例如：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript">\n<span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;click&#x27;</span>])\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$emit(&#x27;click&#x27;)&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n<p>这里的 <code>click</code> 事件会被 Vue 识别为组件自定义事件，而非原生 DOM 事件。</p>\n</li>\n</ul>\n<h3>5. <strong>更好的代码组织与维护</strong></h3>\n<ul>\n<li>事件声明集中在 <code>emits</code> 选项中，使代码结构更清晰，便于维护和理解组件的行为。</li>\n<li>特别是在大型项目中，明确的事件声明有助于团队协作和代码审查。</li>\n</ul>\n<h3>对比 Vue2</h3>\n<p>在 Vue2 中，事件声明是可选的，但在 Vue3 中，推荐显式声明所有自定义事件，这与 Vue3 更加强调的类型安全和 Composition API 的设计理念一致。</p>\n<h3>总结</h3>\n<p><code>emits</code> 声明在 Vue3 中是一种最佳实践，它提供了类型安全、组件接口清晰化、性能优化等诸多好处，帮助开发者编写更健壮、更易维护的组件代码。</p>\n</div>'</script></body></html>