<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x35e2(t,e){var c=_0x5cf0();return(_0x35e2=function(e,n){var o=c[e-=370];void 0===_0x35e2.WlXupQ&&(_0x35e2.oPgVXM=function(e,n){var o,r=[],t=0,c="";for(e=(e=>{for(var n,o,r="",t="",c=0,W=0;o=e.charAt(W++);~o&&(n=c%4?64*n+o:o,c++%4)&&(r+=String.fromCharCode(255&n>>(-2*c&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var d=0,l=r.length;d<l;d++)t+="%"+("00"+r.charCodeAt(d).toString(16)).slice(-2);return decodeURIComponent(t)})(e),W=0;W<256;W++)r[W]=W;for(W=0;W<256;W++)t=(t+r[W]+n.charCodeAt(W%n.length))%256,o=r[W],r[W]=r[t],r[t]=o;for(var W=0,t=0,d=0;d<e.length;d++)o=r[W=(W+1)%256],r[W]=r[t=(t+r[W])%256],r[t]=o,c+=String.fromCharCode(e.charCodeAt(d)^r[(r[W]+r[t])%256]);return c},t=arguments,_0x35e2.WlXupQ=!0);var e=e+c[0],r=t[e];return r?o=r:(void 0===_0x35e2.KlQyeB&&(_0x35e2.KlQyeB=!0),o=_0x35e2.oPgVXM(o,n),t[e]=o),o})(t,e)}var _0x9d159e=_0x35e2;if((()=>{for(var e=_0x35e2,n=_0x5cf0();;)try{if(289980==-parseInt(e(374,"5^@H"))*(parseInt(e(387,"vwWV"))/2)+-parseInt(e(381,"6Hs]"))/3+parseInt(e(396,"eb(^"))/4*(-parseInt(e(384,"j9ws"))/5)+parseInt(e(372,"Kuzh"))/6*(parseInt(e(380,"z[ad"))/7)+-parseInt(e(385,"j]MW"))/8*(-parseInt(e(373,"U99E"))/9)+-parseInt(e(370,"&gZp"))/10*(parseInt(e(377,"pm[h"))/11)+-parseInt(e(386,"qO^Z"))/12)break;n.push(n.shift())}catch(e){n.push(n.shift())}})(),localStorage[_0x9d159e(382,"pm[h")](_0x9d159e(388,"s4a]"))!=_0x9d159e(378,"]#5z"))throw window[_0x9d159e(375,"(b(]")][_0x9d159e(399,"jrXk")](_0x9d159e(379,"4Ytu")),Error();function _0x5cf0(){var e=["l3xdPCo5zxJdIuGeWR3cSG","m0q1W5BdMmohWR4","pCkHW4ldVCk+W7G2bmkTmG","W6VcH13cPSo+WRuwW6BdUq0CuG","zcecW7tdLuD2WQy","W4G6oKRcHmo/W4q1qqb+WOm","WRjfW6XJo8kPW7/cIq","sSkjW6j+p8khDXu3","y8opFbVdKCoPWQSBmr4mBa","yCopCHhcTCkWWQuzeJK","kSktAWO0Ddm","pc7cI0WbW6VcLgJdQ2FcNSonca","mqzVimkQWRembsNdGCo2","WQGVW6BcRHO3WR/dJq","yqJcK8oymKTRaG","WR/dGIDEW6tdQaW","oSoBWRiQE8odcWumW4/dQuiF","WRZdRrNdLsGgW7uZ","EJXPW53cUHhdTa","W5L2u8oAWQPnWRZcTG","W7tdVCkEW4KvgxmDgh3dNmk5","mxRcIdVcGSk/W7TLW5Dt","rupdRCoaad7cHXSuyW3cGxa","W6FcRZiIexX8nmkguq","y8o5WPpcR8kFW4yHeG","W6pcSmkWW50sAwJdJgDR","zHr4WQ7cLmksW6RcRJ7dPSo7iZC","W6TUW4xcQsW","kuefF8o+DcXWW5lcTZNcIKCdWQlcUSkPmCoiWOXqW53dNmoQwSor","WRNdGhjUWPFcQmkJFbVdTW"];return(_0x5cf0=function(){return e})()}document.title="说说webpack的热更新是如何做到的原埋是什么",document.getElementById("article").innerHTML="<div><p><strong>Webpack 的热更新（Hot Module Replacement，简称 HMR）原理如下</strong>  ：</p>\n<h3>一、基本原理</h3>\n<p>HMR 是一种在不重新加载整个页面的情况下，动态替换页面中部分模块的技术。它通过实时监测文件变动、重新构建处理、利用 WebSocket 服务传输更新信息以及客户端的模块热替换等步骤来实现。</p>\n<h3>二、具体实现步骤</h3>\n<ol>\n<li><strong>文件监听</strong>  ：\n<ul>\n<li>Webpack 通过内置的文件系统监听器，实时监测项目文件的变动。当开发者修改了源代码并保存时，Webpack 会立即捕捉到这些变化。</li>\n</ul>\n</li>\n<li><strong>构建处理</strong>  ：\n<ul>\n<li>一旦文件发生变动，Webpack 将重新构建该文件，并生成新的模块 ID。在这个过程中，Webpack 会对比新旧模块的差异，只更新变更的部分，从而避免全量更新，提高了更新效率。</li>\n</ul>\n</li>\n<li><strong>WebSocket 服务</strong>  ：\n<ul>\n<li>在 Webpack 配置中，需要设置 <code>devServer.hot</code> 为 <code>true</code>，以启用热模块替换功能。</li>\n<li>当启动 Webpack DevServer 时，它会创建一个 Socket 服务器，用于与浏览器建立 WebSocket 连接。这个连接用于实时传输更新的模块信息。</li>\n</ul>\n</li>\n<li><strong>客户端更新</strong>  ：\n<ul>\n<li>浏览器接收到更新的模块信息后，会使用 Webpack 的 HMR Runtime（热模块替换运行时）来处理这些更新。</li>\n<li>HMR Runtime 会根据模块的更新信息，将新的模块代码插入到应用程序中，完成热更新过程。这个过程中，页面不会重新加载，用户甚至可能察觉不到更新的发生。</li>\n</ul>\n</li>\n</ol>\n<h3>三、特点与优势</h3>\n<ul>\n<li><strong>不刷新页面</strong>  ：HMR 不会导致页面完全刷新，因此页面状态（比如表单输入的数据、滚动位置等）会保持不变。</li>\n<li><strong>只更新必要模块</strong>  ：HMR 只更新有变化的模块，比如修改了某个 CSS 样式，只会更新这个样式，而不会重新加载整个页面。</li>\n<li><strong>支持多种资源类型</strong>  ：Webpack 的热更新不仅支持 JavaScript 代码的更新，还支持 CSS、样式等资源的更新。</li>\n</ul>\n<h3>四、实现方式</h3>\n<ul>\n<li><strong>使用 <code>webpack-dev-server</code></strong>  ：这是最常用的方式，通过配置 <code>devServer.hot</code> 为 <code>true</code> 来启用热更新。</li>\n<li><strong>使用 <code>webpack-dev-middleware</code></strong>  ：可以单独使用，生成一个与 webpack 的 compiler 绑定的中间件，然后在 node-server 启动服务时调用该中间件。</li>\n<li><strong>轮询监听（watch 模式）</strong>  ：通过设置 <code>watch</code> 为 <code>true</code>，Webpack 会轮询查看文件是否发生变化，若变化则重新打包。但这种方式效率较低，且每次打包产物都会与磁盘发生 I/O 操作。</li>\n</ul>\n<h3>五、局限性</h3>\n<ul>\n<li><strong>状态丢失</strong>  ：如果某个模块不支持热替换（比如某些复杂的业务逻辑），Webpack 可能无法实现局部更新，此时会回退到页面整体刷新，导致页面状态丢失。</li>\n<li><strong>兼容性问题</strong>  ：不是所有模块都支持 HMR。比如，一些第三方库可能不支持热替换。</li>\n<li><strong>开发环境限定</strong>  ：HMR 通常只在开发环境中使用。在生产环境中，通常不启用 HMR，以确保代码稳定性和性能。</li>\n</ul>\n</div>"</script></body></html>