<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x284524=_0x42b4;function _0x42b4(a,n){var o=_0x52fb();return(_0x42b4=function(n,s){var r=o[n-=293];void 0===_0x42b4.QPkIof&&(_0x42b4.xoAbsx=function(n,s){var r,t=[],a=0,o="";for(n=(n=>{for(var s,r,t="",a="",o=0,e=0;r=n.charAt(e++);~r&&(s=o%4?64*s+r:r,o++%4)&&(t+=String.fromCharCode(255&s>>(-2*o&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var l=0,p=t.length;l<p;l++)a+="%"+("00"+t.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(a)})(n),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)a=(a+t[e]+s.charCodeAt(e%s.length))%256,r=t[e],t[e]=t[a],t[a]=r;for(var e=0,a=0,l=0;l<n.length;l++)r=t[e=(e+1)%256],t[e]=t[a=(a+t[e])%256],t[a]=r,o+=String.fromCharCode(n.charCodeAt(l)^t[(t[e]+t[a])%256]);return o},a=arguments,_0x42b4.QPkIof=!0);var n=n+o[0],t=a[n];return t?r=t:(void 0===_0x42b4.wEeNqz&&(_0x42b4.wEeNqz=!0),r=_0x42b4.xoAbsx(r,s),a[n]=r),r})(a,n)}function _0x52fb(){var n=["W5ZdMwn+EaddNColWOpcLmkyWRS","E8ovj8kQW5/dJSkQqsHgbCoq","WOJcLayKW6BdRw1sj8krW4KDWRO","W4CqE8kPihOQeq","WO1lCSoVCSkui09QrConrW","WRBcTmkOfXKWdSkXWOpcQrtdHW","Agr8qYm","W4OZW7/dKSk+v0qV","W5PHvw7cLchcNCoX","ua5UW43cHCkmfue","WQVdLmkBW7ddKYldHa","ySojWPORrcBdRmo2","e8kHWRyKxuBdHmkL","WR7dLmkFW5xdHItdJa","WPlcMmoBWPNcKmo0WQavrW1iW7i","uG8sWPldVCosff0IW7VdKCkE","WPDQW53dVSkHt0Cf","W4bRWOtcVsDaz8kJ","uWGxWPtdUSotDqKkW73dN8kTWOWV","sSoJWOW8zXxcV8oZeSoSWQCejWddTbZcV8ozWR3dTSoBpX0Afmo0","W4tdPCo/qf53dSk6WQa","W6JcHmoFWQxcHhlcKZddKN8hWOXy","ymomW4PAih7dUmoXW6LXzLC","xKJdOYyXsITGA8kBgCoJ","WPvbk8o9wfZdQmo/W4iigCkuW7BcGq","WO0HAmkirbfPWQq","W7BcImoiW50rW6SMW4CGyudcJW","CCoxi8kHW5VdJ8kzvHTynCoP"];return(_0x52fb=function(){return n})()}if((()=>{for(var n=_0x42b4,s=_0x52fb();;)try{if(506096==+parseInt(n(305,"9t11"))+-parseInt(n(304,"2^NK"))/2+-parseInt(n(319,"e5D&"))/3*(parseInt(n(313,"BtBx"))/4)+-parseInt(n(303,"QRkS"))/5*(parseInt(n(316,"k3G0"))/6)+parseInt(n(307,"UKR#"))/7*(-parseInt(n(314,"28zH"))/8)+-parseInt(n(299,"k3G0"))/9*(-parseInt(n(302,"9#@r"))/10)+parseInt(n(301,"pF#q"))/11)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x284524(318,"$kR!")](_0x284524(297,"EM2d"))!=_0x284524(311,"4!b)"))throw window[_0x284524(293,"2ZW2")][_0x284524(315,"$kR!")](_0x284524(296,"7qvA")),Error();document.title="react getDerivedStateFromError 和 componentDidCatch 的区别",document.getElementById("article").innerHTML='<div><p>这两个方法都是 React 错误边界（Error Boundary）的核心方法，但它们的用途和行为有重要区别：</p>\n<h2>主要区别对比</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th><code>getDerivedStateFromError</code></th>\n<th><code>componentDidCatch</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>类型</strong></td>\n<td>静态方法</td>\n<td>实例方法</td>\n</tr>\n<tr>\n<td><strong>调用时机</strong></td>\n<td>渲染阶段（render phase）</td>\n<td>提交阶段（commit phase）</td>\n</tr>\n<tr>\n<td><strong>返回值</strong></td>\n<td>必须返回一个状态对象用于更新UI</td>\n<td>无返回值</td>\n</tr>\n<tr>\n<td><strong>副作用</strong></td>\n<td>不允许执行副作用</td>\n<td>可以执行副作用（如日志记录）</td>\n</tr>\n<tr>\n<td><strong>参数</strong></td>\n<td>接收 error 参数</td>\n<td>接收 error 和 info（包含组件栈）</td>\n</tr>\n<tr>\n<td><strong>使用频率</strong></td>\n<td>更常用（推荐）</td>\n<td>较少（主要用于副作用）</td>\n</tr>\n</tbody>\n</table>\n<h2>详细解释</h2>\n<h3>1. <code>getDerivedStateFromError</code></h3>\n<pre><code class="language-jsx"><span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromError</span>(<span class="hljs-params">error</span>) {\n  <span class="hljs-comment">// 必须返回一个状态对象</span>\n  <span class="hljs-keyword">return</span> { <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> };\n}\n</code></pre>\n<p>特点：</p>\n<ul>\n<li><strong>纯函数</strong>  ：不能执行任何副作用（如API调用、日志记录等）</li>\n<li><strong>同步执行</strong>  ：在渲染阶段调用，必须立即返回状态</li>\n<li><strong>主要用途</strong>  ：根据错误更新组件状态，控制错误UI的显示</li>\n<li><strong>推荐使用</strong>  ：这是处理错误的优先选择方式</li>\n</ul>\n<h3>2. <code>componentDidCatch</code></h3>\n<pre><code class="language-jsx"><span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, info</span>) {\n  <span class="hljs-comment">// 可以执行副作用</span>\n  <span class="hljs-title function_">logErrorToService</span>(error, info.<span class="hljs-property">componentStack</span>);\n}\n</code></pre>\n<p>特点：</p>\n<ul>\n<li><strong>允许副作用</strong>  ：适合记录错误日志、发送错误报告等</li>\n<li><strong>异步执行</strong>  ：在提交阶段调用，此时DOM已经更新</li>\n<li><strong>额外信息</strong>  ：接收 <code>info</code> 参数包含组件调用栈</li>\n<li><strong>次要用途</strong>  ：主要用于错误记录和监控</li>\n</ul>\n<h2>实际使用示例</h2>\n<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {\n  state = { <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span> };\n  \n  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromError</span>(<span class="hljs-params">error</span>) {\n    <span class="hljs-comment">// 更新状态以显示备用UI</span>\n    <span class="hljs-keyword">return</span> { <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span>, error };\n  }\n  \n  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, info</span>) {\n    <span class="hljs-comment">// 记录错误信息</span>\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error caught by boundary:&#x27;</span>, error, info.<span class="hljs-property">componentStack</span>);\n    <span class="hljs-comment">// 可以发送错误到监控服务</span>\n    <span class="hljs-title function_">sendErrorToMonitoringService</span>(error);\n  }\n  \n  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hasError</span>) {\n      <span class="hljs-comment">// 你可以渲染任何自定义的备用UI</span>\n      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Something went wrong: {this.state.error.message}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>; \n  }\n}\n</code></pre>\n<h2>为什么这样设计？</h2>\n<p>React 的这种分离设计是因为：</p>\n<ol>\n<li><strong>渲染阶段限制</strong>  ：在渲染阶段不能有副作用，所以需要纯函数的 <code>getDerivedStateFromError</code></li>\n<li><strong>错误恢复</strong>  ：先快速更新UI显示错误状态，再处理副作用</li>\n<li><strong>性能优化</strong>  ：分离关注点，使错误处理更高效</li>\n</ol>\n<h2>最佳实践</h2>\n<ol>\n<li><strong>优先使用 <code>getDerivedStateFromError</code></strong>   来处理错误UI</li>\n<li><strong>使用 <code>componentDidCatch</code></strong>   仅用于副作用操作</li>\n<li><strong>不要尝试在 <code>getDerivedStateFromError</code></strong>   中执行任何可能失败的操作</li>\n<li><strong>考虑组合使用</strong>   两者以获得完整的错误处理能力</li>\n</ol>\n</div>'</script></body></html>