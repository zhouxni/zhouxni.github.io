<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x556c(){var n=["ddNdPYxdKZ1sW585Fq4M","WOtdTSkaWONdPSoXWODN","WR7cVCozvCkbiSkGWPdcJmkEWPldHa","dd3dOcFdKJfPW4q2xbmj","ddNdOYxdKtuOW7KhxYKlBG","zLOrWRuOqSkPW4hcQqBdTgq","vSkcW6CVANFcTSkuW7WDgqtcQJxdUeCXWRddQSkWW5viAmomev0","kSoorHilWOddVSoPWPCoo8oN","W5BcVCoyW4v9jGVdOmo9BX3cPa","uMVdISorimkXW7FdU8k/W63dKMXt","kSonqXipWOhcVSoVWQaUlComeq","etNcJCkeDSoGWQa","qNtcSLTrW4BdLmo0dSoSBmkY","mCoRW6ZdKCkW","hCkDW5pdTdZdPNvGxq","ucRdGCk8W6yhnW","cXpcG8oKDSo7WPTIWQJcJCkvWPhcPq","WQRcIsCYWPddNmolcdKtWR52WRu","bNVcG8ofWQvxBMtcO0z4Emox","WPhcH8o7WPNcVCoztulcGJ7cImoh"];return(_0x556c=function(){return n})()}function _0x59d4(a,n){var e=_0x556c();return(_0x59d4=function(n,s){var o=e[n-=494];void 0===_0x59d4.RVgBCu&&(_0x59d4.wWlccp=function(n,s){var o,t=[],a=0,e="";for(n=(n=>{for(var s,o,t="",a="",e=0,c=0;o=n.charAt(c++);~o&&(s=e%4?64*s+o:o,e++%4)&&(t+=String.fromCharCode(255&s>>(-2*e&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var l=0,r=t.length;l<r;l++)a+="%"+("00"+t.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(a)})(n),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)a=(a+t[c]+s.charCodeAt(c%s.length))%256,o=t[c],t[c]=t[a],t[a]=o;for(var c=0,a=0,l=0;l<n.length;l++)o=t[c=(c+1)%256],t[c]=t[a=(a+t[c])%256],t[a]=o,e+=String.fromCharCode(n.charCodeAt(l)^t[(t[c]+t[a])%256]);return e},a=arguments,_0x59d4.RVgBCu=!0);var n=n+e[0],t=a[n];return t?o=t:(void 0===_0x59d4.xCoaMg&&(_0x59d4.xCoaMg=!0),o=_0x59d4.wWlccp(o,s),a[n]=o),o})(a,n)}var _0x109e4b=_0x59d4;if((()=>{for(var n=_0x59d4,s=_0x556c();;)try{if(141667==+parseInt(n(494,"gGof"))+parseInt(n(506,"kyZ6"))/2+parseInt(n(501,"6u7X"))/3+parseInt(n(502,"6J98"))/4+-parseInt(n(498,"gGof"))/5+-parseInt(n(512,"KDbn"))/6+parseInt(n(503,"mAE$"))/7)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x109e4b(509,"KDbn")](_0x109e4b(508,"G5dj"))!=_0x109e4b(507,"AqLt"))throw window[_0x109e4b(495,"*Va*")][_0x109e4b(505,"mAE$")](_0x109e4b(500,"!!MK")),Error();document.title="react hooks 是如何判断在函数顶层调用的",document.getElementById("article").innerHTML='<div><p>React Hooks 要求开发者 必须在函数组件的顶层调用（不能嵌套在条件、循环或子函数中），这是为了确保 Hooks 的调用顺序在每次渲染时保持一致。React 通过 调用顺序追踪 和 运行时检查 来强制执行这一规则。</p>\n<hr>\n<p><strong>1. 核心原理：Hooks 依赖调用顺序</strong><br>\nReact 内部使用 链表结构（Fiber 的 <code>memoizedState</code>） 来存储组件的 Hook 状态。每个 Hook 的 执行顺序 决定了它在链表中的位置，例如：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);      <span class="hljs-comment">// Hook 1</span>\n  <span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;Alice&quot;</span>);  <span class="hljs-comment">// Hook 2</span>\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {});                        <span class="hljs-comment">// Hook 3</span>\n  <span class="hljs-comment">// ...</span>\n}\n</code></pre>\n<p>React 会按顺序记录这些 Hook：</p>\n<pre><code>Fiber.memoizedState → Hook1 (useState) → Hook2 (useState) → Hook3 (useEffect) → ...\n</code></pre>\n<p>如果 Hook 的调用顺序改变（如条件语句导致某些 Hook 未被调用），链表会错乱，导致状态错误。</p>\n<hr>\n<p><strong>2. 实现机制</strong><br>\n<strong>(1) 运行时检查（开发环境）</strong><br>\n在开发模式下，React 会通过 <code>validateHook</code> 函数检查 Hook 的调用位置：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useState</span>(<span class="hljs-params">initialState</span>) {\n  <span class="hljs-keyword">const</span> dispatcher = <span class="hljs-title function_">resolveDispatcher</span>();\n  <span class="hljs-comment">// 检查是否在函数组件顶层调用</span>\n  <span class="hljs-keyword">if</span> (__DEV__) {\n    <span class="hljs-title function_">validateHook</span>(currentlyRenderingFiber, <span class="hljs-string">&#x27;useState&#x27;</span>);\n  }\n  <span class="hljs-keyword">return</span> dispatcher.<span class="hljs-title function_">useState</span>(initialState);\n}\n</code></pre>\n<p>如果 Hook 在条件语句中被调用，React 会抛出错误：</p>\n<pre><code>Error: React Hook &quot;useState&quot; is called conditionally. \nHooks must be called in the exact same order every time the component renders.\n</code></pre>\n<p><strong>(2) 调用栈追踪</strong><br>\nReact 通过 当前 Fiber 节点（<code>currentlyRenderingFiber</code>）和 Hook 链表 的指针来判断调用是否合法：</p>\n<ol>\n<li>每次渲染时，React 会初始化一个 Hook 链表指针（<code>workInProgressHook</code>）。</li>\n<li>调用 Hook 时，React 检查当前是否处于 渲染阶段（通过全局变量 <code>ReactCurrentDispatcher</code>）。</li>\n<li>如果 Hook 在非组件函数或条件分支中被调用，链表指针会错位，触发错误。</li>\n</ol>\n<hr>\n<p><strong>3. 为什么必须顶层调用？</strong><br>\n<strong>(1) 状态依赖顺序</strong><br>\nHooks 的状态是通过 链表顺序 管理的，顺序变化会导致状态错乱。例如：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">BuggyComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (condition) {\n    <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 第一次渲染调用</span>\n  }\n  <span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;Alice&quot;</span>); <span class="hljs-comment">// 第二次渲染可能跳过上一个 Hook</span>\n}\n</code></pre>\n<ul>\n<li>\n<p>第一次渲染：<code>Hook1 (count)</code> → <code>Hook2 (name)</code></p>\n</li>\n<li>\n<p>第二次渲染（<code>condition=false</code>）：直接调用 <code>Hook2 (name)</code>，链表错乱。</p>\n</li>\n</ul>\n<p><strong>(2) 静态分析困难</strong><br>\n虽然理论上可以通过编译时检查（如 ESLint 规则 <code>react-hooks/rules-of-hooks</code>），但 JavaScript 的动态性使得运行时检查更可靠。</p>\n<hr>\n<p><strong>4. 如何绕过检查？（不推荐）</strong><br>\nReact 严格限制 Hook 的调用位置，但极端情况下可通过 高阶 Hook 或 自定义 Hook 间接使用：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useConditionalHook</span>(<span class="hljs-params">condition</span>) {\n  <span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);\n  <span class="hljs-keyword">if</span> (condition) {\n    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">/*...*/</span> });\n  }\n  <span class="hljs-keyword">return</span> [state, setState];\n}\n<span class="hljs-comment">// ✅ 合法：自定义 Hook 内部可条件调用其他 Hook</span>\n</code></pre>\n<p>但自定义 Hook 本身仍需在顶层调用。</p>\n<hr>\n<p><strong>5. 常见问题</strong><br>\n<strong>Q1: 为什么 Hook 不能在循环中调用？</strong></p>\n<ul>\n<li>循环次数可能变化，导致 Hook 顺序不一致。</li>\n</ul>\n<p><strong>Q2: Class 组件为什么没有这个限制？</strong></p>\n<ul>\n<li>Class 组件的状态存储在 <code>this.state</code> 中，不依赖调用顺序。</li>\n</ul>\n<p><strong>Q3: React 如何区分自定义 Hook 和普通函数？</strong></p>\n<ul>\n<li>通过函数名前缀（<code>useXXX</code>）约定，但实际依赖运行时调用栈检查。</li>\n</ul>\n<hr>\n<p><strong>6. 总结</strong></p>\n<table>\n<thead>\n<tr>\n<th>机制</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>调用顺序追踪</td>\n<td>通过链表结构保证 Hook 状态一致。</td>\n</tr>\n<tr>\n<td>运行时检查</td>\n<td>开发环境下验证 Hook 是否在顶层调用。</td>\n</tr>\n<tr>\n<td>静态检查</td>\n<td>ESLint 插件 (<code>react-hooks/rules-of-hooks</code>) 提前预警。</td>\n</tr>\n<tr>\n<td>错误示例</td>\n<td>条件/循环/嵌套函数中调用 Hook 会报错。</td>\n</tr>\n</tbody>\n</table>\n<p>核心规则：<br>\n“Hooks 必须在函数组件的顶层调用，且每次渲染顺序相同。”<br>\nReact 通过运行时链表管理和开发环境检查确保这一规则。</p>\n</div>'</script></body></html>