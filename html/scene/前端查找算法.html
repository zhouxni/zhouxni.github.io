<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4367(l,s){var r=_0x55cb();return(_0x4367=function(s,n){var a=r[s-=189];void 0===_0x4367.VZZCCZ&&(_0x4367.evEhbW=function(s,n){var a,t=[],l=0,r="";for(s=(s=>{for(var n,a,t="",l="",r=0,p=0;a=s.charAt(p++);~a&&(n=r%4?64*n+a:a,r++%4)&&(t+=String.fromCharCode(255&n>>(-2*r&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,e=t.length;o<e;o++)l+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)l=(l+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[l],t[l]=a;for(var p=0,l=0,o=0;o<s.length;o++)a=t[p=(p+1)%256],t[p]=t[l=(l+t[p])%256],t[l]=a,r+=String.fromCharCode(s.charCodeAt(o)^t[(t[p]+t[l])%256]);return r},l=arguments,_0x4367.VZZCCZ=!0);var s=s+r[0],t=l[s];return t?a=t:(void 0===_0x4367.NtIxfR&&(_0x4367.NtIxfR=!0),a=_0x4367.evEhbW(a,n),l[s]=a),a})(l,s)}var _0x15f7ad=_0x4367;function _0x55cb(){var s=["WQ/dR8owDWVdTNxdUq","BgBdLmoQfCo/cmouW5TJW5FcOG","vSkKWPr9hCksk3pcS1eU","Ec/dMHXMv8k0wmoKW5/cHNqY","zmk+WR7dLmo1WQ3dMmkWqq","FMmMW4ZcQmkSW6BdGG","guvcumo9qWnrW57dSLqMWR3cJ3yhrmojaCoDquCvW5/cUwy","WQVdPSksj2FdN2ldRXFdPr4","WP7cTZvwwSoUa8oMW47dPSo0WP4p","WPNdM0Sil8klEG","EsZdNHDKxSoLx8owW53cTv4","W74fxHH9wmoyW7vBW5zYW7xcOG","W6ipW7ddOKzLW5W","WR1nwSkcj8kYWPtcKCo3D8o/WO7cGq","WRPyW78SW6GJmCottXmFW4pdLW","oN3cHhCaFCoRW4DEp3/cIIK","W6ZcO8otysO","Evn0w0TMu8kKyCoAWOzU","WPxcUdCXamkYwCoNW6y","W5rbDmkyySk4WQFcHwu","smkrmSo0dezOWRv0W4nIF8k8","o3hcHNieFCoPW4H4cxtcPbi","W5XhC8o2o8oLWRhcVhRdOHpdQW","W58EiCo5WOreWQO","WQa5mCk4W6P6W5y","WOezj8kUFCk+WQtcOG"];return(_0x55cb=function(){return s})()}if((()=>{for(var s=_0x4367,n=_0x55cb();;)try{if(417866==+parseInt(s(214,"m#FR"))+-parseInt(s(204,"Zxt9"))/2*(-parseInt(s(192,"UnjV"))/3)+-parseInt(s(190,"rnS)"))/4+-parseInt(s(210,"tHH@"))/5*(-parseInt(s(202,"hXF1"))/6)+parseInt(s(201,"x2Kh"))/7+-parseInt(s(195,"I7YT"))/8+-parseInt(s(194,"97[m"))/9*(parseInt(s(205,"I7YT"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x15f7ad(199,"gq3H")](_0x15f7ad(191,"pxzO"))!=_0x15f7ad(203,"97[m"))throw window[_0x15f7ad(212,"Sl0Q")][_0x15f7ad(211,"OBI%")](_0x15f7ad(193,"W26c")),Error();document.title="前端查找算法",document.getElementById("article").innerHTML='<div><p>在前端开发中，常见的查找算法主要用于在数据集合中快速定位目标元素，以下为你详细介绍前端三大查找算法的原理、实现及应用场景：</p>\n<h3><strong>一、顺序查找（Linear Search）</strong></h3>\n<h4><strong>基本原理</strong></h4>\n<p>从数据集合的第一个元素开始，逐个与目标元素进行比较，直到找到匹配项或遍历完整个集合。</p>\n<h4><strong>实现代码（JavaScript）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">linearSearch</span>(<span class="hljs-params">arr, target</span>) {\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) {\n    <span class="hljs-keyword">if</span> (arr[i] === target) {\n      <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// 返回目标元素的索引</span>\n    }\n  }\n  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 未找到目标元素</span>\n}\n</code></pre>\n<h4><strong>时间复杂度</strong></h4>\n<ul>\n<li>平均时间复杂度：O(n)，其中n为数据集合的长度。</li>\n<li>最坏情况：需遍历整个集合，时间复杂度为O(n)。</li>\n<li>最好情况：目标元素在第一个位置，时间复杂度为O(1)。</li>\n</ul>\n<h4><strong>应用场景</strong></h4>\n<ul>\n<li>数据量较小或无序的数据集合。</li>\n<li>数据更新频繁（如动态添加元素），无需维护额外结构。</li>\n<li>示例：在未排序的数组中查找某个值，或在DOM节点列表中逐个查找特定元素。</li>\n</ul>\n<h3><strong>二、二分查找（Binary Search）</strong></h3>\n<h4><strong>基本原理</strong></h4>\n<p>要求数据集合<strong>有序</strong>  ，通过不断将数据集合分为两半，比较中间元素与目标值，逐步缩小查找范围，直到找到目标元素或确定其不存在。</p>\n<h4><strong>实现代码（JavaScript）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">arr, target</span>) {\n  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;\n  <span class="hljs-keyword">let</span> right = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;\n  \n  <span class="hljs-keyword">while</span> (left &lt;= right) {\n    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);\n    \n    <span class="hljs-keyword">if</span> (arr[mid] === target) {\n      <span class="hljs-keyword">return</span> mid; <span class="hljs-comment">// 找到目标元素</span>\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) {\n      left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 目标在右半部分</span>\n    } <span class="hljs-keyword">else</span> {\n      right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 目标在左半部分</span>\n    }\n  }\n  \n  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 未找到目标元素</span>\n}\n</code></pre>\n<h4><strong>时间复杂度</strong></h4>\n<ul>\n<li>平均时间复杂度：O(log n)，每次将查找范围缩小一半。</li>\n<li>最坏情况：O(log n)，需遍历对数级别的次数。</li>\n</ul>\n<h4><strong>应用场景</strong></h4>\n<ul>\n<li>有序数组或可排序的数据结构（如有序列表、字典）。</li>\n<li>数据量较大且查找频繁，需高效定位的场景。</li>\n<li>示例：在排序后的用户列表中查找特定用户ID，或在索引数据库中快速定位数据。</li>\n</ul>\n<h3><strong>三、哈希查找（Hash Search）</strong></h3>\n<h4><strong>基本原理</strong></h4>\n<p>利用哈希函数将目标元素的键值映射到哈希表的某个位置，通过直接访问该位置来查找元素，时间复杂度接近O(1)。</p>\n<h4><strong>实现代码（JavaScript）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 使用JavaScript的Object或Map实现哈希查找</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">hashSearch</span>(<span class="hljs-params">hashTable, key</span>) {\n  <span class="hljs-comment">// 使用Object实现</span>\n  <span class="hljs-keyword">if</span> (hashTable[key] !== <span class="hljs-literal">undefined</span>) {\n    <span class="hljs-keyword">return</span> hashTable[key];\n  }\n  \n  <span class="hljs-comment">// 或使用Map实现</span>\n  <span class="hljs-comment">// if (hashTable.has(key)) {</span>\n  <span class="hljs-comment">//   return hashTable.get(key);</span>\n  <span class="hljs-comment">// }</span>\n  \n  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 未找到目标元素</span>\n}\n\n<span class="hljs-comment">// 示例：构建哈希表</span>\n<span class="hljs-keyword">const</span> userHash = {\n  <span class="hljs-string">&quot;1001&quot;</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> },\n  <span class="hljs-string">&quot;1002&quot;</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> },\n  <span class="hljs-string">&quot;1003&quot;</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">28</span> }\n};\n\n<span class="hljs-comment">// 查找用户ID为1002的信息</span>\n<span class="hljs-keyword">const</span> user = <span class="hljs-title function_">hashSearch</span>(userHash, <span class="hljs-string">&quot;1002&quot;</span>);\n</code></pre>\n<h4><strong>时间复杂度</strong></h4>\n<ul>\n<li>理想情况下：O(1)，直接通过哈希表定位元素。</li>\n<li>存在哈希冲突时：需通过链表或红黑树处理，时间复杂度接近O(1)，最坏情况为O(n)（但实际开发中可通过优化哈希函数减少冲突）。</li>\n</ul>\n<h4><strong>应用场景</strong></h4>\n<ul>\n<li>需要快速查找、插入和删除的数据场景。</li>\n<li>键值对映射（如用户ID与用户信息的关联）。</li>\n<li>示例：前端缓存数据（如缓存API请求结果）、状态管理中的数据映射（如Redux的state树）、表单验证中的错误信息存储等。</li>\n</ul>\n<h3><strong>三大算法对比总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>算法</strong></th>\n<th><strong>数据要求</strong></th>\n<th><strong>时间复杂度</strong></th>\n<th><strong>空间复杂度</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>顺序查找</td>\n<td>无序</td>\n<td>O(n)</td>\n<td>O(1)</td>\n<td>小数据量、无序或动态更新场景</td>\n</tr>\n<tr>\n<td>二分查找</td>\n<td>有序</td>\n<td>O(log n)</td>\n<td>O(1)</td>\n<td>大数据量、有序且查找频繁场景</td>\n</tr>\n<tr>\n<td>哈希查找</td>\n<td>无要求</td>\n<td>O(1)（平均）</td>\n<td>O(n)</td>\n<td>键值对映射、高频查找与更新场景</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>前端实际应用案例</strong></h3>\n<ul>\n<li><strong>顺序查找</strong>  ：在DOM操作中使用<code>querySelectorAll</code>遍历节点列表。</li>\n<li><strong>二分查找</strong>  ：在前端图表库中对有序数据进行快速定位（如时间轴数据筛选）。</li>\n<li><strong>哈希查找</strong>  ：使用<code>Map</code>存储组件状态，通过键快速获取值（如React的Context API）。</li>\n</ul>\n<p>根据具体业务场景选择合适的算法，可有效提升前端应用的性能和用户体验。</p>\n</div>'</script></body></html>