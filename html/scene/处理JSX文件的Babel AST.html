<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1bf0(l,s){var t=_0x1ee8();return(_0x1bf0=function(s,n){var a=t[s-=494];void 0===_0x1bf0.tBOaRW&&(_0x1bf0.GPHgPA=function(s,n){var a,p=[],l=0,t="";for(s=(s=>{for(var n,a,p="",l="",t=0,e=0;a=s.charAt(e++);~a&&(n=t%4?64*n+a:a,t++%4)&&(p+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,c=p.length;r<c;r++)l+="%"+("00"+p.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)p[e]=e;for(e=0;e<256;e++)l=(l+p[e]+n.charCodeAt(e%n.length))%256,a=p[e],p[e]=p[l],p[l]=a;for(var e=0,l=0,r=0;r<s.length;r++)a=p[e=(e+1)%256],p[e]=p[l=(l+p[e])%256],p[l]=a,t+=String.fromCharCode(s.charCodeAt(r)^p[(p[e]+p[l])%256]);return t},l=arguments,_0x1bf0.tBOaRW=!0);var s=s+t[0],p=l[s];return p?a=p:(void 0===_0x1bf0.gEQfic&&(_0x1bf0.gEQfic=!0),a=_0x1bf0.GPHgPA(a,n),l[s]=a),a})(l,s)}var _0x2e93ea=_0x1bf0;function _0x1ee8(){var s=["WOldGSo7W4tdJ2qVlZPYAYFcHa","vHaoWOpdOYBdOCkGW4pdMb7dIrW","sfldHsVdVIhdM8o/W5iHhNO","bWjMj8kNWQWDWQldKmkmW709uG","emk1fSo0WRZcQH4R","a8kVdCkDCdBdQmkT","r8oXW5tcN8knc8o0WPO","W5BdTSoTtCo+WQC0zbS1BsddUvdcKq4WWQpdVM3cTLrFBfZdVa","rSolW6ldN0GwWPKPg8ogWOVcNgq","aqrNkSkMWQGCWQVdOSkNW5CbAW","WOPlW71tW6uLda","EmknW4OnjXHEW7BcJW","W6W5W7VdQfLMj8kdW4C","jSk0zmouAG","ixZcS8o2adCqE8k0WRpcSa","WPXSWQ3cTr8MxCkdW4/cPmkyWRqr","CIZdSSknrdqK","W5K6W7upk8oVW5O2o30Wka","rmo0WR3dSSoiAmkaW5ZdI8onhXlcR8oO","gmkWetf1W6eSW6FdQhVdMW","WOhdH8o+W4BdJgCVic9bAZ/cGG","WP9TWQNcTbWMxSowW73cVCk/WPiuEa","smkQWO/cSJPSW4i","FHVdLapdOLDGWRrZ","WPuTWP0zW4WmgvunWRJdKtNdLW","o3JdVSoOFG1B"];return(_0x1ee8=function(){return s})()}if((()=>{for(var s=_0x1bf0,n=_0x1ee8();;)try{if(733838==-parseInt(s(497,"TrtX"))*(parseInt(s(511,"n)mv"))/2)+parseInt(s(503,"SN5)"))/3*(parseInt(s(499,"WhMm"))/4)+parseInt(s(507,"@B5E"))/5+parseInt(s(505,"EG]b"))/6*(parseInt(s(515,"8s])"))/7)+parseInt(s(504,"B!v4"))/8+parseInt(s(509,"8s])"))/9+-parseInt(s(501,"(3]*"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x2e93ea(496,"%0!I")](_0x2e93ea(518,"(3]*"))!=_0x2e93ea(519,"[6pf"))throw window[_0x2e93ea(510,"gPWr")][_0x2e93ea(516,"5sv6")](_0x2e93ea(513,"OWUP")),Error();document.title="处理JSX文件的Babel AST",document.getElementById("article").innerHTML='<div><p>处理JSX文件的Babel AST遍历需要结合JSX特定的解析和遍历方式。以下是具体步骤和示例代码：</p>\n<h3>1. <strong>解析JSX文件为Babel AST</strong></h3>\n<p>使用<code>@babel/parser</code>解析JSX代码，需启用<code>jsx</code>插件：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/parser&#x27;</span>);\n<span class="hljs-keyword">const</span> code = <span class="hljs-string">&#x27;&lt;div className=&quot;container&quot;&gt;Hello JSX!&lt;/div&gt;&#x27;</span>;\n\n<span class="hljs-keyword">const</span> ast = parser.<span class="hljs-title function_">parse</span>(code, {\n  <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&#x27;module&#x27;</span>,\n  <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&#x27;jsx&#x27;</span>] <span class="hljs-comment">// 启用JSX解析</span>\n});\n</code></pre>\n<h3>2. <strong>遍历JSX节点</strong></h3>\n<p>使用<code>@babel/traverse</code>遍历AST，并处理JSX相关节点类型：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/traverse&#x27;</span>).<span class="hljs-property">default</span>;\n\n<span class="hljs-title function_">traverse</span>(ast, {\n  <span class="hljs-comment">// 处理JSX元素（如&lt;div&gt;、&lt;MyComponent&gt;）</span>\n  <span class="hljs-title class_">JSXElement</span>(path) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Found JSX element:&#x27;</span>, path.<span class="hljs-property">node</span>.<span class="hljs-property">openingElement</span>.<span class="hljs-property">name</span>.<span class="hljs-property">name</span>);\n  },\n  \n  <span class="hljs-comment">// 处理JSX属性（如className、onClick）</span>\n  <span class="hljs-title class_">JSXAttribute</span>(path) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Found attribute:&#x27;</span>, path.<span class="hljs-property">node</span>.<span class="hljs-property">name</span>.<span class="hljs-property">name</span>);\n  },\n  \n  <span class="hljs-comment">// 处理JSX表达式（如{name}、{() =&gt; {}}）</span>\n  <span class="hljs-title class_">JSXExpressionContainer</span>(path) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Found expression:&#x27;</span>, path.<span class="hljs-property">node</span>.<span class="hljs-property">expression</span>.<span class="hljs-property">type</span>);\n  }\n});\n</code></pre>\n<h3>3. <strong>修改JSX节点（示例：转换className为class）</strong></h3>\n<p>遍历过程中可以修改AST节点：</p>\n<pre><code class="language-javascript"><span class="hljs-title function_">traverse</span>(ast, {\n  <span class="hljs-title class_">JSXAttribute</span>(path) {\n    <span class="hljs-keyword">const</span> { node } = path;\n    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">name</span>.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;className&#x27;</span>) {\n      node.<span class="hljs-property">name</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;class&#x27;</span>; <span class="hljs-comment">// 将className改为class</span>\n    }\n  }\n});\n</code></pre>\n<h3>4. <strong>生成修改后的代码</strong></h3>\n<p>使用<code>@babel/generator</code>将修改后的AST转回代码：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/generator&#x27;</span>).<span class="hljs-property">default</span>;\n<span class="hljs-keyword">const</span> { code } = <span class="hljs-title function_">generator</span>(ast);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Transformed code:&#x27;</span>, code);\n<span class="hljs-comment">// 输出: &lt;div class=&quot;container&quot;&gt;Hello JSX!&lt;/div&gt;</span>\n</code></pre>\n<h3>5. <strong>完整示例：遍历并转换JSX文件</strong></h3>\n<p>下面是一个完整的脚本，演示如何遍历JSX文件并处理常见节点：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/parser&#x27;</span>);\n<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/traverse&#x27;</span>).<span class="hljs-property">default</span>;\n<span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/generator&#x27;</span>).<span class="hljs-property">default</span>;\n<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);\n<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">processJSXFile</span>(<span class="hljs-params">filePath</span>) {\n  <span class="hljs-keyword">const</span> code = fs.<span class="hljs-title function_">readFileSync</span>(filePath, <span class="hljs-string">&#x27;utf8&#x27;</span>);\n  \n  <span class="hljs-comment">// 解析为AST</span>\n  <span class="hljs-keyword">const</span> ast = parser.<span class="hljs-title function_">parse</span>(code, {\n    <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&#x27;module&#x27;</span>,\n    <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&#x27;jsx&#x27;</span>, <span class="hljs-string">&#x27;classProperties&#x27;</span>] <span class="hljs-comment">// 根据需要添加更多插件</span>\n  });\n  \n  <span class="hljs-comment">// 遍历并处理JSX节点</span>\n  <span class="hljs-title function_">traverse</span>(ast, {\n    <span class="hljs-comment">// 处理函数组件</span>\n    <span class="hljs-title class_">FunctionDeclaration</span>(path) {\n      <span class="hljs-keyword">const</span> { node } = path;\n      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">id</span> &amp;&amp; node.<span class="hljs-property">body</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">some</span>(\n        <span class="hljs-function"><span class="hljs-params">stmt</span> =&gt;</span> stmt.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;ReturnStatement&#x27;</span> &amp;&amp; \n               stmt.<span class="hljs-property">argument</span> &amp;&amp; \n               stmt.<span class="hljs-property">argument</span>.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;JSXElement&#x27;</span>\n      )) {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Found functional component:&#x27;</span>, node.<span class="hljs-property">id</span>.<span class="hljs-property">name</span>);\n      }\n    },\n    \n    <span class="hljs-comment">// 处理类组件</span>\n    <span class="hljs-title class_">ClassDeclaration</span>(path) {\n      <span class="hljs-keyword">const</span> { node } = path;\n      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">superClass</span> &amp;&amp; node.<span class="hljs-property">superClass</span>.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;Component&#x27;</span>) {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Found class component:&#x27;</span>, node.<span class="hljs-property">id</span>.<span class="hljs-property">name</span>);\n      }\n    },\n    \n    <span class="hljs-comment">// 处理JSX元素</span>\n    <span class="hljs-title class_">JSXElement</span>(path) {\n      <span class="hljs-keyword">const</span> tagName = path.<span class="hljs-property">node</span>.<span class="hljs-property">openingElement</span>.<span class="hljs-property">name</span>.<span class="hljs-property">name</span>;\n      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;JSX element:&#x27;</span>, tagName);\n      \n      <span class="hljs-comment">// 示例：自动为&lt;input&gt;添加type=&quot;text&quot;</span>\n      <span class="hljs-keyword">if</span> (tagName === <span class="hljs-string">&#x27;input&#x27;</span>) {\n        <span class="hljs-keyword">const</span> hasType = path.<span class="hljs-property">node</span>.<span class="hljs-property">openingElement</span>.<span class="hljs-property">attributes</span>.<span class="hljs-title function_">some</span>(\n          <span class="hljs-function"><span class="hljs-params">attr</span> =&gt;</span> attr.<span class="hljs-property">name</span> &amp;&amp; attr.<span class="hljs-property">name</span>.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;type&#x27;</span>\n        );\n        \n        <span class="hljs-keyword">if</span> (!hasType) {\n          path.<span class="hljs-property">node</span>.<span class="hljs-property">openingElement</span>.<span class="hljs-property">attributes</span>.<span class="hljs-title function_">push</span>({\n            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;JSXAttribute&#x27;</span>,\n            <span class="hljs-attr">name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;JSXIdentifier&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;type&#x27;</span> },\n            <span class="hljs-attr">value</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;StringLiteral&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;text&#x27;</span> }\n          });\n        }\n      }\n    }\n  });\n  \n  <span class="hljs-comment">// 生成转换后的代码</span>\n  <span class="hljs-keyword">const</span> { <span class="hljs-attr">code</span>: output } = <span class="hljs-title function_">generator</span>(ast);\n  fs.<span class="hljs-title function_">writeFileSync</span>(path.<span class="hljs-title function_">join</span>(path.<span class="hljs-title function_">dirname</span>(filePath), <span class="hljs-string">&#x27;transformed.jsx&#x27;</span>), output);\n}\n\n<span class="hljs-comment">// 使用示例</span>\n<span class="hljs-title function_">processJSXFile</span>(path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src/components/MyComponent.jsx&#x27;</span>));\n</code></pre>\n<h3>关键依赖</h3>\n<p>确保安装以下依赖：</p>\n<pre><code class="language-sh">npm install @babel/parser @babel/traverse @babel/generator\n</code></pre>\n<h3>常见JSX节点类型</h3>\n<table>\n<thead>\n<tr>\n<th>节点类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>JSXElement</code></td>\n<td>JSX元素（如<code>&lt;div&gt;</code>）</td>\n</tr>\n<tr>\n<td><code>JSXFragment</code></td>\n<td>JSX片段（如<code>&lt;&gt;&lt;/&gt;</code>）</td>\n</tr>\n<tr>\n<td><code>JSXIdentifier</code></td>\n<td>标识符（如<code>div</code>、<code>Foo</code>）</td>\n</tr>\n<tr>\n<td><code>JSXAttribute</code></td>\n<td>属性（如<code>className=&quot;x&quot;</code>）</td>\n</tr>\n<tr>\n<td><code>JSXExpressionContainer</code></td>\n<td>表达式（如<code>{value}</code>）</td>\n</tr>\n<tr>\n<td><code>JSXOpeningElement</code></td>\n<td>开始标签（如<code>&lt;div&gt;</code>）</td>\n</tr>\n<tr>\n<td><code>JSXClosingElement</code></td>\n<td>结束标签（如<code>&lt;/div&gt;</code>）</td>\n</tr>\n</tbody>\n</table>\n<h3>注意事项</h3>\n<ol>\n<li><strong>插件配置</strong>  ：根据项目需要添加更多Babel插件（如<code>typescript</code>、<code>decorators</code>）。</li>\n<li><strong>AST结构差异</strong>  ：JSX节点在Babel 7和Babel 6中的结构略有不同，本文基于Babel 7。</li>\n<li><strong>复杂表达式</strong>  ：JSX中的表达式（如箭头函数、条件表达式）需要额外处理。</li>\n</ol>\n<p>通过这种方式，你可以全面遍历和转换JSX文件中的节点。</p>\n</div>'</script></body></html>