<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x38d5de=_0x19ff;function _0x19ff(t,s){var p=_0xdfb4();return(_0x19ff=function(s,n){var a=p[s-=257];void 0===_0x19ff.VTTDjx&&(_0x19ff.GBRsdi=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,c=0;a=s.charAt(c++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,o=l.length;e<o;e++)t+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(s),c=0;c<256;c++)l[c]=c;for(c=0;c<256;c++)t=(t+l[c]+n.charCodeAt(c%n.length))%256,a=l[c],l[c]=l[t],l[t]=a;for(var c=0,t=0,e=0;e<s.length;e++)a=l[c=(c+1)%256],l[c]=l[t=(t+l[c])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(e)^l[(l[c]+l[t])%256]);return p},t=arguments,_0x19ff.VTTDjx=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x19ff.mJfnqS&&(_0x19ff.mJfnqS=!0),a=_0x19ff.GBRsdi(a,n),t[s]=a),a})(t,s)}if((()=>{for(var s=_0x19ff,n=_0xdfb4();;)try{if(497909==+parseInt(s(285,"p#WC"))*(parseInt(s(269,"QCA#"))/2)+-parseInt(s(280,"$chd"))/3*(parseInt(s(273,"m]ZN"))/4)+parseInt(s(266,"C8jq"))/5*(-parseInt(s(257,"x!et"))/6)+-parseInt(s(274,"ndJF"))/7+parseInt(s(268,"*E@d"))/8*(parseInt(s(279,"XE2C"))/9)+parseInt(s(258,"3a%G"))/10*(-parseInt(s(282,"G6cO"))/11)+parseInt(s(261,"5nfb"))/12)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x38d5de(284,"x!et")](_0x38d5de(278,"tLy["))!=_0x38d5de(260,"[scE"))throw window[_0x38d5de(264,"$chd")][_0x38d5de(277,"z)q9")](_0x38d5de(286,"3a%G")),Error();function _0xdfb4(){var s=["WRjXW60mWO3dIdG","WQZcNH9/k8oEkdG","W5BcNNjdW47cR8kAW6TxWRldIq","W4BcNSkjW51HWQuyW6m3","aSo0WQldM8o4zIfF","WRzOFmk9WPyVhq","z8ogW4/dQCk1ggP7aCoig8kE","WRyUWRb0W6NcOu7cMquDESoJda","W5/dKCkAW6tdMuZdVNxdMSoPwKq","jJFcLSodjSoCW6S","W6jFehiGWQpcVSkq","xmkjWR7cUvHjWQFdSa7dGM3dIey","WPJcPCo1W6pdUSopr8k9W60","W53dKSkBW6BcRr3dOKldUCon","WP7cGSoBWR3cIbNdNW","WOtcOqtcUICbW616W5W","s8k3ESoHdCk1W6tcTvhcSehcRN4","W7xdHuSRzSo6davmWQ7cOq","w20soW3dLmoLWRpdHCobBWaS","D8kbCmomWRJcSmotdZldIq","WOFcL2FcLmowveRdM8kzW4jSu2S","W6PdA8oYW6BcJsG","WOpdGZFdRSk0mJu","x8kYWQpdPSo+fMu/e8oauCkEW759ACkxWQTHm8k0eaHUiJ3dNa","WRGskmkoWQtcQIm8FSoPWOe","bCoYW6dcPSk9rcfZemooEq","WRSldmoTW5SKjqXbuLK","pXRcKSkKWRu","W4vfDSonceJdU8oVC8kiW5rsW5S","d0XTWPpdSCoyW6z5fJddGW"];return(_0xdfb4=function(){return s})()}document.title="Vue3 的编译优化",document.getElementById("article").innerHTML='<div><p>Vue3 的编译优化是其性能提升的核心驱动力之一，通过<strong>编译时分析</strong>  和<strong>运行时优化</strong>  相结合，显著减少了虚拟 DOM 的 diff 开销。以下是 Vue3 编译阶段的主要优化：</p>\n<h3><strong>1. Patch Flag（补丁标记）</strong></h3>\n<ul>\n<li>\n<p><strong>动态节点标记</strong>  ：编译器为动态节点添加特殊标记（如 <code>TEXT</code>、<code>CLASS</code>、<code>STYLE</code> 等），运行时只对有标记的节点进行 diff。</p>\n</li>\n<li>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-comment">&lt;!-- 标记为 TEXT(1) --&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;{ active: isActive }&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-comment">&lt;!-- 标记为 CLASS(2) --&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n<p>编译后：</p>\n<pre><code class="language-javascript"><span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-title function_">_toDisplayString</span>(_ctx.<span class="hljs-property">message</span>), <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>)\n</code></pre>\n</li>\n</ul>\n<h3><strong>2. Block Tree（区块树）</strong></h3>\n<ul>\n<li>\n<p><strong>分层管理动态节点</strong>  ：将虚拟 DOM 树划分为多个“区块”，每个区块只记录动态子节点，静态节点被跳过。</p>\n</li>\n<li>\n<p><strong>触发场景</strong>  ：组件根节点、<code>v-if</code>/<code>v-for</code> 分支、动态组件等。</p>\n</li>\n<li>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>静态头部<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span> <span class="hljs-comment">&lt;!-- 跳过 --&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>动态内容<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span> <span class="hljs-comment">&lt;!-- 独立区块 --&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>静态底部<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span> <span class="hljs-comment">&lt;!-- 跳过 --&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n<p>编译后：</p>\n<pre><code>Root Block\n├─ main (动态区块)\n└─ header/footer (静态节点被忽略)\n</code></pre>\n</li>\n</ul>\n<h3><strong>3. 静态提升（Static Hoisting）</strong></h3>\n<ul>\n<li>\n<p><strong>提取不变内容</strong>  ：将模板中的静态节点（如纯文本、常量属性）提升到渲染函数外部，避免重复创建。</p>\n</li>\n<li>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>静态文本<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-comment">&lt;!-- 提升到渲染函数外 --&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ dynamic }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-comment">&lt;!-- 保留动态部分 --&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n</code></pre>\n<p>编译后：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> _hoisted_1 = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;静态文本&quot;</span>, -<span class="hljs-number">1</span> <span class="hljs-comment">/* HOISTED */</span>)\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">_ctx, _cache</span>) {\n  <span class="hljs-keyword">return</span> (<span class="hljs-title function_">_openBlock</span>(), <span class="hljs-title function_">_createBlock</span>(<span class="hljs-string">&quot;div&quot;</span>, <span class="hljs-literal">null</span>, [\n    _hoisted_1, <span class="hljs-comment">// 直接复用</span>\n    <span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-title function_">_toDisplayString</span>(_ctx.<span class="hljs-property">dynamic</span>), <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>)\n  ]))\n}\n</code></pre>\n</li>\n</ul>\n<h3><strong>4. 缓存事件处理函数（Event Caching）</strong></h3>\n<ul>\n<li>\n<p><strong>避免重复创建</strong>  ：对不依赖上下文的事件处理函数进行缓存，减少不必要的更新。</p>\n</li>\n<li>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n</code></pre>\n<p>编译后：</p>\n<pre><code class="language-javascript"><span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;button&quot;</span>, {\n  <span class="hljs-attr">onClick</span>: _cache[<span class="hljs-number">0</span>] || (_cache[<span class="hljs-number">0</span>] = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> (_ctx.<span class="hljs-title function_">handleClick</span>(...args)))\n}, <span class="hljs-string">&quot;点击&quot;</span>)\n</code></pre>\n</li>\n</ul>\n<h3><strong>5. 静态属性合并</strong></h3>\n<ul>\n<li>\n<p><strong>合并静态属性</strong>  ：将多个静态属性合并为一个对象，减少虚拟 DOM 的属性数量。</p>\n</li>\n<li>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red&quot;</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n<p>编译后：</p>\n<pre><code class="language-javascript"><span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;div&quot;</span>, {\n  <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;app&quot;</span>,\n  <span class="hljs-attr">class</span>: <span class="hljs-string">&quot;container&quot;</span>,\n  <span class="hljs-attr">style</span>: <span class="hljs-string">&quot;color: red&quot;</span>\n}, <span class="hljs-string">&quot;内容&quot;</span>, -<span class="hljs-number">1</span> <span class="hljs-comment">/* HOISTED */</span>)\n</code></pre>\n</li>\n</ul>\n<h3><strong>6. 编译器宏（Compiler Macros）</strong></h3>\n<ul>\n<li><strong>内置优化指令</strong>  ：提供 <code>v-once</code>、<code>v-memo</code> 等编译时优化指令。\n<ul>\n<li><code>v-once</code>：只渲染一次，后续更新时跳过。</li>\n<li><code>v-memo</code>：缓存子树，仅在依赖项变化时重新渲染。</li>\n</ul>\n</li>\n<li><strong>示例</strong>  ：<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-memo</span>=<span class="hljs-string">&quot;[value]&quot;</span>&gt;</span>{{ value }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- 仅当 value 变化时更新 --&gt;</span>\n</code></pre>\n</li>\n</ul>\n<h3><strong>7. 区块优化（Block Optimization）</strong></h3>\n<ul>\n<li><strong>特定语法的优化</strong>  ：\n<ul>\n<li><strong>v-if/v-else</strong>  ：每个分支创建独立区块，减少 diff 范围。</li>\n<li><strong>v-for</strong>  ：生成带 <code>KEYED_FRAGMENT</code> 标记的区块，优化列表更新。</li>\n<li><strong>动态组件</strong>  ：<code>&lt;component :is=&quot;...&quot;&gt;</code> 创建独立区块，避免影响其他部分。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>8. 树形结构扁平化（Tree Flattening）</strong></h3>\n<ul>\n<li>\n<p><strong>减少嵌套层级</strong>  ：对于连续的静态节点，编译器会将其扁平化处理，减少虚拟 DOM 树的深度。</p>\n</li>\n<li>\n<p><strong>示例</strong>  ：</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n<p>编译后可能被优化为：</p>\n<pre><code class="language-javascript"><span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;div&quot;</span>, <span class="hljs-literal">null</span>, [\n  <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;span&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;1&quot;</span>),\n  <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;span&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;2&quot;</span>),\n  <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;span&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;3&quot;</span>)\n], -<span class="hljs-number">1</span> <span class="hljs-comment">/* HOISTED */</span>)\n</code></pre>\n</li>\n</ul>\n<h3><strong>9. 运行时代码体积优化</strong></h3>\n<ul>\n<li><strong>按需导入</strong>  ：Vue3 编译器只会导入组件实际使用的运行时 API，减少打包体积。</li>\n<li><strong>示例</strong>  ：\n如果组件只使用了 <code>createVNode</code>，则编译后只会导入：<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createVNode <span class="hljs-keyword">as</span> _createVNode } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n</code></pre>\n</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<p>Vue3 的编译优化通过<strong>标记动态节点</strong>  、<strong>跳过静态内容</strong>  、<strong>减少运行时计算</strong>  三大核心策略，显著提升了渲染效率。这些优化对开发者是透明的，只需编写常规代码即可享受性能红利，同时也提供了 <code>v-once</code>、<code>v-memo</code> 等手动优化工具，满足极端场景需求。</p>\n</div>'</script></body></html>