<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1000(a,n){var t=_0x1085();return(_0x1000=function(n,s){var e=t[n-=474];void 0===_0x1000.EvNbts&&(_0x1000.uDUeEa=function(n,s){var e,o=[],a=0,t="";for(n=(n=>{for(var s,e,o="",a="",t=0,r=0;e=n.charAt(r++);~e&&(s=t%4?64*s+e:e,t++%4)&&(o+=String.fromCharCode(255&s>>(-2*t&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var c=0,l=o.length;c<l;c++)a+="%"+("00"+o.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(a)})(n),r=0;r<256;r++)o[r]=r;for(r=0;r<256;r++)a=(a+o[r]+s.charCodeAt(r%s.length))%256,e=o[r],o[r]=o[a],o[a]=e;for(var r=0,a=0,c=0;c<n.length;c++)e=o[r=(r+1)%256],o[r]=o[a=(a+o[r])%256],o[a]=e,t+=String.fromCharCode(n.charCodeAt(c)^o[(o[r]+o[a])%256]);return t},a=arguments,_0x1000.EvNbts=!0);var n=n+t[0],o=a[n];return o?e=o:(void 0===_0x1000.cbQMoD&&(_0x1000.cbQMoD=!0),e=_0x1000.uDUeEa(e,s),a[n]=e),e})(a,n)}var _0x19e0d8=_0x1000;function _0x1085(){var n=["Emk/WPzCCYpcNW","sb7cVMmHiCkLW480WQlcHZtdNqbHWQlcMCo3DCkLW6KqWQhdR8oEuW","WOZcI8k/W4HIdg9Ghaml","vWpcNSkZewhcQSoiEbBcQbK","W5ddL3NcQrFdTcFdMu8","WOqgi8ogW6ZcQaflFGddUIP/","WRqYW6COW7NcG8oNW5ddUG","nCkOWOdcSNW","WOFcHSoeWPqGiefN","fv7dUgirs8obWOuj","W4hcVuddSmk0dmkmzW","nCkjgCkYCseCv2hdPSo8","mmkdfSk2FxmRyNFdPSodWRy","vapcNmoQyZhcQSoewa","D8oTW4VdTZ06WOeMW5O1CMq","fhZdGbzHbmoBqSkyt8kpW6tcPG","vHLcvCoeW4KRW5pdM2tcSf4","gmkryxBcT10rW6ZcHJJcLmo0","D8oKW4tcHuPQWR0NW70","lmoGW5P3F3O5m8k3WQ1A","s8kDeCksth0CCmo7","umoQWQRcGmoeuSoD","omohrCkZCgO/qCot","WRDAW61hvmkvWOldPmk+WRyj","W4a6W4VdIHlcVa3cO8kYhXVdRa","WPxdPM7dUmk2a8kUra"];return(_0x1085=function(){return n})()}if((()=>{for(var n=_0x1000,s=_0x1085();;)try{if(152379==-parseInt(n(499,"YD0#"))*(-parseInt(n(497,"qQo6"))/2)+parseInt(n(495,"kiii"))/3*(parseInt(n(475,"kiii"))/4)+parseInt(n(491,"#WDH"))/5+parseInt(n(496,"zP8l"))/6+-parseInt(n(484,"&o#G"))/7+parseInt(n(486,"EyeU"))/8*(parseInt(n(489,"b*[F"))/9)+-parseInt(n(498,"xJCZ"))/10)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x19e0d8(493,"5wgJ")](_0x19e0d8(487,"b*[F"))!=_0x19e0d8(474,"1^Wc"))throw window[_0x19e0d8(477,"sZZX")][_0x19e0d8(488,"Bul8")](_0x19e0d8(494,")W9X")),Error();document.title="Webpack 5 在 Tree Shaking 方面确实大幅优化了",document.getElementById("article").innerHTML='<div><p>是的，Webpack 5 在 <strong>Tree Shaking</strong>   方面确实大幅优化了<strong>自动识别副作用（Side Effects）</strong>   的能力，使得开发者可以更高效地移除未使用的代码，而无需手动配置 <code>sideEffects</code> 字段。以下是 Webpack 5 在 Tree Shaking 方面的核心改进和优化策略：</p>\n<hr>\n<h2><strong>1. Webpack 5 的 Tree Shaking 增强</strong></h2>\n<h3><strong>(1) 更深入的静态分析</strong></h3>\n<p>Webpack 5 通过改进的 <strong><code>innerGraph</code></strong>   优化，可以更精确地追踪模块内部的依赖关系，包括：</p>\n<ul>\n<li><strong>嵌套属性访问</strong>   （如 <code>obj.used</code> vs <code>obj.unused</code>）</li>\n<li><strong>模块内部未使用的导出</strong>   （即使它们在同一文件中）</li>\n<li><strong>CommonJS 的部分静态分析</strong>   （如 <code>require</code> 的简单解构）</li>\n</ul>\n<h3><strong>(2) 自动识别副作用</strong></h3>\n<p>Webpack 5 会<strong>自动分析代码是否有副作用</strong>   ，例如：</p>\n<ul>\n<li><strong>直接副作用</strong>   （如 <code>console.log</code>、<code>window.x = 1</code>）会被标记，不会被 Tree Shaking 移除。</li>\n<li><strong>纯函数调用</strong>   （如 <code>/*#__PURE__*/</code> 标记的函数）会被优化。</li>\n</ul>\n<h3><strong>(3) 动态导入的 Tree Shaking</strong></h3>\n<p>Webpack 5 支持对 <code>import()</code> 动态导入的代码进行 Tree Shaking：</p>\n<pre><code class="language-js"><span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackExports: [&quot;used&quot;] */</span> <span class="hljs-string">&quot;./module.js&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">m</span>) =&gt;</span> m.<span class="hljs-title function_">used</span>()); <span class="hljs-comment">// 只保留 `used`，移除未使用的导出</span>\n</code></pre>\n<hr>\n<h2><strong>2. 何时仍需 <code>sideEffects</code> 配置？</strong></h2>\n<p>虽然 Webpack 5 的自动分析能力很强，但以下情况仍需手动配置 <code>sideEffects</code>：</p>\n<h3><strong>(1) 模块整体有副作用</strong></h3>\n<p>例如：</p>\n<ul>\n<li><strong>CSS 文件</strong>   （<code>import \'./styles.css\'</code>）</li>\n<li><strong>Polyfill 或全局初始化脚本</strong>   （<code>import \'regenerator-runtime\'</code>）</li>\n</ul>\n<p>需要在 <code>package.json</code> 中声明：</p>\n<pre><code class="language-json"><span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;sideEffects&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;*.css&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;*.global.js&quot;</span><span class="hljs-punctuation">]</span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n<p>否则 Webpack 可能会误删它们。</p>\n<h3><strong>(2) 第三方库优化</strong></h3>\n<p>某些库（如 <code>lodash</code>）需要 <code>sideEffects: false</code> 来启用完整 Tree Shaking：</p>\n<pre><code class="language-json"><span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;sideEffects&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n<p>否则 Webpack 可能无法优化其未使用的导出。</p>\n<h3><strong>(3) 避免误删必要代码</strong></h3>\n<p>如果代码涉及<strong>动态属性访问</strong>   或<strong>复杂副作用</strong>   ，显式声明 <code>sideEffects</code> 更安全。</p>\n<hr>\n<h2><strong>3. 如何验证 Tree Shaking 是否生效？</strong></h2>\n<h3><strong>(1) 查看编译输出</strong></h3>\n<p>在 <code>webpack.config.js</code> 中启用 <code>usedExports</code>：</p>\n<pre><code class="language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">optimization</span>: {\n    <span class="hljs-attr">usedExports</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 显示哪些导出被使用</span>\n    <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 生产模式默认启用</span>\n  },\n};\n</code></pre>\n<p>编译后，未使用的代码会被标记为 <code>/* unused harmony export */</code>。</p>\n<h3><strong>(2) 使用 <code>webpack-bundle-analyzer</code></strong></h3>\n<pre><code class="language-bash">npm install --save-dev webpack-bundle-analyzer\n</code></pre>\n<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span> =\n  <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack-bundle-analyzer&quot;</span>).<span class="hljs-property">BundleAnalyzerPlugin</span>;\n\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span>()],\n};\n</code></pre>\n<p>运行构建后，可视化分析哪些代码被移除。</p>\n<hr>\n<h2><strong>4. 最佳实践</strong></h2>\n<ol>\n<li><strong>优先依赖 Webpack 5 的自动分析</strong>   ，大多数情况下无需手动配置 <code>sideEffects</code>。</li>\n<li><strong>对第三方库</strong>   ，检查其 <code>package.json</code> 是否支持 Tree Shaking（如 <code>lodash-es</code> 优于 <code>lodash</code>）。</li>\n<li><strong>对 CSS/全局脚本</strong>   ，显式声明 <code>sideEffects</code> 防止误删。</li>\n<li><strong>使用 <code>/*#__PURE__*/</code> 标记无副作用的函数调用</strong>   ：<pre><code class="language-js"><span class="hljs-keyword">const</span> result = <span class="hljs-comment">/*#__PURE__*/</span> <span class="hljs-title function_">calculate</span>(); <span class="hljs-comment">// 提示 Webpack 可安全移除</span>\n</code></pre>\n</li>\n<li><strong>生产模式默认启用 Tree Shaking</strong>   ，无需额外配置。</li>\n</ol>\n<hr>\n<h2><strong>总结</strong></h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Webpack 4</th>\n<th>Webpack 5</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>自动副作用分析</strong></td>\n<td>较弱，依赖 <code>sideEffects</code></td>\n<td><strong>大幅增强</strong>   ，可自动识别</td>\n</tr>\n<tr>\n<td><strong>嵌套属性优化</strong></td>\n<td>不支持</td>\n<td><strong>支持</strong>   （如 <code>obj.used</code> vs <code>obj.unused</code>）</td>\n</tr>\n<tr>\n<td><strong>动态导入 Tree Shaking</strong></td>\n<td>有限支持</td>\n<td><strong>完整支持</strong></td>\n</tr>\n<tr>\n<td><strong>CommonJS 优化</strong></td>\n<td>几乎无优化</td>\n<td><strong>部分静态分析</strong></td>\n</tr>\n</tbody>\n</table>\n<p><strong>结论</strong>   ：</p>\n<ul>\n<li><strong>Webpack 5 的 Tree Shaking 更智能</strong>   ，能自动移除更多无用代码。</li>\n<li><strong>但仍需 <code>sideEffects</code> 配置</strong>   来处理 CSS、第三方库等特殊情况。</li>\n<li><strong>推荐结合 <code>webpack-bundle-analyzer</code> 验证优化效果</strong>   。</li>\n</ul>\n<p>如果你的项目已经升级到 Webpack 5，可以享受更高效的 Tree Shaking，但仍需注意边缘情况的手动优化。 🚀</p>\n</div>'</script></body></html>