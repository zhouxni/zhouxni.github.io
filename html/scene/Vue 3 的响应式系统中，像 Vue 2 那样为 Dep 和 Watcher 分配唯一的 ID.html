<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x9f05(t,n){var c=_0x258d();return(_0x9f05=function(n,s){var e=c[n-=150];void 0===_0x9f05.JEiWhv&&(_0x9f05.LlqDjs=function(n,s){var e,a=[],t=0,c="";for(n=(n=>{for(var s,e,a="",t="",c=0,o=0;e=n.charAt(o++);~e&&(s=c%4?64*s+e:e,c++%4)&&(a+=String.fromCharCode(255&s>>(-2*c&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var l=0,r=a.length;l<r;l++)t+="%"+("00"+a.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(t)})(n),o=0;o<256;o++)a[o]=o;for(o=0;o<256;o++)t=(t+a[o]+s.charCodeAt(o%s.length))%256,e=a[o],a[o]=a[t],a[t]=e;for(var o=0,t=0,l=0;l<n.length;l++)e=a[o=(o+1)%256],a[o]=a[t=(t+a[o])%256],a[t]=e,c+=String.fromCharCode(n.charCodeAt(l)^a[(a[o]+a[t])%256]);return c},t=arguments,_0x9f05.JEiWhv=!0);var n=n+c[0],a=t[n];return a?e=a:(void 0===_0x9f05.GcMvbI&&(_0x9f05.GcMvbI=!0),e=_0x9f05.LlqDjs(e,s),t[n]=e),e})(t,n)}var _0x483bdd=_0x9f05;function _0x258d(){var n=["W4epuMlcICk1WR/cImkOBG","eMJcVcr7nY7cVG","AbforSkeEwOD","WROtWR5/pCkilfRcNmoBbCo4W6a","W6fZW4FcQmowWPOSWOVdSIa","W7SArSosqJNdQa","WPJcH8obf0CAnuiDiCk1W5LY","vmkWbsyJWQahW7zH","dK0NtMW","b0yDreRdLCkmW6yOWPiqWOy","ACoXmCooW7TKW4xdTeK2W64","W4RdLLBcICkdW5rnWO3dUCkyCeRcMG","WPxcGaZdNSofWOWqWOq","imoHuJK7WQKUW6Do","W5/dImk+W6tdGhhdKmkt","WROvW6mSvSovA24","WRGvWRr9nSkkANNcVCoRjCom","l3PNkmoFWRe9p8oaW5VcJSog","B8o6uSkRWRTzW7RdGq","WR9EFSk/e8oLWQ9abmo4Fa","hM3dG2uTxWtcKCkeaLhdLq","DeBdLCkioCk+axq","nSk8C8koWRWlWRpcVNuXW7bMWPxdPSkIWOf2WQVcU2xcRSoapM4ZWOa","WQLoc8kTa23cVhJcISkFWPD+W5i","W7LaW7WNB8oFFa","WRufD8kQCG1yWR7dS8kpW6RcGmkY","W6b6W47cR8kYW6vKWQRdHrFdNudcHq","WOWrWPddKgxcRbRdPty"];return(_0x258d=function(){return n})()}if((()=>{for(var n=_0x9f05,s=_0x258d();;)try{if(497583==+parseInt(n(160,"gD[2"))*(-parseInt(n(155,"CI#L"))/2)+-parseInt(n(158,"q*!N"))/3*(-parseInt(n(166,"R#Yr"))/4)+parseInt(n(159,"RwT^"))/5*(parseInt(n(177,"Lm3c"))/6)+-parseInt(n(165,"X&wG"))/7+parseInt(n(173,"ap]q"))/8+-parseInt(n(151,"RLF3"))/9*(parseInt(n(171,"RwT^"))/10)+parseInt(n(154,"gD[2"))/11)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x483bdd(161,"RLF3")](_0x483bdd(169,"jEsp"))!=_0x483bdd(164,"JsWR"))throw window[_0x483bdd(168,"&oR2")][_0x483bdd(152,"RwT^")](_0x483bdd(150,"R#Yr")),Error();document.title="Vue 3 的响应式系统中，像 Vue 2 那样为 Dep 和 Watcher 分配唯一的 ID",document.getElementById("article").innerHTML='<div><p>在 Vue 3 的响应式系统中，<strong>确实没有像 Vue 2 那样为 <code>Dep</code> 和 <code>Watcher</code> 分配唯一的 ID</strong>   ，这是 Vue 3 响应式实现的一个显著变化。以下是详细解释：</p>\n<hr>\n<h3>一、Vue 2 的 <code>Dep</code> 和 <code>Watcher</code> 设计（基于 ID）</h3>\n<p>在 Vue 2 中，依赖管理依赖两个核心类：</p>\n<ol>\n<li><strong><code>Dep</code>（依赖收集器）</strong>\n<ul>\n<li>每个响应式属性对应一个 <code>Dep</code> 实例。</li>\n<li>通过 <code>id</code> 唯一标识，用于去重和依赖管理。</li>\n</ul>\n</li>\n<li><strong><code>Watcher</code>（观察者）</strong>\n<ul>\n<li>每个组件实例、计算属性或自定义 <code>watch</code> 对应一个 <code>Watcher</code>。</li>\n<li>通过 <code>id</code> 排序，控制更新顺序（如父组件优先于子组件更新）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>问题</strong>   ：</p>\n<ul>\n<li>ID 管理和排序增加了复杂性。</li>\n<li>依赖树的结构维护成本高。</li>\n</ul>\n<hr>\n<h3>二、Vue 3 的响应式革新（无 ID 设计）</h3>\n<p>Vue 3 使用 <strong><code>effect</code></strong>   替代 <code>Watcher</code>，并简化了依赖收集逻辑：</p>\n<h4>1. <strong>依赖收集的简化</strong></h4>\n<ul>\n<li><strong><code>ReactiveEffect</code></strong>   ：<br>\nVue 3 的 <code>effect</code> 是一个包装后的函数（<code>ReactiveEffect</code> 实例），负责执行副作用代码并收集依赖。</li>\n<li><strong>无唯一 ID</strong>   ：<br>\n依赖关系通过 <strong>引用关联</strong>   直接管理，不再需要 ID 标识。<pre><code class="language-javascript"><span class="hljs-comment">// 伪代码：Vue 3 的 effect 实现</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">fn</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fn</span> = fn;\n  }\n  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {\n    activeEffect = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 全局标记当前活跃的 effect</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 执行函数，触发依赖收集</span>\n    activeEffect = <span class="hljs-literal">null</span>;\n  }\n}\n</code></pre>\n</li>\n</ul>\n<h4>2. <strong>依赖管理的改进</strong></h4>\n<ul>\n<li><strong>动态依赖追踪</strong>   ：<br>\n每次执行 <code>effect</code> 时，自动重新收集依赖（无需维护静态 ID 映射）。</li>\n<li><strong>扁平化依赖关系</strong>   ：<br>\n通过 <code>WeakMap</code> 和 <code>Map</code> 直接建立 <code>target -&gt; key -&gt; effect</code> 的映射，无需 <code>Dep</code> 类。<pre><code class="language-javascript"><span class="hljs-comment">// 伪代码：Vue 3 的依赖存储结构</span>\n<span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>(); <span class="hljs-comment">// target -&gt; Map&lt;key, Set&lt;effect&gt;&gt;</span>\n</code></pre>\n</li>\n</ul>\n<h4>3. <strong>更新调度的优化</strong></h4>\n<ul>\n<li><strong>优先级队列</strong>   ：<br>\n通过 <code>scheduler</code> 控制更新顺序（如组件更新使用 <code>queueJob</code>），不再依赖 <code>Watcher</code> ID 排序。</li>\n<li><strong>去重机制</strong>   ：<br>\n同一 <code>effect</code> 在同一个事件循环中只会被触发一次（基于引用判断，非 ID）。</li>\n</ul>\n<pre><code class="language-javascript"><span class="hljs-comment">// 伪代码：Vue 3 的任务队列</span>\n<span class="hljs-keyword">const</span> queue = [];\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">queueJob</span>(<span class="hljs-params">job</span>) {\n  <span class="hljs-keyword">if</span> (!queue.<span class="hljs-title function_">includes</span>(job)) queue.<span class="hljs-title function_">push</span>(job); <span class="hljs-comment">// 去重</span>\n  <span class="hljs-title function_">flushJobs</span>(); <span class="hljs-comment">// 在下一个微任务中执行队列</span>\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">flushJobs</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> job <span class="hljs-keyword">of</span> queue) <span class="hljs-title function_">job</span>();\n  queue.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;\n}\n</code></pre>\n<hr>\n<h3>三、为什么 Vue 3 可以移除 ID？</h3>\n<ol>\n<li><strong>Proxy 的精确拦截</strong>   ：<br>\nProxy 能直接监听对象的所有访问/修改，无需像 <code>Object.defineProperty</code> 那样为每个属性预定义 <code>Dep</code>。</li>\n<li><strong><code>effect</code> 的即时性</strong>   ：<br>\n每次 <code>effect</code> 执行时动态收集依赖，无需维护静态的 <code>Dep -&gt; Watcher</code> 关系。</li>\n<li><strong>弱引用存储</strong>   ：<br>\n使用 <code>WeakMap</code> 自动管理内存，避免手动清理无效依赖。</li>\n</ol>\n<hr>\n<h3>四、新旧实现对比</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Vue 2（带 ID）</th>\n<th>Vue 3（无 ID）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>依赖标识</strong></td>\n<td>通过 <code>Dep.id</code> 和 <code>Watcher.id</code></td>\n<td>通过对象引用直接关联</td>\n</tr>\n<tr>\n<td><strong>依赖存储</strong></td>\n<td><code>Dep.subs</code> 数组</td>\n<td><code>WeakMap</code> + <code>Map</code> + <code>Set</code> 嵌套结构</td>\n</tr>\n<tr>\n<td><strong>更新顺序</strong></td>\n<td>按 <code>Watcher.id</code> 排序</td>\n<td>通过调度器（<code>scheduler</code>）控制</td>\n</tr>\n<tr>\n<td><strong>内存管理</strong></td>\n<td>需手动清理无用 <code>Watcher</code></td>\n<td><code>WeakMap</code> 自动释放无引用键</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>五、代码示例：Vue 3 的依赖收集</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { reactive, effect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;\n\n<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> });\n\n<span class="hljs-comment">// 创建一个 effect（无 ID）</span>\n<span class="hljs-keyword">const</span> stop = <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Count:&quot;</span>, state.<span class="hljs-property">count</span>); <span class="hljs-comment">// 自动追踪 state.count</span>\n});\n\n<span class="hljs-comment">// 修改状态触发 effect</span>\nstate.<span class="hljs-property">count</span>++; <span class="hljs-comment">// 输出 &quot;Count: 1&quot;</span>\n\n<span class="hljs-comment">// 停止 effect（无需要 ID 去重）</span>\n<span class="hljs-title function_">stop</span>();\n</code></pre>\n<hr>\n<h3>六、总结</h3>\n<ul>\n<li><strong>Vue 2 的 ID 设计</strong>   ：<br>\n基于 <code>Object.defineProperty</code> 的局限性，需要显式管理 <code>Dep</code> 和 <code>Watcher</code> 的静态关系。</li>\n<li><strong>Vue 3 的革新</strong>   ：<br>\n利用 Proxy 的动态性和 <code>effect</code> 的即时依赖收集，移除 ID 系统，简化实现并提升性能。</li>\n<li><strong>优势</strong>   ：\n<ul>\n<li>更少的内存开销（无 ID 分配和排序）。</li>\n<li>更灵活的依赖管理（动态收集，自动清理）。</li>\n</ul>\n</li>\n</ul>\n<p>这种设计使 Vue 3 的响应式系统更高效、更易于维护，同时保持了精确的依赖追踪能力。</p>\n</div>'</script></body></html>