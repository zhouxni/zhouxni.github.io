<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2f5f(l,s){var e=_0x17e0();return(_0x2f5f=function(s,n){var a=e[s-=378];void 0===_0x2f5f.xwFoVU&&(_0x2f5f.saSSeY=function(s,n){var a,p=[],l=0,e="";for(s=(s=>{for(var n,a,p="",l="",e=0,t=0;a=s.charAt(t++);~a&&(n=e%4?64*n+a:a,e++%4)&&(p+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=p.length;c<r;c++)l+="%"+("00"+p.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(s),t=0;t<256;t++)p[t]=t;for(t=0;t<256;t++)l=(l+p[t]+n.charCodeAt(t%n.length))%256,a=p[t],p[t]=p[l],p[l]=a;for(var t=0,l=0,c=0;c<s.length;c++)a=p[t=(t+1)%256],p[t]=p[l=(l+p[t])%256],p[l]=a,e+=String.fromCharCode(s.charCodeAt(c)^p[(p[t]+p[l])%256]);return e},l=arguments,_0x2f5f.xwFoVU=!0);var s=s+e[0],p=l[s];return p?a=p:(void 0===_0x2f5f.JOVTEg&&(_0x2f5f.JOVTEg=!0),a=_0x2f5f.saSSeY(a,n),l[s]=a),a})(l,s)}var _0x17b38f=_0x2f5f;function _0x17e0(){var s=["cmoqWOJdPf48wW","WOfxj8kYCW","WQSnWQ1TxHFdR8knuh7cLSo1oW","WR9sFHqkC8oVW7S","W4X3F8kfDCkRW5ZcLxPjhmk1CmkHwmowWP8UgL8Asr/cQHxdPW","W77dOmoMWRi6zSonbmkH","emkrW6JcOCo6WPTfW61cWRuTvCo8","e0C4WRlcPCkAW6nPW6z1W4HxqsW","W6FdGgTzrvKcd1NdV8o5W4C","W47cSraiW4lcJNZdISknW6VdM8k+","gmknfZxdGgtcNLq","q2H/WRDNdmk+WQeLFG3cUq","W5rWdmogWRidWQ5CWOi","pSk1x8kvWRBcNbfIq8ogW7KVjG","DmoVfmoXFmkjWR/cNYOAlmk4W5yu","sLHXC8ovW7aHka","W6VcMmote8ktWO4cWRPNWRz+","W6JcNSoqemkqW4TAWOf0WQrGWPm+","eu80W7/dPCoVWRmyW7i","gWnuW6LMW7xdHqy","WP4PqmogW7PqW57cMCkZW4TIqa","WPC7W4VcMGhcMhi","W6VcMmosemksW4rCWRjXWQbsWQ0S","W43cSbumW4FdHxhdG8k0W7RdQG","WQJcNSolWQ/dSe4HWP16WOi","W4pdOa7dV8oTwmkOWRxcSha","tSkaW7aVqtRdLmkBfCoRbhVdTa","bLJdGmkgW7SHaa4"];return(_0x17e0=function(){return s})()}if((()=>{for(var s=_0x2f5f,n=_0x17e0();;)try{if(536480==-parseInt(s(393,"UU1N"))*(-parseInt(s(387,"U686"))/2)+parseInt(s(386,"Wcf("))/3+parseInt(s(401,"5ZzF"))/4+parseInt(s(378,"5ZzF"))/5+-parseInt(s(404,"5NC@"))/6*(-parseInt(s(389,"Ke$Z"))/7)+-parseInt(s(381,"XsA2"))/8*(-parseInt(s(379,"UU1N"))/9)+parseInt(s(399,"e2O3"))/10*(-parseInt(s(398,"BoF&"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x17b38f(384,"ERsV")](_0x17b38f(396,"%JHa"))!=_0x17b38f(385,"k7a["))throw window[_0x17b38f(383,"1B%5")][_0x17b38f(405,"o)%b")](_0x17b38f(388,"9Yf@")),Error();document.title="什么是虚拟DOM，如何实现一个虚拟DOM",document.getElementById("article").innerHTML='<div><h3>什么是虚拟DOM？</h3>\n<p>虚拟DOM（Virtual DOM）是一种在内存中表示真实DOM树的轻量级JavaScript对象。它是对真实DOM的抽象，通过以JavaScript对象的形式来描述DOM结构，使得对DOM的操作可以在内存中进行，而无需直接操作真实的DOM树。当状态发生变化时，虚拟DOM会生成一个新的虚拟DOM树，与旧的虚拟DOM树进行差异比较（即Diff算法），找出需要更新的部分，然后批量更新到真实DOM上，从而提高渲染效率。</p>\n<h3>虚拟DOM的优势</h3>\n<ol>\n<li><strong>提高渲染效率</strong>  ：通过批量更新真实DOM，减少直接操作真实DOM的次数，降低重排和重绘的开销。</li>\n<li><strong>跨平台</strong>  ：虚拟DOM与平台无关，可以在不同环境中运行，如浏览器、Native应用等。</li>\n<li><strong>便于实现复杂功能</strong>  ：如组件化、状态管理等，虚拟DOM为这些功能提供了良好的基础。</li>\n</ol>\n<h3>如何实现一个虚拟DOM？</h3>\n<p>实现一个虚拟DOM系统涉及以下几个关键步骤：</p>\n<h4>1. 创建虚拟DOM节点</h4>\n<p>首先，需要定义虚拟DOM节点的结构。一个虚拟DOM节点可以是一个普通的JavaScript对象，包含标签名、属性、子节点等信息。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-params">tag, props, children</span>) {\n  <span class="hljs-keyword">return</span> {\n    tag,\n    props,\n    children\n  };\n}\n</code></pre>\n<h4>2. 渲染虚拟DOM到真实DOM</h4>\n<p>接下来，需要实现一个函数，将虚拟DOM节点渲染到真实DOM上。这个函数需要递归地处理子节点。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">vnode, container</span>) {\n  <span class="hljs-comment">// 如果vnode是一个字符串，则直接创建文本节点</span>\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vnode === <span class="hljs-string">&#x27;string&#x27;</span>) {\n    <span class="hljs-keyword">return</span> container.<span class="hljs-title function_">appendChild</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(vnode));\n  }\n\n  <span class="hljs-comment">// 创建真实DOM元素</span>\n  <span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">tag</span>);\n\n  <span class="hljs-comment">// 设置属性</span>\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> vnode.<span class="hljs-property">props</span>) {\n    <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">props</span>.<span class="hljs-title function_">hasOwnProperty</span>(key)) {\n      el.<span class="hljs-title function_">setAttribute</span>(key, vnode.<span class="hljs-property">props</span>[key]);\n    }\n  }\n\n  <span class="hljs-comment">// 递归渲染子节点</span>\n  vnode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> {\n    <span class="hljs-title function_">render</span>(child, el);\n  });\n\n  <span class="hljs-comment">// 将元素添加到容器中</span>\n  container.<span class="hljs-title function_">appendChild</span>(el);\n\n  <span class="hljs-keyword">return</span> el;\n}\n</code></pre>\n<h4>3. 实现Diff算法</h4>\n<p>Diff算法是虚拟DOM的核心，用于比较新旧虚拟DOM树的差异。这里可以实现一个简单的Diff算法，只处理同层级节点的比较。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">diff</span>(<span class="hljs-params">oldVnode, newVnode</span>) {\n  <span class="hljs-keyword">const</span> patches = [];\n\n  <span class="hljs-title function_">walk</span>(oldVnode, newVnode, patches, <span class="hljs-number">0</span>);\n\n  <span class="hljs-keyword">return</span> patches;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">oldVnode, newVnode, patches, index</span>) {\n  <span class="hljs-keyword">const</span> currentPatch = [];\n\n  <span class="hljs-comment">// 如果新节点不存在，表示需要删除旧节点</span>\n  <span class="hljs-keyword">if</span> (!newVnode) {\n    currentPatch.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;REMOVE&#x27;</span>, index });\n  }\n  <span class="hljs-comment">// 如果节点类型不同，表示需要替换节点</span>\n  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> oldVnode === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> newVnode === <span class="hljs-string">&#x27;string&#x27;</span>) {\n    <span class="hljs-keyword">if</span> (oldVnode !== newVnode) {\n      currentPatch.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;TEXT&#x27;</span>, <span class="hljs-attr">text</span>: newVnode });\n    }\n  }\n  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldVnode.<span class="hljs-property">tag</span> === newVnode.<span class="hljs-property">tag</span>) {\n    <span class="hljs-comment">// 比较属性</span>\n    <span class="hljs-keyword">const</span> propPatches = <span class="hljs-title function_">diffProps</span>(oldVnode.<span class="hljs-property">props</span>, newVnode.<span class="hljs-property">props</span>);\n    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(propPatches).<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {\n      currentPatch.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;PROPS&#x27;</span>, <span class="hljs-attr">props</span>: propPatches });\n    }\n\n    <span class="hljs-comment">// 比较子节点</span>\n    <span class="hljs-title function_">diffChildren</span>(oldVnode.<span class="hljs-property">children</span>, newVnode.<span class="hljs-property">children</span>, patches);\n  } <span class="hljs-keyword">else</span> {\n    currentPatch.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;REPLACE&#x27;</span>, <span class="hljs-attr">node</span>: newVnode });\n  }\n\n  <span class="hljs-keyword">if</span> (currentPatch.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {\n    patches[index] = currentPatch;\n  }\n}\n\n<span class="hljs-comment">// 简化版的属性比较和子节点比较函数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">diffProps</span>(<span class="hljs-params">oldProps, newProps</span>) {\n  <span class="hljs-keyword">const</span> patches = {};\n\n  <span class="hljs-comment">// 找出需要更新的属性</span>\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> newProps) {\n    <span class="hljs-keyword">if</span> (newProps.<span class="hljs-title function_">hasOwnProperty</span>(key) &amp;&amp; newProps[key] !== oldProps[key]) {\n      patches[key] = newProps[key];\n    }\n  }\n\n  <span class="hljs-comment">// 找出需要删除的属性（这里简化处理，只考虑新增和更新的属性）</span>\n\n  <span class="hljs-keyword">return</span> patches;\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">diffChildren</span>(<span class="hljs-params">oldChildren, newChildren, patches</span>) {\n  <span class="hljs-keyword">const</span> childPatches = [];\n  oldChildren.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">child, idx</span>) =&gt;</span> {\n    <span class="hljs-title function_">walk</span>(child, newChildren[idx], childPatches, idx);\n  });\n\n  <span class="hljs-comment">// 处理新增的子节点（这里简化处理，假设子节点数量相同或只处理已有索引）</span>\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = oldChildren.<span class="hljs-property">length</span>; i &lt; newChildren.<span class="hljs-property">length</span>; i++) {\n    childPatches.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD&#x27;</span>, <span class="hljs-attr">node</span>: newChildren[i] });\n  }\n\n  <span class="hljs-keyword">if</span> (childPatches.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {\n    patches.<span class="hljs-title function_">push</span>(...childPatches);\n  }\n}\n</code></pre>\n<p><strong>注意</strong>  ：上述Diff算法是一个简化版本，实际的虚拟DOM库（如React、Vue）中的Diff算法会更加复杂和高效，处理更多边缘情况和优化性能。</p>\n<h4>4. 应用补丁更新真实DOM</h4>\n<p>最后，需要实现一个函数，根据Diff算法生成的补丁（patches）来更新真实DOM。</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">applyPatches</span>(<span class="hljs-params">el, patches</span>) {\n  patches.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">patch</span> =&gt;</span> {\n    <span class="hljs-comment">// 根据补丁类型更新DOM</span>\n    <span class="hljs-keyword">if</span> (patch.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;REMOVE&#x27;</span>) {\n      el.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(el);\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (patch.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;TEXT&#x27;</span>) {\n      el.<span class="hljs-property">textContent</span> = patch.<span class="hljs-property">text</span>;\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (patch.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;PROPS&#x27;</span>) {\n      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> patch.<span class="hljs-property">props</span>) {\n        el.<span class="hljs-title function_">setAttribute</span>(key, patch.<span class="hljs-property">props</span>[key]);\n      }\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (patch.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;REPLACE&#x27;</span>) {\n      <span class="hljs-keyword">const</span> newEl = <span class="hljs-title function_">render</span>(patch.<span class="hljs-property">node</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>)); <span class="hljs-comment">// 临时容器</span>\n      el.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">replaceChild</span>(newEl, el);\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (patch.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;ADD&#x27;</span>) {\n      <span class="hljs-comment">// 处理新增子节点（这里简化处理，假设补丁包含新节点）</span>\n      <span class="hljs-keyword">const</span> newEl = <span class="hljs-title function_">render</span>(patch.<span class="hljs-property">node</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>)); <span class="hljs-comment">// 临时容器</span>\n      el.<span class="hljs-title function_">appendChild</span>(newEl);\n    }\n    <span class="hljs-comment">// 注意：这里简化了子节点的更新逻辑，实际实现中需要更复杂的处理</span>\n  });\n}\n</code></pre>\n<h3>总结</h3>\n<p>实现一个虚拟DOM系统涉及创建虚拟DOM节点、渲染虚拟DOM到真实DOM、实现Diff算法以及应用补丁更新真实DOM等关键步骤。虽然上述实现是一个简化版本，但它展示了虚拟DOM的基本原理和工作流程。在实际应用中，虚拟DOM库会处理更多复杂情况，并提供更高效的Diff算法和DOM更新机制。</p>\n</div>'</script></body></html>