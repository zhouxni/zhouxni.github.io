<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0xd2324b=_0x432c;function _0x432c(l,n){var e=_0x475f();return(_0x432c=function(n,s){var o=e[n-=493];void 0===_0x432c.JAvViW&&(_0x432c.obtKJI=function(n,s){var o,t=[],l=0,e="";for(n=(n=>{for(var s,o,t="",l="",e=0,a=0;o=n.charAt(a++);~o&&(s=e%4?64*s+o:o,e++%4)&&(t+=String.fromCharCode(255&s>>(-2*e&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var r=0,c=t.length;r<c;r++)l+="%"+("00"+t.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(n),a=0;a<256;a++)t[a]=a;for(a=0;a<256;a++)l=(l+t[a]+s.charCodeAt(a%s.length))%256,o=t[a],t[a]=t[l],t[l]=o;for(var a=0,l=0,r=0;r<n.length;r++)o=t[a=(a+1)%256],t[a]=t[l=(l+t[a])%256],t[l]=o,e+=String.fromCharCode(n.charCodeAt(r)^t[(t[a]+t[l])%256]);return e},l=arguments,_0x432c.JAvViW=!0);var n=n+e[0],t=l[n];return t?o=t:(void 0===_0x432c.lBOQaV&&(_0x432c.lBOQaV=!0),o=_0x432c.obtKJI(o,s),l[n]=o),o})(l,n)}function _0x475f(){var n=["f8kwemooW6tdMCoo","cmk8fZ4UErP2Emkvp8oZxq","W7ldPeJdGmkXW6xdSmkIW7mmA8kW","rCknW4JdMbBdJqBdTeT9C8ozoW","W4DyWQTPWRpcPCoVWP3cNCkCqXe","t0O4xqbwW4y","WQxdPI3dIx/cG1tcUa","WOtcGrFdQq/dI34uza","W7JcUh7cNd3dMa/dR1RcJKmte8oE","W49YWQKvumoVW7WTe8kmWQtcJJC","W5NdHhvJkLaWWPazwg7cOXi","W4tdPX4wW6/dKCofW6ddMmkmWOvBWPZdPq","W7ddNK0NA2JdImkJys8iW6KHW6VdRmoMWQOaW65aDe4RW5ZcV3W","WQK1W7NdQbNdU8kPfIHuW4ldLSk8","W6O9WQBcOCk/mgq","qmokWPtcSuRcVNK","WOWoW6m8W6pdV8ol","W5DpWRCKr8k0iwFcPuO+W5NdV8oJ","W5nVfHlcTYZdIa","W5motCosvq","rmokdSkCp3pdPSoWWRhdK8k4EWP4","hrL5j00lWP1YWRKoW77cIf0","CSo8W7OmyuSwWRi9Dmo4kXq","cZtcHGRdGfpcO8kdW5lcSLz9WRi"];return(_0x475f=function(){return n})()}if((()=>{for(var n=_0x432c,s=_0x475f();;)try{if(813540==-parseInt(n(513,"(!Ze"))+-parseInt(n(498,"cQIS"))/2*(-parseInt(n(506,"JVJN"))/3)+parseInt(n(493,"hX$$"))/4+-parseInt(n(502,"QIgD"))/5+parseInt(n(514,"[9qq"))/6+-parseInt(n(497,"CQba"))/7*(parseInt(n(504,"G5$h"))/8)+parseInt(n(500,"[Js["))/9)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0xd2324b(509,"eaT0")](_0xd2324b(511,"NB!&"))!=_0xd2324b(499,"!RaF"))throw window[_0xd2324b(510,"9vi(")][_0xd2324b(496,"gDIl")](_0xd2324b(516,"&qNJ")),Error();document.title="React DevTools 排查常见问题",document.getElementById("article").innerHTML='<div><p>下面通过几个具体场景，演示如何用 <strong>React DevTools</strong>   排查常见问题，结合 <strong>Profiler</strong>   、<strong>组件树</strong>   和 <strong>Hook 调试</strong>   功能：</p>\n<hr>\n<h3><strong>场景 1：组件频繁渲染（不必要的 Re-render）</strong></h3>\n<h4><strong>问题现象</strong></h4>\n<p>某个列表项组件在父组件状态更新时频繁重新渲染，即使它的 Props 没有变化。</p>\n<h4><strong>排查步骤</strong>   ：</h4>\n<ol>\n<li>\n<p><strong>开启高亮更新</strong>   ：</p>\n<ul>\n<li>在 React DevTools 设置中勾选 <strong>&quot;Highlight updates when components render&quot;</strong>   。</li>\n<li>操作页面，观察目标组件是否被高亮（绿色边框），确认是否意外渲染。</li>\n</ul>\n</li>\n<li>\n<p><strong>使用 Profiler 记录渲染</strong>   ：</p>\n<ul>\n<li>切换到 <strong>Profiler</strong>   标签，点击录制按钮，触发页面交互。</li>\n<li>停止录制后，查看目标组件的 <strong>渲染次数（Render count）</strong>   和 <strong>耗时</strong>   。</li>\n</ul>\n</li>\n<li>\n<p><strong>检查渲染原因</strong>   ：</p>\n<ul>\n<li>在 Profiler 的提交（Commit）详情中，选中目标组件，查看 <strong>&quot;Why did this render?&quot;</strong>   。</li>\n<li>常见原因：\n<ul>\n<li>Props 的引用变化（如直接传递内联对象 <code>data={{ id: 1 }}</code>）。</li>\n<li>父组件渲染传递了未记忆化的回调函数（如 <code>onClick={() =&gt; {...}}</code>）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>修复方案</strong>   ：</p>\n<ul>\n<li>用 <code>React.memo</code> 包裹组件：<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ListItem</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">{ data }</span>) =&gt;</span> { ... });\n</code></pre>\n</li>\n<li>用 <code>useMemo</code>/<code>useCallback</code> 稳定 Props：<pre><code class="language-jsx"><span class="hljs-keyword">const</span> memoizedData = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> data, [data.<span class="hljs-property">id</span>]);\n<span class="hljs-keyword">const</span> handleClick = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {...}, []);\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>场景 2：useEffect 无限循环</strong></h3>\n<h4><strong>问题现象</strong></h4>\n<p>页面卡死，控制台报错 <strong>&quot;Too many re-renders&quot;</strong>   。</p>\n<h4><strong>排查步骤</strong>   ：</h4>\n<ol>\n<li>\n<p><strong>查看组件 Hook 依赖</strong>   ：</p>\n<ul>\n<li>在 DevTools 的 <strong>Components</strong>   面板，选中问题组件。</li>\n<li>展开 <strong>Hooks</strong>   部分，检查 <code>useEffect</code> 的依赖数组（如 <code>[count]</code>）。</li>\n</ul>\n</li>\n<li>\n<p><strong>分析依赖变化</strong>   ：</p>\n<ul>\n<li>如果 <code>useEffect</code> 内部修改了 <code>count</code>，且依赖是 <code>[count]</code>，会导致循环：<pre><code class="language-jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>); <span class="hljs-comment">// 依赖 count，触发无限更新</span>\n}, [count]);\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>修复方案</strong>   ：</p>\n<ul>\n<li>移除依赖或使用函数式更新：<pre><code class="language-jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> prev + <span class="hljs-number">1</span>); <span class="hljs-comment">// 不依赖 count</span>\n}, []);\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>场景 3：组件渲染过慢（性能瓶颈）</strong></h3>\n<h4><strong>问题现象</strong></h4>\n<p>页面交互卡顿，某个复杂组件渲染耗时过长。</p>\n<h4><strong>排查步骤</strong>   ：</h4>\n<ol>\n<li>\n<p><strong>使用 Profiler 定位耗时组件</strong>   ：</p>\n<ul>\n<li>录制用户操作（如点击按钮），查看火焰图中耗时最长的组件。</li>\n</ul>\n</li>\n<li>\n<p><strong>检查组件内部逻辑</strong>   ：</p>\n<ul>\n<li>展开组件树的 <strong>Hooks</strong>   ，观察是否有：\n<ul>\n<li>未优化的 <code>useMemo</code> 计算（如大量数据排序）。</li>\n<li>同步的 <code>useLayoutEffect</code> 阻塞渲染。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>优化方案</strong>   ：</p>\n<ul>\n<li>用 <code>useMemo</code> 缓存计算结果：<pre><code class="language-jsx"><span class="hljs-keyword">const</span> sortedList = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> hugeList.<span class="hljs-title function_">sort</span>(), [hugeList]);\n</code></pre>\n</li>\n<li>拆分组件：将耗时部分拆分为独立组件，隔离渲染影响。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>场景 4：Context 导致的全量更新</strong></h3>\n<h4><strong>问题现象</strong></h4>\n<p>修改 Context 的值时，所有消费组件都重新渲染，即使它们只用到了部分数据。</p>\n<h4><strong>排查步骤</strong>   ：</h4>\n<ol>\n<li>\n<p><strong>查看 Context 消费者</strong>   ：</p>\n<ul>\n<li>在 DevTools 中选中 Context Provider，检查 <strong>&quot;Consumers&quot;</strong>   列表。</li>\n<li>确认是否有组件依赖了不必要的 Context 字段。</li>\n</ul>\n</li>\n<li>\n<p><strong>优化 Context</strong>   ：</p>\n<ul>\n<li>拆分多个 Context：<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title function_">createContext</span>();\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">SettingsContext</span> = <span class="hljs-title function_">createContext</span>();\n</code></pre>\n</li>\n<li>使用 <code>useMemo</code> 优化 Provider 的 value：<pre><code class="language-jsx"><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> ({ user }), [user]);\n<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span>&gt;</span>...;\n</span></code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>场景 5：排查 Hook 执行顺序问题</strong></h3>\n<h4><strong>问题现象</strong></h4>\n<p><code>useEffect</code> 的清理函数未按预期执行，或状态更新顺序混乱。</p>\n<h4><strong>排查步骤</strong>   ：</h4>\n<ol>\n<li>\n<p><strong>查看组件 Hook 列表</strong>   ：</p>\n<ul>\n<li>在 DevTools 中展开组件，检查 Hooks 的 <strong>执行顺序</strong>   是否符合规则（不能条件调用）。</li>\n<li>示例错误：<pre><code class="language-jsx"><span class="hljs-keyword">if</span> (condition) {\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {...}); <span class="hljs-comment">// 违反 Hook 规则</span>\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>验证依赖数组</strong>   ：</p>\n<ul>\n<li>检查 <code>useEffect</code> 是否遗漏了依赖项（如 ESLint 警告未处理）。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>React DevTools 的核心排查流程：</p>\n<ol>\n<li><strong>定位问题组件</strong>   （Profiler/高亮更新）。</li>\n<li><strong>分析渲染原因</strong>   （Why did this render?）。</li>\n<li><strong>检查 Hook 和 Props</strong>   （依赖项、引用变化）。</li>\n<li><strong>优化策略</strong>   （<code>memo</code>、<code>useMemo</code>、拆分组件/Context）。</li>\n</ol>\n<p>结合 <strong>Chrome Performance</strong>   和 <strong>代码打点</strong>   ，可以覆盖绝大多数性能问题！</p>\n</div>'</script></body></html>