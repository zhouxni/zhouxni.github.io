<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x238e9c=_0x50c7;function _0x50c7(l,s){var p=_0x5584();return(_0x50c7=function(s,n){var a=p[s-=475];void 0===_0x50c7.pUqVsg&&(_0x50c7.dwefsK=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,c=0;a=s.charAt(c++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,o=t.length;e<o;e++)l+="%"+("00"+t.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(l)})(s),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)l=(l+t[c]+n.charCodeAt(c%n.length))%256,a=t[c],t[c]=t[l],t[l]=a;for(var c=0,l=0,e=0;e<s.length;e++)a=t[c=(c+1)%256],t[c]=t[l=(l+t[c])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(e)^t[(t[c]+t[l])%256]);return p},l=arguments,_0x50c7.pUqVsg=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x50c7.ZNcdGn&&(_0x50c7.ZNcdGn=!0),a=_0x50c7.dwefsK(a,n),l[s]=a),a})(l,s)}function _0x5584(){var s=["WQldKv7cPbpcNcS","bCk6WRPFx8oyW75oWOddTZRdI8ku","WP/dMmk4wuOAWRRcG8oaeSk5WPNdUa","Bh3cVCoLg8oeW5/cIsjGW6iFmq","W5KxxSk0W63dV8oJW58/W7/dKSoIpW","WQKFf8k3CW","amk6WRvAw8oBW7eSWQFdLqFdSCkcda","W6BcOSk+W7JdPSkOo8oDuKXgdWK","j8koW4BdISo0W6LXW5HZvCkIFq","iXujgN3dNmoAW5tcSa","WRRdQbxcSq17Eq","W7SADYD8gvO6W5/cMmk1tmkhWPehWR4fwvVdHKtcP8oyW7NcIXO","jhpdM8kSWPe/s3hcPHeCl8of","WOvpEIGlW5FcQG","s8kRWRpcS8kfWQH4WQ45sehcUW","E3SXdh7dI8kromk8CuHcta","CmkdW63dL8orgSoOuG","W5pcTCk1Fe0klSk3","zCkBDmoHW5tdRaNdUCo2WR8YW6K","jCkmW43dJ8o1W6WQW65bvmkzr8o2","W6e9d8kjuGxdMW","W7pdNGbCBmkdW4/cSeNdUgiUWOuB","smkTWRJcT8kbWQH0WR48yehcMa","qCo5xe8rWO3cHW","WRRcT3hdT8k6yri","fhBdPrCyffVdNG"];return(_0x5584=function(){return s})()}if((()=>{for(var s=_0x50c7,n=_0x5584();;)try{if(999249==+parseInt(s(491,"1CPW"))*(-parseInt(s(475,"IYUP"))/2)+-parseInt(s(478,"SYLn"))/3+parseInt(s(479,"uxW*"))/4+parseInt(s(489,"65Hl"))/5+parseInt(s(476,"r4wW"))/6*(-parseInt(s(499,"1CPW"))/7)+-parseInt(s(497,"]FJ7"))/8*(parseInt(s(480,"vWXU"))/9)+parseInt(s(483,"SYLn"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x238e9c(500,"H2P3")](_0x238e9c(486,"gkyg"))!=_0x238e9c(482,"]FJ7"))throw window[_0x238e9c(494,"c*([")][_0x238e9c(477,"9Eps")](_0x238e9c(488,"1iW@")),Error();document.title="JSX  并非 React 专有语法",document.getElementById("article").innerHTML='<div><p>你是对的，JSX <strong>并非 React 专有语法</strong>  ，而是一种可被编译的 JavaScript 语法扩展。虽然 React 是 JSX 最著名的使用者，但 JSX 本身是中立的，可以被其他库或框架采用。</p>\n<h3><strong>JSX 的本质</strong></h3>\n<p>JSX 是一种<strong>语法糖</strong>  ，它允许在 JavaScript 代码中编写类似 XML 的结构。其核心是通过编译器将 JSX 转换为普通 JavaScript 函数调用。例如：</p>\n<pre><code class="language-jsx"><span class="hljs-comment">// JSX 代码</span>\n<span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;\n\n<span class="hljs-comment">// 可编译为任意函数调用，不一定要用 React</span>\n<span class="hljs-keyword">const</span> element = <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;h1&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Hello, world!&quot;</span>);\n</code></pre>\n<h3><strong>非 React 的 JSX 实现</strong></h3>\n<ol>\n<li><strong>Preact</strong><br>\n轻量级 React 替代品，同样支持 JSX：<pre><code class="language-jsx"><span class="hljs-comment">// Preact 使用 h() 函数而非 React.createElement</span>\n<span class="hljs-keyword">import</span> { h, render } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;preact&quot;</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello from Preact!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n</code></pre>\n</li>\n<li><strong>SolidJS</strong><br>\n高性能响应式库，使用 JSX 但运行机制与 React 不同：<pre><code class="language-jsx"><span class="hljs-keyword">import</span> { createSignal } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;solid-js&quot;</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">Counter</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">createSignal</span>(<span class="hljs-number">0</span>);\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count() + 1)}&gt;{count()}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n};\n</code></pre>\n</li>\n<li><strong>自定义实现</strong><br>\n你甚至可以为自己的库定义 JSX 转换函数：<pre><code class="language-javascript"><span class="hljs-comment">// 自定义 JSX 工厂函数</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-params">type, props, ...children</span>) {\n  <span class="hljs-keyword">return</span> { type, props, children };\n}\n\n<span class="hljs-comment">// 配置 Babel 指向自定义工厂</span>\n<span class="hljs-comment">/** <span class="hljs-doctag">@jsx</span> createElement */</span>\n<span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Custom JSX!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n</code></pre>\n</li>\n</ol>\n<h3><strong>JSX 与 React 的关系</strong></h3>\n<p>React 是 JSX 最广泛的使用者，但需要明确：</p>\n<ul>\n<li><strong>React 默认使用 <code>React.createElement()</code></strong>   作为 JSX 编译目标。</li>\n<li><strong>React 17+ 引入新 JSX 转换</strong>  ：<br>\n不再需要手动导入 React，而是使用内置的 <code>jsx</code> 函数：<pre><code class="language-jsx"><span class="hljs-comment">// React 17+ 无需 import React</span>\n<span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;\n</code></pre>\n</li>\n</ul>\n<h3><strong>JSX 编译配置</strong></h3>\n<p>通过 Babel 或 TypeScript 配置，可以指定 JSX 转换的目标函数：</p>\n<h4><strong>Babel 配置（.babelrc）</strong></h4>\n<pre><code class="language-json"><span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>\n    <span class="hljs-punctuation">[</span>\n      <span class="hljs-string">&quot;@babel/plugin-transform-react-jsx&quot;</span><span class="hljs-punctuation">,</span>\n      <span class="hljs-punctuation">{</span>\n        <span class="hljs-attr">&quot;pragma&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;createElement&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 指定 JSX 工厂函数</span>\n        <span class="hljs-attr">&quot;pragmaFrag&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Fragment&quot;</span>\n      <span class="hljs-punctuation">}</span>\n    <span class="hljs-punctuation">]</span>\n  <span class="hljs-punctuation">]</span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n<h4><strong>TypeScript 配置（tsconfig.json）</strong></h4>\n<pre><code class="language-json"><span class="hljs-punctuation">{</span>\n  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>\n    <span class="hljs-attr">&quot;jsx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-jsx&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// React 17+ 新转换</span>\n    <span class="hljs-attr">&quot;jsxImportSource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;preact&quot;</span> <span class="hljs-comment">// 若使用 Preact</span>\n  <span class="hljs-punctuation">}</span>\n<span class="hljs-punctuation">}</span>\n</code></pre>\n<h3><strong>总结</strong></h3>\n<p>JSX 是一种独立的语法规范，<strong>不绑定任何框架</strong>  。它的核心是通过编译将类 XML 语法转换为 JavaScript 函数调用。React 只是最流行的 JSX 使用者，而现代前端生态中，许多其他库也在采用 JSX 来提升开发体验。</p>\n</div>'</script></body></html>