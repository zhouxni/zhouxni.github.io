<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x2c74(t,s){var o=_0x972f();return(_0x2c74=function(s,n){var a=o[s-=311];void 0===_0x2c74.KclrpJ&&(_0x2c74.oTTfKH=function(s,n){var a,l=[],t=0,o="";for(s=(s=>{for(var n,a,l="",t="",o=0,p=0;a=s.charAt(p++);~a&&(n=o%4?64*n+a:a,o++%4)&&(l+=String.fromCharCode(255&n>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,c=l.length;e<c;e++)t+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(t)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)t=(t+l[p]+n.charCodeAt(p%n.length))%256,a=l[p],l[p]=l[t],l[t]=a;for(var p=0,t=0,e=0;e<s.length;e++)a=l[p=(p+1)%256],l[p]=l[t=(t+l[p])%256],l[t]=a,o+=String.fromCharCode(s.charCodeAt(e)^l[(l[p]+l[t])%256]);return o},t=arguments,_0x2c74.KclrpJ=!0);var s=s+o[0],l=t[s];return l?a=l:(void 0===_0x2c74.SYwZad&&(_0x2c74.SYwZad=!0),a=_0x2c74.oTTfKH(a,n),t[s]=a),a})(t,s)}function _0x972f(){var s=["W6tdMKxcLSksvCoNiCodWQZdPCoY","W7qLxSoGEX7dRmonW6iyCmkq","WQrJhCkLpHZcRmkxW7uACSkeW71vrKlcON7cQvtdTSkdcCkOFgG","WP3cOCkwAwfMDq","j8oKW4j3rW","jSowWRy+WRqFew1cd8oLWRG","WR5YgCk5lexdPG","tLvuh8oWlK3dOKe","eSkeW49GW5qbWO5IxMVdGSoygW","AConW4pcKen6uJ/dVtFcM8kTW7y","WPOeW6BdOCkhWOW4iCklz8o8W44","W5NdK8oZW4BcTmogWOdcJW","f8kcW41QW5CfW6L8v1xdQmo6","W5PMpWNdM8oAmW","WP5xvJ0iEbjTg8obWPvc","nmkvWPBdGGaIdJu","WO7cNGSIWQRcNmkK","W74GwmoTFHFdSSo/W60NuCkd","W5FdLWxdPCk/vSkbn8obW5HdWPW","W4VdK0PnW6XDW4NdKq","W6ddNexcLSkuv8oSf8oHWRpdL8oU","W7dcI8kPt8o1WRbkWOxcVvrFWQJdPG","W6tdHCo5WRFdRhTwW6aYW6ZdLCkLlq","oWCdq8k3AfldVuhcLXjT"];return(_0x972f=function(){return s})()}var _0x371602=_0x2c74;if((()=>{for(var s=_0x2c74,n=_0x972f();;)try{if(168869==+parseInt(s(319,"l&tn"))+parseInt(s(321,"^4oN"))/2*(parseInt(s(314,"7V7O"))/3)+-parseInt(s(330,"K6Dz"))/4+parseInt(s(324,"mwfd"))/5+-parseInt(s(323,"FX81"))/6+parseInt(s(334,"dfS4"))/7+-parseInt(s(315,"aaf#"))/8*(parseInt(s(312,"1mIU"))/9))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x371602(317,"lqL@")](_0x371602(332,"mwfd"))!=_0x371602(329,"#48Q"))throw window[_0x371602(316,"dfS4")][_0x371602(331,"qYX0")](_0x371602(327,"qYX0")),Error();document.title="在 React 中可以做哪些性能优化",document.getElementById("article").innerHTML='<div><p>在 React 中，性能优化是一个重要的主题，尤其是在构建大型或复杂应用时。以下是一些常见的 React 性能优化策略，按照不同的优化方向进行分类和详细说明：</p>\n<hr>\n<h3><strong>一、减少不必要的渲染</strong></h3>\n<ol>\n<li><strong>使用 <code>React.memo</code></strong>  ：\n<ul>\n<li><strong>作用</strong>  ：防止函数组件在 props 未变化时重新渲染。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {\n  <span class="hljs-comment">// 组件逻辑</span>\n});\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>使用 <code>shouldComponentUpdate</code> 或 <code>PureComponent</code></strong>  ：\n<ul>\n<li><strong>作用</strong>  ：在类组件中，通过手动比较 props 和 state，防止不必要的渲染。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.PureComponent</span> {\n  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-comment">// 组件逻辑</span>\n  }\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>使用 <code>useMemo</code> 和 <code>useCallback</code></strong>  ：\n<ul>\n<li><strong>作用</strong>  ：缓存计算结果和函数实例，避免在每次渲染时重新创建。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-jsx"><span class="hljs-keyword">const</span> memoizedValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">computeExpensiveValue</span>(a, b), [a, b]);\n<span class="hljs-keyword">const</span> memoizedCallback = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">doSomething</span>(a, b);\n}, [a, b]);\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>二、优化组件的渲染逻辑</strong></h3>\n<ol>\n<li><strong>拆分组件</strong>  ：\n<ul>\n<li><strong>作用</strong>  ：将组件拆分为更小的子组件，只渲染必要的部分。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; (\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> /&gt;</span> {/* 只有 Content 变化时才会重新渲染 */}\n    <span class="hljs-tag">&lt;<span class="hljs-name">Footer</span> /&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n);\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>使用惰性初始化（lazy initialization）</strong>  ：\n<ul>\n<li><strong>作用</strong>  ：延迟加载组件或数据，减少初始渲染时间。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">LazyComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./LazyComponent&#x27;</span>));\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>避免匿名函数和内联对象</strong>  ：\n<ul>\n<li><strong>作用</strong>  ：匿名函数和内联对象在每次渲染时都会创建新的引用，导致子组件重新渲染。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-jsx"><span class="hljs-comment">// 避免</span>\n&lt;<span class="hljs-title class_">MyComponent</span> onClick={<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">handleClick</span>()} /&gt;\n<span class="hljs-comment">// 改为</span>\n<span class="hljs-keyword">const</span> handleClick = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 处理逻辑</span>\n}, []);\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span> /&gt;</span></span>\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>三、优化列表渲染</strong></h3>\n<ol>\n<li><strong>使用 <code>key</code> 属性</strong>  ：\n<ul>\n<li><strong>作用</strong>  ：帮助 React 识别哪些项改变了、被添加了或被移除了，减少不必要的渲染。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-jsx"><span class="hljs-keyword">const</span> listItems = items.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> (\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>&gt;</span>{item.name}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>\n));\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>避免在渲染方法中创建新数组或对象</strong>  ：\n<ul>\n<li><strong>作用</strong>  ：在渲染方法中创建新数组或对象会导致子组件重新渲染。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-jsx"><span class="hljs-comment">// 避免</span>\n<span class="hljs-keyword">const</span> listItems = items.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ ...item, <span class="hljs-attr">selected</span>: <span class="hljs-literal">false</span> }));\n<span class="hljs-comment">// 改为</span>\n<span class="hljs-keyword">const</span> listItems = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> items.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({ ...item, <span class="hljs-attr">selected</span>: <span class="hljs-literal">false</span> })), [items]);\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>四、使用 Context 和 Redux 等状态管理工具</strong></h3>\n<ol>\n<li><strong>合理使用 Context</strong>  ：\n<ul>\n<li><strong>作用</strong>  ：避免通过 props 层层传递数据，减少组件间的耦合。</li>\n<li><strong>注意</strong>  ：Context 会导致消费它的所有组件重新渲染，应谨慎使用。</li>\n</ul>\n</li>\n<li><strong>使用 Redux 或 MobX</strong>  ：\n<ul>\n<li><strong>作用</strong>  ：集中管理状态，减少组件间的状态传递和不必要的渲染。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">mapStateToProps</span> = (<span class="hljs-params">state</span>) =&gt; ({\n  <span class="hljs-attr">value</span>: state.<span class="hljs-property">value</span>,\n});\n<span class="hljs-title function_">connect</span>(mapStateToProps)(<span class="hljs-title class_">MyComponent</span>);\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>五、代码拆分和懒加载</strong></h3>\n<ol>\n<li><strong>代码拆分（Code Splitting）</strong>  ：\n<ul>\n<li><strong>作用</strong>  ：将代码拆分为更小的块，按需加载，减少初始加载时间。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { <span class="hljs-title class_">Suspense</span>, lazy } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">LazyComponent</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./LazyComponent&#x27;</span>));\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; (\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}&gt;\n    <span class="hljs-tag">&lt;<span class="hljs-name">LazyComponent</span> /&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span>\n);\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>动态导入（Dynamic Import）</strong>  ：\n<ul>\n<li><strong>作用</strong>  ：按需加载模块，减少初始包大小。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-jsx"><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./module&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> {\n  <span class="hljs-comment">// 使用模块</span>\n});\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>六、使用 Profiler 工具分析性能</strong></h3>\n<ol>\n<li><strong>React Profiler</strong>  ：\n<ul>\n<li><strong>作用</strong>  ：帮助识别性能瓶颈，分析组件的渲染时间和频率。</li>\n<li><strong>示例</strong>  ：<pre><code class="language-jsx">&lt;<span class="hljs-title class_">Profiler</span> id=<span class="hljs-string">&quot;MyComponent&quot;</span> onRender={<span class="hljs-function">(<span class="hljs-params">id, phase, actualDuration, baseDuration, startTime, commitTime</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${id}</span>&#x27;s <span class="hljs-subst">${phase}</span> phase:`</span>, actualDuration);\n}}&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>\n&lt;/<span class="hljs-title class_">Profiler</span>&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>Chrome DevTools</strong>  ：\n<ul>\n<li><strong>作用</strong>  ：使用 Chrome DevTools 的 Performance 面板分析应用的性能。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>七、其他优化技巧</strong></h3>\n<ol>\n<li><strong>虚拟化长列表</strong>  ：\n<ul>\n<li><strong>作用</strong>  ：对于长列表，只渲染可视区域内的项，减少 DOM 节点数量。</li>\n<li><strong>示例</strong>  ：使用 <code>react-window</code> 或 <code>react-virtualized</code>。</li>\n</ul>\n</li>\n<li><strong>避免不必要的状态提升</strong>  ：\n<ul>\n<li><strong>作用</strong>  ：只将必要的状态提升到最近的公共祖先组件，减少状态传递的开销。</li>\n</ul>\n</li>\n<li><strong>使用 Reselect 等选择器库</strong>  ：\n<ul>\n<li><strong>作用</strong>  ：缓存 Redux 等状态管理中的派生数据，减少计算开销。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>核心策略</strong>  ：减少不必要的渲染、优化组件的渲染逻辑、优化列表渲染、合理使用状态管理工具、代码拆分和懒加载、使用 Profiler 工具分析性能。</li>\n<li><strong>推荐方案</strong>  ：\n<ul>\n<li>对于小型应用，优先使用 <code>React.memo</code>、<code>useMemo</code>、<code>useCallback</code> 等轻量级优化手段。</li>\n<li>对于大型应用，结合使用代码拆分、懒加载、状态管理工具等高级优化策略。</li>\n</ul>\n</li>\n<li><strong>注意事项</strong>  ：\n<ul>\n<li>性能优化应基于实际性能瓶颈，避免过度优化。</li>\n<li>使用 Profiler 工具分析性能，确保优化措施有效。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>结论</strong></h3>\n<p>React 提供了多种性能优化策略，开发者应根据应用的具体需求和性能瓶颈，选择合适的优化手段。通过合理的优化，可以显著提升 React 应用的性能和用户体验。</p>\n</div>'</script></body></html>