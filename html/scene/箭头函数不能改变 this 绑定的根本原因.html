<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x44617b=_0x2293;function _0x2293(c,s){var e=_0x9908();return(_0x2293=function(s,n){var a=e[s-=479];void 0===_0x2293.VCZIDG&&(_0x2293.qZXUbQ=function(s,n){var a,o=[],c=0,e="";for(s=(s=>{for(var n,a,o="",c="",e=0,l=0;a=s.charAt(l++);~a&&(n=e%4?64*n+a:a,e++%4)&&(o+=String.fromCharCode(255&n>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var t=0,p=o.length;t<p;t++)c+="%"+("00"+o.charCodeAt(t).toString(16)).slice(-2);return decodeURIComponent(c)})(s),l=0;l<256;l++)o[l]=l;for(l=0;l<256;l++)c=(c+o[l]+n.charCodeAt(l%n.length))%256,a=o[l],o[l]=o[c],o[c]=a;for(var l=0,c=0,t=0;t<s.length;t++)a=o[l=(l+1)%256],o[l]=o[c=(c+o[l])%256],o[c]=a,e+=String.fromCharCode(s.charCodeAt(t)^o[(o[l]+o[c])%256]);return e},c=arguments,_0x2293.VCZIDG=!0);var s=s+e[0],o=c[s];return o?a=o:(void 0===_0x2293.wLtLuE&&(_0x2293.wLtLuE=!0),a=_0x2293.qZXUbQ(a,n),c[s]=a),a})(c,s)}if((()=>{for(var s=_0x2293,n=_0x9908();;)try{if(294894==+parseInt(s(503,"trRQ"))+-parseInt(s(490,"JTTU"))/2*(-parseInt(s(487,"Cpqz"))/3)+parseInt(s(504,"Me3f"))/4+-parseInt(s(498,"rIx]"))/5*(parseInt(s(505,"ua#]"))/6)+-parseInt(s(483,"u5k4"))/7*(parseInt(s(486,"hgIk"))/8)+parseInt(s(481,"Nt^5"))/9*(parseInt(s(494,"hLH!"))/10)+-parseInt(s(506,"cqSN"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x44617b(479,"6xkh")](_0x44617b(488,"2a4B"))!=_0x44617b(485,"3#kR"))throw window[_0x44617b(484,"hgIk")][_0x44617b(497,"zoSO")](_0x44617b(492,"HQ$b")),Error();function _0x9908(){var s=["W4FcTMekodZdQa","efddOCkEESobWPJdRmkIWPldSa","aKKSlCoZxCooWPJdL8oohmoT","f8kFxxihDttdKSkUW7Ds","bGRdL8oZASkBWQf7W4tdMCo/","W4j1iGvjvLJcLrhcJSk+WQvC","jdBdUmoRWPyOWPW","WOPvd8kfWOxdOSolACkfECoAAmoW","f3ldGItcMJ0+","WRyRySoKW63cV0m","W5ldRSodWP8YWOZcJ1ddOmoEb8o8","sY4numk8WO3dR8oN","W5FcKSkrlSo0","hYGhy8k/WRxdHq","W69qW5JdLYBcH8km","W5ddJmkiyCoSm3qvWQO","W6xcHSoGWQifyCoo","W78iAfaOq23cMJfTW5xcPW","W5tdP8odWP0+WO3cPe/dU8ogiCoo","AX3cQmolo0uVoSk7kMyYF8kGxSkcWPf1WR4+WQ3cPCk0g8o/WP4","hmoLW70pbGRdQ8oUW60qoCoS","WQSVvCkrW5FdMHPFWP3cRcm+yG","W6/cGanbCJPAWPJcIW","mfZdPmkcE00YzSk0i0Gbsq","qgudW5mAWRZcGW","WPRdNmo6WQWFbSoBWRzR","WPpdN8o9W75LemoTWQD/ACoi","b0aTlCoYwCoKWPxdN8oGdmoA"];return(_0x9908=function(){return s})()}document.title="箭头函数不能改变 this 绑定的根本原因",document.getElementById("article").innerHTML='<div><p>箭头函数不能通过 <code>call()</code>、<code>apply()</code> 或 <code>bind()</code> 绑定上下文的根本原因在于 JavaScript 对箭头函数的设计机制。具体来说：</p>\n<h3><strong>1. 箭头函数的 <code>this</code> 是静态绑定的</strong></h3>\n<p>箭头函数没有自己的 <code>this</code>，而是直接捕获其<strong>定义时的外层执行上下文</strong>  的 <code>this</code> 值。这个值在箭头函数的整个生命周期中固定不变，无法被动态修改。</p>\n<p>例如：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>,\n  <span class="hljs-attr">arrow</span>: <span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// 捕获全局作用域的this（非严格模式下是window）</span>\n  }\n};\n\nobj.<span class="hljs-title function_">arrow</span>(); <span class="hljs-comment">// 输出undefined（浏览器环境）</span>\n</code></pre>\n<p>无论箭头函数如何被调用（直接调用、作为方法调用、通过 <code>call()</code> 等），其内部的 <code>this</code> 始终指向定义时的上下文。</p>\n<h3><strong>2. <code>call()</code>/<code>apply()</code>/<code>bind()</code> 的工作原理</strong></h3>\n<p>这三个方法的核心作用是<strong>在函数调用时动态指定 <code>this</code> 值</strong>  。但它们只对<strong>拥有自己 <code>this</code> 的函数</strong>  有效（如普通函数）。对于箭头函数，由于其 <code>this</code> 已被静态绑定，这些方法无法改变其指向。</p>\n<p>例如：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">arrow</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);\n<span class="hljs-keyword">const</span> regular = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); };\n\n<span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> };\n\n<span class="hljs-comment">// 普通函数：this被call()修改为obj</span>\nregular.<span class="hljs-title function_">call</span>(obj); <span class="hljs-comment">// { name: &quot;Alice&quot; }</span>\n\n<span class="hljs-comment">// 箭头函数：this仍指向定义时的上下文（全局对象）</span>\narrow.<span class="hljs-title function_">call</span>(obj);   <span class="hljs-comment">// Window（浏览器环境）</span>\n</code></pre>\n<h3><strong>3. 语言规范的强制限制</strong></h3>\n<p>ECMAScript 规范明确规定：</p>\n<ul>\n<li>箭头函数的 <code>[[Call]]</code> 内部方法<strong>不接受 <code>thisArgument</code> 参数</strong>  （即无法通过 <code>call()</code>/<code>apply()</code> 指定 <code>this</code>）。</li>\n<li>调用 <code>arrowFunction.bind(obj)</code> 会返回一个新的箭头函数，但<strong>其 <code>this</code> 仍指向原上下文</strong>  ，<code>bind()</code> 的参数被忽略。</li>\n</ul>\n<h3><strong>为什么设计成这样？</strong></h3>\n<p>箭头函数的设计初衷是为了简化<strong>需要捕获外层上下文的场景</strong>  （如回调函数、闭包），避免 <code>this</code> 指向的不确定性。例如：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> {\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">seconds</span> = <span class="hljs-number">0</span>;\n  }\n\n  <span class="hljs-title function_">start</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-comment">// 箭头函数捕获Timer实例的this</span>\n    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">seconds</span>++; <span class="hljs-comment">// 正确访问Timer实例的属性</span>\n    }, <span class="hljs-number">1000</span>);\n  }\n}\n</code></pre>\n<p>如果箭头函数支持 <code>call()</code>/<code>apply()</code>/<code>bind()</code>，上述代码中的 <code>this</code> 可能被意外修改，导致 <code>this.seconds</code> 无法正确更新。</p>\n<h3><strong>总结</strong></h3>\n<p>箭头函数的 <code>this</code> 是<strong>静态绑定</strong>  的，从定义时就固定指向外层上下文，因此无法通过 <code>call()</code>、<code>apply()</code> 或 <code>bind()</code> 动态改变其 <code>this</code> 值。这是 JavaScript 语言设计的特性，旨在提供更简洁、更可靠的上下文捕获机制。</p>\n</div>'</script></body></html>