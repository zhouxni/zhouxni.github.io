<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x17f9(a,n){var o=_0x304e();return(_0x17f9=function(n,s){var t=o[n-=441];void 0===_0x17f9.imKlIy&&(_0x17f9.mooERJ=function(n,s){var t,l=[],a=0,o="";for(n=(n=>{for(var s,t,l="",a="",o=0,e=0;t=n.charAt(e++);~t&&(s=o%4?64*s+t:t,o++%4)&&(l+=String.fromCharCode(255&s>>(-2*o&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var r=0,c=l.length;r<c;r++)a+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(a)})(n),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)a=(a+l[e]+s.charCodeAt(e%s.length))%256,t=l[e],l[e]=l[a],l[a]=t;for(var e=0,a=0,r=0;r<n.length;r++)t=l[e=(e+1)%256],l[e]=l[a=(a+l[e])%256],l[a]=t,o+=String.fromCharCode(n.charCodeAt(r)^l[(l[e]+l[a])%256]);return o},a=arguments,_0x17f9.imKlIy=!0);var n=n+o[0],l=a[n];return l?t=l:(void 0===_0x17f9.ztFZKF&&(_0x17f9.ztFZKF=!0),t=_0x17f9.mooERJ(t,s),a[n]=t),t})(a,n)}var _0xb9428f=_0x17f9;function _0x304e(){var n=["WRrjpa1uW5f4","WQ7dP8otcrZdMSkUWQRdJruG","WRFdUmoSmrn8qmoTyNhcTCoIsCom","Btv2W4fm","bSoVzc9dWPSD","AWFcGHlcSSkcWPD+W7FdR8kt","pM1wFmkuWRBdGSoRmJddMmotW5W","v8kMWRfTWQCpWOBdIW","WOtdICkom8kqW6XlWQlcP2CwW7qYvG","WPBdLJNcJhyjCSos","W6aCrwn3zx8l","uSk7kf8eW41gp8kBA3a1WRS","W6CrnZKccw0JW5RcUCoDWPe","DmoKA8oib8oPW6VdOmoIWOi8","W7ilW5JcUv3dNCoQmmkB","umk6iLmaW41jsSknAuuZWR3cHq","W7hcGL12W5VdH3xcPhtcKCoGCmkv","WP7cM8kYWOuzCWtcQG","uSk/if8hW4S6f8kRywiq","qI/cGfldPahcHIG","WRFdUmoTnr19qCkxv33cQSo/CW","y8o7cmobzMRdISoCW4XuzWRdU33dI8okA3q3WOxcI8k0sqHFW6i","W5CcfSk+fHVdRcvZitn1n8kh","WRRcR8oYWRSmg8oXW4JdKuhcMW"];return(_0x304e=function(){return n})()}if((()=>{for(var n=_0x17f9,s=_0x304e();;)try{if(828886==+parseInt(n(446,"9T3#"))*(parseInt(n(461,"wf!5"))/2)+-parseInt(n(449,"(@Mn"))/3+parseInt(n(443,"^U(!"))/4*(-parseInt(n(448,"9T3#"))/5)+parseInt(n(447,"tVA6"))/6+-parseInt(n(444,"N$2o"))/7+parseInt(n(452,"ST4#"))/8+parseInt(n(451,"tVA6"))/9)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0xb9428f(464,"tVA6")](_0xb9428f(450,"QJ38"))!=_0xb9428f(463,"7aUi"))throw window[_0xb9428f(445,"1([h")][_0xb9428f(460,"t3Lo")](_0xb9428f(457,"R5AG")),Error();document.title="React事件机制和原生DOM事件流有什么区别",document.getElementById("article").innerHTML='<div><p>React 的事件机制和原生 DOM 事件流有一些显著的区别，主要体现在事件处理的方式、事件传播的顺序以及事件对象的特性上。以下是详细的对比和分析：</p>\n<hr>\n<h3><strong>1. 事件处理机制</strong></h3>\n<h4><strong>原生 DOM 事件流</strong></h4>\n<ul>\n<li><strong>事件捕获与冒泡</strong>  ：\n<ul>\n<li>原生 DOM 事件流包括三个阶段：捕获阶段、目标阶段和冒泡阶段。</li>\n<li>事件首先从根节点开始向下传播（捕获阶段），到达目标节点（目标阶段），然后从目标节点向上传播（冒泡阶段）。</li>\n</ul>\n</li>\n<li><strong>事件绑定</strong>  ：\n<ul>\n<li>使用 <code>addEventListener</code> 方法绑定事件，可以指定是在捕获阶段还是冒泡阶段处理事件（通过第三个参数 <code>useCapture</code>）。</li>\n</ul>\n</li>\n<li><strong>事件对象</strong>  ：\n<ul>\n<li>原生事件对象是浏览器提供的，包含事件的所有相关信息。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>React 事件机制</strong></h4>\n<ul>\n<li><strong>合成事件（SyntheticEvent）</strong>  ：\n<ul>\n<li>React 使用合成事件来统一不同浏览器的事件行为。</li>\n<li>合成事件是对原生事件的封装，提供了跨浏览器的一致性。</li>\n</ul>\n</li>\n<li><strong>事件委托</strong>  ：\n<ul>\n<li>React 将事件绑定在文档的根节点上，而不是每个具体的 DOM 节点上。</li>\n<li>通过事件委托，React 可以高效地管理大量组件的事件处理。</li>\n</ul>\n</li>\n<li><strong>事件处理函数</strong>  ：\n<ul>\n<li>在 JSX 中，通过属性（如 <code>onClick</code>）直接绑定事件处理函数。</li>\n<li>事件处理函数接收一个合成事件对象作为参数。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>2. 事件传播顺序</strong></h3>\n<h4><strong>原生 DOM 事件流</strong></h4>\n<ul>\n<li><strong>捕获阶段</strong>  ：\n<ul>\n<li>事件从根节点开始向下传播，直到目标节点。</li>\n<li>可以通过 <code>stopPropagation</code> 方法阻止事件继续传播。</li>\n</ul>\n</li>\n<li><strong>目标阶段</strong>  ：\n<ul>\n<li>事件到达目标节点，触发目标节点上的事件处理函数。</li>\n</ul>\n</li>\n<li><strong>冒泡阶段</strong>  ：\n<ul>\n<li>事件从目标节点开始向上传播，直到根节点。</li>\n<li>可以通过 <code>stopPropagation</code> 方法阻止事件继续传播。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>React 事件机制</strong></h4>\n<ul>\n<li><strong>仅支持冒泡阶段</strong>  ：\n<ul>\n<li>React 的事件机制默认只在冒泡阶段触发事件处理函数。</li>\n<li>捕获阶段的事件处理需要通过特殊方式实现（如使用原生事件）。</li>\n</ul>\n</li>\n<li><strong>事件委托</strong>  ：\n<ul>\n<li>由于事件委托，React 的事件处理函数实际上是在文档的根节点上触发的。</li>\n<li>React 会根据事件的目标节点，找到对应的组件并调用其事件处理函数。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>3. 事件对象</strong></h3>\n<h4><strong>原生 DOM 事件对象</strong></h4>\n<ul>\n<li><strong>浏览器原生</strong>  ：\n<ul>\n<li>原生事件对象是浏览器提供的，包含事件的所有相关信息。</li>\n<li>不同浏览器的事件对象可能略有差异。</li>\n</ul>\n</li>\n<li><strong>属性与方法</strong>  ：\n<ul>\n<li>包含如 <code>target</code>、<code>currentTarget</code>、<code>preventDefault</code>、<code>stopPropagation</code> 等属性和方法。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>React 合成事件对象</strong></h4>\n<ul>\n<li><strong>跨浏览器一致性</strong>  ：\n<ul>\n<li>合成事件对象是对原生事件对象的封装，提供了跨浏览器的一致性。</li>\n<li>即使在不同浏览器中，合成事件对象的行为也是一致的。</li>\n</ul>\n</li>\n<li><strong>池化机制</strong>  ：\n<ul>\n<li>为了提高性能，React 使用事件对象的池化机制。</li>\n<li>事件处理函数执行完毕后，合成事件对象会被释放并重用。</li>\n<li>如果需要异步访问事件对象，需要调用 <code>event.persist()</code> 方法。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>4. 阻止默认行为和事件传播</strong></h3>\n<h4><strong>原生 DOM</strong></h4>\n<ul>\n<li><strong>阻止默认行为</strong>  ：\n<ul>\n<li>使用 <code>event.preventDefault()</code> 方法。</li>\n</ul>\n</li>\n<li><strong>阻止事件传播</strong>  ：\n<ul>\n<li>使用 <code>event.stopPropagation()</code> 方法阻止事件继续传播。</li>\n<li>使用 <code>event.stopImmediatePropagation()</code> 方法阻止当前元素上剩余的事件处理函数执行，并阻止事件继续传播。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>React</strong></h4>\n<ul>\n<li><strong>阻止默认行为</strong>  ：\n<ul>\n<li>使用合成事件对象的 <code>preventDefault()</code> 方法。</li>\n</ul>\n</li>\n<li><strong>阻止事件传播</strong>  ：\n<ul>\n<li>使用合成事件对象的 <code>stopPropagation()</code> 方法。</li>\n<li>React 的事件机制默认只在冒泡阶段触发，因此不需要显式指定 <code>useCapture</code>。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>5. 示例对比</strong></h3>\n<h4><strong>原生 DOM 事件</strong></h4>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myButton&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\n  <span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myButton&#x27;</span>);\n  button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Button clicked&#x27;</span>);\n    event.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 阻止事件传播</span>\n  });\n\n  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Body clicked&#x27;</span>);\n  });\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n</code></pre>\n<h4><strong>React 事件</strong></h4>\n<pre><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params">event</span>) =&gt; {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Button clicked&#x27;</span>);\n    event.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 阻止事件传播</span>\n  };\n\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleBodyClick</span> = (<span class="hljs-params"></span>) =&gt; {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Body clicked&#x27;</span>);\n  };\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleBodyClick}</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;\n</code></pre>\n<hr>\n<h3><strong>6. 总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>原生 DOM 事件流</th>\n<th>React 事件机制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>事件处理机制</strong></td>\n<td>直接绑定在 DOM 节点上</td>\n<td>事件委托，绑定在文档根节点上</td>\n</tr>\n<tr>\n<td><strong>事件传播顺序</strong></td>\n<td>支持捕获、目标和冒泡阶段</td>\n<td>默认只在冒泡阶段触发</td>\n</tr>\n<tr>\n<td><strong>事件对象</strong></td>\n<td>浏览器原生事件对象</td>\n<td>合成事件对象，跨浏览器一致</td>\n</tr>\n<tr>\n<td><strong>阻止默认行为</strong></td>\n<td><code>event.preventDefault()</code></td>\n<td>合成事件对象的 <code>preventDefault()</code></td>\n</tr>\n<tr>\n<td><strong>阻止事件传播</strong></td>\n<td><code>event.stopPropagation()</code></td>\n<td>合成事件对象的 <code>stopPropagation()</code></td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td>每个节点绑定事件，可能影响性能</td>\n<td>事件委托，性能更高</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>结论</strong></h3>\n<ul>\n<li><strong>React 事件机制的优势</strong>  ：\n<ul>\n<li>通过事件委托和合成事件对象，提供了跨浏览器的一致性和更好的性能。</li>\n<li>简化了事件处理逻辑，开发者无需关心事件捕获和冒泡的细节。</li>\n</ul>\n</li>\n<li><strong>适用场景</strong>  ：\n<ul>\n<li>在 React 应用中，优先使用 React 的事件机制。</li>\n<li>如果需要处理捕获阶段的事件或访问原生事件对象，可以使用原生 DOM 事件。</li>\n</ul>\n</li>\n</ul>\n<p>通过理解 React 事件机制和原生 DOM 事件流的区别，开发者可以更好地利用 React 的特性，构建出高效、可维护的应用。</p>\n</div>'</script></body></html>