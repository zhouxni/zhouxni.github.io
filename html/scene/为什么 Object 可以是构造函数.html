<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0xa9e585=_0x122a;function _0x123e(){var s=["WRVdVCoMiCoMnmkL","g1xcHSoZWOZdMJC","urDZBCopdmk3lG","W7xcHMBdL8kvp8kcWPnVdCotW7G","W73dVCo8g8oQ","ut/cKL1VW5ldNSoqW4a4ALi","W61YBvhdTX8IcG","aSorrCouaCoJWOqGWPuDWRfKW4ScW4NdMLSBW4bYWPVcGYpcR8kIDa","pXeUcSokWRRcSCo3W4lcQ8kzWPOB","W5PYW7tcG8ocvSkEWRm7oSkcW5a","prC5FSk2W41cW7tdRmooW4qs","xSoqBIHeW6W2W5OwWPCnW7XB","WRTyj8oov8kWkq","ovjPcCowWP1/","k8oguSobaCkQW6bQWPy","mNFcSmkYW7ZcQ8kCWOJcVCoIWQJcVG","WPBcNSoqW4tdOJhdR8obdMtdM8odoG","W63cMmkOWRJcH33dV8k8xrTElW","W4TCBSksrfydcmkyW6/dUSoUjG","FCkdzSoyeg/cSq","W6vTbSooqCk0lq","W49wAmkErfnbe8kvW57dISoN","W5vnWOepW6a5pq","oHm3F8k+W4KLW6RdPmoYW7eaxa","W71HWQS5WPavWOFcTSorDSkrb0i","sSkuW43dUSoEW4FcLW","W75OW615W7bIW5ZcUq","oXiGdSonWRldSCoYW4hcNCk4WRK"];return(_0x123e=function(){return s})()}function _0x122a(e,s){var t=_0x123e();return(_0x122a=function(s,n){var o=t[s-=331];void 0===_0x122a.TgceDF&&(_0x122a.wpIQgS=function(s,n){var o,a=[],e=0,t="";for(s=(s=>{for(var n,o,a="",e="",t=0,c=0;o=s.charAt(c++);~o&&(n=t%4?64*n+o:o,t++%4)&&(a+=String.fromCharCode(255&n>>(-2*t&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var p=0,r=a.length;p<r;p++)e+="%"+("00"+a.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(s),c=0;c<256;c++)a[c]=c;for(c=0;c<256;c++)e=(e+a[c]+n.charCodeAt(c%n.length))%256,o=a[c],a[c]=a[e],a[e]=o;for(var c=0,e=0,p=0;p<s.length;p++)o=a[c=(c+1)%256],a[c]=a[e=(e+a[c])%256],a[e]=o,t+=String.fromCharCode(s.charCodeAt(p)^a[(a[c]+a[e])%256]);return t},e=arguments,_0x122a.TgceDF=!0);var s=s+t[0],a=e[s];return a?o=a:(void 0===_0x122a.cNhnsI&&(_0x122a.cNhnsI=!0),o=_0x122a.wpIQgS(o,n),e[s]=o),o})(e,s)}if((()=>{for(var s=_0x122a,n=_0x123e();;)try{if(540415==-parseInt(s(356,"FgIH"))*(-parseInt(s(332,"aSLI"))/2)+parseInt(s(354,"omMp"))/3+parseInt(s(339,"[Sg7"))/4+-parseInt(s(336,"6jKB"))/5*(-parseInt(s(343,"e!P$"))/6)+-parseInt(s(346,"YOW9"))/7+-parseInt(s(358,"0!I&"))/8*(-parseInt(s(335,"vz%a"))/9)+-parseInt(s(345,"(%k&"))/10*(parseInt(s(338,"FgIH"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0xa9e585(355,"vz%a")](_0xa9e585(357,"7mGz"))!=_0xa9e585(347,"e!P$"))throw window[_0xa9e585(349,"d2Z2")][_0xa9e585(334,"ctN9")](_0xa9e585(350,"7mGz")),Error();document.title="为什么 Object 可以是构造函数",document.getElementById("article").innerHTML='<div><p>因为 <strong>“Object” 这个名字在 JavaScript 里同时指向两样东西：</strong></p>\n<ol>\n<li><strong>一个内置的函数对象</strong>   （<code>function Object() { [native code] }</code>）；</li>\n<li><strong>一个全局命名空间对象</strong>   （<code>Object.xxx</code> 提供的所有静态方法：create、keys、assign…）。</li>\n</ol>\n<p>只有第 1 个角色让它能够充当构造函数；第 2 个角色只是普通对象，用来挂载工具方法。<br>\n两个角色共用同一段内置函数，所以看上去“Object 既是对象又是函数”。</p>\n<hr>\n<h3>证明它真的是函数</h3>\n<pre><code class="language-js"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Object</span>; <span class="hljs-comment">// &quot;function&quot;</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// 存在，指向 Object 的 prototype 对象</span>\n<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;prototype&quot;</span>); <span class="hljs-comment">// true</span>\n</code></pre>\n<ul>\n<li>作为函数，它天生带 <code>prototype</code> 属性；</li>\n<li>因此 <code>new Object()</code> 合法，内部会用这个 <code>prototype</code> 作为新对象的原型。</li>\n</ul>\n<hr>\n<h3>与 <code>new Object()</code> 返回的普通对象区别</h3>\n<pre><code class="language-js"><span class="hljs-keyword">const</span> o1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// 普通对象</span>\n<span class="hljs-keyword">const</span> o2 = <span class="hljs-title class_">Object</span>; <span class="hljs-comment">// 这是函数本身</span>\n\n<span class="hljs-keyword">typeof</span> o1; <span class="hljs-comment">// &quot;object&quot;</span>\n<span class="hljs-keyword">typeof</span> o2; <span class="hljs-comment">// &quot;function&quot;</span>\n\no1.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// undefined</span>\no2.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// [object Object]  (Object.prototype)</span>\n</code></pre>\n<hr>\n<h3>一句话总结</h3>\n<blockquote>\n<p><strong>Object 能当构造函数，是因为它就是一段内置函数；而 <code>new Object()</code> 返回的只是这段函数构造出来的普通对象，普通对象没有 <code>prototype</code>，自然不能再被 <code>new</code>。</strong></p>\n</blockquote>\n</div>'</script></body></html>