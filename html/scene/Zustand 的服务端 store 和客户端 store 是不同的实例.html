<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x27e95d=_0x4873;function _0x4873(e,n){var o=_0x22ee();return(_0x4873=function(n,s){var t=o[n-=123];void 0===_0x4873.wfHMgQ&&(_0x4873.SvwNqf=function(n,s){var t,a=[],e=0,o="";for(n=(n=>{for(var s,t,a="",e="",o=0,r=0;t=n.charAt(r++);~t&&(s=o%4?64*s+t:t,o++%4)&&(a+=String.fromCharCode(255&s>>(-2*o&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var l=0,p=a.length;l<p;l++)e+="%"+("00"+a.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(e)})(n),r=0;r<256;r++)a[r]=r;for(r=0;r<256;r++)e=(e+a[r]+s.charCodeAt(r%s.length))%256,t=a[r],a[r]=a[e],a[e]=t;for(var r=0,e=0,l=0;l<n.length;l++)t=a[r=(r+1)%256],a[r]=a[e=(e+a[r])%256],a[e]=t,o+=String.fromCharCode(n.charCodeAt(l)^a[(a[r]+a[e])%256]);return o},e=arguments,_0x4873.wfHMgQ=!0);var n=n+o[0],a=e[n];return a?t=a:(void 0===_0x4873.NnkUOz&&(_0x4873.NnkUOz=!0),t=_0x4873.SvwNqf(t,s),e[n]=t),t})(e,n)}function _0x22ee(){var n=["u8ojW6P4W43cGcdcPmk8gSoM","FCk1vmovp3ipWPefW7u","ocJcSCoYW4JdKrddOf1HWPRcPuW","k8k5WRRdIb7dT8kKeSobcCou","kSofWOVcLGW2W5NdG8kEWRtdNr7cQq","h3NcImoKWP9xWOFcRW","cCoGn8kkW4jxp8ktWQ50","CrDMjCkoW5mJhmki","WRKhWQFcPKNcS8oUW6W","WPddSSoIFK0+WPVcRa","WOObWQRcJLFdLmkGc8ojtmoJxxq","ovfwWOJdNW1LWQPJW5NcGmo7g8kzWP3dSc1IDCk8W7foW7HrWQDS","WPu5hSkXwSobW7L8hSoIumkiW7a","aCosy8k/fLmoW6xcNG","WPddVmktnG5NW4ZcGmoYr2OBCq","zHxcK2e6nbjdWQL5Ef95WRm","rJjxAIinW4/dVrW9","k8opWQaosmkZW7iu","dhNdJxiPgCoe","fxG8W7egW4rcya","BuxdK8kUvZrlWOhcQ8kEW7JdVLe0","qrZdLmkmrmoEDmo/sMRcIe5t","EwZdT8k0WOy","W5BcJ8oIkmo1zmoRECkOla","cCoLmmknWRiKCmkfWQzrAcFdKq","WOLdg8keW4pdR24","WRPfcmknW5hdV0b5lW","yXhcLwe/nH8QWP9XwMDU"];return(_0x22ee=function(){return n})()}if((()=>{for(var n=_0x4873,s=_0x22ee();;)try{if(639128==-parseInt(n(125,"b2B4"))+-parseInt(n(150,"Fyz]"))/2+-parseInt(n(139,"sWe5"))/3*(parseInt(n(124,"hrRT"))/4)+parseInt(n(130,"&8c!"))/5*(parseInt(n(126,"akkR"))/6)+-parseInt(n(137,"dHmb"))/7*(parseInt(n(132,"dHmb"))/8)+parseInt(n(133,"sc(*"))/9*(-parseInt(n(128,"G82o"))/10)+parseInt(n(138,"Fyz]"))/11)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x27e95d(141,"Oag6")](_0x27e95d(149,"dz)J"))!=_0x27e95d(145,"b2B4"))throw window[_0x27e95d(131,"&s^c")][_0x27e95d(148,"dz)J")](_0x27e95d(134,"qwRu")),Error();document.title="Zustand 的服务端 store 和客户端 store 是不同的实例",document.getElementById("article").innerHTML='<div><p>在 Next.js 或任何支持 SSR（服务端渲染）的框架中，<strong>Zustand 的服务端 store 和客户端 store 确实是不同的实例</strong>   ，这是 Zustand 能安全支持 SSR 的核心设计。以下是关键解析：</p>\n<hr>\n<h3>🌟 核心机制</h3>\n<ol>\n<li>\n<p><strong>服务端（Node.js 环境）</strong></p>\n<ul>\n<li>每次页面请求（如 <code>getServerSideProps</code>）都会创建一个<strong>全新的 store 实例</strong></li>\n<li>该实例仅在当前请求的生命周期内有效，请求结束后被垃圾回收</li>\n<li><strong>不会</strong>   在服务端不同请求间共享状态（避免跨用户污染）</li>\n</ul>\n</li>\n<li>\n<p><strong>客户端（浏览器环境）</strong></p>\n<ul>\n<li>页面 hydration 时，会创建一个<strong>独立的客户端 store 实例</strong></li>\n<li>该实例与任何服务端 store 无关，但可通过初始化状态同步数据</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>🔍 验证示例</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// store/useStore.js</span>\n<span class="hljs-keyword">import</span> { create } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;zustand&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useStore = <span class="hljs-title function_">create</span>(<span class="hljs-function">() =&gt;</span> ({\n  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,\n  <span class="hljs-attr">lastUpdated</span>: <span class="hljs-literal">null</span>,\n}));\n\n<span class="hljs-comment">// 组件中打印实例地址</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">Component</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>();\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Store instance address:&quot;</span>, store);\n  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;\n};\n</code></pre>\n<ul>\n<li><strong>服务端输出</strong>   ：每次请求打印不同的地址（如 <code>{}</code>）</li>\n<li><strong>客户端输出</strong>   ：页面加载后打印另一个独立地址（如 <code>{}</code>）</li>\n</ul>\n<hr>\n<h3>🛠️ 如何保证状态一致性？</h3>\n<p>虽然实例不同，但可以通过两种方式同步初始状态：</p>\n<h4>方式 1：通过 Props 传递初始值（推荐）</h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 页面级数据获取（服务端）</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getServerSideProps</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">const</span> initialCount = <span class="hljs-number">42</span>; <span class="hljs-comment">// 模拟从 API 获取</span>\n  <span class="hljs-keyword">return</span> { <span class="hljs-attr">props</span>: { initialCount } };\n};\n\n<span class="hljs-comment">// 客户端初始化</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">Page</span> = (<span class="hljs-params">{ initialCount }</span>) =&gt; {\n  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n    useStore.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: initialCount });\n  }, [initialCount]);\n};\n</code></pre>\n<h4>方式 2：序列化到 HTML（自动 hydration）</h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 服务端渲染时获取状态</span>\n<span class="hljs-keyword">const</span> initialStoreState = useStore.<span class="hljs-title function_">getState</span>()\n\n<span class="hljs-comment">// 将状态作为全局变量注入 HTML</span>\n&lt;script dangerouslySetInnerHTML={{\n  <span class="hljs-attr">__html</span>: <span class="hljs-string">`window.__INITIAL_STATE__ = <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(initialStoreState)}</span>`</span>\n}} /&gt;\n\n<span class="hljs-comment">// 客户端初始化</span>\n<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">__INITIAL_STATE__</span>) {\n    useStore.<span class="hljs-title function_">setState</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">__INITIAL_STATE__</span>)\n  }\n}, [])\n</code></pre>\n<hr>\n<h3>⚠️ 常见陷阱与解决方案</h3>\n<table>\n<thead>\n<tr>\n<th>问题</th>\n<th>现象</th>\n<th>修复方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>直接修改服务端 store</strong></td>\n<td>客户端看不到变化</td>\n<td>必须通过 <code>setState</code> 更新</td>\n</tr>\n<tr>\n<td><strong>非序列化状态</strong></td>\n<td>Hydration 报错</td>\n<td>确保状态是纯 JSON 对象</td>\n</tr>\n<tr>\n<td><strong>依赖浏览器 API</strong></td>\n<td>服务端报错</td>\n<td>动态加载含浏览器逻辑的组件</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>🌐 架构图示</h3>\n<pre><code>Request 1 (User A) → 创建 Store A → 返回 HTML + 初始状态 A\n                     ↑\n                    （独立）\n                     ↓\nClient Hydration → 创建 Store A\' → 同步状态 A\n\nRequest 2 (User B) → 创建 Store B → 返回 HTML + 初始状态 B\n                     ↑\n                    （独立）\n                     ↓\nClient Hydration → 创建 Store B\' → 同步状态 B\n</code></pre>\n<hr>\n<h3>📌 总结</h3>\n<ol>\n<li><strong>服务端和客户端的 store 实例不同</strong>   ，但 Zustand 的设计天然支持这种隔离</li>\n<li><strong>状态同步是开发者的责任</strong>   ，需手动传递初始状态（通过 props 或全局变量）</li>\n<li><strong>避免直接依赖服务端 store</strong>   ，所有交互应在客户端完成</li>\n<li><strong>持久化中间件</strong>   （如 <code>persist</code>）会自动处理客户端存储，无需担心 SSR 冲突</li>\n</ol>\n<p>这种设计正是 Zustand 比 Redux 等库更适合 SSR 的原因——它用最轻量的方式实现了<strong>安全的请求级状态隔离</strong>   。</p>\n</div>'</script></body></html>