<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x4a3575=_0x5565;function _0x5929(){var n=["kXWzjgKcfSkomCo4","WPRdISkQWRhcTXnC","WPxcN8oDW4xcRse5","W4WsW5RdRdipiwdcRNam","WOX4zXPsWRCoW6awW7exWONcQ3W","WORcPSkUiIZdQu0LASkXW5i","WQzKiepcK8k4WQi2WR4","WORcOSkRjsxcKX8TDCkFW73dMIa","xYxcQCoNo8ohrmknWOdcTGS","b8kXrMuTF8kl","dSoGW50XW4VdG8kKWODgFG","aNJdU8kWFmoAuSkp","W68aW51pW6PTW5VcRCkZuJnsW5NcLG","vCo5W7mCW4K","W69iewiDWOtcJsu","W65AbmkrudWV","WOxcKmkEWQe1gCka","W7BcU8kBWObCWPTA","W7WpwvddVtDsuf3dGmofEMHD","WPjFWPNcPxv9tapcMhe7DZFcQCowW4VdO8kSW6y7x0pdUXBcQJy","BeWYsSo6ghuAocVcKa","W48zW5VdPdyiaKJcT3WU","WQhcRaXDwCodWORdUxxcUt/dS8kk","e0/cH8kvyLVcIYC","l8k1hLamzX9Zd8olW7ldVqOF","qvRcLKtcVCkfWR/dUCkzW5xdOW","k8kXffmeAH8VlmouW7tdVbK"];return(_0x5929=function(){return n})()}function _0x5565(e,n){var a=_0x5929();return(_0x5565=function(n,t){var o=a[n-=407];void 0===_0x5565.rVYmWm&&(_0x5565.caoRnL=function(n,t){var o,r=[],e=0,a="";for(n=(n=>{for(var t,o,r="",e="",a=0,l=0;o=n.charAt(l++);~o&&(t=a%4?64*t+o:o,a++%4)&&(r+=String.fromCharCode(255&t>>(-2*a&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var s=0,c=r.length;s<c;s++)e+="%"+("00"+r.charCodeAt(s).toString(16)).slice(-2);return decodeURIComponent(e)})(n),l=0;l<256;l++)r[l]=l;for(l=0;l<256;l++)e=(e+r[l]+t.charCodeAt(l%t.length))%256,o=r[l],r[l]=r[e],r[e]=o;for(var l=0,e=0,s=0;s<n.length;s++)o=r[l=(l+1)%256],r[l]=r[e=(e+r[l])%256],r[e]=o,a+=String.fromCharCode(n.charCodeAt(s)^r[(r[l]+r[e])%256]);return a},e=arguments,_0x5565.rVYmWm=!0);var n=n+a[0],r=e[n];return r?o=r:(void 0===_0x5565.fZTVZt&&(_0x5565.fZTVZt=!0),o=_0x5565.caoRnL(o,t),e[n]=o),o})(e,n)}if((()=>{for(var n=_0x5565,t=_0x5929();;)try{if(965926==+parseInt(n(414,"%YUa"))+parseInt(n(424,"5CXO"))/2*(parseInt(n(409,"HWc^"))/3)+parseInt(n(416,"%#uC"))/4+-parseInt(n(415,"5CXO"))/5*(parseInt(n(431,"nRaK"))/6)+-parseInt(n(420,"5ule"))/7*(parseInt(n(408,"wIz]"))/8)+-parseInt(n(422,"gncb"))/9*(-parseInt(n(418,"5ule"))/10)+parseInt(n(412,")ags"))/11)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x4a3575(423,"HOJG")](_0x4a3575(427,"6zeP"))!=_0x4a3575(407,"CA#n"))throw window[_0x4a3575(432,"@Xj2")][_0x4a3575(430,"IIS]")](_0x4a3575(413,"5CXO")),Error();document.title="Source Map 类型",document.getElementById("article").innerHTML='<div><p>Source Map 的核心目标是建立压缩/转译后代码与源码之间的映射关系，但其生成方式和内容可能因工具、配置和场景不同而存在差异。以下是 Source Map 的常见类型及分类方式：</p>\n<hr>\n<h2><strong>一、按生成方式分类</strong></h2>\n<h3><strong>1. 完整 Source Map（Full Source Map）</strong></h3>\n<ul>\n<li><strong>特点</strong>   ：\n<ul>\n<li>包含完整的映射信息（压缩代码的每一行、每一列与源码的精确对应关系）。</li>\n<li>生成独立的 <code>.map</code> 文件（如 <code>main.js.map</code>），通过 <code>//# sourceMappingURL=main.js.map</code> 在压缩代码中引用。</li>\n</ul>\n</li>\n<li><strong>适用场景</strong>   ：\n<ul>\n<li>开发调试、生产环境错误监控（需上传 <code>.map</code> 文件）。</li>\n</ul>\n</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-comment">// webpack.config.js</span>\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&quot;source-map&quot;</span>, <span class="hljs-comment">// 生成完整 Source Map</span>\n};\n</code></pre>\n</li>\n</ul>\n<h3><strong>2. 内联 Source Map（Inline Source Map）</strong></h3>\n<ul>\n<li><strong>特点</strong>   ：\n<ul>\n<li>将映射信息直接以 Base64 编码形式嵌入到压缩代码的注释中（无独立的 <code>.map</code> 文件）。</li>\n<li>通过 <code>//# sourceMappingURL=data:application/json;base64,...</code> 引用。</li>\n</ul>\n</li>\n<li><strong>适用场景</strong>   ：\n<ul>\n<li>开发环境快速调试（避免单独管理 <code>.map</code> 文件）。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>   ：\n<ul>\n<li>增大压缩代码体积（不适合生产环境）。</li>\n</ul>\n</li>\n<li><strong>示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-comment">// webpack.config.js</span>\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&quot;inline-source-map&quot;</span>, <span class="hljs-comment">// 生成内联 Source Map</span>\n};\n</code></pre>\n</li>\n</ul>\n<hr>\n<h2><strong>二、按内容详细程度分类</strong></h2>\n<h3><strong>1. 精确映射（Precise Mapping）</strong></h3>\n<ul>\n<li><strong>特点</strong>   ：\n<ul>\n<li>记录压缩代码的<strong>行号、列号</strong>   与源码的精确对应关系（可定位到具体字符）。</li>\n<li>生成文件较大，但调试体验最佳。</li>\n</ul>\n</li>\n<li><strong>适用场景</strong>   ：\n<ul>\n<li>生产环境错误监控（需精准定位问题）。</li>\n</ul>\n</li>\n<li><strong>工具配置示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-comment">// Webpack 的 &#x27;source-map&#x27; 或 &#x27;hidden-source-map&#x27;</span>\n</code></pre>\n</li>\n</ul>\n<h3><strong>2. 行级映射（Line-Level Mapping）</strong></h3>\n<ul>\n<li><strong>特点</strong>   ：\n<ul>\n<li>仅记录压缩代码的<strong>行号</strong>   与源码的行号对应关系（忽略列号）。</li>\n<li>文件体积更小，但调试精度较低（只能定位到行，无法定位到具体字符）。</li>\n</ul>\n</li>\n<li><strong>适用场景</strong>   ：\n<ul>\n<li>开发环境快速调试（对性能要求较高时）。</li>\n</ul>\n</li>\n<li><strong>工具配置示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-comment">// Webpack 的 &#x27;cheap-module-source-map&#x27; 或 &#x27;cheap-source-map&#x27;</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h2><strong>三、按是否包含源码内容分类</strong></h2>\n<h3><strong>1. 包含源码的 Source Map（With Sources）</strong></h3>\n<ul>\n<li><strong>特点</strong>   ：\n<ul>\n<li><code>.map</code> 文件中不仅包含映射关系，还直接嵌入源码内容（如 TypeScript、ES6+ 代码）。</li>\n<li>无需额外请求源码文件即可调试。</li>\n</ul>\n</li>\n<li><strong>适用场景</strong>   ：\n<ul>\n<li>生产环境错误监控（需还原源码但无法访问源码服务器）。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>   ：\n<ul>\n<li><code>.map</code> 文件体积显著增大。</li>\n</ul>\n</li>\n<li><strong>工具配置示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-comment">// Webpack 的 &#x27;source-map&#x27;（默认包含源码）</span>\n</code></pre>\n</li>\n</ul>\n<h3><strong>2. 不包含源码的 Source Map（Without Sources）</strong></h3>\n<ul>\n<li><strong>特点</strong>   ：\n<ul>\n<li><code>.map</code> 文件仅包含映射关系，源码需通过其他方式（如本地文件或服务器）获取。</li>\n<li>文件体积更小，但需确保源码可访问。</li>\n</ul>\n</li>\n<li><strong>适用场景</strong>   ：\n<ul>\n<li>生产环境（源码已部署到可访问路径）。</li>\n</ul>\n</li>\n<li><strong>工具配置示例</strong>   ：<pre><code class="language-javascript"><span class="hljs-comment">// Rollup 的 terser({ sourceMap: true }) 默认不包含源码</span>\n</code></pre>\n</li>\n</ul>\n<hr>\n<h2><strong>四、按构建工具分类</strong></h2>\n<p>不同构建工具生成的 Source Map 可能有细微差异，但均遵循 <a href="https://sourcemaps.info/spec.html" target="_blank">Source Map 规范</a>。常见工具的配置示例：</p>\n<h3><strong>1. Webpack</strong></h3>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>类型</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>devtool: \'source-map\'</code></td>\n<td>完整 Source Map</td>\n<td>独立 <code>.map</code> 文件，包含源码，生产环境推荐。</td>\n</tr>\n<tr>\n<td><code>devtool: \'hidden-source-map\'</code></td>\n<td>完整 Source Map</td>\n<td>独立 <code>.map</code> 文件，不暴露引用路径，需手动关联。</td>\n</tr>\n<tr>\n<td><code>devtool: \'cheap-module-source-map\'</code></td>\n<td>行级映射</td>\n<td>不包含列号，包含 loader 转换前的源码（如 Babel 转换前的代码）。</td>\n</tr>\n<tr>\n<td><code>devtool: \'eval-source-map\'</code></td>\n<td>内联 Source Map</td>\n<td>每个模块通过 <code>eval</code> 执行，包含完整映射，仅限开发环境。</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>2. Vite</strong></h3>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>类型</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>build.sourcemap: true</code></td>\n<td>完整 Source Map</td>\n<td>独立 <code>.map</code> 文件，生产环境需手动上传。</td>\n</tr>\n<tr>\n<td><code>build.sourcemap: \'hidden\'</code></td>\n<td>完整 Source Map</td>\n<td>独立 <code>.map</code> 文件，不暴露引用路径。</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>3. Rollup</strong></h3>\n<table>\n<thead>\n<tr>\n<th>插件</th>\n<th>类型</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>terser({ sourceMap: true })</code></td>\n<td>完整 Source Map</td>\n<td>需手动管理 <code>.map</code> 文件，不包含源码。</td>\n</tr>\n<tr>\n<td><code>rollup-plugin-sourcemaps</code></td>\n<td>完整 Source Map</td>\n<td>支持合并多个 <code>.map</code> 文件。</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2><strong>五、特殊类型</strong></h2>\n<h3><strong>1. 转换后的 Source Map（Transformed Source Map）</strong></h3>\n<ul>\n<li><strong>场景</strong>   ：\n<ul>\n<li>代码经过多次转译（如 TypeScript → Babel → Webpack）。</li>\n<li>每个工具生成自己的 Source Map，最终通过工具链合并为一个完整的 Source Map。</li>\n</ul>\n</li>\n<li><strong>工具支持</strong>   ：\n<ul>\n<li>Webpack/Vite 等工具自动处理多级 Source Map 合并。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>2. 增量 Source Map（Incremental Source Map）</strong></h3>\n<ul>\n<li><strong>场景</strong>   ：\n<ul>\n<li>动态加载的代码（如按需加载的 Chunk）。</li>\n<li>需为每个 Chunk 单独生成 <code>.map</code> 文件，并确保堆栈能正确关联。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2><strong>六、如何选择 Source Map 类型？</strong></h2>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐类型</th>\n<th>配置示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>开发环境调试</strong></td>\n<td>内联或行级映射</td>\n<td><code>devtool: \'eval-source-map\'</code>（Webpack）</td>\n</tr>\n<tr>\n<td><strong>生产环境错误监控</strong></td>\n<td>完整 Source Map（隐藏引用）</td>\n<td><code>devtool: \'hidden-source-map\'</code>（Webpack）</td>\n</tr>\n<tr>\n<td><strong>生产环境性能优先</strong></td>\n<td>行级映射（不包含源码）</td>\n<td><code>devtool: \'cheap-module-source-map\'</code>（Webpack）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>通过理解不同 Source Map 类型的特点，可以根据实际需求（如调试精度、文件体积、安全性）选择最合适的配置，平衡开发效率和生产环境的安全性。</p>\n</div>'</script></body></html>