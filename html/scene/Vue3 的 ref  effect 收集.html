<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5365(){var s=["WP7dIXRdS2NdHNDbg8k0W6lcOq","WPTBW7uJW50+W5a","DmouD0fZgSoIct1AWRZdPG","eaBdR8oJW74VkG","WO5lW4OiWQOmc8kkumkGqSkG","WRtcTSorWQGDWQ8tW482emoQW5e","WO/cLGxcV8oNWRXcW58","A8kvW6LJdSoLWRZcQ8oYrfFcIq","W7xcGwpcMqDcW60qomkLmmkoWOO","BmoaWQObtSkRWRq","WRJdTmoNdmkG","i8o1W4TkWQBcSafECmkEkCk7W4e","kcBcIxNcT8oJt8o1aIKgrG","WR1DW6ipW5OOW7BcIfO","n0qtW57dHqNdVSoUa8kyWORdGW","WPhdJHRdVgZdGeTljCkyW4/cRW","WQSPEMZcQmkVtZRdU8kYWQHB","pXCKWQVcObZcPmkXW6GnWOZcMG","WQXdaGJdVmomBW","B8o/WPGfuSkaWPu","kSkrmWK1eSkCAsLOWOVdHwfgW5m5aSo4ubZdHfJcOrT3fq","a3KNFSkNW4qAAJpcH3OE","caWhW5eotgm","WRVcOf0bDHzSW4ZdV1tcI2e"];return(_0x5365=function(){return s})()}var _0x30bdb1=_0x3b1a;function _0x3b1a(c,s){var t=_0x5365();return(_0x3b1a=function(s,e){var a=t[s-=341];void 0===_0x3b1a.KFjWSh&&(_0x3b1a.TiiHIE=function(s,e){var a,n=[],c=0,t="";for(s=(s=>{for(var e,a,n="",c="",t=0,o=0;a=s.charAt(o++);~a&&(e=t%4?64*e+a:a,t++%4)&&(n+=String.fromCharCode(255&e>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var l=0,p=n.length;l<p;l++)c+="%"+("00"+n.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(c)})(s),o=0;o<256;o++)n[o]=o;for(o=0;o<256;o++)c=(c+n[o]+e.charCodeAt(o%e.length))%256,a=n[o],n[o]=n[c],n[c]=a;for(var o=0,c=0,l=0;l<s.length;l++)a=n[o=(o+1)%256],n[o]=n[c=(c+n[o])%256],n[c]=a,t+=String.fromCharCode(s.charCodeAt(l)^n[(n[o]+n[c])%256]);return t},c=arguments,_0x3b1a.KFjWSh=!0);var s=s+t[0],n=c[s];return n?a=n:(void 0===_0x3b1a.OSsiLA&&(_0x3b1a.OSsiLA=!0),a=_0x3b1a.TiiHIE(a,e),c[s]=a),a})(c,s)}if((()=>{for(var s=_0x3b1a,e=_0x5365();;)try{if(181597==+parseInt(s(356,"f[SN"))+-parseInt(s(345,"4rv)"))/2+parseInt(s(342,"XTyG"))/3+parseInt(s(354,"FMkD"))/4*(-parseInt(s(361,"!PH9"))/5)+parseInt(s(346,"A#c9"))/6*(parseInt(s(349,"iJ3Q"))/7)+-parseInt(s(364,"^T5T"))/8+-parseInt(s(363,"AsDv"))/9)break;e.push(e.shift())}catch(s){e.push(e.shift())}})(),localStorage[_0x30bdb1(353,"182i")](_0x30bdb1(341,"182i"))!=_0x30bdb1(362,"#H]v"))throw window[_0x30bdb1(358,"I(lM")][_0x30bdb1(350,"^Ckq")](_0x30bdb1(348,"FMkD")),Error();document.title="Vue3 的 ref  effect 收集",document.getElementById("article").innerHTML='<div><p>是的，Vue3 的 <code>ref</code> 创建的数据同样会被收集到 <code>targetMap</code> 中，但具体实现方式与 <code>reactive</code> 有所不同。理解这一点需要深入响应式系统的实现原理。</p>\n<h3><strong>1. Vue3 响应式系统的核心结构：<code>targetMap</code></strong></h3>\n<p>Vue3 的响应式系统基于 <strong>Proxy + 依赖收集</strong>   实现，核心数据结构是 <code>targetMap</code>（内部称为 <code>WeakMap&lt;target, Map&lt;key, Set&lt;effect&gt;&gt;&gt;</code>）：</p>\n<ul>\n<li><strong><code>targetMap</code></strong>  ：存储所有被代理对象（<code>target</code>）的依赖关系。\n<ul>\n<li><strong>键（<code>target</code>）</strong>  ：被代理的原始对象（如 <code>reactive</code> 创建的对象）。</li>\n<li><strong>值</strong>  ：一个 <code>Map</code>，存储该对象的每个属性（<code>key</code>）对应的副作用函数（<code>effect</code>）集合。</li>\n</ul>\n</li>\n</ul>\n<p>例如：</p>\n<pre><code class="language-javascript">targetMap = <span class="hljs-title class_">WeakMap</span> {\n  { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Vue&#x27;</span> } =&gt; <span class="hljs-title class_">Map</span> {\n    <span class="hljs-string">&#x27;name&#x27;</span> =&gt; <span class="hljs-title class_">Set</span> { effect1, effect2 }\n  }\n}\n</code></pre>\n<h3><strong>2. <code>ref</code> 的响应式实现</strong></h3>\n<p><code>ref</code> 本质是一个包含 <code>.value</code> 属性的对象，其响应式由 <code>RefImpl</code> 类实现：</p>\n<pre><code class="language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefImpl</span> {\n  <span class="hljs-keyword">private</span> <span class="hljs-attr">_value</span>: <span class="hljs-built_in">any</span>;\n  <span class="hljs-keyword">public</span> <span class="hljs-attr">dep</span>?: <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">ReactiveEffect</span>&gt;; <span class="hljs-comment">// 依赖集合</span>\n\n  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = <span class="hljs-title function_">isObject</span>(value) ? <span class="hljs-title function_">reactive</span>(value) : value; <span class="hljs-comment">// 深层响应式</span>\n  }\n\n  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() {\n    <span class="hljs-title function_">track</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&#x27;value&#x27;</span>); <span class="hljs-comment">// 收集依赖（将当前 effect 添加到 this.dep）</span>\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>;\n  }\n\n  <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">newVal</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = newVal;\n    <span class="hljs-title function_">trigger</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&#x27;value&#x27;</span>); <span class="hljs-comment">// 触发更新（执行 this.dep 中的所有 effect）</span>\n  }\n}\n</code></pre>\n<ul>\n<li><strong>依赖收集</strong>  ：访问 <code>ref.value</code> 时，通过 <code>track</code> 函数将当前副作用（<code>effect</code>）收集到 <code>RefImpl</code> 实例的 <code>dep</code> 集合中。</li>\n<li><strong>触发更新</strong>  ：修改 <code>ref.value</code> 时，通过 <code>trigger</code> 函数执行 <code>dep</code> 中的所有副作用。</li>\n</ul>\n<h3><strong>3. <code>ref</code> 与 <code>targetMap</code> 的关系</strong></h3>\n<p>虽然 <code>ref</code> 本身不是 <code>targetMap</code> 的直接键（<code>target</code>），但它的依赖信息会通过以下方式存储：</p>\n<h4><strong>3.1 基本类型的 <code>ref</code></strong></h4>\n<p>对于基本类型（如 <code>number</code>、<code>string</code>），<code>ref</code> 的依赖直接存储在 <code>RefImpl</code> 实例的 <code>dep</code> 中，而非 <code>targetMap</code>：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// RefImpl 实例</span>\n\n<span class="hljs-comment">// 依赖收集过程简化：</span>\ncount.<span class="hljs-property">dep</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([effect1, effect2]); <span class="hljs-comment">// 直接存储在实例的 dep 中</span>\n</code></pre>\n<h4><strong>3.2 对象类型的 <code>ref</code></strong></h4>\n<p>如果 <code>ref</code> 存储的是对象（如 <code>ref({})</code>），Vue 会自动将其转换为 <code>reactive</code>，此时依赖会存储在 <code>targetMap</code> 中：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">ref</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Vue&#x27;</span> }); <span class="hljs-comment">// 等价于 ref(reactive({ name: &#x27;Vue&#x27; }))</span>\n\n<span class="hljs-comment">// 依赖存储在 targetMap 中：</span>\ntargetMap = <span class="hljs-title class_">WeakMap</span> {\n  { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Vue&#x27;</span> } =&gt; <span class="hljs-title class_">Map</span> {\n    <span class="hljs-string">&#x27;name&#x27;</span> =&gt; <span class="hljs-title class_">Set</span> { effect1, effect2 }\n  }\n}\n</code></pre>\n<h3><strong>4. 关键区别</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><code>reactive</code></th>\n<th><code>ref</code>（基本类型）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>依赖存储位置</strong></td>\n<td><code>targetMap</code> 中的对象属性</td>\n<td><code>RefImpl</code> 实例的 <code>dep</code> 集合</td>\n</tr>\n<tr>\n<td><strong>触发依赖方式</strong></td>\n<td>修改对象属性（如 <code>obj.name = \'Vue\'</code>）</td>\n<td>修改 <code>.value</code>（如 <code>count.value = 1</code>）</td>\n</tr>\n<tr>\n<td><strong>是否为 Proxy 对象</strong></td>\n<td>是</td>\n<td>否（但 <code>.value</code> 可能是 Proxy）</td>\n</tr>\n</tbody>\n</table>\n<h3><strong>5. 示例验证</strong></h3>\n<p>通过自定义 <code>effect</code> 可以验证 <code>ref</code> 的依赖收集：</p>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { ref, effect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;\n\n<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);\n\n<span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>); <span class="hljs-comment">// 访问 count.value，触发依赖收集</span>\n});\n\ncount.<span class="hljs-property">value</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// 触发更新，输出 1</span>\n</code></pre>\n<ul>\n<li>当执行 <code>effect</code> 时，<code>count.value</code> 的访问会触发 <code>RefImpl</code> 的 <code>get value()</code>，进而调用 <code>track</code> 收集依赖。</li>\n<li>修改 <code>count.value</code> 时，会触发 <code>set value()</code>，进而调用 <code>trigger</code> 执行所有依赖。</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>基本类型的 <code>ref</code></strong>  ：依赖信息直接存储在 <code>RefImpl</code> 实例的 <code>dep</code> 中，不通过 <code>targetMap</code>。</li>\n<li><strong>对象类型的 <code>ref</code></strong>  ：内部使用 <code>reactive</code>，依赖信息存储在 <code>targetMap</code> 中。</li>\n</ul>\n<p>因此，<strong><code>ref</code> 的依赖管理方式与 <code>reactive</code> 一致，但具体实现路径不同</strong>  。这一设计确保了无论使用 <code>ref</code> 还是 <code>reactive</code>，Vue3 的响应式系统都能高效工作。</p>\n</div>'</script></body></html>