<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1dfae9=_0x5d76;function _0x5d76(l,n){var e=_0x5750();return(_0x5d76=function(n,s){var a=e[n-=496];void 0===_0x5d76.wUiBbY&&(_0x5d76.aDdwEA=function(n,s){var a,o=[],l=0,e="";for(n=(n=>{for(var s,a,o="",l="",e=0,t=0;a=n.charAt(t++);~a&&(s=e%4?64*s+a:a,e++%4)&&(o+=String.fromCharCode(255&s>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=o.length;c<r;c++)l+="%"+("00"+o.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(n),t=0;t<256;t++)o[t]=t;for(t=0;t<256;t++)l=(l+o[t]+s.charCodeAt(t%s.length))%256,a=o[t],o[t]=o[l],o[l]=a;for(var t=0,l=0,c=0;c<n.length;c++)a=o[t=(t+1)%256],o[t]=o[l=(l+o[t])%256],o[l]=a,e+=String.fromCharCode(n.charCodeAt(c)^o[(o[t]+o[l])%256]);return e},l=arguments,_0x5d76.wUiBbY=!0);var n=n+e[0],o=l[n];return o?a=o:(void 0===_0x5d76.kIWTgF&&(_0x5d76.kIWTgF=!0),a=_0x5d76.aDdwEA(a,s),l[n]=a),a})(l,n)}function _0x5750(){var n=["W5ZdJHpdLmk/gqncW5W1CbK","W5RdLhBcRKddLe4T","WPinsuTYW6S/","fwv7yI7dTCkUW47dSLHRWOtcPq","iCopWQtdSmoTrmoIWRPDm8k/tCoG","nupcNKSdnLFdVGxdLCkdWQK","hZZcQdakdCoAy8kpW5dcMGJcHW","gdldHSoQWOCEWRW3kmoeACkUxq","W6r+C2j6uxtdUKKQvwFdJW","ySklW6pcU8kS","zJCGm2RcSSovW67dOq","zSo2mgJdG2dcRmkesW7dPvu","eHedWP/dKCk3hCkSv8oJWPZcRq","W5HCW6u6W4WznG","WRFdQmo0tc7cSmkA","W7hcSWNcT8k2oXpcSaNcQSkSvG","frrtB0JcON4","WQtcLSodm0qDeW","jr9EW7naqSknWQi+hmoOW5G","W7BdL8o9WQe5WPNcQCkXW5ZdT0GpySohtxX+nI3cHcJdS8ojW47cVmkS","EXJdT8kBjCkQB8kQW4COkmkr","nedcMeOpoI/dIcNdPCksWQ3cIq","W6iZfXmKhGa"];return(_0x5750=function(){return n})()}if((()=>{for(var n=_0x5d76,s=_0x5750();;)try{if(350083==+parseInt(n(498,"xLgq"))*(parseInt(n(496,"F@3e"))/2)+-parseInt(n(511,"D3qG"))/3+-parseInt(n(514,"fS3J"))/4+parseInt(n(502,"Uw@a"))/5+-parseInt(n(497,"piAx"))/6+parseInt(n(505,"6[MG"))/7+parseInt(n(510,"LIMf"))/8*(-parseInt(n(512,"je[n"))/9))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x1dfae9(513,"fPU!")](_0x1dfae9(509,"Uw@a"))!=_0x1dfae9(508,"uf1m"))throw window[_0x1dfae9(500,"egDS")][_0x1dfae9(501,"*FJM")](_0x1dfae9(518,"svNz")),Error();document.title="介绍下navigator.sendBeacon方法",document.getElementById("article").innerHTML='<div><p><strong>navigator.sendBeacon 方法介绍</strong></p>\n<p><code>navigator.sendBeacon</code> 是 HTML5 引入的一个用于异步发送少量数据到服务器的 API。它特别适用于在页面即将卸载或关闭时发送数据，确保数据的可靠传输。以下是关于 <code>navigator.sendBeacon</code> 方法的详细介绍：</p>\n<h3>一、基本用法</h3>\n<pre><code class="language-javascript">navigator.<span class="hljs-title function_">sendBeacon</span>(url, data);\n</code></pre>\n<ul>\n<li><strong>url</strong>  ：要发送数据的目标服务器的 URL。</li>\n<li><strong>data</strong>  （可选）：要发送的数据，可以是任意类型，如字符串、<code>FormData</code> 对象、<code>Blob</code> 对象等。</li>\n</ul>\n<p>当用户代理成功把数据加入传输队列时，<code>sendBeacon()</code> 方法将会返回 <code>true</code>，否则返回 <code>false</code>。</p>\n<h3>二、主要特点</h3>\n<ol>\n<li><strong>可靠发送</strong>  ：\n<ul>\n<li>即使页面关闭或卸载，<code>sendBeacon</code> 方法也会尽力将数据发送到服务器。</li>\n<li>它会在浏览器的后台线程中异步发送数据，不会阻塞页面的卸载或关闭过程。</li>\n</ul>\n</li>\n<li><strong>异步发送</strong>  ：\n<ul>\n<li><code>sendBeacon</code> 方法发送的请求是异步的，不会阻塞页面的其他操作。</li>\n</ul>\n</li>\n<li><strong>数据限制</strong>  ：\n<ul>\n<li>由于 <code>sendBeacon</code> 是在后台发送数据，为了避免对用户体验造成太大影响，它对发送的数据大小有一定的限制。具体的限制因浏览器而异，但通常在几 KB 到几十 KB 之间。</li>\n</ul>\n</li>\n<li><strong>简单易用</strong>  ：\n<ul>\n<li>使用 <code>sendBeacon</code> 非常简单，只需要指定目标 URL 和要发送的数据即可。</li>\n<li>它不需要设置复杂的请求头或处理响应。</li>\n</ul>\n</li>\n<li><strong>遵循同源策略</strong>  ：\n<ul>\n<li><code>sendBeacon</code> 方法遵循同源策略，不能发送跨域请求，除非服务器设置了适当的 CORS 头。</li>\n</ul>\n</li>\n<li><strong>始终使用 HTTP POST 请求</strong>  ：\n<ul>\n<li><code>sendBeacon</code> 方法始终使用 HTTP POST 请求，并且无法自定义请求头。</li>\n</ul>\n</li>\n</ol>\n<h3>三、适用场景</h3>\n<ol>\n<li><strong>页面卸载时的日志记录</strong>  ：\n<ul>\n<li>在用户离开页面时记录行为数据，如页面停留时间、点击行为等。</li>\n</ul>\n</li>\n<li><strong>分析和监控</strong>  ：\n<ul>\n<li>发送用户行为数据到分析服务器，用于网站性能监控和用户行为分析。</li>\n</ul>\n</li>\n<li><strong>状态报告</strong>  ：\n<ul>\n<li>向服务器报告应用程序状态或错误信息。</li>\n</ul>\n</li>\n<li><strong>心跳包</strong>  ：\n<ul>\n<li>利用 <code>navigator.sendBeacon</code> 发送心跳包，与服务器保持长连接，避免长时间未请求而断开连接。</li>\n</ul>\n</li>\n</ol>\n<h3>四、使用示例</h3>\n<ol>\n<li><strong>发送字符串数据</strong>  ：<pre><code class="language-javascript">navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&#x27;/log&#x27;</span>, <span class="hljs-string">&#x27;用户点击了按钮&#x27;</span>);\n</code></pre>\n</li>\n<li><strong>发送 JSON 数据</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> data = { <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;gqk&#x27;</span>, <span class="hljs-attr">page</span>: <span class="hljs-string">&#x27;home&#x27;</span>, <span class="hljs-attr">stayTime</span>: <span class="hljs-string">&#x27;5 minutes&#x27;</span> };\n<span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data)], { <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;application/json; charset=UTF-8&#x27;</span> });\nnavigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&#x27;http://example.com/log&#x27;</span>, blob);\n</code></pre>\n</li>\n<li><strong>发送 <code>FormData</code> 数据</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();\nformData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;gqk&#x27;</span>);\nnavigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&#x27;http://example.com/submit&#x27;</span>, formData);\n</code></pre>\n</li>\n</ol>\n<h3>五、浏览器兼容性</h3>\n<p><code>navigator.sendBeacon</code> 支持主流的现代浏览器，包括 Chrome、Firefox、Safari、Edge 等，但不支持较老的浏览器（如 IE 11 及更早版本）。</p>\n<h3>六、注意事项</h3>\n<ol>\n<li><strong>数据大小限制</strong>  ：\n<ul>\n<li>由于 <code>sendBeacon</code> 对发送的数据大小有限制，因此不适合发送大量数据。如果需要发送大量数据，可能需要考虑其他方法，如 WebSocket 或服务器端的长轮询。</li>\n</ul>\n</li>\n<li><strong>无法处理响应</strong>  ：\n<ul>\n<li><code>sendBeacon</code> 是单向通信，无法处理服务器响应。因此，它适用于只需要发送数据而不需要从服务器获取数据的场景。</li>\n</ul>\n</li>\n<li><strong>选择正确的事件</strong>  ：\n<ul>\n<li>在使用 <code>sendBeacon</code> 时，应选择合适的事件来触发数据发送。例如，<code>visibilitychange</code> 事件比 <code>unload</code> 事件更可靠，因为 <code>unload</code> 事件在某些情况下（如移动设备）可能不会被触发。</li>\n</ul>\n</li>\n</ol>\n</div>'</script></body></html>