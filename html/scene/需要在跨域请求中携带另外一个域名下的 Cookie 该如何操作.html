<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x14f6d0=_0x10bf;function _0x3095(){var n=["WRDeCGZdO8kputhdP8kEW4RcQSkDW6O","WRviCWVdOmkfvJldUSkdW6JcHmk8W5m","pCkBxHnFtSkqa8klW6jzW73dMSoIWQb1qmoRW5NdL8klW7NdNmk5kbi","W6iihsvAhvRdOei","W4RdQ8obC2hdTmkA","WRvpDWBcM8opaKJdR8kF","W48rW5TxW6BdO8kebqO","cCk4W7uWW7JdR0ldLvVcGmoUqW","WR1jCWJdQSkov3JdU8k7W4JcR8k4","W6hcR8k7gSoCW44ZW6agWR8","meVdVxlcNuf7fc3cHW","vmoJWQnMWR/cSKVdKa","WO8sW6xdISoJyrGyaSkDcmoE","ANzmWO3dMSonW70","WQahWPiRW4irbrOzevTsy3W","W64WqSklW7RdPSkcqIi","gfldG3ddIG","WQ5FB8kQWQeTWRNcMCoUWRTNW68o","WQ3cTsxdH8oXW6ldKeVcRHZdLHXX","W48rW5qqWPRcGCoShJH8tSoNW64","eSojh8kktCoIW4tdU8oZ","ECo4q8kDrSkNCI5RA0G","sXxdHfb0W4vdWPFdRCoVgW","kI3dNSkDnXCmp3aX","E8o+rSoComkeBIXO","nfz2rSoAWRZcSrpcRCkrhXTxW4y"];return(_0x3095=function(){return n})()}function _0x10bf(o,n){var e=_0x3095();return(_0x10bf=function(n,s){var a=e[n-=485];void 0===_0x10bf.kWeFBy&&(_0x10bf.WOqbeB=function(n,s){var a,l=[],o=0,e="";for(n=(n=>{for(var s,a,l="",o="",e=0,t=0;a=n.charAt(t++);~a&&(s=e%4?64*s+a:a,e++%4)&&(l+=String.fromCharCode(255&s>>(-2*e&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var i=0,r=l.length;i<r;i++)o+="%"+("00"+l.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(o)})(n),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)o=(o+l[t]+s.charCodeAt(t%s.length))%256,a=l[t],l[t]=l[o],l[o]=a;for(var t=0,o=0,i=0;i<n.length;i++)a=l[t=(t+1)%256],l[t]=l[o=(o+l[t])%256],l[o]=a,e+=String.fromCharCode(n.charCodeAt(i)^l[(l[t]+l[o])%256]);return e},o=arguments,_0x10bf.kWeFBy=!0);var n=n+e[0],l=o[n];return l?a=l:(void 0===_0x10bf.gEOpPX&&(_0x10bf.gEOpPX=!0),a=_0x10bf.WOqbeB(a,s),o[n]=a),a})(o,n)}if((()=>{for(var n=_0x10bf,s=_0x3095();;)try{if(998548==-parseInt(n(509,"OEr%"))*(-parseInt(n(499,"ot&L"))/2)+-parseInt(n(496,"o9FC"))/3*(-parseInt(n(495,"bs*["))/4)+parseInt(n(510,"X#c0"))/5*(-parseInt(n(486,"UH^i"))/6)+parseInt(n(497,"Q0yT"))/7+parseInt(n(508,"bs*["))/8+parseInt(n(503,"PWfr"))/9+-parseInt(n(488,"W)^u"))/10)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x14f6d0(502,"yeyq")](_0x14f6d0(504,"%^zA"))!=_0x14f6d0(505,"oNjk"))throw window[_0x14f6d0(500,"o9FC")][_0x14f6d0(493,"jcVO")](_0x14f6d0(491,"F&Y3")),Error();document.title="需要在跨域请求中携带另外一个域名下的 Cookie 该如何操作",document.getElementById("article").innerHTML='<div><p>在跨域请求中携带另一个域名下的 Cookie 是一项具有挑战性的任务，因为浏览器的安全策略（如同源策略）限制了跨域请求中 Cookie 的自动发送。然而，有几种方法可以实现这一目标，具体取决于你的应用架构和安全需求。以下是几种常见的方法：</p>\n<hr>\n<h3><strong>一、使用 CORS（跨域资源共享）并设置 <code>credentials</code></strong></h3>\n<ol>\n<li><strong>服务器端配置 CORS</strong>  ：\n<ul>\n<li>在目标服务器上配置 CORS，允许特定的源发送跨域请求，并允许携带 Cookie。</li>\n<li>设置响应头：<pre><code class="language-http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://your-allowed-origin.com  // 不能使用通配符 *\n<span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>客户端设置 <code>credentials</code></strong>  ：\n<ul>\n<li>在发起跨域请求时，设置 <code>credentials</code> 选项为 <code>\'include\'</code>，以允许发送 Cookie。</li>\n<li>示例（使用 Fetch API）：<pre><code class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://target-domain.com/api/data&#x27;</span>, {\n  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,\n  <span class="hljs-attr">credentials</span>: <span class="hljs-string">&#x27;include&#x27;</span> <span class="hljs-comment">// 允许携带 Cookie</span>\n})\n.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())\n.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))\n.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, error));\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>注意事项</strong>  ：\n<ul>\n<li><code>Access-Control-Allow-Origin</code> 不能设置为通配符 <code>*</code>，必须指定具体的源。</li>\n<li>确保浏览器允许第三方 Cookie（某些浏览器可能默认禁用第三方 Cookie）。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>二、使用代理服务器</strong></h3>\n<ol>\n<li><strong>原理</strong>  ：\n<ul>\n<li>在同源服务器上设置一个代理，由同源服务器代表客户端向目标服务器发起请求。</li>\n<li>由于请求是同源的，浏览器会自动携带 Cookie。</li>\n</ul>\n</li>\n<li><strong>实现方式</strong>  ：\n<ul>\n<li>在同源服务器上配置反向代理（如 Nginx、Apache）。</li>\n<li>示例（Nginx 配置）：<pre><code class="language-nginx"><span class="hljs-section">location</span> /api/ {\n  <span class="hljs-attribute">proxy_pass</span> https://target-domain.com/;\n  <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;\n  <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;\n  <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>优点</strong>  ：\n<ul>\n<li>避免了跨域问题，Cookie 自动携带。</li>\n<li>适用于需要隐藏目标服务器细节的场景。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>增加了同源服务器的负担。</li>\n<li>需要额外的服务器配置和维护。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>三、使用 JSONP（仅限 GET 请求）</strong></h3>\n<ol>\n<li><strong>原理</strong>  ：\n<ul>\n<li>JSONP 是一种通过 <code>&lt;script&gt;</code> 标签实现跨域请求的方法。</li>\n<li>服务器返回一个 JavaScript 函数调用，浏览器执行该函数，实现数据传输。</li>\n</ul>\n</li>\n<li><strong>实现方式</strong>  ：\n<ul>\n<li>客户端动态创建一个 <code>&lt;script&gt;</code> 标签，设置 <code>src</code> 为目标服务器的 URL，并附带一个回调函数名称。</li>\n<li>服务器返回包含回调函数的响应。</li>\n<li>示例：<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleResponse</span>(<span class="hljs-params">data</span>) {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);\n}\n\n<span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);\nscript.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;https://target-domain.com/api/data?callback=handleResponse&#x27;</span>;\n<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>限制</strong>  ：\n<ul>\n<li>仅支持 GET 请求。</li>\n<li>无法携带 Cookie，因为 <code>&lt;script&gt;</code> 标签不支持设置请求头。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>四、使用 PostMessage 进行跨窗口通信</strong></h3>\n<ol>\n<li><strong>原理</strong>  ：\n<ul>\n<li>如果两个域名之间存在某种关系（如 iframe 嵌套），可以使用 <code>window.postMessage</code> 进行跨窗口通信。</li>\n<li>父窗口和子窗口可以通过 <code>postMessage</code> 发送和接收消息，包括需要传递的 Cookie 信息（需要手动处理）。</li>\n</ul>\n</li>\n<li><strong>实现方式</strong>  ：\n<ul>\n<li>父窗口向子窗口发送消息：<pre><code class="language-javascript"><span class="hljs-keyword">const</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myIframe&#x27;</span>);\niframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Hello from parent&#x27;</span>, <span class="hljs-string">&#x27;https://target-domain.com&#x27;</span>);\n</code></pre>\n</li>\n<li>子窗口接收消息：<pre><code class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {\n  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">origin</span> !== <span class="hljs-string">&#x27;https://parent-domain.com&#x27;</span>) <span class="hljs-keyword">return</span>;\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received message:&#x27;</span>, event.<span class="hljs-property">data</span>);\n});\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>注意事项</strong>  ：\n<ul>\n<li>需要确保通信双方都是可信的源。</li>\n<li>不直接携带 Cookie，但可以通过消息传递 Cookie 信息（不推荐，存在安全风险）。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>五、使用 SameSite Cookie 属性（有限制）</strong></h3>\n<ol>\n<li><strong>原理</strong>  ：\n<ul>\n<li><code>SameSite</code> 属性用于控制 Cookie 在跨站请求中的发送行为。</li>\n<li>设置为 <code>None</code> 并启用 <code>Secure</code> 属性，允许跨域请求携带 Cookie（需要 HTTPS）。</li>\n</ul>\n</li>\n<li><strong>设置方式</strong>  ：\n<ul>\n<li>在服务器端设置 Cookie 时，添加 <code>SameSite=None; Secure</code> 属性。</li>\n<li>示例（设置 HTTP 响应头）：<pre><code class="language-http"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>myCookie=value; SameSite=None; Secure\n</code></pre>\n</li>\n</ul>\n</li>\n<li><strong>限制</strong>  ：\n<ul>\n<li>浏览器支持情况可能有所不同。</li>\n<li>需要 HTTPS 协议。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>总结</strong></h3>\n<ul>\n<li><strong>CORS + credentials</strong>  ：适用于需要直接跨域请求并携带 Cookie 的场景，需要服务器和客户端共同配置。</li>\n<li><strong>代理服务器</strong>  ：适用于需要隐藏目标服务器细节或无法修改目标服务器配置的场景。</li>\n<li><strong>JSONP</strong>  ：仅适用于 GET 请求，无法携带 Cookie。</li>\n<li><strong>PostMessage</strong>  ：适用于存在窗口关系的场景，不直接携带 Cookie。</li>\n<li><strong>SameSite Cookie</strong>  ：适用于需要控制 Cookie 跨站发送行为的场景，有浏览器和协议限制。</li>\n</ul>\n<hr>\n<h3><strong>安全注意事项</strong></h3>\n<ul>\n<li><strong>保护 Cookie</strong>  ：确保 Cookie 设置 <code>HttpOnly</code> 和 <code>Secure</code> 属性，防止 XSS 攻击和 Cookie 泄露。</li>\n<li><strong>验证来源</strong>  ：在服务器端验证请求的来源，防止 CSRF 攻击。</li>\n<li><strong>遵守法规</strong>  ：确保符合相关法律法规（如 GDPR）对 Cookie 和用户数据的要求。</li>\n</ul>\n</div>'</script></body></html>