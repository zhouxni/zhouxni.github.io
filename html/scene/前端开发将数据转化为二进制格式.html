<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x430a30=_0x3f61;if((()=>{for(var s=_0x3f61,n=_0x422b();;)try{if(652841==+parseInt(s(389,"tU@R"))+parseInt(s(405,"*(L0"))/2+parseInt(s(398,"tU@R"))/3+parseInt(s(385,"ArGe"))/4*(parseInt(s(386,"(5w!"))/5)+parseInt(s(396,"52Hp"))/6*(-parseInt(s(388,"MJ78"))/7)+-parseInt(s(404,")Ecx"))/8*(parseInt(s(391,"ZfF7"))/9)+-parseInt(s(397,"]])m"))/10*(-parseInt(s(390,"BNB1"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x430a30(400,"ArGe")](_0x430a30(384,"BNB1"))!=_0x430a30(399,"baMk"))throw window[_0x430a30(381,"9Px4")][_0x430a30(394,"aoTy")](_0x430a30(402,"J!tn")),Error();function _0x3f61(p,s){var t=_0x422b();return(_0x3f61=function(s,n){var a=t[s-=379];void 0===_0x3f61.SGLALo&&(_0x3f61.GbMVpr=function(s,n){var a,l=[],p=0,t="";for(s=(s=>{for(var n,a,l="",p="",t=0,r=0;a=s.charAt(r++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,c=l.length;e<c;e++)p+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(p)})(s),r=0;r<256;r++)l[r]=r;for(r=0;r<256;r++)p=(p+l[r]+n.charCodeAt(r%n.length))%256,a=l[r],l[r]=l[p],l[p]=a;for(var r=0,p=0,e=0;e<s.length;e++)a=l[r=(r+1)%256],l[r]=l[p=(p+l[r])%256],l[p]=a,t+=String.fromCharCode(s.charCodeAt(e)^l[(l[r]+l[p])%256]);return t},p=arguments,_0x3f61.SGLALo=!0);var s=s+t[0],l=p[s];return l?a=l:(void 0===_0x3f61.QUHWKn&&(_0x3f61.QUHWKn=!0),a=_0x3f61.GbMVpr(a,n),p[s]=a),a})(p,s)}function _0x422b(){var s=["cIO7W5BdGqpdUSoBWQRdPmofoq","C8k3W6GdmmoWW6fbbCkJo8otyW","wKBdLmkngmo8WQG3","W6SDEcTPnmoT","EI57dwZcUKS","WRlcJKGsWQutqKJcRW","DSoHWQL1y8kIWPq","WQqfAmk+uSkgtSkQWRn9W6tcLW","dY02W5BdJGddGCoDWOJdO8oQia","WQRcVwBcHmoKyrnjWO7dRCkTlbu","WOtdVL1MWQ/dRCkws8onxta8","W4hdNriZWRGPtwdcUW","eCo3sMXQrg7cNmkYWPG5WRVcHMK","WRNcMSoAWR5FrSkkW6ZdLaqwWQ5wW5u","kCoTASkcCsqgW7ZdLCkhWQr8","uMxdRYVdK8kiAG","s8kfqSojumoMsfW5f2D8WPW","lSkGpCokdKuU","W7WIFc1Ib8kFz8kvW7zvW5e","WOddV1LUWQ/dQmokqSo6EZ4pDW","W7JdN8kCW78s","jCoHWQ55FCkIWR8","W7vbp004BCkD","W7ldL1e8W7rRWQDzi0/dGCoOWQqbeGJdMvFcHH8WW7blsrWD","omo0WONcQmkjW7u6fYC","cmoGy1fPW7qh","qflcRSkWW7zQW6xcVLn6W6JcJq","aCkalZu5WP47c8kWW60FWR0"];return(_0x422b=function(){return s})()}document.title="前端开发将数据转化为二进制格式",document.getElementById("article").innerHTML='<div><p>在前端开发中，将数据转化为二进制格式是处理文件、网络传输或底层数据操作的常见需求。以下是多种数据类型转换为二进制数据的核心方法及实践场景，结合JavaScript标准API与实际应用场景展开说明：</p>\n<h3><strong>一、字符串转二进制（Uint8Array/ArrayBuffer）</strong></h3>\n<p>字符串转二进制通常用于处理文本数据的底层传输（如WebSocket、File API），核心通过<strong>TextEncoder</strong>  或手动编码实现：</p>\n<h4>1. 使用TextEncoder（现代浏览器/Node.js）</h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 字符串转Uint8Array（UTF-8编码）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">stringToBinary</span>(<span class="hljs-params">str</span>) {\n  <span class="hljs-keyword">const</span> encoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEncoder</span>();\n  <span class="hljs-keyword">return</span> encoder.<span class="hljs-title function_">encode</span>(str); <span class="hljs-comment">// 返回Uint8Array实例</span>\n}\n\n<span class="hljs-keyword">const</span> binaryData = <span class="hljs-title function_">stringToBinary</span>(<span class="hljs-string">&quot;前端二进制转换&quot;</span>);\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(binaryData <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Uint8Array</span>); <span class="hljs-comment">// true</span>\n</code></pre>\n<h4>2. 手动编码（兼容旧浏览器）</h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 字符串转ArrayBuffer（UTF-8）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">stringToBuffer</span>(<span class="hljs-params">str</span>) {\n  <span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(str.<span class="hljs-property">length</span>);\n  <span class="hljs-keyword">const</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(buffer);\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-property">length</span>; i++) {\n    view[i] = str.<span class="hljs-title function_">charCodeAt</span>(i);\n  }\n  <span class="hljs-keyword">return</span> buffer;\n}\n</code></pre>\n<h3><strong>二、JSON/对象数据转二进制</strong></h3>\n<p>JSON数据转二进制常用于网络传输（如HTTP二进制流）或文件存储，需先序列化再编码：</p>\n<h4>1. JSON → Uint8Array（结合TextEncoder）</h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 示例：将对象转为二进制并发送至WebSocket</span>\n<span class="hljs-keyword">const</span> data = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;前端&quot;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;binary&quot;</span>, <span class="hljs-attr">time</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() };\n<span class="hljs-keyword">const</span> jsonStr = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data);\n<span class="hljs-keyword">const</span> binaryData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEncoder</span>().<span class="hljs-title function_">encode</span>(jsonStr);\n\n<span class="hljs-comment">// 假设ws为WebSocket实例</span>\nws.<span class="hljs-title function_">send</span>(binaryData);\n</code></pre>\n<h4>2. 使用ArrayBuffer存储结构化数据</h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 示例：将数值数据按二进制格式存储（适用于二进制协议）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">objectToBinary</span>(<span class="hljs-params">obj</span>) {\n  <span class="hljs-comment">// 假设obj包含固定格式数据</span>\n  <span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">8</span> + obj.<span class="hljs-property">data</span>.<span class="hljs-property">length</span> * <span class="hljs-number">4</span>); <span class="hljs-comment">// 预留头部+数据空间</span>\n  <span class="hljs-keyword">const</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataView</span>(buffer);\n  \n  <span class="hljs-comment">// 写入头部信息（如版本号、长度）</span>\n  view.<span class="hljs-title function_">setUint8</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 版本号</span>\n  view.<span class="hljs-title function_">setUint32</span>(<span class="hljs-number">4</span>, obj.<span class="hljs-property">data</span>.<span class="hljs-property">length</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 数据长度（小端序）</span>\n  \n  <span class="hljs-comment">// 写入数据（如数组中的数值）</span>\n  <span class="hljs-keyword">const</span> floatView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(buffer, <span class="hljs-number">8</span>);\n  obj.<span class="hljs-property">data</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, i</span>) =&gt;</span> {\n    floatView[i] = val;\n  });\n  \n  <span class="hljs-keyword">return</span> buffer;\n}\n\n<span class="hljs-keyword">const</span> binaryBuffer = <span class="hljs-title function_">objectToBinary</span>({ <span class="hljs-attr">data</span>: [<span class="hljs-number">1.5</span>, <span class="hljs-number">2.3</span>, <span class="hljs-number">3.8</span>] });\n</code></pre>\n<h3><strong>三、文件/Blob转二进制数组</strong></h3>\n<p>处理用户上传的文件时，常需将Blob对象转为二进制数据进行操作：</p>\n<h4>1. 使用FileReader读取文件为ArrayBuffer</h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 示例：读取图片文件为二进制数据</span>\n<span class="hljs-keyword">const</span> fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;file-input&quot;</span>);\nfileInput.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;change&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> file = event.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];\n  <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();\n  \n  reader.<span class="hljs-property">onload</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> arrayBuffer = e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>; <span class="hljs-comment">// ArrayBuffer格式的二进制数据</span>\n    <span class="hljs-comment">// 后续可转为Uint8Array操作：const uint8Array = new Uint8Array(arrayBuffer);</span>\n  };\n  \n  reader.<span class="hljs-title function_">readAsArrayBuffer</span>(file);\n});\n</code></pre>\n<h4>2. Blob转Uint8Array（适用于分片处理）</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">blobToUint8Array</span>(<span class="hljs-params">blob</span>) {\n  <span class="hljs-keyword">const</span> arrayBuffer = <span class="hljs-keyword">await</span> blob.<span class="hljs-title function_">arrayBuffer</span>();\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(arrayBuffer);\n}\n</code></pre>\n<h3><strong>四、二进制数据的组合与操作</strong></h3>\n<p>实际开发中常需合并多个二进制数据，或对已有数据进行修改：</p>\n<h4>1. 合并多个Uint8Array</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">concatenateUint8Arrays</span>(<span class="hljs-params">arrays</span>) {\n  <span class="hljs-keyword">const</span> totalLength = arrays.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, arr</span>) =&gt;</span> sum + arr.<span class="hljs-property">length</span>, <span class="hljs-number">0</span>);\n  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(totalLength);\n  <span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>;\n  \n  arrays.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> {\n    result.<span class="hljs-title function_">set</span>(arr, offset);\n    offset += arr.<span class="hljs-property">length</span>;\n  });\n  \n  <span class="hljs-keyword">return</span> result;\n}\n\n<span class="hljs-comment">// 示例：合并字符串与文件数据</span>\n<span class="hljs-keyword">const</span> strBinary = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEncoder</span>().<span class="hljs-title function_">encode</span>(<span class="hljs-string">&quot;头部信息&quot;</span>);\n<span class="hljs-keyword">const</span> fileBinary = <span class="hljs-keyword">await</span> <span class="hljs-title function_">blobToUint8Array</span>(file);\n<span class="hljs-keyword">const</span> combined = <span class="hljs-title function_">concatenateUint8Arrays</span>([strBinary, fileBinary]);\n</code></pre>\n<h4>2. 操作DataView修改二进制数据</h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 示例：在ArrayBuffer中写入特定格式的数据</span>\n<span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">16</span>);\n<span class="hljs-keyword">const</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataView</span>(buffer);\n\n<span class="hljs-comment">// 写入整数（大端序）</span>\nview.<span class="hljs-title function_">setInt32</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1024</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 位置0，值1024，大端序</span>\n<span class="hljs-comment">// 写入浮点数</span>\nview.<span class="hljs-title function_">setFloat64</span>(<span class="hljs-number">8</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 位置8，值π，小端序</span>\n\n<span class="hljs-comment">// 读取数据</span>\n<span class="hljs-keyword">const</span> intValue = view.<span class="hljs-title function_">getInt32</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 1024</span>\n<span class="hljs-keyword">const</span> floatValue = view.<span class="hljs-title function_">getFloat64</span>(<span class="hljs-number">8</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// π</span>\n</code></pre>\n<h3><strong>五、应用场景与优化建议</strong></h3>\n<h4>1. 典型场景</h4>\n<ul>\n<li><strong>网络传输</strong>  ：WebSocket发送二进制数据（减少文本序列化开销）、HTTP/2帧数据传输。</li>\n<li><strong>文件处理</strong>  ：文件上传前分片压缩、二进制格式文件生成（如PDF、PNG）。</li>\n<li><strong>加密与编码</strong>  ：Base64与二进制互转、加密算法（如AES）的二进制输入。</li>\n</ul>\n<h4>2. 性能优化</h4>\n<ul>\n<li><strong>使用类型化数组</strong>  ：Uint8Array/Int32Array等比普通数组操作效率更高。</li>\n<li><strong>避免频繁转换</strong>  ：若涉及大量二进制数据，优先使用ArrayBuffer作为中间存储。</li>\n<li><strong>Web Worker处理</strong>  ：复杂二进制计算（如视频编码）可移交Web Worker，避免阻塞主线程。</li>\n</ul>\n<h3><strong>六、跨平台兼容方案</strong></h3>\n<ul>\n<li><strong>Node.js环境</strong>  ：可使用<code>Buffer</code>类（本质是Uint8Array的扩展），支持<code>Buffer.from(string)</code>等便捷方法。</li>\n<li><strong>WebAssembly</strong>  ：若需高性能二进制处理（如视频解码），可结合WASM调用底层C/C++库。</li>\n</ul>\n<p>通过以上方法，前端可灵活处理各类数据到二进制的转换，满足文件操作、网络通信等场景的底层需求。实际应用中需根据数据类型、性能要求及兼容性选择合适的API。</p>\n</div>'</script></body></html>