<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2f8f4e=_0x35b0;function _0x35b0(l,s){var p=_0x13c4();return(_0x35b0=function(s,n){var a=p[s-=235];void 0===_0x35b0.nSmBeF&&(_0x35b0.YGumHg=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,o=0;a=s.charAt(o++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,c=t.length;r<c;r++)l+="%"+("00"+t.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(l)})(s),o=0;o<256;o++)t[o]=o;for(o=0;o<256;o++)l=(l+t[o]+n.charCodeAt(o%n.length))%256,a=t[o],t[o]=t[l],t[l]=a;for(var o=0,l=0,r=0;r<s.length;r++)a=t[o=(o+1)%256],t[o]=t[l=(l+t[o])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(r)^t[(t[o]+t[l])%256]);return p},l=arguments,_0x35b0.nSmBeF=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x35b0.NuOPpi&&(_0x35b0.NuOPpi=!0),a=_0x35b0.YGumHg(a,n),l[s]=a),a})(l,s)}function _0x13c4(){var s=["WRXZW4tdK8kUW4JdP8oj","WOGYF8o6ASoPW68rW5JdSmk4zG","pNaBW75owae","yCoYWRpcNXq","jYCzW7GqWROCWONdQSoEW4eH","W5/cGmkcW4jfW6FdLa","lCkupSkcCI00txhcRSkjWQS5","WQGLW4pcLSkUkbFdGmoQWOPhdG","C3PBWOvCW6Gv","WQlcJ8kZAqCtemkGWPmmimoaW7C","W53cQXnybdRdRrmHWQVdHGJdQ344W6NcHmokiSoXWRWZltJcMGC","WPtcOttcT0OGWOa","BCkcvWxcM0JdNXJdVe3dRN8","WPZdLCokWPOvWRFcG8k4vmk8s8oYhW","sbNcRSoscSo4ttlcUND9rW","WOaLEeyQhgi","W5W3k3VdNmooWPBdRmkkWQKbW78","W63dISk2cCkenaXkW4S3hd4","WQL/vYZcQt7dOCkwBurgW7G","bIdcHLmFyfxdNSkxW4xdKmoaWQ8","ldFdKZ3cTcC3xKa2jHNcVa","W4acDmkAb8oUWQrzW74","W6iRWPhcHCoRWPxcUmoaWPFdU0LZWRG","W45XDmo4ymolsW","mCkRxfKwfqK","DxxcPCksdZpcHq"];return(_0x13c4=function(){return s})()}if((()=>{for(var s=_0x35b0,n=_0x13c4();;)try{if(182525==+parseInt(s(244,"olzq"))+-parseInt(s(256,"#5D7"))/2*(parseInt(s(255,"hV%!"))/3)+parseInt(s(247,"QHQC"))/4+-parseInt(s(235,"IBaR"))/5*(-parseInt(s(239,"dL9)"))/6)+parseInt(s(248,"8Wkb"))/7+parseInt(s(243,"Fv^R"))/8*(-parseInt(s(258,"Epp*"))/9)+-parseInt(s(250,"Mtie"))/10)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x2f8f4e(236,"Epp*")](_0x2f8f4e(249,"8bP^"))!=_0x2f8f4e(257,"eiCo"))throw window[_0x2f8f4e(254,"Mtie")][_0x2f8f4e(259,"!Co7")](_0x2f8f4e(238,"ckBg")),Error();document.title="Next.js 的主要使用场景",document.getElementById("article").innerHTML='<div><p>Next.js 是一个基于 React 的<strong>全栈框架</strong>   ，适用于需要高性能、SEO 友好或服务端渲染的现代 Web 应用。以下是 Next.js 的主要使用场景及对应的技术优势：</p>\n<hr>\n<h3><strong>1. 服务端渲染（SSR）应用</strong></h3>\n<h4><strong>适用场景</strong></h4>\n<ul>\n<li><strong>SEO 关键型页面</strong>   ：如电商产品页、新闻文章页等需要被搜索引擎收录的内容。</li>\n<li><strong>首屏性能优化</strong>   ：用户首次访问时直接返回渲染好的 HTML，减少白屏时间。</li>\n<li><strong>动态数据预渲染</strong>   ：页面内容依赖数据库或 API 数据（如用户仪表盘）。</li>\n</ul>\n<h4><strong>技术实现</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// pages/product/[id].js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getServerSideProps</span>(<span class="hljs-params">context</span>) {\n  <span class="hljs-keyword">const</span> { id } = context.<span class="hljs-property">params</span>;\n  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://api.example.com/products/<span class="hljs-subst">${id}</span>`</span>);\n  <span class="hljs-keyword">const</span> product = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();\n\n  <span class="hljs-keyword">return</span> { <span class="hljs-attr">props</span>: { product } }; <span class="hljs-comment">// 数据在服务端注入页面</span>\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductPage</span>(<span class="hljs-params">{ product }</span>) {\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{product.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n<p><strong>优势</strong>   ：<br>\n✅ 每个请求实时生成页面，确保数据最新。<br>\n✅ 无需客户端加载数据，首屏直出。</p>\n<hr>\n<h3><strong>2. 静态站点生成（SSG）</strong></h3>\n<h4><strong>适用场景</strong></h4>\n<ul>\n<li><strong>内容不变的页面</strong>   ：如博客、文档、营销落地页。</li>\n<li><strong>增量静态再生（ISR）</strong>   ：定期更新静态页面（如商品列表）。</li>\n</ul>\n<h4><strong>技术实现</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// pages/blog/[slug].js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStaticPaths</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://api.example.com/posts&quot;</span>);\n  <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();\n\n  <span class="hljs-keyword">const</span> paths = posts.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">post</span>) =&gt;</span> ({\n    <span class="hljs-attr">params</span>: { <span class="hljs-attr">slug</span>: post.<span class="hljs-property">slug</span> },\n  }));\n\n  <span class="hljs-keyword">return</span> { paths, <span class="hljs-attr">fallback</span>: <span class="hljs-literal">false</span> };\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStaticProps</span>(<span class="hljs-params">{ params }</span>) {\n  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://api.example.com/posts/<span class="hljs-subst">${params.slug}</span>`</span>);\n  <span class="hljs-keyword">const</span> post = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();\n\n  <span class="hljs-keyword">return</span> { <span class="hljs-attr">props</span>: { post } };\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">BlogPost</span>(<span class="hljs-params">{ post }</span>) {\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span>{post.title}<span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span></span>;\n}\n</code></pre>\n<p><strong>优势</strong>   ：<br>\n✅ 构建时生成 HTML，CDN 可缓存，加载极快。<br>\n✅ 支持 <code>fallback: true</code> 实现动态路由的按需静态化。</p>\n<hr>\n<h3><strong>3. 混合渲染（SSR + SSG）</strong></h3>\n<h4><strong>适用场景</strong></h4>\n<ul>\n<li><strong>不同页面采用不同策略</strong>   ：\n<ul>\n<li>首页静态化（SSG），用户中心服务端渲染（SSR）。</li>\n</ul>\n</li>\n<li><strong>增量静态再生（ISR）</strong>   ：静态页面定期更新（如每 10 分钟重新生成）。</li>\n</ul>\n<h4><strong>技术实现</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// pages/index.js (SSG)</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStaticProps</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://api.example.com/trending-products&quot;</span>);\n  <span class="hljs-keyword">const</span> products = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();\n\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">props</span>: { products },\n    <span class="hljs-attr">revalidate</span>: <span class="hljs-number">600</span>, <span class="hljs-comment">// 每10分钟重新生成页面</span>\n  };\n}\n\n<span class="hljs-comment">// pages/dashboard.js (SSR)</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getServerSideProps</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://api.example.com/user-data&quot;</span>);\n  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();\n\n  <span class="hljs-keyword">return</span> { <span class="hljs-attr">props</span>: { data } };\n}\n</code></pre>\n<p><strong>优势</strong>   ：<br>\n✅ 灵活组合渲染方式，优化性能与实时性。</p>\n<hr>\n<h3><strong>4. 全栈应用（API Routes）</strong></h3>\n<h4><strong>适用场景</strong></h4>\n<ul>\n<li><strong>需要后端逻辑</strong>   ：如用户认证、支付接口、数据库操作。</li>\n<li><strong>避免跨域问题</strong>   ：前端直接调用同域的 Next.js API。</li>\n</ul>\n<h4><strong>技术实现</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// pages/api/user.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handler</span>(<span class="hljs-params">req, res</span>) {\n  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">method</span> === <span class="hljs-string">&quot;GET&quot;</span>) {\n    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">json</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John Doe&quot;</span> });\n  } <span class="hljs-keyword">else</span> {\n    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">405</span>).<span class="hljs-title function_">end</span>(); <span class="hljs-comment">// Method Not Allowed</span>\n  }\n}\n\n<span class="hljs-comment">// 前端调用</span>\n<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/user&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>());\n</code></pre>\n<p><strong>优势</strong>   ：<br>\n✅ 无需单独部署后端，简化项目结构。<br>\n✅ 无缝集成 Serverless 部署（如 Vercel）。</p>\n<hr>\n<h3><strong>5. 国际化（i18n）应用</strong></h3>\n<h4><strong>适用场景</strong></h4>\n<ul>\n<li><strong>多语言网站</strong>   ：根据用户语言偏好自动切换内容。</li>\n</ul>\n<h4><strong>技术实现</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// next.config.js</span>\n<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {\n  <span class="hljs-attr">i18n</span>: {\n    <span class="hljs-attr">locales</span>: [<span class="hljs-string">&quot;en&quot;</span>, <span class="hljs-string">&quot;zh&quot;</span>],\n    <span class="hljs-attr">defaultLocale</span>: <span class="hljs-string">&quot;en&quot;</span>,\n  },\n};\n\n<span class="hljs-comment">// 页面中使用</span>\n<span class="hljs-keyword">import</span> { useRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/router&quot;</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> { locale } = <span class="hljs-title function_">useRouter</span>();\n  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Current language: {locale}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;\n}\n</code></pre>\n<p><strong>优势</strong>   ：<br>\n✅ 内置路由级国际化支持，无需第三方库。<br>\n✅ 自动处理 URL 前缀（如 <code>/en/about</code>）。</p>\n<hr>\n<h3><strong>6. 高性能前端（代码分割、图片优化）</strong></h3>\n<h4><strong>适用场景</strong></h4>\n<ul>\n<li><strong>大型单页应用（SPA）</strong>   ：需要按需加载代码。</li>\n<li><strong>媒体密集型站点</strong>   ：自动优化图片尺寸和格式。</li>\n</ul>\n<h4><strong>技术实现</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 动态导入组件（代码分割）</span>\n<span class="hljs-keyword">import</span> dynamic <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/dynamic&quot;</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">HeavyComponent</span> = <span class="hljs-title function_">dynamic</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;../components/HeavyComponent&quot;</span>));\n\n<span class="hljs-comment">// 自动优化图片</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/image&quot;</span>;\n\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/photo.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Photo&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{500}</span> <span class="hljs-attr">height</span>=<span class="hljs-string">{300}</span> /&gt;</span></span>;\n</code></pre>\n<p><strong>优势</strong>   ：<br>\n✅ 自动代码分割，减少初始加载体积。<br>\n✅ 图片懒加载 + WebP 自动转换。</p>\n<hr>\n<h3><strong>何时不推荐用 Next.js？</strong></h3>\n<ul>\n<li><strong>纯静态站点</strong>   ：内容极少变化，可用更轻量的工具（如 Astro）。</li>\n<li><strong>无 SEO 需求的 SPA</strong>   ：如后台管理系统，直接用 Create React App 更简单。</li>\n<li><strong>需要深度后端集成</strong>   ：如复杂微服务架构，可能需要单独后端（如 Nest.js）。</li>\n</ul>\n<hr>\n<h3><strong>总结：Next.js 的核心优势</strong></h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>技术方案</th>\n<th>优势</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SEO 关键页面</td>\n<td>SSR</td>\n<td>搜索引擎友好，首屏快</td>\n</tr>\n<tr>\n<td>内容型站点（博客）</td>\n<td>SSG</td>\n<td>超快加载，CDN 友好</td>\n</tr>\n<tr>\n<td>用户仪表盘</td>\n<td>SSR + API Routes</td>\n<td>实时数据，免跨域</td>\n</tr>\n<tr>\n<td>多语言网站</td>\n<td>i18n</td>\n<td>内置路由国际化</td>\n</tr>\n<tr>\n<td>大型应用</td>\n<td>代码分割</td>\n<td>按需加载，优化性能</td>\n</tr>\n</tbody>\n</table>\n<p>Next.js 适合大多数现代 Web 应用，尤其在需要<strong>SEO</strong>   、<strong>性能优化</strong>   或<strong>全栈能力</strong>   时是最佳选择。</p>\n</div>'</script></body></html>