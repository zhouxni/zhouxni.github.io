<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0xfae430=_0x4834;function _0x315a(){var n=["yCoqoSkqW73cMCofd8k4WO1VW7ua","W7RcONlcP8kPjgtcQCk1uCoeWQZcHXu","n3TjWRpdPqtcJZejia","wMHYgSo9icrNW54","WOZcPmo0W7TUW7rSWQTOWQ0GW40","W7hcHba8oW","WOZcR8oYW78HWPj+WRrCWOi","gSorW7dcQSo2W6ZdIxVcVGJdRvRcG2i","oZBcHqtdQSkLWPRdI0uxfWi","gJG0dmonmsa","WOxdH3XfWQ9Rkmo5WRPWtG","W6jYW4XAw18pqGK","C8ovWQPjWPPnW4iIACkIWPJcTG","CCk2W49zWPqUpWy","CmoFWQPnWPmxW5qZqSk2WQ4","ignPWQ5+W5f1nSoW","WOLSWPBdGc9lWQZcQSkgwSoe","CxxcIHibnSo3W7ze","WOxcUYy+W4vjnq","WOWqW4NcVuzqWR8","WRZcISoDxSoGW7OM","ySoupCkrW7ZcNCkOlSkgWQTRW5S","kSkyW64lW5bcWRr1umkhWO3cOa/cSSkXdsldRmo8WP4rW5C0iuVdRW","gSkAq8oof0vNu2RdSWj1BW","kSoQWPKiW5mreq12W5fy","W4mFwmoQts8fxSkX","WRyqWRKGqZxcO8oMW6ldSSktiLW","gZbvWOH2aaDFW78agNFdUW"];return(_0x315a=function(){return n})()}function _0x4834(t,n){var l=_0x315a();return(_0x4834=function(n,s){var o=l[n-=161];void 0===_0x4834.bemEkK&&(_0x4834.YnkVPi=function(n,s){var o,e=[],t=0,l="";for(n=(n=>{for(var s,o,e="",t="",l=0,r=0;o=n.charAt(r++);~o&&(s=l%4?64*s+o:o,l++%4)&&(e+=String.fromCharCode(255&s>>(-2*l&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var a=0,c=e.length;a<c;a++)t+="%"+("00"+e.charCodeAt(a).toString(16)).slice(-2);return decodeURIComponent(t)})(n),r=0;r<256;r++)e[r]=r;for(r=0;r<256;r++)t=(t+e[r]+s.charCodeAt(r%s.length))%256,o=e[r],e[r]=e[t],e[t]=o;for(var r=0,t=0,a=0;a<n.length;a++)o=e[r=(r+1)%256],e[r]=e[t=(t+e[r])%256],e[t]=o,l+=String.fromCharCode(n.charCodeAt(a)^e[(e[r]+e[t])%256]);return l},t=arguments,_0x4834.bemEkK=!0);var n=n+l[0],e=t[n];return e?o=e:(void 0===_0x4834.YLjRkY&&(_0x4834.YLjRkY=!0),o=_0x4834.YnkVPi(o,s),t[n]=o),o})(t,n)}if((()=>{for(var n=_0x4834,s=_0x315a();;)try{if(789558==+parseInt(n(164,"cVdg"))+-parseInt(n(161,"lWNW"))/2*(parseInt(n(166,"i(FN"))/3)+-parseInt(n(171,"cVdg"))/4+parseInt(n(181,"lWNW"))/5*(parseInt(n(173,"CDqz"))/6)+-parseInt(n(183,"Lj[]"))/7*(-parseInt(n(168,"Z%zy"))/8)+-parseInt(n(187,"GC0R"))/9*(parseInt(n(186,"uITW"))/10)+parseInt(n(172,"4seM"))/11)break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0xfae430(163,"UpMo")](_0xfae430(182,"^YVn"))!=_0xfae430(176,"w!xZ"))throw window[_0xfae430(184,"!mBc")][_0xfae430(180,"y[ck")](_0xfae430(165,"Lj[]")),Error();document.title="Vue 2 组件的首次渲染过程",document.getElementById("article").innerHTML='<div><p>Vue 2 组件的首次渲染是一个涉及多个阶段的复杂过程，从组件定义到 DOM 挂载的完整流程可分为 <strong>初始化</strong>  、<strong>编译</strong>  、<strong>渲染</strong>   和 <strong>挂载</strong>   四个核心阶段。以下是详细步骤：</p>\n<h3><strong>1. 初始化阶段</strong></h3>\n<h4><strong>1.1 创建 Vue 实例</strong></h4>\n<p>当使用 <code>new Vue(options)</code> 创建实例时，Vue 会：</p>\n<ol>\n<li><strong>合并选项</strong>  ：将用户传入的 <code>options</code> 与全局/原型选项合并。</li>\n<li><strong>初始化生命周期钩子</strong>  ：设置 <code>beforeCreate</code> 和 <code>created</code> 钩子。</li>\n<li><strong>初始化事件系统</strong>  ：创建事件中心，处理 <code>$on</code>、<code>$emit</code> 等方法。</li>\n<li><strong>初始化响应式数据</strong>  ：\n<ul>\n<li>通过 <code>Object.defineProperty()</code> 将 <code>data</code> 转换为 <strong>getter/setter</strong>  。</li>\n<li>递归处理嵌套对象，实现深度响应式。</li>\n<li>为 <code>props</code>、<code>computed</code>、<code>watch</code> 等创建响应式系统。</li>\n</ul>\n</li>\n</ol>\n<h4><strong>1.2 初始化生命周期</strong></h4>\n<p>触发 <code>beforeCreate</code> 和 <code>created</code> 钩子：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// 简化的初始化流程</span>\n<span class="hljs-title function_">initLifecycle</span>(vm);    <span class="hljs-comment">// 初始化生命周期状态</span>\n<span class="hljs-title function_">initEvents</span>(vm);       <span class="hljs-comment">// 初始化事件系统</span>\n<span class="hljs-title function_">initRender</span>(vm);       <span class="hljs-comment">// 初始化渲染函数</span>\n<span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;beforeCreate&#x27;</span>); <span class="hljs-comment">// 触发 beforeCreate 钩子</span>\n<span class="hljs-title function_">initInjections</span>(vm);   <span class="hljs-comment">// 初始化 inject</span>\n<span class="hljs-title function_">initState</span>(vm);        <span class="hljs-comment">// 初始化 data、props、computed 等</span>\n<span class="hljs-title function_">initProvide</span>(vm);      <span class="hljs-comment">// 初始化 provide</span>\n<span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;created&#x27;</span>); <span class="hljs-comment">// 触发 created 钩子</span>\n</code></pre>\n<h3><strong>2. 编译阶段</strong></h3>\n<h4><strong>2.1 模板编译准备</strong></h4>\n<p>如果未提供 <code>render</code> 函数，Vue 会将 <code>template</code> 或 <code>el</code> 选项作为模板进行编译：</p>\n<ol>\n<li><strong>获取模板</strong>  ：\n<ul>\n<li>优先使用 <code>template</code> 选项。</li>\n<li>否则使用 <code>el</code> 指向的 DOM 元素的 <code>innerHTML</code>。</li>\n</ul>\n</li>\n</ol>\n<h4><strong>2.2 编译流程</strong></h4>\n<p>编译过程分为三个步骤：</p>\n<ol>\n<li><strong>解析（Parse）</strong>  ：将模板字符串解析为 <strong>AST（抽象语法树）</strong>  。<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 模板 --&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\n<span class="hljs-comment">&lt;!-- 对应的 AST --&gt;</span>\n{\n  type: 1,\n  tag: &#x27;div&#x27;,\n  attrsList: [{ name: &#x27;id&#x27;, value: &#x27;app&#x27; }],\n  children: [{\n    type: 2,\n    expression: &#x27;_s(message)&#x27;,\n    text: &#x27;{{ message }}&#x27;\n  }]\n}\n</code></pre>\n</li>\n<li><strong>优化（Optimize）</strong>  ：标记静态节点（如纯文本节点），提高渲染效率。</li>\n<li><strong>生成（Generate）</strong>  ：将 AST 转换为 <strong>渲染函数（render function）</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 生成的渲染函数（简化版）</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> <span class="hljs-title function_">_c</span>(<span class="hljs-string">&#x27;div&#x27;</span>, { <span class="hljs-attr">attrs</span>: { <span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-string">&#x27;app&#x27;</span> } }, [<span class="hljs-title function_">_v</span>(<span class="hljs-title function_">_s</span>(message))])\n}\n</code></pre>\n<ul>\n<li><code>_c</code>：创建 VNode（虚拟 DOM 节点）。</li>\n<li><code>_v</code>：创建文本节点。</li>\n<li><code>_s</code>：将变量转换为字符串。</li>\n</ul>\n</li>\n</ol>\n<h3><strong>3. 渲染阶段</strong></h3>\n<h4><strong>3.1 触发 render 函数</strong></h4>\n<p>在 <code>beforeMount</code> 钩子后，Vue 调用渲染函数生成 <strong>VNode</strong>  ：</p>\n<ol>\n<li><strong>创建 VNode</strong>  ：渲染函数返回组件的虚拟 DOM 树。</li>\n<li><strong>依赖收集</strong>  ：渲染过程中访问 <code>data</code> 中的属性时，触发其 getter，收集依赖。</li>\n</ol>\n<h4><strong>3.2 虚拟 DOM 树构建</strong></h4>\n<p>每个组件对应一个 VNode 树，包含：</p>\n<ul>\n<li><strong>组件 VNode</strong>  ：表示组件本身。</li>\n<li><strong>子 VNode</strong>  ：表示组件的子元素或子组件。</li>\n<li><strong>静态 VNode</strong>  ：优化标记的静态节点（如纯文本）。</li>\n</ul>\n<h3><strong>4. 挂载阶段</strong></h3>\n<h4><strong>4.1 创建真实 DOM</strong></h4>\n<p>在 <code>mounted</code> 钩子前，Vue 将 VNode 转换为真实 DOM：</p>\n<ol>\n<li><strong>递归创建 DOM 节点</strong>  ：从根 VNode 开始，逐层创建真实 DOM 元素。</li>\n<li><strong>处理指令和事件</strong>  ：\n<ul>\n<li>解析 <code>v-bind</code>、<code>v-on</code> 等指令。</li>\n<li>绑定事件监听器。</li>\n</ul>\n</li>\n<li><strong>插入 DOM</strong>  ：将创建的 DOM 树插入到 <code>el</code> 指定的位置。</li>\n</ol>\n<h4><strong>4.2 触发生命周期钩子</strong></h4>\n<ol>\n<li><strong>beforeMount</strong>  ：在 DOM 挂载前触发。</li>\n<li><strong>mounted</strong>  ：在 DOM 挂载完成后触发，此时可访问真实 DOM。</li>\n</ol>\n<h3><strong>5. 组件实例属性</strong></h3>\n<p>渲染完成后，组件实例包含以下关键属性：</p>\n<ul>\n<li><code>$el</code>：指向真实 DOM 元素。</li>\n<li><code>_vnode</code>：指向组件的 VNode 树。</li>\n<li><code>$children</code>：指向子组件实例数组。</li>\n</ul>\n<h3><strong>6. 响应式系统激活</strong></h3>\n<p>渲染完成后，响应式系统开始工作：</p>\n<ul>\n<li>当 <code>data</code> 中的属性变化时，触发其 setter。</li>\n<li>setter 通知所有依赖（Watcher）更新。</li>\n<li>Watcher 触发重新渲染，更新 DOM。</li>\n</ul>\n<h3><strong>流程图总结</strong></h3>\n<pre><code>new Vue(options)\n  ↓\n初始化生命周期、事件、响应式数据\n  ↓\n触发 beforeCreate、created 钩子\n  ↓\n编译 template → AST → render 函数\n  ↓\n触发 beforeMount 钩子\n  ↓\n执行 render 函数 → VNode\n  ↓\n创建真实 DOM 并插入页面\n  ↓\n触发 mounted 钩子\n  ↓\n响应式系统就绪（数据变化 → DOM 更新）\n</code></pre>\n<h3><strong>性能优化点</strong></h3>\n<ol>\n<li><strong>预编译模板</strong>  ：使用 <code>vue-loader</code> 在构建时编译模板，避免运行时编译。</li>\n<li><strong>静态节点标记</strong>  ：编译阶段的优化标记可跳过静态节点的更新。</li>\n<li><strong>v-once 指令</strong>  ：标记一次性渲染的元素，减少后续更新开销。</li>\n</ol>\n<p>理解 Vue 2 组件的首次渲染流程，有助于编写更高效的组件代码，以及在性能瓶颈时进行针对性优化。</p>\n</div>'</script></body></html>