<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x188e0e=_0x54d5;function _0x1f01(){var n=["omkvW7GZzMDUgmog","W4Glc8oGW4ydB0nIBSowoqq","WOhdMmoyW6hdMc3dSW","q8kNW6xdGrT0na","WPOdWQq4W702ASkGW75ys0yJ","W7nrW7W8W79Aza","DgeeAHv0W7mwwCkAWOVdKLq","W50zta/dLhvd","oSkwW7PLp2vNoSo6W5X2","EWxdG8oryCkjeKhdOrPeWQnBpCoBldKttSoGtmoOqLGnWRS","WP5nbfdcJcysWRrCWRNdO2xdIG","zCkkhmkrWPLSmSkIWQjQWRRdMJ4","W5PnW6ZcLCk7FN0pWP4","WOpcNaxdVSkbq0G","pgqFW64BnmoPWRRcKmo8WR3cRmo4","W5VcGdidnvZdKxy","WQZdR8kQpGeAWPq","jCouc8k6WPpdU8oXsa","WRxdPCkYW7vtW70GW6BdTSoLWRy","vua5Cmklr8otWPtdLLLJW5VcMq","vurMkmo7iCkLWRi","fHOtv8kIe8kqWO8","aalcNdlcV0dcICk3g3Cma8o5","WQ0AWRFdImo8y1WMWQjlWOG","BNj9gmkgtCoSt8kEv8oSW53dLW","W6FdU2SGlcz7gW","rSknW5m6yG","imovqCoAW5ldPmo0ESotCCor","dtFcMCkWWRDhWOpdOreUWQaJvq","WOiPW4RdRCo5cNKCCW"];return(_0x1f01=function(){return n})()}function _0x54d5(e,n){var s=_0x1f01();return(_0x54d5=function(n,t){var o=s[n-=284];void 0===_0x54d5.QDDdpA&&(_0x54d5.EHgfHn=function(n,t){var o,d=[],e=0,s="";for(n=(n=>{for(var t,o,d="",e="",s=0,a=0;o=n.charAt(a++);~o&&(t=s%4?64*t+o:o,s++%4)&&(d+=String.fromCharCode(255&t>>(-2*s&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var r=0,l=d.length;r<l;r++)e+="%"+("00"+d.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(e)})(n),a=0;a<256;a++)d[a]=a;for(a=0;a<256;a++)e=(e+d[a]+t.charCodeAt(a%t.length))%256,o=d[a],d[a]=d[e],d[e]=o;for(var a=0,e=0,r=0;r<n.length;r++)o=d[a=(a+1)%256],d[a]=d[e=(e+d[a])%256],d[e]=o,s+=String.fromCharCode(n.charCodeAt(r)^d[(d[a]+d[e])%256]);return s},e=arguments,_0x54d5.QDDdpA=!0);var n=n+s[0],d=e[n];return d?o=d:(void 0===_0x54d5.HETcbA&&(_0x54d5.HETcbA=!0),o=_0x54d5.EHgfHn(o,t),e[n]=o),o})(e,n)}if((()=>{for(var n=_0x54d5,t=_0x1f01();;)try{if(569718==-parseInt(n(285,"6*I6"))*(-parseInt(n(298,"0NTj"))/2)+-parseInt(n(304,"4^aB"))/3+-parseInt(n(284,"Z7O$"))/4*(-parseInt(n(292,"ApeH"))/5)+parseInt(n(309,"akJ@"))/6+-parseInt(n(306,"n[!C"))/7*(-parseInt(n(288,"sZIY"))/8)+-parseInt(n(296,"b[lR"))/9*(parseInt(n(310,"akJ@"))/10)+parseInt(n(290,"0NTj"))/11*(parseInt(n(313,"T9B7"))/12))break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x188e0e(295,"!!pa")](_0x188e0e(302,"T9B7"))!=_0x188e0e(286,"TWsu"))throw window[_0x188e0e(305,"PxIt")][_0x188e0e(297,"o!ZU")](_0x188e0e(299,"3MVt")),Error();document.title="HTTP2 的 头部压缩",document.getElementById("article").innerHTML='<div><p>HTTP/2 的 <strong>头部压缩（Header Compression）</strong>   是解决 HTTP 头部冗余传输问题的关键技术，通过 <strong>HPACK 算法</strong>   实现，平均可减少 60%-70% 的头部数据传输量，显著提升性能。以下是详细解析：</p>\n<h3>一、为什么需要头部压缩？</h3>\n<p>HTTP/1.x 存在严重的头部传输冗余问题：</p>\n<ul>\n<li><strong>重复传输</strong>   ：每次请求都需携带大量相同的头部（如 <code>User-Agent</code>、<code>Cookie</code>、<code>Host</code> 等）。</li>\n<li><strong>文本格式低效</strong>   ：头部以明文传输，包含大量分隔符（空格、换行），额外消耗带宽。</li>\n<li><strong>体积可观</strong>   ：复杂请求的头部（含 Cookie）可达 1KB-2KB，甚至超过响应体本身。</li>\n</ul>\n<p>例如，一个带 Cookie 的请求头部可能重复传输类似内容：</p>\n<pre><code class="language-http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/api/data</span> <span class="hljs-meta">HTTP/1.1</span>\n<span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com\n<span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; ...)\n<span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>sessionid=abc123; user=12345; ...\n<span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,...\n</code></pre>\n<p>HTTP/2 的 HPACK 算法正是为解决这些问题设计的。</p>\n<h3>二、HPACK 算法核心原理</h3>\n<p>HPACK 基于 <strong>静态字典 + 动态字典 + 霍夫曼编码</strong>   三者结合实现压缩，核心思路是：<strong>重复的头部字段不重复传输，仅传输索引或差异部分</strong>   。</p>\n<h4>1. 静态字典（Static Table）</h4>\n<ul>\n<li>预定义了 61 个最常用的头部键值对（HTTP/2 规范固定），客户端和服务器都内置这份字典，无需额外传输。</li>\n<li>每个键值对有唯一索引（1-61），传输时只需发送索引即可替代完整字段。</li>\n</ul>\n<p><strong>示例静态字典条目</strong>   ：</p>\n<table>\n<thead>\n<tr>\n<th>索引</th>\n<th>键</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2</td>\n<td><code>:method</code></td>\n<td><code>GET</code></td>\n</tr>\n<tr>\n<td>8</td>\n<td><code>:status</code></td>\n<td><code>200</code></td>\n</tr>\n<tr>\n<td>16</td>\n<td><code>accept-encoding</code></td>\n<td><code>gzip, deflate</code></td>\n</tr>\n<tr>\n<td>22</td>\n<td><code>user-agent</code></td>\n<td>（常见浏览器标识）</td>\n</tr>\n</tbody>\n</table>\n<p>例如：传输 <code>:method: GET</code> 时，只需发送索引 <code>2</code>（1字节），无需传输完整的 <code>:method: GET</code>（10字节）。</p>\n<h4>2. 动态字典（Dynamic Table）</h4>\n<ul>\n<li>双方动态维护的临时字典，用于存储本次连接中已传输过的自定义头部（如 <code>Cookie</code>、<code>X-Custom-Header</code> 等）。</li>\n<li>采用 <strong>FIFO（先进先出）</strong>   策略，满了之后会淘汰最早的条目。</li>\n<li>动态字典的索引从 62 开始（接续静态字典的最大索引 61）。</li>\n</ul>\n<p><strong>工作流程示例</strong>   ：</p>\n<ol>\n<li>首次传输 <code>Cookie: sessionid=abc123</code> 时，动态字典为空，需传输完整键值对（经霍夫曼编码压缩），同时将其加入动态字典（索引 62）。</li>\n<li>再次传输相同 <code>Cookie</code> 时，只需发送索引 <code>62</code>（1字节），无需重复传输完整值。</li>\n</ol>\n<h4>3. 霍夫曼编码（Huffman Coding）</h4>\n<ul>\n<li>对头部中不重复的部分（如静态/动态字典中没有的键值对）进行压缩的算法。</li>\n<li>原理：为高频字符分配短编码（如 <code>:</code> 用 2 位），低频字符分配长编码，减少整体字节数。</li>\n<li>HPACK 定义了专门的霍夫曼码表（针对 HTTP 头部常见字符优化），平均可压缩 30% 文本。</li>\n</ul>\n<h3>三、头部压缩的完整流程</h3>\n<p>以一个实际请求为例，展示 HPACK 如何压缩头部：</p>\n<h4>原始请求头部（未压缩，约 300 字节）：</h4>\n<pre><code class="language-http">:method: GET\n:path: /index.html\n:authority: example.com\n<span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64)\n<span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>sessionid=abc123; theme=dark\n<span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml\n</code></pre>\n<h4>HPACK 压缩步骤：</h4>\n<ol>\n<li>\n<p><strong>静态字典匹配</strong>   ：</p>\n<ul>\n<li><code>:method: GET</code> → 匹配静态字典索引 <code>2</code>（传输 <code>2</code>，1字节）。</li>\n<li><code>:authority: example.com</code> → 无完全匹配，仅键 <code>:authority</code> 在静态字典（索引 1），需传输索引 <code>1</code> + 霍夫曼编码的 <code>example.com</code>。</li>\n</ul>\n</li>\n<li>\n<p><strong>动态字典处理</strong>   ：</p>\n<ul>\n<li>首次传输 <code>Cookie: sessionid=abc123; theme=dark</code> → 无匹配，用霍夫曼编码压缩后传输，并加入动态字典（索引 62）。</li>\n<li>二次传输相同 <code>Cookie</code> → 直接传输索引 <code>62</code>（1字节）。</li>\n</ul>\n</li>\n<li>\n<p><strong>霍夫曼编码</strong>   ：</p>\n<ul>\n<li><code>User-Agent</code> 部分内容未在字典中，用霍夫曼编码压缩字符（如 <code>Mozilla</code> 编码后字节数减少）。</li>\n</ul>\n</li>\n</ol>\n<h4>压缩后结果：</h4>\n<ul>\n<li>首次请求：压缩至约 100 字节（减少 67%）。</li>\n<li>二次请求：因 <code>Cookie</code> 等字段已在动态字典，压缩至约 60 字节（减少 80%）。</li>\n</ul>\n<h3>四、HPACK 与其他压缩算法的区别</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>HPACK</th>\n<th>Gzip/Deflate（HTTP/1.x 常用）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>压缩对象</td>\n<td>仅 HTTP 头部</td>\n<td>整个消息（头部 + 响应体）</td>\n</tr>\n<tr>\n<td>依赖上下文</td>\n<td>依赖连接上下文（字典）</td>\n<td>无上下文，独立压缩每个消息</td>\n</tr>\n<tr>\n<td>压缩效率（头部）</td>\n<td>高（重复字段几乎零开销）</td>\n<td>低（重复字段仍需重新压缩）</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>长期连接（复用字典）</td>\n<td>单次请求/短连接</td>\n</tr>\n</tbody>\n</table>\n<h3>五、实际应用注意事项</h3>\n<ol>\n<li><strong>字典大小限制</strong>   ：动态字典默认最大容量为 4096 字节，可通过 <code>SETTINGS</code> 帧协商调整（服务器和客户端可独立设置）。</li>\n<li><strong>安全性</strong>   ：HPACK 设计时考虑了 CRIME 攻击（利用压缩泄露信息），通过限制动态字典更新策略避免漏洞。</li>\n<li><strong>性能开销</strong>   ：维护字典和霍夫曼编码会增加少量 CPU 消耗，但远小于带宽节省带来的收益。</li>\n<li><strong>兼容性</strong>   ：所有 HTTP/2 实现必须支持 HPACK，无需额外配置（由协议自动处理）。</li>\n</ol>\n<h3>六、效果对比</h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>HTTP/1.x（无压缩）</th>\n<th>HTTP/2（HPACK）</th>\n<th>节省比例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>首次请求（复杂头部）</td>\n<td>1000 字节</td>\n<td>350 字节</td>\n<td>65%</td>\n</tr>\n<tr>\n<td>二次请求（重复头部）</td>\n<td>1000 字节</td>\n<td>150 字节</td>\n<td>85%</td>\n</tr>\n<tr>\n<td>100 次连续请求</td>\n<td>100,000 字节</td>\n<td>15,000 字节</td>\n<td>85%</td>\n</tr>\n</tbody>\n</table>\n<h3>总结</h3>\n<p>HTTP/2 的头部压缩通过 <strong>静态字典复用公共字段、动态字典缓存自定义字段、霍夫曼编码压缩新内容</strong>   的三层策略，大幅减少了头部传输体积，尤其适合长期连接和重复请求场景。结合二进制分帧的多路复用，HPACK 使 HTTP/2 在带宽效率上远超 HTTP/1.x，是现代 Web 性能优化的核心技术之一。</p>\n</div>'</script></body></html>