<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x7c3858=_0x24a3;function _0x24a3(l,n){var a=_0x5b7c();return(_0x24a3=function(n,s){var o=a[n-=231];void 0===_0x24a3.JZXbcV&&(_0x24a3.rcEdYx=function(n,s){var o,t=[],l=0,a="";for(n=(n=>{for(var s,o,t="",l="",a=0,e=0;o=n.charAt(e++);~o&&(s=a%4?64*s+o:o,a++%4)&&(t+=String.fromCharCode(255&s>>(-2*a&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var c=0,r=t.length;c<r;c++)l+="%"+("00"+t.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(l)})(n),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+s.charCodeAt(e%s.length))%256,o=t[e],t[e]=t[l],t[l]=o;for(var e=0,l=0,c=0;c<n.length;c++)o=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=o,a+=String.fromCharCode(n.charCodeAt(c)^t[(t[e]+t[l])%256]);return a},l=arguments,_0x24a3.JZXbcV=!0);var n=n+a[0],t=l[n];return t?o=t:(void 0===_0x24a3.aEAdVz&&(_0x24a3.aEAdVz=!0),o=_0x24a3.rcEdYx(o,s),l[n]=o),o})(l,n)}function _0x5b7c(){var n=["gg7cUSkdWPSqWPfcEG","WOddMJ4DW6nqESoTCsS","qYRdUmkaWRmFWPq2zq","F2VdNSopWPi","WQpcUCoMWP9Ro8oHWP5BW67dTSkuca","rY3dUmoxW7rDW6yvwuBcUJ0C","hgNcUSouW5XsW6nHrGFdNsFcNW","cuxdPHJcGCorACo7","WR5ieSkEWO40WPBcJG","umkTrhJdM8kAW5XRlcK","ocVcN8kjW59nW7xdSeNcQmo3eSoq","WRVdLJKyBMfYeMVdH8oFzCkfW5eIu8kKWPldUCoIffOzWPZcGHq","rvWBvxnrWRy","zCkTWPGQWPOKW7eylJD2W6dcGG","WRXcy8oSW4PqW47dNs4QWQzjWPDX","W6TYW5DlavHj","tfWcz8oUW6JcPCkghmksgIHI","fbdcI8ojWRSMW5r6smoHEa","CCoJputcVXhdV8okW7SGW6tdUYq","WRunEcpcOfFcIs4","vbJcTKJdHCoQySoroXxdIq","d3xdG8oTW6XmWOtdOLtdMdG","W7rCc8knWPNdUwy3w1HbW6fg","W6GFl8kqWO4gWPm","uCo0bqVdKSkpW7e","WP9ADtPsAsy","WOhcNuaYoCkXs8o5W5yzq8oaW5Sd","uuddLtZcUmoFrq","WOpcL0S2oCoqh8klW5i3xW","e8o7W4L6W51JWOi6eG"];return(_0x5b7c=function(){return n})()}if((()=>{for(var n=_0x24a3,s=_0x5b7c();;)try{if(546129==-parseInt(n(245,"Lp24"))*(parseInt(n(234,"PLGc"))/2)+-parseInt(n(244,"YAFS"))/3*(parseInt(n(235,"C%ap"))/4)+parseInt(n(232,"l4u7"))/5+parseInt(n(240,"Zsf6"))/6*(-parseInt(n(231,"dT%B"))/7)+-parseInt(n(253,"H]CP"))/8+-parseInt(n(241,"nrBP"))/9*(parseInt(n(238,"w)&c"))/10)+-parseInt(n(254,"pqD6"))/11*(-parseInt(n(259,"gb6Z"))/12))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x7c3858(233,"pqD6")](_0x7c3858(239,"H]CP"))!=_0x7c3858(243,"&A*("))throw window[_0x7c3858(247,"1TD[")][_0x7c3858(255,"rEt$")](_0x7c3858(251,"5LCe")),Error();document.title="http 简单请求和复杂请求",document.getElementById("article").innerHTML='<div><p>在 HTTP 协议中，跨域资源共享（CORS，Cross-Origin Resource Sharing）机制将请求分为<strong>简单请求</strong>  和<strong>复杂请求</strong>  ，以区分不同情况下的跨域处理方式。这种分类主要基于请求的方法和头部信息，旨在平衡安全性和灵活性。</p>\n<hr>\n<h3><strong>一、简单请求（Simple Request）</strong></h3>\n<p><strong>简单请求</strong>  是指那些对服务器影响较小、安全性较高的跨域请求。这类请求不需要服务器预先确认，浏览器会直接发送请求。</p>\n<h4><strong>1. 简单请求的条件</strong></h4>\n<p>要满足简单请求的条件，必须同时符合以下要求：</p>\n<ul>\n<li><strong>请求方法</strong>  ：\n<ul>\n<li>只能是 <code>GET</code>、<code>HEAD</code>、<code>POST</code> 方法。</li>\n</ul>\n</li>\n<li><strong>请求头部</strong>  ：\n<ul>\n<li>除了浏览器自动设置的头部（如 <code>User-Agent</code>、<code>Host</code>、<code>Origin</code> 等），只能包含以下字段：\n<ul>\n<li><code>Accept</code></li>\n<li><code>Accept-Language</code></li>\n<li><code>Content-Language</code></li>\n<li><code>Content-Type</code>（但值只能是以下三种之一）：\n<ul>\n<li><code>text/plain</code></li>\n<li><code>multipart/form-data</code></li>\n<li><code>application/x-www-form-urlencoded</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>其他限制</strong>  ：\n<ul>\n<li>请求中不能包含自定义头部字段。</li>\n<li>不能使用 <code>ReadableStream</code> 对象作为请求体。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>2. 简单请求的处理流程</strong></h4>\n<ol>\n<li><strong>浏览器发送请求</strong>  ：\n<ul>\n<li>浏览器直接发送实际的请求到目标服务器。</li>\n<li>在请求头中包含 <code>Origin</code> 字段，表明请求的来源。</li>\n</ul>\n</li>\n<li><strong>服务器响应</strong>  ：\n<ul>\n<li>服务器在响应头中包含 <code>Access-Control-Allow-Origin</code> 字段，指定允许访问的源。</li>\n<li>如果服务器允许该跨域请求，浏览器会正常处理响应。</li>\n<li>如果服务器不允许，浏览器会阻止响应，并抛出 CORS 错误。</li>\n</ul>\n</li>\n</ol>\n<h4><strong>3. 示例</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://example.com/data&#x27;</span>, {\n  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,\n  <span class="hljs-attr">headers</span>: {\n    <span class="hljs-string">&#x27;Accept&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>\n  }\n})\n.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())\n.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))\n.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, error));\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li>这是一个简单请求，因为使用了 <code>GET</code> 方法，且头部只包含 <code>Accept</code> 字段。</li>\n<li>浏览器会直接发送请求，服务器需要在响应中包含适当的 CORS 头部。</li>\n</ul>\n<hr>\n<h3><strong>二、复杂请求（Preflight Request）</strong></h3>\n<p><strong>复杂请求</strong>  是指那些可能对服务器产生较大影响或安全性较低的跨域请求。这类请求在发送实际请求之前，需要先发送一个<strong>预检请求</strong>  （Preflight Request）进行“询问”，以确认服务器是否允许该请求。</p>\n<h4><strong>1. 复杂请求的条件</strong></h4>\n<p>只要不符合简单请求的条件，就被视为复杂请求。常见情况包括：</p>\n<ul>\n<li><strong>请求方法</strong>  ：\n<ul>\n<li>使用了 <code>PUT</code>、<code>DELETE</code>、<code>CONNECT</code>、<code>OPTIONS</code>、<code>TRACE</code>、<code>PATCH</code> 等方法。</li>\n</ul>\n</li>\n<li><strong>请求头部</strong>  ：\n<ul>\n<li>包含了自定义头部字段（如 <code>X-Custom-Header</code>）。</li>\n<li><code>Content-Type</code> 的值不在简单请求允许的三种类型之内（如 <code>application/json</code>）。</li>\n</ul>\n</li>\n<li><strong>其他情况</strong>  ：\n<ul>\n<li>使用了 <code>ReadableStream</code> 对象作为请求体。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>2. 预检请求的处理流程</strong></h4>\n<ol>\n<li><strong>浏览器发送预检请求</strong>  ：\n<ul>\n<li>使用 <code>OPTIONS</code> 方法，向目标服务器发送预检请求。</li>\n<li>请求头中包含：\n<ul>\n<li><code>Origin</code>：请求的来源。</li>\n<li><code>Access-Control-Request-Method</code>：实际请求将使用的方法。</li>\n<li><code>Access-Control-Request-Headers</code>：实际请求将包含的自定义头部字段。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>服务器响应预检请求</strong>  ：\n<ul>\n<li>服务器在响应头中包含：\n<ul>\n<li><code>Access-Control-Allow-Origin</code>：允许访问的源。</li>\n<li><code>Access-Control-Allow-Methods</code>：允许的请求方法。</li>\n<li><code>Access-Control-Allow-Headers</code>：允许的请求头部字段。</li>\n<li><code>Access-Control-Allow-Credentials</code>（可选）：是否允许发送凭据（如 Cookies）。</li>\n<li><code>Access-Control-Max-Age</code>（可选）：预检请求的结果在缓存中有效的秒数。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>浏览器发送实际请求</strong>  ：\n<ul>\n<li>如果预检请求成功，浏览器会发送实际的请求。</li>\n<li>如果预检请求失败，浏览器会阻止实际请求，并抛出 CORS 错误。</li>\n</ul>\n</li>\n</ol>\n<h4><strong>3. 示例</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://example.com/data&#x27;</span>, {\n  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,\n  <span class="hljs-attr">headers</span>: {\n    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,\n    <span class="hljs-string">&#x27;X-Custom-Header&#x27;</span>: <span class="hljs-string">&#x27;value&#x27;</span>\n  },\n  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> })\n})\n.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())\n.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))\n.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, error));\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li>这是一个复杂请求，因为使用了 <code>POST</code> 方法，且 <code>Content-Type</code> 为 <code>application/json</code>，还包含了自定义头部 <code>X-Custom-Header</code>。</li>\n<li>浏览器会先发送一个 <code>OPTIONS</code> 预检请求，确认服务器是否允许该请求。</li>\n<li>如果预检请求成功，浏览器会发送实际的 <code>POST</code> 请求。</li>\n</ul>\n<hr>\n<h3><strong>三、简单请求与复杂请求的区别</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>简单请求</strong></th>\n<th><strong>复杂请求</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>请求方法</strong></td>\n<td><code>GET</code>、<code>HEAD</code>、<code>POST</code></td>\n<td>除简单请求方法外的其他方法（如 <code>PUT</code>、<code>DELETE</code>）</td>\n</tr>\n<tr>\n<td><strong>请求头部</strong></td>\n<td>仅允许特定的标准头部，<code>Content-Type</code> 受限</td>\n<td>允许自定义头部，<code>Content-Type</code> 不受限</td>\n</tr>\n<tr>\n<td><strong>预检请求</strong></td>\n<td>不需要</td>\n<td>需要先发送 <code>OPTIONS</code> 预检请求</td>\n</tr>\n<tr>\n<td><strong>安全性</strong></td>\n<td>较高，因为请求的影响较小</td>\n<td>较低，因为请求可能影响较大，需要预检确认</td>\n</tr>\n<tr>\n<td><strong>处理流程</strong></td>\n<td>浏览器直接发送实际请求</td>\n<td>浏览器先发送预检请求，确认后再发送实际请求</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>四、总结</strong></h3>\n<ul>\n<li><strong>简单请求</strong>  适用于对服务器影响较小、安全性较高的跨域请求，浏览器会直接发送请求。</li>\n<li><strong>复杂请求</strong>  适用于可能对服务器产生较大影响或安全性较低的跨域请求，需要先发送预检请求进行确认。</li>\n<li><strong>预检请求</strong>  是复杂请求的一部分，用于在发送实际请求之前，确认服务器是否允许该请求。</li>\n<li><strong>CORS 配置</strong>  ：服务器需要正确配置 CORS 头部，以允许合法的跨域请求。</li>\n</ul>\n<p><strong>建议</strong>  ：</p>\n<ul>\n<li>在开发跨域应用时，尽量使用简单请求，以减少预检请求的开销。</li>\n<li>如果必须使用复杂请求，确保服务器正确响应预检请求，并设置适当的 CORS 头部。</li>\n</ul>\n<hr>\n</div>'</script></body></html>