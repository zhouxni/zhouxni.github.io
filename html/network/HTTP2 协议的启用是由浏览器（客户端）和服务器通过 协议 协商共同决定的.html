<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x106a(){var o=["ddnstw/cPYy","D20pAbPdW6P/W7H9yhPRqG","dSogW7qaWRvaW4RdGa","FSoizXxdNG","WQJcJSk1W5vKW4HfWO9ftefc","hmokWRu/n39wWQGBjg8l","WRlcRCorbSofjv/dQSkpWQldJSogFq","ht4fWOxcK8oNW5tcRNtcICkYhmkG","bmoHWO/cSb3dPK4","W6/cVSoQgCoEW7xdK0hcPmk0W7ddQg/cO1vpW6pdTSoOWRFdRCo6mComFCos","W6/cHHtcJutcU8kIWPTvW7zGwmky","tCoOW5m+W43dMh4jAGFdMSkmW4S","WO9YWO3cHwVcSCkAWO/dItShBWi","WRXliuakda8YW77cMare","eG9zqbWaCSoNomoAddddQG","WQdcG8k7W5nGW4y+WRThv3v2W6C","ftX3W57dISkWWO3cHq","WP8timo1xSkIzmomWRpdKfPm","CSoxWR1WhSkJkhhcNq","nGLHjeuam3uJWR95W7m0W54","W6qTkcbUWP4yWRm","vmoyEMNdPXpcHre","WPJcUvBcQmoTWRFdPa","WRGSW4u9aKZcI8o4","pw9GW4VdGXmZELZdLX7cNmoa","i3XSFYJcIcG"];return(_0x106a=function(){return o})()}function _0x1c5f(r,o){var c=_0x106a();return(_0x1c5f=function(o,n){var t=c[o-=363];void 0===_0x1c5f.rFcSSF&&(_0x1c5f.hqHzDc=function(o,n){var t,T=[],r=0,c="";for(o=(o=>{for(var n,t,T="",r="",c=0,e=0;t=o.charAt(e++);~t&&(n=c%4?64*n+t:t,c++%4)&&(T+=String.fromCharCode(255&n>>(-2*c&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var l=0,d=T.length;l<d;l++)r+="%"+("00"+T.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(r)})(o),e=0;e<256;e++)T[e]=e;for(e=0;e<256;e++)r=(r+T[e]+n.charCodeAt(e%n.length))%256,t=T[e],T[e]=T[r],T[r]=t;for(var e=0,r=0,l=0;l<o.length;l++)t=T[e=(e+1)%256],T[e]=T[r=(r+T[e])%256],T[r]=t,c+=String.fromCharCode(o.charCodeAt(l)^T[(T[e]+T[r])%256]);return c},r=arguments,_0x1c5f.rFcSSF=!0);var o=o+c[0],T=r[o];return T?t=T:(void 0===_0x1c5f.STsfHd&&(_0x1c5f.STsfHd=!0),t=_0x1c5f.hqHzDc(t,n),r[o]=t),t})(r,o)}var _0x196315=_0x1c5f;if((()=>{for(var o=_0x1c5f,n=_0x106a();;)try{if(551885==+parseInt(o(376,"WR7s"))+parseInt(o(378,"1*Z1"))/2+parseInt(o(367,"1*Z1"))/3*(parseInt(o(383,"@19K"))/4)+parseInt(o(387,"ulch"))/5*(parseInt(o(371,"q#l6"))/6)+parseInt(o(373,"&9Yx"))/7*(-parseInt(o(379,"5xyh"))/8)+parseInt(o(377,"G34G"))/9+-parseInt(o(364,"z!4c"))/10)break;n.push(n.shift())}catch(o){n.push(n.shift())}})(),localStorage[_0x196315(385,"SNeB")](_0x196315(381,"L09t"))!=_0x196315(366,"Kuid"))throw window[_0x196315(384,"GzKH")][_0x196315(388,"Mv6!")](_0x196315(372,"E*Xl")),Error();document.title="HTTP2 协议的启用是由浏览器（客户端）和服务器通过 协议 协商共同决定的",document.getElementById("article").innerHTML='<div><p>你的理解完全正确，<strong>HTTP/2 协议的启用是由浏览器（客户端）和服务器通过“协议协商”共同决定的</strong>   ，开发者无法在代码层面直接强制开启或关闭，核心逻辑是“双方均支持 + 协商一致”。以下从“协商过程”“关键前提”“实际表现”三个维度展开，帮你更清晰理解这一机制：</p>\n<h3>一、HTTP/2 协议协商的核心流程</h3>\n<p>浏览器与服务器建立连接时，会通过 <strong>TLS 握手阶段的“ALPN 扩展”</strong>   （Application-Layer Protocol Negotiation，应用层协议协商）完成 HTTP 版本的确认，整个过程无需开发者干预，完全由双方底层协议栈自动处理，步骤如下：</p>\n<ol>\n<li>\n<p><strong>浏览器发起连接请求</strong><br>\n当浏览器访问 <code>https://xxx.com</code> 时（HTTP/2 主流场景基于 TLS，非 TLS 场景极少），会在 TLS 握手的“Client Hello”消息中，通过 <strong>ALPN 扩展</strong>   告诉服务器：“我支持的应用层协议列表包括 HTTP/2（标识为 <code>h2</code>）、HTTP/1.1（标识为 <code>http/1.1</code>）”。</p>\n</li>\n<li>\n<p><strong>服务器确认协议版本</strong><br>\n服务器收到请求后，检查自身是否支持浏览器提供的协议列表：</p>\n<ul>\n<li>若服务器支持 HTTP/2（已配置 HTTP/2 环境），则在 TLS 握手的“Server Hello”消息中，通过 ALPN 扩展回复：“我们使用 HTTP/2（<code>h2</code>）通信”；</li>\n<li>若服务器不支持 HTTP/2（仅支持 HTTP/1.1），则回复：“我们使用 HTTP/1.1（<code>http/1.1</code>）通信”。</li>\n</ul>\n</li>\n<li>\n<p><strong>建立对应协议的连接</strong><br>\n双方确认协议版本后，后续的所有数据传输（如请求帧、响应帧）都会遵循协商好的协议规范：</p>\n<ul>\n<li>协商为 HTTP/2：则使用二进制帧、多路复用等特性；</li>\n<li>协商为 HTTP/1.1：则退回到文本传输、串行请求等旧机制。</li>\n</ul>\n</li>\n</ol>\n<h3>二、协议协商的两个关键前提</h3>\n<p>浏览器与服务器要协商成功 HTTP/2，必须满足两个硬性条件，缺一不可：</p>\n<h4>1. 双方均需支持 HTTP/2</h4>\n<ul>\n<li><strong>服务器侧</strong>   ：需配置 HTTP/2 支持（如 Nginx 需添加 <code>http2 on;</code> 配置，Apache 需启用 <code>mod_http2</code> 模块，Tomcat 需开启 <code>HTTP/2 Connector</code>），且确保 TLS 版本不低于 1.2（HTTP/2 对 TLS 有最低版本要求，主流浏览器不支持 TLS 1.0/1.1 下的 HTTP/2）。</li>\n<li><strong>浏览器侧</strong>   ：现代浏览器（Chrome、Firefox、Safari、Edge 等）均已原生支持 HTTP/2（仅老旧浏览器如 IE 不支持），无需额外配置。</li>\n</ul>\n<h4>2. 必须使用 HTTPS 协议（主流场景）</h4>\n<p>虽然 HTTP/2 标准本身不强制要求 TLS（存在“明文 HTTP/2”，标识为 <code>h2c</code>），但 <strong>所有主流浏览器（Chrome、Safari 等）均仅支持“基于 TLS 的 HTTP/2”（标识为 <code>h2</code>）</strong>   ——原因是明文传输存在安全风险，且浏览器厂商希望推动 HTTPS 普及。<br>\n这意味着：若网站仅支持 HTTP（非 HTTPS），即使浏览器和服务器都支持 HTTP/2，也无法启用，只能使用 HTTP/1.1。</p>\n<h3>三、实际开发中的“协议表现”：如何判断是否启用 HTTP/2？</h3>\n<p>由于协议协商是自动的，开发者可通过工具查看实际使用的协议版本，验证是否启用 HTTP/2：</p>\n<h4>1. 浏览器端：通过 Network 面板查看</h4>\n<ol>\n<li>打开 Chrome/Firefox 开发者工具（F12），切换到「Network」面板；</li>\n<li>访问目标网站，点击任意一个请求，查看「Protocol」列：\n<ul>\n<li>显示 <code>h2</code>：表示已启用 HTTP/2；</li>\n<li>显示 <code>http/1.1</code>：表示协商为 HTTP/1.1（可能是服务器不支持，或 TLS 配置不满足）。</li>\n</ul>\n</li>\n</ol>\n<h4>2. 服务器端：通过配置或工具验证</h4>\n<ul>\n<li>查看服务器配置：如 Nginx 配置文件中是否有 <code>listen 443 ssl http2;</code>（443 是 HTTPS 默认端口，<code>http2</code> 关键字表示启用 HTTP/2）；</li>\n<li>使用在线工具：通过 <a href="https://www.ssllabs.com/ssltest/" target="_blank">SSL Labs</a> 检测网站，在“Protocol Details”中可看到是否支持 HTTP/2。</li>\n</ul>\n<h3>四、常见误区：“开发者能否干预协议协商？”</h3>\n<p>很多开发者会误以为“可以通过代码（如前端 JS、后端接口）强制启用 HTTP/2”，但实际是 <strong>无法干预</strong>   ，原因如下：</p>\n<ul>\n<li>前端层面：浏览器的 ALPN 协议列表是内置的，无法通过 <code>axios</code>、<code>fetch</code>、<code>&lt;script&gt;</code> 等标签修改，只能被动接受协商结果；</li>\n<li>后端层面：服务器的协议支持是通过配置决定的（如 Nginx 开启 <code>http2</code>），但最终是否使用 HTTP/2，仍需看浏览器是否支持（若浏览器仅支持 HTTP/1.1，服务器也会退回到旧协议）。</li>\n</ul>\n<h3>总结</h3>\n<ul>\n<li><strong>核心结论</strong>   ：HTTP/2 的启用是“浏览器与服务器双向协商”的结果，双方均需满足“支持 HTTP/2 + 基于 TLS（主流场景）”，协商过程完全自动化；</li>\n<li><strong>开发者角色</strong>   ：无需在代码中处理协议版本，只需确保两件事——① 服务器正确配置 HTTP/2 和 TLS；② 目标用户使用现代浏览器；</li>\n<li>实际验证：通过浏览器 Network 面板或 SSL 检测工具，即可确认当前连接是否使用 HTTP/2。</li>\n</ul>\n</div>'</script></body></html>