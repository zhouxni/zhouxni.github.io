<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x53ad(){var n=["WPddQCorW4PszK7dUSksW4T+W6JdHG","W40qW6DbnmkXv8kAWQONWRym","ECoaWOibCfBdMG","C8k3W6XeWRflWPCTmGxdPCodbq","B8o/DJ3dHmo2W5C","WR0oiSkOb2fkW5ldQW","eCoji8k1z1ZcJ8ocWP0","WPRdRw0mW4y","W77cPmovyCkxxSoFW7CoWPldTmk3kW","qIbzy8k+edbXySkuW6q","rw5MWQZdGCkTEmoDWQ3dM3S","lCoVW5FcHcvkor0PdvS2WRG","WQb6WO4mW4JdSvNdPLVdIg3dRSok","kCoQWR0tW7eAW4av","rw1KWQ3dHSoUzCoTWOtdPuuB","W69UW6XeW7lcRgrSW7O","W4OqW6DdoSk6cCkxWReuWRCciG","smkyW51grZuFACkidmkusW","x8ofWR7dJ8oklSoF","fs3cMfJdG39O","xNKqW4VcSCkKWORcRSkhWOVcKaa","WR/dISkzW7f7WQVcVmkwAJyioGS","W7erg8kRb0vioWFdKmoHW4GhWQNcISkadmkOv8k0WQtdUmoMW5FdIGq","hSohkCoXdH7dLmowWOFdTmoupgy"];return(_0x53ad=function(){return n})()}var _0x5ca4b5=_0x316f;function _0x316f(d,n){var l=_0x53ad();return(_0x316f=function(n,t){var r=l[n-=344];void 0===_0x316f.TpXsEs&&(_0x316f.sAGioq=function(n,t){var r,o=[],d=0,l="";for(n=(n=>{for(var t,r,o="",d="",l=0,W=0;r=n.charAt(W++);~r&&(t=l%4?64*t+r:r,l++%4)&&(o+=String.fromCharCode(255&t>>(-2*l&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var i=0,a=o.length;i<a;i++)d+="%"+("00"+o.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(d)})(n),W=0;W<256;W++)o[W]=W;for(W=0;W<256;W++)d=(d+o[W]+t.charCodeAt(W%t.length))%256,r=o[W],o[W]=o[d],o[d]=r;for(var W=0,d=0,i=0;i<n.length;i++)r=o[W=(W+1)%256],o[W]=o[d=(d+o[W])%256],o[d]=r,l+=String.fromCharCode(n.charCodeAt(i)^o[(o[W]+o[d])%256]);return l},d=arguments,_0x316f.TpXsEs=!0);var n=n+l[0],o=d[n];return o?r=o:(void 0===_0x316f.KZVOyd&&(_0x316f.KZVOyd=!0),r=_0x316f.sAGioq(r,t),d[n]=r),r})(d,n)}if((()=>{for(var n=_0x316f,t=_0x53ad();;)try{if(556915==-parseInt(n(351,"d!Pi"))+parseInt(n(357,"PgyV"))/2+-parseInt(n(346,"0bGW"))/3*(-parseInt(n(367,"YSqv"))/4)+parseInt(n(353,"deTH"))/5*(-parseInt(n(356,"dESp"))/6)+-parseInt(n(345,"Uof5"))/7+parseInt(n(360,"YSqv"))/8+-parseInt(n(364,"S$T9"))/9)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x5ca4b5(365,"[O&z")](_0x5ca4b5(352,"4ISK"))!=_0x5ca4b5(344,"gEB9"))throw window[_0x5ca4b5(350,"S$T9")][_0x5ca4b5(355,"^*Nn")](_0x5ca4b5(359,"xyEL")),Error();document.title="HTTP2 的“双向通信”本质",document.getElementById("article").innerHTML="<div><p>HTTP/2 的“双向通信”本质是在单个 TCP 连接上实现客户端与服务器之间的<strong>全双工数据传输</strong>  ，并通过二进制分帧层将数据拆分为独立帧，使多个数据流能在同一连接上同时双向流动。以下从技术原理、核心机制及与 HTTP/1.x 的对比等方面详细解析：</p>\n<h3>一、双向通信的技术本质：全双工与二进制分帧的结合</h3>\n<ol>\n<li><strong>全双工传输的底层支撑</strong><br>\nTCP 协议本身支持全双工通信（通信双方可同时发送和接收数据），HTTP/2 基于此特性，在应用层通过<strong>二进制分帧层</strong>  将 HTTP 消息分解为多个独立的帧（Frame）。每个帧携带属于特定数据流（Stream）的片段，且帧的发送顺序可以乱序，接收端根据帧头部的流标识符（Stream ID）重新组装数据。\n<ul>\n<li>例如：客户端发送请求帧的同时，服务器可发送响应帧，两者互不阻塞，真正实现“双向同时通信”。</li>\n</ul>\n</li>\n<li><strong>数据流（Stream）的双向性</strong><br>\n每个数据流是一个双向字节流，客户端和服务器均可作为发送方或接收方。例如：\n<ul>\n<li>客户端创建数据流发送请求（如获取 HTML），服务器在同一数据流中返回响应；</li>\n<li>服务器也可主动在新数据流中发送 PUSH_PROMISE 帧，推送资源给客户端（如 CSS 文件），形成服务器主动发起的双向通信。</li>\n</ul>\n</li>\n</ol>\n<h3>二、双向通信的核心机制：多路复用与流控制</h3>\n<ol>\n<li><strong>多路复用打破单向请求限制</strong><br>\nHTTP/1.x 中，客户端需按顺序发送请求，服务器按顺序响应，存在“队首阻塞”问题；而 HTTP/2 通过双向通信和多路复用，允许：\n<ul>\n<li>客户端在一个连接中同时发送多个请求帧（如请求 HTML、JS、图片），每个请求对应独立数据流；</li>\n<li>服务器同时处理多个数据流，并通过不同数据流返回响应，数据帧在网络中交错传输，接收端按 Stream ID 重组。<br>\n本质上，双向通信让“请求 - 响应”不再是单向顺序流程，而是多流并行的双向数据交换。</li>\n</ul>\n</li>\n<li><strong>流控制确保双向通信有序性</strong><br>\n为避免某一方发送数据过快导致对方缓冲区溢出，HTTP/2 通过 <strong>WINDOW_UPDATE 帧</strong>  实现双向流控制：\n<ul>\n<li>接收方为每个数据流和整个连接设置流量控制窗口，限制发送方的发送量；</li>\n<li>发送方根据窗口大小调整发送速率，当窗口为 0 时暂停发送，接收方释放缓冲区后通过 WINDOW_UPDATE 帧通知发送方继续传输。<br>\n该机制保证了双向通信中数据传输的平衡，避免资源浪费。</li>\n</ul>\n</li>\n</ol>\n<h3>三、与 HTTP/1.x 的本质区别：从“单向请求 - 响应”到“双向数据流交互”</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>HTTP/1.x</th>\n<th>HTTP/2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>通信模式</strong></td>\n<td>客户端单向发起请求，服务器单向响应</td>\n<td>客户端与服务器可双向主动发送数据</td>\n</tr>\n<tr>\n<td><strong>连接利用率</strong></td>\n<td>每个请求 - 响应需独立连接或复用连接但受顺序限制</td>\n<td>单个连接承载所有双向数据流，利用率极高</td>\n</tr>\n<tr>\n<td><strong>资源推送能力</strong></td>\n<td>无，服务器只能被动响应请求</td>\n<td>服务器可通过 PUSH_PROMISE 帧主动推送资源</td>\n</tr>\n<tr>\n<td><strong>队首阻塞</strong></td>\n<td>存在（请求或响应阻塞会影响后续流程）</td>\n<td>不存在（数据流独立，帧可乱序传输）</td>\n</tr>\n</tbody>\n</table>\n<h3>四、双向通信的应用价值：性能优化与服务器主动性</h3>\n<ol>\n<li><strong>降低延迟与提升吞吐量</strong><br>\n双向通信允许服务器在响应客户端请求的同时，主动推送其他资源（如通过 PUSH_PROMISE 帧推送 JS/CSS），减少客户端等待请求的时间。例如：\n<ul>\n<li>客户端请求 HTML 时，服务器在返回 HTML 响应的同时，通过新数据流推送相关资源，客户端无需额外发送请求，直接接收资源并渲染，缩短页面加载时间。</li>\n</ul>\n</li>\n<li><strong>服务器资源调度的灵活性</strong><br>\n双向通信赋予服务器主动控制数据传输的能力：\n<ul>\n<li>可根据优先级调整数据流的处理顺序（如高优先级请求优先响应）；</li>\n<li>可利用空闲连接带宽主动推送缓存资源，减少客户端重复请求。</li>\n</ul>\n</li>\n</ol>\n<h3>总结：双向通信的本质是“全双工+分帧+多路复用”的协议重构</h3>\n<p>HTTP/2 的双向通信并非简单的“客户端与服务器可以互相发数据”，其本质是通过二进制分帧将 HTTP 消息拆解为独立帧，在全双工 TCP 连接上实现多数据流的双向并行传输，打破了 HTTP/1.x 单向请求 - 响应的限制，使服务器从“被动响应”变为“主动调度”，最终实现网络资源的高效利用和性能优化。</p>\n</div>"</script></body></html>