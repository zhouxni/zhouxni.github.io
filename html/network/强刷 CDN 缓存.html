<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1550(){var s=["fI3cL3FcRmovg8o0s8ojpa","hqr2WRiOWOtdRse","D8oRW6yDWPXOgg3dNqpdMCkNpa","t0RcHvxcJ2JdOmkctCk3WQ/cNmki","Bt/cJZVdU8kGa8kegMBcQYi","qCkRWOi8bCo0WPZdRSkTyCkKBK8","CmkoWPTiW6OZBa","qf0HW6bOW5ZcTGSPdYLIWR0","W5NdNSoeW7jBfhZcPrNcTCoZW4FdRq","W41qW7VdOCoxl3SvEGKosW","W78+WOSTevpcJG","WPPsWQKkbKddQmk2","WOtdReNcRharW4ziW48","luJdOmkoW59gW7Kbh2WrW4G","WO/cJCkeWOGBqcu","W5xdMSoCW6yhhSoXzCouWQVcOx/cQa","W6NcNZjyWOlcMh0","c8oqW64QlSoLWQHduMGC","WRr1W6VcLvLrW40rW7q","vCkBWOpcOCouyrJcPGjSW73dIG","WQ3cVG9iWR0","WRRdHmkqfXBcQSkdWOPO","xCoOkSkbW7WmW7ZcHHa","bmoFW7pcNxFcQCoefq","W45BW7/cOSkjCuu+yG","W4ZdSr3dP8kmz8k9W7ZdPwJdMmkgW6W","fIWdW413xrVdHmoNpZlcVxK","WPZcJSkVexK7n8o1t8k6pmkKW6xcHmkoWP5VW7T3WO/cQSokBSk7owW"];return(_0x1550=function(){return s})()}var _0x1a78c4=_0x212b;function _0x212b(c,s){var t=_0x1550();return(_0x212b=function(s,n){var a=t[s-=350];void 0===_0x212b.mIYmyx&&(_0x212b.KqvaSO=function(s,n){var a,l=[],c=0,t="";for(s=(s=>{for(var n,a,l="",c="",t=0,o=0;a=s.charAt(o++);~a&&(n=t%4?64*n+a:a,t++%4)&&(l+=String.fromCharCode(255&n>>(-2*t&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,p=l.length;e<p;e++)c+="%"+("00"+l.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(c)})(s),o=0;o<256;o++)l[o]=o;for(o=0;o<256;o++)c=(c+l[o]+n.charCodeAt(o%n.length))%256,a=l[o],l[o]=l[c],l[c]=a;for(var o=0,c=0,e=0;e<s.length;e++)a=l[o=(o+1)%256],l[o]=l[c=(c+l[o])%256],l[c]=a,t+=String.fromCharCode(s.charCodeAt(e)^l[(l[o]+l[c])%256]);return t},c=arguments,_0x212b.mIYmyx=!0);var s=s+t[0],l=c[s];return l?a=l:(void 0===_0x212b.hmHSTn&&(_0x212b.hmHSTn=!0),a=_0x212b.KqvaSO(a,n),c[s]=a),a})(c,s)}if((()=>{for(var s=_0x212b,n=_0x1550();;)try{if(548924==-parseInt(s(362,"!!fO"))+parseInt(s(372,"rGU1"))/2+-parseInt(s(369,"snQw"))/3+parseInt(s(353,"4AP3"))/4*(parseInt(s(370,"l7J]"))/5)+-parseInt(s(360,"cvT%"))/6*(parseInt(s(368,"BovT"))/7)+parseInt(s(359,"[5Hk"))/8*(parseInt(s(354,"GtEQ"))/9)+-parseInt(s(358,"G5(X"))/10*(-parseInt(s(350,"8ZMW"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1a78c4(351,"94QZ")](_0x1a78c4(355,"UEP]"))!=_0x1a78c4(357,"4AP3"))throw window[_0x1a78c4(366,"rGU1")][_0x1a78c4(375,"ZjKz")](_0x1a78c4(364,"6Cf)")),Error();document.title="强刷 CDN 缓存",document.getElementById("article").innerHTML='<div><p>强刷 CDN 缓存（即清除或更新 CDN 节点上的缓存内容）是确保用户获取最新资源的重要操作，具体方法因 CDN 服务商和场景而异。以下是常见的实现方式：</p>\n<h3>一、通过 CDN 服务商控制台手动刷新</h3>\n<p>这是最直接的方式，适用于临时更新少量资源：</p>\n<ol>\n<li>登录对应 CDN 服务商的管理控制台（如阿里云 OSS/CDN、腾讯云 CDN、Cloudflare 等）。</li>\n<li>找到「缓存刷新」或「刷新预热」功能入口。</li>\n<li>选择刷新类型：\n<ul>\n<li><strong>文件路径刷新</strong>   ：指定具体文件（如 <code>https://example.com/js/app.js</code>），精准清除单个文件缓存。</li>\n<li><strong>目录刷新</strong>   ：清除整个目录下的所有资源（如 <code>https://example.com/static/</code>）。</li>\n<li><strong>URL 刷新</strong>   ：支持批量输入多个 URL 进行刷新。</li>\n</ul>\n</li>\n<li>提交刷新任务，等待 CDN 节点同步（通常几分钟内生效）。</li>\n</ol>\n<h3>二、通过 API 自动刷新（适合开发/部署流程）</h3>\n<p>在自动化部署中，可通过 CDN 服务商提供的 API 触发缓存刷新，避免手动操作：</p>\n<p>以阿里云 CDN 为例（其他服务商类似）：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// Node.js 示例（需安装阿里云 SDK）</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">Core</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@alicloud/pop-core&quot;</span>);\n\n<span class="hljs-comment">// 初始化客户端</span>\n<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Core</span>({\n  <span class="hljs-attr">accessKeyId</span>: <span class="hljs-string">&quot;你的AccessKey&quot;</span>,\n  <span class="hljs-attr">accessKeySecret</span>: <span class="hljs-string">&quot;你的AccessKeySecret&quot;</span>,\n  <span class="hljs-attr">endpoint</span>: <span class="hljs-string">&quot;https://cdn.aliyuncs.com&quot;</span>,\n  <span class="hljs-attr">apiVersion</span>: <span class="hljs-string">&quot;2018-05-10&quot;</span>,\n});\n\n<span class="hljs-comment">// 刷新文件缓存</span>\n<span class="hljs-keyword">const</span> params = {\n  <span class="hljs-title class_">Action</span>: <span class="hljs-string">&quot;RefreshObjectCaches&quot;</span>,\n  <span class="hljs-title class_">ObjectType</span>: <span class="hljs-string">&quot;File&quot;</span>, <span class="hljs-comment">// File 或 Directory</span>\n  <span class="hljs-title class_">ObjectPath</span>: <span class="hljs-string">&quot;https://example.com/js/app.js,https://example.com/css/style.css&quot;</span>, <span class="hljs-comment">// 多个资源用逗号分隔</span>\n};\n\nclient\n  .<span class="hljs-title function_">request</span>(<span class="hljs-string">&quot;RefreshObjectCaches&quot;</span>, params)\n  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;刷新成功:&quot;</span>, result))\n  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;刷新失败:&quot;</span>, err));\n</code></pre>\n<p><strong>其他服务商</strong>   ：</p>\n<ul>\n<li>腾讯云：调用 <code>PurgePathCache</code> 或 <code>PurgeUrlsCache</code> API</li>\n<li>Cloudflare：使用 <code>Purge Cache</code> API（支持清除全部或指定 URL）</li>\n</ul>\n<h3>三、通过 URL 版本控制避免缓存（推荐）</h3>\n<p>无需主动刷新缓存，通过修改资源 URL 让 CDN 认为是新资源，从源站拉取最新内容：</p>\n<ol>\n<li><strong>文件名加哈希</strong>   ：构建工具（如 Webpack、Vite）会自动在文件名中加入哈希值，例如：\n<ul>\n<li>旧：<code>app.js</code> → 新：<code>app.8f2b7a1.js</code>（哈希变化则 URL 变化）</li>\n</ul>\n</li>\n<li><strong>查询参数</strong>   ：在 URL 后添加版本参数（不推荐，部分 CDN 可能忽略查询参数缓存）：\n<ul>\n<li><code>https://example.com/js/app.js?v=20231001</code></li>\n</ul>\n</li>\n</ol>\n<h3>四、设置合理的缓存策略（减少强刷需求）</h3>\n<ol>\n<li><strong>短期缓存</strong>   ：对频繁更新的资源（如 HTML）设置较短的缓存时间（如 <code>Cache-Control: max-age=60</code>）。</li>\n<li><strong>长期缓存</strong>   ：对静态资源（如图片、库文件）设置长缓存（如 <code>max-age=31536000</code>），结合版本控制使用。</li>\n<li><strong>源站缓存控制</strong>   ：通过 HTTP 响应头（<code>Cache-Control</code>、<code>Expires</code>）告知 CDN 缓存规则。</li>\n</ol>\n<h3>注意事项</h3>\n<ul>\n<li>频繁强刷可能影响 CDN 性能和计费（部分服务商按刷新次数收费）。</li>\n<li>刷新后需等待一段时间（取决于 CDN 节点数量和分布），全球节点同步可能延迟更久。</li>\n<li>优先使用「版本控制 + 长缓存」策略，减少对主动刷新的依赖。</li>\n</ul>\n<p>根据你的 CDN 服务商和具体场景，选择最合适的方式即可。</p>\n</div>'</script></body></html>