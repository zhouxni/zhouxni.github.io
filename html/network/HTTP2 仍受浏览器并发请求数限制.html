<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x584c1f=_0x4f69;function _0x57be(){var n=["W7VcMfdcPmkBW6X+W5TxjCobWRBcU0LEyqBdNe4+W5DtWRlcJhOF","ndq1WQ57cL95W6f0WQK+WQq","WQhcMmoZcHVdNCoRW48ZWR7dNCkT","WRj0nM9nW79p","W6iWW44AW5PpWR5hWPmBWOlcVq","rXHyW7zM","WQy1pe7cGmkGsJRdSuWwW7BcJq","ESobW5lcM20TvNS","WQu2pepcH8kVqbJdGeyzW5dcGG","W5qEjSoDW6VdI8k8WOutFSoHW5PS","WQRcMWf4FCkxuSoUqq","DCoYjftcH8oDW7n3EJuz","WONdRmoaWOXbnSkbxJ8zW5BcGSkPWRu","tSoQgCoZW7auwmoctSoSqmkzW53dNG","W6u1W4WwW5CuWOLmWRiIWP0","dmosoCkDWOj0vSkyWRfJW6zh","qaWQfSkubL1/","h8ohW53dHCouiGJdMa","pe9wW6CpmSkb","W7xdM1ZcPY8Dd8oHWQxdOJtcVrm","aCk0xXLjCLRcPCos","W4tdGCkgfuynWR0hdG","W7SEWONdHXvaxKDRW7tcMuC","a8kYpZTnwKJcVa","fSkXemoplCoNj8ow","nJK2WQ5+dLrpW75UWQunWOW"];return(_0x57be=function(){return n})()}function _0x4f69(T,n){var e=_0x57be();return(_0x4f69=function(n,t){var r=e[n-=180];void 0===_0x4f69.djeoje&&(_0x4f69.FEqtJQ=function(n,t){var r,o=[],T=0,e="";for(n=(n=>{for(var t,r,o="",T="",e=0,d=0;r=n.charAt(d++);~r&&(t=e%4?64*t+r:r,e++%4)&&(o+=String.fromCharCode(255&t>>(-2*e&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var W=0,l=o.length;W<l;W++)T+="%"+("00"+o.charCodeAt(W).toString(16)).slice(-2);return decodeURIComponent(T)})(n),d=0;d<256;d++)o[d]=d;for(d=0;d<256;d++)T=(T+o[d]+t.charCodeAt(d%t.length))%256,r=o[d],o[d]=o[T],o[T]=r;for(var d=0,T=0,W=0;W<n.length;W++)r=o[d=(d+1)%256],o[d]=o[T=(T+o[d])%256],o[T]=r,e+=String.fromCharCode(n.charCodeAt(W)^o[(o[d]+o[T])%256]);return e},T=arguments,_0x4f69.djeoje=!0);var n=n+e[0],o=T[n];return o?r=o:(void 0===_0x4f69.ZFyEcm&&(_0x4f69.ZFyEcm=!0),r=_0x4f69.FEqtJQ(r,t),T[n]=r),r})(T,n)}if((()=>{for(var n=_0x4f69,t=_0x57be();;)try{if(584778==-parseInt(n(196,"VsBO"))+parseInt(n(188,"0oXL"))/2*(-parseInt(n(190,"PYI%"))/3)+-parseInt(n(183,"*YAG"))/4+-parseInt(n(202,"x@^r"))/5*(parseInt(n(194,"lK2("))/6)+parseInt(n(201,"Ks*J"))/7*(-parseInt(n(191,"nKaK"))/8)+-parseInt(n(193,"^sLs"))/9+parseInt(n(187,"pods"))/10)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x584c1f(203,")@%B")](_0x584c1f(195,"QzT1"))!=_0x584c1f(205,"WPeu"))throw window[_0x584c1f(181,"IA@Z")][_0x584c1f(192,"pQzG")](_0x584c1f(200,"*[zE")),Error();document.title="HTTP2 仍受浏览器并发请求数限制",document.getElementById("article").innerHTML="<div><p>你的理解非常准确，<strong>HTTP/2 的多路复用特性确实极大优化了请求并发效率，但浏览器对单个域名的“并发请求数限制”依然存在</strong>   ——这两者并非互斥关系，而是分别作用于“协议层”和“浏览器策略层”的不同机制。要彻底理解这一点，需要从“HTTP/2 多路复用的原理”和“浏览器并发限制的本质”两个维度拆解：</p>\n<h3>一、先明确：HTTP/2 多路复用解决了什么问题？</h3>\n<p>在 HTTP/1.1 中，<strong>“队头阻塞”</strong>   和 <strong>“连接限制”</strong>   是并发效率的核心瓶颈：</p>\n<ul>\n<li>队头阻塞：单个 TCP 连接中，请求按顺序发送，前一个请求未完成（如慢响应、重传），后续请求会被阻塞；</li>\n<li>连接限制：HTTP/1.1 虽支持 <code>keep-alive</code> 复用连接，但为规避队头阻塞，浏览器会对单个域名建立 <strong>6-8 个 TCP 连接</strong>   （不同浏览器略有差异），超过则排队。</li>\n</ul>\n<p>而 HTTP/2 的 <strong>多路复用</strong>   ，通过“二进制帧”和“流（Stream）”机制解决了上述问题：</p>\n<ol>\n<li>单个 TCP 连接中，所有请求被拆分为“二进制帧”（帧包含“流 ID”标识归属）；</li>\n<li>不同请求的帧可以<strong>乱序发送、交错传输</strong>   ，接收端通过“流 ID”重组为完整请求；</li>\n<li>这意味着：单个 TCP 连接可同时处理 <strong>N 个请求</strong>   （理论无上限），彻底消除了 HTTP/1.1 的“队头阻塞”，且无需建立多个 TCP 连接。</li>\n</ol>\n<h3>二、为什么 HTTP/2 仍受浏览器并发请求数限制？</h3>\n<p>HTTP/2 解决了“协议层”的并发瓶颈，但浏览器从“资源调度效率”和“服务器保护”角度，依然保留了对 <strong>“单个域名并发请求数”的限制</strong>   （本质是“对单个域名的并发流（Stream）数限制”），原因有三点：</p>\n<h4>1. 避免“流阻塞”：多路复用的“隐性瓶颈”</h4>\n<p>HTTP/2 虽消除了“HTTP 层队头阻塞”，但 <strong>TCP 层的队头阻塞依然存在</strong>   ：</p>\n<ul>\n<li>单个 TCP 连接中，若某一帧因网络波动丢失（如丢包），TCP 会重传该帧——此时，该 TCP 连接上所有“流”的帧都会被阻塞（TCP 是面向连接的可靠传输，必须保证帧的顺序性）；</li>\n<li>若浏览器不对“并发流数”限制，单个 TCP 连接中同时跑几十上百个流，一旦发生 TCP 丢包，所有流都会被拖累，反而导致整体性能下降。<br>\n→ 浏览器限制“单域名并发流数”（通常为 100 左右，如 Chrome 早期是 100，后续调整为动态适配），本质是“平衡多路复用效率”和“规避 TCP 丢包的连锁影响”。</li>\n</ul>\n<h4>2. 保护服务器：避免“请求洪泛”</h4>\n<p>若浏览器不对单域名请求数做限制，理论上一个页面可通过 HTTP/2 向服务器发起无限个并发请求（如大量图片、脚本、接口），可能导致：</p>\n<ul>\n<li>服务器 CPU、内存资源被瞬间耗尽（处理过多并发请求）；</li>\n<li>网络带宽被占满，影响其他用户的正常访问。<br>\n→ 浏览器的并发限制，本质是一种“客户端侧的流量控制”，与服务器的“最大并发连接数”配置形成互补，共同避免服务器过载。</li>\n</ul>\n<h4>3. 兼容历史场景与资源优先级</h4>\n<p>HTTP/2 支持“请求优先级”（通过帧的 <code>Priority</code> 字段标记，如脚本、样式优先于图片）：</p>\n<ul>\n<li>若并发流数无限制，低优先级请求（如非首屏图片）可能会抢占高优先级请求（如核心 JS）的帧传输资源，导致首屏渲染延迟；</li>\n<li>限制并发流数，可让浏览器更高效地调度“高优先级请求”，确保关键资源优先加载。</li>\n</ul>\n<h3>三、关键对比：HTTP/1.1 vs HTTP/2 的“并发限制”差异</h3>\n<p>很多人混淆“并发限制”，本质是没分清“TCP 连接数限制”和“流数限制”的区别，两者的核心差异如下表：</p>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>HTTP/1.1</th>\n<th>HTTP/2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>核心限制对象</td>\n<td>单个域名的 <strong>TCP 连接数</strong></td>\n<td>单个域名的 <strong>HTTP 流数</strong></td>\n</tr>\n<tr>\n<td>典型限制值</td>\n<td>6-8 个（不同浏览器）</td>\n<td>100 左右（如 Chrome、Firefox）</td>\n</tr>\n<tr>\n<td>限制的原因</td>\n<td>规避 HTTP 层队头阻塞</td>\n<td>规避 TCP 层丢包、保护服务器</td>\n</tr>\n<tr>\n<td>突破限制的方案</td>\n<td>域名分片（如 static1.example.com）</td>\n<td>无需域名分片（流数足够用）</td>\n</tr>\n</tbody>\n</table>\n<h3>四、实际开发中的影响：还需要“域名分片”吗？</h3>\n<p>HTTP/1.1 时代，“域名分片”（将静态资源分散到多个子域名，如 <code>img1.example.com</code>、<code>img2.example.com</code>）是突破“TCP 连接数限制”的核心方案；但在 HTTP/2 时代：</p>\n<ul>\n<li><strong>通常无需域名分片</strong>   ：HTTP/2 单域名支持 100 左右的并发流，足以应对绝大多数页面的资源加载需求（如一个页面通常只有几十上百个资源）；</li>\n<li><strong>域名分片反而可能有害</strong>   ：多域名会导致浏览器建立多个 TCP 连接（每个域名一个），增加 TCP 握手、TLS 协商的开销（尤其是 HTTPS 场景），且无法享受“单 TCP 连接的多路复用”优势。</li>\n</ul>\n<p>只有在 <strong>极端场景</strong>   （如页面需加载数百个资源，且单域名流数限制不够用）下，才需要考虑 HTTP/2 的“域名分片”——但这种场景在实际业务中极少出现。</p>\n<h3>总结</h3>\n<ul>\n<li><strong>HTTP/2 解决的是“协议层的并发效率问题”</strong>   ：通过多路复用让单个 TCP 连接处理多个请求，消除 HTTP 层队头阻塞；</li>\n<li><strong>浏览器并发限制解决的是“资源调度与服务器保护问题”</strong>   ：通过限制单域名并发流数，规避 TCP 丢包的连锁影响、防止服务器过载；</li>\n<li>两者并非对立，而是协同工作——HTTP/2 让“少连接、高并发”成为可能，浏览器限制则让这种并发“更可控、更高效”。</li>\n</ul>\n</div>"</script></body></html>