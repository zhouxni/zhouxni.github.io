<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2e93d3=_0x5e10;function _0x5e10(t,n){var T=_0x49b6();return(_0x5e10=function(n,r){var e=T[n-=113];void 0===_0x5e10.pztscK&&(_0x5e10.mHWaGr=function(n,r){var e,o=[],t=0,T="";for(n=(n=>{for(var r,e,o="",t="",T=0,i=0;e=n.charAt(i++);~e&&(r=T%4?64*r+e:e,T++%4)&&(o+=String.fromCharCode(255&r>>(-2*T&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var W=0,c=o.length;W<c;W++)t+="%"+("00"+o.charCodeAt(W).toString(16)).slice(-2);return decodeURIComponent(t)})(n),i=0;i<256;i++)o[i]=i;for(i=0;i<256;i++)t=(t+o[i]+r.charCodeAt(i%r.length))%256,e=o[i],o[i]=o[t],o[t]=e;for(var i=0,t=0,W=0;W<n.length;W++)e=o[i=(i+1)%256],o[i]=o[t=(t+o[i])%256],o[t]=e,T+=String.fromCharCode(n.charCodeAt(W)^o[(o[i]+o[t])%256]);return T},t=arguments,_0x5e10.pztscK=!0);var n=n+T[0],o=t[n];return o?e=o:(void 0===_0x5e10.sGDcEu&&(_0x5e10.sGDcEu=!0),e=_0x5e10.mHWaGr(e,r),t[n]=e),e})(t,n)}function _0x49b6(){var n=["W6zxFfvwWO3dIJXUe27cL8o/","mG7cLSkoWQpcOSoe","jCoyrvtdM8ofWQO","daeOEvpcQ0vDyW","zCojWOpcRXujk8obqKNcOqBdIq","WPlcJ8k3W7n/WPdcUdu0","rWxdV1JdRq","W6RcNvpcLmkGntbFrmoptCklW4VcTq","DSkbDxNcHZb8WRy","W6RcMLlcKSkHvgqWxmoqxW","dmo4W7ddJH0xjXvammkNvJ9XmwqIcCo5B1FcHW7dNfWN","W5ToWOdcNSkkWQeX","rcpdVCovnSk7EqGf","W4O3W4pdO8kTWQCaW6BcR0hcICkEWRe","WQCOW5eTg8k+W6ZdG8oVW404","WRjAWRNcUmopDCkJqSkUic1dW7q","W5tdTfCpW5dcQ8kNW7SfWRLgFSkE","CvVdN8ouW7tdSCkyDg5BiqNdSSo7","W6nxE1rxWOtdJJHUcvlcTSo9","WRGkWQi6AKVdVSoLWRjWWQZcOmk+","WQbkaSo1nSkryfjIWQlcQM3cK8kM","W7WMdmkGWQbFrq","W7a/W7FdUmkYW6vK","WQRcGuKjW6mqCG","yJiKsc/cV2fxydRdLeFdVxK","BCktBayEW4VcTCozWPvfswCa"];return(_0x49b6=function(){return n})()}if((()=>{for(var n=_0x5e10,r=_0x49b6();;)try{if(752822==-parseInt(n(114,"4aGp"))*(parseInt(n(131,"QuFG"))/2)+-parseInt(n(129,"f&2U"))/3*(-parseInt(n(122,"(@u0"))/4)+-parseInt(n(123,"Y(On"))/5*(-parseInt(n(127,"HJsQ"))/6)+parseInt(n(137,"vaRk"))/7+-parseInt(n(134,"Ybtj"))/8+parseInt(n(116,"j6aq"))/9+-parseInt(n(135,"EVOm"))/10)break;r.push(r.shift())}catch(n){r.push(r.shift())}})(),localStorage[_0x2e93d3(115,"GkZ6")](_0x2e93d3(130,"gV^X"))!=_0x2e93d3(124,"nqqi"))throw window[_0x2e93d3(126,"v$!l")][_0x2e93d3(119,"EVOm")](_0x2e93d3(128,"ryIi")),Error();document.title="HTTP2 在浏览器中对单个域名仅使用 1 个 TCP 连接",document.getElementById("article").innerHTML="<div><p>在大多数情况下，HTTP/2 在浏览器中对<strong>单个域名仅使用 1 个 TCP 连接</strong>   ，这是其与 HTTP/1.1 最核心的区别之一，也是多路复用特性的基础。但严格来说，“仅使用 1 个 TCP 连接”并非绝对规则，存在一些特殊场景会触发多个连接。</p>\n<h3>一、常态：单域名单 TCP 连接</h3>\n<p>HTTP/2 的设计初衷就是通过 <strong>“单连接多路复用”</strong>   替代 HTTP/1.1 的“多连接串行”，核心逻辑是：</p>\n<ul>\n<li>单个 TCP 连接内，所有请求被拆分为二进制帧，通过“流（Stream）”机制实现并发传输（不同请求的帧可交错发送）；</li>\n<li>无需像 HTTP/1.1 那样建立 6-8 个 TCP 连接来规避队头阻塞，因此浏览器默认对单个域名只创建 1 个 TCP 连接。</li>\n</ul>\n<p>这一设计带来的优势显著：</p>\n<ul>\n<li>减少 TCP 握手、TLS 协商的开销（尤其 HTTPS 场景）；</li>\n<li>避免多个 TCP 连接的“慢启动”阶段对带宽的浪费；</li>\n<li>集中利用单一连接的带宽资源，提升传输效率。</li>\n</ul>\n<h3>二、特殊场景：单域名可能建立多个 TCP 连接</h3>\n<p>尽管“单连接”是主流，但以下情况会导致浏览器为单个域名创建<strong>多个 TCP 连接</strong>   ：</p>\n<h4>1. 服务器限制并发流数</h4>\n<p>HTTP/2 允许服务器通过 <code>SETTINGS_MAX_CONCURRENT_STREAMS</code> 字段（如 Nginx 默认值为 128）限制单连接的最大并发流数。</p>\n<ul>\n<li>若浏览器需要发起的请求数（流数）超过该限制（如页面有 200 个资源），会新建 TCP 连接来承载超额的流；</li>\n<li>例如：服务器限制 100 个并发流，浏览器发起 150 个请求时，可能建立 2 个 TCP 连接（100 + 50）。</li>\n</ul>\n<h4>2. 连接异常或负载均衡</h4>\n<ul>\n<li>若当前 TCP 连接出现异常（如丢包严重、响应超时），浏览器可能新建备用连接；</li>\n<li>部分 CDN 或服务器集群会通过“连接迁移”机制，引导浏览器建立多个连接以实现负载均衡（较罕见）。</li>\n</ul>\n<h4>3. 应对 TCP 层队头阻塞</h4>\n<p>HTTP/2 虽解决了 HTTP 层队头阻塞，但 TCP 层的队头阻塞（如丢包重传）仍存在：</p>\n<ul>\n<li>单个 TCP 连接中，若某一帧丢失，所有流的传输都会暂停等待重传；</li>\n<li>极端场景下（如高丢包网络），部分浏览器（如 Chrome）会主动新建 TCP 连接，将部分请求分流到新连接，降低风险（此为浏览器自适应策略，非标准）。</li>\n</ul>\n<h4>4. 旧版本浏览器的兼容性行为</h4>\n<p>早期支持 HTTP/2 的浏览器（如 2015-2018 年的 Chrome、Firefox）存在“预建立 2 个 TCP 连接”的逻辑，用于兼容服务器端的流数限制，但现代浏览器（2020 年后版本）已普遍优化为“按需创建”。</p>\n<h4>5. 不同域名</h4>\n<p>单连接是针对单个域名（origin，包含协议、主机名、端口）的。如果一个网页有来自 https://example.com和 https://cdn.example.com的资源，浏览器会为每个域名分别建立一个 HTTP/2 连接。这就是为什么“域名分片”（Domain Sharding）在 HTTP/2 环境下反而成了反模式，因为它会强制创建不必要的多个连接，失去了单连接的优势。</p>\n<h3>三、关键结论</h3>\n<ul>\n<li><strong>主流情况</strong>   ：HTTP/2 对单个域名<strong>默认使用 1 个 TCP 连接</strong>   ，多路复用机制足以支撑绝大多数页面的资源加载需求（通常 100-200 个资源）；</li>\n<li><strong>例外情况</strong>   ：仅在“服务器限制并发流数”“连接异常”等边缘场景下，才会建立多个 TCP 连接，且数量通常很少（2-3 个），远少于 HTTP/1.1 的 6-8 个；</li>\n<li>开发视角：无需刻意干预连接数，浏览器会自动优化；相比 HTTP/1.1，HTTP/2 的连接管理效率已大幅提升，“域名分片”等旧方案反而可能适得其反。</li>\n</ul>\n</div>"</script></body></html>