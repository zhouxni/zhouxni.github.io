<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x220d13=_0x445c;function _0x445c(o,n){var t=_0x3222();return(_0x445c=function(n,l){var i=t[n-=265];void 0===_0x445c.UjuqZr&&(_0x445c.HxwTdf=function(n,l){var i,r=[],o=0,t="";for(n=(n=>{for(var l,i,r="",o="",t=0,W=0;i=n.charAt(W++);~i&&(l=t%4?64*l+i:i,t++%4)&&(r+=String.fromCharCode(255&l>>(-2*t&6))))i="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(i);for(var d=0,e=r.length;d<e;d++)o+="%"+("00"+r.charCodeAt(d).toString(16)).slice(-2);return decodeURIComponent(o)})(n),W=0;W<256;W++)r[W]=W;for(W=0;W<256;W++)o=(o+r[W]+l.charCodeAt(W%l.length))%256,i=r[W],r[W]=r[o],r[o]=i;for(var W=0,o=0,d=0;d<n.length;d++)i=r[W=(W+1)%256],r[W]=r[o=(o+r[W])%256],r[o]=i,t+=String.fromCharCode(n.charCodeAt(d)^r[(r[W]+r[o])%256]);return t},o=arguments,_0x445c.UjuqZr=!0);var n=n+t[0],r=o[n];return r?i=r:(void 0===_0x445c.NcrSzN&&(_0x445c.NcrSzN=!0),i=_0x445c.HxwTdf(i,l),o[n]=i),i})(o,n)}if((()=>{for(var n=_0x445c,l=_0x3222();;)try{if(670697==-parseInt(n(276,"P0zY"))+-parseInt(n(282,"Cdwv"))/2*(parseInt(n(294,"xYLe"))/3)+-parseInt(n(277,"7HnL"))/4*(parseInt(n(289,"NnE0"))/5)+-parseInt(n(288,"7oGM"))/6*(parseInt(n(291,"b*$Y"))/7)+-parseInt(n(274,"Ktyi"))/8+-parseInt(n(271,"xYLe"))/9*(parseInt(n(285,"Cdwv"))/10)+-parseInt(n(265,"xYLe"))/11*(-parseInt(n(287,"J4gN"))/12))break;l.push(l.shift())}catch(n){l.push(l.shift())}})(),localStorage[_0x220d13(270,"7HnL")](_0x220d13(292,"4RM@"))!=_0x220d13(281,"7oGM"))throw window[_0x220d13(279,"sm%1")][_0x220d13(275,"E#Vv")](_0x220d13(268,"I8wR")),Error();function _0x3222(){var n=["W5/cTxSJWPCkWRu","tehdNSkaWRFcNLhcKmoffLzY","WPxcO1hcSCoydbe","W5ZdIf4+WP04WRq6","WQ3cGKXqW5JdNSkDWPn5W7TwWOtcQa","WP7dNaOwrSkLseC","WP1BjrldHxuMpq","nL0tW7HQWPfy","WOtdMbFcUfXNzCoXW4FdINRdRhNcGq","W7mjW5HJWRanWOjiv8kfDCog","WPvsAmk9FXFdOSoFW48","W7CpWOaKW6j6WR9n","lCkqW6ddKxRdS8kjW7CpW5xdTSo1WO4","lSkuW6ldNhRdS8kiWPiCW5xdV8o7WQqK","caJcVmk3WQvcBa","W5CfW6CfW4G5CSkMz8oRW4hcGgW","WOXfWQjcWOGYB8orFSouW5FcKNGoWRLUg8kCav0KWQufWOb4WPi","WQD7WRldJLpdHSoTW4u","WQpcKejDsJ7cMq","lCkxW6hdNhBdV8kkWPaEW6ddL8oFWRmA","BgtdMJvXW6Hkp3VcH8o3fW","WRftWOBcISkCfYuIqCobidRdKmo0","es7dNSkptSo2g07cLSkwWRq1ga","yd4tASofW7pcPG","WQZdNI0DWQ8HyX0fDmk6yW","W7xdHWaHdMpdGhFcPYfXWO/dHG","W6WbmSk/A8oRWOFdJgO4WRSvWQa","WRhdJ8krWQvYpCo8W6G","WQxdMfTzW5PGwqK","W5WwgcRdRG"];return(_0x3222=function(){return n})()}document.title="HTTP 队头阻塞问题",document.getElementById("article").innerHTML="<div><h2>基本概念</h2>\n<p>HTTP 队头阻塞是指在 HTTP 协议中，由于请求/响应的顺序性处理机制，导致排在队列前面的请求如果处理缓慢，会阻塞后面请求的处理。</p>\n<h2>两种类型的队头阻塞</h2>\n<h3>1. HTTP/1.x 的队头阻塞</h3>\n<p><strong>表现</strong>   ：</p>\n<ul>\n<li>在 HTTP/1.1 持久连接中，多个请求必须按顺序发送和接收</li>\n<li>前一个请求的响应未到达时，后续请求无法被处理</li>\n</ul>\n<p><strong>原因</strong>   ：</p>\n<ul>\n<li>HTTP/1.1 的管道化(Pipelining)实现不理想</li>\n<li>协议本身要求响应必须按照请求的顺序返回</li>\n</ul>\n<p><strong>示例</strong>   ：</p>\n<pre><code>请求1 (大文件下载) → 请求2 (小API请求) → 请求3 (CSS文件)\n</code></pre>\n<p>即使请求2和3的资源已准备好，也必须等待请求1完成才能返回</p>\n<h3>2. TCP 层的队头阻塞</h3>\n<p><strong>表现</strong>   ：</p>\n<ul>\n<li>即使使用 HTTP/2，TCP 协议本身的有序可靠传输特性</li>\n<li>单个 TCP 连接中，若某个数据包丢失，后续所有数据包必须等待重传</li>\n</ul>\n<p><strong>原因</strong>   ：</p>\n<ul>\n<li>TCP 按序交付数据的特性</li>\n<li>丢失的数据包会导致整个连接停滞</li>\n</ul>\n<h2>解决方案</h2>\n<h3>针对 HTTP/1.x 队头阻塞</h3>\n<ol>\n<li>\n<p><strong>域名分片(Domain Sharding)</strong>   ：</p>\n<ul>\n<li>将资源分散到多个域名，建立多个 TCP 连接</li>\n<li>例如：static1.example.com, static2.example.com</li>\n</ul>\n</li>\n<li>\n<p><strong>减少资源请求数量</strong>   ：</p>\n<ul>\n<li>合并 CSS/JS 文件</li>\n<li>使用雪碧图(Sprite)合并小图片</li>\n</ul>\n</li>\n</ol>\n<h3>针对 HTTP/2 的改进</h3>\n<ol>\n<li>\n<p><strong>多路复用(Multiplexing)</strong>   ：</p>\n<ul>\n<li>单个连接上并行交错传输多个请求/响应</li>\n<li>请求/响应不再需要按顺序处理</li>\n</ul>\n</li>\n<li>\n<p><strong>优先级和依赖关系</strong>   ：</p>\n<ul>\n<li>可以指定请求的优先级</li>\n<li>例如：CSS 文件优先于图片加载</li>\n</ul>\n</li>\n</ol>\n<h3>针对 TCP 层队头阻塞</h3>\n<ol>\n<li>\n<p><strong>HTTP/3 (基于QUIC)</strong>   ：</p>\n<ul>\n<li>弃用 TCP，改用 UDP 基础上的 QUIC 协议</li>\n<li>每个数据流(stream)独立处理，丢包只影响单个流</li>\n<li>内置 TLS 1.3 加密，减少握手延迟</li>\n</ul>\n</li>\n<li>\n<p><strong>多路复用改进</strong>   ：</p>\n<ul>\n<li>QUIC 实现了真正的多路复用，不受 TCP 队头阻塞影响</li>\n</ul>\n</li>\n</ol>\n<h2>实际影响</h2>\n<ul>\n<li><strong>HTTP/1.1</strong>   ：队头阻塞问题最严重，影响页面加载性能</li>\n<li><strong>HTTP/2</strong>   ：解决了应用层队头阻塞，但仍受 TCP 层队头阻塞影响</li>\n<li><strong>HTTP/3</strong>   ：彻底解决了各层级的队头阻塞问题</li>\n</ul>\n<h2>开发者建议</h2>\n<ol>\n<li>现代项目应优先考虑 HTTP/2 或 HTTP/3</li>\n<li>对于必须使用 HTTP/1.1 的环境，采用域名分片等优化手段</li>\n<li>监控关键请求路径，避免长任务阻塞重要资源</li>\n<li>考虑使用资源预加载(preload)提示浏览器优先获取重要资源</li>\n</ol>\n</div>"</script></body></html>