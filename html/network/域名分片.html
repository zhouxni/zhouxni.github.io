<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x126169=_0x50f8;function _0x3f5f(){var n=["WOzIWP5/WOePmW","WRLWiCkMW70mp0uGkW","aCohyuldHtZcISk5W5u","zgDVq8kR","WPa3WRxdUKuoW7tdSLrDW4nJWR7dOItcRt5CW4D3WPpdS8ocW6lcJCkZ","W7VdGrNdVxbNW7yA","y8k/pmoqc8k/WQNdQYRdK8otaSkQ","kmolW5hdNfFcO8k1A8oaCW","abFdNYawWRyvWO3dJSo9W6FcGSoncW","zY1TWP4iW7BcHSoqWPO","vSkhWO3dNXv8jSkrWOZcUW","WPTXoSoIW7JcLSo/axddQ8oHA8ka","cCoqW4VcOJj/ga","WPpdVMCkW5GYWRtdQCoBaLS6W6i","sSkQW6BdHCo8rSo7WQJcJYy","tCkjWQNdGanaWQpcONOh","aIW8yCoFbepdN0Lb","A8oXBmkxE0hcICocW6FdUa","h8kOW4dcVI7dGqpdImocWQW","W5RcT8kIid19ihhdHtmRWP/dVa","tIxcPSokWQibh2iMWOy","WPhdV2ydW5a0WRtdM8o7guuyW7e","tCklWQ/cQHjpWOhcHKu","tspcOmokW4nFFYSOWO1xt8orW7u","WRP0j8kNWQDZA3OGfItdSSk/","mCkRp8k2sSk+W71tEmoN"];return(_0x3f5f=function(){return n})()}function _0x50f8(l,n){var e=_0x3f5f();return(_0x50f8=function(n,t){var o=e[n-=167];void 0===_0x50f8.SiTbac&&(_0x50f8.EAbMoA=function(n,t){var o,r=[],l=0,e="";for(n=(n=>{for(var t,o,r="",l="",e=0,s=0;o=n.charAt(s++);~o&&(t=e%4?64*t+o:o,e++%4)&&(r+=String.fromCharCode(255&t>>(-2*e&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var g=0,i=r.length;g<i;g++)l+="%"+("00"+r.charCodeAt(g).toString(16)).slice(-2);return decodeURIComponent(l)})(n),s=0;s<256;s++)r[s]=s;for(s=0;s<256;s++)l=(l+r[s]+t.charCodeAt(s%t.length))%256,o=r[s],r[s]=r[l],r[l]=o;for(var s=0,l=0,g=0;g<n.length;g++)o=r[s=(s+1)%256],r[s]=r[l=(l+r[s])%256],r[l]=o,e+=String.fromCharCode(n.charCodeAt(g)^r[(r[s]+r[l])%256]);return e},l=arguments,_0x50f8.SiTbac=!0);var n=n+e[0],r=l[n];return r?o=r:(void 0===_0x50f8.ovLAMQ&&(_0x50f8.ovLAMQ=!0),o=_0x50f8.EAbMoA(o,t),l[n]=o),o})(l,n)}if((()=>{for(var n=_0x50f8,t=_0x3f5f();;)try{if(474710==-parseInt(n(188,"]Hr3"))*(parseInt(n(174,"N6FB"))/2)+-parseInt(n(187,"]s3M"))/3*(parseInt(n(192,"YQUv"))/4)+parseInt(n(170,"k1Wl"))/5+-parseInt(n(178,"S40$"))/6+-parseInt(n(186,"#hlc"))/7*(parseInt(n(182,"i27S"))/8)+parseInt(n(167,"2*V3"))/9+parseInt(n(169,"YQUv"))/10)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x126169(184,"i27S")](_0x126169(181,"mkkA"))!=_0x126169(175,"*e0V"))throw window[_0x126169(177,"Hx*6")][_0x126169(172,"qZ3t")](_0x126169(176,"i^nJ")),Error();document.title="域名分片",document.getElementById("article").innerHTML='<div><p>好的，我们来详细解析一下“域名分片”这个前端性能优化技术。</p>\n<h3>一、什么是域名分片？</h3>\n<p><strong>域名分片</strong>   是一种为了解决浏览器对同一域名下并发请求数量限制的优化技术。其核心思想是：<strong>将网站所需的静态资源（如图片、JS、CSS文件）分散到多个不同的域名（或子域名）下来进行加载。</strong></p>\n<p><strong>举个例子：</strong><br>\n假设你的网站主域名是 <code>www.example.com</code>。</p>\n<ul>\n<li><strong>未使用域名分片：</strong>   所有资源都从 <code>www.example.com</code> 加载，比如 <code>www.example.com/image1.jpg</code>, <code>www.example.com/style.css</code>。</li>\n<li><strong>使用域名分片：</strong>   你可以创建几个子域名，如 <code>static1.example.com</code>, <code>static2.example.com</code>, <code>static3.example.com</code>，然后将资源分散到这些域名上加载，比如 <code>static1.example.com/image1.jpg</code>, <code>static2.example.com/style.css</code>。</li>\n</ul>\n<hr>\n<h3>二、为什么需要域名分片？—— 其历史背景和原理</h3>\n<p>要理解域名分片，必须先了解它的对手：<strong>浏览器的并发请求数限制</strong>  。</p>\n<ol>\n<li>\n<p><strong>浏览器的限制：</strong><br>\n在 HTTP/1.1 时代，大多数浏览器为了不过度消耗服务器资源和避免网络拥堵，会对同一个域名同时发起的 HTTP 请求数量进行限制。这个限制通常是 <strong>6</strong>   个（不同浏览器略有差异）。</p>\n<ul>\n<li><strong>这意味着：</strong>   如果你的网页需要加载 30 个静态资源（这在现代网页中很常见），而它们都来自同一个域名，那么浏览器最多只能同时下载 6 个。它必须等前6个中的某些请求完成后，才能发起第7个、第8个请求，以此类推。这会形成一个“排队”现象，严重拖慢页面加载速度。</li>\n</ul>\n</li>\n<li>\n<p><strong>域名分片的解决方案：</strong><br>\n域名分片巧妙地“绕过”了这个限制。因为浏览器的限制是 <strong>“每个域名”</strong>   ，而不是“每个页面”。</p>\n<ul>\n<li><strong>工作原理：</strong>   如果你将资源分布在 3 个不同的域名上（例如 <code>static1.com</code>, <code>static2.com</code>, <code>static3.com</code>），那么浏览器对每个域名都有 6 个并发限制。</li>\n<li><strong>效果：</strong>   理论上，你的页面的总并发请求数就变成了 <code>3个域名 * 6个并发/域名 = 18个并发请求</code>。这样，那30个资源就能以更快的速度、更并行地被下载完，从而显著提升页面加载性能。</li>\n</ul>\n</li>\n</ol>\n<p><strong>图示理解：</strong></p>\n<pre><code>同一域名（HTTP/1.1）:\n[请求1] [请求2] [请求3] [请求4] [请求5] [请求6] -&gt; 等待 -&gt; [请求7] [请求8] ... 速度慢\n\n域名分片后（HTTP/1.1）:\n域名A: [请求1] [请求2] [请求3] [请求4] [请求5] [请求6]\n域名B: [请求7] [请求8] [请求9] [请求10] [请求11] [请求12]\n域名C: [请求13] [请求14] ...\n// 所有请求几乎同时进行，速度快得多\n</code></pre>\n<hr>\n<h3>三、域名分片的优缺点</h3>\n<h4>优点（主要在 HTTP/1.1 环境下）</h4>\n<ol>\n<li><strong>提升页面加载速度：</strong>   这是最核心的优点，通过增加并发连接数，减少了资源加载的排队时间。</li>\n<li><strong>绕过连接限制：</strong>   直接解决了浏览器对同一域名并发请求数的瓶颈。</li>\n</ol>\n<h4>缺点（现代环境下非常突出）</h4>\n<ol>\n<li><strong>额外的DNS查询开销：</strong>   每个新的域名都需要进行DNS解析，这会增加几十到几百毫秒的延迟。</li>\n<li><strong>额外的TCP连接开销：</strong>   每个新域名都需要建立新的TCP连接（包括TCP三次握手和TLS握手），这进一步增加了开销。</li>\n<li><strong>缓存效果变差：</strong>   如果分片不合理，可能会导致浏览器缓存效率降低。因为不同域名下的资源即使内容一样，也会被分别缓存。</li>\n<li><strong>开发与运维成本：</strong>   需要维护多个域名/子域名，配置SSL证书等，增加了复杂性。</li>\n<li><strong>对HTTP/2不友好：</strong>   这是<strong>最关键</strong>  的缺点，下面会详细说明。</li>\n</ol>\n<hr>\n<h3>四、现代Web开发中还需要域名分片吗？—— HTTP/2 带来的变革</h3>\n<p><strong>简短答案：对于已经使用 HTTP/2 或 HTTP/3 的网站，通常不再需要甚至应该避免使用域名分片。</strong></p>\n<h4>为什么 HTTP/2 让域名分片过时了？</h4>\n<p>HTTP/2 引入了一个革命性的特性：<strong>多路复用</strong>  。</p>\n<ul>\n<li><strong>多路复用：</strong>   允许通过<strong>单个TCP连接</strong>  同时发送多个请求和响应。这些请求和响应是交错进行的，互不阻塞。</li>\n<li><strong>对比 HTTP/1.1：</strong>   在 HTTP/1.1 中，即使有多个连接，每个连接也只能处理一个请求-响应周期（虽然有管线化，但实践中有很多问题）。</li>\n</ul>\n<p><strong>HTTP/2 的优势：</strong></p>\n<ol>\n<li><strong>消除了队头阻塞：</strong>   一个请求的延迟不会影响同连接上的其他请求。</li>\n<li><strong>高效的单一连接：</strong>   一个域名只需要一个TCP连接，就可以并行处理成百上千个请求。这彻底解决了HTTP/1.1的并发限制问题。</li>\n<li><strong>避免分片带来的开销：</strong>   使用一个域名，意味着只需要一次DNS查询、一次TCP握手、一次TLS握手。这完美规避了域名分片的所有缺点。</li>\n</ol>\n<p><strong>因此，在 HTTP/2 下，域名分片变成了一个“反模式”：</strong></p>\n<ul>\n<li>你本来可以用一个高效连接解决所有问题。</li>\n<li>如果你使用了域名分片，浏览器反而需要与多个域名建立多个TCP连接，每个连接都有握手开销。这违背了HTTP/2的设计初衷，<strong>很可能导致性能下降而不是提升</strong>  。</li>\n</ul>\n<hr>\n<h3>五、实践建议</h3>\n<ol>\n<li>\n<p><strong>如果你的网站已经升级到 HTTP/2：</strong></p>\n<ul>\n<li><strong>停止使用域名分片。</strong>   将静态资源合并到主域名或尽可能少的域名下。</li>\n<li>享受单一连接带来的高效和低开销。</li>\n</ul>\n</li>\n<li>\n<p><strong>如果你的网站仍在使用 HTTP/1.1（并且短期内无法升级）：</strong></p>\n<ul>\n<li>域名分片仍然是一个有效的优化手段。</li>\n<li><strong>分片数量要适度：</strong>   通常 2-4 个子域名就足够了。分得过多，DNS查询和连接建立的开销会抵消并发带来的收益。</li>\n<li>常见的做法是使用专门的CDN域名来间接实现分片，例如 <code>cdn.example.com</code>。</li>\n</ul>\n</li>\n<li>\n<p><strong>其他考虑（即使在HTTP/2下也需要多域名的情况）：</strong></p>\n<ul>\n<li><strong>Cookie优化：</strong>   对于不需要Cookie的静态资源（如图片、CSS、JS），使用一个独立的、与主站不同的域名（例如 <code>static.example.com</code>）来存放，并确保这个域名不会发送Cookie。这样可以减少每个请求的头部大小，提升性能。这个独立的域名通常被称为 <strong>Cookie-Free Domain</strong>  。注意，这<strong>不是</strong>  域名分片，因为目的不是为了增加并发，而是为了减少请求头体积。</li>\n<li><strong>第三方资源：</strong>   加载来自不同域名的第三方资源（如Google Fonts、分析代码等）是正常的，这不属于主动实施的“域名分片”策略。</li>\n</ul>\n</li>\n</ol>\n<h3>总结</h3>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">特性</th>\n<th style="text-align:left">HTTP/1.1 环境</th>\n<th style="text-align:left">HTTP/2/3 环境</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>域名分片</strong></td>\n<td style="text-align:left"><strong>推荐</strong>  ，核心优化手段，用于提升并发</td>\n<td style="text-align:left"><strong>不推荐</strong>  ，是反模式，会增加开销</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>核心目标</strong></td>\n<td style="text-align:left">绕过浏览器对同一域名的并发请求限制</td>\n<td style="text-align:left">利用多路复用，减少连接建立的开销</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>最佳实践</strong></td>\n<td style="text-align:left">使用2-4个子域名进行分片</td>\n<td style="text-align:left">合并资源，使用尽可能少的域名</td>\n</tr>\n</tbody>\n</table>\n<p>总而言之，域名分片是特定历史时期（HTTP/1.1）的产物，它在当时是高性能网站的标配技术。但在现代HTTP/2已成为主流的背景下，我们应该理解其原理并认识到它已基本完成历史使命，转而拥抱更先进的HTTP/2特性。</p>\n</div>'</script></body></html>