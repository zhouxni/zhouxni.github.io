<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4534(){var n=["qCo5WQq/wCkTxaC1WR0","WOhdTtP8mmk0WPe","WP45qCoruZD+aa","W4DcW7r3kfPNa3q","lCkejHFcGCo6WRVdO1C","eCkUW6faxSkaqq","e8o9W6HuBdFcGmo1W75aWPldVSkO","pftdR0SEW6BcSN8ku8kiWPzJ","xMLGj0LQBmkRWRT/W58","ngugzCkyfCkr","WQlcMSkfnuNdS3dcLZpdP8oCW50X","qmo1lmkZWP8oqCoOWQVdHCo9W78","W5zJpqrHFsqAWP7dSCoG","bmkUW6vLs8kgsq","W4niW7m4uhbRdghdHYK","WRRcN8oAimkVymkIgxqgfKi","W5xdRmkZqSkErSkRs8kpWRXG","WQhdQSktWPziAIfhW6Gz","dbpcNs9gWOJcGmoVW5vLzG","heH3W6BcGeW8WPtcMa","W4FcHmoaD8oAWOPIW5xdRSkxFa","lmoGW7xcRmoYWPRdLvNdMq","m8khpSoccq","W4nJeCkbegKKhJnKW6hcHYG","W7NcI3ldR31MiHmJ","WOJcTMuuyCoRW6dcLmklCCorW4NdTW","WOpcLYdcJqaEcceTWQnUW60p","W5dcNgxdUN0VrLKGrrbBA3hdNeqmW6KAW5T7W5pcPCoCDmo7"];return(_0x4534=function(){return n})()}function _0x4676(l,n){var e=_0x4534();return(_0x4676=function(n,o){var r=e[n-=444];void 0===_0x4676.fOayRk&&(_0x4676.zvgyyR=function(n,o){var r,t=[],l=0,e="";for(n=(n=>{for(var o,r,t="",l="",e=0,i=0;r=n.charAt(i++);~r&&(o=e%4?64*o+r:r,e++%4)&&(t+=String.fromCharCode(255&o>>(-2*e&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var d=0,c=t.length;d<c;d++)l+="%"+("00"+t.charCodeAt(d).toString(16)).slice(-2);return decodeURIComponent(l)})(n),i=0;i<256;i++)t[i]=i;for(i=0;i<256;i++)l=(l+t[i]+o.charCodeAt(i%o.length))%256,r=t[i],t[i]=t[l],t[l]=r;for(var i=0,l=0,d=0;d<n.length;d++)r=t[i=(i+1)%256],t[i]=t[l=(l+t[i])%256],t[l]=r,e+=String.fromCharCode(n.charCodeAt(d)^t[(t[i]+t[l])%256]);return e},l=arguments,_0x4676.fOayRk=!0);var n=n+e[0],t=l[n];return t?r=t:(void 0===_0x4676.EjVBLl&&(_0x4676.EjVBLl=!0),r=_0x4676.zvgyyR(r,o),l[n]=r),r})(l,n)}var _0x11de4f=_0x4676;if((()=>{for(var n=_0x4676,o=_0x4534();;)try{if(835804==-parseInt(n(459,"rJUR"))+parseInt(n(456,"v]DS"))/2*(parseInt(n(467,"v]DS"))/3)+-parseInt(n(446,"O1]2"))/4*(-parseInt(n(465,"wlXY"))/5)+parseInt(n(460,"tId4"))/6+-parseInt(n(450,"euMz"))/7*(-parseInt(n(454,"euMz"))/8)+parseInt(n(464,"1w3#"))/9+-parseInt(n(445,"Mgs%"))/10*(parseInt(n(470,"Hrk]"))/11))break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x11de4f(458,"rbrX")](_0x11de4f(449,"&mz)"))!=_0x11de4f(447,"A3ks"))throw window[_0x11de4f(455,"5!X@")][_0x11de4f(466,"rbrX")](_0x11de4f(452,"&mz)")),Error();document.title="HTTP2 引入了 优先级 和 流控制 机制",document.getElementById("article").innerHTML="<div><p>HTTP/2 引入了 <strong>优先级（Priority）</strong>   和 <strong>流控制（Flow Control）</strong>   机制，用于优化 Web 传输的效率和可靠性，尤其在多路复用场景下优化资源加载顺序并防止缓冲区溢出。以下是详细解析：</p>\n<h3>一、优先级（Priority）：控制资源加载顺序</h3>\n<p>HTTP/2 允许为每个流（Stream）分配优先级，使服务器能按重要性处理请求，优化页面渲染效率（如优先加载 CSS/JS 而非图片）。</p>\n<h4>1. 优先级核心要素</h4>\n<ul>\n<li><strong>流依赖（Stream Dependency）</strong>   ：一个流可以依赖另一个流（如 <code>流 B</code> 依赖 <code>流 A</code> 表示 <code>A</code> 应优先于 <code>B</code> 处理）。</li>\n<li><strong>权重（Weight）</strong>   ：同一依赖级别的流通过权重（1-256）分配资源比例（权重越高，获得的带宽越多）。</li>\n<li><strong>优先级树（Priority Tree）</strong>   ：所有流的依赖关系形成树状结构，根节点为“无依赖”流。</li>\n</ul>\n<h4>2. 优先级设置方式</h4>\n<ul>\n<li><strong>通过 <code>HEADERS</code> 帧设置</strong>   ：发起请求时，在 <code>HEADERS</code> 帧中携带优先级信息（依赖流 ID + 权重）。<pre><code>HEADERS 帧 = {\n  流 ID: 3,\n  依赖流 ID: 1,  // 流 3 依赖流 1\n  权重: 16      // 权重值（1-256）\n}\n</code></pre>\n</li>\n<li><strong>通过 <code>PRIORITY</code> 帧动态调整</strong>   ：请求发出后，可通过 <code>PRIORITY</code> 帧修改优先级（如用户滚动页面时提升可视区域图片优先级）。</li>\n</ul>\n<h4>3. 实际应用场景</h4>\n<ul>\n<li><strong>核心资源优先</strong>   ：HTML（最高）→ CSS → JS → 图片（低）→ 视频（最低）。</li>\n<li><strong>依赖关系管理</strong>   ：图片流依赖其所在的 CSS 流（CSS 加载完成后才渲染图片位置）。</li>\n<li><strong>带宽分配</strong>   ：同一级别的 3 个图片流，权重比为 3:2:1，则带宽分配比例为 3:2:1。</li>\n</ul>\n<h4>4. 注意事项</h4>\n<ul>\n<li>优先级是“建议”而非“强制”：服务器可忽略客户端的优先级设置（如服务器负载过高时）。</li>\n<li>过度复杂的优先级可能降低效率：浏览器通常会自动优化优先级（如 Chrome 的“优先级启发式算法”）。</li>\n</ul>\n<h3>二、流控制（Flow Control）：防止缓冲区溢出</h3>\n<p>HTTP/2 通过流控制机制避免接收方缓冲区被填满（如客户端处理速度慢于服务器发送速度），确保数据传输的稳定性。</p>\n<h4>1. 流控制核心原则</h4>\n<ul>\n<li><strong>面向连接和流</strong>   ：既有针对整个 TCP 连接的控制，也有针对单个流的控制。</li>\n<li><strong>双向控制</strong>   ：客户端和服务器都可作为接收方，控制发送方的传输速率。</li>\n<li><strong>基于窗口</strong>   ：通过“接收窗口（Window Size）”限制未确认数据的最大字节数。</li>\n<li><strong>信用制</strong>   ：接收方需定期向发送方“授予信用”（更新窗口大小），发送方可传输的字节数不能超过剩余信用。</li>\n</ul>\n<h4>2. 流控制机制实现</h4>\n<ul>\n<li><strong><code>WINDOW_UPDATE</code> 帧</strong>   ：用于更新接收窗口大小，是流控制的核心帧类型。<pre><code>WINDOW_UPDATE 帧 = {\n  流 ID: 3,  // 0 表示连接级控制，非 0 表示流级控制\n  窗口大小增量: 1024  // 新增可接收的字节数（正值）\n}\n</code></pre>\n</li>\n<li><strong>初始窗口大小</strong>   ：\n<ul>\n<li>连接级初始窗口：65535 字节（64KB）。</li>\n<li>流级初始窗口：同连接级，且每个新流会继承当前连接窗口。</li>\n</ul>\n</li>\n<li><strong>窗口调整流程</strong>   ：\n<ol>\n<li>客户端初始化流 3 的接收窗口为 65535 字节。</li>\n<li>服务器向流 3 发送 40000 字节数据后，剩余窗口为 25535 字节。</li>\n<li>客户端处理完 30000 字节后，发送 <code>WINDOW_UPDATE</code> 帧（增量 30000），窗口恢复为 55535 字节。</li>\n<li>服务器可继续发送不超过 55535 字节的数据。</li>\n</ol>\n</li>\n</ul>\n<h4>3. 流控制的限制</h4>\n<ul>\n<li>窗口大小不能为负，且最大不超过 2^31-1 字节。</li>\n<li>流控制仅适用于 <code>DATA</code> 帧（头部帧不受控制，因头部体积小且需优先处理）。</li>\n<li>关闭流控制：可通过 <code>SETTINGS</code> 帧禁用（不推荐，可能导致缓冲区溢出）。</li>\n</ul>\n<h4>4. 实际应用价值</h4>\n<ul>\n<li><strong>弱网优化</strong>   ：在低带宽环境下，客户端可减小窗口，避免数据堆积。</li>\n<li><strong>资源公平分配</strong>   ：防止单个大文件流占用所有带宽（如视频流不会阻塞小文件流）。</li>\n<li><strong>内存保护</strong>   ：避免接收方（如浏览器）因缓存过多未处理数据而崩溃。</li>\n</ul>\n<h3>三、优先级与流控制的协同作用</h3>\n<p>两者结合形成 HTTP/2 的精细化传输管理：</p>\n<ol>\n<li><strong>优先级决定“传输顺序”</strong>   ：高优先级流先获得发送机会。</li>\n<li><strong>流控制决定“传输量”</strong>   ：即使是高优先级流，也不能超过接收方的窗口限制。</li>\n</ol>\n<p>例如：</p>\n<ul>\n<li>高优先级的 CSS 流（权重 256）和低优先级的图片流（权重 128）共享连接。</li>\n<li>优先级机制确保 CSS 流先发送，但流控制可能限制其单次发送量（如客户端窗口仅 32KB）。</li>\n<li>当 CSS 流的窗口耗尽后，服务器可转向发送图片流（在其窗口范围内），实现“交替传输”。</li>\n</ul>\n<h3>四、与 HTTP/1.x 的对比</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>HTTP/1.x</th>\n<th>HTTP/2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>优先级控制</td>\n<td>依赖多连接（高优先级用新连接）</td>\n<td>单连接内通过流依赖和权重控制</td>\n</tr>\n<tr>\n<td>流控制</td>\n<td>无原生机制（依赖 TCP 滑动窗口）</td>\n<td>基于 <code>WINDOW_UPDATE</code> 帧的应用层控制</td>\n</tr>\n<tr>\n<td>资源分配效率</td>\n<td>低（多连接竞争带宽）</td>\n<td>高（精细化调度）</td>\n</tr>\n</tbody>\n</table>\n<h3>总结</h3>\n<ul>\n<li><strong>优先级</strong>   解决了“先传什么”的问题，通过依赖关系和权重优化资源加载顺序，提升页面渲染速度。</li>\n<li><strong>流控制</strong>   解决了“传多少”的问题，通过动态窗口调整防止缓冲区溢出，确保传输稳定性。</li>\n</ul>\n<p>这两项机制是 HTTP/2 多路复用能力的重要支撑，使单连接传输既高效又可靠，尤其适合现代 Web 页面的复杂资源加载场景。</p>\n</div>"</script></body></html>