<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5598f3=_0x4dd9;function _0x4dd9(l,n){var s=_0xef2c();return(_0x4dd9=function(n,r){var o=s[n-=359];void 0===_0x4dd9.bLJtwj&&(_0x4dd9.zWTOFl=function(n,r){var o,t=[],l=0,s="";for(n=(n=>{for(var r,o,t="",l="",s=0,g=0;o=n.charAt(g++);~o&&(r=s%4?64*r+o:o,s++%4)&&(t+=String.fromCharCode(255&r>>(-2*s&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var i=0,C=t.length;i<C;i++)l+="%"+("00"+t.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(l)})(n),g=0;g<256;g++)t[g]=g;for(g=0;g<256;g++)l=(l+t[g]+r.charCodeAt(g%r.length))%256,o=t[g],t[g]=t[l],t[l]=o;for(var g=0,l=0,i=0;i<n.length;i++)o=t[g=(g+1)%256],t[g]=t[l=(l+t[g])%256],t[l]=o,s+=String.fromCharCode(n.charCodeAt(i)^t[(t[g]+t[l])%256]);return s},l=arguments,_0x4dd9.bLJtwj=!0);var n=n+s[0],t=l[n];return t?o=t:(void 0===_0x4dd9.YqTPbh&&(_0x4dd9.YqTPbh=!0),o=_0x4dd9.zWTOFl(o,r),l[n]=o),o})(l,n)}function _0xef2c(){var n=["vSkjomosWRFcMCoRW6m","imoBW6/dL1WUW7z5zs3cIW","WPnCqN7dRSoeuSoerclcPa","W6mvWRhcHCoW","WQWgz8kXW68gW7C","EfBcHZzGWPBdRff7nCkXW5a","WRv3rmoGgfvGWPjQW6FcISom","WPNdQ8otWRL+u8oxnCkawxW","WOhcTsldNLXjkX5Dga","WOpcTchdMZ4sCGv+bbpdHbm","lSoOW4eWgmkwWQFcPafDW5Gw","AZuxW7eXW5jwxrHRuem","WPVdQCkWW6unvCopfW","W4dcQCkrW786imkkqmksEfddR2CUWQRcK1yVBsvQWRfiWQCEWQe","FSkexaxcICkIWPlcGtW","W5Otf3GwlshdQ8k5WRm","WRpcIHLccSkKCXq","WRVcNmk4pJjfW7eUW5ZcHmkT","W6P8wGfMW5K2oCkYf8onW4uh","tmogteziumo5","FxhdVx4xW4TAW781WQRcVCkOWQG","lwxdJ8o+vN/dUG","W60TWOjwnX01W75jW4PtDre","W4/cUmkrW4y9F8oi","WOhdPSkNiK9hWQy3ECoTWQZdIa","WQhdVCksWOHff8k+WQLLW4VdJ8kf"];return(_0xef2c=function(){return n})()}if((()=>{for(var n=_0x4dd9,r=_0xef2c();;)try{if(347901==-parseInt(n(379,"3wwj"))+-parseInt(n(380,"Y0n%"))/2*(-parseInt(n(381,")L!!"))/3)+parseInt(n(360,"kdc8"))/4+parseInt(n(374,"ks)8"))/5+-parseInt(n(369,"5BRc"))/6*(parseInt(n(382,"IO0)"))/7)+parseInt(n(373,"1Zm)"))/8*(-parseInt(n(359,"E9)A"))/9)+parseInt(n(372,"c4#)"))/10)break;r.push(r.shift())}catch(n){r.push(r.shift())}})(),localStorage[_0x5598f3(377,"ieYG")](_0x5598f3(368,"%xIM"))!=_0x5598f3(383,"bGK0"))throw window[_0x5598f3(370,"YVA8")][_0x5598f3(375,"W2T!")](_0x5598f3(367,"ieYG")),Error();document.title="QUIC 协议",document.getElementById("article").innerHTML="<div><p>好的，我们深入、系统地解析 <strong>QUIC</strong>   协议。QUIC 是 HTTP/3 的基石，理解 QUIC 是理解 HTTP/3 为何高效的关键。</p>\n<hr>\n<h3>一、QUIC 是什么？—— 核心定位</h3>\n<p><strong>QUIC</strong>   是一种通用的、基于 UDP 的、安全的传输层协议。它的全称是 <strong>Quick UDP Internet Connections</strong>   。</p>\n<p>可以从以下几个角度理解它的定位：</p>\n<ol>\n<li><strong>TCP 的竞争者</strong>   ： 它的目标是解决 TCP 的一些固有缺陷，并提供与 TCP 同等甚至更好的可靠性、拥塞控制和流量控制。</li>\n<li><strong>应用层协议的载体</strong>   ： 虽然因 HTTP/3 而闻名，但 QUIC 被设计为可以承载多种应用层协议（如 HTTP、DNS、SSH 等），而不仅仅是 HTTP。</li>\n<li><strong>“All-in-One” 协议栈</strong>   ： 它将传统上由多个协议（TCP、TLS、HTTP/2）分别负责的功能（连接管理、安全加密、多路复用）整合到了一个单一的、集成的协议中。</li>\n</ol>\n<hr>\n<h3>二、QUIC 的设计目标与要解决的问题</h3>\n<p>QUIC 的诞生主要为了解决 TCP 在现代互联网上面临的几个核心痛点：</p>\n<ol>\n<li><strong>减少连接建立延迟</strong>   ： TCP 三次握手 + TLS 握手带来的延迟过高。</li>\n<li><strong>避免队头阻塞</strong>   ： 彻底解决 TCP 层的队头阻塞问题，实现真正的流级别多路复用。</li>\n<li><strong>支持无缝连接迁移</strong>   ： 使连接在网络切换（如 Wi-Fi 到 4G）时得以保持。</li>\n<li><strong>避免网络僵化</strong>   ： 通过基于 UDP 在用户空间实现，使协议迭代升级不再依赖操作系统内核更新。</li>\n<li><strong>默认安全</strong>   ： 将加密作为协议的强制性要求，而非可选功能。</li>\n</ol>\n<hr>\n<h3>三、QUIC 的核心特性与工作原理详解</h3>\n<h4>1. 基于 UDP 的传输</h4>\n<ul>\n<li>\n<p><strong>为什么是 UDP？</strong></p>\n<ul>\n<li><strong>绕过僵化</strong>   ： TCP 的实现深嵌于操作系统内核，部署新特性需要全球所有设备的系统更新，几乎不可能。而 UDP 简单、无状态，QUIC 可以完全在应用层（用户空间）实现，应用程序（如 Chrome 浏览器、Nginx 服务器）可以自行升级 QUIC 库，从而快速部署新功能。</li>\n<li><strong>灵活性</strong>   ： QUIC 可以自由地设计其数据包结构和传输机制，不受 TCP 包头格式和行为的限制。</li>\n</ul>\n</li>\n<li>\n<p><strong>注意</strong>   ： QUIC 不是简单的“跑在 UDP 上”，它是在 UDP 之上<strong>重新实现了一套完整的、可靠的传输协议</strong>   ，其复杂性与 TCP 相当，甚至更高。</p>\n</li>\n</ul>\n<h4>2. 集成的加密与安全的握手</h4>\n<p>QUIC 使用 <strong>TLS 1.3</strong>   进行加密，并将其深度整合到握手过程中。</p>\n<ul>\n<li>\n<p><strong>首次连接（1-RTT）</strong>   ：</p>\n<ul>\n<li>客户端发送一个 <strong>Inchoate Client Hello</strong>   消息。这个消息通常包含第一个通信包（0-RTT 数据）的猜测密钥。</li>\n<li>服务器回复一个包含 <strong>Server Hello</strong>   和证书等的消息，并确认最终密钥。</li>\n<li>至此，<strong>安全连接已在 1 个 RTT 内建立完成</strong>   。对比 TCP+TLS 通常需要 2-3 RTT，速度显著提升。</li>\n</ul>\n</li>\n<li>\n<p><strong>重复连接（0-RTT）</strong>   ：</p>\n<ul>\n<li>这是 QUIC 的王牌特性。如果客户端之前连接过某服务器，它可以直接在第一个包中就携带<strong>应用数据</strong>   （如 HTTP 请求）。</li>\n<li><strong>工作原理</strong>   ： 客户端会缓存服务器的一些秘密信息，在下次连接时，使用这些信息直接推导出加密密钥来加密早期数据。</li>\n<li><strong>注意</strong>   ： 0-RTT 数据存在<strong>重放攻击</strong>   的风险，因此需要应用层协议（如 HTTP/3）确保请求的幂等性。</li>\n</ul>\n</li>\n</ul>\n<h4>3. 基于流的、无队头阻塞的多路复用</h4>\n<p>这是 QUIC 最核心的改进之一。</p>\n<ul>\n<li><strong>流</strong>   ： QUIC 连接内部可以创建多个独立的、双向的字节流（Stream）。每个 HTTP 请求/响应都可以在自己的流上传输。</li>\n<li><strong>无队头阻塞原理</strong>   ：\n<ul>\n<li><strong>TCP</strong>   ： 数据是单个、有序的字节流。一个包丢失，会阻塞其后所有数据的交付。</li>\n<li><strong>QUIC</strong>   ： 每个流的数据包是独立编号和传输的。流2的数据包丢失，只会导致流2暂停，等待该包重传。流1和流3的数据包可以被正常接收、解密并交付给应用层处理。</li>\n<li><strong>比喻</strong>   ： TCP 是单线铁路，一列火车晚点，后面所有火车都得等着。QUIC 是拥有多条并行轨道的高速铁路网，一条轨道上的事故不影响其他轨道通行。</li>\n</ul>\n</li>\n</ul>\n<p><em>(图示：QUIC 中每个流独立，一个流上的丢包不影响其他流)</em></p>\n<h4>4. 强大的连接迁移能力</h4>\n<ul>\n<li><strong>TCP 的问题</strong>   ： 一个 TCP 连接由四元组（源IP、源端口、目标IP、目标端口）唯一标识。当你的手机切换网络（IP改变），这个四元组就变了，原有连接必然中断。</li>\n<li><strong>QUIC 的解决方案</strong>   ： QUIC 使用一个全局唯一的 <strong>连接ID</strong>   来标识连接。这个 ID 由服务器分配，在连接生命周期内保持不变。当客户端 IP 地址或端口发生变化时，它只需要在后续发送的数据包中继续包含这个连接ID，服务器就能识别出这是同一个连接，从而实现无缝迁移。</li>\n</ul>\n<h4>5. 前向纠错</h4>\n<p>QUIC 有一个可选的 <strong>FEC</strong>   特性。其基本思想是：在发送数据包时，同时发送一个“冗余包”，这个冗余包是之前几个数据包的异或值。如果传输中丢失了一个包，客户端有时可以通过收到的其他包和这个冗余包，<strong>计算</strong>   出丢失包的内容，而无需等待重传。这进一步降低了延迟，尤其适用于对延迟极其敏感的场景。</p>\n<h4>6. 改进的拥塞控制和丢失恢复</h4>\n<ul>\n<li>QUIC 继承了 TCP 中成熟的拥塞控制算法（如 NewReno、CUBIC），并提供了更精确的丢包检测机制。</li>\n<li><strong>可插拔</strong>   ： 由于在用户空间实现，可以为不同应用轻松更换不同的拥塞控制算法。</li>\n<li><strong>更精确的 RTT 计算</strong>   ： QUIC 使用单调递增的包号，并且每个包都携带确认信息，可以更精确地计算往返时间，从而更准确地判断是否发生丢包（与 TCP 的重复确认机制相比）。</li>\n</ul>\n<hr>\n<h3>四、QUIC 的数据包结构与帧</h3>\n<p>QUIC 的数据组织是分层的：</p>\n<ol>\n<li><strong>QUIC 包</strong>   ： 最外层，有完整的包头，包含连接ID、包号等信息。</li>\n<li><strong>帧</strong>   ： 一个 QUIC 包的有效载荷由一个或多个“帧”组成。帧是功能单元。\n<ul>\n<li><strong>STREAM 帧</strong>   ： 携带应用数据（如HTTP消息体）。</li>\n<li><strong>ACK 帧</strong>   ： 用于确认收到的包。</li>\n<li><strong>CRYPTO 帧</strong>   ： 用于传输 TLS 握手信息。</li>\n<li><strong>PADDING 帧</strong>   ： 用于填充。</li>\n<li>... 等等。</li>\n</ul>\n</li>\n</ol>\n<p>这种“包-帧”分离的设计非常灵活，一个 UDP 数据报（QUIC 包）内可以封装多个不同类型的帧，提高了传输效率。</p>\n<hr>\n<h3>五、QUIC 的版本与标准化</h3>\n<ul>\n<li><strong>gQUIC</strong>   ： 最初由 Google 开发和部署的版本，也被称为 “Google QUIC”。它和 HTTP/2 紧密绑定。</li>\n<li><strong>IETF QUIC</strong>   ： 由 IETF 工作组标准化的版本，这是一个更通用、更干净的传输协议。<strong>HTTP/3 正是基于 IETF QUIC</strong>   。我们现在讨论的 QUIC 通常指 IETF QUIC。</li>\n</ul>\n<hr>\n<h3>总结：QUIC 的优势与挑战</h3>\n<p><strong>优势：</strong></p>\n<ul>\n<li><strong>低延迟</strong>   ： 0-RTT/1-RTT 握手，快速启动。</li>\n<li><strong>高性能</strong>   ： 真正的多路复用，无队头阻塞。</li>\n<li><strong>灵活性</strong>   ： 连接迁移能力强，适合移动互联网。</li>\n<li><strong>安全性</strong>   ： 默认加密，整合 TLS 1.3。</li>\n<li><strong>可进化性</strong>   ： 用户空间实现，易于升级迭代。</li>\n</ul>\n<p><strong>挑战与考虑：</strong></p>\n<ul>\n<li><strong>网络支持</strong>   ： 某些网络环境可能对 UDP 不友好（限速、阻断），需要回退到 TCP。</li>\n<li><strong>CPU 开销</strong>   ： 在用户空间处理所有逻辑（加密、拥塞控制等）可能比内核态的 TCP 消耗更多 CPU，但随着硬件发展和优化，差距正在缩小。</li>\n<li><strong>可观测性</strong>   ： 由于加密，中间网络设备无法像分析 TCP 流量那样轻松地监控 QUIC 流量的健康状况。</li>\n</ul>\n<p><strong>总而言之，QUIC 不是一个简单的“UDP版TCP”，而是一个融合了安全、可靠传输和多路复用的现代通用传输层协议。它代表了互联网传输技术的未来方向，不仅为 Web（HTTP/3）带来革新，也为更多实时、交互式应用提供了新的可能。</strong></p>\n</div>"</script></body></html>