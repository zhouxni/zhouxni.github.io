<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x10f2fa=_0x3bd4;function _0x3bd4(i,n){var l=_0x3793();return(_0x3bd4=function(n,r){var o=l[n-=294];void 0===_0x3bd4.HUjPEi&&(_0x3bd4.tpZyyE=function(n,r){var o,t=[],i=0,l="";for(n=(n=>{for(var r,o,t="",i="",l=0,W=0;o=n.charAt(W++);~o&&(r=l%4?64*r+o:o,l++%4)&&(t+=String.fromCharCode(255&r>>(-2*l&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var e=0,d=t.length;e<d;e++)i+="%"+("00"+t.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(i)})(n),W=0;W<256;W++)t[W]=W;for(W=0;W<256;W++)i=(i+t[W]+r.charCodeAt(W%r.length))%256,o=t[W],t[W]=t[i],t[i]=o;for(var W=0,i=0,e=0;e<n.length;e++)o=t[W=(W+1)%256],t[W]=t[i=(i+t[W])%256],t[i]=o,l+=String.fromCharCode(n.charCodeAt(e)^t[(t[W]+t[i])%256]);return l},i=arguments,_0x3bd4.HUjPEi=!0);var n=n+l[0],t=i[n];return t?o=t:(void 0===_0x3bd4.JVpWwA&&(_0x3bd4.JVpWwA=!0),o=_0x3bd4.tpZyyE(o,r),i[n]=o),o})(i,n)}function _0x3793(){var n=["WOVcM8kUW59axsW","bJRcGc3dJqNdI1CtgYb1","W4VcOCkHW7D+sSkjW4pdQmkkWOn7W6S","W6ddJSogdSobedNdQGOxW6VcTq","jIxdI8osW6rNW5HsW5FcKa8V","rCo5WR8OgSoYsxW","WQjUWPxdQr5bW4m","W6bVdItcVaRcH8o1WQ4XW5DMW4S","iSovAxu1qmoQ","yeTEW7xcRmkGW6yF","WOy8WRToW4BdGSoEW41HWRmXW60","rmkRw8kwqdNcK8ksbCoUWPRcRLe","rINcUSoBWPGYdCobWRhdLSkBWQvX","W6O4fvb9smkQE8o5WQ/dGcK","WOi+imoWW7m","tSoLytycsSkj","WO5jW44oWRpcK8oI","iqRdTKraW7dcOmkPmbe8W5S","rSkNxCkurthcLCkMmCoyWQdcRee","WPXxqmotW7ZdRSowjsJcGKFdINBdJCoNW5tdSvlcTSo6AutdHSkcWP1N","qSkWW5HOWRWCrG","WPBcMmktu8kavtpdTri","W40tdCkBWR/dOCk2qX7cQgRdHq","WORdR8o6WQWlarCaWQ/cPM7cOG","W4dcTZKGWOnRkZy"];return(_0x3793=function(){return n})()}if((()=>{for(var n=_0x3bd4,r=_0x3793();;)try{if(438671==+parseInt(n(317,"RY25"))*(parseInt(n(299,"#*T("))/2)+parseInt(n(303,"XK8a"))/3+parseInt(n(302,"^tTZ"))/4+parseInt(n(311,"RY25"))/5*(-parseInt(n(309,"SDq5"))/6)+-parseInt(n(305,"LMFw"))/7+parseInt(n(294,"ieyc"))/8*(-parseInt(n(310,"KqO6"))/9)+parseInt(n(313,"tGex"))/10)break;r.push(r.shift())}catch(n){r.push(r.shift())}})(),localStorage[_0x10f2fa(316,"e^oh")](_0x10f2fa(297,"wCez"))!=_0x10f2fa(315,"eyGf"))throw window[_0x10f2fa(300,"6!!s")][_0x10f2fa(307,"o*Ek")](_0x10f2fa(295,"Tgbx")),Error();document.title="TCP协议中四次挥手后的 TIME_WAIT 状态持续 2MSL 的目的",document.getElementById("article").innerHTML="<div><p>在TCP协议中，四次挥手（Four-Way Handshake）后的<strong>TIME_WAIT状态持续2MSL（Maximum Segment Lifetime）</strong>  主要有两个核心目的：</p>\n<h3><strong>1. 确保最后一个ACK包被对方收到</strong></h3>\n<ul>\n<li><strong>挥手过程</strong>  ：\n<ol>\n<li>客户端发送FIN包请求关闭连接。</li>\n<li>服务器收到FIN后发送ACK确认。</li>\n<li>服务器发送FIN包请求关闭连接。</li>\n<li>客户端收到FIN后发送ACK确认，并进入<strong>TIME_WAIT状态</strong>  等待2MSL。</li>\n</ol>\n</li>\n<li><strong>潜在问题</strong>  ：<br>\n若客户端发送的最后一个ACK在传输中丢失，服务器将因未收到确认而重发FIN包。此时客户端若已关闭连接（无TIME_WAIT），将响应RST包（重置连接），导致服务器异常。通过等待2MSL，客户端可确保：\n<ul>\n<li>若ACK丢失，服务器会重发FIN，客户端能再次响应ACK。</li>\n<li>2MSL时间足够长，可覆盖ACK和FIN的最大往返时间，避免延迟包干扰后续连接。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>2. 防止“延迟包”干扰新连接</strong></h3>\n<ul>\n<li><strong>MSL（最大段生存期）</strong>  ：指任何TCP分段在网络中存活的最长时间，通常为2分钟（RFC 793建议值）。</li>\n<li><strong>延迟包风险</strong>  ：<br>\n若旧连接的数据包因网络拥塞等原因延迟到达，而新连接已使用相同的IP地址和端口对（四元组），延迟包可能被误认为是新连接的数据，导致数据错乱。</li>\n<li><strong>TIME_WAIT的作用</strong>  ：<br>\n等待2MSL可确保：\n<ul>\n<li>旧连接的所有数据包都已在网络中消亡（超过MSL时间）。</li>\n<li>新连接建立时，旧连接的延迟包不会干扰。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>为什么是2MSL？</strong></h3>\n<ul>\n<li><strong>MSL（发送方） + MSL（接收方）</strong>  ：<br>\n理论上，一个数据包从发送到确认的最长时间为2MSL（发送方MSL + 接收方MSL）。等待2MSL可确保：\n<ul>\n<li>旧连接的所有数据包（包括FIN、ACK）都已过期。</li>\n<li>新连接不会收到来自旧连接的任何数据包。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>TIME_WAIT的负面影响与优化</strong></h3>\n<ul>\n<li><strong>端口占用</strong>  ：TIME_WAIT状态会占用本地端口，高并发场景下可能导致端口耗尽。</li>\n<li><strong>优化方法</strong>  ：\n<ul>\n<li>服务端可调整<code>net.ipv4.tcp_tw_reuse</code>参数（需配合<code>TCP_TIMESTAMP</code>），允许复用处于TIME_WAIT的端口。</li>\n<li>客户端可通过随机端口（动态端口范围）避免端口耗尽。</li>\n</ul>\n</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<p>TCP四次挥手后的2MSL等待是为了：</p>\n<ol>\n<li><strong>可靠性保障</strong>  ：确保最后一个ACK被对方收到，避免连接异常关闭。</li>\n<li><strong>数据隔离</strong>  ：防止旧连接的延迟包干扰新连接。<br>\n这是TCP协议为保证连接可靠关闭和数据完整性设计的重要机制。</li>\n</ol>\n</div>"</script></body></html>