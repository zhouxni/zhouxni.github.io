<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x31e497=_0x5533;function _0x5339(){var n=["mSoPWOFcUmkrDqBdHsWKnq","acVcQI1LB0ykWQxdHxDlWR4","DKtcLSkbpNzoW5uvWPPtq8kVvrSqW5BdQmk9W6ZcISo6nfGQWOG","udBcN1yKtrBcHMZcMCo8ha","pvOVzmkXWOJdRmkA","udRcISksd2VdIG","WR7cGZldNt/cHSodWRn8WQuihq","qv7cMhaUW7W0W4pcQG","wdlcLLqKsZpcJvBcMCoogW","rLxcNIjqWRqgW7xcQ8oLW5eA","mCktW5pdUSo0smoDwG","vJlcNfyKtfFcOMdcJSo7kN8","WQhdKJXMW5ewlYldRua7WP04","fdBcIx3cPHRcQmoQzWTsBq","WQ5RWQLwxa","lCkgprGXW4mL","WRaJW78CW5u4lSo2W71noW","WQhdKZfKW5CqyG3dUfGrWOi","WR/cHZddS2RcP8kBW78K","F8k2zKldKCk3WR4KW5dcTmoEAeW","y8kcW7NcJCoPWOldPNFcGa","W6RcK8o1W7fAAmoPW7FdMeX+WQNcPq","mmoxbZldN8kusmoxWPn6EIrE","jmoRnXdcLmoPW6uC"];return(_0x5339=function(){return n})()}function _0x5533(r,n){var t=_0x5339();return(_0x5533=function(n,l){var o=t[n-=480];void 0===_0x5533.KaeugQ&&(_0x5533.PJjiod=function(n,l){var o,i=[],r=0,t="";for(n=(n=>{for(var l,o,i="",r="",t=0,e=0;o=n.charAt(e++);~o&&(l=t%4?64*l+o:o,t++%4)&&(i+=String.fromCharCode(255&l>>(-2*t&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var c=0,d=i.length;c<d;c++)r+="%"+("00"+i.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(r)})(n),e=0;e<256;e++)i[e]=e;for(e=0;e<256;e++)r=(r+i[e]+l.charCodeAt(e%l.length))%256,o=i[e],i[e]=i[r],i[r]=o;for(var e=0,r=0,c=0;c<n.length;c++)o=i[e=(e+1)%256],i[e]=i[r=(r+i[e])%256],i[r]=o,t+=String.fromCharCode(n.charCodeAt(c)^i[(i[e]+i[r])%256]);return t},r=arguments,_0x5533.KaeugQ=!0);var n=n+t[0],i=r[n];return i?o=i:(void 0===_0x5533.iLNbdW&&(_0x5533.iLNbdW=!0),o=_0x5533.PJjiod(o,l),r[n]=o),o})(r,n)}if((()=>{for(var n=_0x5533,l=_0x5339();;)try{if(547185==-parseInt(n(496,"0Iu4"))+parseInt(n(482,"[UB("))/2*(parseInt(n(486,"^UXz"))/3)+-parseInt(n(491,"[8Bz"))/4+parseInt(n(488,")q&*"))/5+-parseInt(n(503,"tXUy"))/6+parseInt(n(485,"y1@l"))/7+-parseInt(n(499,"^&5a"))/8*(-parseInt(n(494,"*S4f"))/9))break;l.push(l.shift())}catch(n){l.push(l.shift())}})(),localStorage[_0x31e497(495,"DyzB")](_0x31e497(484,"Wxxd"))!=_0x31e497(480,"JOb!"))throw window[_0x31e497(489,"y1@l")][_0x31e497(481,"D7((")](_0x31e497(492,"%)15")),Error();document.title="代理服务器缓存",document.getElementById("article").innerHTML="<div><h3>代理服务器缓存详解</h3>\n<p>代理服务器缓存是位于客户端和源服务器之间的中间层，用于存储和提供经常请求的内容。通过缓存，代理服务器可以显著减少延迟、加快页面加载速度、降低带宽消耗，并减轻源服务器的负载。以下是关于代理服务器缓存的全面解析：</p>\n<hr>\n<h4>一、代理服务器缓存的工作原理</h4>\n<ol>\n<li><strong>缓存机制</strong>  ：\n<ul>\n<li><strong>首次请求</strong>  ：当客户端首次请求某个资源时，代理服务器会向源服务器请求该资源，并将其存储在缓存中。</li>\n<li><strong>后续请求</strong>  ：当其他客户端再次请求同一资源时，代理服务器会直接从缓存中提供该资源，而无需再次向源服务器请求。</li>\n</ul>\n</li>\n<li><strong>缓存键</strong>  ：\n<ul>\n<li>代理服务器使用 URL、请求头（如 <code>Accept</code>、<code>User-Agent</code> 等）和其他参数作为缓存键，以唯一标识缓存的资源。</li>\n</ul>\n</li>\n<li><strong>缓存有效性</strong>  ：\n<ul>\n<li>代理服务器会根据源服务器返回的缓存控制头字段（如 <code>Cache-Control</code>、<code>Expires</code>、<code>ETag</code>、<code>Last-Modified</code> 等）来判断缓存的有效性。</li>\n<li>如果缓存过期或源服务器指示资源已更改，代理服务器会重新向源服务器请求最新资源。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4>二、代理服务器缓存的优势</h4>\n<ol>\n<li><strong>提高性能</strong>  ：\n<ul>\n<li>通过缓存经常请求的内容，代理服务器可以显著减少客户端的等待时间，提高页面加载速度。</li>\n<li>缓存还可以减少网络延迟，特别是在客户端与源服务器之间距离较远的情况下。</li>\n</ul>\n</li>\n<li><strong>降低带宽消耗</strong>  ：\n<ul>\n<li>代理服务器缓存可以减少源服务器的流量，降低带宽成本。</li>\n<li>对于高流量的网站或应用，缓存可以显著减少网络拥塞。</li>\n</ul>\n</li>\n<li><strong>增强可靠性</strong>  ：\n<ul>\n<li>在源服务器出现故障或网络中断时，代理服务器可以继续提供缓存的内容，确保服务的连续性。</li>\n</ul>\n</li>\n<li><strong>负载均衡</strong>  ：\n<ul>\n<li>代理服务器可以分发客户端请求，减轻源服务器的负载，提高系统的整体可扩展性。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4>三、代理服务器缓存的控制策略</h4>\n<ol>\n<li><strong>缓存控制头字段</strong>  ：\n<ul>\n<li><strong>Cache-Control</strong>  ：源服务器可以通过设置 <code>Cache-Control</code> 头字段来控制代理服务器的缓存行为。例如，<code>Cache-Control: public, max-age=3600</code> 指示代理服务器可以缓存该资源 1 小时。</li>\n<li><strong>Expires</strong>  ：设置缓存的过期时间，但现代应用中更推荐使用 <code>Cache-Control</code>。</li>\n<li><strong>ETag</strong>   和 <strong>Last-Modified</strong>  ：用于条件请求，确保代理服务器在资源未发生变化时不会重复向源服务器请求。</li>\n</ul>\n</li>\n<li><strong>缓存验证</strong>  ：\n<ul>\n<li>当缓存过期时，代理服务器会向源服务器发送条件请求（如 <code>If-Modified-Since</code> 或 <code>If-None-Match</code>），以验证缓存的有效性。</li>\n<li>如果源服务器返回 304 状态码（未修改），代理服务器会继续使用缓存；如果返回 200 状态码和新的资源内容，代理服务器会更新缓存。</li>\n</ul>\n</li>\n<li><strong>缓存清理</strong>  ：\n<ul>\n<li>代理服务器可以定期清理过期缓存，或根据源服务器的指示（如通过缓存清理 API）手动清除特定资源的缓存。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4>四、代理服务器缓存的应用场景</h4>\n<ol>\n<li><strong>内容分发网络（CDN）</strong>  ：\n<ul>\n<li>CDN 是代理服务器缓存的典型应用，它通过将内容缓存到全球各地的节点上，使用户能够从最近的节点获取内容，提高访问速度。</li>\n</ul>\n</li>\n<li><strong>企业网络</strong>  ：\n<ul>\n<li>在企业网络中，代理服务器可以缓存常用的软件更新、补丁和内部资源，减少带宽消耗和源服务器的负载。</li>\n</ul>\n</li>\n<li><strong>Web 应用</strong>  ：\n<ul>\n<li>Web 应用可以使用代理服务器缓存静态资源（如图片、CSS、JavaScript 文件等），提高页面加载速度和用户体验。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4>五、代理服务器缓存的注意事项</h4>\n<ol>\n<li><strong>缓存一致性</strong>  ：\n<ul>\n<li>确保代理服务器的缓存与源服务器的资源保持一致，避免提供过时的内容。</li>\n<li>使用合适的缓存控制策略，如设置较短的缓存时间或禁用缓存对于经常变化的资源。</li>\n</ul>\n</li>\n<li><strong>安全性</strong>  ：\n<ul>\n<li>对于包含敏感信息的资源，应谨慎设置缓存策略，避免缓存被恶意利用。</li>\n<li>可以使用 HTTPS 加密传输，确保缓存内容的安全性。</li>\n</ul>\n</li>\n<li><strong>缓存清理机制</strong>  ：\n<ul>\n<li>定期清理过期缓存，避免缓存占用过多存储空间。</li>\n<li>提供缓存清理 API 或工具，方便管理员手动清除特定资源的缓存。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4>六、总结</h4>\n<p>代理服务器缓存是提高网络性能、降低带宽消耗和增强可靠性的重要手段。通过合理的缓存控制策略和应用场景选择，可以充分发挥代理服务器缓存的优势。同时，也需要注意缓存一致性、安全性和缓存清理机制等问题，确保代理服务器缓存的有效性和可靠性。</p>\n</div>"</script></body></html>