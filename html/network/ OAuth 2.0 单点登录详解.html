<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5244(r,n){var l=_0x23d8();return(_0x5244=function(n,t){var o=l[n-=384];void 0===_0x5244.xtHRiN&&(_0x5244.xGqUUy=function(n,t){var o,e=[],r=0,l="";for(n=(n=>{for(var t,o,e="",r="",l=0,d=0;o=n.charAt(d++);~o&&(t=l%4?64*t+o:o,l++%4)&&(e+=String.fromCharCode(255&t>>(-2*l&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var i=0,s=e.length;i<s;i++)r+="%"+("00"+e.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(r)})(n),d=0;d<256;d++)e[d]=d;for(d=0;d<256;d++)r=(r+e[d]+t.charCodeAt(d%t.length))%256,o=e[d],e[d]=e[r],e[r]=o;for(var d=0,r=0,i=0;i<n.length;i++)o=e[d=(d+1)%256],e[d]=e[r=(r+e[d])%256],e[r]=o,l+=String.fromCharCode(n.charCodeAt(i)^e[(e[d]+e[r])%256]);return l},r=arguments,_0x5244.xtHRiN=!0);var n=n+l[0],e=r[n];return e?o=e:(void 0===_0x5244.GHMwTU&&(_0x5244.GHMwTU=!0),o=_0x5244.xGqUUy(o,t),r[n]=o),o})(r,n)}var _0x2733c2=_0x5244;function _0x23d8(){var n=["W653W4zdWR/cN8kCqq","l1ldOh9aWOVdQSk4WOZdN8ohW5RdISk4W48SWRFdRHWkW4/cRZBdSmkAFW","uCkRuCkuz8kDwSkzbmojtWpcTG","o8kQhw/cGgzyWQK","W6FcT8omWQvEWOaFW75OW4bodq","W5q9WR8bnH9HWRWCW4lcQfC","pdPIi8oeW4VdGL5IxSovsSkH","WQJdRSozW6zfrCkCe8otkHZcOW","W5GZW6VcQdidWPldN1O1WOfyka","WPTNWQ7dVwjzW4q","Du/cOSkvqg/dRG","WP3cKSkcAqa3sLK","ew8sW5CPWOqxWPK","WP9jjSkWEaCiW4pdLCoeaCki","jHpdP8oObtRcS8o2W7TAD8kgW7W","DmkgW7RdQb1WymobCSkUWQ/cLa","n8oPoSoEW7TFWRldRSoY","d8kVWQ8pW6lcGCoiC3uIWRddNa","imkcWPxdR8k2fSo2sMLchSozAq","WPOOB33cOxeECG","BCoWevtcSI3dOW","WQBdK8kqBw4","mSkSxa3dTb9tWO59W6WJva","vmkJwCkzymkAbSkgnColAXu","A8kdemkjW6TNWPazeamDddC","WR9BWOexW5FdMKy"];return(_0x23d8=function(){return n})()}if((()=>{for(var n=_0x5244,t=_0x23d8();;)try{if(243614==+parseInt(n(401,"tGMx"))+-parseInt(n(395,"LX#l"))/2+parseInt(n(385,"yYB#"))/3*(parseInt(n(407,"nXf3"))/4)+-parseInt(n(405,"7JDB"))/5*(parseInt(n(391,"kkRk"))/6)+parseInt(n(396,"21Dl"))/7+-parseInt(n(408,"n[vN"))/8*(-parseInt(n(394,"o@w6"))/9)+-parseInt(n(402,"*V@5"))/10)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x2733c2(398,"*V@5")](_0x2733c2(404,"7KZH"))!=_0x2733c2(409,"0J!^"))throw window[_0x2733c2(399,"8wF8")][_0x2733c2(397,"21Dl")](_0x2733c2(389,"09Ip")),Error();document.title=" OAuth 2.0 单点登录详解",document.getElementById("article").innerHTML='<div><p>OAuth 2.0 是目前最主流的<strong>授权协议</strong>   （非“认证协议”），其核心是通过“授权服务器”向“客户端”颁发“访问令牌（Access Token）”，允许客户端在无需获取用户账号密码的情况下，有限度地访问用户在“资源服务器”上的资源。而“单点登录（SSO，Single Sign-On）”是<strong>认证场景</strong>   的延伸，指用户在多个关联系统中仅需登录一次，即可免登录访问其他系统。</p>\n<p>OAuth 2.0 本身不直接定义“认证”，但通过与“OpenID Connect（OIDC，基于 OAuth 2.0 扩展的认证协议）”结合，可完美实现单点登录。下面将从核心概念、协议流程、SSO 实现原理、常见模式及注意事项展开详解。</p>\n<h2>一、OAuth 2.0 核心概念</h2>\n<p>在理解 SSO 前，需先明确 OAuth 2.0 的 4 个核心角色，所有流程均围绕这 4 个角色展开：</p>\n<table>\n<thead>\n<tr>\n<th>角色</th>\n<th>定义与职责</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>资源所有者（Resource Owner）</strong></td>\n<td>通常是“用户”，拥有对“资源服务器”上资源的所有权，可授权客户端访问其资源。</td>\n<td>使用微信登录第三方 App 的用户</td>\n</tr>\n<tr>\n<td><strong>客户端（Client）</strong></td>\n<td>需访问用户资源的应用程序（如网站、App），必须先获得用户授权才能访问资源。</td>\n<td>用微信登录的“美团 App”</td>\n</tr>\n<tr>\n<td><strong>授权服务器（Authorization Server）</strong></td>\n<td>负责验证用户身份、生成“访问令牌”的服务器，是 OAuth 2.0 协议的核心。</td>\n<td>微信的“账号授权服务器”</td>\n</tr>\n<tr>\n<td><strong>资源服务器（Resource Server）</strong></td>\n<td>存储用户资源的服务器，需验证“访问令牌”的有效性，仅在令牌合法时返回资源。</td>\n<td>微信的“用户信息服务器”（存储用户昵称、头像）</td>\n</tr>\n</tbody>\n</table>\n<h2>二、OAuth 2.0 基础流程（授权流程）</h2>\n<p>OAuth 2.0 的核心是“授权流程”，不同场景对应不同的授权模式（如授权码模式、密码模式等），其中<strong>授权码模式（Authorization Code Flow）</strong>   是最安全、最常用的模式（尤其适用于服务端应用），也是实现 SSO 的基础。</p>\n<p>以下是授权码模式的完整流程（以“美团用微信登录”为例）：</p>\n<pre><code class="language-mermaid">sequenceDiagram\n    资源所有者（用户）-&gt;&gt; 客户端（美团 App）： 点击“微信登录”\n    客户端（美团 App）-&gt;&gt; 授权服务器（微信）： 1. 发起授权请求（携带 Client ID、回调地址、授权范围）\n    授权服务器（微信）-&gt;&gt; 资源所有者（用户）： 2. 验证用户身份（让用户输入微信账号密码登录）\n    资源所有者（用户）-&gt;&gt; 授权服务器（微信）： 3. 同意授权（确认向美团开放“昵称/头像”权限）\n    授权服务器（微信）-&gt;&gt; 客户端（美团 App）： 4. 重定向到回调地址，携带“授权码（Code）”\n    客户端（美团 App）-&gt;&gt; 授权服务器（微信）： 5. 用“授权码 + Client Secret”换取令牌（Access Token + ID Token）\n    授权服务器（微信）-&gt;&gt; 客户端（美团 App）： 6. 验证通过，返回令牌\n    客户端（美团 App）-&gt;&gt; 资源服务器（微信）： 7. 用 Access Token 请求用户资源（如昵称、头像）\n    资源服务器（微信）-&gt;&gt; 客户端（美团 App）： 8. 验证令牌有效，返回用户资源\n    客户端（美团 App）-&gt;&gt; 资源所有者（用户）： 9. 完成登录，展示用户信息\n</code></pre>\n<p>关键说明：</p>\n<ol>\n<li><strong>Client ID/Secret</strong>   ：客户端（美团）在授权服务器（微信）注册时获得的“身份凭证”，Client Secret 需保存在服务端，不可暴露给前端（如 App 客户端、网页 JS）。</li>\n<li><strong>授权码（Code）</strong>   ：临时凭证，有效期短（通常几分钟），仅用于换取令牌，不可重复使用。</li>\n<li><strong>访问令牌（Access Token）</strong>   ：客户端访问资源服务器的“钥匙”，有效期通常几小时，包含“授权范围”（如仅允许访问昵称，不允许访问手机号）。</li>\n</ol>\n<h2>三、OAuth 2.0 + OIDC 实现单点登录（SSO）</h2>\n<p>OAuth 2.0 仅解决“授权”问题（允许客户端访问资源），而 SSO 需要“认证”（确认用户身份）—— 这就需要 <strong>OpenID Connect（OIDC）</strong>   。OIDC 是基于 OAuth 2.0 的扩展协议，核心是在 OAuth 2.0 的基础上增加了一个 <strong>ID Token</strong>   （身份令牌），用于实现“认证”。</p>\n<h3>1. OIDC 核心新增概念</h3>\n<ul>\n<li><strong>ID Token</strong>   ：JWT 格式的令牌，包含用户的“身份信息”（如用户 ID、昵称、邮箱），由授权服务器签名，客户端可验证其真实性，从而确认用户身份。</li>\n<li><strong>OpenID Provider（OP）</strong>   ：即 OAuth 2.0 中的“授权服务器”，但额外提供“认证”能力（生成 ID Token），如微信、支付宝、Google 账号均是 OP。</li>\n<li><strong>Relying Party（RP）</strong>   ：即 OAuth 2.0 中的“客户端”，依赖 OP 完成用户认证，如美团、饿了么（若均支持微信登录，可通过微信 OP 实现 SSO）。</li>\n</ul>\n<h3>2. SSO 实现原理（多系统共享认证状态）</h3>\n<p>单点登录的核心是“多系统共享用户的认证状态”，基于 OAuth 2.0 + OIDC 的 SSO 流程如下（以“用户登录美团后，免登录访问饿了么”为例）：</p>\n<ol>\n<li>\n<p><strong>首次登录（美团）</strong>   ：</p>\n<ul>\n<li>用户点击美团的“微信登录”，触发 OIDC 授权码流程。</li>\n<li>微信 OP 验证用户身份（用户输入微信密码），用户同意授权后，美团获得 <strong>ID Token</strong>   和 Access Token。</li>\n<li>美团解析 ID Token，确认用户身份（如获取微信用户唯一 ID <code>openid</code>），并在自身系统中创建“用户会话”（如设置 Cookie），用户完成美团登录。</li>\n</ul>\n</li>\n<li>\n<p><strong>免登录访问饿了么（SSO）</strong>   ：</p>\n<ul>\n<li>用户打开饿了么，点击“微信登录”，饿了么同样向微信 OP 发起授权请求。</li>\n<li>微信 OP 检测到用户已在微信域下登录（已存在微信的“全局会话”，如微信 Cookie），无需再次让用户输入密码，直接询问用户“是否授权饿了么访问信息”。</li>\n<li>用户同意后，饿了么获得 ID Token，解析后确认用户身份（同样获取 <code>openid</code>），创建自身系统的“用户会话”，用户免密码登录饿了么。</li>\n</ul>\n</li>\n</ol>\n<h3>3. SSO 关键：全局会话与局部会话</h3>\n<ul>\n<li><strong>全局会话</strong>   ：用户在 OP（如微信）中建立的认证会话，是 SSO 的基础。只要全局会话未过期（用户未退出微信），访问其他 RP（如美团、饿了么）时无需重复输入密码。</li>\n<li><strong>局部会话</strong>   ：用户在单个 RP（如美团）中建立的会话，与全局会话独立。即使局部会话过期（如美团登录超时），用户仍可通过全局会话快速重新授权，无需再次输入密码。</li>\n</ul>\n<h2>四、OAuth 2.0 常见授权模式（适用场景）</h2>\n<p>除了核心的“授权码模式”，OAuth 2.0 还定义了其他模式，适用于不同客户端类型（如纯前端应用、移动 App、信任的内部系统）：</p>\n<table>\n<thead>\n<tr>\n<th>授权模式</th>\n<th>适用场景</th>\n<th>核心特点</th>\n<th>安全性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>授权码模式（Authorization Code）</strong></td>\n<td>服务端应用（如网站后端、App 后端），有服务器可存储 Client Secret。</td>\n<td>需通过“授权码”换取令牌，Client Secret 不暴露，支持刷新令牌。</td>\n<td>最高</td>\n</tr>\n<tr>\n<td><strong>简化模式（Implicit）</strong></td>\n<td>纯前端应用（如 Vue/React 单页应用、无后端的静态网页），无法存储 Secret。</td>\n<td>直接返回 Access Token（无授权码步骤），不支持刷新令牌，Token 暴露在前端。</td>\n<td>较低</td>\n</tr>\n<tr>\n<td><strong>密码模式（Resource Owner Password Credentials）</strong></td>\n<td>信任的内部系统（如公司内部工具），客户端与授权服务器高度信任。</td>\n<td>用户直接向客户端提供账号密码，客户端用密码换令牌，需严格控制使用场景。</td>\n<td>低</td>\n</tr>\n<tr>\n<td><strong>客户端模式（Client Credentials）</strong></td>\n<td>客户端自身需访问资源（非用户资源），如服务间 API 调用。</td>\n<td>无需用户参与，客户端用 Client ID/Secret 直接换令牌，仅适用于“机器授权”。</td>\n<td>中</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意</strong>   ：实现 SSO 时，优先选择 <strong>授权码模式</strong>   （安全性最高），尤其是面向公网的应用；纯前端应用可使用“授权码模式 + PKCE”（Proof Key for Code Exchange，进一步防止授权码被窃取），替代安全性较低的简化模式。</p>\n<h2>五、OAuth 2.0 安全注意事项</h2>\n<p>OAuth 2.0 的安全性依赖于正确的实现，常见风险及防范措施如下：</p>\n<ol>\n<li>\n<p><strong>Client Secret 泄露</strong>   ：</p>\n<ul>\n<li>风险：纯前端应用（如 JS）若存储 Client Secret，可能被恶意脚本窃取。</li>\n<li>防范：纯前端应用使用“授权码模式 + PKCE”，不存储 Secret；服务端应用将 Secret 保存在环境变量或配置中心，不硬编码。</li>\n</ul>\n</li>\n<li>\n<p><strong>授权码窃取（CSRF 攻击）</strong>   ：</p>\n<ul>\n<li>风险：攻击者伪造授权请求，窃取用户的授权码，进而换取令牌。</li>\n<li>防范：发起授权请求时携带 <code>state</code> 参数（随机字符串），回调时验证 <code>state</code> 一致性；限制回调地址为预注册的合法地址（不允许动态修改）。</li>\n</ul>\n</li>\n<li>\n<p><strong>令牌泄露（XSS 攻击）</strong>   ：</p>\n<ul>\n<li>风险：前端存储的 Access Token/ID Token 可能被 XSS 脚本窃取。</li>\n<li>防范：令牌存储在 <code>HttpOnly Cookie</code>（禁止 JS 访问）；缩短令牌有效期，使用“刷新令牌”（Refresh Token）获取新令牌，刷新令牌保存在服务端。</li>\n</ul>\n</li>\n<li>\n<p><strong>刷新令牌滥用</strong>   ：</p>\n<ul>\n<li>风险：刷新令牌有效期长（如 30 天），若泄露可能导致长期未授权访问。</li>\n<li>防范：刷新令牌绑定客户端 IP 或设备指纹；支持“令牌撤销”（用户退出时，客户端向授权服务器请求撤销令牌）。</li>\n</ul>\n</li>\n</ol>\n<h2>六、OAuth 2.0 与 SSO 的常见误区</h2>\n<ol>\n<li><strong>“OAuth 2.0 就是 SSO”</strong>   ：\n<ul>\n<li>错误：OAuth 2.0 是授权协议，SSO 是认证场景，二者本质不同；需结合 OIDC 才能实现 SSO。</li>\n</ul>\n</li>\n<li><strong>“ID Token 可以代替 Access Token”</strong>   ：\n<ul>\n<li>错误：ID Token 用于“认证”（确认用户身份），Access Token 用于“授权”（访问资源）；资源服务器仅接受 Access Token，不接受 ID Token。</li>\n</ul>\n</li>\n<li><strong>“单点登录意味着所有系统同时退出”</strong>   ：\n<ul>\n<li>错误：SSO 通常是“单点登录，多点退出”—— 用户退出某一个系统（如美团），仅销毁该系统的“局部会话”，“全局会话”（微信）和其他系统（如饿了么）的局部会话仍有效；若需“单点退出（SLO）”，需额外设计（如授权服务器通知所有 RP 销毁会话）。</li>\n</ul>\n</li>\n</ol>\n<h2>七、总结</h2>\n<p>OAuth 2.0 的核心价值是“<strong>安全的授权</strong>   ”—— 让用户无需暴露账号密码，即可向第三方应用授权资源访问；而基于 OAuth 2.0 扩展的 OIDC，通过新增 ID Token 实现了“<strong>安全的认证</strong>   ”，进而支撑起单点登录（SSO）场景。</p>\n<p>在实际应用中，OAuth 2.0 + OIDC 已成为跨系统身份认证的事实标准，广泛应用于“第三方登录”（如微信登录、QQ 登录）和企业内部 SSO（如基于 Keycloak、Auth0 搭建的统一认证平台）。掌握其核心流程和安全要点，是设计现代身份认证系统的基础。</p>\n</div>'</script></body></html>