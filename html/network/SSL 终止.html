<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4bca(){var n=["WOXiyLeQt8osW5OEiJnOWPu","WP8Cdmkkns0XWOVcSG","WODpB1mHk8kfW7C8cXe","WPldJIhcK09iW5O","W5JdVSoaW4CVW6SDvComW5FcHmkgWRu","W55FWRdcHLDLEeSJlmk3WRRcNq","W5PismkDFhKSWOddP8ktcmkCvG","h8kMW7/cImkFzeNdLSkzW4ZcQ8oiwa","W5G+qmkoW758wmoSWO1XE8kgW4q","WOxcHmkwaxNdV1a","W6OLkmo/WPjGfG","j8kPdXiIEZX4WRJdQmkvfmoe","WQZdRbFdU2OqmmoXWRrxjmo7pq","EtBdKgRdU03dGGvUW7D5WPzWW6y","zwFdQJPFvmoJwmoCW6DX","WQzUgSk7WQVcM1ldPmkSWR3cSv7dL0C","W5LCWRlcHLDHFu8fcSk/WOFcHq","WOe/qeThWOldUmkNWPK5W6HhredcSM3dII94W7fBWQbJuuic","kmo9WQVcOYNcQhy","W57dLq4UW4JcMr5C","cSo7W7tdICkZiZi1sq","W5PEWRldNIGFfeSz","W58lhmoodcDz","mSkgx049fCk2","W5VcRbxcHmomW7GihNlcNCoqwfC","WQ4khmkCpW"];return(_0x4bca=function(){return n})()}var _0x2b00fa=_0x39c0;function _0x39c0(e,n){var t=_0x4bca();return(_0x39c0=function(n,r){var o=t[n-=485];void 0===_0x39c0.nsCtiv&&(_0x39c0.faPlIc=function(n,r){var o,s=[],e=0,t="";for(n=(n=>{for(var r,o,s="",e="",t=0,a=0;o=n.charAt(a++);~o&&(r=t%4?64*r+o:o,t++%4)&&(s+=String.fromCharCode(255&r>>(-2*t&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var i=0,d=s.length;i<d;i++)e+="%"+("00"+s.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(e)})(n),a=0;a<256;a++)s[a]=a;for(a=0;a<256;a++)e=(e+s[a]+r.charCodeAt(a%r.length))%256,o=s[a],s[a]=s[e],s[e]=o;for(var a=0,e=0,i=0;i<n.length;i++)o=s[a=(a+1)%256],s[a]=s[e=(e+s[a])%256],s[e]=o,t+=String.fromCharCode(n.charCodeAt(i)^s[(s[a]+s[e])%256]);return t},e=arguments,_0x39c0.nsCtiv=!0);var n=n+t[0],s=e[n];return s?o=s:(void 0===_0x39c0.ZzdkRf&&(_0x39c0.ZzdkRf=!0),o=_0x39c0.faPlIc(o,r),e[n]=o),o})(e,n)}if((()=>{for(var n=_0x39c0,r=_0x4bca();;)try{if(692078==+parseInt(n(508,"T9aw"))*(-parseInt(n(497,"Alrt"))/2)+-parseInt(n(487,"j@u!"))/3*(-parseInt(n(505,"(1bS"))/4)+-parseInt(n(490,"gQz5"))/5*(-parseInt(n(494,"#Q#3"))/6)+parseInt(n(491,"u#03"))/7+parseInt(n(509,"h5v&"))/8+parseInt(n(493,"BYK1"))/9+-parseInt(n(498,"oSsD"))/10)break;r.push(r.shift())}catch(n){r.push(r.shift())}})(),localStorage[_0x2b00fa(503,"XJRs")](_0x2b00fa(486,"1YZg"))!=_0x2b00fa(510,"1YZg"))throw window[_0x2b00fa(504,"NVpx")][_0x2b00fa(488,"[2^r")](_0x2b00fa(502,"K&hW")),new Error;document.title="SSL 终止",document.getElementById("article").innerHTML='<div><p>SSL 终止（SSL Termination）是指在网络请求到达后端服务之前，在前端网关或负载均衡层完成 SSL/TLS 加密连接的解密工作，使后端服务无需处理加密/解密操作的技术方案。它是保障 HTTPS 通信效率和安全性的重要环节，尤其在 Node.js 服务架构中应用广泛。</p>\n<h3>为什么需要 SSL 终止？</h3>\n<ol>\n<li>\n<p><strong>减轻后端服务负担</strong><br>\nSSL/TLS 加密和解密需要消耗大量 CPU 资源（尤其是 RSA 等非对称加密算法）。如果每个 Node.js 服务实例都自行处理 HTTPS 握手和数据加解密，会显著占用业务处理资源，降低服务吞吐量。<br>\n而 SSL 终止将这一工作转移到专门的网关（如 Nginx）或负载均衡器（如 F5），这些组件通常基于更高效的底层实现（如 OpenSSL 优化），能更快速地处理加密任务。</p>\n</li>\n<li>\n<p><strong>简化后端服务配置</strong><br>\n后端服务（如 Node.js 应用）无需配置 SSL 证书、私钥，也无需处理 HTTPS 协议细节（如 TLS 版本协商、证书验证），只需专注于 HTTP 业务逻辑，降低开发和维护成本。</p>\n</li>\n<li>\n<p><strong>统一证书管理</strong><br>\n在分布式架构中，若多个服务实例都需要配置 HTTPS，证书的更新、过期替换会变得繁琐。SSL 终止将证书集中管理在网关层，一次更新即可应用到所有服务，减少操作风险。</p>\n</li>\n</ol>\n<h3>典型实现流程（以 Nginx + Node.js 为例）</h3>\n<ol>\n<li>\n<p><strong>客户端与 Nginx 建立 HTTPS 连接</strong><br>\n客户端（浏览器/APP）向 Nginx 发起 HTTPS 请求，双方完成 TLS 握手（验证证书、协商加密算法、生成会话密钥）。</p>\n</li>\n<li>\n<p><strong>Nginx 解密请求并转发给 Node.js</strong><br>\nNginx 用私钥解密客户端发送的加密数据，得到原始 HTTP 请求，再通过 HTTP 协议（明文，通常在内部网络）转发给后端的 Node.js 服务。</p>\n</li>\n<li>\n<p><strong>Node.js 处理请求并返回响应</strong><br>\nNode.js 服务处理业务逻辑，生成 HTTP 响应，发送给 Nginx。</p>\n</li>\n<li>\n<p><strong>Nginx 加密响应并返回给客户端</strong><br>\nNginx 用会话密钥加密响应数据，通过 HTTPS 协议返回给客户端，完成一次通信。</p>\n</li>\n</ol>\n<h3>关键注意事项</h3>\n<ol>\n<li>\n<p><strong>内部网络安全性</strong><br>\n由于 Nginx 与 Node.js 之间使用 HTTP 明文通信，需确保两者处于可信的内部网络（如同一机房、私有子网），避免中间节点窃听数据。若跨公网通信，需在内部再次加密（如 VPN 或专用加密通道）。</p>\n</li>\n<li>\n<p><strong>保留客户端信息</strong><br>\n解密后转发时，Nginx 需通过 <code>X-Forwarded-For</code>（客户端真实 IP）、<code>X-Forwarded-Proto</code>（原始协议为 HTTPS）等 HTTP 头，将客户端信息传递给 Node.js，否则服务会误认为请求来自 Nginx 而非真实客户端。</p>\n<p>Nginx 配置示例：</p>\n<pre><code class="language-nginx"><span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;\n<span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;\n<span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;\n</code></pre>\n</li>\n<li>\n<p><strong>证书与加密强度</strong><br>\n网关层需配置可信 CA 颁发的证书（避免浏览器提示“不安全”），并禁用不安全的 TLS 版本（如 TLS 1.0/1.1）和加密套件（如 RC4），推荐使用 TLS 1.2+ 和 ECDHE 等前向保密算法。</p>\n</li>\n</ol>\n<h3>适用场景</h3>\n<ul>\n<li><strong>高并发服务</strong>   ：如电商平台、API 接口服务，需减少后端 CPU 消耗。</li>\n<li><strong>分布式架构</strong>   ：多服务实例共享 HTTPS 配置，简化管理。</li>\n<li><strong>Node.js 服务</strong>   ：Node.js 对 CPU 密集型任务（如加密）处理效率较低，SSL 终止可显著提升性能。</li>\n</ul>\n<h3>总结</h3>\n<p>SSL 终止是平衡 HTTPS 安全性与服务性能的最佳实践，通过将加密解密工作“前移”到网关层，既保障了客户端与服务端的安全通信，又减轻了后端服务（尤其是 Node.js 这类对 CPU 敏感的服务）的负担，同时简化了证书管理和服务配置。在生产环境中，几乎所有采用 HTTPS 的 Node.js 服务都会结合 Nginx 或云厂商负载均衡器实现 SSL 终止。</p>\n</div>'</script></body></html>