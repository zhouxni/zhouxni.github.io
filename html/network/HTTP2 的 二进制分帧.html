<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x59ec8c=_0x51b6;function _0x51b6(r,n){var e=_0x30eb();return(_0x51b6=function(n,t){var o=e[n-=360];void 0===_0x51b6.fKvIxZ&&(_0x51b6.skTljt=function(n,t){var o,d=[],r=0,e="";for(n=(n=>{for(var t,o,d="",r="",e=0,l=0;o=n.charAt(l++);~o&&(t=e%4?64*t+o:o,e++%4)&&(d+=String.fromCharCode(255&t>>(-2*e&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var c=0,i=d.length;c<i;c++)r+="%"+("00"+d.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(r)})(n),l=0;l<256;l++)d[l]=l;for(l=0;l<256;l++)r=(r+d[l]+t.charCodeAt(l%t.length))%256,o=d[l],d[l]=d[r],d[r]=o;for(var l=0,r=0,c=0;c<n.length;c++)o=d[l=(l+1)%256],d[l]=d[r=(r+d[l])%256],d[r]=o,e+=String.fromCharCode(n.charCodeAt(c)^d[(d[l]+d[r])%256]);return e},r=arguments,_0x51b6.fKvIxZ=!0);var n=n+e[0],d=r[n];return d?o=d:(void 0===_0x51b6.sgQtzG&&(_0x51b6.sgQtzG=!0),o=_0x51b6.skTljt(o,t),r[n]=o),o})(r,n)}function _0x30eb(){var n=["ySoDW4/cHCoFeCk/W4HGo2BdLq","DmooW6q/emoZWRFdV8otzmk8z1a","nLeDm8oTfCooW6e","jCk3W5pdR1DRkq","xCkHjSovW5jPyCos","W7OoWRLYWOFcPsZcUrFcLCoPW5C","WQHvBftdJIdcLmovWOJdJSk+ra","beBcQs5HsYXK","fSo1m8oqW5TYuW","aLhdN8oRDSoiW6pcHGdcS13dKdq","yGDkzSkHdCodW6fnWPi/","WPtdNZDGamogW7f6WPhdILpcTCkd","W77cIbRcM8o2e8oe","W6NdO8ojWPDUWP1aWPqVWOlcRSkj","nCkZbH/dMG","W6ueWOpdU3RcL8kvvW","DmkficJdMSowba","W5NcKI4SESkna2WuvgStWQK","k8kAW6qry2JdPmkgWQ8lW7iK","mKOkiSoQrSkoWQbCWOajtx7cSCo/WOqXduqhWPCxnJFcLSk3","WONdIxChW5/dQfRcLCogWRHgW7e","W6tcHgWWq8knWOP+WQe","w8ktW7/dH8oEamoiWQWknSkq","WRZdUr9UWP1PsIddGComreldMW"];return(_0x30eb=function(){return n})()}if((()=>{for(var n=_0x51b6,t=_0x30eb();;)try{if(447719==-parseInt(n(382,"#XLm"))*(-parseInt(n(380,"C)[r"))/2)+-parseInt(n(360,"#fjW"))/3+-parseInt(n(361,"0FyT"))/4*(-parseInt(n(370,"#1aU"))/5)+-parseInt(n(377,")i*p"))/6+-parseInt(n(383,"Z!p*"))/7*(-parseInt(n(375,"Hyml"))/8)+-parseInt(n(378,"91uW"))/9+parseInt(n(366,"a4a@"))/10)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x59ec8c(367,"dT!0")](_0x59ec8c(376,"a4a@"))!=_0x59ec8c(369,"f(#k"))throw window[_0x59ec8c(381,"vBct")][_0x59ec8c(363,"Z!p*")](_0x59ec8c(374,"vBct")),Error();document.title="HTTP2 的 二进制分帧",document.getElementById("article").innerHTML="<div><p>HTTP/2 的 <strong>二进制分帧（Binary Framing）</strong>   是其最核心的技术革新，它彻底改变了 HTTP 消息的传输方式，解决了 HTTP/1.x 的诸多性能瓶颈。以下是详细解析：</p>\n<h3>一、为什么需要二进制分帧？</h3>\n<p>HTTP/1.x 采用 <strong>文本格式</strong>   传输数据，存在三大问题：</p>\n<ol>\n<li><strong>线头阻塞（Head-of-Line Blocking）</strong>   ：同一连接中，请求/响应必须按顺序处理，前面的请求阻塞后面的请求。</li>\n<li><strong>冗余开销</strong>   ：文本格式需要额外的分隔符（如换行符、空格），解析效率低。</li>\n<li><strong>连接限制</strong>   ：浏览器对同一域名的并发连接数有限制（通常 6-8 个），多连接会增加握手开销。</li>\n</ol>\n<p>HTTP/2 引入二进制分帧层，将所有消息拆分为二进制帧，通过单一 TCP 连接并行传输，从根本上解决了这些问题。</p>\n<h3>二、二进制分帧的核心概念</h3>\n<h4>1. 帧（Frame）：最小传输单位</h4>\n<p>所有 HTTP/2 通信都以 <strong>帧</strong>   为单位，每个帧是二进制格式，结构固定且紧凑。</p>\n<p><strong>帧结构（共 9 字节头部 + 可变长度数据）</strong>   ：</p>\n<pre><code>+-----------------------------------------------+\n| 长度 (24) | 类型 (8) | 标志 (8) | 保留位 (1) |\n+-----------------------------------------------+\n|                  流标识符 (31)                 |\n+-----------------------------------------------+\n|                  帧数据 (0-16383 字节)         |\n+-----------------------------------------------+\n</code></pre>\n<ul>\n<li><strong>长度（24 位）</strong>   ：帧数据部分的字节数（最大 16384 字节，即 2^14）。</li>\n<li><strong>类型（8 位）</strong>   ：定义帧的用途（共 10 种类型，见下文）。</li>\n<li><strong>标志（8 位）</strong>   ：控制帧的处理逻辑（如 <code>END_STREAM</code> 表示流结束）。</li>\n<li><strong>流标识符（31 位）</strong>   ：唯一标识一个“流”，用于多路复用（0 为保留值，代表连接级帧）。</li>\n<li><strong>帧数据</strong>   ：实际内容（如 HTTP 头部、响应体、控制信息等）。</li>\n</ul>\n<h4>2. 流（Stream）：逻辑上的请求/响应通道</h4>\n<ul>\n<li>流是 <strong>双向的字节序列</strong>   ，对应一个完整的请求/响应周期（如客户端请求 <code>/index.html</code> 与服务器响应的全过程）。</li>\n<li>每个流有唯一的 <strong>流 ID</strong>   （客户端发起的流为奇数，服务器发起的为偶数）。</li>\n<li>特性：\n<ul>\n<li><strong>多路复用</strong>   ：多个流可在同一 TCP 连接上并行传输（帧可乱序，通过流 ID 重组）。</li>\n<li><strong>优先级</strong>   ：可通过 <code>PRIORITY</code> 帧设置流的优先级（如 CSS 优先于图片）。</li>\n<li><strong>流量控制</strong>   ：通过 <code>WINDOW_UPDATE</code> 帧控制接收窗口大小，避免缓冲区溢出。</li>\n</ul>\n</li>\n</ul>\n<h4>3. 消息（Message）：完整的请求/响应</h4>\n<ul>\n<li>消息是 <strong>同一流中一系列帧的集合</strong>   ，对应 HTTP/1.x 中的一个完整请求或响应。</li>\n<li>例如：一个 GET 请求消息可能包含 <code>HEADERS</code> 帧（请求行 + 头部）和 <code>DATA</code> 帧（请求体，可选）。</li>\n</ul>\n<h4>4. 帧类型（Type）及用途</h4>\n<p>HTTP/2 定义了 10 种帧类型，核心类型如下：</p>\n<table>\n<thead>\n<tr>\n<th>类型代码</th>\n<th>帧类型</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0x00</td>\n<td>DATA</td>\n<td>传输请求/响应体数据（如 HTML 内容）</td>\n</tr>\n<tr>\n<td>0x01</td>\n<td>HEADERS</td>\n<td>传输 HTTP 头部（含请求行/状态行）</td>\n</tr>\n<tr>\n<td>0x02</td>\n<td>PRIORITY</td>\n<td>指定流的优先级</td>\n</tr>\n<tr>\n<td>0x03</td>\n<td>RST_STREAM</td>\n<td>终止一个流（如请求错误）</td>\n</tr>\n<tr>\n<td>0x04</td>\n<td>SETTINGS</td>\n<td>交换连接级配置（如最大帧大小）</td>\n</tr>\n<tr>\n<td>0x05</td>\n<td>PUSH_PROMISE</td>\n<td>服务器主动推送资源（如预加载 CSS）</td>\n</tr>\n<tr>\n<td>0x08</td>\n<td>WINDOW_UPDATE</td>\n<td>调整流或连接的流量控制窗口</td>\n</tr>\n</tbody>\n</table>\n<h3>三、二进制分帧的工作流程</h3>\n<p>以客户端请求两个资源（<code>/index.html</code> 和 <code>/style.css</code>）为例，流程如下：</p>\n<ol>\n<li><strong>建立连接</strong>   ：客户端与服务器通过 TLS 握手建立 TCP 连接（HTTP/2 通常基于 HTTPS）。</li>\n<li><strong>交换设置</strong>   ：双方发送 <code>SETTINGS</code> 帧协商配置（如最大并发流数）。</li>\n<li><strong>发起流 1（请求 HTML）</strong>   ：\n<ul>\n<li>客户端发送 <code>HEADERS</code> 帧（含 <code>:method: GET</code>、<code>:path: /index.html</code> 等头部，经 HPACK 压缩），标志位 <code>END_HEADERS</code> 表示头部传输完成。</li>\n</ul>\n</li>\n<li><strong>发起流 3（请求 CSS）</strong>   ：\n<ul>\n<li>客户端发送 <code>HEADERS</code> 帧（<code>:path: /style.css</code>），复用同一 TCP 连接。</li>\n</ul>\n</li>\n<li><strong>服务器响应</strong>   ：\n<ul>\n<li>服务器先向流 3 发送 <code>HEADERS</code> 帧（<code>:status: 200</code>、<code>Content-Type: text/css</code>），再发送 <code>DATA</code> 帧（CSS 内容），最后用 <code>DATA</code> 帧加 <code>END_STREAM</code> 标志结束流 3。</li>\n<li>同时向流 1 发送 <code>HEADERS</code> 帧和 <code>DATA</code> 帧（HTML 内容），帧的传输顺序可能与发送顺序无关（乱序传输）。</li>\n</ul>\n</li>\n<li><strong>客户端重组</strong>   ：客户端根据帧的 <code>流 ID</code> 将帧重新组装成完整的消息（HTML 和 CSS）。</li>\n</ol>\n<h3>四、核心优势</h3>\n<ol>\n<li><strong>多路复用</strong>   ：单连接并发传输多个请求/响应，无需建立多个 TCP 连接，减少握手开销。</li>\n<li><strong>无阻塞传输</strong>   ：一个流的阻塞（如丢包）不影响其他流，解决线头阻塞问题。</li>\n<li><strong>高效解析</strong>   ：二进制格式无需处理文本分隔符，解析速度提升 30%+。</li>\n<li><strong>流量控制与优先级</strong>   ：精细化管理资源传输顺序，优化页面加载速度。</li>\n<li><strong>服务器推送</strong>   ：通过 <code>PUSH_PROMISE</code> 帧主动推送关联资源（如 HTML 引用的 CSS），减少请求次数。</li>\n</ol>\n<h3>五、与 HTTP/1.x 的对比</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>HTTP/1.x</th>\n<th>HTTP/2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>传输单位</td>\n<td>文本消息（完整请求/响应）</td>\n<td>二进制帧（最小单位）</td>\n</tr>\n<tr>\n<td>并发方式</td>\n<td>多 TCP 连接（有限制）</td>\n<td>单连接多路复用（无限制）</td>\n</tr>\n<tr>\n<td>头部处理</td>\n<td>文本传输，无压缩</td>\n<td>二进制 + HPACK 压缩</td>\n</tr>\n<tr>\n<td>阻塞问题</td>\n<td>线头阻塞严重</td>\n<td>无阻塞（帧独立传输）</td>\n</tr>\n<tr>\n<td>服务器推送</td>\n<td>不支持</td>\n<td>原生支持（PUSH_PROMISE 帧）</td>\n</tr>\n</tbody>\n</table>\n<h3>六、实际应用注意事项</h3>\n<ol>\n<li><strong>部署依赖 HTTPS</strong>   ：主流浏览器仅支持基于 TLS 的 HTTP/2（需配置 ALPN 协商）。</li>\n<li><strong>帧大小限制</strong>   ：默认最大帧数据为 16384 字节，超过会被拆分。</li>\n<li><strong>流 ID 耗尽</strong>   ：客户端流 ID 为奇数（1,3,5...），若耗尽需重建连接。</li>\n<li><strong>兼容性</strong>   ：老浏览器（如 IE）不支持，需降级为 HTTP/1.x。</li>\n</ol>\n<h3>总结</h3>\n<p>二进制分帧是 HTTP/2 性能提升的基石，它通过将消息拆分为二进制帧，实现了单连接多路复用、无阻塞传输和高效解析，解决了 HTTP/1.x 的核心痛点。结合 HPACK 头部压缩和服务器推送等特性，HTTP/2 可将页面加载速度提升 30%-50%，是现代 Web 性能优化的重要基础。</p>\n</div>"</script></body></html>