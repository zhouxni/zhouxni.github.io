<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5803ed=_0x49e6;function _0x49e6(e,n){var c=_0x49af();return(_0x49e6=function(n,o){var r=c[n-=473];void 0===_0x49e6.KDbObw&&(_0x49e6.WCOylP=function(n,o){var r,t=[],e=0,c="";for(n=(n=>{for(var o,r,t="",e="",c=0,d=0;r=n.charAt(d++);~r&&(o=c%4?64*o+r:r,c++%4)&&(t+=String.fromCharCode(255&o>>(-2*c&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var W=0,i=t.length;W<i;W++)e+="%"+("00"+t.charCodeAt(W).toString(16)).slice(-2);return decodeURIComponent(e)})(n),d=0;d<256;d++)t[d]=d;for(d=0;d<256;d++)e=(e+t[d]+o.charCodeAt(d%o.length))%256,r=t[d],t[d]=t[e],t[e]=r;for(var d=0,e=0,W=0;W<n.length;W++)r=t[d=(d+1)%256],t[d]=t[e=(e+t[d])%256],t[e]=r,c+=String.fromCharCode(n.charCodeAt(W)^t[(t[d]+t[e])%256]);return c},e=arguments,_0x49e6.KDbObw=!0);var n=n+c[0],t=e[n];return t?r=t:(void 0===_0x49e6.XnnfYp&&(_0x49e6.XnnfYp=!0),r=_0x49e6.WCOylP(r,o),e[n]=r),r})(e,n)}if((()=>{for(var n=_0x49e6,o=_0x49af();;)try{if(133501==+parseInt(n(486,"8X58"))*(parseInt(n(476,"mLiL"))/2)+-parseInt(n(493,"AG[["))/3+parseInt(n(477,"4ww)"))/4+parseInt(n(479,"GwML"))/5+-parseInt(n(488,"m6lm"))/6+-parseInt(n(481,"n9y&"))/7*(parseInt(n(489,"m6lm"))/8)+parseInt(n(480,"xwVH"))/9)break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x5803ed(495,"TtSf")](_0x5803ed(473,"8u5V"))!=_0x5803ed(496,"TtSf"))throw window[_0x5803ed(483,"a[mj")][_0x5803ed(492,"QuJ*")](_0x5803ed(484,"l&Yc")),Error();function _0x49af(){var n=["w8oBrmk9W5lcJddcRsLrghxcMW","WP8ifbNcKHFdOmoUkNO7","WPnvqCoUW7NcPCkaWPbCdrxdQG","WPpcVL0dyGhcImoi","W43cIM/cLZaxz8ogF1JdV8o8WPLWdX7cRKbDh8k/a8ovWR3cTCkE","WQxcVSooaCkexCoHyuhcVSoHWRXS","WRf9Bb1aWQZdJCkifG/cJq","DcZcQMpcK8kJD8kAEa","WQlcVCola8kexCkCsh7cTmojWOC","WQxcVmolySobk8kBA3e","W43cTMGOErVcPG","W4RdGSk+W6jdW4Xzx8klW59IuW","hcjEW4ZdHsDZ","W5GFnarqWRRcIGPCWQLaAW","W4JdOmkyrH8YACk3WRiAWQa","W5vlW4ddRmk5xmo2","W4jBW4FdLSk0","gCkCW5bEimkrWOfitq","n8kBxCouaCodftdcRSonW4K","FsZcPaBdNSorCmkdBgn+eW","nmoxW7JcHmkNrmok","W7xcTJy8W6v1yW41bSkxWRS","w34DWPNcLhfYB8oNW7HLiW","FCkaW4jaWRrYWQBdJmkAt8o6WQy"];return(_0x49af=function(){return n})()}document.title="TCP 协议中的 2MSL",document.getElementById("article").innerHTML="<div><p>TCP 协议中的 <strong>2MSL（Twice Maximum Segment Lifetime）</strong>   是连接终止阶段的一个重要机制，主要与 <strong>TIME_WAIT</strong>   状态相关。以下是详细解释：</p>\n<hr>\n<h3><strong>1. MSL 是什么？</strong></h3>\n<ul>\n<li><strong>MSL（Maximum Segment Lifetime）</strong>  ：TCP 报文段在网络中的最大存活时间，超过该时间后报文会被丢弃。不同系统实现不同，通常为 <strong>30秒~2分钟</strong>  （例如 Linux 默认 60秒）。</li>\n<li><strong>2MSL</strong>  ：即两倍的 MSL，是 TCP 连接在 <code>TIME_WAIT</code> 状态的持续时间。</li>\n</ul>\n<hr>\n<h3><strong>2. 为什么需要 TIME_WAIT 和 2MSL？</strong></h3>\n<p>当 TCP 连接主动关闭（主动发起 FIN 的一端）时，会进入 <code>TIME_WAIT</code> 状态并等待 <strong>2MSL</strong>   时间，主要解决以下问题：</p>\n<h4><strong>（1）确保最后一个 ACK 到达对端</strong></h4>\n<ul>\n<li>如果主动关闭方发送的最后一个 <code>ACK</code> 丢失，被动关闭方会重传 <code>FIN</code>。</li>\n<li>主动关闭方在 <code>TIME_WAIT</code> 期间可以重新响应这个 <code>FIN</code>，避免连接异常。</li>\n</ul>\n<h4><strong>（2）避免旧连接的重复报文干扰新连接</strong></h4>\n<ul>\n<li>网络中可能残留旧连接的延迟报文（因路由问题等）。</li>\n<li>等待 2MSL 可以确保这些报文失效，避免被新建立的同名连接（相同四元组）误接收。</li>\n</ul>\n<hr>\n<h3><strong>3. 2MSL 的具体影响</strong></h3>\n<ul>\n<li><strong>持续时间</strong>  ：通常为 <strong>1~4分钟</strong>  （例如 MSL=30秒时，2MSL=60秒）。</li>\n<li><strong>资源占用</strong>  ：连接在 <code>TIME_WAIT</code> 期间会占用端口和内存，高并发场景下可能导致端口耗尽（可通过 <code>SO_REUSEADDR</code> 选项复用端口）。</li>\n</ul>\n<hr>\n<h3><strong>4. 相关 RFC 规范</strong></h3>\n<ul>\n<li><strong>RFC 793</strong>  ：定义 MSL 为 2 分钟（但允许实现调整）。</li>\n<li><strong>RFC 1337</strong>  ：强调 <code>TIME_WAIT</code> 的重要性，避免因跳过它导致数据错误。</li>\n</ul>\n<hr>\n<h3><strong>5. 实际应用建议</strong></h3>\n<ul>\n<li><strong>服务器优化</strong>  ：对于需要频繁重启的服务，可通过设置 <code>SO_REUSEADDR</code> 快速复用 <code>TIME_WAIT</code> 状态的端口。</li>\n<li><strong>长连接</strong>  ：减少短连接可降低 <code>TIME_WAIT</code> 数量。</li>\n</ul>\n<hr>\n<h3><strong>总结</strong></h3>\n<p>2MSL 是 TCP 协议设计中的一种容错机制，通过 <code>TIME_WAIT</code> 状态确保连接可靠关闭，尽管会短暂占用资源，但对数据完整性至关重要。</p>\n</div>"</script></body></html>