<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x58c8d1=_0x4348;function _0x4348(e,n){var s=_0x2692();return(_0x4348=function(n,o){var r=s[n-=439];void 0===_0x4348.xkWlAw&&(_0x4348.CwvdiJ=function(n,o){var r,t=[],e=0,s="";for(n=(n=>{for(var o,r,t="",e="",s=0,i=0;r=n.charAt(i++);~r&&(o=s%4?64*o+r:r,s++%4)&&(t+=String.fromCharCode(255&o>>(-2*s&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var l=0,g=t.length;l<g;l++)e+="%"+("00"+t.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(e)})(n),i=0;i<256;i++)t[i]=i;for(i=0;i<256;i++)e=(e+t[i]+o.charCodeAt(i%o.length))%256,r=t[i],t[i]=t[e],t[e]=r;for(var i=0,e=0,l=0;l<n.length;l++)r=t[i=(i+1)%256],t[i]=t[e=(e+t[i])%256],t[e]=r,s+=String.fromCharCode(n.charCodeAt(l)^t[(t[i]+t[e])%256]);return s},e=arguments,_0x4348.xkWlAw=!0);var n=n+s[0],t=e[n];return t?r=t:(void 0===_0x4348.mpikfP&&(_0x4348.mpikfP=!0),r=_0x4348.CwvdiJ(r,o),e[n]=r),r})(e,n)}function _0x2692(){var n=["WR4OWQhcGgGzAa","W4SZqmk6eSoNua","eKScywlcL8ksWRFcQmovxxy","EcuECSkKW6RcLdVcQ2VdUMJcOW","WOZdTmoLW6ul","p1/cQe/cTCoTb8kUW7TqCr3cQM0","nCkSWQW3kCkZo8k6ENjGW7i","a1VdMqf8WQvCWP42AmkjmW","W6dcHmkAx09/AJO","W751W6BdNtXdoZTtpmoCCuS","W41yW6ddJHKYuSo4lXOUW7S","e0yhzMlcNSowWPpcPmo9sLpcLW","WOddImoaWPpcR8o2tmowW4m","bIBcRCkdWQOlW4Xjz8oTrmoWWRa","jCo2ASkZW5NdUvhdNKRdNCoKWOO","eKKdyMBcL8kWWOxcNSoRD3u","dCkJW6nMWRFcUmoqdeRdR8kIW6fUWPO","W6VdVSkdWRZcKvhcSG","o8oTumo7WP9BW7rbWQ/dG8kjW7i","W7tcN8kwW4ldQCk1CSo+W7CMrSoc","y8kPl3zZWOBcTq","bCoRW7PHW6zxowRcJCkAkmorW4KBetRcJSoJgxOVWRfSWQnhW7W"];return(_0x2692=function(){return n})()}if((()=>{for(var n=_0x4348,o=_0x2692();;)try{if(272382==+parseInt(n(444,"qnmN"))+-parseInt(n(440,"F#mf"))/2+-parseInt(n(455,"xA)S"))/3+-parseInt(n(449,"Yywp"))/4*(parseInt(n(439,"tZnm"))/5)+-parseInt(n(458,"GuHI"))/6+-parseInt(n(459,"2Dy]"))/7+parseInt(n(442,"hrKb"))/8)break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x58c8d1(446,"fkJ&")](_0x58c8d1(460,"Jh[W"))!=_0x58c8d1(452,"w3w^"))throw window[_0x58c8d1(456,"pRVb")][_0x58c8d1(448,"xE4!")](_0x58c8d1(447,"g!qx")),Error();document.title="普通 Token 的缺点",document.getElementById("article").innerHTML="<div><p>普通 Token（通常指简单的随机字符串令牌，如传统 Session ID 或自定义令牌）在身份验证和授权场景中虽然使用广泛，但相比 JWT 等结构化令牌，存在诸多缺点，主要体现在以下几个方面：</p>\n<h3><strong>1. 依赖服务端存储，扩展性差</strong></h3>\n<ul>\n<li><strong>必须存储状态</strong>   ：普通 Token 本身不包含用户信息，仅作为服务端存储的“指针”（如关联用户 ID），服务端需在数据库、缓存（如 Redis）或内存中维护 Token 与用户数据的映射关系。</li>\n<li><strong>分布式系统瓶颈</strong>   ：在分布式集群或微服务架构中，需确保所有服务节点能访问共享的 Token 存储（如 Redis 集群），增加了部署复杂度和网络开销。</li>\n<li><strong>存储压力</strong>   ：高并发场景下，大量 Token 的存储和查询会消耗服务端资源（如内存、磁盘 IO）。</li>\n</ul>\n<h3><strong>2. 信息携带能力弱</strong></h3>\n<ul>\n<li><strong>仅作为标识符</strong>   ：普通 Token 通常是无意义的随机字符串，无法直接包含用户信息（如角色、权限、过期时间）。</li>\n<li><strong>增加数据库查询</strong>   ：服务端每次验证 Token 时，需先查询存储系统获取用户数据（如用户 ID、权限），额外增加数据库或缓存的访问次数，降低性能。</li>\n</ul>\n<h3><strong>3. 安全性隐患</strong></h3>\n<ul>\n<li><strong>易被篡改且难验证</strong>   ：普通 Token 若未加密或签名，攻击者可伪造 Token 冒充用户（需依赖服务端存储的校验逻辑，而非 Token 自身）。</li>\n<li><strong>CSRF 风险</strong>   ：若 Token 存储在 Cookie 中且未设置 <code>SameSite</code> 等属性，可能遭受跨站请求伪造攻击。</li>\n<li><strong>泄露后危害大</strong>   ：由于 Token 本身无过期信息，若被盗用，攻击者可长期使用（需服务端手动吊销，操作复杂）。</li>\n</ul>\n<h3><strong>4. 跨域与跨服务支持弱</strong></h3>\n<ul>\n<li><strong>跨域传递受限</strong>   ：普通 Token 若依赖 Cookie 传递，会受浏览器同源策略限制，在前后端分离或跨域场景中需额外配置（如 CORS），兼容性差。</li>\n<li><strong>跨服务共享难</strong>   ：在微服务架构中，不同服务需重复查询 Token 对应的用户信息，增加冗余逻辑；若服务间网络隔离，还可能导致 Token 验证失败。</li>\n</ul>\n<h3><strong>5. 缺乏标准化</strong></h3>\n<ul>\n<li><strong>格式与逻辑不统一</strong>   ：普通 Token 的生成、验证、吊销逻辑完全由开发者自定义，不同系统实现差异大，易出现漏洞。</li>\n<li><strong>无统一过期机制</strong>   ：需手动设计过期逻辑（如定时清理存储的 Token），可能因实现疏漏导致 Token 长期有效。</li>\n</ul>\n<h3><strong>6. 权限管理复杂</strong></h3>\n<ul>\n<li><strong>无法携带权限信息</strong>   ：每次请求需额外查询用户权限（如角色、操作许可），增加服务端处理成本。</li>\n<li><strong>细粒度控制难</strong>   ：若需临时限制用户权限（如禁用某个功能），需修改服务端存储的用户数据，无法通过 Token 本身动态调整。</li>\n</ul>\n<h3><strong>7. 不适合第三方集成</strong></h3>\n<ul>\n<li><strong>单点登录（SSO）支持差</strong>   ：多个独立系统间共享普通 Token 时，需统一存储和校验逻辑，集成成本高。</li>\n<li><strong>第三方授权繁琐</strong>   ：在 OAuth2 等场景中，普通 Token 无法自包含用户信息，第三方服务需额外调用接口获取用户数据，流程复杂。</li>\n</ul>\n<h3><strong>总结</strong></h3>\n<p>普通 Token 的核心问题在于<strong>依赖服务端状态存储、信息携带能力弱、安全性依赖外部逻辑</strong>   ，在分布式系统、前后端分离架构或高并发场景中，这些缺点会显著影响系统的扩展性、性能和安全性。相比之下，JWT 等结构化令牌通过“自包含信息+签名验证”的设计，更好地解决了这些问题，但普通 Token 因其实现简单，仍适用于小型、低并发或内部系统。</p>\n</div>"</script></body></html>