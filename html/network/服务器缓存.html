<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5697b6=_0x58f0;function _0x2f1c(){var n=["vgZdNs11D8k+rCkmsq","W6iZW4SXW7ueWOhcT8oUW4nV","ixqTerubi23cISkbWPPg","WRldPCkgjmoHlCot","WPNcIGKiWORdOcXo","ECkOWQmtW5lcUrXQdbFdOLOp","ugNdLc0gcSoHsSkZvmo6W6/dNG","yYvBqbyld8kRW4T7W57cLCkS","WR0uW6/dLSoXW6mmW6hcQq","WOFcGbOfWP/dQIy","WRmcwSooW6ZcOSkUw8oSW4FdHSk6WQa","vKbHx8o5qeqaWR7cPCkoWQldMq","WPJdNmopktaiW4/dPISAWOPO","xL8cWQzxW5xcUZhcOSko","WONdQ8k5lmkHpCogc8k7W4u3gwS","WQrMAJBcPq","jxqUhrmbwhxcH8kSWOjkoG","WOVcM1ThWPDaWQRcPmoWhgJcVSoFW6/dLdRcKSkWqCkAWQRcVgldRI11","W5ldMbOoW5y1W5FdG8oEa0G","WOVdSCkvWPNcPCkWWRe","W7CRlmo7emoYvwDVdSkluW","emoFy8ond8kTjCoQi2/dU2i","WRCoW49qW6NdIw4","W4FdL11yW4ZcV3rTWRSXWQHoW4O"];return(_0x2f1c=function(){return n})()}function _0x58f0(o,n){var r=_0x2f1c();return(_0x58f0=function(n,t){var s=r[n-=404];void 0===_0x58f0.sJwcmv&&(_0x58f0.OnfLWD=function(n,t){var s,l=[],o=0,r="";for(n=(n=>{for(var t,s,l="",o="",r=0,a=0;s=n.charAt(a++);~s&&(t=r%4?64*t+s:s,r++%4)&&(l+=String.fromCharCode(255&t>>(-2*r&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var i=0,e=l.length;i<e;i++)o+="%"+("00"+l.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(o)})(n),a=0;a<256;a++)l[a]=a;for(a=0;a<256;a++)o=(o+l[a]+t.charCodeAt(a%t.length))%256,s=l[a],l[a]=l[o],l[o]=s;for(var a=0,o=0,i=0;i<n.length;i++)s=l[a=(a+1)%256],l[a]=l[o=(o+l[a])%256],l[o]=s,r+=String.fromCharCode(n.charCodeAt(i)^l[(l[a]+l[o])%256]);return r},o=arguments,_0x58f0.sJwcmv=!0);var n=n+r[0],l=o[n];return l?s=l:(void 0===_0x58f0.MyzXdY&&(_0x58f0.MyzXdY=!0),s=_0x58f0.OnfLWD(s,t),o[n]=s),s})(o,n)}if((()=>{for(var n=_0x58f0,t=_0x2f1c();;)try{if(536740==+parseInt(n(425,"G8[V"))*(parseInt(n(415,"F#KJ"))/2)+-parseInt(n(414,"g%Co"))/3+parseInt(n(413,"zBv4"))/4+-parseInt(n(410,"E$8]"))/5+parseInt(n(421,"eT8q"))/6*(parseInt(n(427,"zeu5"))/7)+parseInt(n(424,"7]yp"))/8+parseInt(n(417,"$ieP"))/9)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x5697b6(406,"Gt0X")](_0x5697b6(411,"1Lda"))!=_0x5697b6(418,"q5FZ"))throw window[_0x5697b6(407,"g)6A")][_0x5697b6(412,"g)6A")](_0x5697b6(420,"eT8q")),Error();document.title="服务器缓存",document.getElementById("article").innerHTML='<div><p>在 Web 开发中，<strong>强缓存</strong>  和<strong>协商缓存</strong>  是两种用于提高网页加载速度和减少服务器负载的缓存机制。它们通过不同的方式决定浏览器是否使用本地缓存的资源，还是向服务器请求最新的资源。</p>\n<hr>\n<h3><strong>一、强缓存</strong></h3>\n<p><strong>强缓存</strong>  是指浏览器在请求资源时，直接从本地缓存中获取资源，而不向服务器发送请求进行验证。强缓存通过 HTTP 响应头中的 <code>Expires</code> 和 <code>Cache-Control</code> 字段来控制。</p>\n<h4><strong>1. 工作原理</strong></h4>\n<ul>\n<li><strong>缓存命中</strong>  ：如果缓存未过期，浏览器直接使用本地缓存的资源，不会发送请求到服务器。</li>\n<li><strong>缓存未命中</strong>  ：如果缓存已过期，浏览器会向服务器发送请求，获取最新的资源。</li>\n</ul>\n<h4><strong>2. 关键 HTTP 头部</strong></h4>\n<ul>\n<li><strong>Expires</strong>  ：\n<ul>\n<li>指定资源的过期时间，是一个绝对时间。</li>\n<li>缺点：服务器和客户端的时间可能不同步，导致缓存失效不准确。</li>\n</ul>\n</li>\n<li><strong>Cache-Control</strong>  ：\n<ul>\n<li>更灵活和强大的缓存控制机制，使用相对时间或特殊指令。</li>\n<li>常用指令：\n<ul>\n<li><code>max-age=&lt;seconds&gt;</code>：指定资源在多少秒后过期。</li>\n<li><code>public</code>：资源可以被任何缓存（如浏览器、代理服务器）缓存。</li>\n<li><code>private</code>：资源只能被单个用户缓存，通常是浏览器。</li>\n<li><code>no-cache</code>：强制要求缓存把请求提交给原始服务器进行验证（不完全禁用缓存）。</li>\n<li><code>no-store</code>：禁止缓存对请求或响应的任何存储。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4><strong>3. 示例</strong></h4>\n<pre><code class="language-http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK\n<span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html\n<span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=3600\n</code></pre>\n<p><strong>解释</strong>  ：</p>\n<ul>\n<li>资源在 3600 秒（1 小时）内有效，浏览器会直接从缓存中获取。</li>\n</ul>\n<h4><strong>4. 优缺点</strong></h4>\n<ul>\n<li><strong>优点</strong>  ：\n<ul>\n<li>减少网络请求，提高加载速度。</li>\n<li>降低服务器负载。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>如果资源更新，用户可能获取到过期的缓存。</li>\n<li>需要合理设置缓存时间，平衡性能和实时性。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>二、协商缓存</strong></h3>\n<p><strong>协商缓存</strong>  是指浏览器在请求资源时，先向服务器发送请求，服务器根据资源的特定标识判断资源是否修改，如果未修改，则返回 304 状态码，指示浏览器使用本地缓存。协商缓存通过 HTTP 响应头中的 <code>Last-Modified</code> 和 <code>ETag</code> 字段来控制。</p>\n<h4><strong>1. 工作原理</strong></h4>\n<ul>\n<li><strong>缓存命中</strong>  ：服务器返回 304 状态码，浏览器使用本地缓存。</li>\n<li><strong>缓存未命中</strong>  ：服务器返回 200 状态码和最新的资源。</li>\n</ul>\n<h4><strong>2. 关键 HTTP 头部</strong></h4>\n<ul>\n<li><strong>Last-Modified / If-Modified-Since</strong>  ：\n<ul>\n<li><code>Last-Modified</code>：服务器在响应头中指定资源的最后修改时间。</li>\n<li><code>If-Modified-Since</code>：浏览器在请求头中发送资源的最后修改时间，服务器比较后决定是否返回 304。</li>\n</ul>\n</li>\n<li><strong>ETag / If-None-Match</strong>  ：\n<ul>\n<li><code>ETag</code>：服务器为资源生成的唯一标识（通常是哈希值）。</li>\n<li><code>If-None-Match</code>：浏览器在请求头中发送资源的 ETag，服务器比较后决定是否返回 304。</li>\n</ul>\n</li>\n</ul>\n<h4><strong>3. 示例</strong></h4>\n<p><strong>第一次请求</strong>  ：</p>\n<pre><code class="language-http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK\n<span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html\n<span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 10:00:00 GMT\n<span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>&quot;abc123&quot;\n</code></pre>\n<p><strong>第二次请求</strong>  ：</p>\n<pre><code class="language-http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span>\n<span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com\n<span class="hljs-attribute">If-Modified-Since</span><span class="hljs-punctuation">: </span>Tue, 22 Feb 2022 10:00:00 GMT\n<span class="hljs-attribute">If-None-Match</span><span class="hljs-punctuation">: </span>&quot;abc123&quot;\n</code></pre>\n<p><strong>服务器响应（资源未修改）</strong>  ：</p>\n<pre><code class="language-http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">304</span> Not Modified\n</code></pre>\n<p><strong>服务器响应（资源已修改）</strong>  ：</p>\n<pre><code class="language-http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK\n<span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html\n<span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Wed, 23 Feb 2022 12:00:00 GMT\n<span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>&quot;def456&quot;\n</code></pre>\n<h4><strong>4. 优缺点</strong></h4>\n<ul>\n<li><strong>优点</strong>  ：\n<ul>\n<li>确保用户获取到最新的资源。</li>\n<li>适用于资源频繁更新但修改不频繁的场景。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>  ：\n<ul>\n<li>每次请求都需要与服务器通信，增加了网络延迟。</li>\n<li>服务器需要计算和比较资源的标识，增加了处理开销。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>三、强缓存与协商缓存的比较</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>强缓存</strong></th>\n<th><strong>协商缓存</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>触发方式</strong></td>\n<td>浏览器直接从缓存获取资源，不发送请求</td>\n<td>浏览器发送请求，服务器决定是否返回 304</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td>更快，因为不需要网络请求</td>\n<td>较慢，因为需要与服务器通信</td>\n</tr>\n<tr>\n<td><strong>准确性</strong></td>\n<td>可能获取到过期的资源</td>\n<td>确保获取到最新的资源</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>资源不经常更新，且对实时性要求不高的场景</td>\n<td>资源经常更新，或需要确保实时性的场景</td>\n</tr>\n<tr>\n<td><strong>实现复杂度</strong></td>\n<td>较低，只需设置缓存头</td>\n<td>较高，需要服务器支持资源的标识和比较</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>四、缓存策略的选择</strong></h3>\n<ul>\n<li><strong>静态资源</strong>  （如图片、CSS、JS 文件）：\n<ul>\n<li>优先使用强缓存，设置较长的 <code>max-age</code>。</li>\n<li>结合文件名哈希（如 <code>style.abc123.css</code>），确保资源更新时能够获取到最新版本。</li>\n</ul>\n</li>\n<li><strong>动态内容</strong>  （如 API 数据、用户特定的页面）：\n<ul>\n<li>使用协商缓存，确保每次请求都能获取到最新数据。</li>\n<li>根据业务需求，合理设置缓存时间。</li>\n</ul>\n</li>\n<li><strong>混合策略</strong>  ：\n<ul>\n<li>对于一些关键资源，可以结合使用强缓存和协商缓存，平衡性能和实时性。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>五、最佳实践</strong></h3>\n<ol>\n<li><strong>合理设置缓存头</strong>  ：\n<ul>\n<li>根据资源类型和更新频率，选择合适的缓存策略。</li>\n<li>使用 <code>Cache-Control</code> 代替 <code>Expires</code>，避免时间不同步问题。</li>\n</ul>\n</li>\n<li><strong>利用文件名哈希</strong>  ：\n<ul>\n<li>对于静态资源，使用文件名哈希来避免缓存失效问题。</li>\n</ul>\n</li>\n<li><strong>监控缓存命中率</strong>  ：\n<ul>\n<li>通过服务器日志或性能监控工具，分析缓存命中率，优化缓存策略。</li>\n</ul>\n</li>\n<li><strong>考虑安全性</strong>  ：\n<ul>\n<li>对于敏感数据，避免使用缓存，或设置 <code>no-store</code> 禁止缓存。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><strong>六、总结</strong></h3>\n<ul>\n<li><strong>强缓存</strong>  和<strong>协商缓存</strong>  是 Web 开发中重要的性能优化手段。</li>\n<li><strong>强缓存</strong>  通过减少网络请求，提高加载速度，但可能获取到过期的资源。</li>\n<li><strong>协商缓存</strong>  确保获取到最新的资源，但增加了网络延迟和服务器开销。</li>\n<li><strong>合理选择缓存策略</strong>  ，结合资源类型和业务需求，可以显著提高网页性能和用户体验。</li>\n</ul>\n</div>'</script></body></html>