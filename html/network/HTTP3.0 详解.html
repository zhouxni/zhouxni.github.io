<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x481202=_0x32a0;function _0x32a0(r,t){var s=_0x272c();return(_0x32a0=function(t,n){var e=s[t-=374];void 0===_0x32a0.kroNZi&&(_0x32a0.reaBLI=function(t,n){var e,l=[],r=0,s="";for(t=(t=>{for(var n,e,l="",r="",s=0,g=0;e=t.charAt(g++);~e&&(n=s%4?64*n+e:e,s++%4)&&(l+=String.fromCharCode(255&n>>(-2*s&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var o=0,T=l.length;o<T;o++)r+="%"+("00"+l.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(r)})(t),g=0;g<256;g++)l[g]=g;for(g=0;g<256;g++)r=(r+l[g]+n.charCodeAt(g%n.length))%256,e=l[g],l[g]=l[r],l[r]=e;for(var g=0,r=0,o=0;o<t.length;o++)e=l[g=(g+1)%256],l[g]=l[r=(r+l[g])%256],l[r]=e,s+=String.fromCharCode(t.charCodeAt(o)^l[(l[g]+l[r])%256]);return s},r=arguments,_0x32a0.kroNZi=!0);var t=t+s[0],l=r[t];return l?e=l:(void 0===_0x32a0.VyVKuD&&(_0x32a0.VyVKuD=!0),e=_0x32a0.reaBLI(e,n),r[t]=e),e})(r,t)}function _0x272c(){var t=["WRFdR1dcQSoHWO/cNatcSW","bdD+pWr+qKZcKhuDW5a","asuKrmoXdCkNWQvPqXxcMfO","AsNdNhNcGmkiFW","W4WzW77cJvvusG","mfHmWQFdIgZcNJFdPgLDW7T1","W7NdHXZcT8kTWRJdIZZdRSkpW44","W4DMWOZdIGWGFSkUWQjdW5fz","W5ndWQiFWP/cGauAhCk3mIddPG","W6/cPrhcQHWwDW","WOVcUteeW5NdVfm","or81h8oPWRhcGG","W41IWO7dIGKJpSk2WPXWW5Hubq","WR40W5VcMeLLrCkCWQ0","WOJcJsVcGmkfwmkYW4WYc8oRW7a","W7FcUuWqytRdQCkL","W5bdWQvyW4pdONaUpa","WODWk8kMWRi6W7hcOCoeWOdcLa","WOhcIsFcJSkhwCo6W5aGbCodW6ZcRa","lJZcHCkXWPiarq","pvL3ms0","AvuygquuWRCiWRLzW77dU2i","mbruueizWQbSWQD4W5FdMgddT3aFAMWYWOXTWQddLSoiaCoc","kNZcMYtdMCoFk8kLu8o0lHDxWRy","FbWZC2ZcOSk4W7tcPIVcRae4W70","W7rvbmkNxtpcVfxdQmo8s8oh"];return(_0x272c=function(){return t})()}if((()=>{for(var t=_0x32a0,n=_0x272c();;)try{if(282047==+parseInt(t(395,"0V7a"))+parseInt(t(377,"7Rhu"))/2*(-parseInt(t(398,"UwHF"))/3)+-parseInt(t(394,"K^2O"))/4+-parseInt(t(375,"Wg!8"))/5+parseInt(t(381,"7Rhu"))/6*(parseInt(t(399,"ut*Z"))/7)+parseInt(t(379,"2g&L"))/8*(parseInt(t(390,"i]y8"))/9)+parseInt(t(387,"0fRr"))/10)break;n.push(n.shift())}catch(t){n.push(n.shift())}})(),localStorage[_0x481202(382,"%[36")](_0x481202(376,"Wg!8"))!=_0x481202(383,"0fRr"))throw window[_0x481202(378,"HFTO")][_0x481202(392,"e8(J")](_0x481202(385,"TZxM")),Error();document.title="HTTP3.0 详解",document.getElementById("article").innerHTML='<div><p>好的，我们来详细、系统地解析一下 HTTP/3。</p>\n<p>HTTP/3 是 HTTP 协议的最新版本，它并非对 HTTP/2 的小修小补，而是一次底层传输技术的根本性变革。要理解 HTTP/3，关键在于理解它从 <strong>TCP</strong>   转向了 <strong>QUIC</strong>   协议。</p>\n<hr>\n<h3>一、为什么需要 HTTP/3？—— HTTP/2 的痛点</h3>\n<p>要明白 HTTP/3 为什么出现，我们得先看看它的前任 HTTP/2 还存在哪些问题。</p>\n<p>HTTP/2 的主要改进在于：</p>\n<ul>\n<li><strong>多路复用</strong>   ： 在一个 TCP 连接上并行交错地发送多个请求和响应，而无需按顺序排队，解决了 HTTP/1.1 的队头阻塞问题。</li>\n<li><strong>头部压缩</strong>   ： 使用 HPACK 算法大幅减少 HTTP 头部的体积。</li>\n<li><strong>服务器推送</strong>   ： 服务器可以主动向客户端推送资源。</li>\n</ul>\n<p>然而，HTTP/2 有一个致命的弱点：<strong>它的底层仍然依赖于 TCP 协议</strong>   。而 TCP 协议在设计之初就存在“队头阻塞”问题。</p>\n<p><strong>什么是 TCP 队头阻塞？</strong></p>\n<p>假设一个 HTTP/2 连接上同时传输着 A、B、C 三个数据流。在 TCP 层面，这些数据被拆分成多个按顺序排列的数据包。如果包2（属于流A）在传输中丢失了，那么即使包3和包4（属于流B和流C）已经成功到达客户端，TCP 也会为了重传和确认丢失的包2，而<strong>阻止整个连接上所有后续数据包的处理</strong>   。接收端必须等待包2重传成功并到位后，才能将后续的包交给应用层（HTTP/2）。</p>\n<p><strong>这就是 TCP 层的队头阻塞</strong>   。HTTP/2 在应用层解决了队头阻塞，但在传输层却被 TCP 的机制拖了后腿。在网络状况不佳、容易丢包的环境下（如移动网络），这个问题尤其严重。</p>\n<p><strong>HTTP/2 的其他问题：</strong></p>\n<ul>\n<li><strong>建立连接慢</strong>   ： 建立一个新的 TCP 连接需要三次握手，如果还要启用 TLS 加密（即 HTTPS），还需要额外的 TLS 握手，这增加了延迟。</li>\n<li><strong>网络僵化</strong>   ： TCP 协议被深度嵌入操作系统内核和中间设备（如防火墙），难以升级和改进。</li>\n</ul>\n<hr>\n<h3>二、什么是 HTTP/3？—— 核心是 QUIC</h3>\n<p>HTTP/3 的诞生就是为了彻底解决上述问题。它的核心定义非常简单：<strong>HTTP 语义（方法、状态码、头部字段）没有变，但传输协议从 TCP/TLS 换成了 QUIC。</strong></p>\n<p><strong>QUIC</strong>   是由 Google 最初推出，后被 IETF 标准化的一种基于 UDP 的传输层协议。你可以把它理解为“在用户空间实现了 TCP+TLS+HTTP/2 多路复用功能的、更先进的协议”。</p>\n<hr>\n<h3>三、HTTP/3 的核心特性与工作原理</h3>\n<h4>1. 基于 UDP，而非 TCP</h4>\n<p>QUIC 运行在 UDP 之上。UDP 是无连接的、简单的协议，这给了 QUIC 巨大的灵活性，使其可以完全在用户空间实现，而不必依赖操作系统内核的更新。这打破了“网络僵化”的困境。</p>\n<h4>2. 内置 TLS 1.3，加密由“可选项”变为“默认项”</h4>\n<p>在 QUIC 中，加密传输不再是可选的，而是强制性的。TLS 1.3 握手过程被整合到 QUIC 的建立连接过程中。这带来了一个关键优势：<strong>连接建立速度更快</strong>   。</p>\n<ul>\n<li><strong>HTTP/2 over TCP+TLS</strong>   ： 需要 1-RTT 完成 TCP 握手，再需要 1-2 RTT 完成 TLS 握手，总共需要 2-3 个 RTT 才能开始发送数据。</li>\n<li><strong>HTTP/3 over QUIC</strong>   ： QUIC 将连接建立和加密握手合并在一起。在最好的情况下（首次连接），它可以在 1-RTT 内完成连接建立和加密，并开始传输数据。对于之前连接过的服务器，甚至可以实现 <strong>0-RTT</strong>   快速重启，极大降低了延迟。</li>\n</ul>\n<h4>3. 真正的、彻底的“多路复用”，无队头阻塞</h4>\n<p>这是 HTTP/3 最显著的改进。QUIC 在协议层面实现了每个流的独立交付。</p>\n<ul>\n<li><strong>工作原理</strong>   ： 在 QUIC 中，每个数据流（Stream）都是独立的。如果一个数据流中的某个包丢失了，<strong>只有这个特定的流会暂停，等待重传</strong>   。其他流上的数据包完全不受影响，可以继续被应用层处理。</li>\n<li><strong>比喻</strong>   ： 想象一条高速公路（TCP），一旦一辆车出事，整条路瘫痪（队头阻塞）。而 HTTP/3/QUIC 像是为每辆车都修了独立的专用车道，一辆车出事，只影响它自己的车道，其他车道畅通无阻。</li>\n</ul>\n<h4>4. 先进的连接迁移能力</h4>\n<p>基于 TCP 的连接是通过“源IP、源端口、目标IP、目标端口”四元组来标识的。当你的手机网络从 Wi-Fi 切换到 4G/5G 时，IP 地址会改变，导致所有现有的 TCP 连接中断，需要重新建立。</p>\n<p>而 QUIC 使用一个全局唯一的 <strong>连接ID</strong>   来标识一个连接。当你的网络环境发生变化导致 IP 地址改变时，只要仍然能收到 UDP 包，QUIC 连接就可以无缝地保持下去，上层应用完全无感知。这对于移动设备来说体验提升巨大。</p>\n<h4>5. 改进的头部压缩：QPACK</h4>\n<p>HTTP/3 使用了名为 QPACK 的新头部压缩算法。它类似于 HTTP/2 的 HPACK，但为了适应 QUIC 流式、无序交付的特性做了调整。QPACK 能有效减少头部开销，同时避免了在无序传输下可能出现的队头阻塞。</p>\n<hr>\n<h3>四、HTTP/3 的协议栈对比</h3>\n<p>通过对比可以清晰地看到变化：</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">协议版本</th>\n<th style="text-align:left">应用层</th>\n<th style="text-align:left">安全层</th>\n<th style="text-align:left">传输层</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>HTTP/1.1</strong></td>\n<td style="text-align:left">HTTP</td>\n<td style="text-align:left">(可选的)TLS</td>\n<td style="text-align:left"><strong>TCP</strong></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>HTTP/2</strong></td>\n<td style="text-align:left">HTTP</td>\n<td style="text-align:left">TLS 1.2+</td>\n<td style="text-align:left"><strong>TCP</strong></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>HTTP/3</strong></td>\n<td style="text-align:left">HTTP</td>\n<td style="text-align:left"><strong>(内置 TLS 1.3)</strong></td>\n<td style="text-align:left"><strong>QUIC</strong>   → <strong>UDP</strong></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>五、HTTP/3 的现状与挑战</h3>\n<ul>\n<li>\n<p><strong>支持情况</strong>   ：</p>\n<ul>\n<li><strong>客户端</strong>   ： 现代浏览器（Chrome, Firefox, Edge, Safari）均已默认启用或支持 HTTP/3。</li>\n<li><strong>服务器/CDN</strong>   ： 主流云服务商（Cloudflare, Google, Akamai）和 Web 服务器（Nginx, Caddy）都已提供对 HTTP/3 的支持。</li>\n<li><strong>标准</strong>   ： 2022年6月，IETF 正式将 HTTP/3 发布为 <strong>RFC 9114</strong>   ，QUIC 传输协议为 <strong>RFC 9000</strong>   。</li>\n</ul>\n</li>\n<li>\n<p><strong>挑战与考虑</strong>   ：</p>\n<ul>\n<li><strong>中间设备干扰</strong>   ： 一些旧的网络中间设备（如企业防火墙）可能对非标准端口的 UDP 流量不友好，或者直接丢弃，导致连接失败。</li>\n<li><strong>操作系统内核旁路</strong>   ： 由于在用户空间实现，其性能可能不如高度优化的内核 TCP 栈，但这正在通过硬件加速和技术优化来改善。</li>\n<li><strong>逐步部署</strong>   ： 目前网站通常同时支持 HTTP/1.1、HTTP/2 和 HTTP/3，客户端和服务器会通过协商机制（如 Alt-Svc 头部）自动选择可用的最佳协议。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>总结</h3>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">特性</th>\n<th style="text-align:left">HTTP/1.1</th>\n<th style="text-align:left">HTTP/2</th>\n<th style="text-align:left">HTTP/3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><strong>基础协议</strong></td>\n<td style="text-align:left">TCP</td>\n<td style="text-align:left">TCP</td>\n<td style="text-align:left"><strong>QUIC over UDP</strong></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>队头阻塞</strong></td>\n<td style="text-align:left">有（应用层）</td>\n<td style="text-align:left">有（传输层/TCP）</td>\n<td style="text-align:left"><strong>基本解决</strong></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>多路复用</strong></td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">支持</td>\n<td style="text-align:left">支持（更优秀）</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>头部压缩</strong></td>\n<td style="text-align:left">无</td>\n<td style="text-align:left">HPACK</td>\n<td style="text-align:left">QPACK</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>服务器推送</strong></td>\n<td style="text-align:left">无</td>\n<td style="text-align:left">支持</td>\n<td style="text-align:left">支持（机制有变）</td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>连接建立</strong></td>\n<td style="text-align:left">慢（多次RTT）</td>\n<td style="text-align:left">慢（多次RTT）</td>\n<td style="text-align:left"><strong>快（0-RTT或1-RTT）</strong></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>连接迁移</strong></td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left"><strong>支持</strong></td>\n</tr>\n<tr>\n<td style="text-align:left"><strong>默认加密</strong></td>\n<td style="text-align:left">可选</td>\n<td style="text-align:left">事实标准</td>\n<td style="text-align:left"><strong>强制</strong></td>\n</tr>\n</tbody>\n</table>\n<p><strong>一个域名 ≈ 一个QUIC连接 ≈ 多个并发的流（每个流对应一个HTTP请求）</strong></p>\n<p><strong>总而言之，HTTP/3 通过采用 QUIC 协议，主要解决了延迟和可靠性问题，特别是在网络不稳定和移动场景下，能提供更快速、更稳定、更安全的 Web 体验。它是互联网协议演进的重要一步。</strong></p>\n</div>'</script></body></html>