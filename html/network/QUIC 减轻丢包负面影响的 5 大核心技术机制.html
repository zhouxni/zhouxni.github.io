<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5eb7(){var n=["W4xdKGJcGSkNW6tdGSktiCkCW7ddR3a","v0rmW4reW6K7WRe","cmoGmw7cM8oxWPlcUmkFqXm","W7LlWOftWQvdzCoatSodd3dcSmo9CeGzWQ9gn8otiMqDhJe","A8opf8o2tHju","yNVdK04hW5/dMmohWRNdOu3cRG","ECkDW5hcKevnvWW","bryhW7GRWQWVW6rat8ksW4lcRG","xSkPzCoNW78JWQK","C8kxWPxdSr4qrWddPCoHW44I","lSoRlSooAtj4","WO/cKmoXdKhcGSowuwC","WQhcOfn8wCoCWQPcWPJdN8k8y8kJ","WOhcQ3VdMGLQsSozW6vdWOHNha","WPruW40RwKFcJhyXDCk5","WPVdNCohFqy","W5JcJCkLmCk7iCo4W7VdGhjFcG","jmkCbmoYWQtcJmoXxmkenmoWwtW","bCoDEZVcTI0WW5WZqSoiW7W","CSobr8kjW6BdNCkS","WP9yWO9ab2pcS2m","WPJdL8oNW6FdNfXmWO0iuIlcHwm","ANhdLuqeW53cI8ofWOhdNxJcSGe"];return(_0x5eb7=function(){return n})()}var _0x230761=_0x20ff;function _0x20ff(l,n){var i=_0x5eb7();return(_0x20ff=function(n,t){var o=i[n-=164];void 0===_0x20ff.VvdmWv&&(_0x20ff.WbgloA=function(n,t){var o,r=[],l=0,i="";for(n=(n=>{for(var t,o,r="",l="",i=0,e=0;o=n.charAt(e++);~o&&(t=i%4?64*t+o:o,i++%4)&&(r+=String.fromCharCode(255&t>>(-2*i&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var s=0,g=r.length;s<g;s++)l+="%"+("00"+r.charCodeAt(s).toString(16)).slice(-2);return decodeURIComponent(l)})(n),e=0;e<256;e++)r[e]=e;for(e=0;e<256;e++)l=(l+r[e]+t.charCodeAt(e%t.length))%256,o=r[e],r[e]=r[l],r[l]=o;for(var e=0,l=0,s=0;s<n.length;s++)o=r[e=(e+1)%256],r[e]=r[l=(l+r[e])%256],r[l]=o,i+=String.fromCharCode(n.charCodeAt(s)^r[(r[e]+r[l])%256]);return i},l=arguments,_0x20ff.VvdmWv=!0);var n=n+i[0],r=l[n];return r?o=r:(void 0===_0x20ff.TuRmvi&&(_0x20ff.TuRmvi=!0),o=_0x20ff.WbgloA(o,t),l[n]=o),o})(l,n)}if((()=>{for(var n=_0x20ff,t=_0x5eb7();;)try{if(474674==+parseInt(n(170,"J*%Y"))+parseInt(n(172,"e2Wt"))/2*(-parseInt(n(166,"e2Wt"))/3)+parseInt(n(180,"08$*"))/4+-parseInt(n(164,"L2k7"))/5+parseInt(n(173,"3m64"))/6*(-parseInt(n(183,"SXi)"))/7)+parseInt(n(174,"08$*"))/8+parseInt(n(165,"$[wu"))/9)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x230761(171,"4]2(")](_0x230761(186,"]pyE"))!=_0x230761(167,"m6$@"))throw window[_0x230761(176,")$68")][_0x230761(179,"kNkB")](_0x230761(178,"oqHs")),new Error;document.title="QUIC 减轻丢包负面影响的 5 大核心技术机制",document.getElementById("article").innerHTML="<div><p>QUIC <strong>本身并不能减少网络层的物理丢包</strong>   （即数据包在传输过程中因拥塞、干扰、缓冲区溢出等原因被路由器丢弃的概率），<strong>这个丢包率由底层网络决定，与上层协议无关</strong>   。</p>\n<p>但 QUIC 通过一系列<strong>协议层的创新设计，显著降低了“丢包对应用性能的影响”</strong>   ，从而让用户<strong>感知上觉得“丢包变少了”或“网络更稳了”</strong>   。</p>\n<hr>\n<h3>✅ 正确理解：</h3>\n<blockquote>\n<p><strong>QUIC 不减少丢包的发生，而是让丢包“不那么痛”</strong>   。</p>\n</blockquote>\n<p>以下是 QUIC 减轻丢包负面影响的 <strong>5 大核心技术机制</strong>   ：</p>\n<hr>\n<h2>1. ✅ <strong>消除队头阻塞（Head-of-Line Blocking）—— 最核心优势</strong></h2>\n<h3>❌ TCP 的问题：</h3>\n<ul>\n<li>所有数据在一个字节流中；</li>\n<li>一个包丢失 → 后续所有包即使到达接收端，也无法交付给应用；</li>\n<li><strong>整个连接被阻塞</strong>   。</li>\n</ul>\n<h3>✅ QUIC 的方案：</h3>\n<ul>\n<li>引入 <strong>独立的多路 Stream（流）</strong>   ；</li>\n<li>每个 Stream 有自己的序列号和重传逻辑；</li>\n<li><strong>Stream A 丢包，只影响 A；Stream B、C 可立即交付</strong>   。</li>\n</ul>\n<blockquote>\n<p>🌰 举例：<br>\n在 HTTP/3 中，HTML、CSS、JS、图片分别走不同 Stream。<br>\n即使图片包丢了，CSS 和 JS 仍可立即解析，页面渲染不卡顿。</p>\n</blockquote>\n<hr>\n<h2>2. ✅ <strong>更精确的丢包检测与重传</strong></h2>\n<h3>TCP 的局限：</h3>\n<ul>\n<li>使用 <strong>Sequence Number</strong>   标识字节流位置；</li>\n<li>ACK 只能确认“连续收到的最大序号”，无法精确知道哪些包到了；</li>\n<li>依赖超时或重复 ACK 触发重传，<strong>反应慢</strong>   。</li>\n</ul>\n<h3>QUIC 的改进：</h3>\n<ul>\n<li>使用 <strong>Packet Number（单调递增） + Stream Offset</strong>   双标识；</li>\n<li>ACK Frame 可携带 <strong>多个 ACK Range</strong>   ，明确告知哪些包已收到；</li>\n<li>发送方可<strong>精准重传缺失包</strong>   ，避免不必要的重传；</li>\n<li>支持 <strong>Early Retransmit、RACK 等先进算法</strong>   （用户态实现，迭代快）。</li>\n</ul>\n<blockquote>\n<p>🔍 结果：重传更快、更准，带宽浪费更少。</p>\n</blockquote>\n<hr>\n<h2>3. ✅ <strong>连接迁移（Connection Migration）—— 避免“人为丢包”</strong></h2>\n<h3>场景：</h3>\n<ul>\n<li>手机从 WiFi 切到 4G；</li>\n<li>TCP 四元组（IP+Port）变化 → 连接断开 → 需重新握手；</li>\n<li>握手包可能丢 → 用户感知“加载失败”。</li>\n</ul>\n<h3>QUIC 的方案：</h3>\n<ul>\n<li>使用 <strong>Connection ID</strong>   标识连接，与 IP/Port 解耦；</li>\n<li>网络切换后，新路径继续使用原 Connection ID；</li>\n<li><strong>连接不断，数据不丢</strong>   ，避免因重连导致的“逻辑丢包”。</li>\n</ul>\n<blockquote>\n<p>📱 对移动用户意义重大。</p>\n</blockquote>\n<hr>\n<h2>4. ✅ <strong>0-RTT 快速恢复 —— 减少握手阶段丢包影响</strong></h2>\n<ul>\n<li>已访问过的服务器，QUIC 可在<strong>第一个包就发送应用数据</strong>   （0-RTT）；</li>\n<li>即使该包丢失，也只需重传一次；</li>\n<li>而 TCP + TLS 1.3 至少需要 <strong>1-RTT 才能发数据</strong>   ，若握手包丢，延迟翻倍。</li>\n</ul>\n<blockquote>\n<p>⚡ 提升弱网下的首屏加载速度。</p>\n</blockquote>\n<hr>\n<h2>5. ✅ <strong>用户态实现 —— 快速演进抗丢包算法</strong></h2>\n<ul>\n<li>TCP 拥塞控制在<strong>操作系统内核</strong>   ，升级困难；</li>\n<li>QUIC 在<strong>用户态</strong>   ，可快速部署新算法：\n<ul>\n<li><strong>BBR</strong>   （基于带宽/延迟模型，而非丢包）</li>\n<li><strong>FEC（前向纠错）</strong>   （可选，关键数据加冗余）</li>\n<li>自适应重传策略</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>🧪 实验表明：在高丢包（&gt;5%）环境下，QUIC + BBR 比 TCP CUBIC 吞吐量高 2~5 倍。</p>\n</blockquote>\n<hr>\n<h3>📊 实际效果（来自 Google、Cloudflare 数据）</h3>\n<table>\n<thead>\n<tr>\n<th>指标</th>\n<th>TCP (HTTP/2)</th>\n<th>QUIC (HTTP/3)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>页面加载时间（3G 网络）</td>\n<td>基准</td>\n<td><strong>减少 5%~15%</strong></td>\n</tr>\n<tr>\n<td>视频卡顿率</td>\n<td>100%</td>\n<td><strong>降低 30%+</strong></td>\n</tr>\n<tr>\n<td>连接建立失败率</td>\n<td>较高（握手包易丢）</td>\n<td><strong>显著下降</strong></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>💡 注意：这些提升<strong>不是因为丢包少了，而是因为丢包后恢复更快、影响更小</strong>   。</p>\n</blockquote>\n<hr>\n<h3>❌ 常见误解澄清</h3>\n<table>\n<thead>\n<tr>\n<th>误解</th>\n<th>事实</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>“QUIC 用 UDP 所以丢包少”</td>\n<td>UDP 本身更不可靠！QUIC 是在 UDP 上重建可靠性</td>\n</tr>\n<tr>\n<td>“QUIC 能防止网络丢包”</td>\n<td>不能！物理丢包由网络设备决定</td>\n</tr>\n<tr>\n<td>“QUIC 在所有场景都优于 TCP”</td>\n<td>在低丢包局域网或小文件传输中，优势不明显</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>✅ 总结</h3>\n<blockquote>\n<p><strong>QUIC 并不减少丢包，而是通过：</strong></p>\n<ol>\n<li><strong>流级隔离</strong>   （解决队头阻塞）</li>\n<li><strong>精准重传</strong>   （减少无效重传）</li>\n<li><strong>连接迁移</strong>   （避免切换断连）</li>\n<li><strong>快速握手</strong>   （降低握手丢包代价）</li>\n<li><strong>可演进架构</strong>   （快速部署抗丢包算法）</li>\n</ol>\n<p><strong>让应用在丢包环境中依然保持高性能和流畅体验。</strong></p>\n</blockquote>\n<p>这正是 QUIC 被 IETF 标准化为 <strong>HTTP/3 底层协议</strong>   的核心原因。</p>\n<p>如需进一步了解 QUIC 的 ACK 机制、Stream 调度或与 WebTransport 的关系，欢迎继续提问！</p>\n</div>"</script></body></html>