<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x1e1b(){var n=["WONdGJHNcWmF","imkwW6TqW7nxuSoze8oL","cGbAfmo7WO7dPd/dH8kyW55O","W63dHCkVW6pdRLVdJ8kSwX4","xCkysLO9W67cNNZdNG","WQ3dNCoihqpdU8kwW5FdSLvcqa","xmosfetdUx3dNKT8WOqnWOW","jI14aWTAdHKOEW","W4W8W4fZWPnWevJdO08","j8kMWOddRtZcSdW","W63dHSkPW6/dTKxdV8keyZm","WQZcUmkDsfZcMmkm","suyEv8kW","WPtdJc0FWONcPmoDWPP7WOW","WRtdKeFcKMldI8oyn3mNW6/cGW","WOddMcTRW5JdPaRdLmkSWP8","WP5bE3xdLCo0WP01wmoG","u8oGW5FcNhhdQ8kfWOBdSG","i8kqW6bFWQOoqSozdSoqzmoW","WPpdJ2LNWOdcMmowWOS","W5vVaCkHWO0iWOCw","W5tcH8o2WR58uCk9jG","j8oWWPXDBZlcV0mt","WPCHWRhdR1pdJmkiW5hcG3C","W5PMWQ/cU8oEW7JcHqBdSCoJ","WPpcKSotjmo5W6iPrCklWOe","W6/cKGpdLcBdHmkJw1eDW7lcG1FdQmo4hCk/WOWDW6uOWORdHrm/W78","W405WPddPdypW4dcPgzG","WOBcRmkNeKT+imoCw8k8WPCs"];return(_0x1e1b=function(){return n})()}var _0x2c1317=_0x5085;function _0x5085(e,n){var a=_0x1e1b();return(_0x5085=function(n,t){var d=a[n-=146];void 0===_0x5085.oKNuHX&&(_0x5085.NMWoqX=function(n,t){var d,s=[],e=0,a="";for(n=(n=>{for(var t,d,s="",e="",a=0,o=0;d=n.charAt(o++);~d&&(t=a%4?64*t+d:d,a++%4)&&(s+=String.fromCharCode(255&t>>(-2*a&6))))d="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(d);for(var l=0,p=s.length;l<p;l++)e+="%"+("00"+s.charCodeAt(l).toString(16)).slice(-2);return decodeURIComponent(e)})(n),o=0;o<256;o++)s[o]=o;for(o=0;o<256;o++)e=(e+s[o]+t.charCodeAt(o%t.length))%256,d=s[o],s[o]=s[e],s[e]=d;for(var o=0,e=0,l=0;l<n.length;l++)d=s[o=(o+1)%256],s[o]=s[e=(e+s[o])%256],s[e]=d,a+=String.fromCharCode(n.charCodeAt(l)^s[(s[o]+s[e])%256]);return a},e=arguments,_0x5085.oKNuHX=!0);var n=n+a[0],s=e[n];return s?d=s:(void 0===_0x5085.jfVicB&&(_0x5085.jfVicB=!0),d=_0x5085.NMWoqX(d,t),e[n]=d),d})(e,n)}if((()=>{for(var n=_0x5085,t=_0x1e1b();;)try{if(113136==-parseInt(n(152,"j$ge"))*(-parseInt(n(153,"s7NJ"))/2)+-parseInt(n(159,"IwKs"))/3*(parseInt(n(150,"jEV&"))/4)+-parseInt(n(147,"s7NJ"))/5+-parseInt(n(166,"zc#R"))/6*(-parseInt(n(149,"LAEe"))/7)+-parseInt(n(160,"@fkP"))/8+-parseInt(n(173,"jDE@"))/9*(-parseInt(n(161,"nxb1"))/10)+-parseInt(n(169,"7iNp"))/11*(-parseInt(n(172,"@fkP"))/12))break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x2c1317(151,"tyEJ")](_0x2c1317(164,"eis0"))!=_0x2c1317(154,"jDE@"))throw window[_0x2c1317(163,"N&g%")][_0x2c1317(171,"U3d(")](_0x2c1317(168,"aNLC")),Error();document.title="HTTP1.0 详解",document.getElementById("article").innerHTML='<div><h1>HTTP/1.0 详解：Web 协议的基石版本</h1>\n<p>HTTP（HyperText Transfer Protocol，超文本传输协议）是用于在客户端（如浏览器）和服务器之间传输超文本（如 HTML、图片、文本）的应用层协议。<strong>HTTP/1.0</strong>   作为该协议的首个标准化版本，于 1996 年在 RFC 1945 中正式定义，为早期 Web 的发展奠定了核心基础，尽管如今已被 HTTP/1.1、HTTP/2 等后续版本取代，但理解其设计和特性是掌握 Web 协议演进的关键。</p>\n<h2>一、HTTP/1.0 的核心定位与历史背景</h2>\n<p>在 HTTP/1.0 之前，Web 协议处于“非标准化”阶段（被称为 HTTP/0.9，仅支持 GET 方法和纯文本传输）。随着 Web 内容从纯文本扩展到图片、音频等多媒体，以及交互需求的增加，标准化协议的需求日益迫切——HTTP/1.0 正是为解决这一问题而生，其核心目标是：</p>\n<ol>\n<li>定义统一的请求-响应格式，确保不同客户端（浏览器）和服务器的兼容性；</li>\n<li>扩展协议功能，支持多种资源类型和交互方式；</li>\n<li>为后续协议的演进提供可扩展的基础框架。</li>\n</ol>\n<h2>二、HTTP/1.0 的核心特性</h2>\n<p>HTTP/1.0 在 HTTP/0.9 的基础上进行了关键扩展，核心特性可归纳为以下几点：</p>\n<h3>1. 支持多种请求方法（Method）</h3>\n<p>HTTP/1.0 首次定义了除 <code>GET</code> 之外的请求方法，满足不同的交互需求，常用方法如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n<th>是否幂等*</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>GET</code></td>\n<td>从服务器获取资源（如 HTML 页面、图片），请求参数附加在 URL 中</td>\n<td>是</td>\n</tr>\n<tr>\n<td><code>POST</code></td>\n<td>向服务器提交数据（如表单提交），数据放在请求体中，不暴露在 URL 中</td>\n<td>否</td>\n</tr>\n<tr>\n<td><code>HEAD</code></td>\n<td>与 <code>GET</code> 类似，但仅返回响应头（无响应体），用于快速获取资源元信息</td>\n<td>是</td>\n</tr>\n<tr>\n<td><code>PUT</code></td>\n<td>向服务器上传资源（如替换文件），覆盖目标路径的现有资源</td>\n<td>是</td>\n</tr>\n<tr>\n<td><code>DELETE</code></td>\n<td>请求服务器删除目标路径的资源</td>\n<td>是</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>*注：<strong>幂等性</strong>   指多次执行相同请求，结果与执行一次一致（不会因重复请求产生副作用），<code>POST</code> 因可能重复提交表单（如重复下单），故不满足幂等性。</p>\n</blockquote>\n<h3>2. 引入 HTTP 消息结构：请求与响应</h3>\n<p>HTTP/1.0 明确了“请求-响应”的消息格式，二者均由 <strong>起始行、头部字段、空行、消息体</strong>   四部分组成（部分场景下消息体可省略）。</p>\n<h4>（1）请求消息结构</h4>\n<p>示例：向服务器请求 <code>/index.html</code> 资源</p>\n<pre><code class="language-http">GET /index.html HTTP/1.0  # 起始行：方法 + 资源路径 + 协议版本\n<span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com     # 头部字段：键值对，描述请求属性\n<span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/4.0   # 客户端标识（如浏览器型号）\n<span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html, image/jpeg  # 客户端可接受的资源类型\n\n# 空行：分隔头部与消息体（必须存在，即使无消息体）\n# 消息体：POST/PUT 等方法时存放提交数据，GET 方法无消息体\n</code></pre>\n<h4>（2）响应消息结构</h4>\n<p>示例：服务器对上述请求的响应</p>\n<pre><code class="language-http"><span class="hljs-meta">HTTP/1.0</span> <span class="hljs-number">200</span> OK  # 起始行：协议版本 + 状态码 + 状态描述\n<span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Wed, 20 Sep 2023 12:00:00 GMT  # 响应生成时间\n<span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache/2.2.15  # 服务器软件标识\n<span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html  # 响应体的 MIME 类型（资源类型）\n<span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>1024     # 响应体的字节数\n\n<span class="language-xml"># 空行：分隔头部与消息体\n<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>  # 消息体：资源内容（此处为 HTML 代码）\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Hello HTTP/1.0<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n</span></code></pre>\n<h3>3. 支持 MIME 类型：多资源格式传输</h3>\n<p>HTTP/0.9 仅支持纯文本（<code>text/plain</code>），而 HTTP/1.0 通过 <strong>MIME 类型（Multipurpose Internet Mail Extensions）</strong>   实现了多种资源的传输，核心通过 <code>Content-Type</code> 头部字段标识资源类型，常见 MIME 类型如下：</p>\n<ul>\n<li><code>text/html</code>：HTML 页面</li>\n<li><code>image/jpeg</code>：JPEG 图片</li>\n<li><code>image/png</code>：PNG 图片</li>\n<li><code>application/json</code>：JSON 数据</li>\n<li><code>text/css</code>：CSS 样式表</li>\n</ul>\n<p>MIME 类型的引入，让 Web 从“纯文本时代”进入“多媒体时代”，是浏览器能展示图文混合页面的关键。</p>\n<h3>4. 引入状态码（Status Code）：明确响应结果</h3>\n<p>HTTP/1.0 定义了状态码，用于让客户端快速判断请求是否成功，以及失败的原因，核心状态码分类如下：</p>\n<table>\n<thead>\n<tr>\n<th>状态码范围</th>\n<th>类别</th>\n<th>含义示例</th>\n<th>常见状态码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1xx</td>\n<td>信息提示</td>\n<td>服务器已接收请求，需继续处理</td>\n<td>（HTTP/1.0 暂未实际使用）</td>\n</tr>\n<tr>\n<td>2xx</td>\n<td>成功</td>\n<td>请求已正常处理</td>\n<td>200 OK（成功）</td>\n</tr>\n<tr>\n<td>3xx</td>\n<td>重定向</td>\n<td>需客户端进一步操作才能获取资源</td>\n<td>302 Found（临时重定向）</td>\n</tr>\n<tr>\n<td>4xx</td>\n<td>客户端错误</td>\n<td>请求存在问题（如资源不存在）</td>\n<td>404 Not Found（资源未找到）</td>\n</tr>\n<tr>\n<td>5xx</td>\n<td>服务器错误</td>\n<td>服务器处理请求失败</td>\n<td>500 Internal Server Error（服务器内部错误）</td>\n</tr>\n</tbody>\n</table>\n<h3>5. 无连接（Connection: close）：短连接模式</h3>\n<p>HTTP/1.0 的默认连接模式是 <strong>无连接</strong>   ，即：</p>\n<ol>\n<li>客户端与服务器建立 TCP 连接；</li>\n<li>发送一个 HTTP 请求，接收一个 HTTP 响应；</li>\n<li>响应完成后，立即关闭 TCP 连接。</li>\n</ol>\n<p>这种模式的优点是实现简单，避免服务器长期占用连接资源；但缺点也极为明显——若客户端需获取多个资源（如一个 HTML 页面包含 10 张图片），则需重复建立/关闭 11 次 TCP 连接（1 次 HTML + 10 次图片），而 TCP 连接的“三次握手”和“四次挥手”会产生大量延迟，严重影响页面加载速度。</p>\n<h2>三、HTTP/1.0 的局限性（为何被 HTTP/1.1 取代）</h2>\n<p>尽管 HTTP/1.0 推动了 Web 的早期发展，但随着 Web 规模扩大，其局限性逐渐凸显，主要包括：</p>\n<ol>\n<li>\n<p><strong>无连接效率低</strong>   ：每次请求都需建立 TCP 连接，频繁的“握手-挥手”浪费带宽和时间，尤其对包含多资源的页面（如电商页面），延迟明显。</p>\n</li>\n<li>\n<p><strong>缺乏持久连接支持</strong>   ：HTTP/1.0 未定义持久连接（Keep-Alive）的标准，尽管部分服务器通过自定义头部支持，但兼容性差，无法成为通用方案。</p>\n</li>\n<li>\n<p><strong>无 Host 头部的标准定义</strong>   ：早期服务器多为“单 IP 对应单网站”，但随着虚拟主机（多网站共享一个 IP）普及，HTTP/1.0 未标准化 <code>Host</code> 头部，导致服务器无法区分同一 IP 下的不同网站请求（后期 HTTP/1.0 补充了 <code>Host</code> 头部，但未纳入最初标准）。</p>\n</li>\n<li>\n<p><strong>缓存机制不完善</strong>   ：HTTP/1.0 仅支持 <code>Expires</code>（绝对时间）和 <code>Pragma: no-cache</code> 等简单缓存控制，无法精确控制缓存的有效性（如相对时间、缓存验证），易导致客户端使用过期资源。</p>\n</li>\n<li>\n<p><strong>无管道化（Pipelining）支持</strong>   ：客户端需等待前一个请求的响应返回后，才能发送下一个请求，无法“批量发送请求”，进一步增加了页面加载延迟。</p>\n</li>\n</ol>\n<h2>四、HTTP/1.0 与 HTTP/1.1 的核心差异</h2>\n<p>HTTP/1.1（1999 年 RFC 2616 定义）作为 HTTP/1.0 的升级版本，针对性解决了上述局限性，二者核心差异如下：</p>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>HTTP/1.0</th>\n<th>HTTP/1.1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>连接模式</td>\n<td>默认无连接（关闭 TCP）</td>\n<td>默认持久连接（Keep-Alive）</td>\n</tr>\n<tr>\n<td>Host 头部</td>\n<td>非标准（部分支持）</td>\n<td>强制要求（支持虚拟主机）</td>\n</tr>\n<tr>\n<td>缓存机制</td>\n<td>仅 <code>Expires</code>、<code>Pragma</code></td>\n<td>新增 <code>Cache-Control</code>、<code>ETag</code> 等</td>\n</tr>\n<tr>\n<td>管道化支持</td>\n<td>不支持（需等待前一响应）</td>\n<td>支持（批量发送请求，无序响应）</td>\n</tr>\n<tr>\n<td>状态码扩展</td>\n<td>少量状态码（如 200、404、500）</td>\n<td>新增 100 Continue、409 Conflict 等</td>\n</tr>\n<tr>\n<td>范围请求</td>\n<td>不支持（无法断点续传）</td>\n<td>支持 <code>Range</code> 头部（断点续传）</td>\n</tr>\n</tbody>\n</table>\n<h2>五、HTTP/1.0 的现状与意义</h2>\n<p>如今，HTTP/1.0 已几乎不再被主流 Web 服务使用，绝大多数服务器和客户端（浏览器）均支持 HTTP/1.1 及以上版本。但 HTTP/1.0 的历史意义不可替代：</p>\n<ol>\n<li>它是 HTTP 协议的<strong>首个标准化版本</strong>   ，统一了请求-响应格式，为不同厂商的客户端和服务器提供了兼容性基础；</li>\n<li>首次引入了请求方法、状态码、MIME 类型等核心概念，这些概念被后续版本继承并优化，成为 Web 协议的“基石”；</li>\n<li>暴露的局限性（如无连接、缓存不完善）直接推动了 HTTP/1.1 的设计，间接影响了 HTTP/2（二进制帧、多路复用）的演进。</li>\n</ol>\n<p>综上，HTTP/1.0 虽因技术局限性被淘汰，但其作为 Web 协议的“奠基者”，在 Web 发展史上具有不可磨灭的地位，理解其设计思想和缺陷，是掌握现代 Web 协议（如 HTTP/2、HTTP/3）的重要前提。</p>\n</div>'</script></body></html>