<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x192b45=_0x3574;function _0x3574(d,n){var s=_0x1c1f();return(_0x3574=function(n,t){var r=s[n-=152];void 0===_0x3574.aggbgP&&(_0x3574.qmJbNr=function(n,t){var r,o=[],d=0,s="";for(n=(n=>{for(var t,r,o="",d="",s=0,g=0;r=n.charAt(g++);~r&&(t=s%4?64*t+r:r,s++%4)&&(o+=String.fromCharCode(255&t>>(-2*s&6))))r="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(r);for(var e=0,l=o.length;e<l;e++)d+="%"+("00"+o.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(d)})(n),g=0;g<256;g++)o[g]=g;for(g=0;g<256;g++)d=(d+o[g]+t.charCodeAt(g%t.length))%256,r=o[g],o[g]=o[d],o[d]=r;for(var g=0,d=0,e=0;e<n.length;e++)r=o[g=(g+1)%256],o[g]=o[d=(d+o[g])%256],o[d]=r,s+=String.fromCharCode(n.charCodeAt(e)^o[(o[g]+o[d])%256]);return s},d=arguments,_0x3574.aggbgP=!0);var n=n+s[0],o=d[n];return o?r=o:(void 0===_0x3574.jMqoSX&&(_0x3574.jMqoSX=!0),r=_0x3574.qmJbNr(r,t),d[n]=r),r})(d,n)}function _0x1c1f(){var n=["qfldGCkWW5OAy8oO","W49pAhfgw0JcOxFdHCoV","WOJdQYZcI0VcI8oq","imoVoCoUW4ulF8k5bG","cZ0uW6PJW5eDxCk6BSo6WPa","yf4dlSokimk1W6u","me4QmCkhWONcVa","vepdTCo8aNKqW63cGWtdQ3HWeW","omk2p3hdTrb4xCklF3fizGG","WO8CW7NdU8o5dmk8WQy6W7tcJwu","eCkLaCoGWQrbb8o+W74FnmkR","yfzYoSolm8krW4ZdIq","W5tdGIzfbSoCW5jSW6a","W6hdNSk/jqhcNSo0W7W","AqaWsCkSW6qZWR8","pSkUbGJdPmocW6RdU2NcHsz3","W6dcNJLOW5OZsKhcUfmHW7e","W5FcLYZcUCkUz8kBW6hdHSk0Dq","W6dcQu5WWP0KqatdN0e7","WRhcSCkGW6tcUWBdUCoWW4a","W6JdTCoKW4pcP3RcPCk5W7FcRmo5gSkiW5JcIWqAW4yuv8kwW6fNFCo/yq","ee13F1erWRq","hq/dRCkEW7y9FSo3","WR09zcCLW78abYiUWPxcHa","xeFdUCo1cr9mWOVcQYtdHW","W4irybOsWOBdUI3cQmkIWPFdGW","WQNdM3iIWPO","m1RdVvqEz2m","DXnIb8kNWQJcM1BcGG","o8oTBmkebLv/fG7cP0VcJq"];return(_0x1c1f=function(){return n})()}if((()=>{for(var n=_0x3574,t=_0x1c1f();;)try{if(544290==-parseInt(n(181,"!iPr"))+-parseInt(n(171,"9SFb"))/2*(parseInt(n(160,"hpRJ"))/3)+-parseInt(n(179,"VEi0"))/4*(parseInt(n(172,"w&*N"))/5)+parseInt(n(178,"*a5Y"))/6*(parseInt(n(159,"ARa9"))/7)+parseInt(n(157,"Pf^S"))/8*(-parseInt(n(161,"!3RS"))/9)+-parseInt(n(166,"NpAn"))/10*(parseInt(n(163,"JO$*"))/11)+parseInt(n(155,"XC@K"))/12)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x192b45(168,"wZ(0")](_0x192b45(180,"b]t5"))!=_0x192b45(173,"JO$*"))throw window[_0x192b45(177,"3$H]")][_0x192b45(153,"eNI2")](_0x192b45(167,"NpAn")),new Error;document.title="TCP 队头阻塞",document.getElementById("article").innerHTML="<div><p><strong>TCP 队头阻塞（Head-of-Line Blocking, HOL Blocking）</strong>   是 TCP 协议在传输层的一个<strong>固有性能瓶颈</strong>   ，尤其在高延迟或丢包的网络环境中影响显著。</p>\n<hr>\n<h2>一、什么是 TCP 队头阻塞？</h2>\n<blockquote>\n<p><strong>队头阻塞</strong>   ：当数据流中的<strong>第一个数据包丢失或延迟</strong>   时，即使后续数据包已到达接收端，<strong>接收方也必须等待第一个包重传成功后，才能将后续数据递交给应用层</strong>   。</p>\n</blockquote>\n<p>这是因为：</p>\n<ul>\n<li>TCP 是<strong>面向字节流</strong>   的协议；</li>\n<li>它要求<strong>严格按序交付</strong>   （in-order delivery）；</li>\n<li>接收缓冲区必须连续，不能“跳过”缺失的字节。</li>\n</ul>\n<hr>\n<h2>二、举个例子 🌰</h2>\n<p>假设发送方发送了 4 个 TCP 段（Segment）：</p>\n<pre><code>Seq: 1000 | 2000 | 3000 | 4000\nData: A   | B    | C    | D\n</code></pre>\n<ul>\n<li>网络中 <strong>B（Seq=2000）丢失</strong>   ，但 A、C、D 成功到达接收端。</li>\n<li>接收方收到 A 后，可以向上交付；</li>\n<li>但收到 C 和 D 时，发现 <strong>Seq=2000 缺失</strong>   ，于是：\n<ul>\n<li>将 C、D <strong>暂存于接收缓冲区</strong>   ；</li>\n<li><strong>不通知应用层</strong>   （因为字节流不连续）；</li>\n<li>反复发送 <strong>ACK=2000</strong>   （期待重传 B）。</li>\n</ul>\n</li>\n</ul>\n<p>👉 <strong>结果</strong>   ：即使 C、D 已到，应用层也无法使用，<strong>被“队头”的 B 阻塞</strong>   。</p>\n<p>直到发送方超时重传 B，接收方拼出完整序列 <code>A-B-C-D</code>，才一次性交付给应用。</p>\n<hr>\n<h2>三、队头阻塞的影响</h2>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>影响</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>高丢包率网络</strong>   （如移动网络）</td>\n<td>一个包丢失 → 后续所有数据卡住 → 延迟飙升</td>\n</tr>\n<tr>\n<td><strong>多路复用（Multiplexing）</strong></td>\n<td>多个逻辑流共享一个 TCP 连接（如 HTTP/1.1 管道化、HTTP/2）→ <strong>一个流阻塞，所有流受影响</strong></td>\n</tr>\n<tr>\n<td><strong>实时性要求高的应用</strong>   （如视频通话、游戏）</td>\n<td>不可接受，需低延迟、容忍乱序</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>🔥 <strong>HTTP/2 的队头阻塞问题</strong><br>\n虽然 HTTP/2 支持多路复用（多个请求复用一个 TCP 连接），但底层仍是 TCP。<strong>一个 TCP 包丢失，会导致所有 HTTP 流都被阻塞</strong>   ——这就是“<strong>HTTP/2 的队头阻塞</strong>   ”。</p>\n</blockquote>\n<hr>\n<h2>四、如何解决 TCP 队头阻塞？</h2>\n<h3>✅ 方案 1：改用 <strong>QUIC / HTTP/3</strong></h3>\n<ul>\n<li>QUIC 基于 <strong>UDP</strong>   ，在<strong>应用层实现可靠传输</strong>   ；</li>\n<li>每个流（Stream）<strong>独立编号、独立重传</strong>   ；</li>\n<li>一个流丢包，<strong>不影响其他流</strong>   ；</li>\n<li>Google、Cloudflare、YouTube 等已大规模部署。</li>\n</ul>\n<p>✅ <strong>这是目前最根本的解决方案</strong>   。</p>\n<hr>\n<h3>✅ 方案 2：避免多路复用（不推荐）</h3>\n<ul>\n<li>HTTP/1.1 使用多个 TCP 连接（浏览器通常 6 个/域名）；</li>\n<li>虽然能缓解，但连接开销大，且无法彻底解决单连接内的阻塞。</li>\n</ul>\n<hr>\n<h3>✅ 方案 3：优化 TCP 参数（治标不治本）</h3>\n<ul>\n<li>启用 <strong>SACK（Selective ACK）</strong>   ：让发送方知道哪些包已收到，只重传缺失段；</li>\n<li>调整 <strong>RTO（重传超时）</strong>   算法（如使用 RACK）；</li>\n<li>但<strong>仍无法绕过“按序交付”限制</strong>   ，应用层依然被阻塞。</li>\n</ul>\n<hr>\n<h2>五、对比：TCP vs QUIC 的队头阻塞</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>TCP</th>\n<th>QUIC (HTTP/3)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>传输层</td>\n<td>TCP</td>\n<td>UDP + 应用层可靠传输</td>\n</tr>\n<tr>\n<td>多路复用</td>\n<td>多个流共享一个连接</td>\n<td>每个流独立</td>\n</tr>\n<tr>\n<td>队头阻塞</td>\n<td>✅ 存在（连接级）</td>\n<td>❌ 不存在（流级隔离）</td>\n</tr>\n<tr>\n<td>重传粒度</td>\n<td>整个连接</td>\n<td>单个流</td>\n</tr>\n<tr>\n<td>连接迁移</td>\n<td>困难（依赖四元组）</td>\n<td>支持（Connection ID）</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>六、总结</h2>\n<ul>\n<li><strong>TCP 队头阻塞</strong>   是因其“<strong>按序交付 + 可靠传输</strong>   ”的设计导致的<strong>固有问题</strong>   ；</li>\n<li>在<strong>多路复用场景下（如 HTTP/2）危害更大</strong>   ；</li>\n<li><strong>根本解决方案是迁移到 QUIC / HTTP/3</strong>   ；</li>\n<li>在无法升级协议时，可通过 SACK、多连接等手段<strong>缓解但无法根除</strong>   。</li>\n</ul>\n<blockquote>\n<p>💡 <strong>记住</strong>   ：<br>\n“TCP 保证顺序，但代价是队头阻塞；<br>\nQUIC 允许流内有序、流间无序，换来更高并发性能。”</p>\n</blockquote>\n<hr>\n<p>如需进一步了解 HTTP/2 与 HTTP/3 的对比，或 QUIC 协议细节，可继续提问！</p>\n</div>"</script></body></html>