<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x1083bf=_0x2bfe;function _0x156a(){var n=["WQmwW7JdPSolW7vICmkZACkzFSkt","W5hcQSoBWP16e8ofmw7cICkwWQqe","WQbxbdzZW5hdLG","WPeWWQNcMcldGCkSWPerkCkfDW","W5qkamo0zSkkF3DaWQewWRNcNW","lmkFWQTbhIyBxWRcNxVcJ8kDmSoNtSoPgSozW6tcTCoIW6rbzf4","WRiSaMVcPCkobSodW7vnW4yzWOy","WQO6WQKJW5G","W68RkmoFWPG5kq","W4b4utJdOSojECo+W50","W4FdKSoRWRy5WRBdT8kkWRLZigO","iaddOmo5WPxdJwz3WQTmW4uYWPe","W5CbnLNcPgJcHSoeWQhdPrbQ","W5hcO8kquuG/kq","pSomW4urfmoRWP8Hnh7cUSkCW7C","n1xcNKdcVJuc","WQ0EgbL0W4hdQW0","r33cUSohrmoHB8kCWP3dPZH2W6C","lapdPCo9WPpdHIXtWRT8W74E","W7P0WO5AW6pcG3GuWOekrvSr","W4OFBadcNmo0cW","g8o1mxlcO8k2W5ZdSCoiAmoEW7lcSG","W5GltCk/omohf2K","W7W6W5S5WR/dKYS","W610utZdPCotxCo1"];return(_0x156a=function(){return n})()}function _0x2bfe(o,n){var e=_0x156a();return(_0x2bfe=function(n,s){var t=e[n-=290];void 0===_0x2bfe.LJqenS&&(_0x2bfe.FqlsHT=function(n,s){var t,a=[],o=0,e="";for(n=(n=>{for(var s,t,a="",o="",e=0,l=0;t=n.charAt(l++);~t&&(s=e%4?64*s+t:t,e++%4)&&(a+=String.fromCharCode(255&s>>(-2*e&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var r=0,c=a.length;r<c;r++)o+="%"+("00"+a.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(o)})(n),l=0;l<256;l++)a[l]=l;for(l=0;l<256;l++)o=(o+a[l]+s.charCodeAt(l%s.length))%256,t=a[l],a[l]=a[o],a[o]=t;for(var l=0,o=0,r=0;r<n.length;r++)t=a[l=(l+1)%256],a[l]=a[o=(o+a[l])%256],a[o]=t,e+=String.fromCharCode(n.charCodeAt(r)^a[(a[l]+a[o])%256]);return e},o=arguments,_0x2bfe.LJqenS=!0);var n=n+e[0],a=o[n];return a?t=a:(void 0===_0x2bfe.bOEAec&&(_0x2bfe.bOEAec=!0),t=_0x2bfe.FqlsHT(t,s),o[n]=t),t})(o,n)}if((()=>{for(var n=_0x2bfe,s=_0x156a();;)try{if(453824==-parseInt(n(304,"F7Ag"))*(parseInt(n(292,"j[HH"))/2)+parseInt(n(313,"Mlc2"))/3+parseInt(n(308,"uPjU"))/4*(-parseInt(n(294,"ZozK"))/5)+parseInt(n(296,"1DIi"))/6+-parseInt(n(302,"c^Lo"))/7+parseInt(n(300,"bVRv"))/8+parseInt(n(299,"^&hW"))/9*(parseInt(n(312,"g]S&"))/10))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x1083bf(309,"O24]")](_0x1083bf(305,"c^Lo"))!=_0x1083bf(303,"]SpA"))throw window[_0x1083bf(295,"c^Lo")][_0x1083bf(311,")DyB")](_0x1083bf(301,"W)ef")),Error();document.title="Yoga 引擎",document.getElementById("article").innerHTML='<div><p>Yoga 引擎是 React Native 跨平台布局系统的核心，由 Facebook 基于 <strong>Flexbox 布局算法</strong>   开发的 <strong>跨平台布局引擎</strong>  （C++ 实现）。它负责将 React 组件的样式和布局属性转换为原生平台（iOS/Android）可理解的布局指令。以下是深度解析：</p>\n<hr>\n<h3>一、Yoga 的核心设计</h3>\n<h4>1. <strong>核心特性</strong></h4>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>跨平台</strong></td>\n<td>同一套布局规则在 iOS/Android/Web 上表现一致</td>\n</tr>\n<tr>\n<td><strong>Flexbox 实现</strong></td>\n<td>完整支持 CSS Flexbox 规范（部分属性除外）</td>\n</tr>\n<tr>\n<td><strong>高性能</strong></td>\n<td>C++ 实现，计算效率高，内存占用低</td>\n</tr>\n<tr>\n<td><strong>无 UI 依赖</strong></td>\n<td>纯布局计算，不依赖任何平台的 UI 系统</td>\n</tr>\n</tbody>\n</table>\n<h4>2. <strong>与 React Native 的集成</strong></h4>\n<pre><code class="language-mermaid">graph TB\n  JS[React 组件] --&gt;|样式/布局属性| Yoga[Yoga 引擎]\n  Yoga --&gt;|布局结果| iOS[UIKit]\n  Yoga --&gt;|布局结果| Android[ViewGroup]\n</code></pre>\n<hr>\n<h3>二、Yoga 的工作流程</h3>\n<h4>1. <strong>布局计算步骤</strong></h4>\n<ol>\n<li><strong>样式传递</strong>  ：<br>\nReact 组件的 <code>style</code> 属性通过序列化传递给 Yoga。<pre><code class="language-jsx">&lt;<span class="hljs-title class_">View</span> style={{ <span class="hljs-attr">flex</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">padding</span>: <span class="hljs-number">10</span> }} /&gt;\n</code></pre>\n</li>\n<li><strong>节点树构建</strong>  ：<br>\nYoga 在原生侧创建对应的 <strong>YogaNode</strong>   树，每个节点存储布局属性。</li>\n<li><strong>布局计算</strong>  ：<br>\nYoga 递归计算每个节点的：\n<ul>\n<li>尺寸（width/height）</li>\n<li>位置（top/left）</li>\n<li>边距（margin/padding）</li>\n</ul>\n<pre><code class="language-cpp"><span class="hljs-built_in">YGNodeCalculateLayout</span>(yogaNode, availableWidth, availableHeight, direction);\n</code></pre>\n</li>\n<li><strong>结果传递</strong>  ：<br>\n计算后的布局信息（<code>{ x, y, width, height }</code>）传递给原生视图系统。</li>\n</ol>\n<h4>2. <strong>关键计算规则</strong></h4>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>Yoga 处理逻辑</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>flex: 1</code></td>\n<td>按比例分配剩余空间</td>\n</tr>\n<tr>\n<td><code>margin: &quot;auto&quot;</code></td>\n<td>在交叉轴上居中</td>\n</tr>\n<tr>\n<td><code>position: &quot;absolute&quot;</code></td>\n<td>脱离 Flex 流，相对于父节点定位</td>\n</tr>\n<tr>\n<td><code>flexWrap: &quot;wrap&quot;</code></td>\n<td>超出容器宽度时换行</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>三、与 CSS Flexbox 的差异</h3>\n<p>虽然 Yoga 实现了大部分 Flexbox 规范，但存在 <strong>平台性差异</strong>   和 <strong>限制</strong>  ：</p>\n<h4>1. <strong>不支持的特性</strong></h4>\n<table>\n<thead>\n<tr>\n<th>CSS 特性</th>\n<th>Yoga 状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>gap</code> 属性</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td><code>aspect-ratio</code></td>\n<td>部分支持（需显式设置 <code>height</code> 或 <code>width</code>）</td>\n</tr>\n<tr>\n<td><code>min-content/max-content</code></td>\n<td>不支持</td>\n</tr>\n</tbody>\n</table>\n<h4>2. <strong>平台行为差异</strong></h4>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>iOS/Android</th>\n<th>Web</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>flexDirection: &quot;row&quot;</code> 的基线对齐</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td><code>flex: 1</code> 的默认最小尺寸</td>\n<td>无最小尺寸</td>\n<td>遵守 <code>min-width/min-height</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>四、性能优化策略</h3>\n<h4>1. <strong>减少布局计算深度</strong></h4>\n<pre><code class="language-jsx"><span class="hljs-comment">// 优化前：嵌套过深</span>\n&lt;<span class="hljs-title class_">View</span>&gt;\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">flex:</span> <span class="hljs-attr">1</span> }} /&gt;</span> {/* 触发多次计算 */}\n  <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>\n&lt;/<span class="hljs-title class_">View</span>&gt;\n\n<span class="hljs-comment">// 优化后：扁平化结构</span>\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">flex:</span> <span class="hljs-attr">1</span> }} /&gt;</span></span>\n</code></pre>\n<h4>2. <strong>避免动态布局属性</strong></h4>\n<pre><code class="language-jsx"><span class="hljs-comment">// 避免在动画中频繁修改布局属性</span>\n&lt;<span class="hljs-title class_">View</span> style={{\n  <span class="hljs-attr">width</span>: animValue.<span class="hljs-title function_">interpolate</span>({ ... }) <span class="hljs-comment">// ❌ 触发 Yoga 重计算</span>\n}} /&gt;\n\n<span class="hljs-comment">// 改用 transform（不触发布局计算）</span>\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span>\n  <span class="hljs-attr">transform:</span> [{ <span class="hljs-attr">scale:</span> <span class="hljs-attr">animValue</span> }] // ✅\n}} /&gt;</span></span>\n</code></pre>\n<h4>3. <strong>使用 <code>onLayout</code> 谨慎</strong></h4>\n<pre><code class="language-jsx">&lt;<span class="hljs-title class_">View</span>\n  onLayout={<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">nativeEvent</span>.<span class="hljs-property">layout</span>)} <span class="hljs-comment">// 每次布局变化都会触发</span>\n/&gt;\n</code></pre>\n<hr>\n<h3>五、调试技巧</h3>\n<h4>1. <strong>可视化 Shadow Tree</strong></h4>\n<p>在 <strong>Flipper</strong>   中安装 <code>React Native Layout Inspector</code> 插件，可查看 Yoga 计算的布局树。</p>\n<h4>2. <strong>边界问题排查</strong></h4>\n<ul>\n<li><strong>黄色警告框</strong>  ：表示 Yoga 计算出的布局超出父容器。</li>\n<li><strong>红色错误框</strong>  ：无效的布局属性（如 <code>NaN</code> 值）。</li>\n</ul>\n<h4>3. <strong>打印布局信息</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">UIManager</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;\n\n<span class="hljs-title class_">UIManager</span>.<span class="hljs-title function_">measure</span>(viewRef, <span class="hljs-function">(<span class="hljs-params">x, y, width, height</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>({ x, y, width, height });\n});\n</code></pre>\n<hr>\n<h3>六、Yoga 的未来发展</h3>\n<p>随着 React Native 的 <strong>新架构（Fabric）</strong>   推进：</p>\n<ol>\n<li><strong>同步布局计算</strong>  ：通过 JSI 直接调用 Yoga，减少序列化开销。</li>\n<li><strong>更精细的更新</strong>  ：支持部分子树重计算（而非整树刷新）。</li>\n<li><strong>WASM 支持</strong>  ：探索在 Web 端使用编译为 WASM 的 Yoga。</li>\n</ol>\n<hr>\n<h3>总结</h3>\n<p>Yoga 引擎是 React Native 跨平台一致性的基石：</p>\n<ul>\n<li>✅ <strong>标准化布局</strong>  ：统一 iOS/Android 的 Flexbox 行为</li>\n<li>⚡ <strong>高性能计算</strong>  ：C++ 实现，适合移动端资源限制</li>\n<li>🔧 <strong>可调试性强</strong>  ：与 React DevTools/Flipper 深度集成</li>\n</ul>\n<p>理解 Yoga 的工作原理，能帮助你写出更高性能的 React Native 布局代码。</p>\n</div>'</script></body></html>