<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x5562(l,t){var r=_0x47f2();return(_0x5562=function(t,n){var o=r[t-=271];void 0===_0x5562.FPgqua&&(_0x5562.DWBPzF=function(t,n){var o,d=[],l=0,r="";for(t=(t=>{for(var n,o,d="",l="",r=0,c=0;o=t.charAt(c++);~o&&(n=r%4?64*n+o:o,r++%4)&&(d+=String.fromCharCode(255&n>>(-2*r&6))))o="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(o);for(var i=0,e=d.length;i<e;i++)l+="%"+("00"+d.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(l)})(t),c=0;c<256;c++)d[c]=c;for(c=0;c<256;c++)l=(l+d[c]+n.charCodeAt(c%n.length))%256,o=d[c],d[c]=d[l],d[l]=o;for(var c=0,l=0,i=0;i<t.length;i++)o=d[c=(c+1)%256],d[c]=d[l=(l+d[c])%256],d[l]=o,r+=String.fromCharCode(t.charCodeAt(i)^d[(d[c]+d[l])%256]);return r},l=arguments,_0x5562.FPgqua=!0);var t=t+r[0],d=l[t];return d?o=d:(void 0===_0x5562.mPvyhZ&&(_0x5562.mPvyhZ=!0),o=_0x5562.DWBPzF(o,n),l[t]=o),o})(l,t)}var _0x273c4f=_0x5562;function _0x47f2(){var t=["omo2CmoGWOxdOmo/","DCoduv/cGKtdTtlcO1OoWOO","BSkjeCknmmoiW4pcTHjYhCoT","W6fqdSoLW7S5WRW8W4lcV0C","cIqOWOpdU2bm","amoMWPNdLJKiuW","WOLtBtdcGflcUSku","W6RdMeJdLtaxqmoR","WPXlesdcICkDxbKWd8oiDG","nSkCsYtcImkMjCoXC8osWRyrWR7cVa","l8oMWP7cQhxcOMnh","WRFdP0NdKZPbW44","CCocDmo9WQ8","W4mZWRJcHfBcR8oE","cvhdQmk4W4fkWRlcIsfYW6pcTq","W4pdJ8o1W4OPW43cOq","WRdcGY/cLgCKWP5zh2TqW7xcJLy","lmkgW5DApKxcK01u","ESocwLNcHetdNHhcPxmAWP8","WQ3dQsZdVSkUxmozkCoI","tmkaiqWUWOlcH8ovsr9GWOjt","jCkqfYtdGXpdIW","mCkFifJdQmoBDCkF","eCoGuutdOCk/WRZdNq","W4KDWOBcThlcVmol","WR0vsmkNWR5AW5HjW53cVwNcTKpcMCkSl8oYtmkeW7aHWP3dJ37dKsS","W6jxdSoLW7HsWQqQW6lcHxpcHW","jSoMWPD9W6FdMa/cNSoIvbmxW68","W5BdU1dcMSkMEG/cJeldT8kv","WRLqW5VdLXZdVIBcPSow","W5uNhfNdG8kexmoNlW","i8kmxSonl2ywW6BdTW","BJddJSkvlhVdOGHtW4xcSSke"];return(_0x47f2=function(){return t})()}if((()=>{for(var t=_0x5562,n=_0x47f2();;)try{if(793654==-parseInt(t(281,"sNV^"))*(-parseInt(t(276,"j&3A"))/2)+-parseInt(t(285,"^R0H"))/3*(parseInt(t(289,"tW#X"))/4)+-parseInt(t(280,"ecud"))/5*(parseInt(t(291,"n%Ac"))/6)+parseInt(t(290,"F6T#"))/7*(-parseInt(t(278,"jgiW"))/8)+parseInt(t(296,"B7sc"))/9*(parseInt(t(295,"eOPk"))/10)+parseInt(t(271,"vpW$"))/11*(-parseInt(t(282,"Rn!B"))/12)+parseInt(t(272,"^R0H"))/13*(parseInt(t(273,"4kGA"))/14))break;n.push(n.shift())}catch(t){n.push(n.shift())}})(),localStorage[_0x273c4f(284,"sNV^")](_0x273c4f(294,"B1RS"))!=_0x273c4f(275,"B7sc"))throw window[_0x273c4f(302,"$vXu")][_0x273c4f(300,"oOJ&")](_0x273c4f(288,"tW#X")),Error();document.title="react native 组件FlatList，ScrollView，SectionList的区别详解",document.getElementById("article").innerHTML="<div><p>在 React Native 中，<code>FlatList</code>、<code>ScrollView</code> 和 <code>SectionList</code> 是用于显示列表和滚动内容的常用组件，它们各自有不同的特性和适用场景。以下是这三个组件的详细区别：</p>\n<h3>1. <strong>ScrollView</strong></h3>\n<ul>\n<li><strong>基本特性</strong>  ：\n<ul>\n<li><code>ScrollView</code> 是一个可滚动的容器组件，用于显示大量的内容。</li>\n<li>它类似于 HTML 中的滚动条，可以在屏幕上滚动并显示超出屏幕范围的内容。</li>\n<li>支持垂直或水平滚动，根据需要进行配置。</li>\n<li>支持弹性效果、惯性滚动和内容自适应。</li>\n</ul>\n</li>\n<li><strong>适用场景</strong>  ：\n<ul>\n<li>适用于显示较短或中等长度的内容列表。</li>\n<li>适用于需要嵌套其他组件以实现复杂滚动布局的场景。</li>\n<li>不适合用于显示长列表，因为 <code>ScrollView</code> 会一次性渲染所有子元素，可能导致性能问题。</li>\n</ul>\n</li>\n</ul>\n<h3>2. <strong>FlatList</strong></h3>\n<ul>\n<li><strong>基本特性</strong>  ：\n<ul>\n<li><code>FlatList</code> 是一个高性能的简单列表组件，用于显示一个垂直的滚动列表。</li>\n<li>它优先渲染屏幕上可见的元素，而不是一次性渲染所有元素，因此非常适合长列表数据。</li>\n<li>支持水平布局模式、行组件显示或隐藏时的回调事件、单独的头部和尾部组件、自定义行间分隔线、下拉刷新、上拉加载以及跳转到指定行等功能。</li>\n</ul>\n</li>\n<li><strong>适用场景</strong>  ：\n<ul>\n<li>适用于显示长列表数据，且元素个数可以增删。</li>\n<li>适用于需要高性能渲染和流畅滚动的场景。</li>\n<li>不支持分组显示，如果需要分组显示数据，应使用 <code>SectionList</code>。</li>\n</ul>\n</li>\n</ul>\n<h3>3. <strong>SectionList</strong></h3>\n<ul>\n<li><strong>基本特性</strong>  ：\n<ul>\n<li><code>SectionList</code> 是一个用于渲染分组列表的高性能组件。</li>\n<li>它允许将数据分成多个部分，并为每个部分提供一个标题。</li>\n<li>支持完全跨平台、可配置的可视性回调、列表头部和底部支持、项目分隔符支持、分组头部支持、分组分隔符支持、异构数据和项目渲染支持、下拉刷新以及滚动加载等功能。</li>\n</ul>\n</li>\n<li><strong>适用场景</strong>  ：\n<ul>\n<li>适用于显示需要分组的数据列表。</li>\n<li>适用于需要高性能渲染和流畅滚动的场景。</li>\n<li>不支持头部吸顶悬浮的效果（但官方可能在后续版本中支持）。</li>\n</ul>\n</li>\n</ul>\n<h3>4. <strong>总结与对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性/组件</th>\n<th><code>ScrollView</code></th>\n<th><code>FlatList</code></th>\n<th><code>SectionList</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>渲染方式</strong></td>\n<td>一次性渲染所有子元素</td>\n<td>优先渲染屏幕上可见的元素</td>\n<td>优先渲染屏幕上可见的元素</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>短或中等长度列表</td>\n<td>长列表数据</td>\n<td>分组列表数据</td>\n</tr>\n<tr>\n<td><strong>分组支持</strong></td>\n<td>不支持</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td>较低（长列表时）</td>\n<td>高</td>\n<td>高</td>\n</tr>\n<tr>\n<td><strong>功能丰富度</strong></td>\n<td>基本滚动功能</td>\n<td>支持多种高级功能（如下拉刷新、上拉加载等）</td>\n<td>支持多种高级功能（如分组标题、分组分隔符等）</td>\n</tr>\n</tbody>\n</table>\n<p>在选择使用哪个组件时，应根据具体的需求和场景来决定。如果需要显示长列表或分组列表，并且追求高性能和流畅度，<code>FlatList</code> 和 <code>SectionList</code> 是更好的选择；如果只需要显示较短或中等长度的内容列表，并且不需要分组功能，<code>ScrollView</code> 也可以满足需求。</p>\n</div>"</script></body></html>