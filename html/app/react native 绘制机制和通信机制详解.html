<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x592e(r,n){var l=_0x17a6();return(_0x592e=function(n,t){var s=l[n-=367];void 0===_0x592e.wgpkgf&&(_0x592e.CTxdsg=function(n,t){var s,o=[],r=0,l="";for(n=(n=>{for(var t,s,o="",r="",l=0,a=0;s=n.charAt(a++);~s&&(t=l%4?64*t+s:s,l++%4)&&(o+=String.fromCharCode(255&t>>(-2*l&6))))s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(s);for(var e=0,i=o.length;e<i;e++)r+="%"+("00"+o.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(r)})(n),a=0;a<256;a++)o[a]=a;for(a=0;a<256;a++)r=(r+o[a]+t.charCodeAt(a%t.length))%256,s=o[a],o[a]=o[r],o[r]=s;for(var a=0,r=0,e=0;e<n.length;e++)s=o[a=(a+1)%256],o[a]=o[r=(r+o[a])%256],o[r]=s,l+=String.fromCharCode(n.charCodeAt(e)^o[(o[a]+o[r])%256]);return l},r=arguments,_0x592e.wgpkgf=!0);var n=n+l[0],o=r[n];return o?s=o:(void 0===_0x592e.rNBFnj&&(_0x592e.rNBFnj=!0),s=_0x592e.CTxdsg(s,t),r[n]=s),s})(r,n)}var _0xd8e396=_0x592e;if((()=>{for(var n=_0x592e,t=_0x17a6();;)try{if(117868==-parseInt(n(368,"#YJ]"))+parseInt(n(394,"X&e!"))/2*(parseInt(n(370,"7$fH"))/3)+-parseInt(n(367,"96al"))/4*(-parseInt(n(375,"Cqll"))/5)+parseInt(n(372,"(Z7o"))/6*(-parseInt(n(391,"#kDo"))/7)+-parseInt(n(385,"QwHn"))/8*(-parseInt(n(373,"(Z7o"))/9)+parseInt(n(382,"QwHn"))/10+-parseInt(n(386,"!2pS"))/11)break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0xd8e396(380,"nwaC")](_0xd8e396(374,"a9tN"))!=_0xd8e396(393,"!2pS"))throw window[_0xd8e396(369,"&Gb5")][_0xd8e396(376,"!2pS")](_0xd8e396(377,"bAzF")),Error();function _0x17a6(){var n=["W5OlW4SUvNmZWPzwWRe+","WOtcRsOWWPtcTSoHm2ubAq","D8kAxmk1W74vk8kqWOa","D8kAvmo1WQXXr8koWRtcSxddJxa","WRT/FmoADSolEr3dIa","WPihWP7cM8osWPy2aWBdTSoy","WQhdUCokE8kKkmkO","WR4HfCoRW7lcP8omux8ZFCoTs3BcVmkQWPS3W5fDoaFcKatcVJi","W6rLwCkUWRNcPmkpfuK/FCon","FZVdLmkNoND+Ba","WOiTWPRcMGhdTCkF","uh9uW6lcLKdcOCkHk8oXdhu","Eu7cOSouWOlcQ8k4mHXVaHnx","EKFdTSkOW5hdRCo+mG","WPS+W5qQbZBcOCoi","EuNdMSklW5NdRCoAnq","W6lcPmkniSo9EmkiaKHtWOC8","W45VFqhcGhJcMYBcRrnj","W4Sbk8ogjSkolSklgmoaW4ipWPu","W6rOWQvCWRGWBCkOW7y","rSoaWR3cISkcl2JdMW/cTmkM","WO7dLSo8DMizWPBdLCozm3q","W7/dMWVdUwNdH8kzhSocy8kSlq8","WQpdQCojzmk8","WRVcSmkCWOldGmkjW5So","W6WcW6ddVG10q8oM","ASkzc8ourmk4nHBcPX3cV8oj","zGWtWQxdQWvsW7S"];return(_0x17a6=function(){return n})()}document.title="react native 绘制机制和通信机制详解",document.getElementById("article").innerHTML='<div><p>React Native 的 <strong>绘制机制</strong>   和 <strong>通信机制</strong>   是其实现跨平台高性能的核心设计。以下是深度解析：</p>\n<hr>\n<h3>一、绘制机制（Rendering）</h3>\n<p>React Native 的 UI 渲染分为 <strong>JavaScript 线程</strong>   和 <strong>原生（Native）线程</strong>   协作完成，通过 <strong>异步桥接</strong>   实现跨平台一致性。</p>\n<h4>1. <strong>分层架构</strong></h4>\n<table>\n<thead>\n<tr>\n<th>层级</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>JavaScript 层</strong></td>\n<td>运行 React 逻辑，生成虚拟 DOM（React Element 树）</td>\n</tr>\n<tr>\n<td><strong>Shadow Tree 层</strong></td>\n<td>由 Yoga 布局引擎计算的中间布局树（C++）</td>\n</tr>\n<tr>\n<td><strong>原生 UI 层</strong></td>\n<td>最终映射到 iOS/Android 原生视图（UIView/View）</td>\n</tr>\n</tbody>\n</table>\n<h4>2. <strong>渲染流程</strong></h4>\n<ol>\n<li><strong>JS 线程</strong>  ：\n<ul>\n<li>执行 React 组件逻辑，生成虚拟 DOM。</li>\n<li>通过 <strong>序列化</strong>   将 UI 描述（属性、样式、层级关系）传递给原生模块。</li>\n</ul>\n</li>\n<li><strong>原生线程</strong>  ：\n<ul>\n<li><strong>Shadow Tree 计算</strong>  ：Yoga 引擎解析样式和布局，生成平台无关的布局树。</li>\n<li><strong>原生视图操作</strong>  ：将布局结果转换为 <code>UIView</code>（iOS）或 <code>View</code>（Android）实例。</li>\n<li><strong>渲染到屏幕</strong>  ：由系统 Compositor 合成最终像素。</li>\n</ul>\n</li>\n</ol>\n<h4>3. <strong>关键优化</strong></h4>\n<ul>\n<li><strong>批量更新</strong>  ：合并多个 JS 线程的 UI 更新请求，减少跨线程通信。</li>\n<li><strong>异步布局</strong>  ：Yoga 计算在后台线程执行，不阻塞主线程。</li>\n<li><strong>视图复用</strong>  ：相同类型的组件复用原生视图实例。</li>\n</ul>\n<h4>4. <strong>平台差异处理</strong></h4>\n<table>\n<thead>\n<tr>\n<th>平台</th>\n<th>实现方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>iOS</strong></td>\n<td>通过 Objective-C/Swift 的 <code>RCTUIManager</code> 创建/更新 <code>UIView</code></td>\n</tr>\n<tr>\n<td><strong>Android</strong></td>\n<td>通过 Java/Kotlin 的 <code>UIManagerModule</code> 操作 <code>ViewGroup</code></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>二、通信机制（Communication）</h3>\n<p>React Native 的 <strong>JS 与原生代码交互</strong>   基于 <strong>异步消息队列</strong>   和 <strong>序列化桥接</strong>  。</p>\n<h4>1. <strong>三层通信模型</strong></h4>\n<pre><code class="language-mermaid">graph LR\n  JS[JavaScript] --&gt;|JSON| Bridge[Bridge]\n  Bridge --&gt;|Serialized| Native[iOS/Android]\n  Native --&gt;|Events| Bridge\n  Bridge --&gt;|JSON| JS\n</code></pre>\n<h4>2. <strong>通信方式</strong></h4>\n<h5>a) <strong>JS 调用原生（Native Modules）</strong></h5>\n<ol>\n<li><strong>方法调用</strong>  ：<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NativeModules</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;\n<span class="hljs-title class_">NativeModules</span>.<span class="hljs-property">CameraModule</span>.<span class="hljs-title function_">takePhoto</span>();\n</code></pre>\n<ul>\n<li><strong>流程</strong>  ：\n<ol>\n<li>JS 线程将调用序列化为 JSON。</li>\n<li>通过 Bridge 传递到原生模块队列。</li>\n<li>原生模块解析并执行对应方法。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><strong>性能优化</strong>  ：\n<ul>\n<li><strong>TurboModules</strong>  （新架构）：直接 C++ JSI 调用，跳过 JSON 序列化。</li>\n</ul>\n</li>\n</ol>\n<h5>b) <strong>原生调用 JS（Event Emitter）</strong></h5>\n<ol>\n<li><strong>事件触发</strong>  ：<pre><code class="language-java"><span class="hljs-comment">// Android 示例</span>\nreactContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)\n    .emit(<span class="hljs-string">&quot;onScanResult&quot;</span>, result);\n</code></pre>\n<ul>\n<li><strong>流程</strong>  ：\n<ol>\n<li>原生模块将事件数据序列化。</li>\n<li>通过 Bridge 发送到 JS 事件队列。</li>\n<li>JS 线程的 <code>NativeEventEmitter</code> 接收并处理。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h5>c) <strong>回调与 Promise</strong></h5>\n<pre><code class="language-javascript"><span class="hljs-comment">// JS 端</span>\n<span class="hljs-title class_">NativeModules</span>.<span class="hljs-property">FileSystem</span>.<span class="hljs-title function_">readFile</span>(path, <span class="hljs-function">(<span class="hljs-params">error, content</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(content);\n});\n\n<span class="hljs-comment">// 原生端（Android 示例）</span>\n@<span class="hljs-title class_">ReactMethod</span>\npublic <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> path, Callback callback</span>) {\n  <span class="hljs-keyword">try</span> {\n    callback.<span class="hljs-title function_">invoke</span>(<span class="hljs-literal">null</span>, <span class="hljs-title class_">Files</span>.<span class="hljs-title function_">read</span>(path));\n  } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {\n    callback.<span class="hljs-title function_">invoke</span>(e.<span class="hljs-title function_">getMessage</span>(), <span class="hljs-literal">null</span>);\n  }\n}\n</code></pre>\n<h4>3. <strong>新架构（Fabric &amp; JSI）的改进</strong></h4>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>旧架构（Bridge）</th>\n<th>新架构（JSI）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>通信方式</strong></td>\n<td>异步 JSON 序列化</td>\n<td>直接内存共享</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td>高延迟（~1ms）</td>\n<td>低延迟（~0.01ms）</td>\n</tr>\n<tr>\n<td><strong>线程模型</strong></td>\n<td>多线程队列</td>\n<td>同步/异步可选</td>\n</tr>\n<tr>\n<td><strong>TurboModules</strong></td>\n<td>不支持</td>\n<td>按需加载原生模块</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>三、关键性能瓶颈与解决方案</h3>\n<h4>1. <strong>渲染性能</strong></h4>\n<ul>\n<li><strong>问题</strong>  ：频繁 UI 更新导致 Bridge 拥堵。</li>\n<li><strong>解决</strong>  ：\n<ul>\n<li>使用 <code>useMemo</code>/<code>React.memo</code> 减少不必要的重新渲染。</li>\n<li>复杂动画使用 <code>react-native-reanimated</code>（绕过 Bridge）。</li>\n</ul>\n</li>\n</ul>\n<h4>2. <strong>通信延迟</strong></h4>\n<ul>\n<li><strong>问题</strong>  ：大量小数据包序列化开销。</li>\n<li><strong>解决</strong>  ：\n<ul>\n<li>批量更新（如 <code>UIManager.setChildren</code>）。</li>\n<li>迁移到 JSI（如 <code>react-native-skia</code> 直接 C++ 绘图）。</li>\n</ul>\n</li>\n</ul>\n<h4>3. <strong>内存占用</strong></h4>\n<ul>\n<li><strong>问题</strong>  ：JS 与原生双份数据存储。</li>\n<li><strong>解决</strong>  ：\n<ul>\n<li>使用 <code>hermes-engine</code> 减少 JS 内存占用。</li>\n<li>原生模块懒加载。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>四、调试工具</h3>\n<ol>\n<li><strong>React DevTools</strong>  ：监控虚拟 DOM 更新。</li>\n<li><strong>Flipper</strong>  ：\n<ul>\n<li>查看 Bridge 通信日志。</li>\n<li>可视化 Shadow Tree 布局。</li>\n</ul>\n</li>\n<li><strong>Systrace</strong>  ：分析线程阻塞和渲染耗时。</li>\n</ol>\n<hr>\n<h3>总结</h3>\n<p>React Native 的绘制和通信机制是其跨平台能力的核心：</p>\n<ul>\n<li><strong>绘制</strong>  ：通过 Shadow Tree 和 Yoga 实现布局一致性。</li>\n<li><strong>通信</strong>  ：旧架构依赖异步 Bridge，新架构（JSI）实现零拷贝交互。</li>\n<li><strong>优化方向</strong>  ：减少跨线程通信、利用原生能力、渐进迁移到 Fabric。</li>\n</ul>\n</div>'</script></body></html>