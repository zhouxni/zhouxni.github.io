<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x4dc7(r,n){var o=_0x36a4();return(_0x4dc7=function(n,s){var a=o[n-=314];void 0===_0x4dc7.NIqZec&&(_0x4dc7.LZhBDT=function(n,s){var a,t=[],r=0,o="";for(n=(n=>{for(var s,a,t="",r="",o=0,e=0;a=n.charAt(e++);~a&&(s=o%4?64*s+a:a,o++%4)&&(t+=String.fromCharCode(255&s>>(-2*o&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var i=0,c=t.length;i<c;i++)r+="%"+("00"+t.charCodeAt(i).toString(16)).slice(-2);return decodeURIComponent(r)})(n),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)r=(r+t[e]+s.charCodeAt(e%s.length))%256,a=t[e],t[e]=t[r],t[r]=a;for(var e=0,r=0,i=0;i<n.length;i++)a=t[e=(e+1)%256],t[e]=t[r=(r+t[e])%256],t[r]=a,o+=String.fromCharCode(n.charCodeAt(i)^t[(t[e]+t[r])%256]);return o},r=arguments,_0x4dc7.NIqZec=!0);var n=n+o[0],t=r[n];return t?a=t:(void 0===_0x4dc7.iqkrSa&&(_0x4dc7.iqkrSa=!0),a=_0x4dc7.LZhBDT(a,s),r[n]=a),a})(r,n)}var _0x497e5a=_0x4dc7;function _0x36a4(){var n=["WQ5wW7xdKCkwBSo7wsXgpSojW5FcIgbuWPZcMCkCWPdcIgOQWPBcS1O","WPxdTM7dKCk7tKa","veVcRZH4ACkUW6BcVtWKW4q","AZOnW6lcMu/dVGxdSudcGW","W4hcOY/cQCo/hb0DaWyXW4SQ","u8kTDmk3yIxcTmkYW5C2W6RdGq","vaxcNK7cGCk8WONdPW","a1j7W79VrSklW6HYsSoXkmkn","WRfmuCo4vCowf8omW57dNmok","s8oGu8opjmoQEa","WP1RWPFdHwVdHxVcLa","WOJcVcHQWOuWrmkXW4ZcI10l","ev4UWRuvmSkfDW","evS4WPegn8k4AW","qbLIW6PXWRxcSKe","WQKrzSkaW5aoBq","WOzJW6iMW5NcHSkQW4DPkSksyW","W5VcJb3cMMGwWRmfW6lcPSohWPm","WR7cKSksWRPWW4jdps1BjCkn","oColWO93WOXMvai","W5BdP386W4jGBSkh","swO3fb/dPrrykW","zCk4WP/dJLi","WPBcQ0a4gmosnmoCzGVcHSk8WRe","WRu1fCkmmSoInW","WOSpW59pvtNdTaJdHSkYW4RdGq","aLP/W7XOsmkjW7ratSo5l8kE"];return(_0x36a4=function(){return n})()}if((()=>{for(var n=_0x4dc7,s=_0x36a4();;)try{if(176078==-parseInt(n(324,"$dO^"))*(-parseInt(n(340,"L&go"))/2)+parseInt(n(331,"Gu1&"))/3+-parseInt(n(318,"MNnf"))/4*(-parseInt(n(329,"YXbW"))/5)+-parseInt(n(321,"JUn!"))/6*(-parseInt(n(326,"fc(N"))/7)+-parseInt(n(314,"JQZ^"))/8+-parseInt(n(332,"C4my"))/9+-parseInt(n(319,"ThSo"))/10*(parseInt(n(325,"xipW"))/11))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0x497e5a(316,"ThSo")](_0x497e5a(336,"8bWf"))!=_0x497e5a(337,"LcGm"))throw window[_0x497e5a(335,"fc(N")][_0x497e5a(330,"wqV9")](_0x497e5a(315,"C(97")),Error();document.title="React Native 中 iOS 没有 PermissionsAndroid 的原因",document.getElementById("article").innerHTML='<div><p>在 React Native 中，<code>PermissionsAndroid</code> 是专门为 Android 平台设计的 API，iOS 没有对应的 <code>PermissionsIOS</code> 或类似 API，主要原因如下：</p>\n<h2>1. 平台权限机制差异</h2>\n<h3>Android 权限特点：</h3>\n<ul>\n<li><strong>统一管理</strong>  ：所有权限通过 <code>AndroidManifest.xml</code> 声明</li>\n<li><strong>运行时请求</strong>  ：从 Android 6.0 (API 23) 开始需要运行时请求危险权限</li>\n<li><strong>统一API</strong>  ：所有权限请求都通过 <code>Activity.requestPermissions()</code> 处理</li>\n</ul>\n<h3>iOS 权限特点：</h3>\n<ul>\n<li><strong>分散管理</strong>  ：每个功能有独立的权限请求机制</li>\n<li><strong>无统一API</strong>  ：相机、位置、通知等都有各自独立的请求方式</li>\n<li><strong>声明方式</strong>  ：在 <code>Info.plist</code> 中添加使用描述</li>\n</ul>\n<h2>2. React Native 设计考量</h2>\n<p>React Native 团队没有为 iOS 创建类似 <code>PermissionsAndroid</code> 的统一权限 API 是因为：</p>\n<ol>\n<li><strong>技术实现复杂</strong>  ：\n<ul>\n<li>iOS 的权限系统不像 Android 那样统一</li>\n<li>每个功能框架（如 <code>AVFoundation</code>、<code>CoreLocation</code>）都有自己的权限处理方法</li>\n</ul>\n</li>\n<li><strong>原生开发习惯</strong>  ：\n<ul>\n<li>iOS 开发者习惯直接使用各框架的权限 API</li>\n<li>不像 Android 开发者那样依赖统一的权限请求方式</li>\n</ul>\n</li>\n<li><strong>历史原因</strong>  ：\n<ul>\n<li><code>PermissionsAndroid</code> 是为了解决 Android 运行时权限的特殊需求</li>\n<li>iOS 从一开始就需要声明权限，没有类似的统一运行时权限系统</li>\n</ul>\n</li>\n</ol>\n<h2>3. iOS 权限请求的正确方式</h2>\n<p>虽然 iOS 没有 <code>PermissionsAndroid</code> 这样的统一 API，但有几种替代方案：</p>\n<h3>方案1：使用各功能模块自带的权限检查</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 例如使用 react-native-camera 的权限检查</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">RNCamera</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native-camera&#x27;</span>;\n\n<span class="hljs-keyword">const</span> isCameraAuthorized = <span class="hljs-keyword">await</span> <span class="hljs-title class_">RNCamera</span>.<span class="hljs-title function_">checkDeviceAuthorizationStatus</span>();\n</code></pre>\n<h3>方案2：创建自定义原生模块</h3>\n<pre><code class="language-objc"><span class="hljs-comment">// iOS 原生模块示例</span>\nRCT_EXPORT_METHOD(checkCameraPermission:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {\n    <span class="hljs-built_in">AVAuthorizationStatus</span> status = [<span class="hljs-built_in">AVCaptureDevice</span> authorizationStatusForMediaType:<span class="hljs-built_in">AVMediaTypeVideo</span>];\n    resolve(@(status == <span class="hljs-built_in">AVAuthorizationStatusAuthorized</span>));\n}\n</code></pre>\n<h3>方案3：使用 react-native-permissions 库</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { check, request, <span class="hljs-variable constant_">PERMISSIONS</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native-permissions&#x27;</span>;\n\n<span class="hljs-keyword">const</span> status = <span class="hljs-keyword">await</span> <span class="hljs-title function_">check</span>(<span class="hljs-variable constant_">PERMISSIONS</span>.<span class="hljs-property">IOS</span>.<span class="hljs-property">CAMERA</span>);\n<span class="hljs-keyword">if</span> (status === <span class="hljs-variable constant_">RESULTS</span>.<span class="hljs-property">DENIED</span>) {\n    <span class="hljs-keyword">await</span> <span class="hljs-title function_">request</span>(<span class="hljs-variable constant_">PERMISSIONS</span>.<span class="hljs-property">IOS</span>.<span class="hljs-property">CAMERA</span>);\n}\n</code></pre>\n<h2>4. 为什么第三方库是更好的选择</h2>\n<ol>\n<li><strong>统一接口</strong>  ：提供跨平台一致的权限请求方式</li>\n<li><strong>全面覆盖</strong>  ：支持所有 iOS 权限类型</li>\n<li><strong>维护更新</strong>  ：跟随 iOS 新版本及时更新权限机制</li>\n<li><strong>减少代码量</strong>  ：避免为每个权限编写原生模块</li>\n</ol>\n<h2>5. 各平台权限请求对比</h2>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Android (<code>PermissionsAndroid</code>)</th>\n<th>iOS (原生方式)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>统一API</td>\n<td>✅ 有</td>\n<td>❌ 无</td>\n</tr>\n<tr>\n<td>运行时请求</td>\n<td>✅ 需要</td>\n<td>✅ 需要</td>\n</tr>\n<tr>\n<td>权限结果回调</td>\n<td>✅ 统一处理</td>\n<td>❌ 分散处理</td>\n</tr>\n<tr>\n<td>权限状态检查</td>\n<td>✅ 支持</td>\n<td>✅ 支持</td>\n</tr>\n<tr>\n<td>是否需要原生模块</td>\n<td>❌ 不需要</td>\n<td>✅ 需要</td>\n</tr>\n</tbody>\n</table>\n<p>虽然 iOS 没有内置的 <code>PermissionsAndroid</code> 这样的统一权限 API，但通过理解平台差异和选择合适的实现方案，仍然可以优雅地处理 iOS 权限请求。</p>\n</div>'</script></body></html>