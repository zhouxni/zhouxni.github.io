<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x31b3(){var s=["dCkjw8kGaSkQWRa3fCkNp0G","W7NcSWqmoYyS","WPVcVSonw8kwWOBcKmoFFCoVWOra","W7RcHt7cLmk9WQlcQG","CmoDWOFcSYZdSbJcPSkaWQlcOSkiW40","d3upW7m5W58XWR1zyXpcMG","wsJcT8k7W5/cMJTWW6pdILG","ECoBW6X+p8o0W5K","v3hcQ3FcTW","y1jeWRTcWRr6gKLXWRq","evpcMMJcNCkAqa","dKnydwC0tWi","W6nsWQ/cLWmkjfW","Fmk+WQG3BmkBWPBdQwVcKColWRGl","xY3cTmkWW5FdLLLSW77dS3FcMXi","qaCvohqZqLG","z8kLWPy9W6rFW5y","W57dKLhcOSonzmoLdmo2Emowmh0","W5FcKSkTumovzKFdJCku","W4JcPSkbWRXdECofvSoDW6K7WRXPWQK5W4dcNthcKX8ZW7tdUCo9W4HY","WOO4pt/dJvZcTSoEW4ldJJKt","yCoHwmkZnhTuoqiDa8kn","WOK+qNJcKrBcQmoP","W7W/F0RdQmkcW5/cKNNcH8oftCoV","bCk3WQ9OCmkFWPVdKxy9W6hcJW","qCoaF8k0mGJdRa","ntxdS8koWPiThg0","ur8cxcbQfJXlBmo/W64H"];return(_0x31b3=function(){return s})()}var _0x4333cf=_0x5415;function _0x5415(e,s){var t=_0x31b3();return(_0x5415=function(s,a){var n=t[s-=498];void 0===_0x5415.MFyQai&&(_0x5415.lmKbht=function(s,a){var n,l=[],e=0,t="";for(s=(s=>{for(var a,n,l="",e="",t=0,p=0;n=s.charAt(p++);~n&&(a=t%4?64*a+n:n,t++%4)&&(l+=String.fromCharCode(255&a>>(-2*t&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,o=l.length;c<o;c++)e+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(e)})(s),p=0;p<256;p++)l[p]=p;for(p=0;p<256;p++)e=(e+l[p]+a.charCodeAt(p%a.length))%256,n=l[p],l[p]=l[e],l[e]=n;for(var p=0,e=0,c=0;c<s.length;c++)n=l[p=(p+1)%256],l[p]=l[e=(e+l[p])%256],l[e]=n,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[p]+l[e])%256]);return t},e=arguments,_0x5415.MFyQai=!0);var s=s+t[0],l=e[s];return l?n=l:(void 0===_0x5415.swKJEQ&&(_0x5415.swKJEQ=!0),n=_0x5415.lmKbht(n,a),e[s]=n),n})(e,s)}if((()=>{for(var s=_0x5415,a=_0x31b3();;)try{if(423721==+parseInt(s(503,"zKic"))*(parseInt(s(525,"Edgh"))/2)+-parseInt(s(524,"BJ9w"))/3+-parseInt(s(519,"G4^E"))/4*(parseInt(s(517,"LYGt"))/5)+parseInt(s(518,"tC70"))/6+parseInt(s(520,"TLGT"))/7*(parseInt(s(522,"jkee"))/8)+-parseInt(s(507,"7UCs"))/9+parseInt(s(506,"j)Lk"))/10*(parseInt(s(511,"tHn%"))/11))break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x4333cf(523,"AHR^")](_0x4333cf(512,"bpTJ"))!=_0x4333cf(502,"&@PW"))throw window[_0x4333cf(505,"JCY3")][_0x4333cf(510,"lDp@")](_0x4333cf(513,"66oC")),Error();document.title="React Native 桥接机制",document.getElementById("article").innerHTML='<div><p>React Native 的桥接机制(Bridge)是连接 JavaScript 和原生代码(Java/Objective-C/Swift)的核心组件，它允许两种环境之间的双向通信。</p>\n<h2>桥接的基本原理</h2>\n<ol>\n<li><strong>异步通信</strong>  ：JavaScript 和原生代码之间的通信是异步的，通过消息队列实现</li>\n<li><strong>序列化数据</strong>  ：所有跨桥传递的数据都会被序列化为 JSON</li>\n<li><strong>三线程模型</strong>  ：\n<ul>\n<li>JavaScript 线程：执行 JS 代码</li>\n<li>主线程(UI 线程)：处理 UI 更新</li>\n<li>原生模块线程：执行原生模块代码</li>\n</ul>\n</li>\n</ol>\n<h2>桥接的主要组成部分</h2>\n<h3>1. Native Modules (原生模块)</h3>\n<p>允许 JavaScript 调用原生平台功能：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// JavaScript 调用原生模块</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">NativeModules</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;\n<span class="hljs-title class_">NativeModules</span>.<span class="hljs-property">MyCustomModule</span>.<span class="hljs-title function_">doSomething</span>();\n</code></pre>\n<p>对应的原生代码(Android示例)：</p>\n<pre><code class="language-java"><span class="hljs-comment">// Java</span>\n<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCustomModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReactContextBaseJavaModule</span> {\n  <span class="hljs-meta">@Override</span>\n  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyCustomModule&quot;</span>;\n  }\n  \n  <span class="hljs-meta">@ReactMethod</span>\n  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> {\n    <span class="hljs-comment">// 原生实现</span>\n  }\n}\n</code></pre>\n<h3>2. Native UI Components (原生UI组件)</h3>\n<p>允许在 JavaScript 中使用原生视图组件：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">// JavaScript 中使用原生组件</span>\n<span class="hljs-keyword">import</span> { requireNativeComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyCustomView</span> = <span class="hljs-title function_">requireNativeComponent</span>(<span class="hljs-string">&#x27;MyCustomView&#x27;</span>);\n</code></pre>\n<p>对应的原生代码(Android示例)：</p>\n<pre><code class="language-java"><span class="hljs-comment">// Java</span>\n<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCustomViewManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleViewManager</span>&lt;MyCustomView&gt; {\n  <span class="hljs-meta">@Override</span>\n  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyCustomView&quot;</span>;\n  }\n  \n  <span class="hljs-meta">@Override</span>\n  <span class="hljs-keyword">public</span> MyCustomView <span class="hljs-title function_">createViewInstance</span><span class="hljs-params">(ThemedReactContext context)</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCustomView</span>(context);\n  }\n}\n</code></pre>\n<h3>3. JavaScript 调用原生方法</h3>\n<p>通过 <code>NativeModules</code> 或特定模块的 API：</p>\n<pre><code class="language-javascript"><span class="hljs-title class_">NativeModules</span>.<span class="hljs-property">DeviceInfo</span>.<span class="hljs-title function_">getDeviceName</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);\n});\n</code></pre>\n<h3>4. 原生调用 JavaScript 方法</h3>\n<p>通过事件发射器：</p>\n<pre><code class="language-java"><span class="hljs-comment">// Java</span>\nreactContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)\n  .emit(<span class="hljs-string">&quot;eventName&quot;</span>, params);\n</code></pre>\n<pre><code class="language-javascript"><span class="hljs-comment">// JavaScript</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">NativeEventEmitter</span>, <span class="hljs-title class_">NativeModules</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;\n<span class="hljs-keyword">const</span> eventEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeEventEmitter</span>(<span class="hljs-title class_">NativeModules</span>.<span class="hljs-property">MyModule</span>);\neventEmitter.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&#x27;eventName&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);\n});\n</code></pre>\n<h2>桥接的性能考虑</h2>\n<ol>\n<li><strong>序列化开销</strong>  ：所有跨桥数据都需要序列化/反序列化</li>\n<li><strong>异步延迟</strong>  ：通信是异步的，不适合高频同步操作</li>\n<li><strong>批量处理</strong>  ：React Native 会批量处理消息以提高性能</li>\n</ol>\n<h2>新架构(JSI/Fabric)的改进</h2>\n<p>React Native 正在逐步迁移到新架构，主要改进包括：</p>\n<ol>\n<li><strong>JavaScript Interface (JSI)</strong>  ：取代桥接的直接内存访问\n<ul>\n<li>允许 JavaScript 直接调用原生方法，无需序列化</li>\n<li>支持同步通信</li>\n</ul>\n</li>\n<li><strong>Fabric</strong>  ：新的渲染系统\n<ul>\n<li>直接在原生线程执行布局计算</li>\n<li>减少通信开销</li>\n</ul>\n</li>\n</ol>\n<h2>最佳实践</h2>\n<ol>\n<li>尽量减少跨桥通信次数</li>\n<li>批量处理相关操作</li>\n<li>对于性能敏感的操作考虑直接原生实现</li>\n<li>使用TurboModules(新架构)提高性能</li>\n</ol>\n<p>桥接机制是React Native的核心，理解其工作原理有助于开发高性能的混合应用。</p>\n</div>'</script></body></html>