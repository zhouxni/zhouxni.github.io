<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5af5a9=_0x274c;function _0x274c(r,n){var l=_0x52ec();return(_0x274c=function(n,t){var e=l[n-=353];void 0===_0x274c.QPZjPL&&(_0x274c.EpgnEI=function(n,t){var e,o=[],r=0,l="";for(n=(n=>{for(var t,e,o="",r="",l=0,i=0;e=n.charAt(i++);~e&&(t=l%4?64*t+e:e,l++%4)&&(o+=String.fromCharCode(255&t>>(-2*l&6))))e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(e);for(var a=0,c=o.length;a<c;a++)r+="%"+("00"+o.charCodeAt(a).toString(16)).slice(-2);return decodeURIComponent(r)})(n),i=0;i<256;i++)o[i]=i;for(i=0;i<256;i++)r=(r+o[i]+t.charCodeAt(i%t.length))%256,e=o[i],o[i]=o[r],o[r]=e;for(var i=0,r=0,a=0;a<n.length;a++)e=o[i=(i+1)%256],o[i]=o[r=(r+o[i])%256],o[r]=e,l+=String.fromCharCode(n.charCodeAt(a)^o[(o[i]+o[r])%256]);return l},r=arguments,_0x274c.QPZjPL=!0);var n=n+l[0],o=r[n];return o?e=o:(void 0===_0x274c.AnAIsd&&(_0x274c.AnAIsd=!0),e=_0x274c.EpgnEI(e,t),r[n]=e),e})(r,n)}function _0x52ec(){var n=["weeXW4tdJ0ldTa","c0OKW4ddOLddKa","WPvjcfFdVSoZy8kLvdldTG","W4pcQ8kQD2TpWRui","W4pcH1vpn8ozWQVcRca","CXtcHuVcTcldHCk3","xXTrW63cJ8k5WOpdTCk6WOngWPdcLG","WOuyCdpcOMSZW6tcI8oDba","WRLUW4enifOS","WODjW6lcPdrUrG","WP7dS8o4isyrW6SGsdGJW7TH","W6/dShTbW4a9smoPW44JW50","WP9PW49MA2CpWOVdKSoZW7upWRHXtfxdNmkGtCoOWOj+EhnaiG","A8kDW6VcSHJdOYJcI3W1W58","W7GDW40TtumQya","mmk4WO0ACtLXWPBcUmkiWOmxea","WRjKvCkzB8k7WRaudCoWW5ylW5q","vZzUWOBcV8oFWReHta","ee5qDSo+W7P+WOhcSW","W43dVXm0WOFcGSo5","W5nkyCoRBvNdUSoAW4yZWO3cPt8","W4qCW7JcRZj6ALe","W7DAzCkzW7ZcVSogsSoix8kzEtG","iNG+wHirWOjH","v0FdHtxcGG","WPJdT8o4lY4rWRmmrHOUW64","FCk4W4XRWR/cJeexW4OFW77cJW","u8opWO0IjK7dNCothmoMW7iNFq","oCkbBcBcO8oWoW","WRmKDIBcIIPkWPifnfJdV8kd"];return(_0x52ec=function(){return n})()}if((()=>{for(var n=_0x274c,t=_0x52ec();;)try{if(911384==+parseInt(n(377,"VPUe"))+parseInt(n(370,"@4@^"))/2*(-parseInt(n(366,"h9FM"))/3)+-parseInt(n(382,"qMR5"))/4*(-parseInt(n(378,"7dI%"))/5)+parseInt(n(357,"j$R3"))/6+parseInt(n(364,"jW2["))/7*(-parseInt(n(368,"MGVp"))/8)+-parseInt(n(358,"j4kq"))/9*(-parseInt(n(356,"UG3U"))/10)+parseInt(n(365,"DOpP"))/11*(-parseInt(n(367,"ad^3"))/12))break;t.push(t.shift())}catch(n){t.push(t.shift())}})(),localStorage[_0x5af5a9(381,"qMR5")](_0x5af5a9(369,"A)qe"))!=_0x5af5a9(375,"aL4x"))throw window[_0x5af5a9(354,"s2W7")][_0x5af5a9(360,"J!s*")](_0x5af5a9(363,"!!%^")),Error();document.title="react native 生命周期",document.getElementById("article").innerHTML="<div><p>React Native 的生命周期是指组件从创建到销毁所经历的一系列状态变化。以下是 React Native 生命周期的详细解析：</p>\n<h3>一、生命周期阶段</h3>\n<p>React Native 组件的生命周期大致可以分为三个阶段：</p>\n<ol>\n<li><strong>挂载阶段（Mounting）</strong>  ：组件被创建并插入到虚拟 DOM 中。</li>\n<li><strong>更新阶段（Updating）</strong>  ：组件的 props 或 state 发生变化，导致组件重新渲染。</li>\n<li><strong>卸载阶段（Unmounting）</strong>  ：组件从虚拟 DOM 中移除。</li>\n</ol>\n<h3>二、生命周期方法</h3>\n<h4>1. 挂载阶段</h4>\n<ul>\n<li><strong>constructor(props)</strong>  ：\n<ul>\n<li>在组件实例化时调用，通常用于初始化 state 或绑定事件处理方法。</li>\n<li>必须调用 <code>super(props)</code> 来初始化父类构造函数。</li>\n</ul>\n</li>\n<li><strong>static getDerivedStateFromProps(props, state)</strong>  ：\n<ul>\n<li>在组件实例化和更新时调用，用于根据 props 更新 state。</li>\n<li>返回一个对象来更新 state，或返回 <code>null</code> 不做更新。</li>\n</ul>\n</li>\n<li><strong>render()</strong>  ：\n<ul>\n<li>必须实现的方法，用于返回要渲染的 JSX 代码。</li>\n<li>在组件的挂载阶段和更新阶段都会被调用。</li>\n</ul>\n</li>\n<li><strong>componentDidMount()</strong>  ：\n<ul>\n<li>在组件第一次渲染完成后调用。</li>\n<li>常用于发送网络请求、添加事件监听器等副作用操作。</li>\n</ul>\n</li>\n</ul>\n<h4>2. 更新阶段</h4>\n<ul>\n<li><strong>static getDerivedStateFromProps(props, state)</strong>  ：\n<ul>\n<li>在更新阶段也会被调用，用于根据新的 props 更新 state。</li>\n</ul>\n</li>\n<li><strong>shouldComponentUpdate(nextProps, nextState)</strong>  ：\n<ul>\n<li>用于判断组件是否需要重新渲染。</li>\n<li>返回 <code>true</code> 表示需要更新，返回 <code>false</code> 则阻止更新。</li>\n<li>默认情况下返回 <code>true</code>。</li>\n</ul>\n</li>\n<li><strong>getSnapshotBeforeUpdate(prevProps, prevState)</strong>  ：\n<ul>\n<li>在更新发生之前调用，常用于在 DOM 更新之前获取一些信息（如滚动位置）。</li>\n<li>返回值将作为 <code>componentDidUpdate</code> 的第三个参数。</li>\n</ul>\n</li>\n<li><strong>componentDidUpdate(prevProps, prevState, snapshot)</strong>  ：\n<ul>\n<li>在组件更新完成后调用。</li>\n<li>常用于执行副作用操作（如发送网络请求）或更新外部系统。</li>\n</ul>\n</li>\n<li><strong>render()</strong>  ：\n<ul>\n<li>在更新阶段也会被调用，用于生成新的虚拟 DOM。</li>\n</ul>\n</li>\n</ul>\n<h4>3. 卸载阶段</h4>\n<ul>\n<li><strong>componentWillUnmount()</strong>  ：\n<ul>\n<li>在组件被卸载前调用。</li>\n<li>常用于清理定时器、取消网络请求或移除事件监听器等。</li>\n</ul>\n</li>\n</ul>\n<h3>三、注意事项</h3>\n<ul>\n<li><strong><code>return false</code> 在 React Native 中</strong>  ：\n<ul>\n<li>在事件处理函数中，<code>return false</code> 不会阻止事件冒泡，但可以用于阻止默认行为（如阻止 <code>&lt;a&gt;</code> 标签的跳转）。</li>\n<li>推荐使用 <code>event.preventDefault()</code> 来阻止默认行为，使用 <code>event.stopPropagation()</code> 来阻止事件冒泡。</li>\n</ul>\n</li>\n<li><strong>性能优化</strong>  ：\n<ul>\n<li>在 <code>shouldComponentUpdate</code> 中进行条件判断，避免不必要的重新渲染。</li>\n<li>使用 <code>PureComponent</code> 或 <code>React.memo</code> 来优化性能。</li>\n</ul>\n</li>\n<li><strong>JavaScriptCore</strong>  ：\n<ul>\n<li>React Native 使用 JavaScriptCore 作为其 JavaScript 引擎，负责解释和执行 JavaScript 代码。</li>\n<li>了解 JavaScriptCore 的工作原理有助于理解 React Native 的性能优化和内存管理。</li>\n</ul>\n</li>\n</ul>\n<h3>四、总结</h3>\n<p>React Native 的生命周期方法提供了对组件行为的全面控制，开发者可以根据需要在不同的生命周期阶段执行相应的操作。通过合理使用生命周期方法，可以实现高效的组件管理和性能优化。同时，了解 React Native 的底层机制（如 JavaScriptCore）也有助于更好地理解和优化应用性能。</p>\n</div>"</script></body></html>