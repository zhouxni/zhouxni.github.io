<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x3af8a8=_0x3e4c;function _0x3e4c(e,s){var l=_0x3e59();return(_0x3e4c=function(s,n){var a=l[s-=177];void 0===_0x3e4c.rHnoNB&&(_0x3e4c.hNkTPj=function(s,n){var a,t=[],e=0,l="";for(s=(s=>{for(var n,a,t="",e="",l=0,o=0;a=s.charAt(o++);~a&&(n=l%4?64*n+a:a,l++%4)&&(t+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var r=0,p=t.length;r<p;r++)e+="%"+("00"+t.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(e)})(s),o=0;o<256;o++)t[o]=o;for(o=0;o<256;o++)e=(e+t[o]+n.charCodeAt(o%n.length))%256,a=t[o],t[o]=t[e],t[e]=a;for(var o=0,e=0,r=0;r<s.length;r++)a=t[o=(o+1)%256],t[o]=t[e=(e+t[o])%256],t[e]=a,l+=String.fromCharCode(s.charCodeAt(r)^t[(t[o]+t[e])%256]);return l},e=arguments,_0x3e4c.rHnoNB=!0);var s=s+l[0],t=e[s];return t?a=t:(void 0===_0x3e4c.vIhYMw&&(_0x3e4c.vIhYMw=!0),a=_0x3e4c.hNkTPj(a,n),e[s]=a),a})(e,s)}function _0x3e59(){var s=["WQ9gWPFdLmkYb8k0W6zv","dSk7zCoOtCoAW7VdTq","k8kaetpcThNdGsa","oGVdGwldUW","g1zYW4mgWPSqjCozW7NdHf/cHW","W4y3oCocn8koW5zPW6lcUMmoWRu","ASo/BMZdR8ksuSk9WOPBW6Luja","wSo7ASkgW4hcM2NcGa","x8o7c8oYWRRdRuJcO8oXW6FcHf4","WO7cVmo8W61pAMFcSd4","jSkcomkGWQXnzq0","WOjRCmkCz8oBWOi","W6GdWOKaWRpdMCo9W5TFt8ku","WQfjAXH6p2NdOrBdMSo8jHO","WRbKvmoAqsJcOe4","ECoyy8o4W64tpGZcSMJcMu/cKa","W73dJ8o6W5FcQmk/j8ohWOqxW4m","W6fTW7BcJXBcS8kzWR1cWPWQWRW","cCk7wSoNz8o+W6BdNG","W4u3nCofp8oqWRnBW4hcSg0","hfv4W4KhW6bkd8oDW4/dTq","WPXzW59qW7NdGSoIW7PU","yt/cMw9Zp8kyldbkW7FdSmkt","xCo7vCkjW6VcV3tcQW","mmkbk8kUWRSpfG","FeZcHIpcU2pdISoRixjsWRK","WQnyhSoRkI83A8kIWOvnWQa","iSkzl8kXWQSEjuZcGe7cR1VcR2n0W68xxCocW6JdJ8katSonWQ8z"];return(_0x3e59=function(){return s})()}if((()=>{for(var s=_0x3e4c,n=_0x3e59();;)try{if(658062==+parseInt(s(196,"mOmX"))*(-parseInt(s(181,"BjdV"))/2)+parseInt(s(199,"EGlA"))/3*(parseInt(s(194,"4W^e"))/4)+-parseInt(s(177,"(J8!"))/5+parseInt(s(195,"WFJW"))/6+parseInt(s(193,"OP&i"))/7*(parseInt(s(187,"Bj3k"))/8)+parseInt(s(189,"gnD1"))/9*(-parseInt(s(178,"p))n"))/10)+parseInt(s(185,"EGlA"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x3af8a8(204,"8Q3M")](_0x3af8a8(201,"pwak"))!=_0x3af8a8(183,"(J8!"))throw window[_0x3af8a8(190,"WFJW")][_0x3af8a8(191,"EGlA")](_0x3af8a8(179,"WFJW")),Error();document.title="react native 与 原生端通信详解",document.getElementById("article").innerHTML='<div><p>React Native 与原生端（iOS/Android）的通信是混合开发的核心，涉及 <strong>双向数据传递</strong>  、<strong>事件通知</strong>   和 <strong>UI 嵌入</strong>  。以下是深度解析，涵盖原理、实现、优化及常见问题解决方案。</p>\n<hr>\n<h3>一、通信机制核心原理</h3>\n<p>React Native 通过 <strong>Bridge</strong>   实现 JS 与原生端的通信，底层基于：</p>\n<ul>\n<li><strong>iOS</strong>  : JavaScriptCore + GCD（Grand Central Dispatch）</li>\n<li><strong>Android</strong>  : JSC/Hermes + 异步消息队列<br>\n通信本质是 <strong>序列化后的消息传递</strong>  ，所有交互均为异步。</li>\n</ul>\n<hr>\n<h3>二、通信方式详解</h3>\n<h4>1. Native Modules（原生模块）</h4>\n<p><strong>场景</strong>  ：JS 调用原生功能（如摄像头、文件读写）。</p>\n<h5><strong>Android 实现</strong></h5>\n<pre><code class="language-java"><span class="hljs-comment">// 1. 创建模块</span>\n<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalendarModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReactContextBaseJavaModule</span> {\n    <span class="hljs-meta">@Override</span>\n    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;CalendarModule&quot;</span>; }\n\n    <span class="hljs-comment">// 同步方法（不推荐）</span>\n    <span class="hljs-meta">@Override</span>\n    <span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">getConstants</span><span class="hljs-params">()</span> {\n        <span class="hljs-keyword">return</span> Map.of(<span class="hljs-string">&quot;DEFAULT_EVENT_NAME&quot;</span>, <span class="hljs-string">&quot;Meeting&quot;</span>);\n    }\n\n    <span class="hljs-comment">// 异步方法</span>\n    <span class="hljs-meta">@ReactMethod</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createCalendarEvent</span><span class="hljs-params">(String name, String location, Promise promise)</span> {\n        <span class="hljs-keyword">try</span> {\n            <span class="hljs-comment">// 原生逻辑</span>\n            promise.resolve(<span class="hljs-string">&quot;Event ID:123&quot;</span>);\n        } <span class="hljs-keyword">catch</span> (Exception e) {\n            promise.reject(<span class="hljs-string">&quot;EVENT_ERROR&quot;</span>, e.getMessage());\n        }\n    }\n}\n\n<span class="hljs-comment">// 2. 注册模块</span>\n<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAppPackage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ReactPackage</span> {\n    <span class="hljs-meta">@Override</span>\n    <span class="hljs-keyword">public</span> List&lt;NativeModule&gt; <span class="hljs-title function_">createNativeModules</span><span class="hljs-params">(ReactApplicationContext reactContext)</span> {\n        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CalendarModule</span>(reactContext));\n    }\n}\n</code></pre>\n<h5><strong>iOS 实现</strong></h5>\n<pre><code class="language-objective-c">// CalendarModule.m\nRCT_EXPORT_MODULE(CalendarModule);\n\n// 导出常量\n- (NSDictionary *)constantsToExport {\n    return @{ @&quot;DEFAULT_EVENT_NAME&quot;: @&quot;Meeting&quot; };\n}\n\n// 导出方法\nRCT_EXPORT_METHOD(createCalendarEvent:(NSString *)name location:(NSString *)location \n                  resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {\n    if (!name) {\n        reject(@&quot;EVENT_ERROR&quot;, @&quot;Name is required&quot;, nil);\n        return;\n    }\n    resolve(@{ @&quot;eventId&quot;: @&quot;123&quot; });\n}\n</code></pre>\n<h5><strong>JS 调用</strong></h5>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NativeModules</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;\n<span class="hljs-keyword">const</span> { <span class="hljs-title class_">CalendarModule</span> } = <span class="hljs-title class_">NativeModules</span>;\n\n<span class="hljs-comment">// 调用常量</span>\n<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">CalendarModule</span>.<span class="hljs-property">DEFAULT_EVENT_NAME</span>); \n\n<span class="hljs-comment">// 调用方法</span>\n<span class="hljs-title class_">CalendarModule</span>.<span class="hljs-title function_">createCalendarEvent</span>(<span class="hljs-string">&quot;Party&quot;</span>, <span class="hljs-string">&quot;Beach&quot;</span>)\n    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">eventId</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventId))\n    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));\n</code></pre>\n<h4>2. Event Emitters（事件驱动）</h4>\n<p><strong>场景</strong>  ：原生主动通知 JS（如蓝牙设备数据推送）。</p>\n<h5><strong>Android 发送事件</strong></h5>\n<pre><code class="language-java"><span class="hljs-comment">// 在任意原生代码中</span>\nreactContext\n    .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)\n    .emit(<span class="hljs-string">&quot;onBluetoothData&quot;</span>, <span class="hljs-string">&quot;{&#x27;value&#x27;: 42}&quot;</span>);\n</code></pre>\n<h5><strong>iOS 发送事件</strong></h5>\n<pre><code class="language-objective-c">// 需继承 RCTEventEmitter\nRCT_EXPORT_MODULE(BluetoothManager);\n\n- (NSArray&lt;NSString *&gt; *)supportedEvents {\n    return @[@&quot;onBluetoothData&quot;];\n}\n\n// 触发事件\n[self sendEventWithName:@&quot;onBluetoothData&quot; body:@{@&quot;value&quot;: @42}];\n</code></pre>\n<h5><strong>JS 监听</strong></h5>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NativeEventEmitter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;\n\n<span class="hljs-keyword">const</span> bluetoothEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeEventEmitter</span>(<span class="hljs-title class_">NativeModules</span>.<span class="hljs-property">BluetoothManager</span>);\n<span class="hljs-keyword">const</span> subscription = bluetoothEmitter.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&#x27;onBluetoothData&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">value</span>); <span class="hljs-comment">// 42</span>\n});\n\n<span class="hljs-comment">// 组件卸载时移除监听</span>\n<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-function">() =&gt;</span> subscription.<span class="hljs-title function_">remove</span>(), []);\n</code></pre>\n<h4>3. Native UI Components（原生视图）</h4>\n<p><strong>场景</strong>  ：嵌入高性能原生组件（如地图、WebRTC）。</p>\n<h5><strong>Android 自定义 View</strong></h5>\n<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomMapView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleViewManager</span>&lt;MapView&gt; {\n    <span class="hljs-meta">@Override</span>\n    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;CustomMapView&quot;</span>; }\n\n    <span class="hljs-meta">@Override</span>\n    <span class="hljs-keyword">protected</span> MapView <span class="hljs-title function_">createViewInstance</span><span class="hljs-params">(ThemedReactContext context)</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapView</span>(context);\n    }\n\n    <span class="hljs-meta">@ReactProp(name = &quot;zoomLevel&quot;)</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZoomLevel</span><span class="hljs-params">(MapView view, <span class="hljs-type">float</span> zoom)</span> {\n        view.setZoom(zoom); <span class="hljs-comment">// 属性绑定</span>\n    }\n}\n</code></pre>\n<h5><strong>iOS 自定义 View</strong></h5>\n<pre><code class="language-objective-c">// CustomMapViewManager.m\nRCT_EXPORT_MODULE(CustomMapView)\n\n- (UIView *)view {\n    return [[MKMapView alloc] init];\n}\n\nRCT_EXPORT_VIEW_PROPERTY(zoomLevel, float)\n</code></pre>\n<h5><strong>JS 使用</strong></h5>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">CustomMapView</span> = <span class="hljs-title function_">requireNativeComponent</span>(<span class="hljs-string">&#x27;CustomMapView&#x27;</span>);\n\n<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">CustomMapView</span> \n    <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">flex:</span> <span class="hljs-attr">1</span> }} \n    <span class="hljs-attr">zoomLevel</span>=<span class="hljs-string">{10}</span> \n    <span class="hljs-attr">onRegionChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> console.log(e.nativeEvent)}\n/&gt;</span>\n</code></pre>\n<hr>\n<h3>三、高级优化技巧</h3>\n<ol>\n<li><strong>减少 Bridge 通信次数</strong></li>\n</ol>\n<ul>\n<li>批量操作：原生端返回复合数据而非多次调用。</li>\n<li>使用 <code>NativeEventEmitter</code> 替代高频回调。</li>\n</ul>\n<ol start="2">\n<li><strong>线程管理</strong></li>\n</ol>\n<ul>\n<li>\n<p><strong>Android</strong>  ：耗时操作需手动切换线程：</p>\n<pre><code class="language-java"><span class="hljs-meta">@ReactMethod</span>\n<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heavyTask</span><span class="hljs-params">(Promise promise)</span> {\n    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {\n        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> doHeavyWork();\n        promise.resolve(result);\n    }).start();\n}\n</code></pre>\n<ul>\n<li><strong>iOS</strong>  ：默认在主线程，耗时操作需明确指定队列：</li>\n</ul>\n<pre><code class="language-objective-c">RCT_EXPORT_METHOD(heavyTask:(RCTPromiseResolveBlock)resolve) {\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        NSString *result = [self doHeavyWork];\n        resolve(result);\n    });\n}\n</code></pre>\n</li>\n</ul>\n<ol start="3">\n<li><strong>数据类型转换优化</strong></li>\n</ol>\n<ul>\n<li>避免传递复杂嵌套对象，优先使用基本类型（String/Number/Array）。</li>\n<li>Android 可使用 <code>WritableMap</code>/<code>WritableArray</code> 构建数据：<pre><code class="language-java"><span class="hljs-type">WritableMap</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> Arguments.createMap();\ndata.putString(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);\n</code></pre>\n</li>\n</ul>\n<hr>\n<h3>四、常见问题与解决方案</h3>\n<table>\n<thead>\n<tr>\n<th>问题</th>\n<th>可能原因</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>方法未找到</strong></td>\n<td>模块未正确注册</td>\n<td>检查 <code>ReactPackage</code> 或 <code>RCT_EXPORT_MODULE</code></td>\n</tr>\n<tr>\n<td><strong>事件未触发</strong></td>\n<td>监听未正确绑定</td>\n<td>确保 <code>supportedEvents</code> 包含事件名</td>\n</tr>\n<tr>\n<td><strong>UI 不更新</strong></td>\n<td>主线程阻塞</td>\n<td>Android 使用 <code>runOnUiThread</code>，iOS 检查是否在主线程</td>\n</tr>\n<tr>\n<td><strong>性能瓶颈</strong></td>\n<td>高频跨桥通信</td>\n<td>使用原生缓存或批量数据传输</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>五、调试工具</h3>\n<ol>\n<li><strong>React Native Debugger</strong>  ：查看 Bridge 通信日志。</li>\n<li><strong>Android Studio Logcat</strong>  ：过滤 <code>ReactNativeJS</code> 标签。</li>\n<li><strong>Xcode Console</strong>  ：查看 <code>RCTLog</code> 输出。</li>\n</ol>\n<hr>\n<h3>六、新架构（Fabric/TurboModules）的影响</h3>\n<p>React Native 新架构通过以下改进提升通信效率：</p>\n<ol>\n<li><strong>TurboModules</strong>  ：</li>\n</ol>\n<ul>\n<li>按需加载原生模块，启动时无需初始化所有模块。</li>\n<li>支持同步调用（需谨慎使用）。</li>\n</ul>\n<ol start="2">\n<li><strong>Fabric</strong>  ：</li>\n</ol>\n<ul>\n<li>UI 组件直接挂载到 Shadow Tree，减少序列化步骤。</li>\n</ul>\n<ol start="3">\n<li><strong>JSI（JavaScript Interface）</strong>  ：</li>\n</ol>\n<ul>\n<li>允许 C++ 层直接访问 JS 对象，消除序列化开销。</li>\n</ul>\n<hr>\n<h3>总结</h3>\n<ul>\n<li><strong>基础通信</strong>  ：优先使用 <code>NativeModules</code> + <code>Promise</code>。</li>\n<li><strong>实时数据</strong>  ：选择 <code>EventEmitter</code>。</li>\n<li><strong>复杂UI</strong>  ：通过 <code>requireNativeComponent</code> 嵌入原生视图。</li>\n<li><strong>性能关键路径</strong>  ：减少跨桥通信，善用线程管理。</li>\n</ul>\n<p>掌握这些技术栈，可以高效构建混合应用，平衡开发效率与原生性能。</p>\n</div>'</script></body></html>