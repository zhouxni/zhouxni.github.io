<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x5bb2bb=_0x5022;if((()=>{for(var s=_0x5022,n=_0x54bc();;)try{if(821649==+parseInt(s(263,"COKb"))+-parseInt(s(261,"bs6O"))/2+parseInt(s(275,"$tRS"))/3*(parseInt(s(274,"D0g3"))/4)+-parseInt(s(254,"bhBj"))/5*(parseInt(s(266,"G$Vh"))/6)+parseInt(s(272,"0sn%"))/7*(parseInt(s(268,"JxPi"))/8)+parseInt(s(281,"$tRS"))/9+-parseInt(s(255,"DVg]"))/10*(parseInt(s(257,"#euN"))/11))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x5bb2bb(273,"bs6O")](_0x5bb2bb(280,"nVT8"))!=_0x5bb2bb(270,"RJ19"))throw window[_0x5bb2bb(276,"yoi[")][_0x5bb2bb(258,"Q9@%")](_0x5bb2bb(278,"El%J")),Error();function _0x5022(l,s){var p=_0x54bc();return(_0x5022=function(s,n){var a=p[s-=254];void 0===_0x5022.WtCRrg&&(_0x5022.gJVtGv=function(s,n){var a,t=[],l=0,p="";for(s=(s=>{for(var n,a,t="",l="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(t+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,c=t.length;o<c;o++)l+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(l)})(s),e=0;e<256;e++)t[e]=e;for(e=0;e<256;e++)l=(l+t[e]+n.charCodeAt(e%n.length))%256,a=t[e],t[e]=t[l],t[l]=a;for(var e=0,l=0,o=0;o<s.length;o++)a=t[e=(e+1)%256],t[e]=t[l=(l+t[e])%256],t[l]=a,p+=String.fromCharCode(s.charCodeAt(o)^t[(t[e]+t[l])%256]);return p},l=arguments,_0x5022.WtCRrg=!0);var s=s+p[0],t=l[s];return t?a=t:(void 0===_0x5022.npxUOE&&(_0x5022.npxUOE=!0),a=_0x5022.gJVtGv(a,n),l[s]=a),a})(l,s)}function _0x54bc(){var s=["W5DDvmovW6ZdKmkLW4JdQ3FdSJVcVG","y8onqXVdVdrPos0","W5ZcKSo4W78ncmkEy8ojAcNdJYq","W5NdLmkSWO1GuCoj","W4pdMCkAj8obWRrbWPC","mahcUColW45Oi3u","cCkSWQG+vWjBEHpdICoWFNm","C0pcHmoyWOhcLqxcKdj8W5xdRG","WP7cKIpcJeyAW4WM","hgldVhBdJa","WQNdOtOXWQFcNflcP8oFxSkvsSkL","W5NdVWLUg2X3euu","WOibeCkPWQRcJmo8","bIDMW5abWPXC","lmo2WRyUWRNdPSoEbWpdH08eda","E8o2kSobW5tcR8oZWQ8","bmomuaxdTtlcTmoXt8oDW7JcUvzC","nmo5W7qXtHHUb8kRW7WSWRCLWRtcGCkeE8k7WO3dHdbJCfRcHJq","WORcH8kIWOldL8k5W5dcSSkZWRNdObBdIq","l8otB3xcReGhWOvM","lSo1WRGRWRNdPSoqtWZdMgmBgv4","WONcH8kjkCk3W4/cN8oNW4anWRj/W6S","ECknWO4olCkeWQtcVW","W5rKlmoPzcTgmSkucCknWQBcPa","W5nJiSoSzY5ioSkpmCk5WO/cMW","W6vwFJWAtZ0","l0rfW5OSW5BcIu/cGdddUSolW7G","Bw7cQmk+W7G+W67dISkoWQ9oWQG"];return(_0x54bc=function(){return s})()}document.title="CodePush 更新检查机制深度解析",document.getElementById("article").innerHTML='<div><p>CodePush 的更新检查机制是其热更新能力的核心，下面我将从底层原理到实际应用全面解析这一过程。</p>\n<h2>一、核心检查流程</h2>\n<h3>1. 完整更新检查链条</h3>\n<pre><code>┌───────────────┐    ┌───────────────┐    ┌───────────────┐    ┌───────────────┐\n│   客户端发起   │───&gt;│ 服务器验证    │───&gt;│ 版本比对      │───&gt;│ 返回更新策略  │\n│  检查请求      │    │ DeploymentKey │    │ (SemVer规则)   │    │ (立即/下次启动)│\n└───────────────┘    └───────────────┘    └───────────────┘    └───────────────┘\n</code></pre>\n<h3>2. 关键参与组件</h3>\n<ul>\n<li><strong>客户端SDK</strong>  ：集成在App中的CodePush库</li>\n<li><strong>服务端API</strong>  ：微软App Center的后端服务</li>\n<li><strong>元数据文件</strong>  ：<code>app.json</code>和<code>codepush.json</code></li>\n<li><strong>本地持久化</strong>  ：SQLite存储更新状态</li>\n</ul>\n<h2>二、客户端检查细节</h2>\n<h3>1. 请求参数组成</h3>\n<pre><code class="language-javascript">{\n  <span class="hljs-attr">deploymentKey</span>: <span class="hljs-string">&quot;ABCDE-12345&quot;</span>,  <span class="hljs-comment">// 唯一部署标识</span>\n  <span class="hljs-attr">appVersion</span>: <span class="hljs-string">&quot;1.2.3&quot;</span>,           <span class="hljs-comment">// 当前二进制版本</span>\n  <span class="hljs-attr">packageHash</span>: <span class="hljs-string">&quot;a1b2c3d&quot;</span>,        <span class="hljs-comment">// 当前包哈希</span>\n  <span class="hljs-attr">isCompanion</span>: <span class="hljs-literal">false</span>,            <span class="hljs-comment">// 是否测试包</span>\n  <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;v5&quot;</span>,                   <span class="hljs-comment">// 当前标签</span>\n  <span class="hljs-attr">clientUniqueId</span>: <span class="hljs-string">&quot;device123&quot;</span>     <span class="hljs-comment">// 设备唯一ID</span>\n}\n</code></pre>\n<h3>2. 本地缓存策略</h3>\n<pre><code class="language-mermaid">graph LR\n    A[发起请求] --&gt; B{本地缓存有效?}\n    B --&gt;|是| C[返回304 Not Modified]\n    B --&gt;|否| D[向服务器查询]\n</code></pre>\n<h2>三、服务端验证机制</h2>\n<h3>1. 五层验证关卡</h3>\n<ol>\n<li><strong>DeploymentKey有效性</strong>  ：验证是否注册的合法Key</li>\n<li><strong>平台匹配</strong>  ：iOS/Android不能混用</li>\n<li><strong>版本范围检查</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 更新包的targetBinaryVersion规则</span>\n<span class="hljs-string">&quot;~1.2.3&quot;</span>  <span class="hljs-comment">// 匹配1.2.3到1.3.0之前的所有版本</span>\n<span class="hljs-string">&quot;^1.2.3&quot;</span>  <span class="hljs-comment">// 匹配1.2.3到2.0.0之前的所有版本 </span>\n</code></pre>\n</li>\n<li><strong>发布状态</strong>  ：检查是否被回滚或暂停</li>\n<li><strong>设备百分比</strong>  ：灰度发布比例控制</li>\n</ol>\n<h3>2. 更新包优先级排序</h3>\n<p>服务器会按以下顺序选择最合适的更新包：</p>\n<pre><code>1. 匹配设备标签的包\n2. 版本号最新的包\n3. 发布时间最近的包\n</code></pre>\n<h2>四、更新策略决策</h2>\n<h3>1. 安装模式对比</h3>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>触发时机</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IMMEDIATE</td>\n<td>立即重启生效</td>\n<td>关键修复</td>\n</tr>\n<tr>\n<td>ON_NEXT_RESTART</td>\n<td>下次启动生效</td>\n<td>常规更新</td>\n</tr>\n<tr>\n<td>ON_NEXT_RESUME</td>\n<td>应用回到前台生效</td>\n<td>后台静默更新</td>\n</tr>\n</tbody>\n</table>\n<h3>2. 条件更新控制</h3>\n<pre><code class="language-javascript"><span class="hljs-title class_">CodePush</span>.<span class="hljs-title function_">sync</span>({\n  <span class="hljs-attr">updateDialog</span>: {\n    <span class="hljs-attr">appendReleaseDescription</span>: <span class="hljs-literal">true</span>,\n    <span class="hljs-attr">descriptionPrefix</span>: <span class="hljs-string">&quot;更新内容:\\n&quot;</span>\n  },\n  <span class="hljs-attr">installMode</span>: <span class="hljs-title class_">CodePush</span>.<span class="hljs-property">InstallMode</span>.<span class="hljs-property">IMMEDIATE</span>,\n  <span class="hljs-attr">mandatoryInstallMode</span>: <span class="hljs-title class_">CodePush</span>.<span class="hljs-property">InstallMode</span>.<span class="hljs-property">ON_NEXT_RESTART</span>,\n  <span class="hljs-attr">minimumBackgroundDuration</span>: <span class="hljs-number">60</span> <span class="hljs-comment">// 至少运行60秒才更新</span>\n});\n</code></pre>\n<h2>五、特殊场景处理</h2>\n<h3>1. 二进制版本升级</h3>\n<p>当检测到App版本升级时：</p>\n<ol>\n<li>自动清除所有历史更新</li>\n<li>重新下载新版本对应的更新包</li>\n</ol>\n<h3>2. 回滚机制</h3>\n<p>两种回滚方式：</p>\n<ol>\n<li><strong>服务器端回滚</strong>  ：在App Center控制台操作</li>\n<li><strong>客户端回滚</strong>  ：更新失败自动回退到上一个稳定版本</li>\n</ol>\n<h3>3. 企业版定制策略</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 自定义更新检查逻辑</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">customCheck</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isVPNConnected</span>()) { <span class="hljs-comment">// 只在内网环境更新</span>\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">CodePush</span>.<span class="hljs-title function_">checkForUpdate</span>();\n  }\n  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-literal">null</span>);\n}\n</code></pre>\n<h2>六、调试与监控</h2>\n<h3>1. 实时日志查看</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 启用详细日志</span>\n<span class="hljs-title class_">CodePush</span>.<span class="hljs-title function_">setLogLevel</span>(<span class="hljs-string">&#x27;debug&#x27;</span>);\n\n<span class="hljs-comment">// 典型日志输出</span>\n[<span class="hljs-title class_">CodePush</span>] <span class="hljs-title class_">Checking</span> <span class="hljs-keyword">for</span> update\n[<span class="hljs-title class_">CodePush</span>] <span class="hljs-title class_">Reporting</span> <span class="hljs-title function_">status</span> (<span class="hljs-title class_">Downloading</span>)\n[<span class="hljs-title class_">CodePush</span>] <span class="hljs-title class_">Reporting</span> <span class="hljs-title function_">status</span> (<span class="hljs-title class_">Installed</span>)\n</code></pre>\n<h3>2. 关键性能指标</h3>\n<table>\n<thead>\n<tr>\n<th>指标</th>\n<th>健康阈值</th>\n<th>监控方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>检查耗时</td>\n<td>&lt;1000ms</td>\n<td>App Center Analytics</td>\n</tr>\n<tr>\n<td>下载成功率</td>\n<td>&gt;98%</td>\n<td>自定义埋点</td>\n</tr>\n<tr>\n<td>安装错误率</td>\n<td>&lt;2%</td>\n<td>错误日志分析</td>\n</tr>\n</tbody>\n</table>\n<h3>3. 问题排查指南</h3>\n<pre><code class="language-sh"><span class="hljs-comment"># 查看更新历史</span>\nappcenter codepush deployment <span class="hljs-built_in">history</span> -a &lt;owner&gt;/&lt;app&gt; Production\n\n<span class="hljs-comment"># 检查包差异</span>\nappcenter codepush release compare -a &lt;owner&gt;/&lt;app&gt; -k v12 v13\n</code></pre>\n<p>CodePush的更新检查机制通过多层验证和智能策略，在保证安全可靠的前提下，实现了灵活的热更新能力。理解这些底层原理可以帮助开发者：</p>\n<ol>\n<li>优化更新策略</li>\n<li>快速定位问题</li>\n<li>设计更高效的发布流程</li>\n<li>实现定制化的更新方案</li>\n</ol>\n</div>'</script></body></html>