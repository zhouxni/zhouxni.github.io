<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x2a7a8a=_0x141b;function _0x2966(){var n=["nSkcm3vOWORdLG","WRe4meO3u8oLlG","frrFWO7dRehcKYK","W73cOmkYbCoai001WPnXiZfCAX7cRCopWOGAyLddIHjmrKS","WQpcUCk+hSoZW7a/W7ddGmkYWQf4","WPXoW4RdO8kwBCk7WPRdVZzIlCoa","WPCoWP1Vas/cH8kIW4jGW6akW48","ChZdNxVcQMfFwsldPgrq","WQ3dICkoW7bEsdjhrxZcPNa","AWBdP1mCW5bQevbgWObiaq","frqmW53cHXFdOdBcPMFcOL5L","wfBdSg5Mi8oLwSkWzrVdP8oM","D33dNxNcPgnXsZpdM0fQ","ncZcMYBdVtrt","bYRcIc/dRYr9FrK","o8kJrJa9FCo6WQuVkI03W6S","nmozyWCKW4VdG3tdV0W5W68","WQlcV8kXg8oXW7DyW6/dRSk7WOX6W68","W43cLCovmtxdICow","W5dcPSoFmSkY","WQ/cKmoEWOurdHO","W4LVzYJdNSo/W4ZdGNTSW5RdVq","bq3cOd8JEmk7xa","eH8nW5ZcGrtdPGxcHhRcOeTK"];return(_0x2966=function(){return n})()}function _0x141b(l,n){var r=_0x2966();return(_0x141b=function(n,i){var t=r[n-=216];void 0===_0x141b.whJaEO&&(_0x141b.ZEjMVC=function(n,i){var t,a=[],l=0,r="";for(n=(n=>{for(var i,t,a="",l="",r=0,o=0;t=n.charAt(o++);~t&&(i=r%4?64*i+t:t,r++%4)&&(a+=String.fromCharCode(255&i>>(-2*r&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var e=0,c=a.length;e<c;e++)l+="%"+("00"+a.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(l)})(n),o=0;o<256;o++)a[o]=o;for(o=0;o<256;o++)l=(l+a[o]+i.charCodeAt(o%i.length))%256,t=a[o],a[o]=a[l],a[l]=t;for(var o=0,l=0,e=0;e<n.length;e++)t=a[o=(o+1)%256],a[o]=a[l=(l+a[o])%256],a[l]=t,r+=String.fromCharCode(n.charCodeAt(e)^a[(a[o]+a[l])%256]);return r},l=arguments,_0x141b.whJaEO=!0);var n=n+r[0],a=l[n];return a?t=a:(void 0===_0x141b.YVmJtS&&(_0x141b.YVmJtS=!0),t=_0x141b.ZEjMVC(t,i),l[n]=t),t})(l,n)}if((()=>{for(var n=_0x141b,i=_0x2966();;)try{if(452453==+parseInt(n(232,"a0OQ"))+parseInt(n(236,"pF6t"))/2+parseInt(n(219,"d^2k"))/3+parseInt(n(228,"tZ]X"))/4*(-parseInt(n(234,"c(F@"))/5)+-parseInt(n(229,"gOrQ"))/6*(parseInt(n(216,"$@9L"))/7)+parseInt(n(238,"LY2g"))/8+-parseInt(n(233,"d]pQ"))/9)break;i.push(i.shift())}catch(n){i.push(i.shift())}})(),localStorage[_0x2a7a8a(222,"DLnB")](_0x2a7a8a(218,"$@9L"))!=_0x2a7a8a(223,"Qkci"))throw window[_0x2a7a8a(226,"&^hB")][_0x2a7a8a(217,"$@9L")](_0x2a7a8a(231,"O4SR")),Error();document.title="react native 的工作原理",document.getElementById("article").innerHTML="<div><p>React Native 的工作原理详解如下：</p>\n<h3>一、核心组件与线程</h3>\n<ol>\n<li><strong>JavaScript 线程</strong>  ：\n<ul>\n<li>负责运行 JavaScript 代码，主要处理应用逻辑、状态管理、业务处理等。</li>\n<li>React Native 使用 React 来构建用户界面的虚拟 DOM 树，并在 JavaScript 线程中进行管理。</li>\n</ul>\n</li>\n<li><strong>原生线程</strong>  ：\n<ul>\n<li>负责 UI 渲染和原生代码执行，如使用 UIKit（iOS）或 View 系统（Android）来呈现用户界面。</li>\n<li>原生线程根据 JavaScript 传来的指令，使用原生控件（如 UIView、TextView 等）完成界面的渲染。</li>\n</ul>\n</li>\n<li><strong>虚拟 DOM</strong>  ：\n<ul>\n<li>React Native 使用虚拟 DOM 来提高性能，它是一个轻量级的 DOM 树，在内存中构建并更新。</li>\n<li>当 JavaScript 线程发生状态变化时，React Native 会重新渲染虚拟 DOM，并将更新的 UI 信息传递给原生线程。</li>\n</ul>\n</li>\n</ol>\n<h3>二、桥接机制</h3>\n<p>桥接（Bridge）是 React Native 的核心，它实现了 JavaScript 代码和原生代码之间的通信。桥接机制的工作原理如下：</p>\n<ol>\n<li><strong>JavaScript 与原生模块的通信</strong>  ：\n<ul>\n<li>JavaScript 线程通过桥接向原生线程发送消息，如发起网络请求、读取文件等，并等待响应。</li>\n<li>消息以 JSON 格式传递，桥接会将这些消息转发给原生模块进行处理。</li>\n</ul>\n</li>\n<li><strong>原生与 JavaScript 的回调</strong>  ：\n<ul>\n<li>原生代码处理完消息后，通过桥接将结果返回给 JavaScript 线程。</li>\n<li>JavaScript 线程根据结果更新虚拟 DOM，并最终更新原生 UI。</li>\n</ul>\n</li>\n<li><strong>异步通信</strong>  ：\n<ul>\n<li>桥接本质上是一个异步通信机制，避免了主线程被阻塞，确保 UI 渲染的流畅性。</li>\n<li>React Native 会将一系列 UI 更新合并为一次更新，从而减少不必要的渲染，提高性能。</li>\n</ul>\n</li>\n</ol>\n<h3>三、工作流程</h3>\n<p>React Native 的工作流程可以概括为以下几个步骤：</p>\n<ol>\n<li><strong>编写 JavaScript 代码</strong>  ：\n<ul>\n<li>开发者使用 JavaScript 编写应用逻辑和 UI 组件。</li>\n<li>代码会在 JavaScript 线程中运行，并通过 React 构建虚拟 DOM 树。</li>\n</ul>\n</li>\n<li><strong>触发更新</strong>  ：\n<ul>\n<li>当用户在应用中执行某些操作（如点击按钮或触发动画）时，JavaScript 代码会将这些交互事件发送给桥接。</li>\n</ul>\n</li>\n<li><strong>桥接转发指令</strong>  ：\n<ul>\n<li>桥接将这些指令传递到原生端，转化为原生组件的操作（如修改 UI 样式、更新数据等）。</li>\n</ul>\n</li>\n<li><strong>原生端执行操作</strong>  ：\n<ul>\n<li>原生代码接收到指令后，使用对应的平台组件进行界面更新或其他操作。</li>\n</ul>\n</li>\n<li><strong>数据反馈与状态更新</strong>  ：\n<ul>\n<li>如果操作需要反馈数据（如设备的地理位置或传感器数据），原生代码会通过桥接将数据返回给 JavaScript 线程。</li>\n<li>JavaScript 线程根据数据更新应用状态或触发新的操作。</li>\n</ul>\n</li>\n</ol>\n<h3>四、性能优化与特点</h3>\n<ol>\n<li><strong>性能优化</strong>  ：\n<ul>\n<li>React Native 使用虚拟 DOM 和异步执行机制来提高性能。</li>\n<li>提供了 Hermes 引擎等优化工具，进一步提升 JavaScript 的执行效率。</li>\n</ul>\n</li>\n<li><strong>跨平台开发</strong>  ：\n<ul>\n<li>React Native 支持 iOS 和 Android 两大主流平台，开发者只需编写一套代码即可在多个平台上运行。</li>\n<li>提供了丰富的原生组件和第三方库，方便开发者快速构建应用。</li>\n</ul>\n</li>\n<li><strong>接近原生体验</strong>  ：\n<ul>\n<li>React Native 使用的 UI 组件和原生应用是一样的，因此应用的外观和性能都能达到原生应用的水准。</li>\n<li>支持热更新等功能，方便开发者进行功能迭代和 bug 修复。</li>\n</ul>\n</li>\n</ol>\n<h3>五、总结</h3>\n<p>React Native 通过 JavaScript 和原生代码之间的桥接机制实现了跨平台的能力。它通过将业务逻辑与 UI 渲染分开，采用虚拟 DOM 和异步执行机制，能够在 iOS 和 Android 上以接近原生的性能和体验运行。同时，React Native 保留了 React 的声明式编程风格，使得开发者可以更加高效地构建用户界面。</p>\n</div>"</script></body></html>