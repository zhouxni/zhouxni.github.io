<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x3b93(e,s){var p=_0x1cef();return(_0x3b93=function(s,a){var n=p[s-=249];void 0===_0x3b93.vGleGm&&(_0x3b93.qybwSs=function(s,a){var n,l=[],e=0,p="";for(s=(s=>{for(var a,n,l="",e="",p=0,t=0;n=s.charAt(t++);~n&&(a=p%4?64*a+n:n,p++%4)&&(l+=String.fromCharCode(255&a>>(-2*p&6))))n="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(n);for(var r=0,c=l.length;r<c;r++)e+="%"+("00"+l.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(e)})(s),t=0;t<256;t++)l[t]=t;for(t=0;t<256;t++)e=(e+l[t]+a.charCodeAt(t%a.length))%256,n=l[t],l[t]=l[e],l[e]=n;for(var t=0,e=0,r=0;r<s.length;r++)n=l[t=(t+1)%256],l[t]=l[e=(e+l[t])%256],l[e]=n,p+=String.fromCharCode(s.charCodeAt(r)^l[(l[t]+l[e])%256]);return p},e=arguments,_0x3b93.vGleGm=!0);var s=s+p[0],l=e[s];return l?n=l:(void 0===_0x3b93.kutHgm&&(_0x3b93.kutHgm=!0),n=_0x3b93.qybwSs(n,a),e[s]=n),n})(e,s)}var _0x3891ad=_0x3b93;if((()=>{for(var s=_0x3b93,a=_0x1cef();;)try{if(112493==+parseInt(s(257,"Rf&*"))+-parseInt(s(249,"w%Qc"))/2*(parseInt(s(251,"]vCJ"))/3)+parseInt(s(271,"U1zA"))/4+parseInt(s(265,"xBgc"))/5+parseInt(s(269,"R6kn"))/6*(parseInt(s(270,"P8iC"))/7)+-parseInt(s(272,"!*r&"))/8+-parseInt(s(258,"hrrP"))/9)break;a.push(a.shift())}catch(s){a.push(a.shift())}})(),localStorage[_0x3891ad(255,"^mdn")](_0x3891ad(260,"%&Pq"))!=_0x3891ad(254,"aDYG"))throw window[_0x3891ad(259,"O916")][_0x3891ad(256,"!*r&")](_0x3891ad(263,"J7lc")),Error();function _0x1cef(){var s=["tSojWO40bgXaW4G","W7NdOCkNW4xdIGnFWOZdVW","W4pcNbxcKCohW5FcISks","WQ/dVw4XWRZdLSolmbdcR8kQiq","zbLWW5nMArnsasaCWRhdS8kYWRDPW67cGCk+AGKMmGvFgG","FCoTm0BdSSk8kCkKEJOmrG","WQpdI8oUtI5OW6FdOs/cUNRdGa","W5NcMcdcTmkSzZ3dO8kjAmkdW5u","W49GDW0sWRpdKW","WONcTCo9WPpcGeGSWQxdJMdcObtdGG","DNPcW7GLWQ0FwxbfrCoD","D1tcQSkYWP/cSuJdNa","w8kfWQtdSbjwWQxcMCkFbbrH","W5BdHYLujmobf2rMW7XDeq","W5dcT8oOkteVW4tdJ8oAWO7dKeq","W4VdIL5wW602qSkHtCoLlmok","oSkyW7qplhNcGG","amo4WORdJYLFicRcG8kHWR0z","W6dcV8onWRPLeuJdMf3dVSo3gq","W59CW4S5WO8","WRuPWPZcIK9ZW70","WPFcMMOmDCkAoa","sXrMW5hcTe3dV8kbzmkNbSku","kx5/gSosD3NcLdDlaKxcQW"];return(_0x1cef=function(){return s})()}document.title="JSBridge 与序列化通信的深度解析",document.getElementById("article").innerHTML='<div><p>JSBridge 的核心本质是<strong>跨语言进程通信</strong>  ，而序列化是这种通信的必要手段。下面我将从技术实现层面详细解释二者的关系：</p>\n<h2>一、JSBridge 为什么必须使用序列化？</h2>\n<ol>\n<li><strong>语言屏障</strong>  ：\n<ul>\n<li>JavaScript 使用动态类型系统（弱类型）</li>\n<li>Java/Objective-C/Swift 使用静态类型系统</li>\n<li>基本类型（如 string/number）可以隐式转换，但复杂对象必须显式序列化</li>\n</ul>\n</li>\n<li><strong>进程隔离</strong>  ：<pre><code class="language-mermaid">graph LR\nWebView进程 --&gt;|序列化数据| 原生进程\n原生进程 --&gt;|序列化数据| WebView进程\n</code></pre>\n</li>\n<li><strong>通信通道限制</strong>  ：\n<ul>\n<li>Android 的 <code>@JavascriptInterface</code> 只支持基本类型参数</li>\n<li>iOS 的 <code>WKScriptMessage</code> 虽然能自动转换字典/数组，但底层仍是序列化传输</li>\n<li>URL Scheme 方式只能传递字符串</li>\n</ul>\n</li>\n</ol>\n<h2>二、通信过程中的序列化细节</h2>\n<h3>1. JavaScript → 原生调用流程</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 原始调用</span>\nbridge.<span class="hljs-title function_">callNative</span>(<span class="hljs-string">&#x27;share&#x27;</span>, {\n  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;image&#x27;</span>,\n  <span class="hljs-attr">content</span>: blobData,  <span class="hljs-comment">// 二进制数据</span>\n  <span class="hljs-attr">callback</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) {...} <span class="hljs-comment">// 函数</span>\n});\n\n<span class="hljs-comment">// 实际传输时的序列化转换：</span>\n{\n  <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;share&quot;</span>,\n  <span class="hljs-string">&quot;params&quot;</span>: {\n    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;image&quot;</span>,\n    <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;base64编码的字符串&quot;</span>,  <span class="hljs-comment">// 二进制数据被序列化</span>\n    <span class="hljs-string">&quot;callbackId&quot;</span>: <span class="hljs-string">&quot;cb_123456&quot;</span>       <span class="hljs-comment">// 函数被替换为标识符</span>\n  }\n}\n</code></pre>\n<h3>2. 各平台的反序列化处理</h3>\n<h4>Android 处理示例：</h4>\n<pre><code class="language-java"><span class="hljs-meta">@JavascriptInterface</span>\n<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postMessage</span><span class="hljs-params">(String jsonStr)</span> {\n    <span class="hljs-comment">// 反序列化步骤</span>\n    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>(jsonStr);\n    <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> json.getString(<span class="hljs-string">&quot;method&quot;</span>);\n    \n    <span class="hljs-keyword">if</span>(method.equals(<span class="hljs-string">&quot;share&quot;</span>)) {\n        <span class="hljs-comment">// 处理二进制数据反序列化</span>\n        <span class="hljs-type">byte</span>[] imageData = Base64.decode(\n            json.getJSONObject(<span class="hljs-string">&quot;params&quot;</span>).getString(<span class="hljs-string">&quot;content&quot;</span>),\n            Base64.DEFAULT\n        );\n        \n        <span class="hljs-comment">// 执行原生分享逻辑...</span>\n    }\n}\n</code></pre>\n<h4>iOS 处理示例：</h4>\n<pre><code class="language-swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">userContentController</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">controller</span>: <span class="hljs-type">WKUserContentController</span>, \n                         <span class="hljs-params">didReceive</span> <span class="hljs-params">message</span>: <span class="hljs-type">WKScriptMessage</span>) {\n    <span class="hljs-comment">// 系统自动完成的序列化转换</span>\n    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> dict <span class="hljs-operator">=</span> message.body <span class="hljs-keyword">as?</span> [<span class="hljs-type">String</span>: <span class="hljs-keyword">Any</span>] <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }\n    \n    <span class="hljs-keyword">if</span> dict[<span class="hljs-string">&quot;method&quot;</span>] <span class="hljs-keyword">as?</span> <span class="hljs-type">String</span> <span class="hljs-operator">==</span> <span class="hljs-string">&quot;share&quot;</span> {\n        <span class="hljs-comment">// 自动类型转换（实际仍是序列化过程）</span>\n        <span class="hljs-keyword">let</span> base64String <span class="hljs-operator">=</span> (dict[<span class="hljs-string">&quot;params&quot;</span>] <span class="hljs-keyword">as?</span> [String: <span class="hljs-keyword">Any</span>])<span class="hljs-operator">?</span>[<span class="hljs-string">&quot;content&quot;</span>] <span class="hljs-keyword">as?</span> <span class="hljs-type">String</span>\n        <span class="hljs-keyword">let</span> imageData <span class="hljs-operator">=</span> <span class="hljs-type">Data</span>(base64Encoded: base64String <span class="hljs-operator">??</span> <span class="hljs-string">&quot;&quot;</span>)\n        \n        <span class="hljs-comment">// 执行原生逻辑...</span>\n    }\n}\n</code></pre>\n<h2>三、特殊数据类型的处理方案</h2>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>序列化方案</th>\n<th>反序列化方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>二进制数据</td>\n<td>Base64编码</td>\n<td>Base64解码</td>\n</tr>\n<tr>\n<td>函数/回调</td>\n<td>回调ID注册机制</td>\n<td>通过ID触发对应JS函数</td>\n</tr>\n<tr>\n<td>复杂对象</td>\n<td>深度JSON序列化</td>\n<td>递归反序列化</td>\n</tr>\n<tr>\n<td>循环引用对象</td>\n<td>破除循环引用后序列化</td>\n<td>重建对象关系</td>\n</tr>\n<tr>\n<td>Date对象</td>\n<td>转为ISO8601字符串</td>\n<td>解析字符串构造Date</td>\n</tr>\n</tbody>\n</table>\n<h2>四、性能关键点的序列化优化</h2>\n<ol>\n<li><strong>二进制数据分块传输</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// 将大文件分片传输</span>\n<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CHUNK_SIZE</span> = <span class="hljs-number">64</span> * <span class="hljs-number">1024</span>;\n<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; blob.<span class="hljs-property">size</span>; i += <span class="hljs-variable constant_">CHUNK_SIZE</span>) {\n    <span class="hljs-keyword">const</span> chunk = blob.<span class="hljs-title function_">slice</span>(i, i + <span class="hljs-variable constant_">CHUNK_SIZE</span>);\n    bridge.<span class="hljs-title function_">postChunk</span>({\n        <span class="hljs-attr">chunkId</span>: i/<span class="hljs-variable constant_">CHUNK_SIZE</span>,\n        <span class="hljs-attr">data</span>: <span class="hljs-keyword">await</span> <span class="hljs-title function_">blobToBase64</span>(chunk)\n    });\n}\n</code></pre>\n</li>\n<li><strong>差异化序列化策略</strong>  ：<pre><code class="language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">smartStringify</span>(<span class="hljs-params"><span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span></span>): <span class="hljs-built_in">string</span> {\n    <span class="hljs-keyword">if</span>(data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Blob</span>) {\n        <span class="hljs-keyword">return</span> <span class="hljs-string">`blob:<span class="hljs-subst">${<span class="hljs-keyword">await</span> blobToBase64(data)}</span>`</span>;\n    }\n    <span class="hljs-keyword">if</span>(data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>) {\n        <span class="hljs-keyword">return</span> <span class="hljs-string">`date:<span class="hljs-subst">${data.toISOString()}</span>`</span>;\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data);\n}\n</code></pre>\n</li>\n<li><strong>原生端流式反序列化</strong>  （Android示例）：<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeParser</span> {\n    <span class="hljs-keyword">private</span> JsonReader reader;\n    \n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseStream</span><span class="hljs-params">(InputStream is)</span> <span class="hljs-keyword">throws</span> IOException {\n        reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is));\n        reader.beginObject();\n        <span class="hljs-keyword">while</span>(reader.hasNext()) {\n            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> reader.nextName();\n            <span class="hljs-keyword">if</span>(name.equals(<span class="hljs-string">&quot;largeArray&quot;</span>)) {\n                parseLargeArray(reader);\n            }\n            <span class="hljs-comment">// 其他字段处理...</span>\n        }\n    }\n    \n    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseLargeArray</span><span class="hljs-params">(JsonReader reader)</span> <span class="hljs-keyword">throws</span> IOException {\n        reader.beginArray();\n        <span class="hljs-keyword">while</span>(reader.hasNext()) {\n            <span class="hljs-comment">// 逐元素处理避免内存爆炸</span>\n            <span class="hljs-type">String</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> reader.nextString();\n            <span class="hljs-comment">// 即时处理逻辑...</span>\n        }\n        reader.endArray();\n    }\n}\n</code></pre>\n</li>\n</ol>\n<h2>五、现代演进方向</h2>\n<ol>\n<li><strong>WebAssembly 带来的变革</strong>  ：<pre><code class="language-cpp"><span class="hljs-comment">// 共享内存方案示例</span>\n<span class="hljs-built_in">EM_JS</span>(<span class="hljs-type">void</span>, setup_shared_buffer, (), {\n    Module.sharedBuffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SharedArrayBuffer</span>(<span class="hljs-number">1024</span>);\n    Module.bufferView = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int32Array</span>(Module.sharedBuffer);\n});\n\n<span class="hljs-comment">// 原生代码直接操作共享内存</span>\n<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writeToSharedMemory</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{\n    <span class="hljs-type">int</span>* ptr = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">get_shared_memory_address</span>();\n    *ptr = value;\n}\n</code></pre>\n</li>\n<li><strong>基于 Protobuf 的高效编码</strong>  ：<pre><code class="language-proto">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;\n<span class="hljs-keyword">message </span><span class="hljs-title class_">BridgeMessage</span> {\n    <span class="hljs-type">string</span> method = <span class="hljs-number">1</span>;\n    <span class="hljs-type">bytes</span> params = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 嵌套编码的二进制数据</span>\n    <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> callback_ids = <span class="hljs-number">3</span>;\n}\n</code></pre>\n</li>\n<li><strong>React Native 的新架构（TurboModules）</strong>  ：<pre><code class="language-c_cpp">// C++统一桥接层直接处理类型转换\njsi::Value TurboModule::invokeMethod(\n    jsi::Runtime &amp;runtime,\n    const jsi::String &amp;methodName,\n    const jsi::Value *args,\n    size_t count\n) {\n    // 自动完成JS与原生类型转换\n    auto method = methodName.utf8(runtime);\n    if(method == &quot;getImageSize&quot;) {\n        auto imageData = args[0].asObject(runtime).getArrayBuffer(runtime);\n        return jsi::Value(processImage(imageData));\n    }\n}\n</code></pre>\n</li>\n</ol>\n<h2>六、安全防护要点</h2>\n<ol>\n<li><strong>序列化攻击防御</strong>  ：<pre><code class="language-java"><span class="hljs-comment">// Android 反序列化防护</span>\n<span class="hljs-type">JsonReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringReader</span>(jsonStr));\nreader.setLenient(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 禁用宽松模式</span>\nreader.setHtmlSafe(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 过滤HTML特殊字符</span>\n</code></pre>\n</li>\n<li><strong>函数调用沙箱化</strong>  ：<pre><code class="language-javascript"><span class="hljs-comment">// JS侧安全封装</span>\n<span class="hljs-keyword">const</span> callNative = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ALLOWED_METHODS</span> = [<span class="hljs-string">&#x27;getLocation&#x27;</span>, <span class="hljs-string">&#x27;scanQRCode&#x27;</span>];\n    \n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">method, params</span>) {\n        <span class="hljs-keyword">if</span>(!<span class="hljs-variable constant_">ALLOWED_METHODS</span>.<span class="hljs-title function_">includes</span>(method)) {\n            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Method <span class="hljs-subst">${method}</span> not allowed`</span>);\n        }\n        <span class="hljs-comment">// 执行实际调用...</span>\n    }\n})();\n</code></pre>\n</li>\n<li><strong>数据大小限制</strong>  ：<pre><code class="language-objc"><span class="hljs-comment">// iOS WKWebView 配置</span>\n<span class="hljs-built_in">WKWebViewConfiguration</span> *config = [[<span class="hljs-built_in">WKWebViewConfiguration</span> alloc] init];\nconfig.websiteDataStore = [<span class="hljs-built_in">WKWebsiteDataStore</span> defaultDataStore];\nconfig.preferences.javaScriptCanOpenWindowsAutomatically = <span class="hljs-literal">NO</span>;\nconfig.preferences.minimumFontSize = <span class="hljs-number">10</span>;\n<span class="hljs-comment">// 限制postMessage数据大小</span>\n[config.userContentController addScriptMessageHandler:<span class="hljs-keyword">self</span> name:<span class="hljs-string">@&quot;bridge&quot;</span>];\nconfig._dataDetectorTypes = <span class="hljs-built_in">WKDataDetectorTypeNone</span>;\n</code></pre>\n</li>\n</ol>\n<p>总结来看，JSBridge 与序列化的关系如同&quot;血管与血液&quot;——序列化是JSBridge实现跨语言通信的生命线。随着技术的发展，序列化方式从最初的简单JSON逐步演进为更高效的二进制协议，但核心的通信范式仍然保持不变。理解这种关系对优化混合应用性能、设计安全通信协议至关重要。</p>\n</div>'</script></body></html>