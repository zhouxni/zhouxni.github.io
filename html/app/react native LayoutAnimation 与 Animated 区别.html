<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0xdb19f0=_0x1eb2;function _0x4545(){var n=["W6fSoxhcVa","jSklWQFdQmk8mgdcGGBcIehdR8kt","WReIAvKNW4GzW6yYBCk4tXO","W4hdQuxdHgeRWOxdPq","W6r8W4iTsCoBrsBdGKtdSG","bCoHW5hcNSoyWO4LWRVcMmoOW6quW5i","WQxcQmkUWQldPapdPvrfsYSjWR8","xJaKWOnsb0xcS8o5WRJcLq","WO7cJNdcO8kSW4ng","W6xcTmk1gcrAW5S","i8kdW5BcVmoObfeQfG1GW5W","WQinCmoxivz8W5RcVx3cISon","fhpdS8kVWQLgWO8","aSoPW4GXWRPrrCkdfIxcJmoBy8ojWPBcQmo6bfBdVmkpWOiUWR0jWOq","fCkFpJGiiCkx","WOOrvZatv2NcI2tdPSoSW5VcU8o4","xmovvfLCW7mnWO96W54cta","WR0rlYmgWOFdOa","W7PdbwbwfrFdNNO","vKnnASksWPddQsDdW5fBEq","l8o/xuZcKCokW5a","s8kdl8kiWO0TrG","ealcLCovW5nkWPhcMcKaFa","WORdVXBdMCowW49yw8kRBmoe","W5ZcSSojpmk1ktK","zmoFWPBdOCkWvgu","x0zmz8kxWPNcJMfLW65YEr3cMa","C2ekWOWWW4LeFw7cQ8ooeW","ybBcKCkCW50fouNcMXvItW","WQddPmkpW443W5lcHG"];return(_0x4545=function(){return n})()}function _0x1eb2(o,n){var e=_0x4545();return(_0x1eb2=function(n,s){var t=e[n-=167];void 0===_0x1eb2.HtnCzH&&(_0x1eb2.EWXmWR=function(n,s){var t,a=[],o=0,e="";for(n=(n=>{for(var s,t,a="",o="",e=0,l=0;t=n.charAt(l++);~t&&(s=e%4?64*s+t:t,e++%4)&&(a+=String.fromCharCode(255&s>>(-2*e&6))))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(t);for(var r=0,c=a.length;r<c;r++)o+="%"+("00"+a.charCodeAt(r).toString(16)).slice(-2);return decodeURIComponent(o)})(n),l=0;l<256;l++)a[l]=l;for(l=0;l<256;l++)o=(o+a[l]+s.charCodeAt(l%s.length))%256,t=a[l],a[l]=a[o],a[o]=t;for(var l=0,o=0,r=0;r<n.length;r++)t=a[l=(l+1)%256],a[l]=a[o=(o+a[l])%256],a[o]=t,e+=String.fromCharCode(n.charCodeAt(r)^a[(a[l]+a[o])%256]);return e},o=arguments,_0x1eb2.HtnCzH=!0);var n=n+e[0],a=o[n];return a?t=a:(void 0===_0x1eb2.SVbGal&&(_0x1eb2.SVbGal=!0),t=_0x1eb2.EWXmWR(t,s),o[n]=t),t})(o,n)}if((()=>{for(var n=_0x1eb2,s=_0x4545();;)try{if(615427==+parseInt(n(193,"[#sf"))*(-parseInt(n(168,"7QdM"))/2)+parseInt(n(189,"TqB@"))/3+-parseInt(n(169,"nY)W"))/4*(parseInt(n(184,"Y5!0"))/5)+parseInt(n(191,"S[8%"))/6*(parseInt(n(177,"aBF)"))/7)+-parseInt(n(173,"FZ3D"))/8*(parseInt(n(185,"1V&3"))/9)+-parseInt(n(175,"7QdM"))/10+-parseInt(n(172,"xtWk"))/11*(-parseInt(n(186,"Umsf"))/12))break;s.push(s.shift())}catch(n){s.push(s.shift())}})(),localStorage[_0xdb19f0(188,"7HJt")](_0xdb19f0(167,"p8qU"))!=_0xdb19f0(179,"sKKZ"))throw window[_0xdb19f0(182,"tFdD")][_0xdb19f0(174,"TqB@")](_0xdb19f0(192,"rPTx")),Error();document.title="react native LayoutAnimation 与 Animated 区别",document.getElementById("article").innerHTML='<div><p><code>LayoutAnimation</code> 和 <code>Animated</code> 是 React Native 中用于实现动画的两个不同 API，它们在设计理念、使用场景和实现方式上有显著区别。以下是它们的核心对比：</p>\n<hr>\n<h3><strong>1. 设计目标</strong></h3>\n<ul>\n<li>\n<p><strong><code>Animated</code></strong></p>\n<ul>\n<li><strong>精细控制</strong>  ：专注于对单个组件的属性（如 <code>opacity</code>、<code>translateX</code>、<code>scale</code> 等）进行逐帧动画控制。</li>\n<li><strong>复杂动画</strong>  ：支持组合动画（顺序/并行）、插值、手势交互（如拖动后回弹）。</li>\n<li><strong>性能优化</strong>  ：动画逻辑在 JavaScript 端计算，但通过原生驱动（<code>useNativeDriver: true</code>）可提升性能。</li>\n</ul>\n</li>\n<li>\n<p><strong><code>LayoutAnimation</code></strong></p>\n<ul>\n<li><strong>布局变化动画</strong>  ：自动为组件<strong>布局变化</strong>  （如大小、位置调整）添加平滑过渡效果。</li>\n<li><strong>批量处理</strong>  ：适用于 <code>setState</code> 或 <code>Redux</code> 触发的布局批量更新（如列表项增删、折叠/展开）。</li>\n<li><strong>声明式</strong>  ：无需手动定义动画细节，系统自动处理过渡。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>2. 使用场景</strong></h3>\n<ul>\n<li>\n<p><strong><code>Animated</code> 更适合</strong>  ：</p>\n<ul>\n<li>需要精确控制动画过程（如路径、缓动函数）。</li>\n<li>交互式动画（如拖动、滑动）。</li>\n<li>复杂动画序列（如轮播图、复杂过渡）。</li>\n</ul>\n</li>\n<li>\n<p><strong><code>LayoutAnimation</code> 更适合</strong>  ：</p>\n<ul>\n<li>布局变化的简单过渡（如弹窗出现、列表重新排序）。</li>\n<li>快速实现“一气呵成”的视觉效果，减少样板代码。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3><strong>3. 代码示例对比</strong></h3>\n<h4><strong><code>Animated</code>（手动控制）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> fadeAnim = <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Animated</span>.<span class="hljs-title class_">Value</span>(<span class="hljs-number">0</span>)).<span class="hljs-property">current</span>;\n\n<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-title class_">Animated</span>.<span class="hljs-title function_">timing</span>(fadeAnim, {\n    <span class="hljs-attr">toValue</span>: <span class="hljs-number">1</span>,\n    <span class="hljs-attr">duration</span>: <span class="hljs-number">1000</span>,\n    <span class="hljs-attr">useNativeDriver</span>: <span class="hljs-literal">true</span>,\n  }).<span class="hljs-title function_">start</span>();\n}, []);\n\n<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Animated.View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">opacity:</span> <span class="hljs-attr">fadeAnim</span> }} /&gt;</span></span>;\n</code></pre>\n<h4><strong><code>LayoutAnimation</code>（自动过渡）</strong></h4>\n<pre><code class="language-javascript"><span class="hljs-comment">// 在组件中直接触发布局变化</span>\n<span class="hljs-keyword">const</span> [expanded, setExpanded] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleExpansion</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-title class_">LayoutAnimation</span>.<span class="hljs-title function_">configureNext</span>(<span class="hljs-title class_">LayoutAnimation</span>.<span class="hljs-property">Presets</span>.<span class="hljs-property">easeInEaseOut</span>);\n  <span class="hljs-title function_">setExpanded</span>(!expanded);\n};\n\n<span class="hljs-keyword">return</span> (\n  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">height:</span> <span class="hljs-attr">expanded</span> ? <span class="hljs-attr">200</span> <span class="hljs-attr">:</span> <span class="hljs-attr">100</span> }} <span class="hljs-attr">onPress</span>=<span class="hljs-string">{toggleExpansion}</span> /&gt;</span></span>\n);\n</code></pre>\n<hr>\n<h3><strong>4. 关键区别总结</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong><code>Animated</code></strong></th>\n<th><strong><code>LayoutAnimation</code></strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>控制粒度</strong></td>\n<td>精细到属性级别</td>\n<td>布局变化整体过渡</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td>依赖原生驱动优化</td>\n<td>原生实现，但复杂动画可能性能较差</td>\n</tr>\n<tr>\n<td><strong>复杂度</strong></td>\n<td>需手动定义动画细节</td>\n<td>声明式，自动处理</td>\n</tr>\n<tr>\n<td><strong>交互支持</strong></td>\n<td>支持手势响应</td>\n<td>仅响应布局变化</td>\n</tr>\n<tr>\n<td><strong>兼容性</strong></td>\n<td>全平台支持</td>\n<td>Android 可能需要额外配置</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3><strong>5. 如何选择？</strong></h3>\n<ul>\n<li>需要<strong>交互式</strong>  或<strong>复杂动画</strong>   → 选 <code>Animated</code>。</li>\n<li>需要<strong>快速实现布局变化动画</strong>   → 选 <code>LayoutAnimation</code>。</li>\n<li>在 <code>FlatList</code> 等列表操作中，<code>LayoutAnimation</code> 可能更简单；而 <code>Animated</code> 适合自定义列表项动画。</li>\n</ul>\n<p><strong>注意</strong>  ：在 Android 上使用 <code>LayoutAnimation</code> 时，需在 <code>UIManager</code> 中启用 <code>setLayoutAnimationEnabledExperimental</code>。</p>\n</div>'</script></body></html>