<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>var _0x126608=_0x4688;function _0x4688(t,s){var p=_0x12e7();return(_0x4688=function(s,n){var a=p[s-=441];void 0===_0x4688.tqQNGk&&(_0x4688.owJUEl=function(s,n){var a,l=[],t=0,p="";for(s=(s=>{for(var n,a,l="",t="",p=0,e=0;a=s.charAt(e++);~a&&(n=p%4?64*n+a:a,p++%4)&&(l+=String.fromCharCode(255&n>>(-2*p&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var c=0,r=l.length;c<r;c++)t+="%"+("00"+l.charCodeAt(c).toString(16)).slice(-2);return decodeURIComponent(t)})(s),e=0;e<256;e++)l[e]=e;for(e=0;e<256;e++)t=(t+l[e]+n.charCodeAt(e%n.length))%256,a=l[e],l[e]=l[t],l[t]=a;for(var e=0,t=0,c=0;c<s.length;c++)a=l[e=(e+1)%256],l[e]=l[t=(t+l[e])%256],l[t]=a,p+=String.fromCharCode(s.charCodeAt(c)^l[(l[e]+l[t])%256]);return p},t=arguments,_0x4688.tqQNGk=!0);var s=s+p[0],l=t[s];return l?a=l:(void 0===_0x4688.WaxGMw&&(_0x4688.WaxGMw=!0),a=_0x4688.owJUEl(a,n),t[s]=a),a})(t,s)}function _0x12e7(){var s=["WRtdHeNdR8oudtP2BmodW5lcUWS","WPKVWQKhfSkIlSoaWOz9WOK","eCoxc8oJWRnkWOTR","WRldG8oRW7z5WQnv","zSogymoJW5xcIImwAG","sSoZee3dLSojWRNdI8ocWRBcISkEW5q","WQmmW7pdUCkBW5Kfqvy","W4pdOmoGWQOdW6NdO8ogEmoVCWS","pSk7De/dLCkNWQ3cOKa","WQtcLsFcTeOXWQHVfq","CmklDSk7o8kpk37dQG","W6ldTtFcIfG","WPGOWRRcNCkqamoLy8k3W7RdIvFcGG","c8kiW6KJWQlcQSon","W6ruEatcNr1CkCoWr8kEwCkR","WQdcKIFdVrLnWQvQj8oAcci","W5VdOSoogCo1W6ddKLL/WQ5Tcmkw","CCkgCSoAymoCB0RdO8o7fgtdQW","vwFcHmkdcW0AfGFdOLK","WOhdS8owa8k1WPpcUmkpWR02WQe","W4ZdH8kZwI3cJ8oQlaFcSmopfa","oCk4CYFcI8oWWPVcN2zIW6/dTa","fComhmoYWRqzW4SQW5VdLNNdH0WRW5uKW4xdLqddKYhcOSkYrgam","W4ZcQw92W77dOufVW7NcHha"];return(_0x12e7=function(){return s})()}if((()=>{for(var s=_0x4688,n=_0x12e7();;)try{if(530179==-parseInt(s(454,"*HE3"))+parseInt(s(458,"]Qp5"))/2+-parseInt(s(443,"oGL7"))/3*(parseInt(s(457,"tVqE"))/4)+parseInt(s(451,"ux]x"))/5+parseInt(s(452,"20RE"))/6*(parseInt(s(442,"FSVF"))/7)+-parseInt(s(455,"FSVF"))/8+-parseInt(s(463,"ZnmR"))/9)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x126608(447,"&gRb")](_0x126608(464,"y8tM"))!=_0x126608(445,"ntG5"))throw window[_0x126608(460,"B&gW")][_0x126608(461,"SyWa")](_0x126608(456,"B&gW")),Error();document.title="React Native 新架构深度解析：JSI 与 Fabric",document.getElementById("article").innerHTML='<div><h2>一、JSI (JavaScript Interface) 详解</h2>\n<h3>1. JSI 核心设计理念</h3>\n<p>JSI 是 React Native 新架构的核心基础，它彻底重构了 JavaScript 与原生代码的通信方式：</p>\n<ul>\n<li><strong>去桥接化</strong>  ：取代传统的异步桥接通信</li>\n<li><strong>直接内存访问</strong>  ：JavaScript 可以直接持有和操作原生对象引用</li>\n<li><strong>无序列化</strong>  ：避免了 JSON 序列化的性能开销</li>\n<li><strong>同步能力</strong>  ：支持同步方法调用</li>\n</ul>\n<h3>2. JSI 工作原理</h3>\n<pre><code class="language-cpp"><span class="hljs-comment">// C++ 层示例：创建一个 JSI 函数绑定</span>\n<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">installMyModule</span><span class="hljs-params">(jsi::Runtime &amp;runtime)</span> </span>{\n  <span class="hljs-keyword">auto</span> function = jsi::Function::<span class="hljs-built_in">createFromHostFunction</span>(\n    runtime,\n    jsi::PropNameID::forAscii(runtime, <span class="hljs-string">&quot;nativeFunction&quot;</span>),\n    <span class="hljs-number">2</span>, <span class="hljs-comment">// 参数个数</span>\n    [](jsi::Runtime &amp;runtime, <span class="hljs-type">const</span> jsi::Value &amp;thisVal, <span class="hljs-type">const</span> jsi::Value *args, <span class="hljs-type">size_t</span> count) -&gt; jsi::Value {\n      <span class="hljs-comment">// 直接处理参数</span>\n      <span class="hljs-type">double</span> arg1 = args[<span class="hljs-number">0</span>].<span class="hljs-built_in">asNumber</span>();\n      std::string arg2 = args[<span class="hljs-number">1</span>].<span class="hljs-built_in">asString</span>(runtime).<span class="hljs-built_in">utf8</span>(runtime);\n      \n      <span class="hljs-comment">// 返回结果</span>\n      <span class="hljs-keyword">return</span> jsi::<span class="hljs-built_in">Value</span>(runtime, arg1 + arg<span class="hljs-number">2.l</span>ength());\n    }\n  );\n  \n  runtime.<span class="hljs-built_in">global</span>().<span class="hljs-built_in">setProperty</span>(runtime, <span class="hljs-string">&quot;nativeFunction&quot;</span>, function);\n}\n</code></pre>\n<h3>3. JSI 关键优势</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>旧桥接架构</th>\n<th>JSI 架构</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>通信方式</td>\n<td>异步消息队列</td>\n<td>直接方法调用</td>\n</tr>\n<tr>\n<td>数据传递</td>\n<td>JSON 序列化</td>\n<td>内存共享</td>\n</tr>\n<tr>\n<td>调用延迟</td>\n<td>高(5-10ms)</td>\n<td>低(&lt;1ms)</td>\n</tr>\n<tr>\n<td>线程模型</td>\n<td>强制异步</td>\n<td>支持同步</td>\n</tr>\n<tr>\n<td>内存占用</td>\n<td>高</td>\n<td>低</td>\n</tr>\n</tbody>\n</table>\n<h3>4. TurboModules 实现</h3>\n<p>基于 JSI 的新模块系统：</p>\n<pre><code class="language-typescript"><span class="hljs-comment">// TypeScript 接口定义</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TurboModule</span> {\n  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">getConstants</span>?: <span class="hljs-function">() =&gt;</span> {};\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SampleTurboModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TurboModule</span> {\n  <span class="hljs-title function_">voidFunc</span>(): <span class="hljs-built_in">void</span>;\n  <span class="hljs-title function_">getString</span>(<span class="hljs-attr">arg</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;\n  <span class="hljs-title function_">getNumber</span>(<span class="hljs-attr">arg</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;\n}\n\n<span class="hljs-comment">// 原生模块注册</span>\n<span class="hljs-title class_">TurboModuleRegistry</span>.<span class="hljs-property">getEnforcing</span>&lt;<span class="hljs-title class_">SampleTurboModule</span>&gt;(<span class="hljs-string">&#x27;SampleTurboModule&#x27;</span>);\n</code></pre>\n<h2>二、Fabric 渲染系统解析</h2>\n<h3>1. Fabric 架构革新</h3>\n<p>Fabric 是 React Native 的新渲染系统，主要改进包括：</p>\n<ul>\n<li><strong>同步渲染</strong>  ：UI 更新不再需要跨桥通信</li>\n<li><strong>线程模型优化</strong>  ：<pre><code class="language-mermaid">graph TD\n  JS[JS Thread] --&gt;|序列化指令| Bridge\n  Bridge --&gt;|反序列化| UI[UI Thread]\n  \n  NewJS[JS Thread] --&gt;|直接操作| NewUI[UI Thread]\n  NewJS --&gt;|并行计算| Shadow[Background Layout Thread]\n</code></pre>\n</li>\n<li><strong>视图拍平</strong>  ：减少层级嵌套带来的性能损耗</li>\n</ul>\n<h3>2. 渲染流程对比</h3>\n<p><strong>传统渲染流程</strong>  ：</p>\n<ol>\n<li>React 生成虚拟 DOM</li>\n<li>序列化为 JSON 消息</li>\n<li>通过桥接发送到原生端</li>\n<li>原生端解析并创建视图</li>\n<li>布局计算</li>\n<li>最终渲染</li>\n</ol>\n<p><strong>Fabric 渲染流程</strong>  ：</p>\n<ol>\n<li>React 生成虚拟 DOM</li>\n<li>直接调用 JSI 绑定</li>\n<li>原生视图同步创建</li>\n<li>后台线程并行计算布局</li>\n<li>主线程提交渲染</li>\n</ol>\n<h3>3. 核心 C++ 类结构</h3>\n<pre><code class="language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShadowNode</span> {\n  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">layout</span><span class="hljs-params">(LayoutContext layoutContext)</span></span>;\n  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">propsChanged</span><span class="hljs-params">(Props props)</span></span>;\n};\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">UIManager</span> {\n  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createNode</span><span class="hljs-params">(ShadowNode shadowNode)</span></span>;\n  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateNode</span><span class="hljs-params">(ShadowNode shadowNode)</span></span>;\n  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ShadowNode shadowNode)</span></span>;\n};\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">ComponentDescriptor</span> {\n  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ShadowNode <span class="hljs-title">createShadowNode</span><span class="hljs-params">()</span></span>;\n  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setProps</span><span class="hljs-params">(ShadowNode shadowNode, Props props)</span></span>;\n};\n</code></pre>\n<h3>4. 性能关键指标</h3>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>旧架构(ms)</th>\n<th>Fabric(ms)</th>\n<th>提升幅度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>列表初始渲染</td>\n<td>320</td>\n<td>210</td>\n<td>34%</td>\n</tr>\n<tr>\n<td>列表滚动 FPS</td>\n<td>48</td>\n<td>58</td>\n<td>21%</td>\n</tr>\n<tr>\n<td>复杂视图更新</td>\n<td>125</td>\n<td>68</td>\n<td>46%</td>\n</tr>\n</tbody>\n</table>\n<h2>三、新旧架构迁移实践</h2>\n<h3>1. 代码兼容方案</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// 检查是否启用新架构</span>\n<span class="hljs-keyword">const</span> isFabricEnabled = <span class="hljs-variable language_">global</span>.<span class="hljs-property">nativeFabricUIManager</span> != <span class="hljs-literal">null</span>;\n\n<span class="hljs-comment">// 组件适配方案</span>\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {\n  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> isFabricEnabled ? \n      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FabricCompatView</span> /&gt;</span></span> : \n      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LegacyView</span> /&gt;</span></span>;\n  }\n}\n</code></pre>\n<h3>2. TurboModule 迁移示例</h3>\n<p><strong>旧模块</strong>  ：</p>\n<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OldModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReactContextBaseJavaModule</span> {\n    <span class="hljs-meta">@ReactMethod</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">(String param)</span> {\n        <span class="hljs-comment">// 实现...</span>\n    }\n}\n</code></pre>\n<p><strong>TurboModule</strong>  ：</p>\n<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;react/bridging/Bridging.h&gt;</span></span>\n\n<span class="hljs-keyword">class</span> <span class="hljs-title class_">NewModule</span> : <span class="hljs-keyword">public</span> TurboModule {\n<span class="hljs-keyword">public</span>:\n  <span class="hljs-built_in">NewModule</span>(std::shared_ptr&lt;CallInvoker&gt; jsInvoker)\n      : <span class="hljs-built_in">TurboModule</span>(<span class="hljs-string">&quot;NewModule&quot;</span>, jsInvoker) {}\n  \n  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(jsi::Runtime &amp;rt, jsi::String param)</span> </span>{\n    <span class="hljs-comment">// 直接实现...</span>\n  }\n};\n</code></pre>\n<h3>3. 视图组件迁移</h3>\n<p><strong>旧视图管理器</strong>  ：</p>\n<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LegacyViewManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleViewManager</span>&lt;View&gt; {\n    <span class="hljs-meta">@ReactProp(name = &quot;color&quot;)</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColor</span><span class="hljs-params">(View view, String color)</span> {\n        <span class="hljs-comment">// 设置颜色...</span>\n    }\n}\n</code></pre>\n<p><strong>Fabric 组件</strong>  ：</p>\n<pre><code class="language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FabricViewComponentDescriptor</span> : <span class="hljs-keyword">public</span> ComponentDescriptor {\n  <span class="hljs-function">ShadowNode <span class="hljs-title">createShadowNode</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{\n    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_shared</span>&lt;FabricViewShadowNode&gt;();\n  }\n  \n  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setProps</span><span class="hljs-params">(ShadowNode shadowNode, Props props)</span> <span class="hljs-keyword">override</span> </span>{\n    <span class="hljs-keyword">auto</span> viewProps = std::<span class="hljs-built_in">static_pointer_cast</span>&lt;FabricViewProps&gt;(props);\n    <span class="hljs-comment">// 处理属性更新...</span>\n  }\n};\n</code></pre>\n<h2>四、性能优化实战</h2>\n<h3>1. JSI 性能技巧</h3>\n<pre><code class="language-cpp"><span class="hljs-comment">// 高效的数据传递</span>\n<span class="hljs-function">jsi::Value <span class="hljs-title">processData</span><span class="hljs-params">(jsi::Runtime &amp;rt, <span class="hljs-type">const</span> jsi::Value &amp;data)</span> </span>{\n  <span class="hljs-comment">// 直接访问 ArrayBuffer 避免拷贝</span>\n  <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">isObject</span>() &amp;&amp; data.<span class="hljs-built_in">asObject</span>(rt).<span class="hljs-built_in">isArrayBuffer</span>(rt)) {\n    <span class="hljs-keyword">auto</span> arrayBuffer = data.<span class="hljs-built_in">getObject</span>(rt).<span class="hljs-built_in">getArrayBuffer</span>(rt);\n    <span class="hljs-keyword">auto</span> dataPtr = arrayBuffer.<span class="hljs-built_in">data</span>(rt);\n    <span class="hljs-keyword">auto</span> size = arrayBuffer.<span class="hljs-built_in">size</span>(rt);\n    \n    <span class="hljs-comment">// 直接处理二进制数据...</span>\n  }\n}\n</code></pre>\n<h3>2. Fabric 渲染优化</h3>\n<pre><code class="language-javascript"><span class="hljs-comment">// React 组件优化</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">OptimizedList</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-comment">// 使用 React.memo 避免不必要的重新渲染</span>\n  <span class="hljs-keyword">const</span> renderItem = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-function">(<span class="hljs-params">{ item }</span>) =&gt;</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.item}</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">Text</span>&gt;</span>{item.text}<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>\n  ), []);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FlatList</span>\n      <span class="hljs-attr">data</span>=<span class="hljs-string">{data}</span>\n      <span class="hljs-attr">renderItem</span>=<span class="hljs-string">{renderItem}</span>\n      // <span class="hljs-attr">启用</span> <span class="hljs-attr">Fabric</span> <span class="hljs-attr">优化属性</span>\n      <span class="hljs-attr">unstable_disableVirtualization</span>=<span class="hljs-string">{false}</span>\n      <span class="hljs-attr">debug</span>=<span class="hljs-string">{</span>&quot;<span class="hljs-attr">fabric</span>&quot;}\n    /&gt;</span></span>\n  );\n}\n</code></pre>\n<h3>3. 内存管理策略</h3>\n<pre><code class="language-cpp"><span class="hljs-comment">// 使用智能指针管理 JSI 对象</span>\n<span class="hljs-keyword">struct</span> <span class="hljs-title class_">JsiObjectHolder</span> {\n  std::shared_ptr&lt;jsi::Object&gt; object;\n  \n  <span class="hljs-built_in">JsiObjectHolder</span>(jsi::Runtime &amp;rt, jsi::Object obj) \n    : <span class="hljs-built_in">object</span>(std::<span class="hljs-built_in">make_shared</span>&lt;jsi::Object&gt;(std::<span class="hljs-built_in">move</span>(obj))) {}\n  \n  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invalidate</span><span class="hljs-params">()</span> </span>{\n    object.<span class="hljs-built_in">reset</span>();\n  }\n};\n</code></pre>\n<h2>五、调试与问题排查</h2>\n<h3>1. 常见问题解决方案</h3>\n<table>\n<thead>\n<tr>\n<th>问题现象</th>\n<th>可能原因</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JSI 方法调用崩溃</td>\n<td>线程访问冲突</td>\n<td>确保在主线程访问 UI 相关 JSI 对象</td>\n</tr>\n<tr>\n<td>Fabric 视图不更新</td>\n<td>ShadowNode 未正确更新</td>\n<td>检查 props 比较逻辑</td>\n</tr>\n<tr>\n<td>TurboModule 未注册</td>\n<td>模块名称不匹配</td>\n<td>验证 getTurboModule() 实现</td>\n</tr>\n<tr>\n<td>内存泄漏</td>\n<td>JSI 对象未正确释放</td>\n<td>使用 jsi::Pointer 管理生命周期</td>\n</tr>\n</tbody>\n</table>\n<h3>2. 性能分析工具</h3>\n<pre><code class="language-sh"><span class="hljs-comment"># 启用 Fabric 性能日志</span>\nRCTFabricPerformanceLoggerEnabled=1 react-native run-ios\n\n<span class="hljs-comment"># Android 渲染分析</span>\nadb shell dumpsys gfxinfo com.appname\n</code></pre>\n<h2>六、未来演进方向</h2>\n<ol>\n<li><strong>并发渲染</strong>  ：基于 React 18 的并发特性</li>\n<li><strong>Web 支持</strong>  ：通过 JSI 实现统一架构</li>\n<li><strong>更细粒度更新</strong>  ：部分子树重新渲染</li>\n<li><strong>改进的开发工具</strong>  ：\n<ul>\n<li>可视化 JSI 调用跟踪</li>\n<li>Fabric 渲染树检查器</li>\n</ul>\n</li>\n</ol>\n<p>通过深入理解 JSI 和 Fabric 的设计原理，开发者可以更好地：</p>\n<ul>\n<li>优化现有应用性能</li>\n<li>设计高性能的跨平台组件</li>\n<li>为未来架构演进做好准备</li>\n<li>解决复杂的跨平台交互问题</li>\n</ul>\n<p>新架构显著提升了 React Native 的性能上限，使复杂应用和动画交互达到接近原生的体验，同时保持了 React 的开发效率优势。</p>\n</div>'</script></body></html>