<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x325f(){var s=["WQagWQqABZD0hSkUW6pdKSkYWPu","W6rvE8ogjstcHmkl","kvRdNfRcVSohWPBcR8kfW6JcHWm","bH/dHCoab3NcULdcOMj7W6xcGmke","brBcICk/rYddMcG","W43cJt7cRmoIvcFcPx3cL2L6","cCkGjCoXxXFdUSocDCkQW4K6","kCkirxBcKcGJW5hcK8kKWOFdRW","WQW6ASoPWR0ko8ouW7VcN1m8","W5foWQPeEh/cNY7cTIpdNs/dJW","WQ/dTmkUWPVcOLhcNa","W6GLWPf1WOraW4K","gSo4uSkhE8kkW5JdVSkbnmospSo7","x1RcH8kdqNtcOu/cMLHCW7NcOmk8W6pdMCknaSofA0jkmmoPtZ4","W77dUCoKW6jZlwv2va","W4LzE8ociJ7cOmkaEa","WQHro8kIW59toG","WOVcJgu1WR9AWRFdRSoKWQyfnG","qmktW4O7dMNdGSkW","W67cPCoMW4FdTWVdIhVcHI3dMmkPWRLP","lujOcsxcU0G","WOzJWPhcJd/cR1hdMCkYWPrjW5pcKCot","W5yLW7SefctdKa","dmkGiSo6xXFcSmoBxCkPW64zka","WPpcG3NdQ8ohkZe","W6BdISoqtvO","kCkkqh3cLs9TWO/cNCkBWOFdS8oPWO8","WQO8ymk5W4LTlSonW6y"];return(_0x325f=function(){return s})()}function _0x2bd0(l,s){var c=_0x325f();return(_0x2bd0=function(s,n){var a=c[s-=427];void 0===_0x2bd0.WmWNQn&&(_0x2bd0.RifhpE=function(s,n){var a,t=[],l=0,c="";for(s=(s=>{for(var n,a,t="",l="",c=0,p=0;a=s.charAt(p++);~a&&(n=c%4?64*n+a:a,c++%4)&&(t+=String.fromCharCode(255&n>>(-2*c&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var e=0,o=t.length;e<o;e++)l+="%"+("00"+t.charCodeAt(e).toString(16)).slice(-2);return decodeURIComponent(l)})(s),p=0;p<256;p++)t[p]=p;for(p=0;p<256;p++)l=(l+t[p]+n.charCodeAt(p%n.length))%256,a=t[p],t[p]=t[l],t[l]=a;for(var p=0,l=0,e=0;e<s.length;e++)a=t[p=(p+1)%256],t[p]=t[l=(l+t[p])%256],t[l]=a,c+=String.fromCharCode(s.charCodeAt(e)^t[(t[p]+t[l])%256]);return c},l=arguments,_0x2bd0.WmWNQn=!0);var s=s+c[0],t=l[s];return t?a=t:(void 0===_0x2bd0.vPDpRF&&(_0x2bd0.vPDpRF=!0),a=_0x2bd0.RifhpE(a,n),l[s]=a),a})(l,s)}var _0x347cfe=_0x2bd0;if((()=>{for(var s=_0x2bd0,n=_0x325f();;)try{if(697167==-parseInt(s(443,"hMJt"))*(parseInt(s(440,"GtRI"))/2)+parseInt(s(445,"XvlV"))/3*(-parseInt(s(428,"anaY"))/4)+-parseInt(s(435,"cnpk"))/5+parseInt(s(451,"hXv*"))/6*(-parseInt(s(427,"LPmC"))/7)+parseInt(s(450,"sLyq"))/8*(parseInt(s(429,"OJoN"))/9)+-parseInt(s(454,"LPmC"))/10+parseInt(s(442,"%XN]"))/11)break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x347cfe(434,"L0i@")](_0x347cfe(438,"k!!Z"))!=_0x347cfe(448,"Y&wf"))throw window[_0x347cfe(452,"k!!Z")][_0x347cfe(433,"%XN]")](_0x347cfe(436,"LPmC")),Error();document.title="react native 布局事件对象",document.getElementById("article").innerHTML='<div><p>在 React Native 中，你可以使用 <code>onLayout</code> 事件来获取组件的布局信息。<code>onLayout</code> 事件会在组件的布局计算完成后触发，并传递一个事件对象，其中包含组件的布局信息，如尺寸和位置。</p>\n<p>以下是如何使用 <code>onLayout</code> 事件来获取布局信息的一个示例：</p>\n<hr>\n<h3>示例：获取组件的布局信息</h3>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">View</span>, <span class="hljs-title class_">Text</span>, <span class="hljs-title class_">StyleSheet</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;\n\n<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; {\n  <span class="hljs-keyword">const</span> [layout, setLayout] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);\n\n  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleLayout</span> = (<span class="hljs-params">event</span>) =&gt; {\n    <span class="hljs-keyword">const</span> { x, y, width, height } = event.<span class="hljs-property">nativeEvent</span>.<span class="hljs-property">layout</span>;\n    <span class="hljs-title function_">setLayout</span>({ x, y, width, height });\n  };\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.container}</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">View</span>\n        <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.box}</span>\n        <span class="hljs-attr">onLayout</span>=<span class="hljs-string">{handleLayout}</span> // <span class="hljs-attr">绑定</span> <span class="hljs-attr">onLayout</span> <span class="hljs-attr">事件处理函数</span>\n      &gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">Text</span>&gt;</span>Measure me!<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>\n      {layout &amp;&amp; (\n        <span class="hljs-tag">&lt;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.info}</span>&gt;</span>\n          Layout Info - x: {layout.x}, y: {layout.y}, width: {layout.width}, height: {layout.height}\n        <span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>\n      )}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>\n  );\n};\n\n<span class="hljs-keyword">const</span> styles = <span class="hljs-title class_">StyleSheet</span>.<span class="hljs-title function_">create</span>({\n  <span class="hljs-attr">container</span>: {\n    <span class="hljs-attr">flex</span>: <span class="hljs-number">1</span>,\n    <span class="hljs-attr">justifyContent</span>: <span class="hljs-string">&#x27;center&#x27;</span>,\n    <span class="hljs-attr">alignItems</span>: <span class="hljs-string">&#x27;center&#x27;</span>,\n  },\n  <span class="hljs-attr">box</span>: {\n    <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>,\n    <span class="hljs-attr">height</span>: <span class="hljs-number">100</span>,\n    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;#007BFF&#x27;</span>,\n    <span class="hljs-attr">justifyContent</span>: <span class="hljs-string">&#x27;center&#x27;</span>,\n    <span class="hljs-attr">alignItems</span>: <span class="hljs-string">&#x27;center&#x27;</span>,\n    <span class="hljs-attr">marginBottom</span>: <span class="hljs-number">20</span>,\n  },\n  <span class="hljs-attr">info</span>: {\n    <span class="hljs-attr">fontSize</span>: <span class="hljs-number">16</span>,\n  },\n});\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;\n</code></pre>\n<hr>\n<h3>代码解释</h3>\n<ol>\n<li><strong><code>onLayout</code> 事件处理函数</strong>  ：\n<ul>\n<li><code>handleLayout</code> 是一个事件处理函数，它接收一个事件对象作为参数。</li>\n<li>事件对象的 <code>nativeEvent</code> 属性包含一个 <code>layout</code> 对象，该对象具有 <code>x</code>、<code>y</code>、<code>width</code> 和 <code>height</code> 属性，分别表示组件的左上角坐标和尺寸。</li>\n</ul>\n</li>\n<li><strong>状态管理</strong>  ：\n<ul>\n<li>使用 <code>useState</code> 钩子来管理布局信息。</li>\n<li>当 <code>onLayout</code> 事件触发时，更新状态以存储布局信息。</li>\n</ul>\n</li>\n<li><strong>布局信息展示</strong>  ：\n<ul>\n<li>如果 <code>layout</code> 状态不为空，则显示布局信息。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3><code>onLayout</code> 事件对象结构</h3>\n<p><code>onLayout</code> 事件对象的结构如下：</p>\n<pre><code class="language-javascript">{\n  <span class="hljs-attr">nativeEvent</span>: {\n    <span class="hljs-attr">layout</span>: {\n      <span class="hljs-attr">x</span>: number,       <span class="hljs-comment">// 组件左上角的 x 坐标（相对于父组件）</span>\n      <span class="hljs-attr">y</span>: number,       <span class="hljs-comment">// 组件左上角的 y 坐标（相对于父组件）</span>\n      <span class="hljs-attr">width</span>: number,   <span class="hljs-comment">// 组件的宽度</span>\n      <span class="hljs-attr">height</span>: number   <span class="hljs-comment">// 组件的高度</span>\n    }\n  }\n}\n</code></pre>\n<hr>\n<h3>使用场景</h3>\n<ul>\n<li><strong>动态布局调整</strong>  ：根据组件的实际尺寸和位置来动态调整其他组件的布局或样式。</li>\n<li><strong>动画和过渡</strong>  ：在动画或过渡效果中，使用布局信息来确定组件的初始或最终状态。</li>\n<li><strong>碰撞检测</strong>  ：在需要检测组件之间是否重叠或碰撞的场景中，使用布局信息来计算组件的位置和尺寸。</li>\n</ul>\n<hr>\n<h3>注意事项</h3>\n<ul>\n<li><strong>性能考虑</strong>  ：<code>onLayout</code> 事件可能会在组件的每次渲染后触发，因此在性能敏感的场景中，应谨慎使用，避免不必要的重新渲染。</li>\n<li><strong>异步性</strong>  ：布局计算是异步的，因此 <code>onLayout</code> 事件可能会在组件渲染后的某个时间点触发。</li>\n<li><strong>平台差异</strong>  ：虽然 <code>onLayout</code> 在 iOS 和 Android 上的行为基本一致，但在某些复杂布局或特定平台上，可能会遇到细微的差异。</li>\n</ul>\n<p>通过 <code>onLayout</code> 事件，你可以轻松地获取 React Native 组件的布局信息，并根据这些信息来实现更复杂的布局和交互效果。</p>\n</div>'</script></body></html>