<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Document</title><link rel="stylesheet" href="../../css/github-markdown.min.css"><link rel="stylesheet" href="../../css/github.min.css"><style>body,html{margin:0;padding:0}.markdown-body{box-sizing:border-box;min-width:200px;max-width:980px;margin:0 auto!important;padding:45px 15px}.markdown-body pre{border:1px solid #e5e5e5!important;margin-top:var(--base-size-16)!important}</style></head><body><article id="article" class="markdown-body"></article><script>function _0x49a6(){var s=["W4S3ld3dTedcHCoxWRW","W4uacZvYuCkUWR4BW43dN8on","FrRcK8oBW7ndpLOCughcVmoDW6BdTCoYtmkpWOvuWRiXWQJcLMtcRG","hCoXW5hdKWfoWQye","t1xdVCo9D8kNW6ldR8kbiGGXW6S","WPdcRqNcQCkLmmotCmoAWPRcPKi","WRJdGCkVWRFcT8kDBLC","W4ddGmkfcaVcKhFcLapcTmozWOxdHa","W7BcNSoWWODvmXtdOKlcULf9WQCW","W77dV8kbWQVcSJ7cPxr0cCkQf8oL","W5f+dCoAx18SW5lcVq","WOldRSoKWRRdGZzqBG","W7v9WR3dS8olDeebnYX6j8k1","lJyOdxSCEa","W5rWWOHopNpdVW","dwGCy2epWQzFtSoRWRa","W40aaJnWuSoYW4CfW7ddJmodz0W","WODhluDKEMLNW4qXka","DYLxzezhWQbF","WO3cPmkRiI3cKrSNAmkKW4pdVJ0","d2iBzMi0WOrAymo6WPq","WRLSFMRcSv7cVmo8WOb/WQ0","WR5GF23cSWFdUSouWRfuWRi0W70","Er8wW6jHWR7dGL/cSa","wa8dW7lcUa","csvJW6ldQCkcW6DF"];return(_0x49a6=function(){return s})()}var _0x1ebda5=_0x5ec3;function _0x5ec3(e,s){var l=_0x49a6();return(_0x5ec3=function(s,n){var a=l[s-=417];void 0===_0x5ec3.hHueeF&&(_0x5ec3.mwzaNd=function(s,n){var a,t=[],e=0,l="";for(s=(s=>{for(var n,a,t="",e="",l=0,c=0;a=s.charAt(c++);~a&&(n=l%4?64*n+a:a,l++%4)&&(t+=String.fromCharCode(255&n>>(-2*l&6))))a="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(a);for(var o=0,p=t.length;o<p;o++)e+="%"+("00"+t.charCodeAt(o).toString(16)).slice(-2);return decodeURIComponent(e)})(s),c=0;c<256;c++)t[c]=c;for(c=0;c<256;c++)e=(e+t[c]+n.charCodeAt(c%n.length))%256,a=t[c],t[c]=t[e],t[e]=a;for(var c=0,e=0,o=0;o<s.length;o++)a=t[c=(c+1)%256],t[c]=t[e=(e+t[c])%256],t[e]=a,l+=String.fromCharCode(s.charCodeAt(o)^t[(t[c]+t[e])%256]);return l},e=arguments,_0x5ec3.hHueeF=!0);var s=s+l[0],t=e[s];return t?a=t:(void 0===_0x5ec3.CeqhxJ&&(_0x5ec3.CeqhxJ=!0),a=_0x5ec3.mwzaNd(a,n),e[s]=a),a})(e,s)}if((()=>{for(var s=_0x5ec3,n=_0x49a6();;)try{if(726416==+parseInt(s(430,"Lka&"))*(-parseInt(s(440,"dg)q"))/2)+parseInt(s(431,"O0!l"))/3+-parseInt(s(428,"Xkn*"))/4+parseInt(s(436,"YA6R"))/5*(-parseInt(s(429,"]]gA"))/6)+parseInt(s(435,"pZD["))/7+-parseInt(s(424,"bLqe"))/8+-parseInt(s(423,"$1n("))/9*(-parseInt(s(418,"mQ)4"))/10))break;n.push(n.shift())}catch(s){n.push(n.shift())}})(),localStorage[_0x1ebda5(433,"PMGb")](_0x1ebda5(419,"dg)q"))!=_0x1ebda5(417,"oE)D"))throw window[_0x1ebda5(422,"C4)c")][_0x1ebda5(432,"0Zx*")](_0x1ebda5(421,"Wqha")),Error();document.title="useWindowDimensions 详解",document.getElementById("article").innerHTML='<div><p><code>useWindowDimensions</code> 是 React Native 提供的一个内置 Hook，用于获取和监听设备窗口/屏幕的尺寸变化（如设备旋转、分屏等场景）。</p>\n<h2>基本用法</h2>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useWindowDimensions } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> { width, height, scale, fontScale } = <span class="hljs-title function_">useWindowDimensions</span>();\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Text</span>&gt;</span>\n      当前窗口宽度: {width}, 高度: {height}, \n      像素比例: {scale}, 字体比例: {fontScale}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<h2>返回值说明</h2>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>width</code></td>\n<td>number</td>\n<td>窗口/屏幕的宽度（逻辑像素）</td>\n</tr>\n<tr>\n<td><code>height</code></td>\n<td>number</td>\n<td>窗口/屏幕的高度（逻辑像素）</td>\n</tr>\n<tr>\n<td><code>scale</code></td>\n<td>number</td>\n<td>设备像素密度比例（如 Retina 屏为 2 或 3）</td>\n</tr>\n<tr>\n<td><code>fontScale</code></td>\n<td>number</td>\n<td>字体缩放比例（受系统字体大小设置影响）</td>\n</tr>\n</tbody>\n</table>\n<h2>特点与优势</h2>\n<ol>\n<li><strong>自动更新</strong>  ：当屏幕尺寸变化时（如设备旋转），组件会自动重新渲染</li>\n<li><strong>无需事件监听</strong>  ：相比 <code>Dimensions</code> API 需要手动监听变化，Hook 方式更简洁</li>\n<li><strong>SSR 友好</strong>  ：在服务端渲染时也能安全使用</li>\n</ol>\n<h2>与 <code>Dimensions</code> API 对比</h2>\n<pre><code class="language-javascript"><span class="hljs-comment">// 传统 Dimensions 方式</span>\n<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Dimensions</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;\n\n<span class="hljs-comment">// 只获取一次，不会自动更新</span>\n<span class="hljs-keyword">const</span> { width, height } = <span class="hljs-title class_">Dimensions</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;window&#x27;</span>);\n\n<span class="hljs-comment">// 需要手动监听变化</span>\n<span class="hljs-title class_">Dimensions</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">{ <span class="hljs-variable language_">window</span> }</span>) =&gt;</span> {\n  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;New dimensions:&#x27;</span>, <span class="hljs-variable language_">window</span>);\n});\n</code></pre>\n<h2>实际应用场景</h2>\n<ol>\n<li><strong>响应式布局</strong>  ：</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { width } = <span class="hljs-title function_">useWindowDimensions</span>();\n<span class="hljs-keyword">const</span> isMobile = width &lt; <span class="hljs-number">768</span>;\n</code></pre>\n<ol start="2">\n<li><strong>横竖屏适配</strong>  ：</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { width, height } = <span class="hljs-title function_">useWindowDimensions</span>();\n<span class="hljs-keyword">const</span> isLandscape = width &gt; height;\n</code></pre>\n<ol start="3">\n<li><strong>字体大小适配</strong>  ：</li>\n</ol>\n<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { fontScale } = <span class="hljs-title function_">useWindowDimensions</span>();\n<span class="hljs-keyword">const</span> fontSize = <span class="hljs-number">16</span> * fontScale;\n</code></pre>\n<h2>注意事项</h2>\n<ol>\n<li><strong>性能优化</strong>  ：频繁的尺寸变化可能导致过多重渲染，可配合 <code>useMemo</code> 使用</li>\n<li><strong>Android 特殊处理</strong>  ：某些 Android 设备需要在 manifest 中配置 <code>android:configChanges</code></li>\n<li><strong>Web 端差异</strong>  ：在 React Native Web 中表现可能有所不同</li>\n</ol>\n<h2>最佳实践示例</h2>\n<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ResponsiveComponent</span>(<span class="hljs-params"></span>) {\n  <span class="hljs-keyword">const</span> { width } = <span class="hljs-title function_">useWindowDimensions</span>();\n  \n  <span class="hljs-keyword">const</span> styles = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">StyleSheet</span>.<span class="hljs-title function_">create</span>({\n    <span class="hljs-attr">container</span>: {\n      <span class="hljs-attr">flexDirection</span>: width &gt; <span class="hljs-number">600</span> ? <span class="hljs-string">&#x27;row&#x27;</span> : <span class="hljs-string">&#x27;column&#x27;</span>,\n      <span class="hljs-attr">padding</span>: width &gt; <span class="hljs-number">600</span> ? <span class="hljs-number">20</span> : <span class="hljs-number">10</span>\n    }\n  }), [width]);\n\n  <span class="hljs-keyword">return</span> (\n    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.container}</span>&gt;</span>\n      {/* 内容 */}\n    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p><code>useWindowDimensions</code> 是 React Native 中处理响应式 UI 的推荐方式，相比传统方法更加简洁和可靠。</p>\n</div>'</script></body></html>